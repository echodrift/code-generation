function updateDates ( uint8 _tierId , uint256 _start , uint256 _end ) public onlyOwner ( ) { if ( _start != 0 && _start < _end && _tierId < tiers . length ) { Tier storage tier = tiers [ _tierId ] ; tier . startDate = _start ; tier . endDate = _end ; } }
function isProviderFor ( uint ein , address provider ) public view returns ( bool ) { return identityDirectory [ ein ] . providers . contains ( provider ) ; }
function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( 0 , this , mintedAmount ) ; Transfer ( this , target , mintedAmount ) ; }
function disableInterface ( string _interface ) public onlyOwner { setInterfaceImplementation ( _interface , 0x0 ) ; }
function buyItem ( uint256 _classId ) public { require ( now > presaleStart , "The presale is not started yet" ) ; ItemClass storage class = classIdToClass [ _classId ] ; require ( class . active == true , "This item is not for sale" ) ; require ( class . amount > 0 ) ; require ( class . total < class . amount , "Sold out" ) ; require ( class . statsMin . length == class . statsMax . length ) ; if ( class . price > 0 ) { require ( MANAContract != address ( 0 ) , "Invalid contract address for MANA. Please use the setDatabase() function first." ) ; require ( MANAContract . transferFrom ( msg . sender , address ( this ) , class . price ) == true , "Failed transfering MANA" ) ; } _mintItem ( _classId , msg . sender ) ; }
function projectReimbursement ( ) public payable isAdmin isAwaitingOrCompleted { reimbursementTotal = reimbursementTotal . add ( msg . value ) ; emit ProjectReimbursed ( msg . value ) ; }
function setInfo ( string _zitetag , string _info ) onlyAuthBy0Admin external returns ( bool success ) { bytes32 hash = keccak256 ( abi . encodePacked ( 'zitetag.' , _zitetag ) ) ; zer0netDb . setString ( hash , _info ) ; emit ZitetagUpdate ( hash , _zitetag , _info ) ; return true ; }
function approveAll ( address _to ) public whenNotPaused { require ( _to != msg . sender ) ; require ( _to != address ( 0 ) ) ; operatorApprovals [ msg . sender ] [ _to ] = true ; ApprovalForAll ( msg . sender , _to , true ) ; }
function notate ( address _sender , uint256 _value , uint256 _blockNumber , uint256 [ ] _amounts ) public returns ( bool earlySuccess ) { }
function burnFromWithData ( address _from , uint256 _value , bytes _data ) public onlyModule ( BURN_KEY ) { require ( _value <= allowed [ _from ] [ msg . sender ] , "Value too high" ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; require ( _burn ( _from , _value , _data ) , "Burn invalid" ) ; }
function addPayerRefundAddressAction ( bytes32 _requestId , bytes _payerRefundAddress ) external whenNotPaused onlyRequestPayer ( _requestId ) { uint8 payeesCount = requestCore . getSubPayeesCount ( _requestId ) . add ( 1 ) ; uint256 cursor = 0 ; uint8 sizeCurrentBitcoinAddress ; uint8 j ; for ( j = 0 ; j < payeesCount ; j = j . add ( 1 ) ) { require ( bytes ( payerRefundAddress [ _requestId ] [ cursor ] ) . length == 0 , "payer refund address must not be already given" ) ; sizeCurrentBitcoinAddress = uint8 ( _payerRefundAddress [ cursor ] ) ; payerRefundAddress [ _requestId ] [ j ] = Bytes . extractString ( _payerRefundAddress , sizeCurrentBitcoinAddress , ++ cursor ) ; cursor += sizeCurrentBitcoinAddress ; } emit RefundAddressAdded ( _requestId ) ; }
function setUnclaimedPlotPrice ( uint256 _unclaimedPlotPrice ) external onlyCFO { unclaimedPlotPrice = _unclaimedPlotPrice ; }
function getSharesPercentForPeriod ( bytes32 _userKey , uint _date ) public view returns ( uint ) { uint _periodIdx = periodDate2periodIdx [ _date ] ; if ( _date != 0 && _periodIdx == 0 ) { return 0 ; } if ( _date == 0 ) { _date = now ; _periodIdx = periodsCount ; } uint _bmcDays = _getBmcDaysAmountForUser ( _userKey , _date , _periodIdx ) ; uint _totalBmcDeposit = _getTotalBmcDaysAmount ( _date , _periodIdx ) ; return _totalBmcDeposit != 0 ? _bmcDays * PERCENT_PRECISION / _totalBmcDeposit : 0 ; }
function cancel ( ) public { orderBook [ msg . sender ] = TradeOrder ( 0 , 0 , 0 ) ; TradeOrder memory order = orderBook [ msg . sender ] ; emit TokenOfferChanged ( msg . sender , order . quantity , order . price , order . expiry ) ; }
function buyoutCost ( uint256 _deedId ) external view returns ( uint256 ) { uint256 price = identifierToBuyoutPrice [ _deedId ] ; uint256 [ ] memory claimedSurroundingPlots = _claimedSurroundingPlots ( _deedId ) ; uint256 flatDividends = claimDividend ( ) . mul ( claimedSurroundingPlots . length ) ; return price . add ( flatDividends ) ; }
function refundChannel ( bytes32 channelId ) public { require ( now >= channels [ channelId ] . expiresAt , "TOO_EARLY" ) ; require ( channels [ channelId ] . state == State . Created , "WRONG_STATE" ) ; uint amount = channels [ channelId ] . amount ; address initiator = channels [ channelId ] . initiator ; channels [ channelId ] . state = State . Refunded ; initiator . transfer ( amount ) ; emit ChannelRefunded ( channelId ) ; }
function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( _spender != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _spender ] == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function claim ( address _claimer ) onlyToken returns ( bool success ) { return false ; }
function ( ) payable { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) throw ; } else { throw ; } }
function disableSelling ( ) onlyOwner public { require ( msg . sender == owner ) ; sellingAllowed = false ; }
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) transable public returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallReceiver ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
function setToken ( address _token ) external onlyOwner { token = ERC20 ( _token ) ; }
function isSecurityToken ( address _securityToken ) public view returns ( bool ) { return ( keccak256 ( bytes ( securityTokens [ _securityToken ] . symbol ) ) != keccak256 ( "" ) ) ; }
function tokenFallback ( address _sender , uint _value , bytes ) external { if ( ! active ) { revert ( ) ; } ATxAssetProxy _token = token ; if ( msg . sender != _token . getLatestVersion ( ) ) { revert ( ) ; } uint _etherToExchange = _value . mul ( price ) / ( 10 ** uint ( _token . decimals ( ) ) ) ; if ( this . balance < _etherToExchange ) { revert ( ) ; } ATxPlatformInterface _platform = ATxPlatformInterface ( address ( _token . platform ( ) ) ) ; require ( OK == _platform . revokeAsset ( _token . smbl ( ) , _value ) ) ; uint _restEther = _takeRdFee ( _etherToExchange ) ; _sender . transfer ( _restEther ) ; TokenExchanged ( _sender , _token , _value , _restEther , _etherToExchange . sub ( _restEther ) , rdCollectorAddress , price ) ; }
function buyTokensWithPoly ( uint256 _investedPOLY ) public nonReentrant { require ( ! paused ) ; require ( fundraiseType == FundraiseType . POLY , "POLY should be the mode of investment" ) ; require ( verifyInvestment ( msg . sender , _investedPOLY ) , "Not valid Investment" ) ; _processTx ( msg . sender , _investedPOLY ) ; _forwardPoly ( msg . sender , wallet , _investedPOLY ) ; _postValidatePurchase ( msg . sender , _investedPOLY ) ; }
function claimMultipleAndWithdrawBalance ( bytes32 [ ] question_ids , uint256 [ ] lengths , bytes32 [ ] hist_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) public { }
function newProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument ) returns ( uint ) ;
function setPrice ( uint256 _productId , uint256 _price ) external onlyCLevel { _setPrice ( _productId , _price ) ; ProductPriceChanged ( _productId , _price ) ; }
function enablePurchasing ( ) onlyOwner public { require ( msg . sender == owner ) ; purchasingAllowed = true ; }
function processRequest ( bytes32 [ ] _proof , bytes5 _code , address _dest ) public onlyController { require ( ! sentToAddress [ _dest ] && ! codeUsed [ _code ] , "Funds already sent / Code already used" ) ; require ( MerkleProof . verifyProof ( _proof , root , keccak256 ( abi . encodePacked ( _code ) ) ) , "Invalid code" ) ; sentToAddress [ _dest ] = true ; codeUsed [ _code ] = true ; require ( SNT . transfer ( _dest , sntAmount ) , "Transfer did not work" ) ; _dest . transfer ( ethAmount ) ; emit AddressFunded ( _dest , _code , ethAmount , sntAmount ) ; }
function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; require ( finalizedTime == 0 ) ; require ( getBlockTimestamp ( ) >= startTime ) ; require ( msg . sender == controller || getBlockTimestamp ( ) > endTime || weiToCollect ( ) == 0 ) ; uint256 tokenCap = aix . totalSupply ( ) . mul ( 100 ) . div ( 51 ) ; aix . generateTokens ( devHolder , tokenCap . mul ( 20 ) . div ( 100 ) ) ; aix . generateTokens ( communityHolder , tokenCap . mul ( 29 ) . div ( 100 ) ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = getBlockTimestamp ( ) ; Finalized ( finalizedBlock ) ; }
function verifyTransfer ( address _from , address _to , uint256 _value , bytes _data ) public returns ( bool ) { return _verifyTransfer ( _from , _to , _value , _data , false ) ; }
function regularTransfer ( bytes32 swapId , bytes32 secret ) public { require ( sha256 ( secret ) == atomicswaps [ swapId ] . hashedSecret ) ; uint amount = atomicswaps [ swapId ] . amount ; address beneficiary = atomicswaps [ swapId ] . beneficiary ; delete atomicswaps [ swapId ] ; beneficiary . transfer ( amount ) ; }
function approve ( address spender , uint256 amount , uint256 nonce ) external returns ( bool success ) { address _trg = libAddress ; assembly { let m := mload ( 0x20 ) calldatacopy ( m , 0 , calldatasize ) let success := delegatecall ( gas , _trg , m , calldatasize , m , 0x20 ) switch success case 0 { invalid } default { return ( m , 0x20 ) } } }
function withdraw ( ) external whenWithdrawalEnabled { uint256 ethBalance = ethBalances [ msg . sender ] ; require ( ethBalance > 0 ) ; uint256 elpBalance = elpBalances [ msg . sender ] ; elpBalances [ msg . sender ] = 0 ; ethBalances [ msg . sender ] = 0 ; if ( isWhitelisted ( msg . sender ) ) { token . transfer ( msg . sender , elpBalance ) ; } else { token . transfer ( msg . sender , elpBalance . mul ( threshold ) . div ( ethBalance ) ) ; if ( ethBalance > threshold ) { msg . sender . transfer ( ethBalance - threshold ) ; } } emit Withdrawal ( msg . sender , ethBalance , elpBalance ) ; }
function finishMintingSTO ( ) public onlyOwner { finishedSTOMinting = true ; emit LogFinishMintingSTO ( now ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { success = TokenTransferController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_TRANSFER ) ) . put_transfer ( _from , _to , msg . sender , _value , true ) ; }
function euroCentsInOneEther ( ) public constant returns ( uint ) { return 58000 ; }
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { if ( ! approve ( _spender , _amount ) ) revert ( ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
function purchaseAreaWithData ( uint24 [ ] purchase , uint24 [ ] purchasedAreas , uint256 [ ] areaIndices , string ipfsHash , string url , uint256 initialBuyoutPriceInWeiPerPixel ) external payable { uint256 initialPurchasePrice = validatePurchaseAndDistributeFunds ( purchase , purchasedAreas , areaIndices ) ; uint256 newPlotIndex = addPlotAndData ( purchase , ipfsHash , url , initialBuyoutPriceInWeiPerPixel ) ; for ( uint256 i = 0 ; i < areaIndices . length ; i ++ ) { holes [ areaIndices [ i ] ] . push ( newPlotIndex ) ; } emit PlotPurchased ( newPlotIndex , initialPurchasePrice , msg . sender ) ; }
function withdrawExcessToken ( address token ) external onlyOwner { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 tokenUnits ; bool ok ; ( tokenUnits , ok ) = getTokenUnits ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( creationQuantity_ ) . mul ( tokenUnits ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }
function renounceOwnership ( ) public onlyOwner { OwnershipRenounced ( owner ) ; owner = address ( 0 ) ; }
function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes _data ) public onlyRegistry returns ( bytes4 ) { uint256 estateId = _bytesToUint ( _data ) ; _pushLandId ( estateId , _tokenId ) ; return ERC721_RECEIVED ; }
function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( _spender != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _spender ] == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function buyTokens ( address beneficiary ) public onlyFromRc validPurchase mustBeAtStage ( Stage . Running ) payable { require ( beneficiary != address ( 0 ) ) ; require ( beneficiary != address ( this ) ) ; require ( msg . value >= 1 ether ) ; uint256 weiAmount = msg . value ; uint256 tokens = getTokenAmount ( weiAmount ) ; require ( tokens > 0 ) ; require ( tokensSold . add ( tokens ) <= MAX_TOKENS ) ; tokensSold = tokensSold . add ( tokens ) ; weiRaised = weiRaised . add ( weiAmount ) ; balancesToken [ beneficiary ] = balancesToken [ beneficiary ] . add ( tokens ) ; balancesWei [ beneficiary ] = balancesWei [ beneficiary ] . add ( weiAmount ) ; TokenPurchase ( msg . sender , beneficiary , weiAmount , tokens ) ; forwardFunds ( ) ; }
function ( ) public payable { require ( isContract ( owner ) ) ; require ( TokenController ( owner ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; }
function name ( ) public view returns ( string _name ) ;
function calculateMaxEtherSpend ( Trade trade , uint256 etherBalance ) internal view returns ( uint256 ) { assert ( ! trade . isSell ) ; uint256 tokenDecimals = Utils . getDecimals ( ERC20 ( trade . tokenAddress ) ) ; uint256 srcDecimals = trade . isSell ? tokenDecimals : Utils . eth_decimals ( ) ; uint256 destDecimals = trade . isSell ? Utils . eth_decimals ( ) : tokenDecimals ; uint256 maxSpendAtMinRate = Utils . calcSrcQty ( trade . tokenAmount , srcDecimals , destDecimals , trade . minimumExchangeRate ) ; return Utils . min ( etherBalance , maxSpendAtMinRate ) ; }
function setInt ( bytes32 _key , int _value ) public onlyOwner returns ( bool success ) { intStorage [ _key ] = _value ; return true ; }
function release ( ERC20Basic token ) public { uint256 unreleased = releasableAmount ( token ) ; require ( unreleased > 0 ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . safeTransfer ( beneficiary , unreleased ) ; Released ( unreleased ) ; }
function getDeed ( uint256 identifier ) external view returns ( uint256 deedId , address owner , uint256 buyPrice , uint256 nextBuyPrice ) { deedId = identifier ; owner = identifierToOwner [ identifier ] ; buyPrice = identifierToPrice [ identifier ] ; nextBuyPrice = nextPrice ( buyPrice ) ; }
function getCollectionNamesInRange ( uint64 _startIndex , uint64 _endIndex ) public view returns ( bytes8 [ ] ) { require ( _startIndex <= totalCollections ( ) , "Start index is out of bounds" ) ; require ( _endIndex <= totalCollections ( ) , "End index is out of bounds" ) ; require ( _startIndex <= _endIndex , "End index is less than the start index" ) ; uint64 length = _endIndex - _startIndex ; bytes8 [ ] memory names = new bytes8 [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { names [ i ] = collectionNames [ _startIndex + i ] ; } return names ; }
function ( ) payable { }
function withdrawalToken ( uint256 amount ) onlyOwner public { require ( balanceOf [ this ] >= amount ) ; _transfer ( this , msg . sender , amount ) ; }
function getCurrencySymbol ( ) external view returns ( bytes32 ) { return bytes32 ( "POLY" ) ; }
function removeValidator ( address validator ) external onlyOwner whenNotPaused { require ( isValidator ( validator ) , "unable to remove, no validator located at the provided address" ) ; while ( _validatorApprovals [ validator ] . length > 0 && gasleft ( ) > 25000 ) { uint256 lastIndex = _validatorApprovals [ validator ] . length . sub ( 1 ) ; uint256 targetApproval = _validatorApprovals [ validator ] [ lastIndex ] ; delete _attributeTypes [ targetApproval ] . approvedValidators [ validator ] ; delete _validatorApprovalsIndex [ validator ] [ targetApproval ] ; _validatorApprovals [ validator ] . length -- ; } require ( _validatorApprovals [ validator ] . length == 0 , "Cannot remove validator - first remove any existing validator approvals" ) ; address lastAccount = _validatorAccounts [ _validatorAccounts . length . sub ( 1 ) ] ; _validatorAccounts [ _validators [ validator ] . index ] = lastAccount ; _validators [ lastAccount ] . index = _validators [ validator ] . index ; _validatorAccounts . length -- ; delete _signingKeys [ _validators [ validator ] . signingKey ] ; delete _validators [ validator ] ; emit ValidatorRemoved ( validator ) ; }
function play ( bool startNewGameIfIdle ) external payable { _processGameEnd ( ) ; require ( msg . value >= price ) ; if ( ! gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; gameStarted = true ; gameStarter = msg . sender ; Start ( msg . sender , block . timestamp ) ; } uint256 fee = price . mul ( feePercentage ) . div ( 100000 ) ; uint256 dividend = price . mul ( gameStarterDividendPercentage ) . div ( 100000 ) ; uint256 wagerPoolPart = price . mul ( 2 ) . div ( 7 ) ; lastPlayer = msg . sender ; lastPlayTimestamp = block . timestamp ; prizePool = prizePool . add ( price . sub ( fee ) . sub ( dividend ) . sub ( wagerPoolPart ) ) ; Play ( msg . sender , block . timestamp , block . timestamp + timeout , wagerIndex , prizePool ) ; _sendFunds ( gameStarter , dividend ) ; if ( wagerIndex > 0 && ( wagerIndex % 7 ) == 0 ) { msg . sender . transfer ( wagerPool ) ; wagerPool = 0 ; } wagerPool = wagerPool . add ( wagerPoolPart ) ; wagerIndex = wagerIndex . add ( 1 ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function setFeatureStatus ( string _nameKey , bool _newStatus ) public onlyOwner { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; require ( featureStatus [ key ] != _newStatus , "Status unchanged" ) ; emit ChangeFeatureStatus ( _nameKey , _newStatus ) ; featureStatus [ key ] = _newStatus ; }
function mintToken ( address target , uint256 mintedAmount ) onlyAuthorized public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
function cancelBuyOffer ( uint32 _canvasId ) external stateOwned ( _canvasId ) forceOwned ( _canvasId ) { BuyOffer memory offer = buyOffers [ _canvasId ] ; require ( offer . buyer == msg . sender ) ; buyOffers [ _canvasId ] = BuyOffer ( false , 0x0 , 0 ) ; if ( offer . amount > 0 ) { addPendingWithdrawal ( offer . buyer , offer . amount ) ; } emit BuyOfferCancelled ( _canvasId , offer . buyer , offer . amount ) ; }
function finalize ( ) minCapReached salePeriodCompleted isValidState onlyBy ( owner ) external { balances [ shitFundAddress ] = balances [ shitFundAddress ] . add ( shitFund ) ; assignedSupply = assignedSupply . add ( shitFund ) ; ClaimSHIT ( shitFundAddress , shitFund ) ; Transfer ( 0x0 , shitFundAddress , shitFund ) ; if ( assignedSupply < totalSupply ) { uint256 unassignedSupply = totalSupply . sub ( assignedSupply ) ; balances [ shitFundAddress ] = balances [ shitFundAddress ] . add ( unassignedSupply ) ; assignedSupply = assignedSupply . add ( unassignedSupply ) ; ClaimSHIT ( shitFundAddress , unassignedSupply ) ; Transfer ( 0x0 , shitFundAddress , unassignedSupply ) ; } ethFundAddress . transfer ( this . balance ) ; isFinalized = true ; }
function setExpirationTime ( uint256 time ) public onlyOwner returns ( bool ) { expiration = time ; return true ; }
function setPOLYUSD ( uint256 _price ) onlyOwner public { emit LogPriceUpdated ( _price , POLYUSD , 0 , now ) ; POLYUSD = _price ; latestUpdate = now ; }
function isCertified ( address student ) payable requestFeePaid returns ( bool isIndeed ) { isIndeed = studentCertifications [ student ] . certified ; }
function revoke ( ) onlyOwner public { require ( revocable ) ; require ( ! revoked ) ; _releaseTo ( beneficiary ) ; token . safeTransfer ( owner , token . balanceOf ( this ) ) ; revoked = true ; Revoked ( ) ; }
function transferPreSigned ( address _to , address _delegate , uint256 _value , uint256 _fee , uint256 _nonce , bytes _userData , bytes32 _sig_r , bytes32 _sig_s , uint8 _sig_v ) external { require ( _delegate == address ( 0 ) || _delegate == msg . sender , "_delegate should be address(0) or msg.sender" ) ; address _signer = ( _sig_v != 27 && _sig_v != 28 ) ? address ( 0 ) : ecrecover ( keccak256 ( abi . encodePacked ( address ( this ) , _to , _delegate , _value , _fee , _nonce , _userData ) ) , _sig_v , _sig_r , _sig_s ) ; require ( _signer != address ( 0 ) , "_signature is invalid." ) ; require ( _nonce > usedNonce [ _signer ] , "_nonce must be greater than the last used nonce of the token holder." ) ; usedNonce [ _signer ] = _nonce ; tokenContract . operatorSend ( _signer , _to , _value , _userData , "" ) ; if ( _fee > 0 ) { tokenContract . operatorSend ( _signer , msg . sender , _fee , _userData , "" ) ; } }
function isCreated ( bytes32 _symbol ) public view returns ( bool ) { return assets [ _symbol ] . owner != 0 ; }
function channelManagerByToken ( address token_address ) addressExists ( token_address ) constant returns ( address ) { return registry [ token_address ] ; }
function ( ) payable { acceptPayment ( ) ; }
function playerForceGameEnd ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; require ( game . status == GameStatus . PLAYER_INITIATED_END ) ; int newBalance = conflictRes . playerForceGameEnd ( game . gameType , game . betNum , game . betValue , game . balance , game . stake , game . endInitiatedTime ) ; closeGame ( game , gameId , playerAddress , ReasonEnded . END_FORCED_BY_PLAYER , newBalance ) ; payOut ( game , playerAddress ) ; }
function buy ( ) payable public { require ( ! frozenAccount [ msg . sender ] ) ; require ( msg . value > 0 ) ; buyToken ( ) ; }
function transferToSelf ( uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ selfAddress ] = balances [ selfAddress ] + _value ; Transfer ( msg . sender , selfAddress , _value , _data ) ; allowed [ selfAddress ] [ msg . sender ] = _value + allowed [ selfAddress ] [ msg . sender ] ; Approval ( selfAddress , msg . sender , allowed [ selfAddress ] [ msg . sender ] ) ; return true ; }
function setDeprecatedContract ( Data storage self , address contractAddress ) internal returns ( bool success ) { require ( contractAddress != 0x0 , "Error: cannot deprecate a null address." ) ; bytes32 id = keccak256 ( abi . encodePacked ( 'depcrecated' , contractAddress ) ) ; require ( self . Storage . setBool ( id , true ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function sponsorDAI ( uint _JobID , uint _amount ) public { require ( _JobID >= 0 ) ; require ( _amount > 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( job . status == JobStatus . inProgress ) ; if ( job . sponsors [ msg . sender ] == 0 ) { job . sponsorList . push ( msg . sender ) ; } job . sponsors [ msg . sender ] = job . sponsors [ msg . sender ] + _amount ; job . sponsoredTokens = job . sponsoredTokens + _amount ; job . paymentAvailableForWorker = job . paymentAvailableForWorker + _amount ; job . sponsorsCount = job . sponsorsCount + 1 ; emit DAISponsored ( _JobID , _amount , msg . sender ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _amount ) ; DAI . transferFrom ( msg . sender , address ( this ) , _amount ) ; }
function removePermissionManager ( address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermissionManager ( address ( 0 ) , _app , _role ) ; }
function refund ( address _darknodeID ) external onlyRefundable ( _darknodeID ) { address darknodeOwner = store . darknodeOwner ( _darknodeID ) ; uint256 amount = store . darknodeBond ( _darknodeID ) ; store . removeDarknode ( _darknodeID ) ; ren . transfer ( darknodeOwner , amount ) ; emit LogDarknodeOwnerRefunded ( darknodeOwner , amount ) ; }
function unlock ( ) public returns ( bool success ) { uint256 amount = lockedBalance [ msg . sender ] ; require ( amount > 0 ) ; require ( now >= timeRelease [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; lockedBalance [ msg . sender ] = 0 ; timeRelease [ msg . sender ] = 0 ; Transfer ( 0x0 , msg . sender , amount ) ; UnLock ( msg . sender , amount ) ; return true ; }
function getWithdrawableDates ( ) external view returns ( uint32 [ ] ) { uint32 [ ] memory dates = userToDates [ msg . sender ] ; uint256 datesLength = dates . length ; uint32 [ ] memory withdrawableDates = new uint32 [ ] ( datesLength ) ; uint256 index = 0 ; uint32 now32 = uint32 ( now ) ; for ( uint256 i = 0 ; i < datesLength ; i ++ ) { uint32 date = dates [ i ] ; if ( now32 <= date . add ( WITHDRAW_BUFFER ) ) { continue ; } if ( userDateToStatus [ msg . sender ] [ date ] != UserEntryStatus . COMPLETED ) { continue ; } withdrawableDates [ index ] = date ; index += 1 ; } return withdrawableDates ; }
function addToken ( address _tokenAddress ) public isAdmin isAwaitingOrCompleted { if ( state != PoolState . COMPLETED ) { setPoolToCompleted ( ) ; } for ( uint256 i = 0 ; i < tokenAddress . length ; ++ i ) { require ( tokenAddress [ i ] != _tokenAddress ) ; } ERC20Basic token = ERC20Basic ( _tokenAddress ) ; require ( token . balanceOf ( this ) >= 0 ) ; tokenAddress . push ( _tokenAddress ) ; emit TokenAdded ( _tokenAddress ) ; }
function cancelByAdmin ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 1 ] ; uint256 nonce = data >> 224 ; address user = userId2Address [ data & USER_MASK ] ; require ( nonce > userNonce [ user ] ) ; uint256 gasFee = inputs [ 0 ] ; require ( verify ( keccak256 ( this , gasFee , data & SIGN_MASK ) , user , uint8 ( retrieveV ( data ) ) , bytes32 ( inputs [ 2 ] ) , bytes32 ( inputs [ 3 ] ) ) ) ; address gasToken = 0 ; if ( data & PAYMENT_METHOD_MASK == PAY_BY_JOY ) { gasToken = joyToken ; } require ( balances [ gasToken ] [ user ] >= gasFee ) ; balances [ gasToken ] [ user ] = balances [ gasToken ] [ user ] . sub ( gasFee ) ; balances [ gasToken ] [ joysoWallet ] = balances [ gasToken ] [ joysoWallet ] . add ( gasFee ) ; userNonce [ user ] = nonce ; }
function getRdFee ( ) public view returns ( uint _value , uint _decimals ) { FeeData memory _fee = rdFee ; return ( _fee . feeValue , _fee . feeDecimals ) ; }
function doReserveTrade ( ERC20 src , uint amount , ERC20 dest , address destAddress , uint expectedDestAmount , KyberReserveInterface reserve , uint conversionRate , bool validate ) internal returns ( bool ) { uint callValue = 0 ; if ( src == ETH_TOKEN_ADDRESS ) { callValue = amount ; } else { src . transferFrom ( msg . sender , this , amount ) ; } require ( reserve . trade . value ( callValue ) ( src , amount , dest , this , conversionRate , validate ) ) ; if ( dest == ETH_TOKEN_ADDRESS ) { destAddress . transfer ( expectedDestAmount ) ; } else { require ( dest . transfer ( destAddress , expectedDestAmount ) ) ; } return true ; }
function approve ( address _to , uint256 _cutieId ) external whenNotPaused canBeStoredIn40Bits ( _cutieId ) { require ( _isOwner ( msg . sender , uint40 ( _cutieId ) ) ) ; _approve ( uint40 ( _cutieId ) , _to ) ; emit Approval ( msg . sender , _to , _cutieId ) ; }
function updateShares ( uint newWinnerShare , uint newHostShare , uint newBonusShare ) public onlyOwner { require ( newWinnerShare + newHostShare == 1000 ) ; WINNER_SHARE = newWinnerShare ; HOST_SHARE = newHostShare ; HONORABLE_LOSS_BONUS = newBonusShare ; }
function isOwner ( address _addr ) public constant returns ( bool ) { return m_ownerIndex [ _addr ] > 0 ; }
function enableTokenMinting ( ) public onlyOwner returns ( bool enabled ) { tokenMintingEnabled = true ; TokenMintingEnabled ( msg . sender , true ) ; return true ; }
function isValidIndex ( uint _index , uint _size ) public pure { require ( _index < _size , KEY_NOT_FOUND_ERR ) ; }
function withdrawal ( uint index , address to , uint256 amount ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender ) ; loan . lenderBalance = safeSubtract ( loan . lenderBalance , amount ) ; require ( rcn . transfer ( to , amount ) ) ; unlockTokens ( rcn , amount ) ; return true ; }
function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( WizzleGlobalToken ) { WizzleGlobalToken newToken = new WizzleGlobalToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { mimonedarecipiente spender = mimonedarecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
function getState ( ) public view returns ( State , State ) { if ( needInitialization ) { return ( State . Init , State . Init ) ; } if ( destructed ) { return ( State . Destructed , State . Destructed ) ; } if ( now < startDate ) { return ( State . Waiting , State . Waiting ) ; } State _hardcapState = ( finishedHardcap || ( tokenHardcapIssuedValue == tokenHardcapValue ) || ( now > endDate ) ) ? State . Reached : State . Sale ; State _softcapState = ( tokenSoftcapIssued == tokenSoftcap ) ? State . Reached : State . Sale ; return ( _hardcapState , _softcapState ) ; }
function removeWhitelist ( address _account ) external whenNotPaused onlyAdmin { require ( _account != address ( 0 ) ) ; if ( whitelist [ _account ] ) { whitelist [ _account ] = false ; emit WhitelistRemoved ( _account ) ; } }
function effectiveValue ( bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey ) public view rateNotStale ( sourceCurrencyKey ) rateNotStale ( destinationCurrencyKey ) returns ( uint ) { if ( sourceCurrencyKey == destinationCurrencyKey ) return sourceAmount ; return sourceAmount . multiplyDecimalRound ( exchangeRates . rateForCurrency ( sourceCurrencyKey ) ) . divideDecimalRound ( exchangeRates . rateForCurrency ( destinationCurrencyKey ) ) ; }
function ICOSplit ( ) external isAdmin oneTime { bytes memory empty ; uint i ; if ( ! isFrozen ) { require ( ( relativeDateSave - now ) >= ( relativeDateSave - 150 days ) ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 50000000000000 ) ; currentProfits = ( ( balances [ selfAddress ] - 50000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 300000000000000 , balances [ selfAddress ] ) ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { if ( msg . gas < 240000 ) { currentIteration = i ; break ; } balances [ users [ i ] ] += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; actualProfitSplit += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; if ( i == users . length - 1 ) { assetThaw ( ) ; balances [ selfAddress ] = balances [ selfAddress ] - actualProfitSplit ; hasICORun = true ; } Transfer ( selfAddress , users [ i ] , ( balances [ users [ i ] ] / amountInCirculation ) * currentProfits , empty ) ; } } }
function transfer ( address from , address to , uint256 amount ) public onlyTransferAgent returns ( bool ) { require ( to != 0x0 , "Cannot transfer tokens to the null address." ) ; require ( amount > 0 , "Cannot transfer zero tokens." ) ; Holding memory fromHolding = heldTokens [ from ] ; require ( fromHolding . quantity >= amount , "Not enough tokens to perform the transfer." ) ; require ( ! isExistingHolding ( to ) , "Cannot overwrite an existing holding, use a new wallet." ) ; heldTokens [ from ] = Holding ( fromHolding . quantity . sub ( amount ) , fromHolding . releaseDate , fromHolding . isAffiliate ) ; heldTokens [ to ] = Holding ( amount , fromHolding . releaseDate , false ) ; emit TokensTransferred ( from , to , amount ) ; return true ; }
function revokeAssetWithExternalReference ( bytes32 _symbol , uint _value , string _externalReference ) public returns ( uint _resultCode ) { TransactionContext memory txContext ; txContext . from = msg . sender ; txContext . fromHolderId = getHolderId ( txContext . from ) ; _resultCode = _revokeAsset ( _symbol , _value , txContext ) ; if ( _resultCode != OK ) { return _emitErrorCode ( _resultCode ) ; } _emitter ( ) . emitRevokeExternal ( _symbol , _value , txContext . from , _externalReference ) ; _proxyTransferEvent ( _value , _symbol , txContext ) ; return OK ; }
function mWithdraw ( uint [ ] pledgesAmounts ) { for ( uint i = 0 ; i < pledgesAmounts . length ; i ++ ) { uint64 idPledge = uint64 ( pledgesAmounts [ i ] & ( D64 - 1 ) ) ; uint amount = pledgesAmounts [ i ] / D64 ; withdraw ( idPledge , amount ) ; } }
function balanceOf ( address _owner ) public view returns ( uint ) { return ownershipTokenCount [ _owner ] ; }
function play ( uint256 _gameIndex , bool startNewGameIfIdle ) external payable { _processGameEnd ( ) ; if ( ! gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; price = nextPrice ; timeout = nextTimeout ; finalTimeout = nextFinalTimeout ; numberOfWagersToFinalTimeout = nextNumberOfWagersToFinalTimeout ; gameStarted = true ; gameStarter = msg . sender ; Start ( gameIndex , msg . sender , block . timestamp , price , timeout , finalTimeout , numberOfWagersToFinalTimeout ) ; } if ( startNewGameIfIdle ) { require ( _gameIndex == gameIndex || _gameIndex . add ( 1 ) == gameIndex ) ; } else { require ( _gameIndex == gameIndex ) ; } require ( msg . value >= price ) ; uint256 fee = price . mul ( feePercentage ) . div ( 100000 ) ; uint256 dividend = price . mul ( gameStarterDividendPercentage ) . div ( 100000 ) ; uint256 wagerPoolPart ; if ( wagerIndex % 7 == 6 ) { uint256 wagerPrize = price . mul ( 2 ) ; wagerPoolPart = wagerPrize . sub ( wagerPool ) ; msg . sender . transfer ( wagerPrize ) ; wagerPool = 0 ; } else { wagerPoolPart = price . mul ( 2 ) . div ( 7 ) ; wagerPool = wagerPool . add ( wagerPoolPart ) ; } uint256 currentTimeout = calculateTimeout ( ) ; lastPlayer = msg . sender ; lastWagerTimeoutTimestamp = block . timestamp + currentTimeout ; prizePool = prizePool . add ( price . sub ( fee ) . sub ( dividend ) . sub ( wagerPoolPart ) ) ; Play ( gameIndex , wagerIndex , msg . sender , block . timestamp , lastWagerTimeoutTimestamp , prizePool ) ; _sendFunds ( gameStarter , dividend ) ; wagerIndex ++ ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function addEmissionProvider ( address _provider , uint _block ) public returns ( uint _code ) { if ( emissionProviders [ _provider ] ) { return _emitError ( SERVICE_CONTROLLER_EMISSION_EXIST ) ; } _code = _multisig ( keccak256 ( _provider ) , _block ) ; if ( OK != _code ) { return _code ; } emissionProviders [ _provider ] = true ; uint _count = emissionProvidersCount + 1 ; index2emissionProvider [ _count ] = _provider ; emissionProvider2index [ _provider ] = _count ; emissionProvidersCount = _count ; return OK ; }
function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }
function contribute ( ) public notFinished payable { require ( msg . value <= 500 ether ) ; uint256 tokenBought = 0 ; totalRaised = totalRaised . add ( msg . value ) ; if ( state == State . PreSale ) { require ( now >= PreSaleStart ) ; tokenBought = msg . value . mul ( rates [ 0 ] ) ; if ( PreSaleDistributed <= 30000000 * ( 10 ** 18 ) ) { tokenBought = tokenBought . mul ( 12 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( PreSaleDistributed <= 50000000 * ( 10 ** 18 ) ) { tokenBought = tokenBought . mul ( 11 ) ; tokenBought = tokenBought . div ( 10 ) ; } PreSaleDistributed = PreSaleDistributed . add ( tokenBought ) ; } else if ( state == State . MainSale ) { require ( now >= MainSaleStart ) ; if ( MainSaleDistributed < mainSale1Limit ) { tokenBought = msg . value . mul ( rates [ 1 ] ) ; if ( MainSaleDistributed <= 80000000 * ( 10 ** 18 ) ) { tokenBought = tokenBought . mul ( 12 ) ; tokenBought = tokenBought . div ( 10 ) ; } } else tokenBought = msg . value . mul ( rates [ 2 ] ) ; MainSaleDistributed = MainSaleDistributed . add ( tokenBought ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; require ( totalDistributed <= hardCap ) ; require ( tokenReward . transfer ( msg . sender , tokenBought ) ) ; emit LogContributorsPayout ( msg . sender , tokenBought ) ; emit LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; checkIfFundingCompleteOrExpired ( ) ; }
function getBetInfo ( uint betId ) public view returns ( uint , GameResults , uint , bool ) { return ( bets [ betId ] . gameId , bets [ betId ] . result , bets [ betId ] . amount , bets [ betId ] . isPayoutWithdrawn ) ; }
function requireMultiple ( uint256 _amount ) internal pure { require ( _amount . div ( granularity ) . mul ( granularity ) == _amount ) ; }
function startAirdrop ( uint256 _multiplierPercent ) onlyOwner external returns ( bool ) { pause ( ) ; require ( multiplierPercent == 0 ) ; require ( _multiplierPercent > PERCENT_DIVIDER ) ; currentAirdrop = currentAirdrop . add ( 1 ) ; multiplierPercent = _multiplierPercent ; undropped = totalSupply ( ) ; assert ( multiplierPercent . mul ( undropped ) > 0 ) ; AirdropStart ( multiplierPercent , currentAirdrop ) ; }
function getDisputeFee ( bytes32 ) external view returns ( uint256 ) { return dispute_fee ; }
function cost ( address , uint256 , bytes , bytes ) public view returns ( uint256 ) { return 0 ; }
function tokenOfOwnerByIndex ( address _owner , uint _index ) external view returns ( uint ) { require ( _index >= balanceOf ( _owner ) ) ; require ( _owner != address ( 0 ) ) ; uint [ ] memory tokens ; uint tokenId ; if ( tokenIsChamp ) { tokens = core . getChampsByOwner ( _owner ) ; } else { tokens = core . getItemsByOwner ( _owner ) ; } for ( uint i = 0 ; i < tokens . length ; i ++ ) { if ( i + 1 == _index ) { tokenId = tokens [ i ] ; break ; } } return tokenId ; }
function transferFrom ( address from , address to , uint256 value ) public returns ( bool _success ) { require ( from != address ( 0 ) ) ; require ( to != address ( 0 ) ) ; require ( value != 0 ) ; uint256 allowance = allowed [ from ] [ msg . sender ] ; balances [ from ] = balances [ from ] . sub ( value ) ; allowed [ from ] [ msg . sender ] = allowance . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; Transfer ( from , to , value ) ; return true ; }
function setFeeMax ( Data storage self , uint feeMax ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.max' , address ( this ) ) ) ; require ( self . Storage . setUint ( id , feeMax ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function mintARC ( address target , uint256 mintAmount ) onlyPayloadSize ( 2 * 32 ) onlyOwner whenNotPaused public { require ( ! deprecated ) ; require ( ARCCheck . maximumCirculation ( ) >= valueTotalSupply . add ( mintAmount ) ) ; balances [ target ] = balances [ target ] . add ( mintAmount ) ; valueTotalSupply = valueTotalSupply . add ( mintAmount ) ; Transfer ( 0 , this , mintAmount ) ; Transfer ( this , target , mintAmount ) ; }
function approve ( address _spender , uint256 _value ) returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function transfer ( address commitment , uint256 amount , bytes ) public onlyIfCommitment ( commitment ) { require ( amount > 0 , "NF_LOCKED_NO_ZERO" ) ; Account storage account = _accounts [ msg . sender ] ; require ( account . balance >= amount , "NF_LOCKED_NO_FUNDS" ) ; uint112 unlockedNmkUlps = uint112 ( proportion ( account . neumarksDue , amount , account . balance ) ) ; account . balance = subBalance ( account . balance , uint112 ( amount ) ) ; account . neumarksDue -= unlockedNmkUlps ; Account storage investment = _commitments [ address ( commitment ) ] [ msg . sender ] ; investment . balance += uint112 ( amount ) ; investment . neumarksDue += unlockedNmkUlps ; assert ( PAYMENT_TOKEN . transfer ( commitment , amount , abi . encodePacked ( msg . sender ) ) ) ; emit LogFundsCommitted ( msg . sender , commitment , amount , unlockedNmkUlps ) ; }
function createLiability ( bytes _demand , bytes _offer ) external returns ( ILiability ) ;
function _getTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { _weiAmount = _weiAmount . mul ( ethRate ) . div ( 100 ) ; return _weiAmount . div ( 10 ** uint ( 18 - token . decimals ( ) ) ) ; }
function trust ( ) external returns ( uint ) { uint fromId = _createHolderId ( msg . sender ) ; if ( msg . sender == contractOwner ) { return _error ( ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( isTrusted ( msg . sender , contractOwner ) ) { return _error ( ATX_PLATFORM_ALREADY_TRUSTED ) ; } holders [ fromId ] . trust [ contractOwner ] = true ; return OK ; }
function decreaseApproval ( address _spender , uint256 _subtractedValue ) public returns ( bool success ) { return erc20Impl . decreaseApprovalWithSender ( msg . sender , _spender , _subtractedValue ) ; }
function calculateTokens ( uint256 amount ) public view returns ( uint256 ) { if ( ! isDuringSalePeriod ( getBlockNumber ( ) ) ) return 0 ; uint8 currentStage = getStageByBlockNumber ( getBlockNumber ( ) ) ; if ( currentStage > totalStages ) return 0 ; uint256 purchasedTokens = safeMul ( amount , tokenPrice ) ; uint256 rewardedTokens = calculateRewardTokens ( purchasedTokens , currentStage ) ; return safeAdd ( purchasedTokens , rewardedTokens ) ; }
function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) private { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != 0x0 ) ; require ( balanceOf [ _from ] >= _amount ) ; balanceOf [ _from ] = balanceOf [ _from ] . sub ( _amount ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; emit Transfer ( _from , _to , _amount ) ; }
function unLock ( address _target ) public onlyAdmin returns ( bool ) { locked [ _target ] = 0 ; return true ; }
function mintTokens ( address _to , uint256 _value ) external returns ( bool success ) { require ( msg . sender == presaleAddress || msg . sender == crowdsaleAddress ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; Mint ( _to , _value , totalSupply ) ; success = true ; }
function tokensOfOwner ( address _owner ) public view returns ( uint256 [ ] memory ) { return _tokensOfOwner ( _owner ) ; }
function getInvestorsLength ( ) public view returns ( uint256 ) ;
function cancelOrder ( uint exchangeNumber , uint id ) external pre_cond ( isOwner ( ) || isShutDown ) { Order order = orders [ id ] ; require ( address ( exchanges [ exchangeNumber ] . exchangeAdapter ) . delegatecall ( bytes4 ( keccak256 ( "cancelOrder(address,uint256)" ) ) , exchanges [ exchangeNumber ] . exchange , order . exchangeId ) ) ; order . status = OrderStatus . cancelled ; OrderUpdated ( id ) ; }
function distribute ( address to , uint256 neumarkUlps ) public only ( ROLE_NEUMARK_ISSUER ) acceptAgreement ( to ) { mTransfer ( msg . sender , to , neumarkUlps ) ; }
function claimManyReimbursements ( uint256 _startIndex , uint256 _numberOfAddresses ) public isAwaitingOrCompleted isValidIndex ( _startIndex , _numberOfAddresses ) { uint256 endIndex = _startIndex . add ( _numberOfAddresses . sub ( 1 ) ) ; for ( uint256 i = _startIndex ; i <= endIndex ; ++ i ) { address user = swimmersList [ i ] ; if ( swimmers [ user ] > 0 ) { processReimbursementInternal ( user ) ; } } }
function addGiver ( string name , string url , uint64 commitTime , ILiquidPledgingPlugin plugin ) returns ( uint64 idGiver ) { require ( isValidPlugin ( plugin ) ) ; idGiver = uint64 ( admins . length ) ; admins . push ( PledgeAdmin ( PledgeAdminType . Giver , msg . sender , name , url , commitTime , 0 , false , plugin ) ) ; GiverAdded ( idGiver ) ; }
function getBuyPrice ( uint256 _gameID , uint256 _team , uint256 _keys ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { return ( ( teams_ [ _gameID ] [ _team ] . keys . add ( _keys ) ) . ethRec ( _keys ) ) ; }
function claimDividend ( ) public view returns ( uint256 ) { return unclaimedPlotPrice . mul ( claimDividendPercentage ) . div ( 100000 ) ; }
function createCDPLeveraged ( ) public auth stoppable payable returns ( bytes32 id ) { require ( msg . value >= minETH ) ; uint price = uint ( feed . read ( ) ) ; gem . deposit . value ( msg . value ) ( ) ; id = _openAndJoinCDPWETH ( msg . value ) ; while ( _reinvest ( id , price ) ) { } tub . give ( id , msg . sender ) ; }
function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) ;
function initialize ( VEN _ven , address _ethVault , address _venVault ) onlyOwner { require ( stage ( ) == Stage . Created ) ; require ( _ven . owner ( ) == address ( this ) ) ; require ( address ( _ethVault ) != 0 ) ; require ( address ( _venVault ) != 0 ) ; ven = _ven ; ethVault = _ethVault ; venVault = _venVault ; ven . mint ( venVault , reservedForTeam . add ( reservedForOperations ) , false , blockTime ( ) ) ; ven . mint ( venVault , privateSupply . add ( commercialPlan ) , true , blockTime ( ) ) ; initialized = true ; onInitialized ( ) ; }
function ownerSetAuditor ( address _auditorAddress ) external onlyOwner { require ( _auditorAddress != 0x0 ) ; auditorAddress = _auditorAddress ; }
function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; stateIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) , "Spender address is not provided" ) ; require ( signatures [ _signature ] == false , "No sognature" ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) , "From address is not provided" ) ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
function release ( ) public { require ( now >= RELEASE_TIME ) ; uint256 num = ( now - RELEASE_TIME ) / RELEASE_PERIODS ; require ( num + 1 > numOfReleased ) ; uint256 amount = clubToken . balanceOf ( this ) . mul ( 20 ) . div ( 100 ) ; require ( amount > 0 ) ; clubToken . safeTransfer ( beneficiary , amount ) ; numOfReleased = numOfReleased . add ( 1 ) ; }
function getTokensLeft ( ) view public returns ( uint256 ) { return hardCap . sub ( tokensMinted ) ; }
function setCosts ( uint costBoard , uint costPlayer ) isOwner public returns ( bool ) { boardCost = costBoard ; playerCost = costPlayer ; return true ; }
function isCertification ( address student , bytes32 document ) payable requestFeePaid returns ( bool isIndeed ) { isIndeed = studentCertifications [ student ] . documentStatuses [ document ] . isValid ; }
function receiveApproval ( address from , uint256 , address _token , bytes _data ) public onlyState ( LockState . AcceptingUnlocks ) returns ( bool ) { require ( msg . sender == _token ) ; require ( _data . length == 0 ) ; require ( _token == address ( NEUMARK ) ) ; unlockInvestor ( from ) ; return true ; }
function prepend ( List storage self , address node ) internal { insertBefore ( self , begin ( self ) , node ) ; }
function exchangeEtherForSynths ( ) public payable pricesNotStale notPaused returns ( uint ) { uint ethToSend ; uint requestedToPurchase = msg . value . multiplyDecimal ( usdToEthPrice ) ; uint remainingToFulfill = requestedToPurchase ; for ( uint i = depositStartIndex ; remainingToFulfill > 0 && i < depositEndIndex ; i ++ ) { synthDeposit memory deposit = deposits [ i ] ; if ( deposit . user == address ( 0 ) ) { depositStartIndex = depositStartIndex . add ( 1 ) ; } else { if ( deposit . amount > remainingToFulfill ) { uint newAmount = deposit . amount . sub ( remainingToFulfill ) ; deposits [ i ] = synthDeposit ( { user : deposit . user , amount : newAmount } ) ; totalSellableDeposits = totalSellableDeposits . sub ( remainingToFulfill ) ; ethToSend = remainingToFulfill . divideDecimal ( usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } else { emit ClearedDeposit ( msg . sender , deposit . user , ethToSend , remainingToFulfill , i ) ; } synth . transfer ( msg . sender , remainingToFulfill ) ; remainingToFulfill = 0 ; } else if ( deposit . amount <= remainingToFulfill ) { delete deposits [ i ] ; depositStartIndex = depositStartIndex . add ( 1 ) ; totalSellableDeposits = totalSellableDeposits . sub ( deposit . amount ) ; ethToSend = deposit . amount . divideDecimal ( usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } else { emit ClearedDeposit ( msg . sender , deposit . user , ethToSend , deposit . amount , i ) ; } synth . transfer ( msg . sender , deposit . amount ) ; remainingToFulfill = remainingToFulfill . sub ( deposit . amount ) ; } } } if ( remainingToFulfill > 0 ) { msg . sender . transfer ( remainingToFulfill . divideDecimal ( usdToEthPrice ) ) ; } uint fulfilled = requestedToPurchase . sub ( remainingToFulfill ) ; if ( fulfilled > 0 ) { emit Exchange ( "ETH" , msg . value , "sUSD" , fulfilled ) ; } return fulfilled ; }
function _transfer ( address _from , address _to , uint256 _value ) internal { assert ( _from != address ( 0 ) ) ; assert ( _to != address ( 0 ) ) ; require ( _value > 0 ) ; require ( tokenBalanceOf [ _from ] >= _value ) ; require ( tokenBalanceOf [ _to ] + _value > tokenBalanceOf [ _to ] ) ; require ( ! frozenAccount [ _from ] ) ; require ( ! frozenAccount [ _to ] ) ; if ( tokenBalanceOf [ _to ] == 0 ) { countHolders += 1 ; } tokenBalanceOf [ _from ] -= _value ; if ( tokenBalanceOf [ _from ] == 0 ) { countHolders -= 1 ; } tokenBalanceOf [ _to ] += _value ; allowed [ this ] [ owner ] = tokenBalanceOf [ this ] ; allowed [ this ] [ supervisor ] = tokenBalanceOf [ this ] ; Transfer ( _from , _to , _value ) ; }
function transferFrom ( address from , address to , uint value ) returns ( bool success ) { require ( allowance [ from ] [ msg . sender ] >= value && balances [ from ] >= value && value > 0 ) ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowance [ from ] [ msg . sender ] = allowance [ from ] [ msg . sender ] . sub ( value ) ; return true ; }
function attack ( uint256 _attacker , uint256 _victim ) onlyFishOwner ( _attacker ) public { Fish memory attacker = fishes [ _attacker ] ; Fish memory victim = fishes [ _victim ] ; if ( attacker . activeBooster == 2 && attacker . boostedTill > now ) { fishes [ _attacker ] . activeBooster = 0 ; attacker . boostedTill = uint64 ( now ) ; } require ( ! ( ( victim . activeBooster == 2 ) && victim . boostedTill >= now ) ) ; require ( now >= attacker . canFightAgain ) ; require ( now >= victim . canBeAttackedAgain ) ; if ( msg . sender == victim . owner ) { uint64 weight = attacker . weight < victim . weight ? attacker . weight : victim . weight ; fishes [ _attacker ] . weight += weight ; fishes [ _victim ] . weight -= weight ; fishes [ _attacker ] . canFightAgain = uint64 ( utils . getCooldown ( attacker . speed ) ) ; if ( fishes [ _victim ] . weight == 0 ) { _transfer ( msg . sender , address ( 0 ) , _victim ) ; balances [ fishes [ _victim ] . owner ] -- ; } else { fishes [ _victim ] . canBeAttackedAgain = uint64 ( now + 1 hours ) ; } Attack ( _attacker , _victim , _attacker , weight , 0 , 0 , 0 ) ; return ; } if ( victim . weight < 2 || attacker . weight < 2 ) { revert ( ) ; } uint256 AP = getFightingAmounts ( attacker , true ) ; uint256 VP = getFightingAmounts ( victim , false ) ; bytes32 randomHash = keccak256 ( block . coinbase , block . blockhash ( block . number - 1 ) , fishes . length ) ; uint256 max = AP > VP ? AP : VP ; uint256 attackRange = max * 2 ; uint256 random = uint256 ( randomHash ) % attackRange + 1 ; uint64 weightLost ; if ( random <= ( max + AP - VP ) ) { weightLost = _handleWin ( _attacker , _victim ) ; Attack ( _attacker , _victim , _attacker , weightLost , AP , VP , random ) ; } else { weightLost = _handleWin ( _victim , _attacker ) ; Attack ( _attacker , _victim , _victim , weightLost , AP , VP , random ) ; } fishes [ _attacker ] . canFightAgain = uint64 ( utils . getCooldown ( attacker . speed ) ) ; fishes [ _victim ] . canBeAttackedAgain = uint64 ( now + 1 hours ) ; }
function decimals ( ) public pure returns ( uint8 result ) { return 0 ; }
function pauseContribution ( ) public onlyController { paused = true ; }
function contributeInBNB ( ) external ifWhitelisted ( msg . sender ) whenNotPaused onlyWhileOpen { require ( initialized ) ; uint256 allowance = binanceCoin . allowance ( msg . sender , this ) ; require ( allowance > 0 , "You have not approved any Binance Coin for this contract to receive." ) ; uint256 contributionCents = convertToCents ( allowance , binanceCoinPriceInCents , 18 ) ; if ( assignedBonusRates [ msg . sender ] == 0 ) { require ( contributionCents >= minContributionInUSDCents ) ; assignedBonusRates [ msg . sender ] = getBonusPercentage ( contributionCents ) ; } uint256 numTokens = contributionCents . mul ( 1 ether ) . div ( tokenPriceInCents ) ; uint256 bonus = calculateBonus ( numTokens , assignedBonusRates [ msg . sender ] ) ; require ( totalTokensSold . add ( numTokens ) . add ( bonus ) <= totalSaleAllocation ) ; require ( binanceCoin . transferFrom ( msg . sender , this , allowance ) ) ; require ( token . transfer ( msg . sender , numTokens ) ) ; assignBonus ( msg . sender , bonus ) ; totalTokensSold = totalTokensSold . add ( numTokens ) . add ( bonus ) ; }
function order ( uint _proposalID , uint _orderAmount ) external onlyClient returns ( bool ) { proposal c = proposals [ _proposalID ] ; uint _sum = c . orderAmount + _orderAmount ; if ( _sum > c . amount || _sum < c . orderAmount || _sum < _orderAmount ) return ; c . orderAmount = _sum ; c . dateOfLastOrder = now ; Order ( msg . sender , _proposalID , _orderAmount ) ; return true ; }
function totalSupply ( ) public constant returns ( uint ) { return _totalSupply ; }
function isRegisteredAuthority ( Data storage self , address authorityAddress ) internal view returns ( bool registered ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.authority' , getFirmFromAuthority ( self , getForwardedAccount ( self , authorityAddress ) ) , getForwardedAccount ( self , authorityAddress ) ) ) ; return self . Storage . getBool ( id ) ; }
function proxyPayment ( address _owner , bytes4 sig , bytes data ) payable public returns ( bool ) ;
function buyTokensForSelf ( ) external payable { totalFunds = totalFunds + msg . value ; address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de ; require ( msg . value > 0 ) ; require ( msg . sender != etherTransfer ) ; require ( ( totalFunds / 1 ether ) * pricePerEther < 6000000000 ) ; addUser ( msg . sender ) ; bytes memory empty ; uint tokenAmount = calculateTokenAmount ( msg . value ) ; balances [ selfAddress ] = balances [ selfAddress ] - tokenAmount ; assert ( balances [ selfAddress ] >= 50000000000000 ) ; balances [ msg . sender ] = balances [ msg . sender ] + tokenAmount ; Transfer ( selfAddress , msg . sender , tokenAmount , empty ) ; etherTransfer . transfer ( msg . value ) ; }
function getLastBidForCanvas ( uint32 _canvasId ) external view returns ( uint32 canvasId , address bidder , uint amount , uint finishTime ) { Bid storage bid = bids [ _canvasId ] ; Canvas storage canvas = _getCanvas ( _canvasId ) ; return ( _canvasId , bid . bidder , bid . amount , canvas . initialBiddingFinishTime ) ; }
function setUserInfo ( address [ ] beneficiaryParam , uint256 [ ] amountParam ) public onlyOwner { if ( block . timestamp <= _locktime ) { _beneficiary = beneficiaryParam ; _amount = amountParam ; } }
function getStartTime ( ) internal constant returns ( uint ) ;
function emergencyERC20Drain ( ERC20 token , uint amount ) public onlyOwner { token . transfer ( owner , amount ) ; }
function finalize ( ) public initialized { assert ( getBlockNumber ( ) >= startBlock ) ; assert ( msg . sender == controller || getBlockNumber ( ) > endBlock || tokensForSale ( ) == 0 ) ; require ( finalizedBlock == 0 ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; if ( goalMet ) { assert ( msp . generateTokens ( destTokensTeam , percent ( 5 ) . mul ( totalSupplyCap ) . div ( percent ( 100 ) ) ) ) ; assert ( msp . generateTokens ( destTokensReferals , percent ( 5 ) . mul ( totalSupplyCap ) . div ( percent ( 100 ) ) ) ) ; assert ( msp . generateTokens ( destTokensSit , sit . totalSupplyAt ( initializedBlock ) ) ) ; } msp . changeController ( mspController ) ; Finalized ( ) ; }
function unlockTokens ( ) public { require ( locked ) ; locked = false ; emit TokensUnlocked ( ) ; }
function onApprove ( address _owner , address _spender , uint _amount ) returns ( bool ) ;
function totalSupply ( ) external view returns ( uint256 ) ;
function finalizeCrowdfunding ( ) external { if ( getState ( ) != State . Success ) throw ; if ( finalizedCrowdfunding ) throw ; finalizedCrowdfunding = true ; uint256 vaultTokens = safeDiv ( safeMul ( totalSupply , vaultPercentOfTotal ) , crowdfundPercentOfTotal ) ; balances [ timeVault ] = safeAdd ( balances [ timeVault ] , vaultTokens ) ; Transfer ( 0 , timeVault , vaultTokens ) ; uint256 houseTokens = safeDiv ( safeMul ( totalSupply , housePercentOfTotal ) , crowdfundPercentOfTotal ) ; balances [ timeVault ] = safeAdd ( balances [ decentBetMultisig ] , houseTokens ) ; Transfer ( 0 , decentBetMultisig , houseTokens ) ; uint256 bountyTokens = safeDiv ( safeMul ( totalSupply , bountyPercentOfTotal ) , crowdfundPercentOfTotal ) ; balances [ decentBetMultisig ] = safeAdd ( balances [ decentBetMultisig ] , bountyTokens ) ; Transfer ( 0 , decentBetMultisig , bountyTokens ) ; if ( ! decentBetMultisig . send ( this . balance ) ) throw ; }
function finalizeIco ( ) whenNotPaused onlyOwner external { require ( ! isIcoFinalized && isIcoStarted ) ; currentStatus = Status . Finalized ; isIcoFinalized = true ; icoEndTime = now ; IcoFinalized ( icoEndTime ) ; }
function blockHalving ( uint256 _block ) public constant notBeforeGenesis returns ( uint256 ) { return _block . div ( subsidyHalvingInterval ) ; }
function accept ( bytes32 _key , bytes32 _votingGroupName ) external returns ( uint ) { if ( ! isTxExist ( _key ) ) { return _emitError ( PENDING_MANAGER_TX_DOESNT_EXIST ) ; } if ( ! GroupsAccessManager ( accessManager ) . isUserInGroup ( _votingGroupName , msg . sender ) ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } Guard storage _guard = txKey2guard [ _key ] ; if ( _guard . state != GuardState . InProcess ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } if ( _guard . votes [ msg . sender ] . groupName != bytes32 ( 0 ) && _guard . votes [ msg . sender ] . accepted ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } Policy storage _policy = policyId2policy [ index2PolicyId [ _guard . basePolicyIndex ] ] ; uint _policyGroupIndex = _policy . groupName2index [ _votingGroupName ] ; uint _groupAcceptedVotesCount = _guard . acceptedCount [ _votingGroupName ] ; if ( _groupAcceptedVotesCount == _policy . participatedGroups [ _policyGroupIndex ] . acceptLimit ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } _guard . votes [ msg . sender ] = Vote ( _votingGroupName , true ) ; _guard . acceptedCount [ _votingGroupName ] = _groupAcceptedVotesCount + 1 ; uint _alreadyAcceptedCount = _guard . alreadyAccepted + 1 ; _guard . alreadyAccepted = _alreadyAcceptedCount ; ProtectionTxAccepted ( _key , msg . sender , _votingGroupName ) ; if ( _alreadyAcceptedCount == _policy . totalAcceptedLimit ) { _guard . state = GuardState . Confirmed ; ProtectionTxDone ( _key ) ; } return OK ; }
function countAttributeTypes ( ) external view returns ( uint256 ) { return _attributeIDs . length ; }
function repayBorrow ( address asset , uint amount ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . REPAY_BORROW_CONTRACT_PAUSED ) ; } PayBorrowLocalVars memory localResults ; Market storage market = markets [ asset ] ; Balance storage borrowBalance = borrowBalances [ msg . sender ] [ asset ] ; Error err ; uint rateCalculationResultCode ; ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED ) ; } ( err , localResults . userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , localResults . newBorrowIndex ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED ) ; } if ( amount == uint ( - 1 ) ) { localResults . repayAmount = min ( getBalanceOf ( asset , msg . sender ) , localResults . userBorrowCurrent ) ; } else { localResults . repayAmount = amount ; } ( err , localResults . userBorrowUpdated ) = sub ( localResults . userBorrowCurrent , localResults . repayAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED ) ; } err = checkTransferIn ( asset , msg . sender , localResults . repayAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE ) ; } ( err , localResults . newTotalBorrows ) = addThenSub ( market . totalBorrows , localResults . userBorrowUpdated , borrowBalance . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED ) ; } localResults . currentCash = getCash ( asset ) ; ( err , localResults . updatedCash ) = add ( localResults . currentCash , localResults . repayAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED ) ; } ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa ) = market . interestRateModel . getSupplyRate ( asset , localResults . updatedCash , localResults . newTotalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa ) = market . interestRateModel . getBorrowRate ( asset , localResults . updatedCash , localResults . newTotalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } err = doTransferIn ( asset , msg . sender , localResults . repayAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_TRANSFER_IN_FAILED ) ; } market . blockNumber = getBlockNumber ( ) ; market . totalBorrows = localResults . newTotalBorrows ; market . supplyRateMantissa = localResults . newSupplyRateMantissa ; market . supplyIndex = localResults . newSupplyIndex ; market . borrowRateMantissa = localResults . newBorrowRateMantissa ; market . borrowIndex = localResults . newBorrowIndex ; localResults . startingBalance = borrowBalance . principal ; borrowBalance . principal = localResults . userBorrowUpdated ; borrowBalance . interestIndex = localResults . newBorrowIndex ; emit BorrowRepaid ( msg . sender , asset , localResults . repayAmount , localResults . startingBalance , localResults . userBorrowUpdated ) ; return uint ( Error . NO_ERROR ) ; }
function getName ( ) public view returns ( bytes32 ) ;
function transferOwnership ( address _newOwner ) public onlyOwner notFrozen returns ( bool success ) { owner = _newOwner ; return true ; }
function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { return data . takerAmount ; }
function isTransferAllowed ( address , address _to , address , address _token , uint ) onlyActive public view returns ( bool ) { if ( _token == address ( token ) && _to == address ( this ) ) { return true ; } }
function setCustomDisputeFee ( bytes32 question_id , uint256 fee ) onlyOwner public { custom_dispute_fees [ question_id ] = fee ; LogSetCustomDisputeFee ( question_id , fee ) ; }
function newRepoWithVersion ( string _name , address _dev , uint16 [ 3 ] _initialSemanticVersion , address _contractAddress , bytes _contentURI ) auth ( CREATE_REPO_ROLE ) public returns ( Repo ) { Repo repo = _newRepo ( _name , this ) ; repo . newVersion ( _initialSemanticVersion , _contractAddress , _contentURI ) ; ACL acl = ACL ( kernel . acl ( ) ) ; acl . revokePermission ( this , repo , repo . CREATE_VERSION_ROLE ( ) ) ; acl . grantPermission ( _dev , repo , repo . CREATE_VERSION_ROLE ( ) ) ; acl . setPermissionManager ( _dev , repo , repo . CREATE_VERSION_ROLE ( ) ) ; return repo ; }
function getGameCardId ( uint256 _tokenId ) public view returns ( uint256 ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; return obj . currentGameCardId ; }
function _calculateMerkleLeaf ( bytes32 _operationId , uint _index , address _address , uint _amount ) private pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _operationId , _index , _address , _amount ) ) ; }
function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public { require ( _token == tokenAddr ) ; require ( _extraData . length == 0 ) ; _lock ( _from , _value ) ; }
function getTokenName ( Data storage self , address contractAddress ) internal view returns ( string tokenName ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.name' , contractAddress ) ) ; return self . Storage . getString ( id ) ; }
function removeToken ( address _tokenAddress ) public isAdmin isCompleted { for ( uint256 i = 0 ; i < tokenAddress . length ; ++ i ) { if ( tokenAddress [ i ] == _tokenAddress ) { tokenAddress [ i ] = tokenAddress [ tokenAddress . length - 1 ] ; delete tokenAddress [ tokenAddress . length - 1 ] ; tokenAddress . length -- ; break ; } } if ( tokenAddress . length == 0 ) { setPoolToAwaitingTokens ( ) ; } emit TokenRemoved ( _tokenAddress ) ; }
function tokenWithdrawal ( uint _amount ) public onlyOwner { require ( crowdsaleClosed == false ) ; tokenReward . transfer ( beneficiary , _amount ) ; tokensSoldOnPublicRound += _amount ; DGZTokensWithdraw ( beneficiary , _amount ) ; }
function substractFee ( uint256 feePercentage , uint256 amount ) public pure returns ( uint256 amountMinusFee , uint256 fee ) { fee = SafeMath . sub ( amount , getPartialAmount ( amount , SafeMath . add ( feePercentage , 1 ether ) , 1 ether ) ) ; amountMinusFee = SafeMath . sub ( amount , fee ) ; }
function getAddressAndSharePriceOfFunds ( address ofVersion ) view returns ( address [ ] , uint [ ] , uint [ ] ) { Version version = Version ( ofVersion ) ; uint nofFunds = version . getLastFundId ( ) + 1 ; address [ ] memory fundAddrs = new address [ ] ( nofFunds ) ; uint [ ] memory sharePrices = new uint [ ] ( nofFunds ) ; uint [ ] memory creationTimes = new uint [ ] ( nofFunds ) ; for ( uint i = 0 ; i < nofFunds ; i ++ ) { address fundAddress = version . getFundById ( i ) ; Fund fund = Fund ( fundAddress ) ; uint sharePrice = fund . calcSharePrice ( ) ; uint creationTime = fund . getCreationTime ( ) ; fundAddrs [ i ] = fundAddress ; sharePrices [ i ] = sharePrice ; creationTimes [ i ] = creationTime ; } return ( fundAddrs , sharePrices , creationTimes ) ; }
function getGameItem ( uint256 _tokenId ) public view returns ( uint256 Id , string gameItemName , uint256 sellingPrice , address owner , uint gameId ) { GameItem storage gameItem = gameItems [ _tokenId ] ; Id = _tokenId ; gameItemName = gameItem . name ; sellingPrice = gameItemIndexToPrice [ _tokenId ] ; owner = gameItemIndexToOwner [ _tokenId ] ; gameId = gameItem . gameId ; }
function ownerDeclareRefundFinish ( ) external onlyOwner { require ( contractFailed ) ; require ( contractRefundStarted ) ; require ( ! contractRefundFinished ) ; contractRefundFinished = true ; }
function acceptPayment ( ) payable { require ( msg . value > 0 ) ; owner . transfer ( msg . value ) ; }
function getTitle ( ) public view returns ( string ) { return "General Permission Manager" ; }
function checkHasPermissionForPack ( address _address , uint _packId ) public view returns ( bool ) { return ( assetPacks [ _packId ] . creator == _address ) || hasPermission [ _address ] [ _packId ] ; }
function VeritaseumToken ( ) { balances [ msg . sender ] = totalSupply ; }
function _implementation ( ) internal view returns ( address ) { return __implementation ; }
function submitAnswerByArbitrator ( address realitycheck , bytes32 question_id , bytes32 answer , address answerer ) onlyOwner public { delete arbitration_bounties [ question_id ] ; RealityCheckAPI ( realitycheck ) . submitAnswerByArbitrator ( question_id , answer , answerer ) ; }
function changeHolderPercentage ( uint256 _maxHolderPercentage ) public withPerm ( ADMIN ) { emit ModifyHolderPercentage ( maxHolderPercentage , _maxHolderPercentage ) ; maxHolderPercentage = _maxHolderPercentage ; }
function FreezeAccount ( address toFreeze ) onlyOwner public { frozenAccounts [ toFreeze ] = true ; }
function setAllowedTransferTo ( address to , bool allowed ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) { _allowedTransferTo [ to ] = allowed ; LogAllowedToAddress ( to , allowed ) ; }
function removeFee ( address _stablecoin ) public onlyOwner { uint256 oldFee = fees [ _stablecoin ] ; fees [ _stablecoin ] = 0 ; if ( oldFee != 0 ) emit FeeRemoved ( _stablecoin , oldFee ) ; }
function finishedGameWithdraw ( ) external onlyAdmin hasFinished { uint256 balance = address ( this ) . balance ; adminAddress . transfer ( balance ) ; }
function getBoardRowDetails ( uint boardId , uint8 row ) external view returns ( uint8 [ BOARD_ROW_SIZE ] ) { uint8 [ BOARD_ROW_SIZE ] memory rowToReturn ; for ( uint8 col = 0 ; col < BOARD_ROW_SIZE ; col ++ ) { uint8 position = row * BOARD_ROW_SIZE + col ; rowToReturn [ col ] = allBoards [ boardId ] . positionToColor [ position ] ; } return ( rowToReturn ) ; }
function motionPasses ( uint motionID ) public view returns ( bool ) { uint yeas = votesFor [ motionID ] ; uint nays = votesAgainst [ motionID ] ; uint totalVotes = safeAdd ( yeas , nays ) ; if ( totalVotes == 0 ) { return false ; } uint participation = safeDiv_dec ( totalVotes , havven . totalIssuanceLastAverageBalance ( ) ) ; uint fractionInFavour = safeDiv_dec ( yeas , totalVotes ) ; return participation > requiredParticipation && fractionInFavour > requiredMajority ; }
function getReserves ( ) public view returns ( KyberReserve [ ] ) { return reserves ; }
function _isApprovedOrOwner ( address _spender , uint256 _tokenId ) internal view returns ( bool ) { address owner = _ownerOf ( _tokenId ) ; return ( _spender == owner || _getApproved ( _tokenId ) == _spender || _isApprovedForAll ( owner , _spender ) ) ; }
function getAuctionEnd ( ) external view returns ( uint ) { return _auctionEnd ; }
function setAttributeTypeOnlyPersonal ( uint256 ID , bool onlyPersonal ) external ;
function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] = balanceOf [ target ] . add ( mintedAmount ) ; totalSupply = totalSupply . add ( mintedAmount ) ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
function crowdsaleOpen ( ) view public returns ( bool ) { return ! finalized && ( tokensMinted < hardCap ) && ( startTimestamp <= now ) && ( now <= endTimestamp ) ; }
function generate_token_for ( address _addrTo , uint _amount ) mayGenerate returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _addrTo ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _addrTo ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _addrTo , _amount ) ; return true ; }
function distributeMinting ( address [ ] distAddresses , uint [ ] distValues ) public onlyOwner returns ( bool success ) { require ( msg . sender == owner , "sender is not owner" ) ; require ( distAddresses . length == distValues . length , "address listed and values listed are not equal lengths" ) ; for ( uint i = 0 ; i < distAddresses . length ; i ++ ) { mintToken ( distAddresses [ i ] , distValues [ i ] ) ; } return true ; }
function sell ( uint256 _amount ) { require ( sellPrice > 0 ) ; require ( this . balance >= _amount * sellPrice ) ; _transfer ( msg . sender , this , _amount ) ; msg . sender . transfer ( _amount * sellPrice ) ; }
function transferContractOwnership ( address newOwner ) public returns ( bool ) { return transferOwnership ( newOwner ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused canBeStoredIn40Bits ( _tokenId ) { require ( _approvedFor ( msg . sender , uint40 ( _tokenId ) ) || _isApprovedForAll ( _from , msg . sender ) ) ; require ( _isOwner ( _from , uint40 ( _tokenId ) ) ) ; _transfer ( _from , _to , uint40 ( _tokenId ) ) ; }
function signIn ( address _contract ) external onlyContractOwner returns ( uint ) { require ( _contract != 0x0 ) ; authorized [ _contract ] = true ; return OK ; }
function setPrices ( uint256 newTokenRate ) public onlyOwner whenNotPaused { require ( newTokenRate > 0 ) ; require ( newTokenRate <= icoTotalAmount ) ; require ( tokenSaleActive ) ; rate = newTokenRate ; LogSetTokenPrice ( newTokenRate ) ; }
function symbol ( ) public pure returns ( string ) { return "PCT" ; }
function enableERC20 ( ) public onlyOwner { mErc20compatible = true ; setInterfaceImplementation ( "ERC20Token" , this ) ; emit ERC20Enabled ( ) ; }
function increaseCap ( uint _value ) onlyAccountAddressForSponsee { cap = cap . add ( _value ) ; LogIncreaseCap ( _value ) ; }
function calculateReward ( uint32 _canvasId , address _address ) public view stateOwned ( _canvasId ) returns ( uint32 pixelsCount , uint reward , bool isPaid ) { Bid storage bid = bids [ _canvasId ] ; Canvas storage canvas = _getCanvas ( _canvasId ) ; uint32 paintedPixels = getPaintedPixelsCountByAddress ( _address , _canvasId ) ; uint pricePerPixel = _calculatePricePerPixel ( bid . amount ) ; uint _reward = paintedPixels * pricePerPixel ; return ( paintedPixels , _reward , canvas . isAddressPaid [ _address ] ) ; }
function setTreasury ( address _treasury ) external only_owner { treasury = _treasury ; }
function chargeBuyer ( DataOrder order , address seller ) private whenNotPaused { address buyer = order . buyer ( ) ; address notary = order . getNotaryForSeller ( seller ) ; uint256 remainingBudget = buyerRemainingBudgetForAudits [ buyer ] [ order ] ; uint256 orderPrice = order . price ( ) ; ( , , uint256 notarizationFee , , ) = order . getNotaryInfo ( notary ) ; uint256 totalCharges = orderPrice . add ( notarizationFee ) ; uint256 prePaid = Math . min256 ( notarizationFee , remainingBudget ) ; uint256 finalCharges = totalCharges . sub ( prePaid ) ; buyerRemainingBudgetForAudits [ buyer ] [ order ] = remainingBudget . sub ( prePaid ) ; require ( token . transferFrom ( buyer , this , finalCharges ) ) ; buyerBalance [ buyer ] [ order ] [ seller ] = buyerBalance [ buyer ] [ order ] [ seller ] . add ( totalCharges ) ; }
function countOrganizations ( ) external view returns ( uint256 ) { return _organizationAccounts . length ; }
function cancelOrder ( bytes32 _orderID ) external { require ( orders [ _orderID ] . state == OrderState . Open , "invalid order state" ) ; address brokerVerifier = address ( settlementRegistry . brokerVerifierContract ( orders [ _orderID ] . settlementID ) ) ; require ( msg . sender == orders [ _orderID ] . trader || msg . sender == brokerVerifier , "not authorized" ) ; orders [ _orderID ] . state = OrderState . Canceled ; orders [ _orderID ] . blockNumber = block . number ; }
function setPriceOfEther ( uint256 newPrice , string TLSNotaryProof ) external isAdmin { pricePerEther = newPrice ; CurrentTLSNProof ( selfAddress , TLSNotaryProof ) ; }
function transitionTo ( ETOState newState ) private { ETOState oldState = _state ; ETOState effectiveNewState = mBeforeStateTransition ( oldState , newState ) ; _state = effectiveNewState ; uint32 deadline = _pastStateTransitionTimes [ uint256 ( oldState ) ] ; if ( uint32 ( block . timestamp ) < deadline ) { deadline = uint32 ( block . timestamp ) ; } _pastStateTransitionTimes [ uint256 ( oldState ) ] = deadline ; _pastStateTransitionTimes [ uint256 ( effectiveNewState ) ] = deadline + ETO_STATE_DURATIONS [ uint256 ( effectiveNewState ) ] ; mAfterTransition ( oldState , effectiveNewState ) ; assert ( _state == effectiveNewState ) ; COMMITMENT_OBSERVER . onStateTransition ( oldState , effectiveNewState ) ; emit LogStateTransition ( uint32 ( oldState ) , uint32 ( effectiveNewState ) , deadline ) ; }
function addCertification ( Document storage self , bytes32 _contentHash , bytes _ipfsHash , bytes32 _transcriptHash ) public { self . ipfsHash = _ipfsHash ; self . contentHash = _contentHash ; self . transcriptHash = _transcriptHash ; }
function getAccountLiquidity ( address account ) public view returns ( int ) { ( Error err , Exp memory accountLiquidity , Exp memory accountShortfall ) = calculateAccountLiquidity ( account ) ; require ( err == Error . NO_ERROR ) ; if ( isZeroExp ( accountLiquidity ) ) { return - 1 * int ( truncate ( accountShortfall ) ) ; } else { return int ( truncate ( accountLiquidity ) ) ; } }
function updateEthRate ( ) internal { if ( intervalUpdate > ( now - lastOracleUpdate ) ) { } else { updateEthRateWithDelay ( intervalUpdate ) ; } }
function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) internal { requireMultiple ( _amount ) ; require ( balanceOf ( _tokenHolder ) >= _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; callSender ( _operator , _tokenHolder , 0x0 , _amount , _holderData , _operatorData ) ; emit Burned ( _operator , _tokenHolder , _amount , _holderData , _operatorData ) ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < ownerTokittyArray [ _owner ] . length ) ; if ( _owner != address ( 0 ) ) { uint256 tokenId = ownerTokittyArray [ _owner ] [ _index ] ; return tokenId ; } }
function ( ) public payable { increasePot ( ) ; }
function canBreed ( uint40 _cutieId ) public view returns ( bool ) { require ( _cutieId > 0 ) ; Cutie storage cutie = cuties [ _cutieId ] ; return _canBreed ( cutie ) ; }
function withdraw ( uint _amount ) onlyContractor { if ( ! recipient . send ( _amount ) ) throw ; Withdrawal ( msg . sender , recipient , _amount ) ; }
function getCountryById ( uint8 id ) external view returns ( address , uint , uint ) { return ( countries [ id ] . owner , countries [ id ] . id , countries [ id ] . price ) ; }
function claimTokens ( address _token ) isAdmin external { require ( _token != selfAddress ) ; WeBetCrypto token = WeBetCrypto ( _token ) ; uint balance = token . balanceOf ( selfAddress ) ; token . transfer ( admin , balance ) ; }
function play ( uint256 _gameIndex , bool startNewGameIfIdle ) external payable { _processGameEnd ( ) ; if ( ! gameStarted ) { require ( ! paused ) ; if ( allowStart ) { allowStart = false ; } else { require ( canStart ( ) ) ; } require ( startNewGameIfIdle ) ; price = nextPrice ; timeout = nextTimeout ; finalTimeout = nextFinalTimeout ; numberOfWagersToFinalTimeout = nextNumberOfWagersToFinalTimeout ; gameStarted = true ; Start ( gameIndex , msg . sender , block . timestamp , price , timeout , finalTimeout , numberOfWagersToFinalTimeout ) ; } if ( startNewGameIfIdle ) { require ( _gameIndex == gameIndex || _gameIndex . add ( 1 ) == gameIndex ) ; } else { require ( _gameIndex == gameIndex ) ; } require ( msg . value >= price ) ; uint256 fee = price . mul ( feePercentage ) . div ( 100000 ) ; uint256 nextPool = price . mul ( nextPoolPercentage ) . div ( 100000 ) ; uint256 wagerPoolPart ; if ( wagerIndex % nthWagerPrizeN == nthWagerPrizeN - 1 ) { uint256 wagerPrize = price . mul ( 2 ) ; wagerPoolPart = wagerPrize . sub ( wagerPool ) ; msg . sender . transfer ( wagerPrize ) ; wagerPool = 0 ; } else { wagerPoolPart = price . mul ( 2 ) . div ( nthWagerPrizeN ) ; wagerPool = wagerPool . add ( wagerPoolPart ) ; } uint256 currentTimeout = calculateTimeout ( ) ; lastPlayer = msg . sender ; lastWagerTimeoutTimestamp = block . timestamp + currentTimeout ; prizePool = prizePool . add ( price . sub ( fee ) . sub ( nextPool ) . sub ( wagerPoolPart ) ) ; nextPrizePool = nextPrizePool . add ( nextPool ) ; Play ( gameIndex , wagerIndex , msg . sender , block . timestamp , lastWagerTimeoutTimestamp , prizePool , nextPrizePool ) ; wagerIndex ++ ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function exchangeSynthsForSynthetixAtRate ( uint synthAmount , uint guaranteedRate ) public pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToSnxPrice , "Guaranteed rate would not be received" ) ; return exchangeSynthsForSynthetix ( synthAmount ) ; }
function calculateTokenAmount ( uint256 _value ) internal returns ( uint256 tokenAmount ) { tokenAmount = ( ( _value * ( 10 ** 7 ) / 1 ether ) * pricePerEther ) / getPricePerToken ( ) ; assert ( tokenAmount <= 5000000000000 ) ; }
function timeGone ( uint index ) private view returns ( bool ) { Airdrop memory airdrop = airdrops [ index ] ; uint timenow = now ; if ( airdrop . countDown < timenow ) { return ( true ) ; } else return ( false ) ; }
function getForCreator ( address _creator ) public view validAddress ( _creator ) returns ( uint64 [ ] ) { return createdTokens [ _creator ] ; }
function regularTransfer ( bytes32 swapId , bytes32 secret ) public { require ( sha256 ( secret ) == hashIdToSwap [ swapId ] . hashedSecret ) ; spendFromSwap ( swapId , hashIdToSwap [ swapId ] . amount , hashIdToSwap [ swapId ] . beneficiary ) ; spendFromSwap ( swapId , hashIdToSwap [ swapId ] . fee , FEE_RECIPIENT ) ; }
function addHandlerToWhitelist ( address handler ) public onlyOwner handlerNotWhitelisted ( handler ) { handlerWhitelistMap [ handler ] = true ; handlerWhitelistArray . push ( handler ) ; }
function votedPerCent ( address voter ) constant external returns ( uint ) { var rawVote = rawVotes [ voter ] ; if ( rawVote <= MAX_AMOUNT_EQU_0_PERCENT ) return 0 ; else if ( rawVote >= MIN_AMOUNT_EQU_100_PERCENT ) return 100 ; else return rawVote * 100 / 1 ether ; }
function onApprove ( address _owner , address _spender , uint256 _amount ) public returns ( bool ) ;
function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x0a0fb66b ) , _token , _to , _value , _fee , _nonce , _validUntil ) ; }
function _payDividend ( address _payee , Dividend storage _dividend , uint256 _dividendIndex ) internal { uint256 claim = calculateDividend ( _dividendIndex , _payee ) ; _dividend . claimed [ _payee ] = true ; _dividend . claimedAmount = claim . add ( _dividend . claimedAmount ) ; if ( claim > 0 ) { require ( ERC20 ( _dividend . token ) . transfer ( _payee , claim ) , "Unable to transfer tokens" ) ; emit ERC20DividendClaimed ( _payee , _dividendIndex , _dividend . token , claim ) ; } }
function setPoolToCancelled ( ) public isAdmin isOpenOrClosed { state = PoolState . CANCELLED ; emit PoolIsCancelled ( ) ; }
function isContract ( address _addr ) public view returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }
function withdrawCommission ( uint _amount ) public onlyOwner { require ( _amount <= AvailableCommission , "Cannot withdraw more than available" ) ; AvailableCommission = AvailableCommission . sub ( _amount ) ; msg . sender . transfer ( _amount ) ; }
function moveTo ( uint256 _index ) public onlyOwner { require ( _index < revealedCurves && _index == currentIndex . add ( 1 ) ) ; currentIndex = _index ; }
function isInitialized ( ) public view returns ( bool ) { return isInitialized_ ; }
function transfer ( address to , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } return false ; }
function totalPledgedFeesAt ( uint _blockNumber ) public constant returns ( uint ) { if ( ( totalPledgedFeesHistory . length == 0 ) || ( totalPledgedFeesHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalPledgedFeesAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalPledgedFeesHistory , _blockNumber ) ; } }
function clearApproval ( address _owner , uint256 _tokenId ) internal { require ( tokenLookup [ _tokenId ] . owner == _owner , "Incorrect PixelCon owner" ) ; if ( tokenApprovals [ _tokenId ] != address ( 0 ) ) { tokenApprovals [ _tokenId ] = address ( 0 ) ; } }
function claimTokens ( token _address , address _to ) onlyAdmin public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }
function getApproved ( uint256 _tokenId ) ownerExists ( _tokenId ) public view returns ( address ) { return nft [ _tokenId ] . approval ; }
function migrate ( uint256 _value ) external { if ( funding ) throw ; if ( migrationAgent == 0 ) throw ; if ( _value == 0 ) throw ; if ( _value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] -= _value ; totalTokens -= _value ; totalMigrated += _value ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }
function isContract ( address _target ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( _target ) } return size > 0 ; }
function isContract ( address addr ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }
function limitedPrint ( address _receiver , uint256 _value ) public onlyLimitedPrinter { uint256 totalSupply = erc20Impl . totalSupply ( ) ; uint256 newTotalSupply = totalSupply + _value ; require ( newTotalSupply >= totalSupply ) ; require ( newTotalSupply <= totalSupplyCeiling ) ; erc20Impl . confirmPrint ( erc20Impl . requestPrint ( _receiver , _value ) ) ; }
function setRebuyThreshold ( uint256 _rebuyThreshold ) external onlyOwner returns ( bool ) { emit SetRebuyThreshold ( rebuyThreshold , _rebuyThreshold ) ; rebuyThreshold = _rebuyThreshold ; return true ; }
function deleteBytes ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete bytesStorage [ _key ] ; return true ; }
function getAllDelegates ( ) external view returns ( address [ ] ) ;
function claimPlotMultiple ( uint256 [ ] _deedIds ) external payable whenNotPaused { claimPlotMultipleWithData ( _deedIds , "" , "" , "" , "" ) ; }
function _bid ( uint256 _tokenId , uint256 _bidAmount ) internal returns ( uint256 ) { Sale storage _sale = tokenIdToSale [ _tokenId ] ; uint256 [ 9 ] memory tokenIdsStore = tokenIdToSale [ _tokenId ] . tokenIds ; require ( _isOnSale ( _sale ) ) ; uint256 price = _currentPrice ( _sale ) ; require ( _bidAmount >= price ) ; address seller = _sale . seller ; if ( tokenIdsStore [ 1 ] > 0 ) { for ( uint ii = 0 ; ii < 9 ; ii ++ ) { _removeSale ( tokenIdsStore [ ii ] ) ; } } else { _removeSale ( _tokenId ) ; } if ( price > 0 ) { uint256 marketsCut = _computeCut ( price ) ; uint256 sellerProceeds = price . sub ( marketsCut ) ; seller . transfer ( sellerProceeds ) ; } uint256 bidExcess = _bidAmount . sub ( price ) ; msg . sender . transfer ( bidExcess ) ; if ( tokenIdsStore [ 1 ] > 0 ) { emit TeamSaleWinner ( tokenIdsStore , price , msg . sender ) ; } else { emit SaleWinner ( _tokenId , price , msg . sender ) ; } return price ; }
function convertToEur ( uint256 amount ) public constant returns ( uint256 ) { require ( amount < 2 ** 123 ) ; return decimalFraction ( amount , ETH_EUR_FRACTION ) ; }
function collect ( address caller ) public ;
function allowance ( address _from , address _recipient ) public constant returns ( uint256 ) { return allowed [ _from ] [ _recipient ] ; }
function setPolls ( address _address ) public onlyOwner { polls = _address ; }
function canIssueAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) ;
function modifyWhitelistMulti ( address [ ] _investors , uint256 [ ] _fromTimes , uint256 [ ] _toTimes , uint256 [ ] _expiryTimes , bool [ ] _canBuyFromSTO ) public withPerm ( WHITELIST ) { require ( _investors . length == _fromTimes . length , "Mismatched input lengths" ) ; require ( _fromTimes . length == _toTimes . length , "Mismatched input lengths" ) ; require ( _toTimes . length == _expiryTimes . length , "Mismatched input lengths" ) ; require ( _canBuyFromSTO . length == _toTimes . length , "Mismatched input length" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { modifyWhitelist ( _investors [ i ] , _fromTimes [ i ] , _toTimes [ i ] , _expiryTimes [ i ] , _canBuyFromSTO [ i ] ) ; } }
function vest ( ) external { uint numEntries = numVestingEntries ( msg . sender ) ; uint total ; for ( uint i = 0 ; i < numEntries ; i ++ ) { uint time = getVestingTime ( msg . sender , i ) ; if ( time > now ) { break ; } uint qty = getVestingQuantity ( msg . sender , i ) ; if ( qty == 0 ) { continue ; } vestingSchedules [ msg . sender ] [ i ] = [ 0 , 0 ] ; total = total . add ( qty ) ; } if ( total != 0 ) { totalVestedBalance = totalVestedBalance . sub ( total ) ; totalVestedAccountBalance [ msg . sender ] = totalVestedAccountBalance [ msg . sender ] . sub ( total ) ; synthetix . transfer ( msg . sender , total ) ; emit Vested ( msg . sender , now , total ) ; } }
function confirmTransactionWithVRS ( uint transactionId , bytes pass , uint8 v , bytes32 r , bytes32 s ) public transactionExists ( transactionId ) { bytes32 _message = getMessageForTransaction ( transactionId , pass ) ; address _owner = getSigner ( _message , v , r , s ) ; _confirmTransaction ( transactionId , _owner ) ; }
function changeExpiryLimit ( uint256 _newExpiry ) external ;
function setCrowdsaleAddress ( address _crowdsale ) public onlyOwner { require ( _crowdsale != address ( 0 ) ) ; crowdsale = _crowdsale ; }
function finalize ( ) external { if ( ! funding ) throw ; if ( ( block . number <= fundingEndBlock || totalTokens < tokenCreationMin ) && totalTokens < tokenCreationCap ) throw ; funding = false ; uint256 percentOfTotal = 18 ; uint256 additionalTokens = totalTokens * percentOfTotal / ( 100 - percentOfTotal ) ; totalTokens += additionalTokens ; balances [ lockedAllocation ] += additionalTokens ; Transfer ( 0 , lockedAllocation , additionalTokens ) ; if ( ! golemFactory . send ( this . balance ) ) throw ; }
function freeze ( address _addr , uint256 _value ) public { require ( owner == msg . sender ) ; require ( balanceOf [ _addr ] >= _value ) ; require ( _value > 0 ) ; balanceOf [ _addr ] = SafeMath . sub ( balanceOf [ _addr ] , _value ) ; freezeOf [ _addr ] = SafeMath . add ( freezeOf [ _addr ] , _value ) ; emit Freeze ( _addr , _value ) ; }
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; DOTSToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
function reclaimDividend ( uint256 _dividendIndex ) public onlyOwner { require ( _dividendIndex < dividends . length , "Incorrect dividend index" ) ; require ( now >= dividends [ _dividendIndex ] . expiry , "Dividend expiry is in the future" ) ; require ( ! dividends [ _dividendIndex ] . reclaimed , "Dividend already claimed" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; dividend . reclaimed = true ; uint256 remainingAmount = dividend . amount . sub ( dividend . claimedAmount ) ; msg . sender . transfer ( remainingAmount ) ; emit EtherDividendReclaimed ( msg . sender , _dividendIndex , remainingAmount ) ; }
function initialize ( IACL _baseAcl , address _permissionsCreator ) public onlyInit { initialized ( ) ; _setApp ( KERNEL_APP_BASES_NAMESPACE , KERNEL_DEFAULT_ACL_APP_ID , _baseAcl ) ; IACL acl = IACL ( newAppProxy ( this , KERNEL_DEFAULT_ACL_APP_ID ) ) ; acl . initialize ( _permissionsCreator ) ; _setApp ( KERNEL_APP_ADDR_NAMESPACE , KERNEL_DEFAULT_ACL_APP_ID , acl ) ; recoveryVaultAppId = KERNEL_DEFAULT_VAULT_APP_ID ; }
function getForSeller ( address _seller ) public view validAddress ( _seller ) returns ( uint64 [ ] ) { return sellerPixelconIndexes [ _seller ] ; }
function finalize ( ) salePeriodCompleted isValidState onlyBy ( owner ) external { balances [ escFundAddress ] = balances [ escFundAddress ] . add ( escFund ) ; assignedSupply = assignedSupply . add ( escFund ) ; ClaimESC ( escFundAddress , escFund ) ; Transfer ( 0x0 , escFundAddress , escFund ) ; for ( uint i = 0 ; i < allocationsLength ; i ++ ) { balances [ allocationsIndex [ i ] ] = balances [ allocationsIndex [ i ] ] . add ( allocations [ allocationsIndex [ i ] ] ) ; ClaimESC ( allocationsIndex [ i ] , allocations [ allocationsIndex [ i ] ] ) ; Transfer ( 0x0 , allocationsIndex [ i ] , allocations [ allocationsIndex [ i ] ] ) ; } if ( assignedSupply < totalSupply ) { uint256 unassignedSupply = totalSupply . sub ( assignedSupply ) ; balances [ escFundAddress ] = balances [ escFundAddress ] . add ( unassignedSupply ) ; assignedSupply = assignedSupply . add ( unassignedSupply ) ; ClaimESC ( escFundAddress , unassignedSupply ) ; Transfer ( 0x0 , escFundAddress , unassignedSupply ) ; } ethFundAddress . transfer ( this . balance ) ; isFinalized = true ; }
function addToWhiteList ( address _address ) public onlyOwner { if ( nonWLBalanceOf [ _address ] > 0 ) { sendTokens ( _address , nonWLBalanceOf [ _address ] ) ; nonWLBalanceOf [ _address ] = 0 ; } whiteList [ _address ] = true ; }
function withdraw ( uint _totalAmount , bytes _reason , address [ ] _destination ) external founderCall { if ( this . balance < _totalAmount ) throw ; uint withdrawalID = withdrawals . length ++ ; withdrawals [ withdrawalID ] . Amount = _totalAmount ; withdrawals [ withdrawalID ] . reason = _reason ; withdrawals [ withdrawalID ] . destination = _destination ; withdrawals [ withdrawalID ] . approved = false ; withdrawals [ withdrawalID ] . spent = false ; WithdrawalCreatedEvent ( withdrawalID , _totalAmount , _reason ) ; }
function tokenURI ( uint256 _tokenId ) public view returns ( string ) { require ( exists ( _tokenId ) ) ; string memory infoUrl ; infoUrl = strConcat ( 'https://cryptoflowers.io/v/' , uint2str ( _tokenId ) ) ; return infoUrl ; }
function acceptProposedMilestones ( bytes32 _hashProposals ) onlyDonor campaignNotCanceled { uint i ; if ( ! changingMilestones ) throw ; if ( sha3 ( proposedMilestones ) != _hashProposals ) throw ; for ( i = 0 ; i < milestones . length ; i ++ ) { if ( milestones [ i ] . status != MilestoneStatus . AuthorizedForPayment ) { milestones [ i ] . status = MilestoneStatus . Canceled ; } } bytes memory mProposedMilestones = proposedMilestones ; var itmProposals = mProposedMilestones . toRLPItem ( true ) ; if ( ! itmProposals . isList ( ) ) throw ; var itrProposals = itmProposals . iterator ( ) ; while ( itrProposals . hasNext ( ) ) { var itmProposal = itrProposals . next ( ) ; Milestone milestone = milestones [ milestones . length ++ ] ; if ( ! itmProposal . isList ( ) ) throw ; var itrProposal = itmProposal . iterator ( ) ; milestone . description = itrProposal . next ( ) . toAscii ( ) ; milestone . url = itrProposal . next ( ) . toAscii ( ) ; milestone . minCompletionDate = itrProposal . next ( ) . toUint ( ) ; milestone . maxCompletionDate = itrProposal . next ( ) . toUint ( ) ; milestone . milestoneLeadLink = itrProposal . next ( ) . toAddress ( ) ; milestone . reviewer = itrProposal . next ( ) . toAddress ( ) ; milestone . reviewTime = itrProposal . next ( ) . toUint ( ) ; milestone . paymentSource = itrProposal . next ( ) . toAddress ( ) ; milestone . payData = itrProposal . next ( ) . toData ( ) ; milestone . status = MilestoneStatus . AcceptedAndInProgress ; } delete proposedMilestones ; changingMilestones = false ; NewMilestoneListAccepted ( ) ; }
function lock ( address _to , uint256 _value , uint256 _end ) internal validAddress ( _to ) onlyOwner returns ( bool ) { require ( _value > 0 ) ; assert ( totalProjectToken > 0 ) ; totalLockToken = totalLockToken . add ( _value ) ; assert ( totalProjectToken >= totalLockToken ) ; require ( allocations [ _to ] . value == 0 ) ; allocations [ _to ] = allocationLock ( { value : _value , end : _end , locked : true } ) ; Lock ( this , _to , _value , _end ) ; return true ; }
function takeOffItem ( uint _champId , uint8 _type ) public onlyOwnerOfChamp ( _champId ) { uint256 itemId ; Champ storage champ = champs [ _champId ] ; if ( _type == 1 ) { itemId = champ . eq_sword ; if ( itemId > 0 ) { champ . eq_sword = 0 ; } } if ( _type == 2 ) { itemId = champ . eq_shield ; if ( itemId > 0 ) { champ . eq_shield = 0 ; } } if ( _type == 3 ) { itemId = champ . eq_helmet ; if ( itemId > 0 ) { champ . eq_helmet = 0 ; } } if ( itemId > 0 ) { items [ itemId ] . onChamp = false ; } }
function balanceOf ( address _owner ) constant returns ( uint256 ) { return balances [ _owner ] ; }
function getReputationByFactory ( address _factoryAddress ) external view returns ( address [ ] ) ;
function kill ( bytes32 _hash ) external pollApproved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) { selfdestruct ( bthFoundationWallet ) ; }
function slowCancel ( bytes32 _offerHash ) external { require ( announcedCancellations [ _offerHash ] != 0 && announcedCancellations [ _offerHash ] <= now , "Insufficient delay" ) ; delete announcedCancellations [ _offerHash ] ; Offer memory offer = offers [ _offerHash ] ; _cancel ( _offerHash , offer . availableAmount , etherAddr , 0 ) ; }
function batchCreateETHCardAsset ( uint8 [ ] _teamId , uint256 [ ] _attributes , uint256 [ ] _playerOverrideId , uint256 [ ] _mlbPlayerId , address [ ] _to ) external canCreate whenNotPaused { require ( isBatchSupported ) ; require ( _teamId . length > 0 && _attributes . length > 0 && _playerOverrideId . length > 0 && _mlbPlayerId . length > 0 && _to . length > 0 ) ; uint256 assetDetails ; uint256 [ 5 ] memory _nftData ; for ( uint ii = 0 ; ii < _attributes . length ; ii ++ ) { require ( _to [ ii ] != address ( 0 ) && _teamId [ ii ] != 0 && _attributes . length != 0 && _mlbPlayerId [ ii ] != 0 ) ; assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( getSequenceId ( _teamId [ ii ] ) ) << 64 ; assetDetails |= uint256 ( _teamId [ ii ] ) << 96 ; assetDetails |= uint256 ( ( _attributes [ ii ] / 1000000000000000000000000000000000000000 ) - 800 ) << 104 ; _nftData = [ assetDetails , _attributes [ ii ] , 0 , _playerOverrideId [ ii ] , _mlbPlayerId [ ii ] ] ; _createNFTCollectible ( _teamId [ ii ] , _attributes [ ii ] , _to [ ii ] , 2 , _nftData ) ; } }
function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; assert ( getBlockNumber ( ) >= startBlock ) ; assert ( msg . sender == controller || getBlockNumber ( ) > endBlock || tokensForSale ( ) == 0 ) ; wct . changeController ( 0x0 ) ; finalizedBlock = getBlockNumber ( ) ; Finalized ( finalizedBlock ) ; }
function addSpender ( address _spender ) external onlyOwner { _validateAddress ( _spender ) ; whitelistedSpenders [ _spender ] = true ; }
function open ( bytes32 channelId , address receiver , uint32 settlingPeriod ) public payable { require ( isAbsent ( channelId ) ) ; channels [ channelId ] = PaymentChannel ( { sender : msg . sender , receiver : receiver , value : msg . value , settlingPeriod : settlingPeriod , settlingUntil : 0 } ) ; DidOpen ( channelId , msg . sender , receiver , msg . value ) ; }
function emergencyStopSale ( ) public only_sale_active onlyOwner { saleStopped = true ; }
function isTrusted ( address _from , address _to ) public view returns ( bool ) { return holders [ getHolderId ( _from ) ] . trust [ _to ] ; }
function isSettling ( bytes32 channelId ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; return channel . settlingUntil != 0 ; }
function kill ( ) public { if ( msg . sender == owner ) selfdestruct ( owner ) ; }
function _getTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { uint256 tokenAmount = _weiAmount . mul ( rate ) ; uint256 bonusTokens = tokenAmount . mul ( bonus ) . div ( 100 ) ; return tokenAmount . add ( bonusTokens ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( crowdsaleSuccessful ) ; require ( _to != address ( 0 ) ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; success = true ; }
function convertCarbonDollar ( address stablecoin , uint256 _amount ) public userNotBlacklisted ( msg . sender ) whenNotPaused { require ( isWhitelisted ( stablecoin ) , "Stablecoin must be whitelisted prior to setting conversion fee" ) ; WhitelistedToken whitelisted = WhitelistedToken ( stablecoin ) ; require ( whitelisted . balanceOf ( address ( this ) ) >= _amount , "Carbon escrow account in WT0 doesn't have enough tokens for burning" ) ; uint256 chargedFee = tokenStorage_CD . computeFee ( _amount , computeFeeRate ( stablecoin ) ) ; uint256 feedAmount = _amount . sub ( chargedFee ) ; _burn ( msg . sender , _amount ) ; require ( whitelisted . transfer ( msg . sender , feedAmount ) ) ; whitelisted . burn ( chargedFee ) ; _mint ( address ( this ) , chargedFee ) ; emit ConvertedToWT ( msg . sender , _amount ) ; }
function onERC721Received ( address _from , uint256 _tokenId , bytes data ) external returns ( bytes4 ) ;
function setBypassStatus ( address to , bool status ) public onlyOwner { freezeBypassing [ to ] = status ; }
function challengeWinnerReward ( uint _challengeID ) public view returns ( uint ) { if ( voting . getTotalNumberOfTokensForWinningOption ( _challengeID ) == 0 ) { return challenges [ _challengeID ] . stake . mul ( 2 ) ; } return challenges [ _challengeID ] . stake . mul ( 2 ) . sub ( challenges [ _challengeID ] . rewardPool ) ; }
function poll ( uint _idPoll ) public view returns ( uint _startBlock , uint _endTime , bool _canVote , bool _canceled , bytes _description , uint8 _numBallots , bool _finalized , uint _voters , address _author , uint [ 100 ] _tokenTotal , uint [ 100 ] _quadraticVotes , uint [ 100 ] _votersByBallot ) { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll storage p = _polls [ _idPoll ] ; _startBlock = p . startBlock ; _endTime = p . endTime ; _canceled = p . canceled ; _canVote = canVote ( _idPoll ) ; _description = p . description ; _numBallots = p . numBallots ; _author = p . author ; _finalized = ( ! p . canceled ) && ( block . number >= _endTime ) ; _voters = p . voters ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { _tokenTotal [ i ] = p . results [ i ] ; _quadraticVotes [ i ] = p . qvResults [ i ] ; _votersByBallot [ i ] = p . votersByBallot [ i ] ; } }
function isCampaignValid ( bytes32 bidId ) public view returns ( bool valid ) { uint startDate = advertisementStorage . getCampaignStartDateById ( bidId ) ; uint endDate = advertisementStorage . getCampaignEndDateById ( bidId ) ; bool validity = advertisementStorage . getCampaignValidById ( bidId ) ; uint nowInMilliseconds = now * 1000 ; return validity && startDate < nowInMilliseconds && endDate > nowInMilliseconds ; }
function mintWithData ( address _investor , uint256 _value , bytes _data ) external returns ( bool success ) ;
function destroy ( uint index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status != Status . destroyed ) ; require ( msg . sender == loan . lender || ( msg . sender == loan . borrower && loan . status == Status . initial ) ) ; DestroyedBy ( index , msg . sender ) ; if ( loan . status != Status . initial ) { lendersBalance [ loan . lender ] -= 1 ; activeLoans -= 1 ; Transfer ( loan . lender , 0x0 , index ) ; } loan . status = Status . destroyed ; return true ; }
function getPreICOBonus ( ) internal constant returns ( uint ) ;
function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( "pVoteQuorum" ) , get ( "pCommitStageLen" ) , get ( "pRevealStageLen" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( "pDispensationPct" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; var ( commitEndDate , revealEndDate , ) = voting . pollMap ( pollID ) ; _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate , msg . sender ) ; return pollID ; }
function signedAverage ( int256 a , int256 b ) public pure returns ( int256 ) { int256 ans = a + b ; if ( a > 0 && b > 0 && ans <= 0 ) { require ( false ) ; } if ( a < 0 && b < 0 && ans >= 0 ) { require ( false ) ; } return ans / 2 ; }
function emergencyRedeem ( uint shareQuantity , address [ ] requestedAssets ) public pre_cond ( balances [ msg . sender ] >= shareQuantity ) returns ( bool ) { address ofAsset ; uint [ ] memory ownershipQuantities = new uint [ ] ( requestedAssets . length ) ; address [ ] memory redeemedAssets = new address [ ] ( requestedAssets . length ) ; for ( uint i = 0 ; i < requestedAssets . length ; ++ i ) { ofAsset = requestedAssets [ i ] ; require ( isInAssetList [ ofAsset ] ) ; for ( uint j = 0 ; j < redeemedAssets . length ; j ++ ) { if ( ofAsset == redeemedAssets [ j ] ) { revert ( ) ; } } redeemedAssets [ i ] = ofAsset ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( address ( this ) ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; if ( assetHoldings == 0 ) continue ; ownershipQuantities [ i ] = mul ( assetHoldings , shareQuantity ) / _totalSupply ; if ( uint ( AssetInterface ( ofAsset ) . balanceOf ( address ( this ) ) ) < ownershipQuantities [ i ] ) { isShutDown = true ; emit ErrorMessage ( "CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy" ) ; return false ; } } annihilateShares ( msg . sender , shareQuantity ) ; for ( uint k = 0 ; k < requestedAssets . length ; ++ k ) { ofAsset = requestedAssets [ k ] ; if ( ownershipQuantities [ k ] == 0 ) { continue ; } else if ( ! AssetInterface ( ofAsset ) . transfer ( msg . sender , ownershipQuantities [ k ] ) ) { revert ( ) ; } } emit Redeemed ( msg . sender , now , shareQuantity ) ; return true ; }
function reclaimERC20 ( address _token , uint _tokens ) external returns ( bool _success ) { require ( msg . sender == fundsWallet ) ; return Token ( _token ) . transfer ( msg . sender , _tokens ) ; }
function emergencyWithdrawAdmin ( ) external hasFinalized onlyAdmin { require ( finalizedTime != 0 && now >= finalizedTime + 10 days ) ; msg . sender . transfer ( address ( this ) . balance ) ; }
function _verifyTransfer ( address _from , address _to , uint256 _value , bytes _data , bool _isTransfer ) internal checkGranularity ( _value ) returns ( bool ) { if ( ! transfersFrozen ) { bool isInvalid = false ; bool isValid = false ; bool isForceValid = false ; bool unarchived = false ; address module ; for ( uint256 i = 0 ; i < modules [ TRANSFER_KEY ] . length ; i ++ ) { module = modules [ TRANSFER_KEY ] [ i ] ; if ( ! modulesToData [ module ] . isArchived ) { unarchived = true ; ITransferManager . Result valid = ITransferManager ( module ) . verifyTransfer ( _from , _to , _value , _data , _isTransfer ) ; if ( valid == ITransferManager . Result . INVALID ) { isInvalid = true ; } else if ( valid == ITransferManager . Result . VALID ) { isValid = true ; } else if ( valid == ITransferManager . Result . FORCE_VALID ) { isForceValid = true ; } } } return unarchived ? ( isForceValid ? true : ( isInvalid ? false : isValid ) ) : true ; } return false ; }
function numberOfPossibleChoices ( ) public pure returns ( uint8 ) { return NUMBER_OF_CHOICES ; }
function _getTokenAmount ( uint256 _investedAmount ) internal view returns ( uint256 ) { return _investedAmount . mul ( rate ) ; }
function finalizeUpgrade ( ) external { if ( getState ( ) != State . Success ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; if ( finalizedUpgrade ) throw ; finalizedUpgrade = true ; upgradeAgent . finalizeUpgrade ( ) ; UpgradeFinalized ( msg . sender , upgradeAgent ) ; }
function tokensOfOwner ( address _owner ) public view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalCountries = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 countryId ; for ( countryId = 0 ; countryId < totalCountries ; countryId ++ ) { if ( countryIndexToOwner [ countryId ] == _owner ) { result [ resultIndex ] = countryId ; resultIndex ++ ; } } return result ; } }
function getPayeeBalance ( bytes32 _requestId , uint8 _payeeIndex ) public view returns ( int256 ) { if ( _payeeIndex == 0 ) { return requests [ _requestId ] . payee . balance ; } else { return subPayees [ _requestId ] [ _payeeIndex - 1 ] . balance ; } }
function getGameInfo ( uint gameId ) public view returns ( string , string , string ) { return ( games [ gameId ] . teamA , games [ gameId ] . teamB , games [ gameId ] . description ) ; }
function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { return transfersAllowed ; }
function transfer ( address _to , uint256 _value ) public { _transfer ( msg . sender , _to , _value ) ; }
function setTransferFeeRate ( uint _transferFeeRate ) external optionalProxy_onlyOwner { require ( _transferFeeRate <= MAX_TRANSFER_FEE_RATE , "Transfer fee rate must be below MAX_TRANSFER_FEE_RATE" ) ; transferFeeRate = _transferFeeRate ; emitTransferFeeUpdated ( _transferFeeRate ) ; }
function calcNav ( uint gav , uint unclaimedFees ) view returns ( uint nav ) { nav = sub ( gav , unclaimedFees ) ; }
function registerTicker ( address _owner , string _ticker , string _tokenName ) external ;
function vote ( uint _idPoll , uint [ ] _ballots ) public { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll storage p = _polls [ _idPoll ] ; require ( block . number >= p . startBlock && block . number < p . endBlock && ! p . canceled , "Poll is inactive" ) ; require ( _ballots . length == p . numBallots , "Number of ballots is incorrect" ) ; unvote ( _idPoll ) ; uint amount = token . balanceOfAt ( msg . sender , p . startBlock ) ; require ( amount != 0 , "No SNT balance available at start block of poll" ) ; p . voters ++ ; uint totalBallots = 0 ; for ( uint8 i = 0 ; i < _ballots . length ; i ++ ) { totalBallots += _ballots [ i ] ; p . ballots [ i ] [ msg . sender ] = _ballots [ i ] ; if ( _ballots [ i ] != 0 ) { p . qvResults [ i ] += sqrt ( _ballots [ i ] / 1 ether ) ; p . results [ i ] += _ballots [ i ] ; } } require ( totalBallots <= amount , "Total ballots must be less than the SNT balance at poll start block" ) ; emit Vote ( _idPoll , msg . sender , _ballots ) ; }
function ownerWithdrawParsecs ( uint256 value ) external onlyOwner { require ( contractFinished ) ; uint256 parsecBalance = parsecToken . balanceOf ( this ) ; uint256 maxAmountToWithdraw = parsecBalance . sub ( pendingParsecs ) ; require ( maxAmountToWithdraw > 0 ) ; require ( maxAmountToWithdraw <= parsecBalance ) ; require ( value > 0 ) ; require ( value <= maxAmountToWithdraw ) ; parsecToken . transfer ( owner , value ) ; }
function _payDividend ( address _payee , Dividend storage _dividend , uint256 _dividendIndex ) internal { uint256 claim = calculateDividend ( _dividendIndex , _payee ) ; _dividend . claimed [ _payee ] = true ; _dividend . claimedAmount = claim . add ( _dividend . claimedAmount ) ; if ( claim > 0 ) { if ( _payee . send ( claim ) ) { emit EtherDividendClaimed ( _payee , _dividendIndex , claim ) ; } else { _dividend . claimed [ _payee ] = false ; emit EtherDividendClaimFailed ( _payee , _dividendIndex , claim ) ; } } }
function getOldestPledgeNotCanceled ( uint64 idPledge ) internal constant returns ( uint64 ) { if ( idPledge == 0 ) return 0 ; Pledge storage p = findPledge ( idPledge ) ; PledgeAdmin storage admin = findAdmin ( p . owner ) ; if ( admin . adminType == PledgeAdminType . Giver ) return idPledge ; assert ( admin . adminType == PledgeAdminType . Project ) ; if ( ! isProjectCanceled ( p . owner ) ) return idPledge ; return getOldestPledgeNotCanceled ( p . oldPledge ) ; }
function setName ( string _name ) onlyOwner { name = _name ; LogSetName ( _name ) ; }
function resultFor ( bytes32 question_id ) external view returns ( bytes32 ) { }
function setController ( address _controller ) external onlymanyowners ( sha3 ( msg . data ) ) { m_controller = _controller ; ControllerSet ( m_controller ) ; }
function __callback ( bytes32 myid , string result , bytes proof ) public { require ( msg . sender == oraclize_cbAddress ( ) ) ; uint newPrice = parseInt ( result ) . mul ( 100 ) ; if ( newPrice >= m_ETHPriceLowerBound && newPrice <= m_ETHPriceUpperBound ) { m_ETHPriceInCents = newPrice ; m_ETHPriceLastUpdate = getTime ( ) ; NewETHPrice ( m_ETHPriceInCents ) ; } else { ETHPriceOutOfBounds ( newPrice ) ; } updateETHPriceInCents ( ) ; }
function adminshipLevel ( address _newAdmin , uint8 _level ) onlyAdmin ( 2 ) public { require ( _newAdmin != address ( 0 ) ) ; level [ _newAdmin ] = _level ; emit AdminshipUpdated ( _newAdmin , _level ) ; }
function addNewAirdrop ( string _name , uint _tokenAmount , uint _countDown , address _smartContract , uint _decimals ) public minEth payable { Token t = Token ( _smartContract ) ; if ( t . balanceOf ( this ) >= _tokenAmount ) { uint lastIndex = airdrops . length ++ ; Airdrop storage airdrop = airdrops [ lastIndex ] ; airdrop . name = _name ; airdrop . id = lastIndex ; airdrop . decimals = _decimals ; airdrop . tokenAmount = _tokenAmount ; airdrop . countDown = _countDown ; airdrop . gasFeePaid = msg . value ; airdrop . timeStamp = now ; airdrop . distributor = msg . sender ; airdrop . tokenSC = Token ( _smartContract ) ; } else revert ( 'Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop' ) ; }
function getApprovedProposals ( ) public view returns ( uint [ ] ) { uint count = 0 ; for ( uint i = 0 ; i < proposals . length ; i ++ ) { if ( proposals [ i ] . approved && ! proposals [ i ] . denied ) { count ++ ; } } uint [ ] memory approvedProposals = new uint [ ] ( count ) ; count = 0 ; for ( i = 0 ; i < proposals . length ; i ++ ) { if ( proposals [ i ] . approved && ! proposals [ i ] . denied ) { approvedProposals [ count ] = i ; count ++ ; } } return approvedProposals ; }
function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) ;
function claim ( ) public returns ( bool ) { return claimInternal ( msg . sender ) ; }
function authorizeOperator ( address _operator ) public whenNotPaused { require ( _operator != msg . sender , "You cannot authorize yourself as an operator" ) ; mAuthorized [ _operator ] [ msg . sender ] = true ; emit AuthorizedOperator ( _operator , msg . sender ) ; }
function authorizeSpender ( address _spender , bool _authorize ) onlyContractOwner { allowedSpenders [ _spender ] = _authorize ; SpenderAuthorization ( _spender , _authorize ) ; }
function addChunk1ToWhiteList ( ) external onlyOwner { require ( ! chunk1IsAdded ) ; addToWhitelist ( 0x2C66aDd04950eE3235fd3EC6BcB2577c88d804E4 , 0.5 ether ) ; addToWhitelist ( 0x008e2E5FC70a2bccB5857AE8591119B3B63fdbc2 , 0.5 ether ) ; addToWhitelist ( 0x0330cc41bDd33f820d92C2df591CD2A5cB99f792 , 0.5 ether ) ; addToWhitelist ( 0x0756ea3a926399c3da2d5bfc520b711bdadfd0b9 , 0.5 ether ) ; addToWhitelist ( 0x08c93a267832a8997a46f13b12faa2821d16a472 , 0.5 ether ) ; addToWhitelist ( 0x0B58dAeAB6D292B5B8A836643023F43E4D0d9b78 , 0.5 ether ) ; addToWhitelist ( 0x0b73f53885581caf26141b4bb5f8c192af611921 , 0.5 ether ) ; addToWhitelist ( 0x0be30C8338C76Cc3EF92734863B0A898d8C8fef4 , 0.5 ether ) ; addToWhitelist ( 0x0fb6829D5543F173d6bba244c2E21CB60544B7fA , 0.5 ether ) ; addToWhitelist ( 0x0fccb03ceb56e683fbcf0229c950d666def66d1d , 0.5 ether ) ; addToWhitelist ( 0x1578416c880a0F282bAc17c692b2A80b4336D29B , 0.5 ether ) ; addToWhitelist ( 0x16fc89d92592b88bc459e19717eEDD51732CfCA1 , 0.5 ether ) ; addToWhitelist ( 0x183feBd8828a9ac6c70C0e27FbF441b93004fC05 , 0.5 ether ) ; addToWhitelist ( 0x1A9D4a4DBb3Fb0750107406f4A7c9379DB42f7B3 , 0.5 ether ) ; addToWhitelist ( 0x1bB95a9c7d50B9b270a604674f4Ed35265087c40 , 0.5 ether ) ; addToWhitelist ( 0x1bf032d01bab6cd4a2d67ec251f5c3f09728a7e3 , 0.5 ether ) ; addToWhitelist ( 0x1C1f687165F982Fcd4672B4319AB966256B57b2e , 0.5 ether ) ; addToWhitelist ( 0x1E2B069ca94e0232A04A4D1317e120f903D41c3A , 0.5 ether ) ; addToWhitelist ( 0x21F23Bb7299Caa26D854DDC38E134E49997471Dd , 0.5 ether ) ; addToWhitelist ( 0x23437833ebf735cdaf526c2a2c24f57ca4726358 , 0.5 ether ) ; addToWhitelist ( 0x2389Ce4eFB2805Fd047C59Fa8991EA9c8361A9a0 , 0.5 ether ) ; addToWhitelist ( 0x248dd8D2b7991d94860c44A5F99fc1483964FBBf , 0.5 ether ) ; addToWhitelist ( 0x257D66c42623c108060a66e4ddE5c3813691Ef38 , 0.5 ether ) ; addToWhitelist ( 0x26D6F116a16efD1f8361c5Da90AEA4B26b564004 , 0.5 ether ) ; addToWhitelist ( 0x272899d5b1451B09De35161B11722C95E34f06A9 , 0.5 ether ) ; addToWhitelist ( 0x29F436906826a7d7Ef0B35292b4f285050108082 , 0.5 ether ) ; addToWhitelist ( 0x2A8Be3303C83e5E9699a8b4B70976577BFedeC71 , 0.5 ether ) ; addToWhitelist ( 0x2C351d47CE2737982D1E25FB6dfa30265913aEAa , 0.5 ether ) ; addToWhitelist ( 0x3cf2fC2cc45EACf1B6495Bf2AA69fbFC0d4b4a30 , 0.5 ether ) ; addToWhitelist ( 0x3Cf5f48Dd9bec4Eff46Ee1E2B9e64b2892B5E64F , 0.5 ether ) ; addToWhitelist ( 0x3D86C8A928E9595114e01bb0539bdD69e9EfDF3B , 0.5 ether ) ; addToWhitelist ( 0x3e825763457fd92a6cb46f5ee0b4969089997da8 , 0.5 ether ) ; addToWhitelist ( 0x3F4351eb6b1dd9a84890C1C89F4D4419Eb88f1Af , 0.5 ether ) ; addToWhitelist ( 0x459cc576ac8332f52ee93cb88228416a872bebd6 , 0.5 ether ) ; addToWhitelist ( 0x45c556aff90d5fe6e91d24874a8036693cec18d0 , 0.5 ether ) ; addToWhitelist ( 0x47449fa838794e665A648FA3e47208a7cd105c9D , 0.5 ether ) ; addToWhitelist ( 0x50405fB11735160056DBc40b92a09B4215501481 , 0.5 ether ) ; addToWhitelist ( 0x51DD5Ef09cF73312BADe4C6BA8e03d647730Ecc3 , 0.5 ether ) ; addToWhitelist ( 0x546A4F1eD47e853Ba119f55A20CbFeaa40ab70E6 , 0.5 ether ) ; addToWhitelist ( 0x549022ad5cd11816eb7ce6ea15ae61c1fb4edb8a , 0.5 ether ) ; addToWhitelist ( 0x5abDC3cB826fC0277D642c9FB52FA76FE3ABb4E7 , 0.5 ether ) ; addToWhitelist ( 0x5b65dfa08283e024c4ad09b5ea7212c539cb9dbf , 0.5 ether ) ; addToWhitelist ( 0x5cC69E09cA05004e5aDCdbE8C8Aac4D16A4651ed , 0.5 ether ) ; addToWhitelist ( 0x60a5550D1e43b63b3164F78F2D186bDb7D393C90 , 0.5 ether ) ; addToWhitelist ( 0x6111d340C833661840ec4c11e84a79a67bE8acCD , 0.5 ether ) ; addToWhitelist ( 0x61E140a78Ec39d373C182bf3eD23cBc1AC86023b , 0.5 ether ) ; addToWhitelist ( 0x62f12F6C3AD04DFACB10ae05fB54f1E997b0133e , 0.5 ether ) ; addToWhitelist ( 0x65276d60Ab36879a6BD88F040D350cd60630FD03 , 0.5 ether ) ; addToWhitelist ( 0x66B993F856d6175D11B98Be2cBc79EB1888B72f7 , 0.5 ether ) ; addToWhitelist ( 0x6806408fd066ccddceaecc0a6c6fbbdb2ae8259c , 0.5 ether ) ; addToWhitelist ( 0x6918a5b07c2f79a4b272bb7653a43438ca96cd3f , 0.5 ether ) ; addToWhitelist ( 0x697DE67DB7d462480418814831d52DA25917A12E , 0.5 ether ) ; chunk1IsAdded = true ; }
function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }
function withdrawTokens ( uint _value ) external ;
function setRegistrationFee ( uint256 _registrationFee ) public onlyOwner returns ( bool ) { require ( _registrationFee > 0 , "new registration fee must be greater than zero" ) ; require ( _registrationFee != registrationFee , "new registration fee must be different" ) ; registrationFee = _registrationFee ; emit RegistrationFeeUpdated ( msg . sender , _registrationFee ) ; return true ; }
function onBurn ( address _owner , uint _tokensToBurn ) public returns ( bool ) { require ( msg . sender == address ( tokenContract ) ) ; uint256 feeTotal = tokenContract . totalPledgedFees ( ) ; uint256 totalTokens = tokenContract . totalSupply ( ) ; uint256 feeValueOfTokens = ( feeTotal . mul ( _tokensToBurn ) ) . div ( totalTokens ) ; require ( tokenContract . destroyTokens ( _owner , _tokensToBurn ) ) ; require ( address ( this ) . balance >= feeValueOfTokens ) ; require ( _owner . send ( feeValueOfTokens ) ) ; emit LogClaim ( _owner , feeValueOfTokens ) ; return true ; }
function upgradeFinance ( address addrAdverFinance ) public onlyOwner ( "upgradeFinance" ) { BaseFinance newAdvFinance = BaseFinance ( addrAdverFinance ) ; address [ ] memory devList = advertisementFinance . getUserList ( ) ; for ( uint i = 0 ; i < devList . length ; i ++ ) { uint balance = advertisementFinance . getUserBalance ( devList [ i ] ) ; newAdvFinance . increaseBalance ( devList [ i ] , balance ) ; } uint256 initBalance = appc . balanceOf ( address ( advertisementFinance ) ) ; advertisementFinance . transferAllFunds ( address ( newAdvFinance ) ) ; uint256 oldBalance = appc . balanceOf ( address ( advertisementFinance ) ) ; uint256 newBalance = appc . balanceOf ( address ( newAdvFinance ) ) ; require ( initBalance == newBalance ) ; require ( oldBalance == 0 ) ; advertisementFinance = newAdvFinance ; }
function migrateCraftTokenMaster ( uint tokenId , address newMasterContract ) public onlyCLevel { CraftToken ( emojiCraftTokenAddress [ tokenId ] ) . setContractMaster ( newMasterContract ) ; }
function getRanking ( ) external view returns ( address [ ] , uint256 [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint256 [ ] memory arr_def = new uint256 [ ] ( len ) ; uint counter = 0 ; for ( uint k = 0 ; k < len ; k ++ ) { arr [ counter ] = getJadeProduction ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; ( , arr_def [ counter ] , , ) = getPlayersBattleStats ( players [ k ] . owneraddress ) ; counter ++ ; } for ( uint i = 0 ; i < len - 1 ; i ++ ) { for ( uint j = 0 ; j < len - i - 1 ; j ++ ) { if ( arr [ j ] < arr [ j + 1 ] ) { uint256 temp = arr [ j ] ; address temp_addr = arr_addr [ j ] ; uint256 temp_def = arr_def [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; arr_addr [ j ] = arr_addr [ j + 1 ] ; arr_addr [ j + 1 ] = temp_addr ; arr_def [ j ] = arr_def [ j + 1 ] ; arr_def [ j + 1 ] = temp_def ; } } } return ( arr_addr , arr , arr_def ) ; }
function proposalChecked ( address _sender , uint _proposalID , uint _amount ) constant external onlyClient returns ( bool ) { if ( _sender != recipient && _sender != creator ) return ; if ( _amount <= proposals [ _proposalID ] . amount - proposals [ _proposalID ] . submittedAmount ) return true ; }
function updateBytes20inBytes ( bytes data , uint offset , bytes20 b ) internal pure { require ( offset >= 0 && offset + 20 <= data . length , "offset value should be in the correct range" ) ; assembly { let m := mload ( add ( data , add ( 20 , offset ) ) ) m := and ( m , 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 ) m := or ( m , div ( b , 0x1000000000000000000000000 ) ) mstore ( add ( data , add ( 20 , offset ) ) , m ) } }
function refund ( ) external { if ( getState ( ) != State . Failure ) throw ; uint256 lunValue = balances [ msg . sender ] ; if ( lunValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalSupply = safeSub ( totalSupply , lunValue ) ; uint256 ethValue = safeDiv ( lunValue , tokensPerEther ) ; Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }
function userInfo ( uint256 _userId ) public view returns ( address , uint256 , uint256 , uint256 , uint256 [ ] , uint256 [ ] ) { User memory user = users [ _userId ] ; return ( user . addr , user . balance , user . totalPay , user . referrersReceived , user . resources , user . referrersByLevel ) ; }
function order ( uint _proposalID , uint _amount ) external returns ( bool ) ;
function reclaim ( IBasicToken token ) public { require ( token != PAYMENT_TOKEN , "NO_PAYMENT_TOKEN_RECLAIM" ) ; Reclaimable . reclaim ( token ) ; }
function registerApprove ( bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) public returns ( bool ) { uint256 index = identifierToIndex [ identifier ] ; require ( index != 0 ) ; Loan storage loan = loans [ index ] ; require ( loan . borrower == ecrecover ( keccak256 ( "\x19Ethereum Signed Message:\n32" , identifier ) , v , r , s ) ) ; loan . approbations [ loan . borrower ] = true ; ApprovedBy ( index , loan . borrower ) ; return true ; }
function withdrawTokens ( address _to , uint _amount ) external validAddress ( _to ) requiresState ( IcoState . FAILED ) onlymanyowners ( keccak256 ( msg . data ) ) { require ( ( _amount > 0 ) && ( m_token . balanceOf ( this ) >= _amount ) ) ; m_token . transfer ( _to , _amount ) ; }
function freezeAccount ( address account , bool isAllowed , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setAccountStatus ( account , isAllowed , issuerFirm ) , "Error: Unable to freeze account. Please check issuerFirm and firm authority are registered" ) ; return true ; }
function onICO ( address buyer , uint256 tokens ) public onlyOwner returns ( bool success ) { require ( isICORunning ) ; require ( isWhitelisted ( buyer ) , "Buyer is not whitelisted" ) ; require ( icoContract != address ( 0 ) ) ; require ( msg . sender == icoContract ) ; require ( tokens > 0 ) ; require ( buyer != address ( 0 ) ) ; require ( totalSupply_ . add ( tokens ) <= TOTAL_SUPPLY_LIMIT ) ; super . mint ( buyer , tokens ) ; emit Transfer ( address ( ICO_EVENT ) , buyer , tokens ) ; return true ; }
function transfer ( address _to , uint256 _value , bytes _data ) external isRunning requireThaw returns ( bool success ) { if ( _to == selfAddress ) { return transferToSelf ( _value , _data ) ; } else if ( isContract ( _to ) ) { return transferToContract ( _to , _value , _data ) ; } else { return transferToAddress ( _to , _value , _data ) ; } }
function sell ( uint256 amount ) public { require ( tradeActive == true ) ; require ( this . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
function mintToken ( address target , uint256 mintedAmount ) onlyOwner { balances [ target ] = balances [ target ] . add ( mintedAmount ) ; currentSupply = currentSupply . add ( mintedAmount ) ; Transfer ( 0 , this , mintedAmount ) ; Transfer ( this , target , mintedAmount ) ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( now >= Stage3Deadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else if ( state == State . Stage1 && now >= Stage1Deadline ) { state = State . Stage2 ; } else if ( state == State . Stage2 && now >= Stage2Deadline ) { state = State . Stage3 ; } }
function approve ( address _spender , uint256 _amount ) public whenNotPaused erc20 returns ( bool success ) { uint balanceAvailable = getAmountOfUnlockedTokens ( msg . sender ) ; require ( balanceAvailable >= _amount , "You can only approve an amount >= the amount of tokens currently unlocked for this account" ) ; mAllowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
function drainContract ( ) external onlyOwner { msg . sender . transfer ( address ( this ) . balance ) ; }
function cancelChampSale ( uint256 _id ) public champIsForSale ( _id ) onlyOwnerOfChamp ( _id ) { Champ storage champ = champs [ _id ] ; _cancelChampSale ( champ ) ; }
function transfer ( address _to , uint _value ) public returns ( bool ) { require ( balances [ msg . sender ] >= _value && balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function tick ( ) internal returns ( bool ) { if ( _now != now ) { _now = now ; uint256 _today ; ( , , end , ended , , , , , , , , ) = FoMoLong . round_ ( thisRoundIndex ) ; if ( ! ended ) { _today = _now / 1 days ; } else { _today = end / 1 days ; } while ( today < _today ) { issuedInsurance = issuedInsurance . sub ( unitToExpire [ today ] ) ; today += 1 ; } } return ended ; }
function updateStateChangeAgent ( address _agent , bool _status ) public onlyOwner { stateChangeAgents [ _agent ] = _status ; }
function _setProtocolVersion ( address _STFactoryAddress , uint8 _major , uint8 _minor , uint8 _patch ) internal { uint8 [ ] memory _version = new uint8 [ ] ( 3 ) ; _version [ 0 ] = _major ; _version [ 1 ] = _minor ; _version [ 2 ] = _patch ; uint24 _packedVersion = VersionUtils . pack ( _major , _minor , _patch ) ; require ( VersionUtils . isValidVersion ( getProtocolVersion ( ) , _version ) , "In-valid version" ) ; set ( Encoder . getKey ( "latestVersion" ) , uint256 ( _packedVersion ) ) ; set ( Encoder . getKey ( "protocolVersionST" , getUint ( Encoder . getKey ( "latestVersion" ) ) ) , _STFactoryAddress ) ; }
function withdraw ( uint256 summeInWei ) isOwner { uint256 contractbalance = this . balance ; address sender = msg . sender ; require ( contractbalance >= summeInWei ) ; withdrawed ( sender , summeInWei , "wei withdrawed" ) ; sender . transfer ( summeInWei ) ; }
function claimPayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( job . worker == msg . sender ) ; uint payment = job . paymentAvailableForWorker ; require ( payment > 0 ) ; job . paymentAvailableForWorker = 0 ; emit PaymentClaimed ( msg . sender , payment , _JobID ) ; DAI . transfer ( msg . sender , payment ) ; }
function _balanceOf ( address _owner ) internal view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return _ownedTokens [ _owner ] . length ; }
function updateRenExBalances ( RenExBalances _newRenExBalancesContract ) external onlyOwner { emit LogRenExBalancesUpdated ( renExBalancesContract , _newRenExBalancesContract ) ; renExBalancesContract = _newRenExBalancesContract ; }
function updateGenerationStopTime ( uint256 _season , uint8 _value ) public onlyManager whenNotPaused { require ( generationSeasonController [ _season ] == 1 && _value != 0 ) ; _updateGenerationSeasonFlag ( _season , _value ) ; }
function getTime ( ) internal returns ( uint256 ) { return now ; }
function cloneTokens ( uint _from , uint _to ) returns ( bool success ) ;
function isContract ( address _caller ) internal constant returns ( bool ) { uint size ; assembly { size := extcodesize ( _caller ) } return size > 0 ; }
function takeOwnership ( uint _divCardId ) public isNotContract { address newOwner = msg . sender ; address oldOwner = divCardIndexToOwner [ _divCardId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _divCardId ) ) ; _transfer ( oldOwner , newOwner , _divCardId ) ; }
function _removeFromDebtRegister ( bytes4 currencyKey , uint amount ) internal { uint debtToRemove = effectiveValue ( currencyKey , amount , "XDR" ) ; uint existingDebt = debtBalanceOf ( messageSender , "XDR" ) ; uint totalDebtIssued = totalIssuedSynths ( "XDR" ) ; uint debtPercentage = debtToRemove . divideDecimalRoundPrecise ( totalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . add ( debtPercentage ) ; if ( debtToRemove == existingDebt ) { synthetixState . clearIssuanceData ( messageSender ) ; synthetixState . decrementTotalIssuerCount ( ) ; } else { uint newDebt = existingDebt . sub ( debtToRemove ) ; uint newTotalDebtIssued = totalDebtIssued . sub ( debtToRemove ) ; uint newDebtPercentage = newDebt . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; synthetixState . setCurrentIssuanceData ( messageSender , newDebtPercentage ) ; } synthetixState . appendDebtLedgerValue ( synthetixState . lastDebtLedgerEntry ( ) . multiplyDecimalRoundPrecise ( delta ) ) ; }
function getInitFunction ( ) external pure returns ( bytes4 ) ;
function removeMember ( address _member ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( members [ _member ] == true ) ; delete members [ _member ] ; for ( uint256 i = 0 ; i < memberKeys . length ; i ++ ) { if ( memberKeys [ i ] == _member ) { delete memberKeys [ i ] ; break ; } } emit MemberRemoved ( _member ) ; }
function _resourcesAtTime ( FactoryType _type , uint8 _level , uint256 _collected_at ) public view returns ( uint256 ) { return worktimeAtDate ( _collected_at ) * ( getProductsPerMinute ( _type , _level ) + getBonusPerMinute ( _type , _level ) ) / 100 ; }
function addAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 validatorFee , bytes signature ) external payable ;
function giveMeCDP ( uint id ) public auth { tub . give ( bytes32 ( id ) , msg . sender ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { bool sucsSlrLmt = _chkSellerLmts ( msg . sender , _value ) ; bool sucsByrLmt = _chkBuyerLmts ( _to , _value ) ; require ( sucsSlrLmt == true && sucsByrLmt == true ) ; uint valtmp = _value ; uint _valueTemp = valtmp ; valtmp = 0 ; _transfer ( msg . sender , _to , _valueTemp ) ; _valueTemp = 0 ; return true ; }
function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; require ( beneficiary . send ( address ( this ) . balance ) ) ; tokenReward . transfer ( beneficiary , remanent ) ; emit LogBeneficiaryPaid ( beneficiary ) ; emit LogContributorsPayout ( beneficiary , remanent ) ; }
function getCertificationDocumentAtIndex ( address student , uint256 index ) payable requestFeePaid returns ( bytes32 document ) { document = studentCertifications [ student ] . documents [ index ] ; }
function auditSecret ( bytes32 _swapID ) external view onlyClosedSwaps ( _swapID ) returns ( bytes32 secretKey ) { Swap memory swap = swaps [ _swapID ] ; return swap . secretKey ; }
function finalizeApprovedContracts ( ) public onlyOwner { approvedContractsFinalized = true ; }
function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; doBuy ( _th ) ; return true ; }
function ( ) payable external { if ( ! funding ) revert ( ) ; if ( msg . value == 0 ) revert ( ) ; var numTokens = msg . value * ( 1000.0 / totalTokens ) ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
function issue ( uint256 _amount ) external authP ( ISSUE_ROLE , arr ( _amount ) ) { _mint ( address ( this ) , _amount ) ; }
function getNotaryForSeller ( address seller ) public view validAddress ( seller ) returns ( address ) { require ( hasSellerBeenAccepted ( seller ) ) ; SellerInfo memory info = sellerInfo [ seller ] ; return info . notary ; }
function description ( ) external view returns ( string ) ;
function transferOwnership ( address newOwner ) isOwner { assert ( newOwner != address ( 0 ) ) ; address oldOwner = owner ; owner = newOwner ; ownerChanged ( msg . sender , oldOwner , newOwner ) ; allowed [ this ] [ oldOwner ] = 0 ; allowed [ this ] [ newOwner ] = tokenBalanceOf [ this ] ; }
function getTokensSold ( ) public view returns ( uint256 ) { return totalTokensSold ; }
function transferFrom ( address from , address to , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value && safeAdd ( balances [ to ] , value ) > balances [ to ] ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { return false ; } }
function _transfer ( address _from , address _to , uint256 _amount , bytes _data ) internal returns ( bool success ) { require ( _to != 0x0 ) ; require ( _amount <= balanceOf ( _from ) ) ; uint256 initialBalances = balanceOf ( _from ) . add ( balanceOf ( _to ) ) ; balances [ _from ] = balanceOf ( _from ) . sub ( _amount ) ; balances [ _to ] = balanceOf ( _to ) . add ( _amount ) ; if ( isContract ( _to ) ) { ReceiverContract receiver = ReceiverContract ( _to ) ; receiver . tokenFallback ( _from , _amount , _data ) ; } assert ( initialBalances == balanceOf ( _from ) . add ( balanceOf ( _to ) ) ) ; return true ; }
function release ( ) public onlyOwnerOrCoOwner { _release ( ) ; }
function setLockQtyToAllowTrading ( uint qtyToLock ) external onlyOwner { lockQtyToAllowTrading = qtyToLock ; }
function getRegion ( uint256 _tokenId ) public view returns ( string regionName , uint256 sellingPrice , address owner ) { Region storage region = regions [ _tokenId ] ; regionName = region . name ; sellingPrice = regionIndexToPrice [ _tokenId ] ; owner = regionIndexToOwner [ _tokenId ] ; }
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) public returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallReceiver ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
function distributeBonuses ( ) public onlyOracleOrOwner onlySaleFinished notDestructed returns ( uint ) { ERC20Interface _token = ERC20Interface ( bonusToken ) ; uint _balance = _token . balanceOf ( address ( this ) ) ; if ( _balance == 0 ) { return _emitError ( EMISSION_PROVIDER_ERROR_INSUFFICIENT_BMC ) ; } Profiterole _profiterole = Profiterole ( profiterole ) ; if ( ! _token . approve ( address ( _profiterole ) , _balance ) ) { return _emitError ( EMISSION_PROVIDER_ERROR_INTERNAL ) ; } if ( OK != _profiterole . distributeBonuses ( _balance ) ) { revert ( ) ; } return OK ; }
function finalizeTS ( ) public returns ( bool ) ;
function getAmountToGive ( OrderData order ) public view onlySelf returns ( uint256 amountToGive ) { bytes32 orderHash = hashOrder ( order ) ; uint256 makeFee = exchange . makeFee ( ) ; uint256 takeFee = exchange . takeFee ( ) ; uint256 ethVolumeAvailable ; if ( order . isSell ) { uint256 tokenVolumeAvailable = Math . min ( exchange . sellOrderBalances ( orderHash ) , order . tokenAmount ) ; ethVolumeAvailable = SafeMath . div ( SafeMath . mul ( tokenVolumeAvailable , order . weiAmount ) , order . tokenAmount ) ; amountToGive = SafeMath . add ( ethVolumeAvailable , feeFromTotalCost ( ethVolumeAvailable , takeFee ) ) ; } else { ethVolumeAvailable = Math . min ( removeFee ( exchange . buyOrderBalances ( orderHash ) , makeFee ) , order . weiAmount ) ; amountToGive = SafeMath . div ( SafeMath . mul ( ethVolumeAvailable , order . tokenAmount ) , order . weiAmount ) ; } }
function revoke ( ERC20 token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . transfer ( owner , refund ) ; emit Revoked ( ) ; }
function ( ) public payable { buyTokens ( msg . sender ) ; }
function _setOracle ( address newOracle ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_ORACLE_OWNER_CHECK ) ; } PriceOracleInterface oracleInterface = PriceOracleInterface ( newOracle ) ; oracleInterface . assetPrices ( address ( 0 ) ) ; address oldOracle = oracle ; oracle = newOracle ; emit NewOracle ( oldOracle , newOracle ) ; return uint ( Error . NO_ERROR ) ; }
function deletePoll ( bytes32 _hash ) external onlymanyowners ( sha3 ( msg . data ) ) { Poll poll = polls [ _hash ] ; if ( poll . exists ) { delete polls [ _hash ] ; LogPollDeleted ( _hash ) ; } }
function getEstateSize ( uint256 estateId ) external view returns ( uint256 ) { return estateLandIds [ estateId ] . length ; }
function mintToken ( uint256 mintedAmount ) onlyOwner public { require ( _balanceOf [ _owner ] + mintedAmount >= _balanceOf [ _owner ] ) ; require ( _totalSupply + mintedAmount >= _totalSupply ) ; _balanceOf [ _owner ] += mintedAmount ; _totalSupply += mintedAmount ; Transfer ( 0 , _owner , mintedAmount ) ; }
function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( DASToken ) { DASToken newToken = new DASToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 18 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 36 ) ) ) { require ( collectedTokens < total . percent ( 50 ) ) ; canExtract = total . percent ( 50 ) ; } else { require ( collectedTokens < total ) ; canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }
function setAuthorizedContract ( string _contractName , address _authorizedAddress , bool _authorized ) external onlyContractOwner ( "ContractManager" , msg . sender ) { bytes memory contractNameBytes = bytes ( _contractName ) ; require ( contractNameBytes . length != 0 ) ; require ( _authorizedAddress != address ( 0 ) ) ; require ( authorization [ _contractName ] [ _authorizedAddress ] != _authorized ) ; authorization [ _contractName ] [ _authorizedAddress ] = _authorized ; emit AuthorizationChanged ( _authorizedAddress , _authorized , _contractName ) ; }
function renounceOwnership ( ) public onlyOwner { emit OwnershipTransferred ( owner , address ( 0 ) ) ; owner = address ( 0 ) ; }
function getSwimmersListArray ( ) public view returns ( address [ ] _arrayToReturn ) { _arrayToReturn = swimmersList ; }
function migrate ( ) onlyMigrationEnabled ( ) public ;
function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner public { sellTokenPerEther = newSellPrice ; buyTokenPerEther = newBuyPrice ; }
function orderConfirmer ( bytes32 _orderID ) external view returns ( address ) ;
function setMigrationAgent ( address _agent ) external { require ( migrationAgent == 0 ) ; require ( msg . sender == migrationMaster ) ; migrationAgent = _agent ; }
function spiceUp ( uint256 _gameIndex , string message ) external payable { _processGameEnd ( ) ; require ( _gameIndex == gameIndex ) ; require ( gameStates [ gameIndex ] . gameStarted || ! paused ) ; require ( msg . value > 0 ) ; gameStates [ gameIndex ] . prizePool = gameStates [ gameIndex ] . prizePool . add ( msg . value ) ; SpiceUpPrizePool ( gameIndex , msg . sender , msg . value , message , gameStates [ gameIndex ] . prizePool ) ; }
function getRaisedPOLY ( ) public view returns ( uint256 ) ;
function requestMortgageId ( Engine engine , uint256 loanId , uint256 deposit , uint256 landId , TokenConverter tokenConverter ) public returns ( uint256 id ) { require ( engine . getCurrency ( loanId ) == MANA_CURRENCY , "Loan currency is not MANA" ) ; address borrower = engine . getBorrower ( loanId ) ; require ( engine . getStatus ( loanId ) == Engine . Status . initial , "Loan status is not inital" ) ; require ( msg . sender == engine . getBorrower ( loanId ) || ( msg . sender == engine . getCreator ( loanId ) && creators [ msg . sender ] ) , "Creator should be borrower or authorized" ) ; require ( engine . isApproved ( loanId ) , "Loan is not approved" ) ; require ( rcn . allowance ( borrower , this ) >= REQUIRED_ALLOWANCE , "Manager cannot handle borrower's funds" ) ; require ( tokenConverter != address ( 0 ) , "Token converter not defined" ) ; require ( loanToLiability [ engine ] [ loanId ] == 0 , "Liability for loan already exists" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 loanAmount = engine . getAmount ( loanId ) ; require ( ( loanAmount + deposit ) >= ( ( landCost / 10 ) * 11 ) , "Not enought total amount" ) ; _tokenTransferFrom ( mana , msg . sender , this , deposit ) ; id = mortgages . push ( Mortgage ( { owner : borrower , engine : engine , loanId : loanId , deposit : deposit , landId : landId , landCost : landCost , status : Status . Pending , tokenConverter : tokenConverter } ) ) - 1 ; loanToLiability [ engine ] [ loanId ] = id ; emit RequestedMortgage ( { _id : id , _borrower : borrower , _engine : engine , _loanId : loanId , _landId : landId , _deposit : deposit , _tokenConverter : tokenConverter } ) ; }
function setAccountStatus ( Data storage self , address account , bool isAllowed , string issuerFirm ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.allowed' , getForwardedAccount ( self , account ) ) ) ; require ( self . Storage . setBool ( id , isAllowed ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; emit AccountStatus ( account , isAllowed , issuerFirm ) ; return true ; }
function calculateCommission ( uint32 _canvasId ) public view stateOwned ( _canvasId ) returns ( uint commission , bool isPaid ) { Bid storage bid = bids [ _canvasId ] ; Canvas storage canvas = _getCanvas ( _canvasId ) ; return ( _calculateCommission ( bid . amount ) , canvas . isCommissionPaid ) ; }
function removeRole ( address addr , string role ) public onlyOwnerOrAdmin { roles [ addr ] [ role ] = false ; emit RoleRemoved ( addr , role ) ; }
function addOfficialOperator ( address _operator ) external onlyOwner { require ( _operator . isContract ( ) , "An official operator must be a contract." ) ; require ( ! mIsOfficialOperator [ _operator ] , "_operator is already an official operator." ) ; mIsOfficialOperator [ _operator ] = true ; emit OfficialOperatorAdded ( _operator ) ; }
function transferTokensToUser ( address tokenAddress , uint256 tokenAmount ) internal { if ( tokenAmount > 0 ) { if ( ! ERC20SafeTransfer . safeTransfer ( tokenAddress , msg . sender , tokenAmount ) ) { errorReporter . revertTx ( "Unable to transfer tokens to user" ) ; } } }
function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
function totalSupply ( ) public view returns ( uint ) { return players . length ; }
function updateMinimumEpochInterval ( uint256 _nextMinimumEpochInterval ) external onlyOwner { nextMinimumEpochInterval = _nextMinimumEpochInterval ; }
function reparametrizeMultisig ( bytes32 msigId , uint unlockTime ) public payable { require ( multisigs [ msigId ] . owner == msg . sender ) ; Multisig storage multisig = multisigs [ msigId ] ; multisig . deposit = add ( multisig . deposit , msg . value ) ; assert ( multisig . unlockTime <= unlockTime ) ; multisig . unlockTime = unlockTime ; emit MultisigReparametrized ( msigId ) ; }
function sendTransaction ( address to , uint256 value , bytes data ) public onlyOwner returns ( bool ) { return to . call . value ( value ) ( data ) ; }
function forward ( bytes _evmScript ) public { require ( canForward ( msg . sender , _evmScript ) , ERROR_CAN_NOT_FORWARD ) ; bytes memory input = new bytes ( 0 ) ; address [ ] memory blacklist = new address [ ] ( 1 ) ; blacklist [ 0 ] = address ( token ) ; runScript ( _evmScript , input , blacklist ) ; }
function ( ) payable public { require ( isContract ( controller ) ) ; require ( ITokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) == true ) ; }
function ( ) payable { IncomingTx ( block . number , msg . sender , msg . value , now ) ; }
function transferMinusFees ( address _to , uint256 _value , uint128 _totalGasFeesSpentByRelayer , uint16 _fee ) private { uint256 _totalFees = ( _value * _fee / 10000 ) + _totalGasFeesSpentByRelayer ; if ( _value - _totalFees > _value ) { return ; } feesAvailableForWithdraw += _totalFees ; _to . transfer ( _value - _totalFees ) ; }
function claimAssetPack ( uint _assetPackId ) public { require ( approvedTakeover [ _assetPackId ] == msg . sender ) ; approvedTakeover [ _assetPackId ] = address ( 0 ) ; assetPacks [ _assetPackId ] . creator = msg . sender ; }
function createDividend ( uint256 _maturity , uint256 _expiry ) payable public onlyOwner { require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( msg . value > 0 ) ; uint256 dividendIndex = dividends . length ; uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupply ( ) ; dividends . push ( Dividend ( checkpointId , now , _maturity , _expiry , msg . value , 0 , currentSupply , false ) ) ; emit EtherDividendDeposited ( msg . sender , checkpointId , now , _maturity , _expiry , msg . value , currentSupply , dividendIndex ) ; }
function list_indexed_bytesarray ( bytes32 _collection_index , uint256 _count , function ( bytes32 ) external constant returns ( bytes32 ) _function_first , function ( bytes32 ) external constant returns ( bytes32 ) _function_last , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _indexed_bytes_items ) { if ( _from_start ) { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _function_first ( _collection_index ) , _count , true , _function_last , _function_next ) ; } else { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _function_last ( _collection_index ) , _count , true , _function_first , _function_previous ) ; } }
function mint ( uint256 _stakeNumber ) public validMint ( _stakeNumber ) returns ( bool ) { uint256 mintAmount = calculateMint ( _stakeNumber ) ; stakes [ msg . sender ] [ _stakeNumber ] . coinsMinted = stakes [ msg . sender ] [ _stakeNumber ] . coinsMinted . add ( mintAmount ) ; stakes [ msg . sender ] [ _stakeNumber ] . lastBlockWithdrawn = block . number ; emit StakeRewardWithdrawn ( msg . sender , _stakeNumber , mintAmount ) ; require ( RTI . mint ( msg . sender , mintAmount ) , "token minting failed" ) ; return true ; }
function doSellerRequestCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return false ; } if ( _escrow . sellerCanCancelAfter != 1 ) { return false ; } escrows [ _tradeHash ] . sellerCanCancelAfter = uint32 ( block . timestamp ) + requestCancellationMinimumTime ; emit SellerRequestedCancel ( _tradeHash ) ; if ( msg . sender == relayer ) { increaseGasSpent ( _tradeHash , GAS_doSellerRequestCancel + _additionalGas ) ; } return true ; }
function detachController ( ) external onlyController { address was = m_controller ; m_controller = address ( 0 ) ; ControllerRetired ( was ) ; }
function retrieveFunds ( ) public onlyController { uint sntBalance = SNT . balanceOf ( address ( this ) ) ; require ( SNT . transfer ( msg . sender , sntBalance ) , "Transfer did not work" ) ; }
function setPrice ( address asset , uint requestedPriceMantissa ) public returns ( uint ) { if ( msg . sender != poster ) { return failOracle ( asset , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PRICE_PERMISSION_CHECK ) ; } return setPriceInternal ( asset , requestedPriceMantissa ) ; }
function ( ) public payable { uint256 size ; address sender = msg . sender ; assembly { size := extcodesize ( sender ) } require ( size > 0 ) ; }
function setStop ( ) onlyOwnerOrCoOwner { isStopped = true ; }
function checkGoalReached ( ) public afterDeadline { if ( ! goalChecked ) { if ( _checkFundingGoalReached ( ) ) { emit GoalReached ( beneficiary , tokenSold , amountRaisedETH ) ; } if ( ! crowdsaleClosed ) { crowdsaleClosed = true ; emit SaleClosed ( ) ; } goalChecked = true ; } }
function setAddressAlias ( address oldAddr , address newAddr ) public onlyRole ( roleAddressAliaser ( ) ) { require ( addressAlias [ oldAddr ] == address ( 0 ) , "oldAddr is already aliased to another address" ) ; require ( addressAlias [ newAddr ] == address ( 0 ) , "newAddr is already aliased to another address" ) ; require ( oldAddr != newAddr , "oldAddr and newAddr must be different" ) ; setAddressAliasUnsafe ( oldAddr , newAddr ) ; }
function transfer ( address to , uint tokens ) public tokenTradingMustBeLive ( msg . sender ) returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ; }
function init ( ) public onlyContractOwner onlyInit returns ( uint ) { needInitialization = false ; bytes32 _symbol = Token ( token ) . smbl ( ) ; if ( OK != Platform ( Token ( token ) . platform ( ) ) . reissueAsset ( _symbol , tokenSoftcap ) ) { revert ( ) ; } return OK ; }
function getInvestorsAt ( uint256 _checkpointId ) external view returns ( address [ ] ) { uint256 count = 0 ; uint256 i ; for ( i = 0 ; i < investorData . investors . length ; i ++ ) { if ( balanceOfAt ( investorData . investors [ i ] , _checkpointId ) > 0 ) { count ++ ; } } address [ ] memory investors = new address [ ] ( count ) ; count = 0 ; for ( i = 0 ; i < investorData . investors . length ; i ++ ) { if ( balanceOfAt ( investorData . investors [ i ] , _checkpointId ) > 0 ) { investors [ count ] = investorData . investors [ i ] ; count ++ ; } } return investors ; }
function initAtx ( address _proxy , address _serviceController , address _dataController , uint _lockupDate ) onlyContractOwner public returns ( bool ) { require ( _serviceController != 0x0 ) ; require ( _dataController != 0x0 ) ; require ( _proxy != 0x0 ) ; require ( _lockupDate > now || _lockupDate == 0 ) ; if ( ! super . init ( ATxProxy ( _proxy ) ) ) { return false ; } serviceController = ServiceController ( _serviceController ) ; dataController = DataController ( _dataController ) ; lockupDate = _lockupDate ; return true ; }
function registerNotary ( address notary , string name , string notaryUrl , string publicKey ) public onlyOwner whenNotPaused validAddress ( notary ) returns ( bool ) { bool isNew = notaryInfo [ notary ] . addr == address ( 0 ) ; require ( allowedNotaries . insert ( notary ) ) ; notaryInfo [ notary ] = NotaryInfo ( notary , name , notaryUrl , publicKey ) ; if ( isNew ) { emit NotaryRegistered ( notary ) ; } else { emit NotaryUpdated ( notary ) ; } return true ; }
function takeOwnership ( uint256 _deedId ) external whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; takeOwnershipMultiple ( _deedIds ) ; }
function totalSupply ( ) public view returns ( uint supply ) { return lib . getTokenSupply ( lib . getTokenSymbol ( address ( this ) ) ) ; }
function getInstructions ( ) external view returns ( string ) { return "Initialises a USD tiered STO." ; }
function withdrawFunds ( uint256 _amount ) external whenNotPaused onlyAdmin { require ( _amount <= address ( this ) . balance ) ; msg . sender . transfer ( _amount ) ; emit FundsWithdrawn ( msg . sender , _amount ) ; }
function getAttributeTypeID ( uint256 index ) external view returns ( uint256 ) { require ( index < _attributeIDs . length , "provided index is outside of the range of defined attribute type IDs" ) ; return _attributeIDs [ index ] ; }
function removeTokenFrom ( address _from , uint256 _tokenId ) internal { uint64 [ ] storage ownedList = ownedTokens [ _from ] ; TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner == _from , "From address is incorrect" ) ; lookupData . owner = address ( 0 ) ; uint64 replacementTokenIndex = ownedList [ ownedList . length - 1 ] ; delete ownedList [ ownedList . length - 1 ] ; ownedList . length -- ; if ( lookupData . ownedIndex < ownedList . length ) { ownedList [ lookupData . ownedIndex ] = replacementTokenIndex ; tokenLookup [ pixelcons [ replacementTokenIndex ] . tokenId ] . ownedIndex = lookupData . ownedIndex ; } lookupData . ownedIndex = 0 ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value && balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value > 0 ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function linkAddresses ( address _currentAddress , bytes _currentAddressSig , address _newAddress , bytes _newAddressSig , bytes32 _nonce ) external { require ( linkIds [ _newAddress ] == 0 ) ; validateLinkSignature ( _currentAddress , _newAddress , _nonce , _currentAddressSig ) ; validateLinkSignature ( _newAddress , _currentAddress , _nonce , _newAddressSig ) ; if ( linkIds [ _currentAddress ] == 0 ) { linkIds [ _currentAddress ] = ++ linkCounter ; } linkIds [ _newAddress ] = linkIds [ _currentAddress ] ; emit AddressLinked ( _currentAddress , _newAddress , linkIds [ _currentAddress ] ) ; }
function setAllocation ( address _beneficiary , uint256 _amount ) external onlyOwner vaultLoading returns ( bool ) { require ( _beneficiary != address ( 0 ) , "Beneficiary of allocation must not be blank" ) ; require ( _amount != 0 , "Amount of allocation must not be zero" ) ; require ( allocations [ _beneficiary ] == 0 , "Allocation amount for this beneficiary is not already set" ) ; allocations [ _beneficiary ] = allocations [ _beneficiary ] . add ( _amount ) ; tokensAllocated = tokensAllocated . add ( _amount ) ; emit Allocated ( _beneficiary , _amount ) ; return true ; }
function availableBalanceOf ( address _owner ) public view returns ( uint256 ) { uint256 balance = balances [ _owner ] ; for ( uint cellIndex = 0 ; cellIndex < frozenBalances [ _owner ] . length ; ++ cellIndex ) { if ( isSpendableFrozenCell ( _owner , cellIndex ) ) balance = balance . add ( frozenBalances [ _owner ] [ cellIndex ] . amount ) ; } return balance ; }
function claimTokens ( address _token ) onlyController public { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } Token token = Token ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }
function setTransferLockFree ( ) onlyAdmin public { require ( lockTransfer == true ) ; lockTransfer = false ; SetTransferLock ( lockTransfer ) ; }
function viewTokenMeta ( uint256 _tokenId ) external view returns ( uint256 tokenType_ , string specialQuality_ , string tokenTitle_ , string tokenDescription_ , string iptcKeyword_ , string imageDescription_ , string tokenClass_ , string originalImageUrl_ ) { tokenType_ = tokenTypes [ _tokenId ] ; tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescriptions [ _tokenId ] ; specialQuality_ = specialQualities [ _tokenId ] ; iptcKeyword_ = iptcKeywords [ _tokenId ] ; imageDescription_ = imageDescriptions [ _tokenId ] ; tokenClass_ = tokenClasses [ _tokenId ] ; originalImageUrl_ = originalImageUrls [ _tokenId ] ; }
function whitelistAddress ( address _user , bool _flag ) public onlyAdmin ( 1 ) { whiteList [ _user ] = _flag ; }
function setShp ( address _shp ) public onlyOwner { shp = SHP ( _shp ) ; }
function purchase ( uint256 _productId , uint256 _numCycles , address _assignee , address _affiliate ) external payable whenNotPaused returns ( uint256 ) { require ( _productId != 0 ) ; require ( _numCycles != 0 ) ; require ( _assignee != address ( 0 ) ) ; require ( msg . value == costForProductCycles ( _productId , _numCycles ) ) ; if ( ! isSubscriptionProduct ( _productId ) ) { require ( _numCycles == 1 ) ; } uint256 attributes = uint256 ( keccak256 ( block . blockhash ( block . number - 1 ) ) ) ^ _productId ^ ( uint256 ( _assignee ) ) ; uint256 licenseId = _performPurchase ( _productId , _numCycles , _assignee , attributes , _affiliate ) ; if ( priceOf ( _productId ) > 0 && _affiliate != address ( 0 ) && _affiliateProgramIsActive ( ) ) { _handleAffiliate ( _affiliate , _productId , licenseId , msg . value ) ; } return licenseId ; }
function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { return transfersAllowed ; }
function buyTokensPostHook ( address _beneficiary , uint256 _tokens , uint256 _toFund ) internal { }
function burnFrom ( address _from , uint _value ) public onlyOwner returns ( bool success ) { require ( balanceOf [ _from ] >= _value ) ; balanceOf [ _from ] -= _value ; totalSupply -= _value ; emit Burn ( _from , _value ) ; return true ; }
function unlockedCollateral ( address account ) public view returns ( uint ) { uint locked = lockedCollateral ( account ) ; uint collat = collateral ( account ) ; return safeSub ( collat , locked ) ; }
function getRarePLATInfo ( uint256 _tokenId ) external view returns ( uint256 sellingPrice , address owner , uint256 nextPrice , uint256 rareClass , uint256 cardId , uint256 rareValue ) { RareCard storage rarecard = rareArray [ _tokenId ] ; sellingPrice = SafeMath . mul ( IndexToPrice [ _tokenId ] , PLATPrice ) ; owner = IndexToOwner [ _tokenId ] ; nextPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 125 ) , 100 ) ; rareClass = rarecard . rareClass ; cardId = rarecard . cardId ; rareValue = rarecard . rareValue ; }
function recoverToVault ( address _token ) public isInitialized transitionsPeriod { uint256 amount = _token == ETH ? address ( this ) . balance : ERC20 ( _token ) . balanceOf ( this ) ; require ( amount > 0 , ERROR_RECOVER_AMOUNT_ZERO ) ; _deposit ( _token , amount , "Recover to Vault" , this , false ) ; }
function transferTickerOwnership ( address _newOwner , string _ticker ) external whenNotPausedOrOwner { string memory ticker = Util . upper ( _ticker ) ; require ( _newOwner != address ( 0 ) , "Invalid address" ) ; bytes32 ownerKey = Encoder . getKey ( "registeredTickers_owner" , ticker ) ; require ( getAddress ( ownerKey ) == msg . sender , "Not authorised" ) ; if ( _tickerStatus ( ticker ) ) require ( IOwnable ( getAddress ( Encoder . getKey ( "tickerToSecurityToken" , ticker ) ) ) . owner ( ) == _newOwner , "New owner does not match token owner" ) ; _deleteTickerOwnership ( msg . sender , ticker ) ; _setTickerOwnership ( _newOwner , ticker ) ; set ( ownerKey , _newOwner ) ; emit ChangeTickerOwnership ( ticker , msg . sender , _newOwner ) ; }
function blacklisted ( ) public view requiresPermission returns ( bool ) { return true ; }
function remainingIssuableNomins ( address issuer ) view public returns ( uint ) { uint issued = nominsIssued [ issuer ] ; uint max = maxIssuableNomins ( issuer ) ; if ( issued > max ) { return 0 ; } else { return safeSub ( max , issued ) ; } }
function totalSupply ( ) public constant returns ( uint256 _totalSupply ) ;
function setBurnAddress ( address _address ) onlyOwner { burnAddress = _address ; ledger . setBurnAddress ( _address ) ; token . setBurnAddress ( _address ) ; }
function removeModerator ( address _removeMod ) public onlyAdmin notFrozen returns ( bool success ) { moderators [ _removeMod ] = false ; ModeratorRemoved ( msg . sender , _removeMod , true ) ; return true ; }
function registerDevices ( bytes32 [ ] _deviceIdHashes , bytes32 [ ] _deviceTypes , bytes32 [ ] _devicePublicKeys ) public onlyManufacturer whenNotPaused returns ( bool ) { require ( _deviceIdHashes . length > 0 , "at least one device is required" ) ; require ( _deviceIdHashes . length == _deviceTypes . length , "device type array needs to be same size as devices" ) ; require ( _deviceIdHashes . length == _devicePublicKeys . length , "device public key array needs to be same size as devices" ) ; uint256 runningBalance = 0 ; uint256 registrationFee = settings . registrationFee ( ) ; for ( uint256 i = 0 ; i < _deviceIdHashes . length ; i ++ ) { bytes32 deviceIdHash = _deviceIdHashes [ i ] ; bytes32 deviceType = _deviceTypes [ i ] ; bytes32 devicePublicKey = _devicePublicKeys [ i ] ; Device memory d = _registerDevice ( msg . sender , deviceIdHash , deviceType , devicePublicKey ) ; emit DeviceRegistered ( msg . sender , registrationFee , deviceIdHash , d . manufacturerId , deviceType ) ; runningBalance = runningBalance . add ( registrationFee ) ; } _depositTokens ( msg . sender , runningBalance ) ; require ( token . transferFrom ( msg . sender , address ( this ) , runningBalance ) , "transferFrom failed" ) ; return true ; }
function _updatePurchasingState ( address _beneficiary , uint256 _weiAmount ) internal { super . _updatePurchasingState ( _beneficiary , _weiAmount ) ; uint256 purchasedTokens = _getTokenAmount ( _weiAmount ) ; tokensRaised = tokensRaised . add ( purchasedTokens ) ; if ( capReached ( ) ) { emit CapOverflow ( _beneficiary , _weiAmount , purchasedTokens ) ; } }
function addAddressesToWhitelist ( address [ ] _addresses ) public onlyWhitelister { for ( uint i = 0 ; i < _addresses . length ; ++ i ) addToWhitelist ( _addresses [ i ] ) ; }
function purgeAccount ( address account ) external onlyOwner onlyDuringSetup { delete vestingSchedules [ account ] ; totalVestedBalance = totalVestedBalance . sub ( totalVestedAccountBalance [ account ] ) ; delete totalVestedAccountBalance [ account ] ; }
function withdraw ( uint256 amount ) external onlyOwner { _token . safeTransfer ( owner ( ) , amount ) ; }
function changeController ( address _newController ) onlyController public { controller = _newController ; }
function calculateToFund ( address _beneficiary , uint256 _weiAmount ) internal view returns ( uint256 ) { uint256 weiAmount = _weiAmount ; uint8 currentStage ; bool onSale ; ( currentStage , onSale ) = getStageIndex ( ) ; require ( onSale ) ; Stage memory p = stages [ currentStage ] ; if ( p . kyc ) { require ( super . registered ( _beneficiary ) ) ; } require ( weiAmount >= uint ( p . minPurchaseLimit ) ) ; if ( p . maxPurchaseLimit != 0 && weiAmount > uint ( p . maxPurchaseLimit ) ) { weiAmount = uint ( p . maxPurchaseLimit ) ; } if ( p . cap > 0 ) { uint256 postWeiRaised = uint256 ( p . weiRaised ) . add ( weiAmount ) ; if ( postWeiRaised > p . cap ) { weiAmount = uint256 ( p . cap ) . sub ( p . weiRaised ) ; } } return super . calculateToFund ( _beneficiary , weiAmount ) ; }
function isInitialized ( ) public view returns ( bool ) { return true ; }
function getCurrencyAddress ( ) external view returns ( address ) { return currencyAddress ; }
function setEtherFeeMin ( uint256 min ) public onlyOwner { etherFeeMin = min ; }
function mConfirmPayment ( uint [ ] pledgesAmounts ) { for ( uint i = 0 ; i < pledgesAmounts . length ; i ++ ) { uint64 idPledge = uint64 ( pledgesAmounts [ i ] & ( D64 - 1 ) ) ; uint amount = pledgesAmounts [ i ] / D64 ; confirmPayment ( idPledge , amount ) ; } }
function mintOnce ( string _key , address _to , uint256 _amount ) private whenNotPaused whenNotMinted ( _key ) returns ( bool ) { mintingList [ computeHash ( _key ) ] = true ; return mintTokens ( _to , _amount ) ; }
function updatePollDescription ( uint _idPoll , bytes _description , uint8 _numBallots ) public { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; require ( _numBallots <= 100 , "Only a max of 100 ballots are allowed" ) ; Poll storage p = _polls [ _idPoll ] ; require ( p . startBlock > block . number , "You cannot modify an active poll" ) ; require ( p . author == msg . sender || msg . sender == controller , "Only the owner/controller can modify the poll" ) ; p . numBallots = _numBallots ; p . description = _description ; p . author = msg . sender ; }
function contains ( string source , string query ) internal pure returns ( bool ) { return indexOf ( source , query ) != - 1 ; }
function balanceOf ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return ownerToRareArray [ _owner ] . length ; }
function removeValidatorApproval ( address validator , uint256 attributeTypeID ) external ;
function destroy ( ) public auth { require ( stopped ) ; selfdestruct ( msg . sender ) ; }
function optOut ( ) public returns ( bool ) { if ( userOptOutVersion [ msg . sender ] != 0x0 ) { return false ; } userOptOutVersion [ msg . sender ] = latestVersion ; return true ; }
function changeHolderCount ( uint256 _maxHolderCount ) public withPerm ( ADMIN ) { emit ModifyHolderCount ( maxHolderCount , _maxHolderCount ) ; maxHolderCount = _maxHolderCount ; }
function transfer ( address _to , uint256 _value ) { _transfer ( msg . sender , _to , _value ) ; }
function sendWithSignature ( address _to , uint256 _amount , uint256 _fee , bytes _data , uint256 _nonce , bytes _sig ) public returns ( bool ) { doSendWithSignature ( _to , _amount , _fee , _data , _nonce , _sig , true ) ; return true ; }
function getUserList ( ) public view onlyAllowed returns ( address [ ] _userList ) { return users ; }
function setTradingLive ( ) public onlyOwner { tradingLive = true ; }
function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { bytes32 orderHash ; bytes32 prefixedHash ; ( orderHash , prefixedHash ) = getOrderHash ( data ) ; return ( data . takerAddress != data . makerAddress && data . expiration >= block . timestamp && ecrecover ( prefixedHash , data . v , data . r , data . s ) == data . makerAddress && ! exchange . fills ( orderHash ) && data . takerAddress == address ( this ) && Utils . tokenAllowanceAndBalanceSet ( data . makerAddress , data . makerToken , data . makerAmount , address ( exchange ) ) ) ; }
function modifyWhitelist ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit ModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }
function rentOutMultiple ( address _to , uint256 _rentPeriod , uint256 [ ] _deedIds ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( validIdentifier ( _deedId ) ) ; require ( identifierToRentPeriodEndTimestamp [ _deedId ] < now ) ; require ( _owns ( msg . sender , _deedId ) ) ; _rentOut ( _to , _rentPeriod , _deedId ) ; } }
function thaw ( ) external privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { m_frozen = false ; }
function getEndTime ( ) internal constant returns ( uint ) { return getStartTime ( ) + ( 5 days ) ; }
function isReserved ( string _symbol , address _owner , string _tokenName , bytes32 _swarmHash ) public returns ( bool ) ;
function setVault ( address _newVaultAddress ) onlyOwner public { vaultAddress = _newVaultAddress ; }
function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return approved [ _owner ] [ _spender ] ; }
function unpause ( ) public onlyCOO { require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
function collect ( ) external onlyAuthorized { owner . transfer ( address ( this ) . balance ) ; }
function _getCampaign ( bytes32 campaignId ) internal returns ( CampaignLibrary . Campaign storage _campaign ) { return campaigns [ campaignId ] ; }
function setQuestionFee ( address realitycheck , uint256 fee ) onlyOwner public { RealityCheckAPI ( realitycheck ) . setQuestionFee ( fee ) ; LogSetQuestionFee ( fee ) ; }
function cancelSaleWhenPaused ( uint256 _tokenId ) external whenPaused onlyGameManager { Sale memory sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; _cancelSale ( _tokenId , seller ) ; }
function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
function withdrawPayments ( address payee ) external nonReentrant onlyOwner requiresState ( State . REFUNDING ) { uint256 payment = m_weiBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }
function disableTokenTransfers ( ) public onlyAdmin whenNotPaused { require ( released ) ; released = false ; emit TokenReleased ( released ) ; }
function buyTokensLowLevel ( address _beneficiary , uint256 _weisAmount ) private stopInEmergency returns ( uint256 tokenAmount ) { if ( _beneficiary == 0x0 ) { revert ( 'buyTokensLowLevel: _beneficiary == 0x0' ) ; } if ( timestamp ( ) < startTime || timestamp ( ) > endTime ) { revert ( 'buyTokensLowLevel: Not withinPeriod' ) ; } if ( ! SCWhitelist . isInvestor ( _beneficiary ) ) { revert ( 'buyTokensLowLevel: Investor is not registered on the whitelist' ) ; } if ( isFinalized ) { revert ( 'buyTokensLowLevel: ICO is already finalized' ) ; } if ( _weisAmount < weisMinInvestment ) { revert ( 'buyTokensLowLevel: Minimal investment not reached. Not enough ethers to perform the minimal purchase' ) ; } if ( weisRaised . add ( _weisAmount ) > weisHardCap ) { revert ( 'buyTokensLowLevel: HardCap reached. Not enough tokens on ICO contract to perform this purchase' ) ; } tokenAmount = _weisAmount . mul ( weisPerEther ) . div ( weisPerBigToken ) ; tokenAmount = tokenAmount . mul ( 100 ) . div ( discountedPricePercentage ) ; weisRaised = weisRaised . add ( _weisAmount ) ; if ( ! SCTokens . transfer ( _beneficiary , tokenAmount ) ) { revert ( 'buyTokensLowLevel: unable to transfer tokens from ICO contract to beneficiary' ) ; } emit BuyTokensLowLevel ( msg . sender , _beneficiary , _weisAmount , tokenAmount ) ; return tokenAmount ; }
function stopPreSales ( ) onlyOwner public { isPreSales = false ; }
function resumeContribution ( ) onlyOwner { paused = false ; }
function tokensup ( uint256 _value ) onlyowner public { totalBhinneka = safeAdd ( totalBhinneka , _value * ( 10 ** decimals ) ) ; balances [ owner ] = safeAdd ( balances [ owner ] , _value * ( 10 ** decimals ) ) ; }
function adminWithdraw ( address _to ) public onlyAdmin validAddress ( _to ) { _to . transfer ( address ( this ) . balance ) ; }
function transfer ( address _to , uint256 _value ) public notContractAddress ( _to ) returns ( bool success ) { require ( ! tokenFrozen ) ; require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function decreaseApproval ( address _spender , uint256 _subtractedValue ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) ) ; return super . decreaseApproval ( _spender , _subtractedValue ) ; }
function validateNameInternal ( string _name ) constant internal returns ( bool allowed ) { bytes memory nameBytes = bytes ( _name ) ; uint lengthBytes = nameBytes . length ; if ( lengthBytes < minimumNameLength || lengthBytes > maximumNameLength ) { return false ; } bool foundNonPunctuation = false ; for ( uint i = 0 ; i < lengthBytes ; i ++ ) { byte b = nameBytes [ i ] ; if ( ( b >= 48 && b <= 57 ) || ( b >= 65 && b <= 90 ) || ( b >= 97 && b <= 122 ) ) { foundNonPunctuation = true ; continue ; } if ( b == 32 || b == 33 || b == 40 || b == 41 || b == 45 || b == 46 || b == 95 ) { continue ; } return false ; } return foundNonPunctuation ; }
function unlock ( ) public { if ( now < unlockedAt ) throw ; if ( ! teamMultisig . send ( address ( this ) . balance ) ) throw ; Unlocked ( ) ; }
function verifyModule ( address _moduleFactory , bool _verified ) external ;
function forward ( ) public payable { require ( msg . value > 0 ) ; weiCollected += msg . value ; internalForward ( ) ; }
function sendPending ( ) returns ( bool ) ;
function getInstructions ( ) public view returns ( string ) { return "Create a ERC20 dividend which will be paid out to token holders proportional to their balances at the point the dividend is created" ; }
function rollbackTransfer ( address _from , address _to , uint _value ) onlyPayloadSize ( 3 * 32 ) { require ( multiSigAddress == msg . sender ) ; balances [ _to ] = balances [ _to ] . sub ( _value ) ; balances [ _from ] = balances [ _from ] . add ( _value ) ; LogRollbackTransfer ( _from , _to , _value ) ; Transfer ( _from , _to , _value ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ;
function setup ( address _tokenAddress ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _tokenAddress != 0x0 ) ; token = LetsbetToken ( _tokenAddress ) ; tokensAuctioned = token . balanceOf ( address ( this ) ) ; tokenMultiplier = 10 ** uint ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; }
function resetWinner ( ) public { require ( grace ) ; require ( now > timeOfWin + 30 days ) ; grace = false ; winner = 0 ; ownersBalance = 0 ; pot = address ( this ) . balance ; }
function enableTransfers ( bool _isTransferEnabled ) public onlyAdmin { isTransferEnabled = _isTransferEnabled ; TransferStatus ( msg . sender , isTransferEnabled ) ; }
function unlock ( ) public onlyOwner { unlocked = true ; }
function donate ( uint64 idGiver , uint64 idReceiver ) payable { if ( idGiver == 0 ) { idGiver = addGiver ( "" , "" , 259200 , ILiquidPledgingPlugin ( 0x0 ) ) ; } PledgeAdmin storage sender = findAdmin ( idGiver ) ; checkAdminOwner ( sender ) ; require ( sender . adminType == PledgeAdminType . Giver ) ; uint amount = msg . value ; require ( amount > 0 ) ; vault . transfer ( amount ) ; uint64 idPledge = findOrCreatePledge ( idGiver , new uint64 [ ] ( 0 ) , 0 , 0 , 0 , PledgeState . Pledged ) ; Pledge storage nTo = findPledge ( idPledge ) ; nTo . amount += amount ; Transfer ( 0 , idPledge , amount ) ; transfer ( idGiver , idPledge , amount , idReceiver ) ; }
function _mint ( address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; _addTokenTo ( _to , _tokenId ) ; emit Transfer ( address ( 0 ) , _to , _tokenId ) ; }
function getContentByID ( ContentMapping storage self , bytes32 _id ) public view returns ( Content storage _content , bool exists ) { return ( self . data [ _id ] , self . data [ _id ] . id == bytes32 ( 0 ) ) ; }
function getTokenAmount ( uint256 weiAmount ) internal view returns ( uint256 ) { uint256 bonus = computeBonus ( weiAmount ) ; uint256 rateWithBonus = rate . mul ( coeff . add ( bonus ) ) . div ( coeff ) ; return weiAmount . mul ( rateWithBonus ) ; }
function setToken ( MintableToken _token ) public onlyOwner { token = _token ; }
function decimals ( ) public view returns ( uint _decimals ) { return lib . getTokenDecimals ( lib . getTokenSymbol ( address ( this ) ) ) ; }
function removeApprovedContractAddress ( address contractAddress ) public onlyOwner { require ( ! approvedContractsFinalized ) ; approvedContractAddresses [ contractAddress ] = false ; }
function reissueAsset ( bytes32 _symbol , uint _value ) public onlyOneOfOwners ( _symbol ) returns ( uint ) { if ( _value == 0 ) { return _error ( ATX_PLATFORM_INVALID_VALUE ) ; } Asset storage asset = assets [ _symbol ] ; if ( ! asset . isReissuable ) { return _error ( ATX_PLATFORM_CANNOT_REISSUE_FIXED_ASSET ) ; } if ( asset . totalSupply + _value < asset . totalSupply ) { return _error ( ATX_PLATFORM_SUPPLY_OVERFLOW ) ; } uint holderId = getHolderId ( msg . sender ) ; asset . wallets [ holderId ] . balance = asset . wallets [ holderId ] . balance . add ( _value ) ; asset . totalSupply = asset . totalSupply . add ( _value ) ; Emitter ( eventsHistory ) . emitIssue ( _symbol , _value , _address ( holderId ) ) ; _proxyTransferEvent ( 0 , holderId , _value , _symbol ) ; return OK ; }
function getValidatorSigningKey ( address validator ) external view returns ( address signingKey ) ;
function deposit ( Data storage self , uint256 amount ) returns ( bool success , uint256 balance ) { uint8 index ; require ( self . opened > 0 ) ; require ( self . closed == 0 ) ; require ( self . token . balanceOf ( msg . sender ) >= amount ) ; index = index_or_throw ( self , msg . sender ) ; Participant storage participant = self . participants [ index ] ; success = self . token . transferFrom ( msg . sender , this , amount ) ; if ( success == true ) { balance = participant . balance ; balance += amount ; participant . balance = balance ; return ( true , balance ) ; } return ( false , 0 ) ; }
function deleteDelegate ( address _delegate ) external withPerm ( CHANGE_PERMISSION ) { require ( delegateDetails [ _delegate ] != bytes32 ( 0 ) , "delegate does not exist" ) ; for ( uint256 i = 0 ; i < allDelegates . length ; i ++ ) { if ( allDelegates [ i ] == _delegate ) { allDelegates [ i ] = allDelegates [ allDelegates . length - 1 ] ; allDelegates . length = allDelegates . length - 1 ; } } delete delegateDetails [ _delegate ] ; }
function orderStatus ( bytes32 _orderID ) external view returns ( uint8 ) ;
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function unarchiveModule ( address _module ) external onlyOwner { TokenLib . unarchiveModule ( modulesToData [ _module ] , _module ) ; }
function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = ADMIN ; return allPermissions ; }
function releaseToEarlyInvestors ( address _beneficiary , uint256 _releaseAmount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , "Beneficiary is not whitelisted" ) ; require ( now >= releaseTimeToUnlockEarlyInvestorTokens , "Release Early Investors tokens on or after GMT: Wednesday, 21 August 2019 00:00:00" ) ; uint256 releaseAmount = _releaseAmount . mul ( E18 ) ; require ( totalTokensIssuedToEarlyInvestors . add ( releaseAmount ) <= EARLY_INVESTORS_SUPPLY_LIMIT ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( releaseAmount ) ; totalTokensIssuedToEarlyInvestors = totalTokensIssuedToEarlyInvestors . add ( releaseAmount ) ; emit Released ( _releaseAmount ) ; }
function claimManyAddresses ( uint256 _startIndex , uint256 _numberOfAddresses ) public isValidIndex ( _startIndex , _numberOfAddresses ) { uint256 endIndex = _startIndex . add ( _numberOfAddresses . sub ( 1 ) ) ; claimAddressesInternal ( _startIndex , endIndex ) ; }
function finalizeNextUpgrade ( ) external { if ( nextUpgradeAgent . owner ( ) == 0x0 ) revert ( ) ; if ( msg . sender != nextUpgradeMaster ) revert ( ) ; if ( finalizedNextUpgrade ) revert ( ) ; finalizedNextUpgrade = true ; nextUpgradeAgent . finalizeUpgrade ( ) ; UpgradeFinalized ( msg . sender , nextUpgradeAgent ) ; }
function getSetupCost ( ) external view returns ( uint256 ) ;
function getCampaignEndPointById ( bytes32 _bidId ) public returns ( string _endPoint ) { return campaignEndPoints [ _bidId ] ; }
function tokenBurner ( uint256 _amount ) public onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( totalSupply . sub ( _amount ) > 0 ) ; require ( balances [ msg . sender ] > _amount ) ; require ( balances [ msg . sender ] . sub ( _amount ) > 0 ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; emit Transfer ( msg . sender , 0 , _amount ) ; return true ; }
function initialize ( string _name , string _symbol ) public onlyInit { require ( bytes ( _name ) . length != 0 ) ; require ( bytes ( _symbol ) . length != 0 ) ; configureToken ( _name , _symbol ) ; initialized ( ) ; }
function set ( uint _fee ) onlyOwner returns ( bool ) { value = _fee ; return true ; }
function _transfer ( address _to , uint256 _tokenId ) private { address from = nft [ _tokenId ] . owner ; clearApproval ( _tokenId ) ; removeNFToken ( from , _tokenId ) ; addNFToken ( _to , _tokenId ) ; emit Transfer ( from , _to , _tokenId ) ; }
function changeOwnership ( address _newOwner ) external onlyOwner { require ( _newOwner != 0x0 ) ; address oldOwner = owner ; owner = _newOwner ; newOwnerCandidate = 0x0 ; emit OwnershipTransferred ( oldOwner , owner ) ; }
function updateGameTimes ( uint secondsPerPeriod , uint8 numberOfPeriods ) public onlyOwner { PLAYER_TURN_SINGLE_PERIOD = secondsPerPeriod ; PLAYER_START_PERIODS = numberOfPeriods ; }
function tokenMinter ( uint256 _amount ) internal view returns ( bool valid ) { require ( tokenMintingEnabled ) ; require ( _amount > 0 ) ; require ( totalSupply . add ( _amount ) > 0 ) ; require ( totalSupply . add ( _amount ) > totalSupply ) ; return true ; }
function changeHatchEscapeCaller ( address _newEscapeHatchCaller ) onlyEscapeHatchCallerOrOwner { escapeHatchCaller = _newEscapeHatchCaller ; }
function setAccessManager ( address _accessManager ) external onlyContractOwner returns ( uint ) { require ( _accessManager != 0x0 ) ; accessManager = _accessManager ; return OK ; }
function multiMint ( uint nonce , uint256 [ ] bits ) onlyOwner { require ( ! mintingStopped ) ; if ( nonce != mintingNonce ) return ; mintingNonce += 1 ; uint256 lomask = ( 1 << 96 ) - 1 ; uint created = 0 ; for ( uint i = 0 ; i < bits . length ; i ++ ) { address a = address ( bits [ i ] >> 96 ) ; uint value = bits [ i ] & lomask ; balanceOf [ a ] = balanceOf [ a ] + value ; controller . ledgerTransfer ( 0 , a , value ) ; created += value ; } totalSupply += created ; }
function collectTokens ( ) public onlyOwner { uint256 balance = token . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finishTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 14 days ) ) ; uint256 canExtract = total . mul ( getTime ( ) . sub ( finalizedTime ) ) . div ( months ( 12 ) ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; require ( token . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }
function burn ( uint256 _value ) public returns ( bool success ) { require ( balanceOf [ msg . sender ] > _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; emit Burn ( msg . sender , _value ) ; return true ; }
function clearIssuanceData ( address account ) external onlyAssociatedContract { delete issuanceData [ account ] ; }
function transferOwnership ( address _newOwner ) public onlyOwner ( ) { require ( _newOwner != address ( 0 ) ) ; owner = _newOwner ; }
function proxyClaimTokens ( address receiverAddress ) public atStage ( Stages . AuctionEnded ) returns ( bool ) { require ( now > finalizedTime + TOKEN_CLAIM_WAITING_PERIOD ) ; require ( receiverAddress != 0x0 ) ; if ( bids [ receiverAddress ] == 0 ) { return false ; } uint num = ( tokenMultiplier * bids [ receiverAddress ] ) / finalPrice ; uint auctionTokensBalance = token . balanceOf ( address ( this ) ) ; if ( num > auctionTokensBalance ) { num = auctionTokensBalance ; } fundsClaimed += bids [ receiverAddress ] ; bids [ receiverAddress ] = 0 ; require ( token . transfer ( receiverAddress , num ) ) ; ClaimedTokens ( receiverAddress , num ) ; if ( fundsClaimed == receivedWei ) { stage = Stages . TokensDistributed ; TokensDistributed ( ) ; } assert ( token . balanceOf ( receiverAddress ) >= num ) ; assert ( bids [ receiverAddress ] == 0 ) ; return true ; }
function transferOwnership ( address _newOwner ) public onlyOwner { newOwner = _newOwner ; }
function issueAttribute ( address account , uint256 attributeTypeID , uint256 value ) external payable ;
function claimTokens ( address _token ) auth { if ( _token == 0x0 ) { address ( msg . sender ) . transfer ( address ( this ) . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( address ( msg . sender ) , balance ) ; emit ClaimedTokens ( _token , address ( msg . sender ) , balance ) ; }
function claimFees ( bytes4 currencyKey ) external optionalProxy returns ( bool ) { uint availableFees = feesAvailable ( messageSender , "XDR" ) ; require ( availableFees > 0 , "No fees available for period, or fees already claimed" ) ; lastFeeWithdrawal [ messageSender ] = recentFeePeriods [ 1 ] . feePeriodId ; _recordFeePayment ( availableFees ) ; _payFees ( messageSender , availableFees , currencyKey ) ; emitFeesClaimed ( messageSender , availableFees ) ; return true ; }
function cancelPayment ( uint64 idPledge , uint amount ) onlyVault { Pledge storage p = findPledge ( idPledge ) ; require ( p . pledgeState == PledgeState . Paying ) ; uint64 oldPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; oldPledge = normalizePledge ( oldPledge ) ; doTransfer ( idPledge , oldPledge , amount ) ; }
function creatorOf ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( address ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , "PixelCon does not exist" ) ; return pixelcons [ lookupData . tokenIndex ] . creator ; }
function requestCosign ( Engine engine , uint256 index , bytes data , bytes oracleData ) public returns ( bool ) { Mortgage storage mortgage = mortgages [ uint256 ( readBytes32 ( data , 0 ) ) ] ; require ( mortgage . engine == engine , "Engine does not match" ) ; require ( mortgage . loanId == index , "Loan id does not match" ) ; require ( mortgage . status == Status . Pending , "Mortgage is not pending" ) ; require ( engines [ engine ] , "Engine not authorized" ) ; mortgage . status = Status . Ongoing ; _generate ( uint256 ( readBytes32 ( data , 0 ) ) , mortgage . owner ) ; uint256 loanAmount = convertRate ( engine . getOracle ( index ) , engine . getCurrency ( index ) , oracleData , engine . getAmount ( index ) ) ; require ( rcn . transferFrom ( mortgage . owner , this , loanAmount ) , "Error pulling RCN from borrower" ) ; uint256 boughtMana = convertSafe ( mortgage . tokenConverter , rcn , mana , loanAmount ) ; delete mortgage . tokenConverter ; uint256 currentLandCost ; ( , , currentLandCost , ) = mortgage . landMarket . auctionByAssetId ( mortgage . landId ) ; require ( currentLandCost <= mortgage . landCost , "Parcel is more expensive than expected" ) ; require ( mana . approve ( mortgage . landMarket , currentLandCost ) , "Error approving mana transfer" ) ; flagReceiveLand = mortgage . landId ; mortgage . landMarket . executeOrder ( mortgage . landId , currentLandCost ) ; require ( mana . approve ( mortgage . landMarket , 0 ) , "Error removing approve mana transfer" ) ; require ( flagReceiveLand == 0 , "ERC721 callback not called" ) ; require ( land . ownerOf ( mortgage . landId ) == address ( this ) , "Error buying parcel" ) ; land . setUpdateOperator ( mortgage . landId , mortgage . owner ) ; uint256 totalMana = boughtMana . add ( mortgage . deposit ) ; uint256 rest = totalMana . sub ( currentLandCost ) ; require ( mana . transfer ( mortgage . owner , rest ) , "Error returning MANA" ) ; require ( mortgage . engine . cosign ( index , 0 ) , "Error performing cosign" ) ; mortgageByLandId [ mortgage . landId ] = uint256 ( readBytes32 ( data , 0 ) ) ; emit StartedMortgage ( uint256 ( readBytes32 ( data , 0 ) ) ) ; return true ; }
function unpause ( ) public onlyOwner { super . _unpause ( ) ; }
function mintToken ( address _target , uint256 _mintedAmount ) onlyOwner { require ( _target != 0x0 ) ; balanceOf [ _target ] += _mintedAmount ; _totalSupply += _mintedAmount ; Transfer ( 0 , this , _mintedAmount ) ; Transfer ( this , _target , _mintedAmount ) ; }
function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; personIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
function safeWithdrawal ( ) public afterDeadline { require ( crowdsaleClosed , "crowdsale must be closed" ) ; if ( ! fundingGoalReached ) { require ( customer [ msg . sender ] . amountRaisedEther > 0 , "message sender has not raised any ether to this contract" ) ; uint256 amount = customer [ msg . sender ] . amountRaisedEther ; customer [ msg . sender ] . amountRaisedEther = 0 ; msg . sender . transfer ( amount ) ; emit FundsWithdrawal ( msg . sender , amount ) ; } else { require ( beneficiary == msg . sender , "message sender is not the beneficiary" ) ; uint256 ethAmount = address ( this ) . balance ; beneficiary . transfer ( ethAmount ) ; emit FundsWithdrawal ( beneficiary , ethAmount ) ; uint256 founderToken = ( tokenSold - minTokenSell ) * ( maxFounderToken - minFounderToken ) / ( maxTokenSell - minTokenSell ) + minFounderToken - ( maxBountyToken - tokenLeftForBounty ) ; require ( tokenReward . transfer ( beneficiary , founderToken ) , "founder token transfer failed" ) ; emit FounderTokenTransfer ( beneficiary , founderToken ) ; uint256 rdaToken = ( tokenSold - minTokenSell ) * ( maxRDAToken - minRDAToken ) / ( maxTokenSell - minTokenSell ) + minRDAToken ; require ( tokenReward . transfer ( beneficiary , rdaToken ) , "RDA token transfer failed" ) ; emit RDATokenTransfer ( beneficiary , rdaToken ) ; tokenReward . burn ( tokenReward . balanceOf ( this ) ) ; } }
function withdraw ( ) public { uint toTransfer = pendingReturns [ msg . sender ] ; require ( toTransfer > 0 ) ; pendingReturns [ msg . sender ] = 0 ; msg . sender . transfer ( toTransfer ) ; }
function onApprove ( address _owner , address _spender , uint256 _amount ) returns ( bool ) { return true ; }
function totalSupply ( ) public view returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }
function addAddressToAccountForUser ( address _newAddress , bytes _newAddressSig , bytes _senderSig , address _sender , bytes32 _nonce ) private nonZero ( _newAddress ) { require ( ! usedSignatures [ keccak256 ( abi . encodePacked ( _newAddressSig ) ) ] , "Signature not unique" ) ; require ( ! usedSignatures [ keccak256 ( abi . encodePacked ( _senderSig ) ) ] , "Signature not unique" ) ; usedSignatures [ keccak256 ( abi . encodePacked ( _newAddressSig ) ) ] = true ; usedSignatures [ keccak256 ( abi . encodePacked ( _senderSig ) ) ] = true ; bytes32 _currentAddressDigest = signingLogic . generateAddAddressSchemaHash ( _newAddress , _nonce ) ; require ( _sender == signingLogic . recoverSigner ( _currentAddressDigest , _senderSig ) ) ; bytes32 _newAddressDigest = signingLogic . generateAddAddressSchemaHash ( _sender , _nonce ) ; require ( _newAddress == signingLogic . recoverSigner ( _newAddressDigest , _newAddressSig ) ) ; registry . addAddressToAccount ( _newAddress , _sender ) ; uint256 _accountId = registry . accountIdForAddress ( _newAddress ) ; emit AddressAdded ( _accountId , _newAddress ) ; }
function disablePrivileged ( ) external privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { m_allowPrivileged = false ; }
function finalize ( ) public returns ( bool ) { require ( super . finalize ( ) ) ; require ( finishMinting ( ) ) ; return true ; }
function externalContribution ( address _contributor , uint256 _wei ) public payable { require ( externalContributionAgents [ msg . sender ] ) ; internalContribution ( _contributor , _wei ) ; }
function removeMember ( address userAddress ) public isMember ( userAddress ) onlyOwner { uint256 refund = cancelMembershipInternal ( userAddress ) ; emit AdminRemovedMember ( msg . sender , userAddress , refund ) ; }
function burn ( uint256 value ) returns ( bool success ) { require ( balances [ msg . sender ] > value && value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; currentSupply = currentSupply . sub ( value ) ; Burn ( msg . sender , value ) ; return true ; }
function ( ) public payable { require ( ( msg . value >= 100000000000000000 ) && ( rateMe != 0 ) ) ; uint value = msg . value * rateMe ; require ( value / msg . value == rateMe ) ; token . transfer ( msg . sender , value ) ; }
function depositEther ( ) payable returns ( bool ) { ErrorReport ( tx . origin , 0 , 0 ) ; DepositToken ( ETH_TOKEN_ADDRESS , msg . value ) ; return true ; }
function burnBid ( uint _index ) public onlyOwner { require ( status == state . ended ) ; require ( bids_sorted_count == 0 ) ; require ( bids [ _index ] . exist == true ) ; require ( bids [ _index ] . is_decrypted == false ) ; require ( bids [ _index ] . is_burned == false ) ; bids_burned [ bids_burned_count ] = _index ; bids_burned_count ++ ; bids_decrypted [ bids_decrypted_count ] = _index ; bids_decrypted_count ++ ; bids [ _index ] . is_burned = true ; emit BidBurned ( _index ) ; }
function getAttributeValue ( address account , uint256 attributeTypeID ) external view returns ( uint256 value ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; require ( ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) , "could not find an attribute value at the provided address and ID" ) ; return _issuedAttributes [ account ] [ attributeTypeID ] . value ; }
function totalSupply ( ) public view returns ( uint ) { return dogs . length - 1 ; }
function setMaxSecurityGuardDelay ( uint _maxSecurityGuardDelay ) onlyOwner { maxSecurityGuardDelay = _maxSecurityGuardDelay ; }
function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; tokenReward . transfer ( creator , remanent ) ; LogContributorsPayout ( creator , remanent ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public notContractAddress ( _to ) returns ( bool success ) { require ( ! tokenFrozen ) ; require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value <= allowances [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; balances [ _to ] += _value ; allowances [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) , "Invalid address" ) ; IERC20 token = IERC20 ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( msg . sender , balance ) , "Transfer failed" ) ; }
function claimPlotWithData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; claimPlotMultipleWithData ( _deedIds , name , description , imageUrl , infoUrl ) ; }
function ( ) external payable { require ( msg . value > 0 ) ; }
function refundTokens ( address _buyer , uint256 tokens ) external onlyCrowdsale whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( balances [ _buyer ] >= tokens ) ; balances [ _buyer ] = balances [ _buyer ] . sub ( tokens ) ; RefundedTokens ( _buyer , tokens ) ; }
function release ( ) public { require ( block . timestamp >= releaseTime ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; require ( amount > 0 ) ; token . transfer ( beneficiary , amount ) ; }
function askQuestion ( uint256 template_id , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { require ( templates [ template_id ] > 0 ) ; bytes32 content_hash = keccak256 ( template_id , opening_ts , question ) ; bytes32 question_id = keccak256 ( content_hash , arbitrator , timeout , msg . sender , nonce ) ; _askQuestion ( question_id , content_hash , arbitrator , timeout , opening_ts ) ; LogNewQuestion ( question_id , msg . sender , template_id , question , content_hash , arbitrator , timeout , opening_ts , nonce , now ) ; return question_id ; }
function newDaoRulesProposal ( uint _minQuorumDivisor , uint _minBoardMeetingFees , uint _minutesSetProposalPeriod , uint _minMinutesDebatePeriod , uint _feesRewardInflationRate , bool _transferable , uint _minutesDebatingPeriod ) payable returns ( uint ) ;
function initialize ( address jurisdiction , uint256 validAttributeTypeID , address sender ) public initializer { Ownable . initialize ( sender ) ; Pausable . initialize ( sender ) ; _issuancePaused = false ; _registry = AttributeRegistryInterface ( jurisdiction ) ; _jurisdiction = BasicJurisdictionInterface ( jurisdiction ) ; _validAttributeTypeID = validAttributeTypeID ; }
function sellCoinsToICO ( uint256 amountOfCoinsToSell ) public returns ( bool success ) { uint amount = amountOfCoinsToSell ; msgSndr [ msg . sender ] = amount ; bool isPreview = false ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool icosuccess ; uint sellPaymentValue ; ( icosuccess , sellPaymentValue ) = ico . sell ( amount , msg . sender , isPreview ) ; require ( icosuccess == true ) ; require ( _getIcoAddr ( ) . balance >= safeAdd ( ico . getMinBal ( ) , sellPaymentValue ) ) ; bool sucsTrTk = false ; bool pymActSucs = false ; if ( isPreview == false ) { sucsTrTk = _safeTransferTkn ( msg . sender , owner , amount ) ; require ( sucsTrTk == true ) ; msgSndr [ msg . sender ] = sellPaymentValue ; pymActSucs = _safePaymentActionAtIco ( sellPaymentValue , msg . sender , 2 ) ; require ( pymActSucs == true ) ; } msgSndr [ msg . sender ] = 0 ; return ( true ) ; }
function destroy ( ) onlyOwner public { uint256 balance = token . balanceOf ( this ) ; assert ( balance > 0 ) ; token . transfer ( owner , balance ) ; selfdestruct ( owner ) ; }
function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; powIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
function getRareInfo ( uint256 _tokenId ) external view returns ( uint256 sellingPrice , address owner , uint256 nextPrice , uint256 rareClass , uint256 cardId , uint256 rareValue ) { RareCard storage rarecard = rareArray [ _tokenId ] ; sellingPrice = IndexToPrice [ _tokenId ] ; owner = IndexToOwner [ _tokenId ] ; nextPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 125 ) , 100 ) ; rareClass = rarecard . rareClass ; cardId = rarecard . cardId ; rareValue = rarecard . rareValue ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( _registry . hasAttribute ( to , _validAttributeTypeID ) , "Transfer failed - receiver is not approved." ) ; return super . transfer ( to , value ) ; }
function rewardTokensForClient ( address _recipient , uint _amount ) external returns ( uint ) ;
function getState ( ) public constant returns ( State ) { if ( finalizedCrowdfunding ) return State . Success ; else if ( getTime ( ) < preSaleStartTime ) return State . Waiting ; else if ( getTime ( ) >= preSaleStartTime && getTime ( ) < fundingStartTime && totalSupply < tokenCreationMax ) return State . PreSale ; else if ( getTime ( ) >= fundingStartTime && getTime ( ) < fundingStartTime + 2 days && totalSupply < tokenCreationMax ) return State . CommunitySale ; else if ( getTime ( ) >= ( fundingStartTime + 2 days ) && getTime ( ) < fundingEndTime && totalSupply < tokenCreationMax ) return State . PublicSale ; else if ( getTime ( ) >= fundingEndTime || totalSupply == tokenCreationMax ) return State . Success ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool _success ) ;
function mOnApprove ( address owner , address spender , uint256 amount ) internal returns ( bool allow ) ;
function proxyClaimTokens ( address receiver_address ) public atStage ( Stages . AuctionEnded ) returns ( bool ) { require ( now > end_time + token_claim_waiting_period ) ; require ( receiver_address != 0x0 ) ; if ( bids [ receiver_address ] == 0 ) { return false ; } uint num = ( token_multiplier * bids [ receiver_address ] ) / final_price ; uint auction_tokens_balance = token . balanceOf ( address ( this ) ) ; if ( num > auction_tokens_balance ) { num = auction_tokens_balance ; } funds_claimed += bids [ receiver_address ] ; bids [ receiver_address ] = 0 ; require ( token . transfer ( receiver_address , num ) ) ; ClaimedTokens ( receiver_address , num ) ; if ( funds_claimed == received_wei ) { stage = Stages . TokensDistributed ; TokensDistributed ( ) ; } assert ( token . balanceOf ( receiver_address ) >= num ) ; assert ( bids [ receiver_address ] == 0 ) ; return true ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { uint valtmp = _value ; uint _valueA = valtmp ; valtmp = 0 ; require ( _valueA <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] = safeSub ( allowance [ _from ] [ msg . sender ] , _valueA ) ; _transfer ( _from , _to , _valueA ) ; _valueA = 0 ; return true ; }
function ( ) public payable { contribute ( ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 ) ;
function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; address generalTransferManager = new GeneralTransferManager ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( address ( generalTransferManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( generalTransferManager ) ; }
function destroy ( ) onlyHammer { suicide ( msg . sender ) ; }
function initialize ( address sender ) public initializer { Ownable . initialize ( sender ) ; Pausable . initialize ( sender ) ; }
function useModule ( address _moduleFactory ) external ;
function getFinalizeTS ( bytes32 question_id ) public view returns ( uint32 ) { }
function transfer ( address _to , uint256 _deedId ) external whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; transferMultiple ( _to , _deedIds ) ; }
function getType ( ) public view returns ( uint8 ) { return 1 ; }
function setUpgradeMaster ( address master ) external { require ( master != 0x0 && msg . sender == upgradeMaster ) ; upgradeMaster = master ; }
function unlock ( address addr , uint index ) public { require ( addr == msg . sender ) ; var lock = lockRecordMap [ addr ] [ index ] ; require ( lock . amount > 0 && ! lock . completed ) ; var during = now - lock . time ; var reward = _calcReward ( during , lock . amount ) ; token t = token ( tokenAddr ) ; t . transferFrom ( owner , addr , lock . amount + reward ) ; lock . completed = true ; Unlock ( addr , index , lock . amount , reward ) ; }
function setWhitelistingAddress ( address _address ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _address != address ( 0 ) ) ; require ( _address != whitelistingAddress ) ; address oldAddress = whitelistingAddress ; whitelistingAddress = _address ; emit WhitelistingAddressChanged ( oldAddress , _address ) ; }
function onChangeTokenController ( address sender , address newController ) public constant returns ( bool ) ;
function addNewBoard ( bytes32 name , string boardDescription ) public payable returns ( bytes32 boardHash ) { require ( msg . value >= boardCost ) ; balance += msg . value ; boardHash = keccak256 ( abi . encodePacked ( name , msg . sender ) ) ; numBoards ++ ; boards [ boardHash ] = Board ( name , boardDescription , 0 , msg . sender ) ; emit newBoardCreated ( boardHash ) ; }
function burn ( uint256 _amount ) public onlyOwner returns ( bool ) { require ( burnable != address ( 0x0 ) ) ; uint256 currTotalSupply = totalSupply ( ) ; uint256 previousBalance = balanceOf ( burnable ) ; require ( currTotalSupply >= _amount ) ; require ( previousBalance >= _amount ) ; updateValueAtNow ( totalSupplyHistory , currTotalSupply - _amount ) ; updateValueAtNow ( balances [ burnable ] , previousBalance - _amount ) ; emit Transfer ( burnable , 0 , _amount ) ; return true ; }
function triggerDestruction ( uint ein , address [ ] memory firstChunk , address [ ] memory lastChunk , bool resetResolvers ) public _identityExists ( ein ) { require ( ! canRecover ( ein ) , "Recovery has not recently been triggered." ) ; Identity storage _identity = identityDirectory [ ein ] ; address payable [ 1 ] memory middleChunk = [ msg . sender ] ; require ( keccak256 ( abi . encodePacked ( firstChunk , middleChunk , lastChunk ) ) == recoveryLogs [ ein ] . hashedOldAssociatedAddresses , "Cannot destroy an EIN from an address that was not recently removed from said EIN via recovery." ) ; emit IdentityDestroyed ( msg . sender , ein , _identity . recoveryAddress , resetResolvers ) ; resetIdentityData ( _identity , address ( 0 ) , resetResolvers ) ; }
function triggerVersion ( address ofVersion ) { trigger ( versionToProposalIds [ ofVersion ] ) ; addVersion ( ofVersion ) ; }
function tokenController ( ) public constant returns ( address currentController ) ;
function mintMulti ( address [ ] _investors , uint256 [ ] _values ) external returns ( bool success ) { require ( _investors . length == _values . length , "Incorrect inputs" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { mint ( _investors [ i ] , _values [ i ] ) ; } return true ; }
function getChampsCount ( ) external view returns ( uint256 ) { return champs . length ; }
function totalSupply ( ) external view returns ( uint256 ) { return _allTokens . length ; }
function validateTradeInput ( ERC20 src , uint srcAmount , ERC20 dest , address destAddress ) internal view returns ( bool ) { require ( srcAmount <= MAX_QTY ) ; require ( srcAmount != 0 ) ; require ( destAddress != address ( 0 ) ) ; require ( src != dest ) ; if ( src == ETH_TOKEN_ADDRESS ) { require ( msg . value == srcAmount ) ; } else { require ( msg . value == 0 ) ; require ( src . balanceOf ( this ) >= srcAmount ) ; } return true ; }
function performSellOrder ( OrderData order , uint256 amountToGiveForOrder ) public onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { approveAddress ( address ( exchange ) , order . token ) ; uint256 takeFee = exchange . takeFee ( ) ; amountSpentOnOrder = amountToGiveForOrder ; uint256 ethAmount = SafeMath . div ( SafeMath . mul ( amountSpentOnOrder , order . weiAmount ) , order . tokenAmount ) ; amountReceivedFromOrder = SafeMath . sub ( ethAmount , exchange . calculateFeeForAccount ( ethAmount , takeFee , address ( this ) ) ) ; exchange . takeBuyOrder ( order . token , order . tokenAmount , order . weiAmount , amountSpentOnOrder , order . maker ) ; totlePrimary . transfer ( amountReceivedFromOrder ) ; }
function setTokenConverter ( TokenConverter _tokenConverter ) external onlyOwner returns ( bool ) { require ( _isContract ( _tokenConverter ) , "Should be a contract" ) ; emit SetTokenConverter ( tokenConverter , _tokenConverter ) ; tokenConverter = _tokenConverter ; return true ; }
function supportsInterface ( bytes4 interfaceID ) external view returns ( bool ) { return ( interfaceID == this . supportsInterface . selector || interfaceID == ( this . hasAttribute . selector ^ this . getAttributeValue . selector ^ this . countAttributeTypes . selector ^ this . getAttributeTypeID . selector ) ) ; }
function addNotary ( address notary , uint256 responsesPercentage , uint256 notarizationFee , string notarizationTermsOfService ) public onlyOwner validAddress ( notary ) returns ( bool ) { require ( transactionCompletedAt == 0 ) ; require ( responsesPercentage <= 100 ) ; require ( ! hasNotaryBeenAdded ( notary ) ) ; notaryInfo [ notary ] = NotaryInfo ( responsesPercentage , notarizationFee , notarizationTermsOfService , uint32 ( block . timestamp ) ) ; notaries . push ( notary ) ; orderStatus = OrderStatus . NotaryAdded ; return true ; }
function proposeMilestones ( bytes _newMilestones ) onlyRecipient campaignNotCanceled { proposedMilestones = _newMilestones ; changingMilestones = true ; NewMilestoneListProposed ( ) ; }
function getPerson ( uint256 _tokenId ) public view returns ( string personName , uint256 sellingPrice , address owner ) ;
function liabilityCreated ( ILiability _liability , uint256 _start_gas ) external returns ( bool ) ;
function buy ( address _sender ) internal { if ( funding_ended ) throw ; if ( block . number < fundingStartBlock ) throw ; if ( block . number > fundingEndBlock ) throw ; if ( msg . value == 0 ) throw ; var numTokens = msg . value * tokenCreationRate ; totalTokens += numTokens ; balances [ _sender ] += numTokens ; founders . transfer ( msg . value ) ; Transfer ( 0 , _sender , numTokens ) ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( now > stage5Deadline && state != State . Successful ) { emit LogStageFinish ( state , stageDistributed ) ; state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } else if ( state == State . stage1 && now > stage1Deadline ) { emit LogStageFinish ( state , stageDistributed ) ; state = State . stage2 ; stageDistributed = 0 ; } else if ( state == State . stage2 && now > stage2Deadline ) { emit LogStageFinish ( state , stageDistributed ) ; state = State . stage3 ; stageDistributed = 0 ; } else if ( state == State . stage3 && now > stage3Deadline ) { emit LogStageFinish ( state , stageDistributed ) ; state = State . stage4 ; stageDistributed = 0 ; } else if ( state == State . stage4 && now > stage4Deadline ) { emit LogStageFinish ( state , stageDistributed ) ; state = State . stage5 ; stageDistributed = 0 ; } }
function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { return false ; }
function startSettling ( bytes32 channelId ) public { require ( canStartSettling ( channelId , msg . sender ) ) ; PaymentChannel storage channel = channels [ channelId ] ; channel . settlingUntil = block . number + channel . settlingPeriod ; DidStartSettling ( channelId ) ; }
function leaveTokenGroupAndWithdrawBalance ( uint256 _tokenId ) external whenNotPaused { address userAdd = msg . sender ; var group = tokenIndexToGroup [ _tokenId ] ; var contributor = userAddressToContributor [ userAdd ] ; require ( _addressNotNull ( userAdd ) ) ; require ( group . exists ) ; require ( group . purchasePrice == 0 ) ; require ( group . addressToContributorArrIndex [ userAdd ] > 0 ) ; require ( contributor . tokenIdToGroupArrIndex [ _tokenId ] > 0 ) ; uint refundBalance = _clearContributorRecordInGroup ( _tokenId , userAdd ) ; _clearGroupRecordInContributor ( _tokenId , userAdd ) ; userAddressToContributor [ userAdd ] . withdrawableBalance += refundBalance ; FundsDeposited ( userAdd , refundBalance ) ; _withdrawUserFunds ( userAdd ) ; LeaveGroup ( _tokenId , userAdd , tokenIndexToGroup [ _tokenId ] . contributedBalance , refundBalance ) ; }
function addAddressesToWhitelist ( address [ ] _users ) public isAdmin { addAddressesToWhitelistInternal ( _users ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( isNotContract ( _to ) ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function _postValidatePurchase ( address , uint256 ) internal pure { }
function finalize ( ) external { if ( ! funding ) throw ; if ( ( block . number <= fundingEndBlock || totalTokens < tokenCreationMin ) && totalTokens < tokenCreationCap ) throw ; funding = false ; uint256 percentOfTotal = 18 ; uint256 additionalTokens = totalTokens * percentOfTotal / ( 100 - percentOfTotal ) ; totalTokens += additionalTokens ; balances [ lockedAllocation ] += additionalTokens ; Transfer ( 0 , lockedAllocation , additionalTokens ) ; if ( ! prospectors_team . send ( this . balance ) ) throw ; }
function balanceOfAt ( address _investor , uint256 _checkpointId ) external view returns ( uint256 ) ;
function incBalance ( address _acct , uint _val ) public onlyModule returns ( bool ) { balances [ _acct ] = balances [ _acct ] . add ( _val ) ; emit BalanceAdj ( msg . sender , _acct , _val , "+" ) ; return true ; }
function GrantToken ( address _customer , uint256 _value , string note ) onlyOwner public { require ( balances [ msg . sender ] >= _value && balances [ _customer ] + _value > balances [ _customer ] ) ; BonusToken ( _customer , _value , note ) ; balances [ msg . sender ] -= _value ; balances [ _customer ] += _value ; Transfer ( msg . sender , _customer , _value ) ; }
function addAttribute ( uint256 attributeTypeID , uint256 value , uint256 validatorFee , bytes signature ) external payable { require ( ! _issuedAttributes [ msg . sender ] [ attributeTypeID ] . exists , "duplicate attributes are not supported, remove existing attribute first" ) ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; uint256 stake = msg . value . sub ( validatorFee ) . sub ( jurisdictionFee ) ; require ( stake >= minimumStake , "attribute requires a greater value than is currently provided" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( address ( this ) , msg . sender , address ( 0 ) , msg . value , validatorFee , attributeTypeID , value ) ) ; require ( ! _invalidAttributeApprovalHashes [ hash ] , "signed attribute approvals from validators may not be reused" ) ; address signingKey = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; address validator = _signingKeys [ signingKey ] ; require ( canValidate ( validator , attributeTypeID ) , "signature does not match an approved validator for given attribute type" ) ; _issuedAttributes [ msg . sender ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , setPersonally : true , operator : address ( 0 ) , validator : validator , value : value , stake : stake } ) ; _invalidAttributeApprovalHashes [ hash ] = true ; emit AttributeAdded ( validator , msg . sender , attributeTypeID , value ) ; if ( stake > 0 ) { emit StakeAllocated ( msg . sender , attributeTypeID , stake ) ; } if ( jurisdictionFee > 0 ) { if ( owner ( ) . send ( jurisdictionFee ) ) { emit FeePaid ( owner ( ) , msg . sender , attributeTypeID , jurisdictionFee ) ; } } if ( validatorFee > 0 ) { if ( validator . send ( validatorFee ) ) { emit FeePaid ( validator , msg . sender , attributeTypeID , validatorFee ) ; } } }
function performRebalance ( Trade [ ] trades , bytes32 id ) public payable whenNotPaused { emit LogRebalance ( id ) ; TradeFlag [ ] memory tradeFlags = initialiseTradeFlags ( trades ) ; staticChecks ( trades , tradeFlags ) ; transferTokens ( trades , tradeFlags ) ; uint256 etherBalance = msg . value ; for ( uint256 i ; i < trades . length ; i ++ ) { Trade memory thisTrade = trades [ i ] ; TradeFlag memory thisTradeFlag = tradeFlags [ i ] ; CurrentAmounts memory amounts = CurrentAmounts ( { amountSpentOnTrade : 0 , amountReceivedFromTrade : 0 , amountLeftToSpendOnTrade : thisTrade . isSell ? thisTrade . tokenAmount : calculateMaxEtherSpend ( thisTrade , etherBalance ) } ) ; performTrade ( thisTrade , thisTradeFlag , amounts ) ; if ( amounts . amountReceivedFromTrade == 0 && thisTrade . optionalTrade ) { continue ; } if ( ! checkIfTradeAmountsAcceptable ( thisTrade , amounts . amountSpentOnTrade , amounts . amountReceivedFromTrade ) ) { errorReporter . revertTx ( "Amounts spent/received in trade not acceptable" ) ; } if ( thisTrade . isSell ) { etherBalance = SafeMath . add ( etherBalance , amounts . amountReceivedFromTrade ) ; } else { etherBalance = SafeMath . sub ( etherBalance , amounts . amountSpentOnTrade ) ; } transferTokensToUser ( thisTrade . tokenAddress , thisTrade . isSell ? amounts . amountLeftToSpendOnTrade : amounts . amountReceivedFromTrade ) ; } if ( etherBalance > 0 ) { msg . sender . transfer ( etherBalance ) ; } }
function cancelGame ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; require ( game . status == GameStatus . WAITING_FOR_SERVER ) ; closeGame ( game , gameId , playerAddress , ReasonEnded . CANCELLED_BY_PLAYER , 0 ) ; payOut ( game , playerAddress ) ; }
function calcSharePriceAndAllocateFees ( ) public returns ( uint ) { var ( gav , managementFee , performanceFee , unclaimedFees , feesShareQuantity , nav , sharePrice ) = performCalculations ( ) ; createShares ( owner , feesShareQuantity ) ; uint highWaterMark = atLastUnclaimedFeeAllocation . highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation . highWaterMark : sharePrice ; atLastUnclaimedFeeAllocation = Calculations ( { gav : gav , managementFee : managementFee , performanceFee : performanceFee , unclaimedFees : unclaimedFees , nav : nav , highWaterMark : highWaterMark , totalSupply : _totalSupply , timestamp : now } ) ; emit FeesConverted ( now , feesShareQuantity , unclaimedFees ) ; emit CalculationUpdate ( now , managementFee , performanceFee , nav , sharePrice , _totalSupply ) ; return sharePrice ; }
function whitelistAddresses ( address [ ] _addresses , uint256 _tier , bool _status ) public onlyController { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { address investorAddress = _addresses [ i ] ; require ( investors [ investorAddress ] . contributedAmount == 0 ) ; investors [ investorAddress ] = WhitelistedInvestor ( _tier , _status , 0 ) ; } }
function enableTransfers ( bool _transfersEnabled ) ;
function getDisputeFee ( bytes32 question_id ) public view returns ( uint256 ) { return ( custom_dispute_fees [ question_id ] > 0 ) ? custom_dispute_fees [ question_id ] : dispute_fee ; }
function mGenerateTokens ( address owner , uint256 amount ) internal { require ( owner != address ( 0 ) ) ; require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; uint256 newTotalSupply = curTotalSupply + amount ; require ( newTotalSupply >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( owner ) ; uint256 newBalanceTo = previousBalanceTo + amount ; assert ( newBalanceTo >= previousBalanceTo ) ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceTo ) ; emit Transfer ( 0 , owner , amount ) ; }
function processContribution ( ) private isValidContribution returns ( uint256 , uint256 ) { var ( allowedContribution , refundAmount ) = getAllowedContribution ( ) ; if ( ! honourWhitelist ( ) ) { AllowedContributionCheck ( allowedContribution , AllowedContributionState . WhitelistClosed ) ; return ( allowedContribution , refundAmount ) ; } if ( whitelist [ msg . sender ] > 0 ) { return processWhitelistedContribution ( allowedContribution , refundAmount ) ; } AllowedContributionCheck ( allowedContribution , AllowedContributionState . NotWhitelisted ) ; return ( allowedContribution , refundAmount ) ; }
function removePartOwner ( address _partowner ) external onlyContractOwner returns ( uint ) { delete partowners [ _partowner ] ; return OK ; }
function unlockInvestor ( address investor ) private { Account memory accountInMem = _accounts [ investor ] ; if ( accountInMem . balance == 0 ) { return ; } removeInvestor ( investor , accountInMem . balance ) ; if ( _lockState == LockState . AcceptingUnlocks ) { require ( NEUMARK . transferFrom ( investor , address ( this ) , accountInMem . neumarksDue ) ) ; NEUMARK . burn ( accountInMem . neumarksDue ) ; if ( currentTime ( ) < accountInMem . unlockDate ) { require ( _penaltyDisbursalAddress != address ( 0 ) ) ; uint256 penalty = decimalFraction ( accountInMem . balance , PENALTY_FRACTION ) ; if ( isContract ( _penaltyDisbursalAddress ) ) { require ( ASSET_TOKEN . approveAndCall ( _penaltyDisbursalAddress , penalty , "" ) ) ; } else { assert ( ASSET_TOKEN . transfer ( _penaltyDisbursalAddress , penalty ) ) ; } LogPenaltyDisbursed ( _penaltyDisbursalAddress , penalty , ASSET_TOKEN , investor ) ; accountInMem . balance -= penalty ; } } if ( _lockState == LockState . ReleaseAll ) { accountInMem . neumarksDue = 0 ; } assert ( ASSET_TOKEN . transfer ( investor , accountInMem . balance ) ) ; LogFundsUnlocked ( investor , accountInMem . balance , accountInMem . neumarksDue ) ; }
function getPayer ( bytes32 _requestId ) public view returns ( address ) { return requests [ _requestId ] . payer ; }
function unlock ( ) external { require ( block . timestamp >= unlockedAtTime ) ; require ( decentBetToken . transfer ( decentBetMultisig , decentBetToken . balanceOf ( address ( this ) ) ) ) ; }
function canReceive ( address receiver ) external view returns ( bool ) ;
function private_list_indexed_bytes_from_bytes ( bytes32 _collection_index , bytes32 _current_item , uint256 _count , bool _including_current , function ( bytes32 ) external constant returns ( bytes32 ) _function_last , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_next ) private constant returns ( bytes32 [ ] _indexed_bytes_items ) { uint256 _i ; uint256 _real_count = 0 ; bytes32 _last_item ; _last_item = _function_last ( _collection_index ) ; if ( _count == 0 || _last_item == bytes32 ( 0x0 ) ) { _indexed_bytes_items = new bytes32 [ ] ( 0 ) ; } else { bytes32 [ ] memory _items_temp = new bytes32 [ ] ( _count ) ; bytes32 _this_item ; if ( _including_current ) { _items_temp [ 0 ] = _current_item ; _real_count = 1 ; } _this_item = _current_item ; for ( _i = _real_count ; ( _i < _count ) && ( _this_item != _last_item ) ; _i ++ ) { _this_item = _function_next ( _collection_index , _this_item ) ; if ( _this_item != bytes32 ( 0x0 ) ) { _real_count ++ ; _items_temp [ _i ] = _this_item ; } } _indexed_bytes_items = new bytes32 [ ] ( _real_count ) ; for ( _i = 0 ; _i < _real_count ; _i ++ ) { _indexed_bytes_items [ _i ] = _items_temp [ _i ] ; } } }
function getVariableReleasableAmount ( address _beneficiary ) internal view returns ( uint releasableAmount ) { Beneficiary memory _b = beneficiaries [ _beneficiary ] ; Release memory _r = releases [ _beneficiary ] ; uint totalReleasableAmount = getTotalLockedAmounts ( _beneficiary ) ; uint releaseRatio ; for ( uint i = _r . releaseTimes . length - 1 ; i >= 0 ; i -- ) { if ( now >= _r . releaseTimes [ i ] ) { releaseRatio = _r . releaseRatios [ i ] ; break ; } } require ( releaseRatio > 0 ) ; releasableAmount = getPartialAmount ( releaseRatio , coeff , totalReleasableAmount ) ; releasableAmount = releasableAmount . sub ( _b . withdrawAmount ) ; }
function setCUSDAddress ( address _cusd ) public onlyOwner { require ( _cusd != address ( cusdAddress ) , "Must be a new cusd address" ) ; require ( AddressUtils . isContract ( _cusd ) , "Must be an actual contract" ) ; address oldCUSD = address ( cusdAddress ) ; cusdAddress = _cusd ; emit CUSDAddressChanged ( oldCUSD , _cusd ) ; }
function howMuchCanIContributeNow ( ) view public returns ( uint256 ) { return howMuchCanXContributeNow ( msg . sender ) ; }
function _payDividend ( address _payee , Dividend storage _dividend , uint256 _dividendIndex ) internal ;
function insert ( MapStorage storage self , address _key ) public returns ( bool ) { require ( _key != address ( 0 ) ) ; if ( exist ( self , _key ) ) { return true ; } self . addressToIndex [ _key ] = self . addresses . length ; self . addresses . push ( _key ) ; return true ; }
function setEscrow ( HavvenEscrow _escrow ) external optionalProxy_onlyOwner { escrow = _escrow ; emitEscrowUpdated ( _escrow ) ; }
function getTokenSymbol ( Data storage self , address contractAddress ) internal view returns ( string tokenSymbol ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.symbol' , contractAddress ) ) ; return self . Storage . getString ( id ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public saleOrUnfrozen ( msg . sender ) returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }
function fulfill ( ContentMapping storage self , bytes32 _id , address _creator , address _brand ) public returns ( bool ) { return self . data [ _id ] . deliverable . fulfill ( _creator , _brand ) ; }
function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner { requireMultiple ( _amount ) ; mTotalSupply = mTotalSupply . add ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , "" , _operatorData , true ) ; Minted ( msg . sender , _tokenHolder , _amount , _operatorData ) ; if ( mErc20compatible ) { Transfer ( 0x0 , _tokenHolder , _amount ) ; } }
function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { require ( _beneficiary != address ( 0 ) ) ; require ( _weiAmount != 0 ) ; increaseTime = token . pauseTime ( ) ; require ( ! crowdsaleClosed && block . timestamp >= start . add ( increaseTime ) && block . timestamp <= end . add ( increaseTime ) ) ; }
function list_indexed_bytesarray_from ( bytes32 _collection_index , bytes32 _current_item , uint256 _count , function ( bytes32 ) external constant returns ( bytes32 ) _function_first , function ( bytes32 ) external constant returns ( bytes32 ) _function_last , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _indexed_bytes_items ) { if ( _from_start ) { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _current_item , _count , false , _function_last , _function_next ) ; } else { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _current_item , _count , false , _function_first , _function_previous ) ; } }
function setPrice ( uint256 _newPrice ) onlyOwner public { require ( now > 1539561600 ) ; buyBackPrice = _newPrice ; }
function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; creator . transfer ( address ( this ) . balance ) ; tokenReward . transfer ( creator , remanent ) ; emit LogBeneficiaryPaid ( creator ) ; emit LogContributorsPayout ( creator , remanent ) ; }
function removeFee ( address stablecoin ) public onlyOwner whenNotPaused { require ( isWhitelisted ( stablecoin ) , "Stablecoin must be whitelisted prior to setting conversion fee" ) ; tokenStorage_CD . removeFee ( stablecoin ) ; }
function freezeAccount ( address from , bool freeze ) onlyOwner public { frozenAccount [ from ] = freeze ; emit FrozenFunds ( from , freeze ) ; }
function getDarknodes ( address _start , uint256 _count ) external view returns ( address [ ] ) { uint256 count = _count ; if ( count == 0 ) { count = numDarknodes ; } return getDarknodesFromEpochs ( _start , count , false ) ; }
function _cancelSale ( uint256 _tokenId , address _seller ) internal { Sale memory saleItem = tokenIdToSale [ _tokenId ] ; if ( saleItem . tokenIds [ 1 ] != 0 ) { for ( uint ii = 0 ; ii < 9 ; ii ++ ) { _removeSale ( saleItem . tokenIds [ ii ] ) ; _transfer ( address ( this ) , _seller , saleItem . tokenIds [ ii ] ) ; } emit SaleCancelled ( _tokenId , _seller ) ; } else { _removeSale ( _tokenId ) ; _transfer ( address ( this ) , _seller , _tokenId ) ; emit SaleCancelled ( _tokenId , _seller ) ; } }
function lock ( address investor , uint256 amount , uint256 neumarks ) public onlyState ( LockState . AcceptingLocks ) onlyController ( ) { require ( amount > 0 ) ; assert ( ASSET_TOKEN . transferFrom ( msg . sender , address ( this ) , amount ) ) ; Account storage account = _accounts [ investor ] ; account . balance = addBalance ( account . balance , amount ) ; account . neumarksDue = add ( account . neumarksDue , neumarks ) ; if ( account . unlockDate == 0 ) { _totalInvestors += 1 ; account . unlockDate = currentTime ( ) + LOCK_PERIOD ; } emit LogFundsLocked ( investor , amount , neumarks ) ; }
function setSaleAuctionContractAddress ( address _address ) external onlyOwner { SaleAuction _contract = SaleAuction ( _address ) ; require ( _contract . isSaleAuction ( ) ) ; saleAuctionContract = _contract ; }
function restartSale ( ) onlyBy ( owner ) external { isStopped = false ; }
function emergencyRedeem ( uint shareQuantity , address [ ] requestedAssets ) public pre_cond ( balances [ msg . sender ] >= shareQuantity ) returns ( bool ) { address ofAsset ; uint [ ] memory ownershipQuantities = new uint [ ] ( requestedAssets . length ) ; for ( uint i = 0 ; i < requestedAssets . length ; ++ i ) { ofAsset = requestedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; if ( assetHoldings == 0 ) continue ; ownershipQuantities [ i ] = mul ( assetHoldings , shareQuantity ) / totalSupply ; if ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) < ownershipQuantities [ i ] ) { isShutDown = true ; ErrorMessage ( "CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy" ) ; return false ; } } annihilateShares ( msg . sender , shareQuantity ) ; for ( uint j = 0 ; j < requestedAssets . length ; ++ j ) { ofAsset = requestedAssets [ j ] ; if ( ownershipQuantities [ j ] == 0 ) { continue ; } else if ( ! AssetInterface ( ofAsset ) . transfer ( msg . sender , ownershipQuantities [ j ] ) ) { revert ( ) ; } } Redeemed ( msg . sender , now , shareQuantity ) ; return true ; }
function granularity ( ) external view returns ( uint256 ) { return granularity_ ; }
function revealVote ( uint _pollID , uint _voteOption , uint _salt ) public { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( abi . encodePacked ( _voteOption , _salt ) ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; emit _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender ) ; }
function _forwardFunds ( ) internal { wallet . transfer ( msg . value ) ; }
function ( ) external payable { uint ethInWei = msg . value ; totalEthInWei = totalEthInWei + ethInWei ; uint perEth = unitsOneEthCanBuy ( ) ; uint256 amount = ethInWei . mul ( perEth ) . div ( 10 ** uint ( 18 - decimals ) ) ; require ( amount > 0 ) ; require ( balances [ fundsWallet ] >= amount ) ; fundsWallet . transfer ( msg . value ) ; bytes memory empty ; processTransfer ( fundsWallet , msg . sender , amount , empty ) ; }
function allowance ( address _owner , address _spender ) constant returns ( uint256 allowed ) { return allowance [ _owner ] [ _spender ] ; }
function getExpectedAmount ( bytes32 _requestId ) public view returns ( int256 ) { int256 expectedAmount = requests [ _requestId ] . payee . expectedAmount ; for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { expectedAmount = expectedAmount . add ( subPayees [ _requestId ] [ i ] . expectedAmount ) ; } return expectedAmount ; }
function setCreateChampFee ( uint256 _fee ) external onlyOwner { createChampFee = _fee ; }
function cutFor ( address _affiliate , uint256 _productId , uint256 _purchaseId , uint256 _purchaseAmount ) public view returns ( uint256 ) { uint256 rate = rateFor ( _affiliate , _productId , _purchaseId , _purchaseAmount ) ; require ( rate <= hardCodedMaximumRate ) ; return ( _purchaseAmount . mul ( rate ) ) . div ( 10000 ) ; }
function addBurningMan ( address _burningMan , uint _block ) public returns ( uint _code ) { if ( burningMans [ _burningMan ] ) { return SERVICE_CONTROLLER_BURNING_MAN_EXIST ; } _code = _multisig ( keccak256 ( _burningMan ) , _block ) ; if ( OK != _code ) { return _code ; } burningMans [ _burningMan ] = true ; return OK ; }
function getBlockNumber ( ) internal constant returns ( uint256 ) { return block . number ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( now > ICOdeadline && state != State . Successful ) { state = State . Successful ; closedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
function checkIfFundingCompleteOrExpired ( ) public { if ( state == State . stage1 && now > dateTimeContract . toTimestamp ( 2018 , 5 , 31 , 23 , 59 ) ) { state = State . stage2 ; } else if ( state == State . stage2 && now > dateTimeContract . toTimestamp ( 2018 , 6 , 30 , 23 , 59 ) ) { state = State . stage3 ; } else if ( state == State . stage3 && now > ICOdeadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
function pause ( ) external timedStateChange ( address ( 0 ) , 0 , true ) requiresState ( IcoState . ACTIVE ) onlyowner { changeState ( IcoState . PAUSED ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownersTokenCount [ _owner ] ; }
function processPreSale ( address _caller ) private { var ( allowedContribution , refundAmount ) = processContribution ( ) ; assert ( msg . value == allowedContribution . add ( refundAmount ) ) ; if ( allowedContribution > 0 ) { doBuy ( _caller , allowedContribution ) ; if ( refundAmount > 0 ) { msg . sender . transfer ( refundAmount ) ; closePreSale ( ) ; } uint256 tillCap = remainingCap ( ) ; if ( tillCap == 0 ) { closePreSale ( ) ; } } else { revert ( ) ; } }
function _isApprovedForAll ( address _owner , address _operator ) internal view returns ( bool ) { return _operatorApprovals [ _owner ] [ _operator ] ; }
function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) ;
function assetPrices ( address asset ) public view returns ( uint ) { if ( paused ) { return 0 ; } else { return _assetPrices [ asset ] . mantissa ; } }
function withdrawSynthetix ( uint quantity ) external onlyOwner onlyDuringSetup { synthetix . transfer ( synthetix , quantity ) ; }
function isValidator ( ) external view returns ( bool ) ;
function withdrawCommission ( uint _amount ) public onlyOwner { require ( _amount <= availableCommission ) ; availableCommission = availableCommission . sub ( _amount ) ; msg . sender . transfer ( _amount ) ; }
function getApproved ( uint256 _tokenId ) public view returns ( address ) ;
function getModulesByName ( bytes32 _name ) external view returns ( address [ ] ) { return names [ _name ] ; }
function setPreferredCurrency ( address account , bytes4 currencyKey ) external onlyAssociatedContract { preferredCurrency [ account ] = currencyKey ; }
function getMinerHalving ( ) public constant returns ( uint256 ) { return getHalvingOf ( msg . sender ) ; }
function changeFactorySetupFee ( uint256 _newSetupCost ) external ;
function symbol ( ) external view returns ( string ) ;
function setFunding ( uint _to ) returns ( bool _success ) ;
function setBuyPrices ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; }
function swap ( address requester , string symbolA , string symbolB , uint valueA , uint valueB , uint8 sigV , bytes32 sigR , bytes32 sigS , uint expiration ) public returns ( bool success ) { require ( lib . execSwap ( requester , symbolA , symbolB , valueA , valueB , sigV , sigR , sigS , expiration ) , "Error: Unable to perform atomic currency swap. Please check parameters." ) ; return true ; }
function cloneProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument , uint _dateOfProposal , uint _orderAmount , uint _dateOfOrder , bool _cloneOrder ) returns ( bool success ) { if ( smartContractStartDate != 0 || recipient == 0 || msg . sender != creator ) throw ; uint _proposalID = proposals . length ++ ; proposal c = proposals [ _proposalID ] ; c . amount = _amount ; c . description = _description ; c . hashOfTheDocument = _hashOfTheDocument ; c . dateOfProposal = _dateOfProposal ; c . orderAmount = _orderAmount ; c . dateOfLastOrder = _dateOfOrder ; ProposalAdded ( msg . sender , _proposalID , _amount , _description , _hashOfTheDocument ) ; if ( _cloneOrder ) passProject . cloneOrder ( address ( this ) , _proposalID , _orderAmount , _dateOfOrder ) ; return true ; }
function name ( ) public view returns ( string _name ) { return lib . getTokenName ( address ( this ) ) ; }
function getTitle ( ) public view returns ( string ) { return "ERC20 Dividend Checkpoint" ; }
function addRecipient ( address addr ) onlyOwner external { require ( recipients . length < MAX_RECIPIENTS , "Too many recipients" ) ; recipients . push ( addr ) ; }
function deedsOfOwner ( address _owner ) external view returns ( uint256 [ ] ) { uint256 deedCount = countOfDeedsByOwner ( _owner ) ; if ( deedCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( deedCount ) ; uint256 totalDeeds = countOfDeeds ( ) ; uint256 resultIndex = 0 ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = identifiers [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { result [ resultIndex ] = identifier ; resultIndex ++ ; } } return result ; } }
function validInitialBuyoutPrice ( uint256 _deedId , uint256 price ) public view returns ( bool ) { return ( price >= unclaimedPlotPrice && price <= maximumInitialBuyoutPrice ( _deedId ) ) ; }
function approve ( address _spender , uint256 _value ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) , "Invalid address." ) ; return super . approve ( _spender , _value ) ; }
function owner ( ) public view returns ( address ) { return getAddress ( Encoder . getKey ( "owner" ) ) ; }
function userEndGame ( uint32 _roundId , int _balance , bytes32 _serverHash , bytes32 _userHash , uint _gameId , address _contractAddress , bytes _serverSig ) public { verifySig ( _roundId , 0 , 0 , 0 , _balance , _serverHash , _userHash , _gameId , _contractAddress , _serverSig , serverAddress ) ; regularEndGame ( msg . sender , _roundId , _balance , _gameId , _contractAddress ) ; }
function unlock ( ) external { if ( block . number < unlockedAtBlockNumber ) throw ; if ( ! lunyrToken . transfer ( lunyrMultisig , lunyrToken . balanceOf ( this ) ) ) throw ; }
function increaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0xa45f71ff ) , _token , _spender , _addedValue , _fee , _nonce ) ; }
function totalSupply ( ) external view returns ( uint ) { return core . getTokenCount ( tokenIsChamp ) ; }
function clearFund ( uint256 _gameID ) external isHuman ( ) isEnded ( _gameID ) isOwner ( ) { require ( now >= game_ [ _gameID ] . withdrawDeadline , "withdraw deadline not passed yet" ) ; require ( gameStatus_ [ _gameID ] . fundCleared == false , "fund already cleared" ) ; gameStatus_ [ _gameID ] . fundCleared = true ; uint256 _totalPot = ( gameStatus_ [ _gameID ] . winningVaultInst ) . add ( gameStatus_ [ _gameID ] . winningVaultFinal ) ; uint256 _amount = _totalPot . sub ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; if ( _amount > 0 ) { FSKingCorp . deposit . value ( _amount ) ( ) ; } emit onFundCleared ( _gameID , _amount , now ) ; }
function tokensOf ( address owner ) public view returns ( uint256 [ ] ) { return _assetsOf [ owner ] ; }
function setMinBalanceForContractCreation ( uint minBalance ) external onlyOwner { minBalanceToAllowContractCreation = minBalance ; }
function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function transferForAdmin ( address token , address account , uint256 amount ) onlyAdmin external { require ( tokenAddress2Id [ token ] != 0 ) ; require ( userAddress2Id [ msg . sender ] != 0 ) ; addUser ( account ) ; balances [ token ] [ msg . sender ] = balances [ token ] [ msg . sender ] . sub ( amount ) ; balances [ token ] [ account ] = balances [ token ] [ account ] . add ( amount ) ; }
function expiry ( ) public constant returns ( uint256 blockNumber ) { }
function unpause ( ) external whenPaused onlyOwner { set ( Encoder . getKey ( "paused" ) , false ) ; emit Unpause ( now ) ; }
function setFee ( address _stablecoin , uint256 _fee ) public onlyOwner { uint256 oldFee = fees [ _stablecoin ] ; fees [ _stablecoin ] = _fee ; if ( oldFee != _fee ) emit FeeChanged ( _stablecoin , oldFee , _fee ) ; }
function freezeAccount ( address _target , bool _freeze ) public onlyOwner { frozenAccount [ _target ] = _freeze ; emit FrozenFunds ( _target , _freeze ) ; }
function getInstructions ( ) external view returns ( string ) { return "Create a dividend which will be paid out to token holders proportionally according to their balances at the point the dividend is created" ; }
function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
function name ( ) public pure returns ( string _deedName ) { _deedName = "MetaGame" ; }
function setTierRates ( uint256 tier1 , uint256 tier2 , uint256 tier3 , uint256 tier4 ) external onlyOwner whenNotPaused { require ( tier1 > 0 && tier2 > 0 && tier3 > 0 && tier4 > 0 ) ; require ( tier1 > tier2 && tier2 > tier3 && tier3 > tier4 ) ; rate = tier1 ; rateTier2 = tier2 ; rateTier3 = tier3 ; rateTier4 = tier4 ; }
function getTagsByType ( uint8 _moduleType ) external view returns ( bytes32 [ ] , address [ ] ) ;
function ownerWithdraw ( uint256 value ) external onlyOwner { if ( totalFunding >= PRESALE_MAXIMUM_FUNDING ) { owner . transfer ( value ) ; saleHasEnded = true ; } else { require ( now >= PRESALE_END_DATE ) ; require ( totalFunding >= PRESALE_MINIMUM_FUNDING ) ; owner . transfer ( value ) ; } }
function changeOwner ( address _newOwner ) public onlyOwner { owner = _newOwner ; }
function deedUri ( uint256 _deedId ) external view returns ( string _deedUri ) ;
function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { require ( state == State . Successful ) ; uint256 remainder = _address . balanceOf ( address ( this ) ) ; _address . transfer ( msg . sender , remainder ) ; }
function getVote ( uint _idPoll , address _voter ) public view returns ( uint [ 100 ] votes ) { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll storage p = _polls [ _idPoll ] ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { votes [ i ] = p . ballots [ i ] [ _voter ] ; } return votes ; }
function makeOffer ( uint256 _tokenId , uint8 _v , bytes32 _r , bytes32 _s ) public notHalted ( ) payable { address recoveredSigner = verify ( keccak256 ( msg . sender ) , _v , _r , _s ) ; require ( signers [ recoveredSigner ] == true ) ; require ( msg . sender != address ( 0 ) ) ; require ( msg . value > 0 ) ; uint256 currentPrice = getTokenPrice ( _tokenId ) ; require ( currentPrice > 0 ) ; if ( _tokenId == logoId && token . getCurrentPriceForToken ( _tokenId ) == 0 ) { require ( msg . value >= logoPrice ) ; token . updateTokensState ( logoId , msg . value ) ; erc20token . mint ( msg . sender , 100 ) ; transferEthers ( platformWallet , msg . value ) ; emit Purchased ( 0 , msg . sender , _tokenId , msg . value , 0 , 0 , msg . value , now ) ; return ; } uint256 minPrice = pricingStrategy . calculateMinPriceForNextRound ( currentPrice , minResalePercentage ) ; require ( msg . value >= minPrice ) ; uint256 offerCounter = offers . length ; offers . push ( Offer ( _tokenId , offerCounter , msg . sender , msg . value , currentPrice , false , now ) ) ; emit OfferMade ( msg . sender , _tokenId , offerCounter , msg . value , now ) ; approve ( offerCounter , _tokenId ) ; }
function setMaxGas ( uint256 _maxGas , uint256 _penalty ) public onlyOwner beforeSale { maxGasPrice = _maxGas ; maxGasPricePenalty = _penalty ; }
function performBuyOrder_ ( OrderData data ) public payable onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { uint256 amountToGiveForOrder = toUint ( msg . data , msg . data . length - 32 ) ; approveAddress ( ERC20_ASSET_PROXY , toAddress ( data . takerAssetData , 16 ) ) ; weth . deposit . value ( amountToGiveForOrder ) ( ) ; LibFillResults . FillResults memory results = exchange . fillOrder ( getZeroExOrder ( data ) , amountToGiveForOrder , data . signature ) ; require ( ERC20SafeTransfer . safeTransfer ( toAddress ( data . makerAssetData , 16 ) , totlePrimary , results . makerAssetFilledAmount ) ) ; amountSpentOnOrder = results . takerAssetFilledAmount ; amountReceivedFromOrder = results . makerAssetFilledAmount ; }
function transferFrom ( address _from , address _to , uint256 _value ) public onlyIfLockTimePassed returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] . add ( _value ) >= balances [ _to ] ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }
function changeOwnership ( bytes32 _symbol , address _newOwner ) public onlyOwner ( _symbol ) returns ( uint ) { if ( _newOwner == 0x0 ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_INVALID_NEW_OWNER ) ; } uint newOwnerId = _createHolderId ( _newOwner ) ; uint assetOwner = _assetOwner ( _symbol ) ; if ( assetOwner == newOwnerId ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } address oldOwner = _address ( assetOwner ) ; set ( store , assetOwnerIdStorage , _symbol , newOwnerId ) ; _emitter ( ) . emitOwnershipChange ( oldOwner , _newOwner , _symbol ) ; return OK ; }
function getJurisdiction ( ) external view returns ( address ) ;
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) , "0x0 Is not a valid owner" ) ; require ( _index < _balanceOf ( _owner ) , "Index out of bounds" ) ; return _assetsOf [ _owner ] [ _index ] ; }
function redeemChannel ( bytes32 channelId , bytes32 secret ) public { require ( sha256 ( abi . encodePacked ( secret ) ) == channels [ channelId ] . hashedSecret , "WRONG_SECRET" ) ; require ( channels [ channelId ] . state == State . Created , "WRONG_STATE" ) ; uint amount = channels [ channelId ] . amount ; address beneficiary = channels [ channelId ] . beneficiary ; channels [ channelId ] . state = State . Redeemed ; beneficiary . transfer ( amount ) ; emit ChannelRedeemed ( channelId ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool _success ) ;
function safeTransfer ( address token , address to , uint256 amount ) internal { CompatibleERC20 ( token ) . transfer ( to , amount ) ; require ( previousReturnValue ( ) , "transfer failed" ) ; }
function allocateInvestors ( ) public onlyController { require ( ( campaignState == 1 ) || ( ( campaignState != 0 ) && ( now > tCampaignEnd + ( 2880 minutes ) ) ) ) ; uint256 nTokens = 0 ; uint256 rate = 0 ; uint256 contributedAmount = 0 ; uint256 investorsProcessedEnd = investorsProcessed + investorsBatchSize ; if ( investorsProcessedEnd > joinedCrowdsale . length ) { investorsProcessedEnd = joinedCrowdsale . length ; } for ( uint256 i = investorsProcessed ; i < investorsProcessedEnd ; i ++ ) { investorsProcessed ++ ; address investorAddress = joinedCrowdsale [ i ] ; contributedAmount = participantList [ investorAddress ] . contributedAmountPreCrowd ; if ( isWhiteListed ) { if ( contributedAmount > participantWhitelist [ investorAddress ] . maxCap ) { contributedAmount = participantWhitelist [ investorAddress ] . maxCap ; } if ( contributedAmount > 0 ) { participantWhitelist [ investorAddress ] . maxCap = participantWhitelist [ investorAddress ] . maxCap . sub ( contributedAmount ) ; } } if ( contributedAmount > 0 ) { rate = preCrowd_tokens_scaled ; nTokens = ( rate . mul ( contributedAmount ) ) . div ( 1 ether ) ; if ( nTokens > maxPreCrowdAllocationPerInvestor ) { nTokens = maxPreCrowdAllocationPerInvestor ; } if ( tokensRemainingPreCrowd . sub ( nTokens ) < 0 ) { nTokens = tokensRemainingPreCrowd ; } participantList [ joinedCrowdsale [ i ] ] . spentAmount = participantList [ joinedCrowdsale [ i ] ] . spentAmount . add ( nTokens . div ( rate ) . mul ( 1 ether ) ) ; tokensRemainingPreCrowd = tokensRemainingPreCrowd . sub ( nTokens ) ; participantList [ investorAddress ] . allocatedTokens = participantList [ investorAddress ] . allocatedTokens . add ( nTokens ) ; } contributedAmount = participantList [ investorAddress ] . contributedAmountStage1 ; if ( isWhiteListed ) { if ( contributedAmount > participantWhitelist [ investorAddress ] . maxCap ) { contributedAmount = participantWhitelist [ investorAddress ] . maxCap ; } if ( contributedAmount > 0 ) { participantWhitelist [ investorAddress ] . maxCap = participantWhitelist [ investorAddress ] . maxCap . sub ( contributedAmount ) ; } } if ( contributedAmount > 0 ) { rate = stage_1_tokens_scaled ; nTokens = ( rate . mul ( contributedAmount ) ) . div ( 1 ether ) ; if ( nTokens > maxStage1AllocationPerInvestor ) { nTokens = maxStage1AllocationPerInvestor ; } if ( tokensRemainingStage1 . sub ( nTokens ) < 0 ) { nTokens = tokensRemainingStage1 ; } participantList [ joinedCrowdsale [ i ] ] . spentAmount = participantList [ joinedCrowdsale [ i ] ] . spentAmount . add ( nTokens . div ( rate ) . mul ( 1 ether ) ) ; tokensRemainingStage1 = tokensRemainingStage1 . sub ( nTokens ) ; participantList [ investorAddress ] . allocatedTokens = participantList [ investorAddress ] . allocatedTokens . add ( nTokens ) ; } contributedAmount = participantList [ investorAddress ] . contributedAmountStage2 ; if ( isWhiteListed ) { if ( contributedAmount > participantWhitelist [ investorAddress ] . maxCap ) { contributedAmount = participantWhitelist [ investorAddress ] . maxCap ; } if ( contributedAmount > 0 ) { participantWhitelist [ investorAddress ] . maxCap = participantWhitelist [ investorAddress ] . maxCap . sub ( contributedAmount ) ; } } if ( contributedAmount > 0 ) { rate = stage_2_tokens_scaled ; nTokens = ( rate . mul ( contributedAmount ) ) . div ( 1 ether ) ; if ( nTokens > maxStage2AllocationPerInvestor ) { nTokens = maxStage2AllocationPerInvestor ; } if ( tokensRemainingStage2 . sub ( nTokens ) < 0 ) { nTokens = tokensRemainingStage2 ; } participantList [ joinedCrowdsale [ i ] ] . spentAmount = participantList [ joinedCrowdsale [ i ] ] . spentAmount . add ( nTokens . div ( rate ) . mul ( 1 ether ) ) ; tokensRemainingStage2 = tokensRemainingStage2 . sub ( nTokens ) ; participantList [ investorAddress ] . allocatedTokens = participantList [ investorAddress ] . allocatedTokens . add ( nTokens ) ; } contributedAmount = participantList [ investorAddress ] . contributedAmountStage3 ; if ( isWhiteListed ) { if ( contributedAmount > participantWhitelist [ investorAddress ] . maxCap ) { contributedAmount = participantWhitelist [ investorAddress ] . maxCap ; } if ( contributedAmount > 0 ) { participantWhitelist [ investorAddress ] . maxCap = participantWhitelist [ investorAddress ] . maxCap . sub ( contributedAmount ) ; } } if ( contributedAmount > 0 ) { rate = stage_3_tokens_scaled ; nTokens = ( rate . mul ( contributedAmount ) ) . div ( 1 ether ) ; if ( nTokens > maxStage3AllocationPerInvestor ) { nTokens = maxStage3AllocationPerInvestor ; } if ( tokensRemainingStage3 . sub ( nTokens ) < 0 ) { nTokens = tokensRemainingStage3 ; } participantList [ joinedCrowdsale [ i ] ] . spentAmount = participantList [ joinedCrowdsale [ i ] ] . spentAmount . add ( nTokens . div ( rate ) . mul ( 1 ether ) ) ; tokensRemainingStage3 = tokensRemainingStage3 . sub ( nTokens ) ; participantList [ investorAddress ] . allocatedTokens = participantList [ investorAddress ] . allocatedTokens . add ( nTokens ) ; } do_grant_tokens ( investorAddress , participantList [ investorAddress ] . allocatedTokens ) ; } }
function bringKydyHome ( uint256 _yinId ) external whenNotPaused returns ( uint256 ) { Kydy storage yin = kydys [ _yinId ] ; require ( yin . createdTime != 0 ) ; require ( _isReadyToBringKydyHome ( yin ) ) ; uint256 yangId = yin . synthesizingWithId ; Kydy storage yang = kydys [ yangId ] ; uint16 parentGen = yin . generation ; if ( yang . generation > yin . generation ) { parentGen = yang . generation ; } uint256 childGenes = geneSynthesis . synthGenes ( yin . genes , yang . genes ) ; address owner = kydyIndexToOwner [ _yinId ] ; uint256 kydyId = _createKydy ( _yinId , yin . synthesizingWithId , parentGen + 1 , childGenes , owner ) ; delete yin . synthesizingWithId ; creatingKydys -- ; msg . sender . transfer ( autoCreationFee ) ; return kydyId ; }
function closePreSignedHashing ( address _investContract , bytes32 _strategyID ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xc95bd3aa ) , _investContract , _strategyID ) ) ; }
function updatePollDescription ( uint _idPoll , bytes _description , uint8 _numBallots ) public { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; require ( _numBallots <= 15 , "Only a max of 15 ballots are allowed" ) ; Poll storage p = _polls [ _idPoll ] ; require ( p . startBlock > block . number , "You cannot modify an active poll" ) ; require ( p . author == msg . sender || msg . sender == controller , "Only the owner/controller can modify the poll" ) ; p . numBallots = _numBallots ; p . description = _description ; p . author = msg . sender ; }
function signOut ( address _contract ) external onlyContractOwner returns ( uint ) { require ( _contract != 0x0 ) ; delete authorized [ _contract ] ; return OK ; }
function frozenCell ( address owner , uint index ) public view returns ( uint amount , uint thawTS , bool isKYCRequired ) { require ( index < frozenCellCount ( owner ) ) ; amount = frozenBalances [ owner ] [ index ] . amount ; thawTS = uint ( frozenBalances [ owner ] [ index ] . thawTS ) ; isKYCRequired = decodeKYCFlag ( frozenBalances [ owner ] [ index ] . isKYCRequired ) ; }
function addValidatorApproval ( address validator , uint256 attributeTypeID ) external onlyOwner whenNotPaused { require ( isValidator ( validator ) && isAttributeType ( attributeTypeID ) , "must specify both a valid attribute and an available validator" ) ; require ( ! _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] , "validator is already approved on the provided attribute" ) ; _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] = true ; uint256 index = _validatorApprovals [ validator ] . length ; _validatorApprovalsIndex [ validator ] [ attributeTypeID ] = index ; _validatorApprovals [ validator ] . push ( attributeTypeID ) ; emit ValidatorApprovalAdded ( validator , attributeTypeID ) ; }
function approve ( address _to , uint256 _tokenId ) public onlyERC721 { require ( _owns ( msg . sender , _tokenId ) ) ; politicianIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
function unpause ( ) public onlyCEO whenPaused { require ( ethernautsStorage != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; require ( ethernautsStorage . contractsGrantedAccess ( address ( this ) ) == true ) ; super . unpause ( ) ; }
function deleteAddress ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete addressStorage [ _key ] ; return true ; }
function clearTrade ( bytes _signature , address _trader , bytes32 _strategyID , address _follower , uint256 _investedAmount , int256 _profitAmount , string _causeToClear ) public returns ( bool ) { require ( traderProfile [ _trader ] [ _strategyID ] != address ( 0 ) ) ; TradeProfile profile = TradeProfile ( traderProfile [ _trader ] [ _strategyID ] ) ; if ( msg . sender != bincentive ) { require ( profile . startTimeOf ( _follower ) + profile . periodLength ( ) <= now ) ; } bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( clearTradePreSignedHashing ( address ( this ) , _trader , _strategyID , _follower , _investedAmount , _profitAmount , _causeToClear ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; uint256 amountToTrader ; uint256 amountToFollower ; ( amountToTrader , amountToFollower ) = profile . clear ( _follower , from , _profitAmount ) ; marginBalances [ _trader ] = marginBalances [ _trader ] . add ( amountToTrader ) ; marginBalances [ _follower ] = marginBalances [ _follower ] . add ( amountToFollower ) ; emit ClearTrade ( _follower , _trader , _investedAmount , _profitAmount , _causeToClear ) ; return true ; }
function totalSupplyAt ( uint256 _checkpointId ) external view returns ( uint256 ) { require ( _checkpointId <= currentCheckpointId ) ; return TokenLib . getValueAt ( checkpointTotalSupply , _checkpointId , totalSupply ( ) ) ; }
function platformLogin ( ) userNotBanned ( msg . sender ) external { cooldown [ msg . sender ] = 0 ; cooldown [ msg . sender ] -= 1 ; }
function withdrawalList ( uint256 [ ] memory loanIds , address to ) public returns ( uint256 ) { uint256 inputId ; uint256 totalWithdraw = 0 ; for ( inputId = 0 ; inputId < loanIds . length ; inputId ++ ) { Loan storage loan = loans [ loanIds [ inputId ] ] ; if ( loan . lender == msg . sender ) { totalWithdraw += loan . lenderBalance ; loan . lenderBalance = 0 ; } } require ( rcn . transfer ( to , totalWithdraw ) ) ; unlockTokens ( rcn , totalWithdraw ) ; return totalWithdraw ; }
function transferFrom ( address _from , address _to , uint256 _amount ) stopOnPause public returns ( bool success ) { require ( _from != 0x0 ) ; require ( allowance ( _from , msg . sender ) >= _amount ) ; bytes memory empty ; allowed [ _from ] [ msg . sender ] = allowance ( _from , msg . sender ) . sub ( _amount ) ; assert ( _transfer ( _from , _to , _amount , empty ) ) ; emit Transfer ( _from , _to , _amount , empty ) ; return true ; }
function addAdministrators ( address _adminAddress ) onlyOwner { administrators [ _adminAddress ] = true ; AdminstratorAdded ( _adminAddress ) ; }
function approvePayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( msg . sender != arbitrator ) { require ( job . manager == msg . sender ) ; require ( job . proofOfLastWorkVerified == true ) ; } require ( job . noOfTotalPayments > job . noOfPaymentsMade ) ; uint currentPayment = job . salaryDeposited . div ( job . noOfTotalPayments ) ; job . paymentAvailableForWorker = job . paymentAvailableForWorker + currentPayment ; job . totalPaidToWorker = job . totalPaidToWorker + currentPayment ; job . noOfPaymentsMade ++ ; if ( job . noOfTotalPayments == job . noOfPaymentsMade ) { job . status = JobStatus . Completed ; } emit PaymentApproved ( msg . sender , _JobID , currentPayment ) ; }
function totalSupply ( ) public constant returns ( uint256 ) { return totalSupply_ - balances [ address ( 0 ) ] ; }
function refundTokens ( address _from , uint256 _amount ) public notTimeLocked stopInEmergency returns ( bool success ) { if ( tx . origin != _from ) { error ( 'refundTokens: tx.origin did not request the refund directly' ) ; return false ; } if ( addressSCICO != msg . sender ) { error ( 'refundTokens: caller is not the current ICO address' ) ; return false ; } if ( balances [ _from ] < _amount ) { error ( 'refundTokens: the amount to transfer is higher than your token balance' ) ; return false ; } if ( ! SCComplianceService . validate ( _from , addressSCICO , _amount ) ) { error ( 'transfer: not allowed by the compliance service' ) ; return false ; } balances [ _from ] = balances [ _from ] . sub ( _amount ) ; balances [ addressSCICO ] = balances [ addressSCICO ] . add ( _amount ) ; emit Transfer ( _from , addressSCICO , _amount ) ; return true ; }
function batchApprove ( address [ ] spenders , uint [ ] quantities ) external pausableIfNotSelfDestructing requireSameLength ( spenders . length , quantities . length ) returns ( bool ) { uint length = spenders . length ; for ( uint i = 0 ; i < length ; i ++ ) { approve ( spenders [ i ] , quantities [ i ] ) ; } return true ; }
function canAddAttribute ( uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) { bytes32 hash = calculateAttributeApprovalHash ( msg . sender , address ( 0 ) , attributeTypeID , value , fundsRequired , validatorFee ) ; address signingKey = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; address validator = _signingKeys [ signingKey ] ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; return ( fundsRequired >= minimumStake . add ( jurisdictionFee ) . add ( validatorFee ) && ! _invalidAttributeApprovalHashes [ hash ] && canValidate ( validator , attributeTypeID ) && ! _issuedAttributes [ msg . sender ] [ attributeTypeID ] . exists ) ; }
function sendTo ( address _recipient , uint _amount ) external onlyClient returns ( bool ) { if ( _recipient . send ( _amount ) ) return true ; else return false ; }
function changeCommission ( uint _newCommission ) public onlyOwner whenNotPaused { require ( _newCommission <= MAX_COMMISION ) ; require ( _newCommission != commission ) ; commission = _newCommission ; emit NewCommission ( commission ) ; }
function deedOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _deedId ) ;
function setupVote ( uint motionID ) internal returns ( uint ) { require ( motionVoting ( motionID ) ) ; require ( ! hasVoted ( msg . sender , motionID ) ) ; require ( msg . sender != motionTarget [ motionID ] ) ; uint weight = havven . recomputeLastAverageBalance ( msg . sender ) ; require ( weight > 0 ) ; voteWeight [ msg . sender ] [ motionID ] = weight ; return weight ; }
function transfer ( address _to , uint256 _value ) public returns ( bool ) { var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
function getTime ( ) internal returns ( uint ) { return now ; }
function initializeToken ( address _cnd ) public onlyController { assert ( CND ( _cnd ) . controller ( ) == address ( this ) ) ; assert ( CND ( _cnd ) . IS_CND_CONTRACT_MAGIC_NUMBER ( ) == 0x1338 ) ; require ( _cnd != 0x0 ) ; cnd = CND ( _cnd ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) external noFreeze { var _allowance = allowed [ _from ] [ _to ] ; if ( _from == selfAddress ) { monthlyLimit [ _to ] = safeSub ( monthlyLimit [ _to ] , _value ) ; require ( cooldown [ _to ] < now ) ; IOUSupply -= _value ; } balances [ _to ] = balances [ _to ] + _value ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; allowed [ _from ] [ _to ] = safeSub ( _allowance , _value ) ; addUser ( _to ) ; Transfer ( _from , _to , _value ) ; }
function release ( ) public { require ( now >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; }
function calculateInterest ( uint256 timeDelta , uint256 interestRate , uint256 amount ) internal pure returns ( uint256 realDelta , uint256 interest ) { if ( amount == 0 ) { interest = 0 ; realDelta = timeDelta ; } else { interest = safeMult ( safeMult ( 100000 , amount ) , timeDelta ) / interestRate ; realDelta = safeMult ( interest , interestRate ) / ( amount * 100000 ) ; } }
function setOraclizeTimeTolerance ( uint256 _oraclizeTimeTolerance ) onlyOwner public { oraclizeTimeTolerance = _oraclizeTimeTolerance ; }
function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( balances [ msg . sender ] >= _value ) { approved [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; } return false ; }
function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) ) ; }
function modifySecurityToken ( string _name , string _ticker , address _owner , address _securityToken , string _tokenDetails , uint256 _deployedAt ) external onlyOwner { require ( bytes ( _name ) . length > 0 && bytes ( _ticker ) . length > 0 , "String length > 0" ) ; require ( bytes ( _ticker ) . length <= 10 , "Ticker length range (0,10]" ) ; require ( _deployedAt != 0 && _owner != address ( 0 ) , "0 value params not allowed" ) ; string memory ticker = Util . upper ( _ticker ) ; require ( _securityToken != address ( 0 ) , "ST address is 0x" ) ; uint256 registrationTime = getUint ( Encoder . getKey ( "registeredTickers_registrationDate" , ticker ) ) ; uint256 expiryTime = getUint ( Encoder . getKey ( "registeredTickers_expiryDate" , ticker ) ) ; if ( registrationTime == 0 ) { registrationTime = now ; expiryTime = registrationTime . add ( getExpiryLimit ( ) ) ; } set ( Encoder . getKey ( "tickerToSecurityToken" , ticker ) , _securityToken ) ; _modifyTicker ( _owner , ticker , _name , registrationTime , expiryTime , true ) ; _storeSecurityTokenData ( _securityToken , ticker , _tokenDetails , _deployedAt ) ; emit NewSecurityToken ( ticker , _name , _securityToken , _owner , _deployedAt , msg . sender , true , getSecurityTokenLaunchFee ( ) ) ; }
function totalSupply ( ) constant returns ( uint256 totalAmount ) ;
function donateToFeePool ( uint n ) external optionalProxy returns ( bool ) { address sender = messageSender ; uint balance = tokenState . balanceOf ( sender ) ; require ( balance != 0 ) ; tokenState . setBalanceOf ( sender , safeSub ( balance , n ) ) ; tokenState . setBalanceOf ( FEE_ADDRESS , safeAdd ( tokenState . balanceOf ( FEE_ADDRESS ) , n ) ) ; emitFeesDonated ( sender , n ) ; emitTransfer ( sender , FEE_ADDRESS , n ) ; return true ; }
function setEthRate ( uint256 ethInWei ) isOwner { require ( ethInWei >= 0 ) ; ethRate = ethInWei ; }
function registerFor ( address _registrant , address _address , uint _timestamp , uint _gasLimit , uint _gasPrice ) public payable returns ( uint ) ;
function donateToFeePool ( uint n ) external optionalProxy returns ( bool ) { address sender = messageSender ; uint balance = tokenState . balanceOf ( sender ) ; require ( balance != 0 , "Must have a balance in order to donate to the fee pool" ) ; tokenState . setBalanceOf ( sender , safeSub ( balance , n ) ) ; tokenState . setBalanceOf ( FEE_ADDRESS , safeAdd ( tokenState . balanceOf ( FEE_ADDRESS ) , n ) ) ; emitFeesDonated ( sender , n ) ; emitTransfer ( sender , FEE_ADDRESS , n ) ; return true ; }
function unpause ( ) public anyOperator whenPaused { super . unpause ( ) ; }
function freezeTokens ( uint256 frozenAmount ) onlyOwner { require ( balanceOf [ address ( this ) ] >= frozenAmount ) ; frozenTokensSupply += frozenAmount ; balanceOf [ address ( this ) ] -= frozenAmount ; }
function onGenerateTokens ( address sender , address owner , uint256 amount ) public constant returns ( bool allow ) ;
function emergencyThaw ( ) isAdmin external { isFrozen = false ; }
function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; isOperatorFor [ _operator ] [ msg . sender ] = true ; emit AuthorizedOperator ( _operator , msg . sender ) ; }
function transferBalanceWithFee ( address _traderFrom , address _traderTo , address _token , uint256 _value , uint256 _fee , address _feePayee ) external onlyRenExSettlementContract ;
function getValidAttributeTypeID ( ) external view returns ( uint256 ) { return _validAttributeTypeID ; }
function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; CappedSTO cappedSTO = new CappedSTO ( msg . sender , address ( polyToken ) ) ; require ( getSig ( _data ) == cappedSTO . getInitFunction ( ) , "Provided data is not valid" ) ; require ( address ( cappedSTO ) . call ( _data ) , "Un-successfull call" ) ; emit LogGenerateModuleFromFactory ( address ( cappedSTO ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( cappedSTO ) ; }
function setWhiteList ( address [ NUMBER_OF_CHOICES ] whitelistedSenders ) external onlyOwner { whitelistedSenderAdresses = whitelistedSenders ; emit WhitelistUpdated ( whitelistedSenders ) ; }
function cancelJob ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( msg . sender != arbitrator ) { require ( job . manager == msg . sender ) ; require ( job . worker == 0x0 ) ; require ( job . status == JobStatus . Open ) ; } job . status = JobStatus . Cancelled ; uint returnAmount = job . salaryDeposited ; emit JobCancelled ( _JobID ) ; DAI . transfer ( job . manager , returnAmount ) ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = pixelIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
function symbol ( ) public view returns ( string ) ;
function _transferFromSenderPaysFee_byProxy ( address sender , address from , address to , uint value , bytes data ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; uint total = safeAdd ( value , fee ) ; tokenState . setAllowance ( from , sender , safeSub ( tokenState . allowance ( from , sender ) , total ) ) ; return _internalTransfer ( from , to , value , fee , data ) ; }
function setOperator ( address _operator , address _tokenHolder , bool _status ) external onlyModule returns ( bool ) { mAuthorized [ _operator ] [ _tokenHolder ] = _status ; return true ; }
function setLockTime ( uint256 locktimeParam , uint256 unlocktimeParam ) public onlyOwner { _unlocktime = unlocktimeParam ; _locktime = locktimeParam ; }
function performSellOrder ( OrderData data , uint256 amountToGiveForOrder ) public onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { approveAddress ( address ( exchange ) , data . tokenGet ) ; exchange . depositToken ( data . tokenGet , amountToGiveForOrder ) ; uint256 amountToTrade ; uint256 fee ; ( amountToTrade , fee ) = substractFee ( data . exchangeFee , amountToGiveForOrder ) ; trade ( data , amountToTrade ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = getPartialAmount ( data . amountGive , data . amountGet , amountToTrade ) ; exchange . withdraw ( amountReceivedFromOrder ) ; address ( totlePrimary ) . transfer ( amountReceivedFromOrder ) ; }
function _pause ( ) internal whenNotPaused { paused = true ; emit Pause ( now ) ; }
function put ( ContentMapping storage self , string _name , string _description , uint _reward ) public returns ( bool ) { require ( ! self . locked ) ; bytes32 _id = generateContentID ( _name ) ; require ( self . data [ _id ] . id == bytes32 ( 0 ) ) ; self . data [ _id ] = Content ( _id , _name , _description , block . timestamp , DeliverableUtils . newDeliverable ( _reward ) ) ; self . keys . push ( _id ) ; return true ; }
function getSupplyRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory utilizationRate0 , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory utilizationRate1 ) = mulScalar ( utilizationRate0 , oneMinusSpreadBasisPoints ) ; assert ( err1 == Error . NO_ERROR ) ; ( Error err2 , Exp memory supplyRate0 ) = mulExp ( utilizationRate1 , annualBorrowRate ) ; assert ( err2 == Error . NO_ERROR ) ; ( Error err3 , Exp memory standardSupplyRate ) = divScalar ( supplyRate0 , 10000 * blocksPerYear ) ; assert ( err3 == Error . NO_ERROR ) ; ( Error err4 , uint finalSupplyRate ) = div ( standardSupplyRate . mantissa , 2 ) ; assert ( err4 == Error . NO_ERROR ) ; return ( uint ( IRError . NO_ERROR ) , finalSupplyRate ) ; }
function userCancelActiveGame ( uint _gameId ) public { address userAddress = msg . sender ; uint gameId = userGameId [ userAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId , "inv gameId" ) ; if ( game . status == GameStatus . ACTIVE ) { game . endInitiatedTime = block . timestamp ; game . status = GameStatus . USER_INITIATED_END ; emit LogUserRequestedEnd ( msg . sender , gameId ) ; } else if ( game . status == GameStatus . SERVER_INITIATED_END && game . roundId == 0 ) { cancelActiveGame ( game , gameId , userAddress ) ; } else { revert ( ) ; } }
function removeExchange ( address ofExchange , uint exchangeIndex ) auth pre_cond ( exchangeInformation [ ofExchange ] . exists ) { require ( registeredExchanges [ exchangeIndex ] == ofExchange ) ; delete exchangeInformation [ ofExchange ] ; delete registeredExchanges [ exchangeIndex ] ; for ( uint i = exchangeIndex ; i < registeredExchanges . length - 1 ; i ++ ) { registeredExchanges [ i ] = registeredExchanges [ i + 1 ] ; } registeredExchanges . length -- ; assert ( ! exchangeInformation [ ofExchange ] . exists ) ; }
function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) internal { address senderImplementation = interfaceAddr ( _from , "ERC777TokensSender" ) ; if ( senderImplementation != 0 ) { ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { _safeTransferFrom ( _from , _to , _tokenId , "" ) ; }
function updateEthRateWithDelay ( uint delay ) internal { require ( delay >= 5 ) ; if ( oraclize_getPrice ( "URL" , ORACLIZE_GAS_LIMIT ) > this . balance ) { LogBalanceRequired ( ) ; } else { oraclize_query ( delay , "URL" , "json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0" , ORACLIZE_GAS_LIMIT ) ; } }
function getSecurityTokenData ( address _securityToken ) external view returns ( string , address , string , uint256 ) { return ( getString ( Encoder . getKey ( "securityTokens_ticker" , _securityToken ) ) , IOwnable ( _securityToken ) . owner ( ) , getString ( Encoder . getKey ( "securityTokens_tokenDetails" , _securityToken ) ) , getUint ( Encoder . getKey ( "securityTokens_deployedAt" , _securityToken ) ) ) ; }
function pay ( string currency , address merchant , uint amount , bool merchantPaysFees , bytes data ) public returns ( bool success ) { uint fees = calculateFees ( amount ) ; require ( lib . setAccountSpendingAmount ( msg . sender , lib . getFxUSDAmount ( currency , amount ) ) , "Error: Unable to set account spending amount." ) ; require ( lib . forceTransfer ( currency , msg . sender , merchant , amount , data ) , "Error: Unable to transfer funds to account" ) ; address feeContract = lib . getFeeContract ( address ( this ) ) ; if ( merchantPaysFees ) { require ( lib . forceTransfer ( currency , merchant , feeContract , fees , lib . getFeeMsg ( feeContract ) ) , "Error: Unable to transfer fees to fee contract." ) ; } else { require ( lib . forceTransfer ( currency , msg . sender , feeContract , fees , lib . getFeeMsg ( feeContract ) ) , "Error: Unable to transfer fees to fee contract." ) ; } return true ; }
function appendVestingEntry ( address account , uint time , uint quantity ) public onlyOwner onlyDuringSetup { require ( now < time , "Time must be in the future" ) ; require ( quantity != 0 , "Quantity cannot be zero" ) ; totalVestedBalance = safeAdd ( totalVestedBalance , quantity ) ; require ( totalVestedBalance <= havven . balanceOf ( this ) , "Must be enough balance in the contract to provide for the vesting entry" ) ; uint scheduleLength = vestingSchedules [ account ] . length ; require ( scheduleLength <= MAX_VESTING_ENTRIES , "Vesting schedule is too long" ) ; if ( scheduleLength == 0 ) { totalVestedAccountBalance [ account ] = quantity ; } else { require ( getVestingTime ( account , numVestingEntries ( account ) - 1 ) < time , "Cannot add new vested entries earlier than the last one" ) ; totalVestedAccountBalance [ account ] = safeAdd ( totalVestedAccountBalance [ account ] , quantity ) ; } vestingSchedules [ account ] . push ( [ time , quantity ] ) ; }
function tokenMetadata ( uint256 _tokenId ) external view returns ( string infoUrl ) { return appendUintToString ( metaBaseUrl , _tokenId ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return ownedTokens [ _owner ] . length ; }
function buysXid ( uint256 _gameID , uint256 [ ] memory _teamEth ) public payable isActivated ( _gameID ) isOngoing ( _gameID ) isNotPaused ( _gameID ) isNotClosed ( _gameID ) isHuman ( ) isWithinLimits ( msg . value ) { uint256 _pID = BMBook . getPlayerID ( msg . sender ) ; buysCore ( _gameID , _pID , _teamEth ) ; }
function length ( MapStorage storage self ) public view returns ( uint ) { return self . addresses . length ; }
function setFundingStartTime ( uint _proposalID , uint _startTime ) external ;
function buyoutAndSetReferrer ( uint256 _gameIndex , bool startNewGameIfIdle , uint256 x , uint256 y , address referrerAddress ) external payable { burnupHolding . setReferrer ( msg . sender , referrerAddress ) ; buyout ( _gameIndex , startNewGameIfIdle , x , y ) ; }
function reclaimDividend ( uint256 _dividendIndex ) public onlyOwner { require ( _dividendIndex < dividends . length , "Incorrect dividend index" ) ; require ( now >= dividends [ _dividendIndex ] . expiry , "Dividend expiry is in the future" ) ; require ( ! dividends [ _dividendIndex ] . reclaimed , "Dividend already claimed" ) ; dividends [ _dividendIndex ] . reclaimed = true ; Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 remainingAmount = dividend . amount . sub ( dividend . claimedAmount ) ; require ( ERC20 ( dividend . token ) . transfer ( msg . sender , remainingAmount ) , "Unable to transfer tokens" ) ; emit ERC20DividendReclaimed ( msg . sender , _dividendIndex , dividend . token , remainingAmount ) ; }
function getWhitelistStatus ( address _address ) external view returns ( bool _whitelisted ) { require ( msg . sender == whitelistingAddress ) ; return whitelist [ _address ] ; }
function release ( address token ) public { require ( msg . sender == creator ) ; uint256 unreleased = _releasableAmount ( token ) ; require ( unreleased > 0 ) ; _released [ token ] = _released [ token ] . add ( unreleased ) ; tokenReward . transfer ( _beneficiary , unreleased ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { assert ( msg . sender != address ( 0 ) ) ; assert ( _from != address ( 0 ) ) ; assert ( _to != address ( 0 ) ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( ! frozenAccount [ _from ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( tokenBalanceOf [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( tokenBalanceOf [ _from ] - _value < tokenBalanceOf [ _from ] ) ; require ( tokenBalanceOf [ _to ] + _value > tokenBalanceOf [ _to ] ) ; require ( _value > 0 ) ; orderToTransfer ( msg . sender , _from , _to , _value , "Order to transfer metadollars from allowed account" ) ; _transfer ( _from , _to , _value ) ; allowed [ _from ] [ msg . sender ] -= _value ; return true ; }
function safeSub ( uint256 a , uint256 b ) internal constant returns ( uint256 z ) { assert ( ( z = a - b ) <= a ) ; }
function setVault ( address _newVaultAddress ) public onlyOwner { vaultAddress = _newVaultAddress ; }
function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; address manualTransferManager = new ManualApprovalTransferManager ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( address ( manualTransferManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( manualTransferManager ) ; }
function sendTo ( address _recipient , uint _amount ) external returns ( bool ) ;
function licenseIssuedTime ( uint256 _licenseId ) public view returns ( uint256 ) { return licenses [ _licenseId ] . issuedTime ; }
function description ( bytes32 _symbol ) public view returns ( string ) { return get ( store , assetDescription , _symbol ) ; }
function changeEscapeHatchCaller ( address _newEscapeHatchCaller ) onlyEscapeHatchCaller { escapeHatchCaller = _newEscapeHatchCaller ; EscapeHatchCallerChanged ( escapeHatchCaller ) ; }
function bid ( uint256 _wave , uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . ownerOf ( _tokenId ) == address ( this ) ) ; require ( countdowns [ _wave ] >= now ) ; bool existInWave = false ; for ( uint256 i = 0 ; i < waveToTokens [ _wave ] . length ; i ++ ) { if ( waveToTokens [ _wave ] [ i ] == _tokenId ) { existInWave = true ; break ; } } require ( existInWave ) ; address oldBuyer = tokenToBuyer [ _tokenId ] ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( msg . sender != address ( 0 ) ) ; require ( msg . value > sellingPrice ) ; sellingPrice = msg . value ; uint256 newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , bonus [ _wave ] ) , percBase ) ; tokenToLastPrice [ _tokenId ] = sellingPrice ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; tokenToBuyer [ _tokenId ] = msg . sender ; if ( oldBuyer != address ( 0 ) ) { oldBuyer . transfer ( tokenToLastPrice [ _tokenId ] ) ; } Bid ( _tokenId , sellingPrice , newPrice , oldBuyer , msg . sender ) ; }
function changeHouseCutPercentage ( uint newHouseCutPercentage ) external onlyOwner { if ( newHouseCutPercentage >= 0 && newHouseCutPercentage < 20 ) { houseCutPercentage = newHouseCutPercentage ; emit HouseCutPercentageChanged ( newHouseCutPercentage ) ; } }
function assetThaw ( ) internal { isFrozen = false ; }
function tokenBurner ( uint256 _amount ) public onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( totalSupply . sub ( _amount ) > 0 ) ; require ( balances [ msg . sender ] > _amount ) ; require ( balances [ msg . sender ] . sub ( _amount ) > 0 ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; Transfer ( msg . sender , 0 , _amount ) ; return true ; }
function calcReward ( uint256 amount ) view public returns ( uint256 ) { if ( rate == 0 ) return 0 ; return amount . div ( rate ) ; }
function registerAsset ( address ofAsset , bytes32 inputName , bytes8 inputSymbol , uint inputDecimals , string inputUrl , string inputIpfsHash , address [ 2 ] breakInBreakOut , uint [ ] inputStandards , bytes4 [ ] inputFunctionSignatures ) auth pre_cond ( ! assetInformation [ ofAsset ] . exists ) { assetInformation [ ofAsset ] . exists = true ; registeredAssets . push ( ofAsset ) ; updateAsset ( ofAsset , inputName , inputSymbol , inputDecimals , inputUrl , inputIpfsHash , breakInBreakOut , inputStandards , inputFunctionSignatures ) ; assert ( assetInformation [ ofAsset ] . exists ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 ) { require ( _owner != address ( 0 ) , "null owner" ) ; return ownedTokens [ _owner ] . length ; }
function getAllIdentifiers ( ) external view returns ( uint256 [ ] ) { return identifiers ; }
function name ( ) public pure returns ( string result ) { return "An Etheal Promo" ; }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( _getApproved ( _tokenId ) == msg . sender ) ; require ( _ownerOf ( _tokenId ) == _from ) ; require ( _to != address ( 0 ) ) ; _clearApprovalAndTransfer ( _from , _to , _tokenId ) ; Approval ( _from , 0 , _tokenId ) ; Transfer ( _from , _to , _tokenId ) ; if ( isContract ( _to ) ) { bytes4 value = ERC721TokenReceiver ( _to ) . onERC721Received ( _from , _tokenId , "" ) ; if ( value != bytes4 ( keccak256 ( "onERC721Received(address,uint256,bytes)" ) ) ) { revert ( ) ; } } }
function onContribution ( address _contributor , uint256 _weiAmount , uint256 _tokens , uint256 _bonus ) public onlyCrowdsale ;
function append ( List storage self , address node ) internal { insertAfter ( self , end ( self ) , node ) ; }
function addBoardScore ( bytes32 boardHash , bytes32 playerName , uint score ) public returns ( bool ) { uint8 playerID = getPlayerId ( boardHash , playerName , 0 ) ; require ( playerID < 255 ) ; boards [ boardHash ] . players [ playerID ] . score_unconfirmed = score ; return true ; }
function resumePresale ( ) onlyOwner public returns ( bool ) { paused = false ; Resumed ( owner , now ) ; return true ; }
function getCampaignPriceById ( bytes32 bidId ) public view returns ( uint price ) { return campaigns [ bidId ] . getPrice ( ) ; }
function createRequestAsPayeeAction ( address [ ] _payeesIdAddress , address [ ] _payeesPaymentAddress , int256 [ ] _expectedAmounts , address _payer , address _payerRefundAddress , string _data ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( msg . sender == _payeesIdAddress [ 0 ] && msg . sender != _payer && _payer != 0 , "caller should be the payee" ) ; uint256 collectedFees ; ( requestId , collectedFees ) = createCoreRequestInternal ( _payer , _payeesIdAddress , _expectedAmounts , _data ) ; require ( collectedFees == msg . value , "fees should be the correct amout" ) ; for ( uint8 j = 0 ; j < _payeesPaymentAddress . length ; j = j . add ( 1 ) ) { payeesPaymentAddress [ requestId ] [ j ] = _payeesPaymentAddress [ j ] ; } if ( _payerRefundAddress != 0 ) { payerRefundAddress [ requestId ] = _payerRefundAddress ; } return requestId ; }
function getOpeningTS ( bytes32 question_id ) public view returns ( uint32 ) { return questions [ question_id ] . opening_ts ; }
function totalSupply ( ) public constant returns ( uint256 ) { return _totalSupply ; }
function startDistribution ( uint256 _currentPeriodRate ) onlyOwner public { require ( currentState != State . Distribution ) ; require ( _currentPeriodRate != 0 ) ; currentState = State . Distribution ; currentPeriodRate = _currentPeriodRate ; }
function transferTokens ( address _to , uint256 _amount ) external { require ( _to != address ( 0x00 ) ) ; require ( _amount > 0 ) ; uint256 balance = token . balanceOf ( this ) ; require ( balance >= _amount ) ; token . safeTransfer ( _to , _amount ) ; }
function setAccountSpendingPeriod ( Data storage self , address account , uint period ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'limit.spending.period' , account ) ) ; require ( self . Storage . setUint ( id , period ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function proposeOwnership ( address _newOwnerCandidate ) onlyOwner { newOwnerCandidate = _newOwnerCandidate ; OwnershipRequested ( msg . sender , newOwnerCandidate ) ; }
function clearKyc ( address [ ] _addrs ) public returns ( bool ) ;
function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balances [ target ] = balances [ target ] . plus ( mintedAmount ) ; totalSupply_ = totalSupply_ . plus ( mintedAmount ) ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
function unlock ( ) public returns ( bool success ) { uint256 amount = lockedBalance [ msg . sender ] ; require ( amount > 0 ) ; require ( now >= timeRelease [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; lockedBalance [ msg . sender ] = 0 ; timeRelease [ msg . sender ] = 0 ; emit Transfer ( 0x0 , msg . sender , amount ) ; emit UnLock ( msg . sender , amount ) ; return true ; }
function getCurrencyAddress ( ) external view returns ( address ) { return 0x9992eC3cF6A55b00978cdDF2b27BC6882d88D1eC ; }
function isDesignatedAssetManager ( address _manager , bytes32 _symbol ) public view returns ( bool ) { uint managerId = getHolderId ( _manager ) ; return isCreated ( _symbol ) && get ( store , assetPartowners , _symbol , managerId ) ; }
function addChunk3ToWhiteList ( ) external onlyOwner { require ( ! chunk3IsAdded ) ; addToWhitelist ( 0xd9b4cb7bf6a04f545c4c0e32d4570f16cbb3be56 , 0.5 ether ) ; addToWhitelist ( 0xDCfe2F26c4c47741851e0201a91FB3b8b6452C81 , 0.5 ether ) ; addToWhitelist ( 0xDf1734032A21Fc9F59E6aCE263b65E4c2bE29861 , 0.5 ether ) ; addToWhitelist ( 0xDFEa4bE32b1f777d82a6389a0d4F399569c46202 , 0.5 ether ) ; addToWhitelist ( 0xE18C42Ecb41d125FB21C61B9A18857A361aFC645 , 0.5 ether ) ; addToWhitelist ( 0xE3e29044291E4f2678c8C1859849a3126B95C2a4 , 0.5 ether ) ; addToWhitelist ( 0xE4B55adb4eCe93f4F53B3a18561BA876dbA3A2cb , 0.5 ether ) ; addToWhitelist ( 0xe96D559283cE2AFC3C79981dA4717bFfFAE69777 , 0.5 ether ) ; addToWhitelist ( 0xEA7F1b3e36eD60257D79a65d8BA2b305d31cEEE7 , 0.5 ether ) ; addToWhitelist ( 0xeaf61945762fa3408bfe286da7ea64bd212abfbf , 0.5 ether ) ; addToWhitelist ( 0xeC7715afA5Fd2833693Bfc3521EF5197716A65b0 , 0.5 ether ) ; addToWhitelist ( 0xee15AD84321176b2644d0894f28db22621c12b74 , 0.5 ether ) ; addToWhitelist ( 0xF05538779A8Ab41741e73a9650CE9B9FE1F3DEc7 , 0.5 ether ) ; addToWhitelist ( 0xF0c106d282648da9690Cd611F4654fF0e78DEf18 , 0.5 ether ) ; addToWhitelist ( 0xF132D556c8d065264A36d239b11Ad4Ad3d9f8f6e , 0.5 ether ) ; addToWhitelist ( 0xAac34A6B597240B1fAEBaEbeD762F0ecbe02fe18 , 0.5 ether ) ; addToWhitelist ( 0xaae16c984ca5245E6AC3c646c1Fb3A9695d2f412 , 0.5 ether ) ; addToWhitelist ( 0xfc575d7064ad46804b28ddc4fce90860addaa256 , 0.5 ether ) ; addToWhitelist ( 0x4df33f230b862941c92585078eb549a7747c47bd , 0.51 ether ) ; addToWhitelist ( 0xaaF1Df7c351c71aD1Df94DB11Ec87b65F5e72531 , 0.51 ether ) ; addToWhitelist ( 0x5C3E4c34f8a12AFBF1b9d85dfc83953c310e4645 , 0.6 ether ) ; addToWhitelist ( 0x6580B24104BCAf1ba4171d6bB3B2F1D31a96C549 , 0.6 ether ) ; addToWhitelist ( 0x0F3B2d5e7C51700aC0986fCe669aB3c69601499a , 0.7 ether ) ; addToWhitelist ( 0x0b74911659bfc903d978ea57a70ea00fab893aa2 , 0.75 ether ) ; addToWhitelist ( 0x45cAa6B0a1d9Db9227DC3D883e31132Ef08F1980 , 0.75 ether ) ; addToWhitelist ( 0xAcC0F848404e484D6fEB8Bef3bc53DF1a80CB94A , 0.75 ether ) ; addToWhitelist ( 0x32c299f7df2e46549fd2dd73f540bf5e8c867d8a , 0.9 ether ) ; addToWhitelist ( 0x00aEc73b737Bf387c60094f993B8010f70C06d4e , 1 ether ) ; addToWhitelist ( 0x014b65Cf880129A5aC836bcb1C35305De529b59c , 1 ether ) ; addToWhitelist ( 0x03D74A8b469dDB568072923323B370d64E795b03 , 1 ether ) ; addToWhitelist ( 0x04E436cC3fCF465e82932DBd1c7598808Ed07b79 , 1 ether ) ; addToWhitelist ( 0x0545Cb34B8e136768dF9f889072a87FD83605480 , 1 ether ) ; addToWhitelist ( 0x0d421e17ABF7509113f3EF03C357Bc2aeF575cb7 , 1 ether ) ; addToWhitelist ( 0x0faF819dE159B151Dd20E304134a6c167B55D9C1 , 1 ether ) ; addToWhitelist ( 0x123d31DA8fCbc11ab3B507c61086a7444305fd44 , 1 ether ) ; addToWhitelist ( 0x16C96155328d9F22973502c2aB2CbEa06Fb3D1A4 , 1 ether ) ; addToWhitelist ( 0x16D6ddeA3cb142773ca7aD4b12842e47B9835C69 , 1 ether ) ; addToWhitelist ( 0x1C3DF26aAC85dC9bebB1E8C0a771705b38abF673 , 1 ether ) ; addToWhitelist ( 0x1d664ddD7A985bED478c94b029444BB43A13ba07 , 1 ether ) ; addToWhitelist ( 0x218A7E78a960B437c409222ED6b48C088C429949 , 1 ether ) ; addToWhitelist ( 0x232f4ADd6ee2d479A9178ea184a83D43C1dca70f , 1 ether ) ; addToWhitelist ( 0x23D6Fa98877C713C00968D43d7E1fE2B14ce443F , 1 ether ) ; addToWhitelist ( 0x241A410828DA842CFB24512b91004ba6bF555D0a , 1 ether ) ; addToWhitelist ( 0x3472bdEca240fDFE3A701254bdD62a6c10B2f0e7 , 1 ether ) ; addToWhitelist ( 0x36889c0Bc35F585062613B6dfa30365AdE826804 , 1 ether ) ; addToWhitelist ( 0x3775eF0bB806098e4678D7758f6b16595c4D0618 , 1 ether ) ; addToWhitelist ( 0x37c9909DFb1f13281Cc0109f5C4F4775a337df7c , 1 ether ) ; addToWhitelist ( 0x3831ee9f3be7ac81d6653d312adefedbf8ede843 , 1 ether ) ; addToWhitelist ( 0x38c9606DAaD44fEB86144ab55107a3154DddCf5c , 1 ether ) ; addToWhitelist ( 0x400d654A92494958E630A928f9c2Cfc9a0A8e011 , 1 ether ) ; addToWhitelist ( 0x42593b745B20f03d36137B6E417C222c1b0FE1a8 , 1 ether ) ; addToWhitelist ( 0x435ca13E9814e0edd2d203E3e14AD9dbcBd19224 , 1 ether ) ; chunk3IsAdded = true ; }
function approveAndCall ( address _operator , uint256 _amount , bytes _operatorData ) public whenNotPaused returns ( bool success ) { uint balanceAvailable = getAmountOfUnlockedTokens ( msg . sender ) ; require ( balanceAvailable >= _amount , "The amount of unlocked tokens must be >= the amount sent" ) ; mAllowed [ msg . sender ] [ _operator ] = _amount ; callOperator ( _operator , msg . sender , _operator , _amount , "0x0" , _operatorData , true ) ; emit Approval ( msg . sender , _operator , _amount ) ; return true ; }
function auditContract ( bytes32 _codeHash , bool _isApproved ) public whenNotPaused { bytes32 hashAuditorCode = keccak256 ( msg . sender , _codeHash ) ; uint8 outcome = auditOutcomes [ hashAuditorCode ] ; require ( outcome == NOT_AUDITED ) ; if ( _isApproved ) auditOutcomes [ hashAuditorCode ] = AUDITED_AND_APPROVED ; else auditOutcomes [ hashAuditorCode ] = AUDITED_AND_REJECTED ; uint reward = rewards [ hashAuditorCode ] ; totalRequestsAmount = totalRequestsAmount . sub ( reward ) ; commission = calcCommission ( reward ) ; availableCommission = availableCommission . add ( commission ) ; emit ContractAudited ( msg . sender , _codeHash , reward , _isApproved ) ; msg . sender . transfer ( reward . sub ( commission ) ) ; }
function transferAndCall ( address _to , uint256 _amount , bytes _data ) external returns ( bool ) { require ( transfer ( _to , _amount ) ) ; emit Transfer ( msg . sender , _to , _amount , _data ) ; if ( isContract ( _to ) ) { require ( contractFallback ( _to , _amount , _data ) ) ; } return true ; }
function canDeposit ( bytes32 channelId , address origin ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isSender = channel . sender == origin ; return isOpen ( channelId ) && isSender ; }
function closeCrowdsale ( ) onlyOwner { require ( block . timestamp > END_DATE || crowdsaleCanceled || balances [ this ] == 0 ) ; transferable = true ; if ( balances [ this ] > 0 ) { uint256 amount = balances [ this ] ; balances [ MULTISIG_WALLET_ADDRESS ] = safeAdd ( balances [ MULTISIG_WALLET_ADDRESS ] , amount ) ; balances [ this ] = 0 ; Transfer ( this , MULTISIG_WALLET_ADDRESS , amount ) ; } }
function acceptAction ( bytes32 _requestId ) public whenNotPaused onlyRequestPayer ( _requestId ) { require ( requestCore . getState ( _requestId ) == RequestCore . State . Created , "request should be created" ) ; requestCore . accept ( _requestId ) ; }
function isCanvasFinished ( uint32 _canvasId ) public view returns ( bool ) { return _isCanvasFinished ( _getCanvas ( _canvasId ) ) ; }
function getPermission ( bytes4 _methodsignature ) public view returns ( string name , string description , string contract_name , bool active ) { return ( permissions [ _methodsignature ] . name , permissions [ _methodsignature ] . description , permissions [ _methodsignature ] . contract_name , permissions [ _methodsignature ] . active ) ; }
function addValidator ( address validator , string description ) external onlyOwner whenNotPaused { require ( validator != address ( 0 ) , "must supply a valid address" ) ; require ( ! isValidator ( validator ) , "a validator with the provided address already exists" ) ; require ( _signingKeys [ validator ] == address ( 0 ) , "a signing key matching the provided address already exists" ) ; _validators [ validator ] = Validator ( { exists : true , index : _validatorAccounts . length , signingKey : validator , description : description } ) ; _signingKeys [ validator ] = validator ; _validatorAccounts . push ( validator ) ; emit ValidatorAdded ( validator , description ) ; }
function totalSupplyAt ( uint _blockNumber ) constant returns ( uint ) { if ( _blockNumber < creationBlock ) { return 0 ; } else if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( parentSnapShotBlock ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
function getPerson ( uint256 _tokenId ) public view returns ( string personName , uint64 satisfaction , uint64 cooldownTime , string slogan , uint256 basePrice , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; personName = person . name ; satisfaction = uint64 ( person . satisfaction ) ; cooldownTime = uint64 ( person . cooldownTime ) ; slogan = person . slogan ; basePrice = person . basePrice ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }
function finishICO ( ) public timedStateChange ( address ( 0 ) , 0 , true ) requiresState ( IcoState . ACTIVE ) onlymanyowners ( keccak256 ( msg . data ) ) { finishICOInternal ( ) ; }
function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) stateOpen ( question_id ) external { bytes32 answer_hash = keccak256 ( answer , nonce ) ; bytes32 commitment_id = keccak256 ( question_id , answer_hash , bond ) ; require ( ! commitments [ commitment_id ] . is_revealed ) ; require ( commitments [ commitment_id ] . reveal_ts > uint32 ( now ) ) ; commitments [ commitment_id ] . revealed_answer = answer ; commitments [ commitment_id ] . is_revealed = true ; if ( bond == questions [ question_id ] . bond ) { _updateCurrentAnswer ( question_id , answer , questions [ question_id ] . timeout ) ; } LogAnswerReveal ( question_id , msg . sender , answer_hash , answer , nonce , bond ) ; }
function blacklistParty ( address _address , bool _motion ) public onlyOwner ( ) { blacklist [ _address ] = _motion ; }
function transfer ( address _to , uint256 _amount , bytes _data ) public returns ( bool success ) { return transferFrom ( msg . sender , _to , _amount , _data ) ; }
function removeAddressesFromAdmins ( address [ ] _admins ) external onlyOwner { require ( _admins . length > 0 , "Cannot remove an empty list to admins!" ) ; for ( uint256 i = 0 ; i < _admins . length ; ++ i ) { address user = _admins [ i ] ; if ( admins [ user ] ) { admins [ user ] = false ; emit AdminRemoved ( user ) ; } } }
function hashOrder ( bytes details , OrderDetails memory order ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( details , order . settlementID , order . tokens , order . price , order . volume , order . minimumVolume ) ) ; }
function getTagByModuleType ( uint8 _moduleType ) public view returns ( bytes32 [ ] ) ;
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) public returns ( bool success ) ;
function airdrop ( address _token , uint256 _amount , address [ ] memory _targets ) public onlyOwner { require ( _targets . length > 0 , 'Target addresses must not be 0' ) ; require ( _targets . length <= 64 , 'Target array length is too big' ) ; require ( _amount * _targets . length <= ERC20 ( _token ) . balanceOf ( address ( this ) ) , 'Airdrop contract does not have enough tokens to execute the airdrop' ) ; for ( uint8 target = 0 ; target < _targets . length ; target ++ ) { ERC20 ( _token ) . transfer ( _targets [ target ] , _amount ) ; } }
function freeClaimAllowanceOf ( address addr ) external view returns ( uint256 ) { return freeClaimAllowance [ addr ] ; }
function balanceOf ( address tokenOwner ) constant public returns ( uint coinBalance ) { return balanceOf [ tokenOwner ] ; }
function updateTreasury ( address _treasury , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _treasury ) , _block ) ; if ( OK != _code ) { return _code ; } treasury = _treasury ; return OK ; }
function allowPublicTransfer ( ) onlyOwner { isPublicTransferAllowed = true ; }
function unlock ( ) external { require ( now >= unlockDate ) ; uint256 entitled = allocations [ msg . sender ] ; require ( entitled > 0 ) ; allocations [ msg . sender ] = 0 ; if ( ! StandardToken ( gmtAddress ) . transfer ( msg . sender , entitled ) ) { revert ( ) ; } }
function destroy ( ) onlyOwner { uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; selfdestruct ( owner ) ; }
function setActiveTimes ( uint256 [ ] _from , uint256 [ ] _to ) external onlyCFO { require ( _from . length == _to . length ) ; activeTimesFrom = _from ; activeTimesTo = _to ; ActiveTimes ( _from , _to ) ; }
function isRegisteredAuthority ( address authority ) public view returns ( bool registered ) { return lib . isRegisteredAuthority ( authority ) ; }
function upgradeFrom ( address _from , uint256 _value ) public { if ( finalizedUpgrade ) revert ( ) ; if ( msg . sender != address ( oldToken ) ) revert ( ) ; if ( _from == decentBetMultisig ) revert ( ) ; if ( ! newToken . isNewToken ( ) ) revert ( ) ; setUpgradeHasBegun ( ) ; safetyInvariantCheck ( _value ) ; newToken . createToken ( _from , _value ) ; safetyInvariantCheck ( 0 ) ; }
function authorizePayment ( string _name , bytes32 _reference , address _recipient , uint _amount , uint _paymentDelay ) returns ( uint ) { if ( ! allowedSpenders [ msg . sender ] ) throw ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; if ( _paymentDelay > 10 ** 18 ) throw ; p . earliestPayTime = _paymentDelay >= timeLock ? now + _paymentDelay : now + timeLock ; p . recipient = _recipient ; p . amount = _amount ; p . name = _name ; p . reference = _reference ; PaymentAuthorized ( idPayment , p . recipient , p . amount ) ; return idPayment ; }
function isSecurityToken ( address _securityToken ) public view returns ( bool ) ;
function depositToken ( ERC20 token , uint amount ) returns ( bool ) { if ( token . allowance ( msg . sender , this ) < amount ) { ErrorReport ( tx . origin , 0x850000001 , token . allowance ( msg . sender , this ) ) ; return false ; } if ( ! token . transferFrom ( msg . sender , this , amount ) ) { ErrorReport ( tx . origin , 0x850000002 , uint ( token ) ) ; return false ; } DepositToken ( token , amount ) ; return true ; }
function updatePolyTokenAddress ( address _newAddress ) external onlyOwner { require ( _newAddress != address ( 0 ) , "Invalid address" ) ; set ( POLYTOKEN , _newAddress ) ; }
function burnToken ( address _target , uint256 _burnedAmount ) onlyAdmin public { balances [ _target ] = SafeMath . sub ( balances [ _target ] , _burnedAmount ) ; totalSupply = SafeMath . sub ( totalSupply , _burnedAmount ) ; Burned ( _target , _burnedAmount ) ; }
function getPlace ( uint256 _tokenId ) public view returns ( string placeName , string placeCountry , string placeOwnerName , uint256 sellingPrice , address owner ) { Place storage place = places [ _tokenId ] ; placeName = place . name ; placeCountry = place . country ; placeOwnerName = place . owner_name ; sellingPrice = placeIndexToPrice [ _tokenId ] ; owner = placeIndexToOwner [ _tokenId ] ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( isTransferWhitelistOnly ) { require ( isUserAllowedToTransfer ( _from ) ) ; } return super . transferFrom ( _from , _to , _value ) ; }
function getDisputeFee ( bytes32 question_id ) public constant returns ( uint256 ) { return ( custom_dispute_fees [ question_id ] > 0 ) ? custom_dispute_fees [ question_id ] : dispute_fee ; }
function adminRemoveTrustedCurrencyContract ( address _oldTrustedContractAddress ) external onlyOwner { require ( trustedCurrencyContracts [ _oldTrustedContractAddress ] != 0 , "_oldTrustedContractAddress should not be 0" ) ; trustedCurrencyContracts [ _oldTrustedContractAddress ] = 0 ; emit RemoveTrustedContract ( _oldTrustedContractAddress ) ; }
function metaIncreaseApproval ( address _spender , uint256 _addedValue , bytes _signature , uint256 _nonce , uint256 _reward ) public userNotBlacklisted ( _spender ) whenNotPaused returns ( bool ) { bytes32 metaHash = metaApproveHash ( _spender , _addedValue , _nonce , _reward ) ; address signer = _getSigner ( metaHash , _signature ) ; require ( ! regulator . isBlacklistedUser ( signer ) , "signer is blacklisted" ) ; require ( _nonce == replayNonce [ signer ] , "this transaction has already been broadcast" ) ; replayNonce [ signer ] ++ ; require ( _reward > 0 , "reward to incentivize relayer must be positive" ) ; require ( _reward <= balanceOf ( signer ) , "not enough balance to reward relayer" ) ; _increaseApproval ( _spender , _addedValue , signer ) ; _transfer ( msg . sender , signer , _reward ) ; return true ; }
function canTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) { from ; if ( value > 0 ) { return ( false , bytes1 ( hex"A0" ) ) ; } if ( ! _isApprovedOrOwner ( msg . sender , tokenId ) ) { return ( false , bytes1 ( hex"A0" ) ) ; } if ( to == address ( 0 ) ) { return ( false , bytes1 ( hex"A0" ) ) ; } if ( ! _registry . hasAttribute ( to , _validAttributeTypeID ) ) { return ( false , bytes1 ( hex"10" ) ) ; } return ( true , bytes1 ( hex"01" ) ) ; }
function getTokenAddressArray ( ) public view returns ( address [ ] _arrayToReturn ) { _arrayToReturn = tokenAddress ; }
function claimTokens ( uint256 amount , address beneficiary ) onlyOwner external { require ( token . transfer ( beneficiary , amount ) ) ; }
function finalize ( ) external { if ( ! funding ) throw ; if ( ( block . number <= fundingEndBlock || totalTokens < tokenCreationMin ) && totalTokens < tokenCreationCap ) throw ; funding = false ; if ( ! bitplusAddress . send ( this . balance ) ) throw ; for ( uint i = 0 ; i < earlyBackers . length ; i ++ ) { if ( earlyBackers [ i ] . deposited != uint256 ( 0 ) ) { uint256 percentage = ( earlyBackers [ i ] . deposited * earlyBackers [ i ] . agreedPercentage / earlyBackers [ i ] . agreedEthPrice ) ; uint256 additionalTokens = totalTokens * percentage / ( 10000 - percentage ) ; address backerAddr = earlyBackers [ i ] . backerAddress ; balances [ backerAddr ] = additionalTokens ; totalTokens += additionalTokens ; Transfer ( 0 , backerAddr , additionalTokens ) ; } } }
function opened ( ) constant returns ( uint ) { return data . opened ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }
function onApprove ( address _owner , address _spender , uint _amount ) public initialized returns ( bool ) { return false ; }
function setDefaultReputationForManufacturer ( bytes32 _manufacturerId , bytes32 _newDefaultScore ) public onlyOwner returns ( bool ) { require ( _manufacturerId != 0 , "_manufacturerId is required" ) ; require ( _newDefaultScore != defaultManufacturerReputations [ _manufacturerId ] , "_newDefaultScore should be different" ) ; defaultManufacturerReputations [ _manufacturerId ] = _newDefaultScore ; emit DefaultReputationScoreChanged ( msg . sender , _manufacturerId , _newDefaultScore ) ; return true ; }
function transferAnyERC20Token ( address addr , uint256 tokens ) public onlyOwner returns ( bool success ) { requireTrade ( addr ) ; return ERC20Interface ( addr ) . transfer ( owner , tokens ) ; }
function unpause ( ) public onlyCEO whenPaused { require ( geneScience != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
function proxyPayment ( address _owner ) public payable returns ( bool ) { return false ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable ;
function authorizeSpender ( address _spender , bool _authorize ) onlyOwner { allowedSpenders [ _spender ] = _authorize ; SpenderAuthorization ( _spender , _authorize ) ; }
function approve ( address _to , uint256 _deedId ) external whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; approveMultiple ( _to , _deedIds ) ; }
function claimReimbursement ( address _user ) public isAwaitingOrCompleted userHasFundedPool ( _user ) { processReimbursementInternal ( _user ) ; }
function performSellOrder ( OrderData order , uint256 amountToGiveForOrder ) public onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { approveAddress ( address ( exchange ) , order . addresses [ 2 ] ) ; exchange . depositTokens ( order . addresses [ 2 ] , amountToGiveForOrder ) ; uint256 feeRate = exchange . feeRate ( ) ; uint256 amountToGive = SafeMath . div ( SafeMath . mul ( amountToGiveForOrder , feeRate ) , SafeMath . add ( feeRate , 1 ) ) ; exchange . takeBuyOrder ( order . addresses , order . values , amountToGive , order . v , order . r , order . s ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = SafeMath . div ( SafeMath . mul ( amountToGive , order . values [ 0 ] ) , order . values [ 1 ] ) ; exchange . withdrawEthers ( amountReceivedFromOrder ) ; address ( totlePrimary ) . transfer ( amountReceivedFromOrder ) ; }
function process_contribution ( address _toAddr ) internal { require ( ( campaignState == 2 ) && ( now <= tCampaignEnd ) && ( paused == false ) ) ; if ( ( now > tBonusStageEnd ) && ( now < tRegSaleStart ) ) { revert ( ) ; } if ( ( now <= tBonusStageEnd ) && ( ( msg . value < bonusMinContribution ) || ( tokensGenerated >= bonusTokenThreshold ) ) ) { revert ( ) ; } require ( msg . value >= minContribution ) ; uint256 rate = get_rate ( ) ; uint256 nTokens = ( rate . mul ( msg . value ) ) . div ( 1 ether ) ; uint256 opEth = ( PRCT_ETH_OP . mul ( msg . value ) ) . div ( 100 ) ; opVaultAddr . transfer ( opEth ) ; require ( do_grant_tokens ( _toAddr , nTokens ) ) ; amountRaised = amountRaised . add ( msg . value ) ; TokenGranted ( _toAddr , nTokens ) ; TotalRaised ( amountRaised ) ; }
function receiveApproval ( address _sender , uint256 _value , bytes _extraData ) public ;
function adminWithdrawBalance ( ) external onlyAdmin { uint256 adminPrize = adminPool ; adminPool = 0 ; adminAddress . transfer ( adminPrize ) ; }
function unpause ( ) public onlyGameManager whenPaused { paused = false ; }
function _burn ( address _owner , uint256 _tokenId ) internal { super . _burn ( _owner , _tokenId ) ; assert ( tokens . length > 0 ) ; uint256 tokenIndex = idToIndex [ _tokenId ] ; assert ( tokens [ tokenIndex ] == _tokenId ) ; uint256 lastTokenIndex = tokens . length - 1 ; uint256 lastToken = tokens [ lastTokenIndex ] ; tokens [ tokenIndex ] = lastToken ; tokens . length -- ; idToIndex [ lastToken ] = tokenIndex ; idToIndex [ _tokenId ] = 0 ; }
function _payDividend ( address _payee , Dividend storage _dividend , uint256 _dividendIndex ) internal { ( uint256 claim , uint256 withheld ) = calculateDividend ( _dividendIndex , _payee ) ; _dividend . claimed [ _payee ] = true ; uint256 claimAfterWithheld = claim . sub ( withheld ) ; if ( claimAfterWithheld > 0 ) { if ( _payee . send ( claimAfterWithheld ) ) { _dividend . claimedAmount = _dividend . claimedAmount . add ( claim ) ; _dividend . dividendWithheld = _dividend . dividendWithheld . add ( withheld ) ; investorWithheld [ _payee ] = investorWithheld [ _payee ] . add ( withheld ) ; emit EtherDividendClaimed ( _payee , _dividendIndex , claim , withheld ) ; } else { _dividend . claimed [ _payee ] = false ; emit EtherDividendClaimFailed ( _payee , _dividendIndex , claim , withheld ) ; } } }
function mintToken ( address target , uint256 mintedOshiAmount ) onlyOwner public returns ( bool ) { balanceOf [ target ] = balanceOf [ target ] . add ( mintedOshiAmount ) ; totalSupply = totalSupply . add ( mintedOshiAmount ) ; emit Transfer ( 0 , address ( this ) , mintedOshiAmount ) ; emit Transfer ( address ( this ) , target , mintedOshiAmount ) ; return true ; }
function trade ( OrderData data , uint256 amountToTrade ) internal { exchange . trade ( data . tokenGet , data . amountGet , data . tokenGive , data . amountGive , data . expires , data . nonce , data . user , data . v , data . r , data . s , amountToTrade ) ; }
function getGirl ( uint256 _tokenId ) public view returns ( string girlName , uint256 sellingPrice , address owner ) { Girl storage girl = girls [ _tokenId ] ; girlName = girl . name ; sellingPrice = girlIndexToPrice [ _tokenId ] ; owner = girlIndexToOwner [ _tokenId ] ; }
function transfer ( address from , address to , uint amount ) public onlyTransferAgent returns ( bool ) { require ( to != 0x0 , "Cannot transfer tokens to the null address." ) ; require ( amount > 0 , "Cannot transfer zero tokens." ) ; Holding memory fromHolding = heldTokens [ from ] ; require ( fromHolding . quantity >= amount , "Not enough tokens to perform the transfer." ) ; require ( ! isExistingHolding ( to ) , "Cannot overwrite an existing holding, use a new wallet." ) ; heldTokens [ from ] = Holding ( fromHolding . quantity . sub ( amount ) , fromHolding . releaseDate , fromHolding . isAffiliate ) ; heldTokens [ to ] = Holding ( amount , fromHolding . releaseDate , false ) ; emit TokensTransferred ( from , to , amount ) ; return true ; }
function getSecurityTokenAddress ( string _ticker ) external view returns ( address ) ;
function getStraightReleasableAmount ( address _beneficiary ) internal view returns ( uint releasableAmount ) { Beneficiary memory _b = beneficiaries [ _beneficiary ] ; Release memory _r = releases [ _beneficiary ] ; uint totalReleasableAmount = getTotalLockedAmounts ( _beneficiary ) ; uint firstTime = _r . releaseTimes [ 0 ] ; uint lastTime = _r . releaseTimes [ 1 ] ; require ( now >= firstTime ) ; if ( now >= lastTime ) { releasableAmount = totalReleasableAmount ; } else { uint firstAmount = getPartialAmount ( _r . releaseRatios [ 0 ] , coeff , totalReleasableAmount ) ; releasableAmount = getPartialAmount ( now . sub ( firstTime ) , lastTime . sub ( firstTime ) , totalReleasableAmount . sub ( firstAmount ) ) ; releasableAmount = releasableAmount . add ( firstAmount ) ; } releasableAmount = releasableAmount . sub ( _b . withdrawAmount ) ; }
function incrementalInverse ( uint256 totalEuroUlps , uint256 burnNeumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public pure returns ( uint256 euroUlps ) { uint256 totalNeumarkUlps = cumulative ( totalEuroUlps ) ; require ( totalNeumarkUlps >= burnNeumarkUlps ) ; uint256 fromNmk = totalNeumarkUlps - burnNeumarkUlps ; uint newTotalEuroUlps = cumulativeInverse ( fromNmk , minEurUlps , maxEurUlps ) ; assert ( totalEuroUlps >= newTotalEuroUlps ) ; return totalEuroUlps - newTotalEuroUlps ; }
function setPlayerOverrideId ( uint256 _tokenId , uint256 _newOverrideId ) public onlyManager whenNotPaused { require ( exists ( _tokenId ) ) ; _updatePlayerOverrideId ( _tokenId , _newOverrideId ) ; }
function claim ( ) public { claimAddress ( msg . sender ) ; }
function approveAndCall ( address spender , uint256 tokenAmount , bytes data ) public tradable ( spender ) returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokenAmount ; emit Approval ( msg . sender , spender , tokenAmount ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokenAmount , this , data ) ; return true ; }
function ownerWithdrawUnspentCredits ( ) external onlyOwner { require ( now >= PRESALE_END_DATE ) ; require ( now < TOKEN_WITHDRAWAL_START_DATE ) ; require ( totalFunding >= PRESALE_MINIMUM_FUNDING ) ; require ( ! unspentCreditsWithdrawn ) ; uint256 currentCredits = parsecToken . balanceOf ( this ) ; uint256 unspentAmount = currentCredits . sub ( grantedParsecCredits ) ; unspentCreditsWithdrawn = true ; parsecToken . transfer ( owner , unspentAmount ) ; }
function sendGiftCard ( address _address ) external onlyAuto { uint256 existing = cards . getOwnedCount ( _address , 1 ) ; require ( existing < schema . getMaxCAP ( ) ) ; require ( SafeMath . add ( existing , 1 ) <= schema . getMaxCAP ( ) ) ; cards . updatePlayersCoinByPurchase ( _address , 0 ) ; if ( schema . unitCoinProduction ( 1 ) > 0 ) { cards . increasePlayersJadeProduction ( _address , cards . getUnitsProduction ( _address , 1 , 1 ) ) ; cards . setUintCoinProduction ( _address , 1 , cards . getUnitsProduction ( _address , 1 , 1 ) , true ) ; } if ( cards . getUintsOwnerCount ( _address ) <= 0 ) { cards . AddPlayers ( _address ) ; } cards . setUintsOwnerCount ( _address , 1 , true ) ; cards . setOwnedCount ( _address , 1 , 1 , true ) ; UnitBought ( _address , 1 , 1 ) ; }
function getName ( ) public view returns ( bytes32 ) { return "GeneralPermissionManager" ; }
function setProxy ( address _proxyAddress , bytes32 _symbol ) public onlyOneOfContractOwners returns ( uint ) { if ( proxies [ _symbol ] != 0x0 ) { return ATX_PLATFORM_PROXY_ALREADY_EXISTS ; } proxies [ _symbol ] = _proxyAddress ; return OK ; }
function acceptOwnership ( ) external onlyNominatedOwner { owner = nominatedOwner ; nominatedOwner = address ( 0 ) ; emit OwnerChanged ( owner , nominatedOwner ) ; }
function exchangeEtherForHavvensAtRate ( uint guaranteedEtherRate , uint guaranteedHavvenRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedEtherRate == usdToEthPrice ) ; require ( guaranteedHavvenRate == usdToHavPrice ) ; return exchangeEtherForHavvens ( ) ; }
function extGoalReached ( ) afterDeadline external { require ( ICOAddress != 0x0 ) ; require ( msg . sender == ICOAddress ) ; goalReached ( ) ; }
function addInvestorBonusInTokens ( address _to , uint tokens ) public onlyOwner { _freezeTransfer ( _to , tokens ) ; investorGiven = investorGiven . add ( tokens ) ; require ( investorGiven <= investorSupply ) ; }
function freezeTransfers ( ) external onlyOwner { require ( ! transfersFrozen , "Already frozen" ) ; transfersFrozen = true ; emit FreezeTransfers ( true , now ) ; }
function setTokenSymbol ( Data storage self , string tokenSymbol ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.symbol' , address ( this ) ) ) ; require ( self . Storage . setString ( id , tokenSymbol ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function generateContentID ( string _name ) public pure returns ( bytes32 ) { return keccak256 ( _name ) ; }
function onApprove ( address _owner , address _spender , uint _amount ) returns ( bool ) { return false ; }
function getCampaignStartDateById ( bytes32 bidId ) public view returns ( uint startDate ) { return campaigns [ bidId ] . getStartDate ( ) ; }
function setWhitelistStatus ( address _address , bool _whitelisted ) external { require ( msg . sender == whitelistingAddress ) ; require ( whitelist [ _address ] != _whitelisted ) ; whitelist [ _address ] = _whitelisted ; emit WhitelistChanged ( _address , _whitelisted ) ; }
function registerEndpoint ( string endpoint ) public noEmptyString ( endpoint ) { string storage old_endpoint = address_to_endpoint [ msg . sender ] ; if ( equals ( old_endpoint , endpoint ) ) { return ; } address_to_endpoint [ msg . sender ] = endpoint ; emit AddressRegistered ( msg . sender , endpoint ) ; }
function transfer ( address _to , uint256 _value ) onlyPayloadSize ( 2 * 32 ) returns ( bool success ) { if ( _to != 0x0 && _value > 0 && balances [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; if ( msg . sender == owner && _to != owner ) { shareholdersBalance += _value ; } if ( msg . sender != owner && _to == owner ) { shareholdersBalance -= _value ; } if ( owner != _to ) { insertShareholder ( _to ) ; } Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }
function setSelfDestructBeneficiary ( address _beneficiary ) external onlyOwner { require ( _beneficiary != address ( 0 ) ) ; selfDestructBeneficiary = _beneficiary ; emit SelfDestructBeneficiaryUpdated ( _beneficiary ) ; }
function transferFeeIncurred ( uint value ) public view returns ( uint ) { return value . multiplyDecimal ( transferFeeRate ) ; }
function getChannelIdentifier ( address participant , address partner ) view public returns ( uint256 ) { require ( participant != address ( 0x0 ) ) ; require ( partner != address ( 0x0 ) ) ; require ( participant != partner ) ; bytes32 pair_hash = getParticipantsHash ( participant , partner ) ; return participants_hash_to_channel_identifier [ pair_hash ] ; }
function getOrderPrice ( address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( uint orderPrice ) { return mul ( buyQuantity , 10 ** uint ( getDecimals ( sellAsset ) ) ) / sellQuantity ; }
function initialize ( address _permissionsCreator ) onlyInit public { initialized ( ) ; require ( msg . sender == address ( kernel ) ) ; _createPermission ( _permissionsCreator , this , CREATE_PERMISSIONS_ROLE , _permissionsCreator ) ; }
function commitVote ( uint _pollID , bytes32 _secretHash , uint _numTokens , uint _prevPollID ) public { require ( commitPeriodActive ( _pollID ) ) ; if ( voteTokenBalance [ msg . sender ] < _numTokens ) { uint remainder = _numTokens . sub ( voteTokenBalance [ msg . sender ] ) ; requestVotingRights ( remainder ) ; } require ( voteTokenBalance [ msg . sender ] >= _numTokens ) ; require ( _pollID != 0 ) ; require ( _secretHash != 0 ) ; require ( _prevPollID == 0 || dllMap [ msg . sender ] . contains ( _prevPollID ) ) ; uint nextPollID = dllMap [ msg . sender ] . getNext ( _prevPollID ) ; if ( nextPollID == _pollID ) { nextPollID = dllMap [ msg . sender ] . getNext ( _pollID ) ; } require ( validPosition ( _prevPollID , nextPollID , msg . sender , _numTokens ) ) ; dllMap [ msg . sender ] . insert ( _prevPollID , _pollID , nextPollID ) ; bytes32 UUID = attrUUID ( msg . sender , _pollID ) ; store . setAttribute ( UUID , "numTokens" , _numTokens ) ; store . setAttribute ( UUID , "commitHash" , uint ( _secretHash ) ) ; pollMap [ _pollID ] . didCommit [ msg . sender ] = true ; emit _VoteCommitted ( _pollID , _numTokens , msg . sender ) ; }
function fulfilled ( bytes32 _missionId , address _buyerId ) public { require ( identity . verifyOwnership ( _buyerId , msg . sender ) ) ; require ( missions [ _missionId ] . isSigned == false ) ; require ( missions [ _missionId ] . balance == missions [ _missionId ] . cost ) ; missions [ _missionId ] . isSigned = true ; missions [ _missionId ] . balance = 0 ; token . approve ( this , missions [ _missionId ] . cost ) ; token . transferFrom ( this , identity . getIdentityWallet ( missions [ _missionId ] . seller ) , missions [ _missionId ] . cost ) ; emit Signed ( _missionId ) ; }
function launchContract ( ) onlyOwner returns ( bool launched ) { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; EnableTokenMinting ( true ) ; return true ; }
function _sellCrowd ( uint cst , address _to ) private { require ( cst >= crowdsaleMinUSD ) ; if ( crowdsaleSold . add ( cst ) <= crowdsaleSupply ) { crowdsaleSold = crowdsaleSold . add ( cst ) ; } else { presaleSold = presaleSold . add ( crowdsaleSold ) . add ( cst ) . sub ( crowdsaleSupply ) ; require ( presaleSold <= presaleSupply ) ; crowdsaleSold = crowdsaleSupply ; } if ( now < crowdsaleStartTime + 3 days ) { if ( whitemap [ _to ] >= cst ) { whitemap [ _to ] -= cst ; whitelistTokens -= cst ; } else { require ( crowdsaleSupply . add ( presaleSupply ) . sub ( presaleSold ) >= crowdsaleSold . add ( whitelistTokens ) ) ; } } }
function withdraw ( uint256 amount ) public ;
function checkTransfer ( address from , uint tokens ) public view { uint newBalance = balances [ from ] . sub ( tokens ) ; uint total = 0 ; if ( now < unlockDate5 ) { require ( now >= unlockDate1 ) ; uint frzdPercent = 0 ; if ( now < unlockDate2 ) { frzdPercent = 80 ; } else if ( now < unlockDate3 ) { frzdPercent = 60 ; } else if ( now < unlockDate4 ) { frzdPercent = 40 ; } else { frzdPercent = 20 ; } total = freezed [ from ] . mul ( frzdPercent ) . div ( 100 ) ; require ( newBalance >= total ) ; } if ( now < teamUnlock4 && teamFreezed [ from ] > 0 ) { uint p = 0 ; if ( now < teamUnlock1 ) { p = 100 ; } else if ( now < teamUnlock2 ) { p = 75 ; } else if ( now < teamUnlock3 ) { p = 50 ; } else if ( now < teamUnlock4 ) { p = 25 ; } total = total . add ( teamFreezed [ from ] . mul ( p ) . div ( 100 ) ) ; require ( newBalance >= total ) ; } }
function shutDownVersion ( uint id ) pre_cond ( isActive ( id ) ) internal { VersionInterface Version = VersionInterface ( versions [ id ] . version ) ; Version . shutDown ( ) ; delete versions [ id ] ; VersionUpdated ( id ) ; }
function withdraw ( address _darknode , ERC20 _token ) public { address darknodeOwner = darknodeRegistry . getDarknodeOwner ( address ( _darknode ) ) ; require ( darknodeOwner != 0x0 , "invalid darknode owner" ) ; uint256 value = darknodeBalances [ _darknode ] [ _token ] ; darknodeBalances [ _darknode ] [ _token ] = 0 ; if ( address ( _token ) == ETHEREUM ) { darknodeOwner . transfer ( value ) ; } else { CompatibleERC20 ( _token ) . safeTransfer ( darknodeOwner , value ) ; } }
function updateSettings ( uint _ethAmount , uint _sntAmount , bytes32 _root ) public onlyController { ethAmount = _ethAmount ; sntAmount = _sntAmount ; root = _root ; }
function addAssetManager ( address _assetManager ) public onlyOwner { require ( address ( assetManager ) == 0x0 ) ; assetManager = IAssetManager ( _assetManager ) ; }
function transferFrom ( address from , address to , uint256 tokens ) public returns ( bool success ) { requireTrade ( from ) ; balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; ensureInAccountList ( from ) ; ensureInAccountList ( to ) ; return true ; }
function _transferFromSenderPaysFee_byProxy ( address sender , address from , address to , uint value ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; uint total = safeAdd ( value , fee ) ; tokenState . setAllowance ( from , sender , safeSub ( tokenState . allowance ( from , sender ) , total ) ) ; return _internalTransfer ( from , to , value , fee ) ; }
function getQueryPrice ( uint EthInCents , uint gasPriceInWei ) public view returns ( uint ) { uint256 oneEth = 1 ether ; uint256 oracalizeFee = oneEth . div ( EthInCents ) . div ( 98 ) ; uint256 gasCost = callbackGasLimit . mul ( gasPriceInWei ) ; return oracalizeFee + gasCost ; }
function disablePrivileged ( ) external privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { require ( false == m_frozen ) ; m_allowPrivileged = false ; }
function highestBid ( ) public view returns ( uint ) { return ( bids [ highestBidder ] ) ; }
function sellTokens ( uint _tokenAmount , uint _from , uint _to ) returns ( uint ) { if ( ! transferable || uint ( balances [ msg . sender ] ) < _amount || numberOfOrders == 0 ) throw ; if ( _to == 0 || _to > numberOfOrders - 1 ) _to = numberOfOrders - 1 ; uint _tokenAmounto ; uint _amount ; uint _totalAmount ; uint o = _from ; for ( uint i = _from ; i <= _to ; i ++ ) { if ( _tokenAmount > 0 && orders [ o ] . buyer != msg . sender ) { _tokenAmounto = TokenAmount ( orders [ o ] . weiGiven , priceMultiplier ( 0 ) , actualPriceDivisor ( 0 ) ) ; if ( _tokenAmount >= _tokenAmounto && transferFromTo ( msg . sender , orders [ o ] . buyer , _tokenAmounto ) ) { _tokenAmount -= _tokenAmounto ; _totalAmount += orders [ o ] . weiGiven ; removeOrder ( o ) ; } else if ( _tokenAmount < _tokenAmounto && transferFromTo ( msg . sender , orders [ o ] . buyer , _tokenAmount ) ) { _amount = weiAmount ( _tokenAmount , priceMultiplier ( 0 ) , actualPriceDivisor ( 0 ) ) ; orders [ o ] . weiGiven -= _amount ; _totalAmount += _amount ; i = _to + 1 ; } else o += 1 ; } else o += 1 ; } if ( ! msg . sender . send ( _totalAmount ) ) throw ; else return _totalAmount ; }
function burn ( uint256 _value ) public returns ( bool success ) { require ( _value > 0 ) ; require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; totalSupply = safeSub ( totalSupply , _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }
function getFxUSDBPSRate ( Data storage self , string currency ) internal view returns ( uint bpsRate ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fx.usd.rate' , currency ) ) ; return self . Storage . getUint ( id ) ; }
function transferAdminship ( address _newAdmin ) onlyAdmin public { admin = _newAdmin ; emit TransferAdminship ( admin ) ; }
function getPendingManager ( ) public view returns ( address ) ;
function addWhitelistAddress ( address investor ) public onlyOwner mustBeAtStage ( Stage . Finished ) { require ( investor != address ( 0 ) && investor != address ( this ) ) ; require ( isWhitelisted [ investor ] == false ) ; require ( balancesToken [ investor ] > 0 ) ; isWhitelisted [ investor ] = true ; }
function changeAllowAllTransfers ( bool _allowAllTransfers ) public withPerm ( FLAGS ) { allowAllTransfers = _allowAllTransfers ; emit AllowAllTransfers ( _allowAllTransfers ) ; }
function setEthealToken ( address _token , address _hodler ) public onlyOwner whenPaused { require ( _token != address ( 0 ) ) ; ethealToken = ERC20MiniMe ( _token ) ; if ( _hodler != address ( 0 ) ) { hodlerReward = Hodler ( _hodler ) ; } else if ( hodlerReward == address ( 0 ) ) { hodlerReward = new Hodler ( TOKEN_HODL_3M , TOKEN_HODL_6M , TOKEN_HODL_9M ) ; } if ( ethealToken . totalSupply ( ) == 0 ) { ethealToken . generateTokens ( SALE , TOKEN_SALE1_PRE . add ( TOKEN_SALE1_NORMAL ) . add ( TOKEN_SALE2 ) . add ( TOKEN_SALE3 ) ) ; ethealToken . generateTokens ( address ( hodlerReward ) , TOKEN_HODL_3M . add ( TOKEN_HODL_6M ) . add ( TOKEN_HODL_9M ) ) ; ethealToken . generateTokens ( owner , TOKEN_BOUNTY . add ( TOKEN_REFERRAL ) ) ; ethealToken . generateTokens ( address ( ethealMultisigWallet ) , TOKEN_COMMUNITY ) ; ethealToken . generateTokens ( address ( this ) , TOKEN_FOUNDERS . add ( TOKEN_TEAM ) ) ; ethealToken . generateTokens ( INVESTOR1 , TOKEN_INVESTORS . div ( 3 ) . mul ( 2 ) ) ; ethealToken . generateTokens ( INVESTOR2 , TOKEN_INVESTORS . div ( 3 ) ) ; } }
function withdrawPoly ( uint256 _amount ) public onlyOwner { require ( ERC20 ( polyToken ) . transfer ( owner , _amount ) , "In-sufficient balance" ) ; }
function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { require ( state == State . Successful ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
function isRegisteredInPreviousEpoch ( address _darknodeID ) public view returns ( bool ) { return isRegisteredInEpoch ( _darknodeID , previousEpoch ) ; }
function changeRecipient ( address _newRecipient ) onlyRecipient { recipient = _newRecipient ; }
function withdraw ( address asset , uint requestedAmount ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . WITHDRAW_CONTRACT_PAUSED ) ; } Market storage market = markets [ asset ] ; Balance storage supplyBalance = supplyBalances [ msg . sender ] [ asset ] ; WithdrawLocalVars memory localResults ; Error err ; uint rateCalculationResultCode ; ( err , localResults . accountLiquidity , localResults . accountShortfall ) = calculateAccountLiquidity ( msg . sender ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED ) ; } ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED ) ; } ( err , localResults . userSupplyCurrent ) = calculateBalance ( supplyBalance . principal , supplyBalance . interestIndex , localResults . newSupplyIndex ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED ) ; } if ( requestedAmount == uint ( - 1 ) ) { ( err , localResults . withdrawCapacity ) = getAssetAmountForValue ( asset , localResults . accountLiquidity ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_CAPACITY_CALCULATION_FAILED ) ; } localResults . withdrawAmount = min ( localResults . withdrawCapacity , localResults . userSupplyCurrent ) ; } else { localResults . withdrawAmount = requestedAmount ; } localResults . currentCash = getCash ( asset ) ; ( err , localResults . updatedCash ) = sub ( localResults . currentCash , localResults . withdrawAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( Error . TOKEN_INSUFFICIENT_CASH , FailureInfo . WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE ) ; } ( err , localResults . userSupplyUpdated ) = sub ( localResults . userSupplyCurrent , localResults . withdrawAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( Error . INSUFFICIENT_BALANCE , FailureInfo . WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED ) ; } if ( ! isZeroExp ( localResults . accountShortfall ) ) { return fail ( Error . INSUFFICIENT_LIQUIDITY , FailureInfo . WITHDRAW_ACCOUNT_SHORTFALL_PRESENT ) ; } ( err , localResults . ethValueOfWithdrawal ) = getPriceForAssetAmount ( asset , localResults . withdrawAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED ) ; } if ( lessThanExp ( localResults . accountLiquidity , localResults . ethValueOfWithdrawal ) ) { return fail ( Error . INSUFFICIENT_LIQUIDITY , FailureInfo . WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL ) ; } ( err , localResults . newTotalSupply ) = addThenSub ( market . totalSupply , localResults . userSupplyUpdated , supplyBalance . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa ) = market . interestRateModel . getSupplyRate ( asset , localResults . updatedCash , market . totalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa ) = market . interestRateModel . getBorrowRate ( asset , localResults . updatedCash , market . totalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } err = doTransferOut ( asset , msg . sender , localResults . withdrawAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_TRANSFER_OUT_FAILED ) ; } market . blockNumber = getBlockNumber ( ) ; market . totalSupply = localResults . newTotalSupply ; market . supplyRateMantissa = localResults . newSupplyRateMantissa ; market . supplyIndex = localResults . newSupplyIndex ; market . borrowRateMantissa = localResults . newBorrowRateMantissa ; market . borrowIndex = localResults . newBorrowIndex ; localResults . startingBalance = supplyBalance . principal ; supplyBalance . principal = localResults . userSupplyUpdated ; supplyBalance . interestIndex = localResults . newSupplyIndex ; emit SupplyWithdrawn ( msg . sender , asset , localResults . withdrawAmount , localResults . startingBalance , localResults . userSupplyUpdated ) ; return uint ( Error . NO_ERROR ) ; }
