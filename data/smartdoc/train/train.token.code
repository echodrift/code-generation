function sendEther ( address to , uint value ) external onlymanyowners ( keccak256 ( msg . data ) ) { require ( address ( 0 ) != to ) ; require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }
function isReadyToMate ( uint256 _ponyId ) public view returns ( bool ) { require ( _ponyId > 0 ) ; Pony storage pon = ponies [ _ponyId ] ; return _isReadyToMate ( pon ) ; }
function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }
function isValidator ( ) external view returns ( bool ) { uint256 totalValidators = _jurisdiction . countValidators ( ) ; for ( uint256 i = 0 ; i < totalValidators ; i ++ ) { address validator = _jurisdiction . getValidator ( i ) ; if ( validator == address ( this ) ) { return true ; } } return false ; }
function issueAttribute ( address account , uint256 attributeTypeID , uint256 value ) external payable whenNotPaused { require ( msg . value == 0 , "Basic jurisdictions do not support payments when assigning attributes" ) ; require ( canValidate ( msg . sender , attributeTypeID ) , "only approved validators may assign attributes of this type" ) ; require ( _issuedAttributes [ account ] [ attributeTypeID ] . validator == address ( 0 ) , "duplicate attributes are not supported, remove existing attribute first" ) ; _issuedAttributes [ account ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , validator : msg . sender , value : value } ) ; emit AttributeAdded ( msg . sender , account , attributeTypeID , value ) ; }
function closeDataResponse ( address seller , bool transactionCompleted ) public onlyOwner validAddress ( seller ) returns ( bool ) { require ( orderStatus != OrderStatus . TransactionCompleted ) ; require ( transactionCompletedAt == 0 ) ; require ( hasSellerBeenAccepted ( seller ) ) ; require ( sellerInfo [ seller ] . status == DataResponseStatus . DataResponseAdded ) ; sellerInfo [ seller ] . status = transactionCompleted ? DataResponseStatus . TransactionCompleted : DataResponseStatus . RefundedToBuyer ; sellerInfo [ seller ] . closedAt = uint32 ( block . timestamp ) ; return true ; }
function deposit ( uint256 amount ) returns ( bool ) { bool success ; uint256 balance ; ( success , balance ) = data . deposit ( amount ) ; if ( success == true ) { ChannelNewBalance ( data . token , msg . sender , balance , block . number ) ; } return success ; }
function lockAndDistributeTokens ( address _tokenHolder , uint256 _amount , uint256 _percentageToLock , uint256 _unlockTime ) public onlyOwner { requireMultiple ( _amount ) ; require ( _percentageToLock <= 100 && _percentageToLock > 0 , "You can only lock a percentage between 0 and 100." ) ; require ( mLockedBalances [ _tokenHolder ] . amount == 0 , "You can only lock one amount of tokens for a given address. It is currently indicating that there are already locked tokens for this address." ) ; uint256 amountToLock = _amount . mul ( _percentageToLock ) . div ( 100 ) ; mBalances [ msg . sender ] = mBalances [ msg . sender ] . sub ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; mLockedBalances [ _tokenHolder ] = lockedTokens ( { amount : amountToLock , timeLockedUntil : _unlockTime } ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , "" , "" , true ) ; emit LockedTokens ( _tokenHolder , amountToLock , _unlockTime ) ; if ( mErc20compatible ) { emit Transfer ( 0x0 , _tokenHolder , _amount ) ; } }
function trade ( TradeInput tradeInput ) internal returns ( uint ) { require ( isEnabled ) ; require ( tx . gasprice <= maxGasPriceValue ) ; require ( validateTradeInput ( tradeInput . src , tradeInput . srcAmount , tradeInput . dest , tradeInput . destAddress ) ) ; BestRateResult memory rateResult = findBestRateTokenToToken ( tradeInput . src , tradeInput . dest , tradeInput . srcAmount ) ; require ( rateResult . rate > 0 ) ; require ( rateResult . rate < MAX_RATE ) ; require ( rateResult . rate >= tradeInput . minConversionRate ) ; uint actualDestAmount ; uint weiAmount ; uint actualSrcAmount ; ( actualSrcAmount , weiAmount , actualDestAmount ) = calcActualAmounts ( tradeInput . src , tradeInput . dest , tradeInput . srcAmount , tradeInput . maxDestAmount , rateResult ) ; if ( actualSrcAmount < tradeInput . srcAmount ) { if ( tradeInput . src == ETH_TOKEN_ADDRESS ) { tradeInput . trader . transfer ( tradeInput . srcAmount - actualSrcAmount ) ; } else { tradeInput . src . transfer ( tradeInput . trader , ( tradeInput . srcAmount - actualSrcAmount ) ) ; } } require ( weiAmount <= getUserCapInWei ( tradeInput . trader ) ) ; require ( doReserveTrade ( tradeInput . src , actualSrcAmount , ETH_TOKEN_ADDRESS , this , weiAmount , KyberReserveInterface ( rateResult . reserve1 ) , rateResult . rateSrcToEth , true ) ) ; require ( doReserveTrade ( ETH_TOKEN_ADDRESS , weiAmount , tradeInput . dest , tradeInput . destAddress , actualDestAmount , KyberReserveInterface ( rateResult . reserve2 ) , rateResult . rateEthToDest , true ) ) ; if ( tradeInput . src != ETH_TOKEN_ADDRESS ) require ( feeBurnerContract . handleFees ( weiAmount , rateResult . reserve1 , tradeInput . walletId ) ) ; if ( tradeInput . dest != ETH_TOKEN_ADDRESS ) require ( feeBurnerContract . handleFees ( weiAmount , rateResult . reserve2 , tradeInput . walletId ) ) ; KyberTrade ( tradeInput . trader , tradeInput . src , actualSrcAmount , tradeInput . destAddress , tradeInput . dest , actualDestAmount ) ; return actualDestAmount ; }
function revoke ( ERC20 token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }
function transferFromPreSigned ( bytes _signature , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = transferFromPreSignedHashing ( address ( this ) , _from , _to , _value , _fee , _nonce ) ; address spender = recover ( hashedTx , _signature ) ; require ( spender != address ( 0 ) ) ; checkValue ( spender , _fee ) ; checkValue ( _from , _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ spender ] = allowed [ _from ] [ spender ] . sub ( _value ) ; balances [ spender ] = balances [ spender ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( _from , _to , _value ) ; emit Transfer ( spender , msg . sender , _fee ) ; return true ; }
function totalSupply ( ) public view returns ( uint256 ) { return totalSupply ; }
function approve ( address _to , uint256 _tokenId ) external payable { require ( msg . value == 0 ) ; address owner = _ownerOf ( _tokenId ) ; require ( _to != owner ) ; require ( msg . sender == owner || _isApprovedForAll ( owner , msg . sender ) ) ; _tokenApprovals [ _tokenId ] = _to ; emit Approval ( owner , _to , _tokenId ) ; }
function register ( string _identifier , uint _version , Template _template ) public { require ( opened || msg . sender == owner ) ; require ( _template . supportsInterface ( 0x01ffc9a7 ) ) ; require ( _template . supportsInterface ( 0xd48445ff ) ) ; address registrant = registrantOfIdentifier [ _identifier ] ; require ( registrant == address ( 0 ) || registrant == msg . sender , "identifier already registered by another registrant" ) ; if ( registrant == address ( 0 ) ) { identifiers . push ( _identifier ) ; registrantOfIdentifier [ _identifier ] = msg . sender ; } uint [ ] storage versions = versionsOfIdentifier [ _identifier ] ; if ( versions . length > 0 ) { require ( _version > versions [ versions . length - 1 ] , "new version must be greater than old versions" ) ; } versions . push ( _version ) ; templateOfVersionOfIdentifier [ _identifier ] [ _version ] = _template ; }
function isDeregistered ( address _darknodeID ) public view returns ( bool ) { uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return deregisteredAt != 0 && deregisteredAt <= currentEpoch . blocknumber ; }
function disqualifyHopeful ( uint withId ) pre_cond ( isOracle ( ) ) { hopefuls [ withId ] . isDisqualified = true ; }
function _isOnSale ( Sale memory _sale ) internal pure returns ( bool ) { return ( _sale . startedAt > 0 ) ; }
function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x0d2d1bf5 ) , _token , _to , _value , _fee , _nonce , _validUntil ) ; }
function totalSupply ( ) public view returns ( uint256 _totalSupply ) { return totalSupply ; }
function ICOSplit ( ) external isAdmin oneTime { uint i ; if ( ! isFrozen ) { require ( ( relativeDateSave - now ) >= ( relativeDateSave - 150 days ) ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 50000000000000 ) ; currentProfits = ( ( balances [ selfAddress ] - 50000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 300000000000000 , balances [ selfAddress ] ) ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { if ( msg . gas < 240000 ) { currentIteration = i ; break ; } actualProfitSplit += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; balances [ users [ i ] ] += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; if ( i == users . length - 1 ) { assetThaw ( ) ; balances [ selfAddress ] = balances [ selfAddress ] - actualProfitSplit ; hasICORun = true ; } Transfer ( selfAddress , users [ i ] , ( balances [ users [ i ] ] / amountInCirculation ) * currentProfits ) ; } } }
function _mintFish ( address _owner , uint32 _weight , uint8 _power , uint8 _agility , uint8 _speed , bytes16 _color ) internal { fishes . length += 1 ; uint256 newFishId = fishes . length - 1 ; Fish storage newFish = fishes [ newFishId ] ; newFish . owner = _owner ; newFish . weight = _weight ; newFish . power = _power ; newFish . agility = _agility ; newFish . speed = _speed ; newFish . color = _color ; balances [ _owner ] ++ ; Transfer ( address ( 0 ) , _owner , newFishId ) ; }
function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function updateGiver ( uint64 idGiver , address newAddr , string newName , string newUrl , uint64 newCommitTime ) { PledgeAdmin storage giver = findAdmin ( idGiver ) ; require ( giver . adminType == PledgeAdminType . Giver ) ; require ( giver . addr == msg . sender ) ; giver . addr = newAddr ; giver . name = newName ; giver . url = newUrl ; giver . commitTime = newCommitTime ; GiverUpdated ( idGiver ) ; }
function getOrderPriceInfo ( address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( uint orderPrice ) { return mul ( buyQuantity , 10 ** uint ( getDecimals ( sellAsset ) ) ) / sellQuantity ; }
function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens -= voterTokens ; challenges [ _challengeID ] . rewardPool -= reward ; require ( token . transfer ( msg . sender , reward ) ) ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; }
function claimProfitEquivalent ( ) public { uint256 toPay ; for ( uint k = 0 ; k <= yearsPast . length - 1 ; k ++ ) { toPay += snapShot [ yearsPast [ k ] ] [ msg . sender ] ; snapShot [ yearsPast [ k ] ] [ msg . sender ] = 0 ; } msg . sender . transfer ( toPay ) ; peLastPeriod -= toPay ; }
function removeFromWhitelist ( address [ ] _bidder_addresses ) public isWhitelister { for ( uint32 i = 0 ; i < _bidder_addresses . length ; i ++ ) { whitelist [ _bidder_addresses [ i ] ] = false ; } }
function getTime ( ) internal view returns ( uint256 ) { return now ; }
function QToken ( address target , uint256 qAmount ) onlyOwner public { balanceOf [ target ] += qAmount ; totalSupply += qAmount ; emit Transfer ( 0 , this , qAmount ) ; emit Transfer ( this , target , qAmount ) ; }
function getMembersArrayLength ( ) public view returns ( uint256 ) { return membersArray . length ; }
function unlockMiner ( ) public locked onlyOwner { require ( block . timestamp >= minerRelaseTime ) ; require ( minerLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= minerLockedAmount ) ; token . transfer ( minerLockAddress , minerLockedAmount ) ; minerLockedAmount = 0 ; }
function setCurrentPrice ( uint256 newPrice ) public onlyOwner { currentPrice = newPrice ; }
function finalize ( bool _forceRefund ) onlyOwner public returns ( bool ) { if ( isFinalized ) { error ( 'finalize: ICO is already finalized.' ) ; return false ; } if ( weisRaised >= weisSoftCap && ! _forceRefund ) { if ( ! SCRefundVault . close ( ) ) { error ( 'finalize: SCRefundVault.close() failed' ) ; return false ; } } else { if ( ! SCRefundVault . enableRefunds ( ) ) { error ( 'finalize: SCRefundVault.enableRefunds() failed' ) ; return false ; } if ( _forceRefund ) { emit ForceRefund ( ) ; } } uint256 balanceAmount = SCTokens . balanceOf ( this ) ; if ( ! SCTokens . transfer ( address ( SCEscrow ) , balanceAmount ) ) { error ( 'finalize: unable to return remaining ICO tokens' ) ; return false ; } if ( ! SCEscrow . deposit ( balanceAmount ) ) { error ( 'finalize: unable to return remaining ICO tokens' ) ; return false ; } isFinalized = true ; emit Finalized ( ) ; return true ; }
function registerDeed ( string propertyAddress , string document ) public { require ( __isSenderInRole ( ROLE_DEED_REGISTRANT ) ) ; uint256 documentHash = uint256 ( keccak256 ( document ) ) ; require ( documentRegistry [ documentHash ] == 0 ) ; require ( document . contains ( propertyAddress ) ) ; documentRegistry [ documentHash ] = now ; uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; if ( addressRegistry [ propertyAddressHash ] . length == 0 ) { knownPropertyAddresses . push ( propertyAddress ) ; } addressRegistry [ propertyAddressHash ] . push ( document ) ; emit DeedRegistered ( propertyAddress , document ) ; }
function calculateCurrentBlock ( uint256 _stakeNumber ) internal view returns ( uint256 currentBlock ) { currentBlock = block . number ; if ( currentBlock >= stakes [ msg . sender ] [ _stakeNumber ] . blockUnlocked ) { currentBlock = stakes [ msg . sender ] [ _stakeNumber ] . blockUnlocked ; } }
function SetContractorManager ( address _contractorManager ) ;
function isSigned ( address _address , bytes32 messageHash , uint8 v , bytes32 r , bytes32 s ) public pure returns ( bool ) { return _isSigned ( _address , messageHash , v , r , s ) || _isSignedPrefixed ( _address , messageHash , v , r , s ) ; }
function commitVote ( uint _pollID , bytes32 _secretHash , uint _numTokens , uint _prevPollID ) external { require ( commitPeriodActive ( _pollID ) ) ; require ( voteTokenBalance [ msg . sender ] >= _numTokens ) ; require ( _pollID != 0 ) ; require ( _prevPollID == 0 || dllMap [ msg . sender ] . contains ( _prevPollID ) ) ; uint nextPollID = dllMap [ msg . sender ] . getNext ( _prevPollID ) ; nextPollID = ( nextPollID == _pollID ) ? dllMap [ msg . sender ] . getNext ( _pollID ) : nextPollID ; require ( validPosition ( _prevPollID , nextPollID , msg . sender , _numTokens ) ) ; dllMap [ msg . sender ] . insert ( _prevPollID , _pollID , nextPollID ) ; bytes32 UUID = attrUUID ( msg . sender , _pollID ) ; store . setAttribute ( UUID , "numTokens" , _numTokens ) ; store . setAttribute ( UUID , "commitHash" , uint ( _secretHash ) ) ; pollMap [ _pollID ] . didCommit [ msg . sender ] = true ; _VoteCommitted ( _pollID , _numTokens , msg . sender ) ; }
function createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) public payable withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _checkpointId , _excluded , _name ) ; }
function totalSupply ( ) public view returns ( uint ) { return rabbits . length - 1 ; }
function staticChecks ( Trade [ ] trades , TradeFlag [ ] tradeFlags ) public view whenNotPaused { bool previousBuyOccured = false ; for ( uint256 i ; i < trades . length ; i ++ ) { Trade memory thisTrade = trades [ i ] ; if ( thisTrade . isSell ) { if ( previousBuyOccured ) { errorReporter . revertTx ( "A buy has occured before this sell" ) ; } if ( ! Utils . tokenAllowanceAndBalanceSet ( msg . sender , thisTrade . tokenAddress , thisTrade . tokenAmount , tokenTransferProxy ) ) { if ( ! thisTrade . optionalTrade ) { errorReporter . revertTx ( "Taker has not sent allowance/balance on a non-optional trade" ) ; } tradeFlags [ i ] . ignoreTrade = true ; continue ; } } else { previousBuyOccured = true ; } for ( uint256 j ; j < thisTrade . orders . length ; j ++ ) { Order memory thisOrder = thisTrade . orders [ j ] ; if ( ! handlerWhitelistMap [ thisOrder . exchangeHandler ] ) { tradeFlags [ i ] . ignoreOrder [ j ] = true ; continue ; } } } }
function channelsSold ( ) constant returns ( uint256 ) { return soldOut . channels ; }
function onTransfer ( address _from , address _to , uint _amount ) public initialized returns ( bool ) { return false ; }
function transferToAddress ( address to , uint256 value , bytes data ) public whenNotPaused afterCrowdsale returns ( bool _success ) { return super . transferToAddress ( to , value , data ) ; }
function setOracleURL ( string _oracleURL ) onlyOwner public { oracleURL = _oracleURL ; }
function updateAsset ( address ofAsset , bytes32 inputName , bytes8 inputSymbol , uint inputDecimals , string inputUrl , string inputIpfsHash , address [ 2 ] ofBreakInBreakOut , uint [ ] inputStandards , bytes4 [ ] inputFunctionSignatures ) auth pre_cond ( assetInformation [ ofAsset ] . exists ) { Asset asset = assetInformation [ ofAsset ] ; asset . name = inputName ; asset . symbol = inputSymbol ; asset . decimals = inputDecimals ; asset . url = inputUrl ; asset . ipfsHash = inputIpfsHash ; asset . breakIn = ofBreakInBreakOut [ 0 ] ; asset . breakOut = ofBreakInBreakOut [ 1 ] ; asset . standards = inputStandards ; asset . functionSignatures = inputFunctionSignatures ; }
function removeAttribute ( uint256 attributeTypeID ) external { require ( ! _attributeTypes [ attributeTypeID ] . restricted , "only jurisdiction or issuing validator may remove a restricted attribute" ) ; require ( _issuedAttributes [ msg . sender ] [ attributeTypeID ] . exists , "only existing attributes may be removed" ) ; address validator = _issuedAttributes [ msg . sender ] [ attributeTypeID ] . validator ; uint256 stake = _issuedAttributes [ msg . sender ] [ attributeTypeID ] . stake ; address refundAddress ; if ( _issuedAttributes [ msg . sender ] [ attributeTypeID ] . setPersonally ) { refundAddress = msg . sender ; } else { address operator = _issuedAttributes [ msg . sender ] [ attributeTypeID ] . operator ; if ( operator == address ( 0 ) ) { refundAddress = validator ; } else { refundAddress = operator ; } } delete _issuedAttributes [ msg . sender ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , msg . sender , attributeTypeID ) ; if ( stake > 0 && address ( this ) . balance >= stake ) { if ( refundAddress . send ( stake ) ) { emit StakeRefunded ( refundAddress , attributeTypeID , stake ) ; } } }
function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; require ( this . balance >= revenue ) ; uint commission = msg . value / sellCommission ; require ( address ( this ) . send ( commission ) ) ; msg . sender . transfer ( revenue ) ; }
function getCanvasesWithSellOffer ( bool includePrivateOffers ) external view returns ( uint32 [ ] ) { uint32 [ ] memory result = new uint32 [ ] ( canvases . length ) ; uint currentIndex = 0 ; for ( uint32 i = 0 ; i < canvases . length ; i ++ ) { SellOffer storage offer = canvasForSale [ i ] ; if ( offer . isForSale && ( includePrivateOffers || offer . onlySellTo == 0x0 ) ) { result [ currentIndex ] = i ; currentIndex ++ ; } } return _slice ( result , 0 , currentIndex ) ; }
function removeEmissionProvider ( address _provider , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _provider ) , _block ) ; if ( OK != _code ) { return _code ; } delete emissionProviders [ _provider ] ; return OK ; }
function getSecurityTokenLaunchFee ( ) external view returns ( uint256 ) ;
function claimTokens ( token _address ) public { require ( state == State . Successful ) ; require ( msg . sender == creator ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( creator , remainder ) ; }
function getCurrencySymbol ( ) external view returns ( bytes32 ) { return currencySymbol ; }
function changeOwner ( address _newOwner ) onlyOwner public { owner = _newOwner ; }
function getGameResult ( uint gameId ) public view returns ( GameResults ) { return games [ gameId ] . result ; }
function buyFood ( uint32 _bundles ) external payable whenNotPaused returns ( bool ) { require ( newContractAddress == address ( 0 ) ) ; uint cost = _bundles * price ; require ( msg . value >= cost ) ; uint fundsExcess = msg . value - cost ; if ( fundsExcess > 1 finney ) { msg . sender . transfer ( fundsExcess ) ; } emit Bought ( msg . sender , _bundles ) ; return true ; }
function batchReclaimExpiredSwaps ( bytes32 msigId , bytes32 [ ] swapIds ) public { for ( uint i = 0 ; i < swapIds . length ; ++ i ) reclaimExpiredSwaps ( msigId , swapIds [ i ] ) ; }
function close ( uint64 nonce , uint256 transferred_amount , bytes32 locksroot , bytes32 extra_hash , bytes signature ) { data . close ( nonce , transferred_amount , locksroot , extra_hash , signature ) ; ChannelClosed ( msg . sender , data . closed ) ; }
function rename ( uint256 _tokenId , bytes8 _name ) public validId ( _tokenId ) returns ( uint64 ) { require ( isCreatorAndOwner ( msg . sender , _tokenId ) , "Sender is not the creator and owner" ) ; TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; pixelconNames [ lookupData . tokenIndex ] = _name ; emit Rename ( _tokenId , _name ) ; return lookupData . tokenIndex ; }
function getTypes ( ) external view returns ( uint8 [ ] ) { uint8 [ ] memory res = new uint8 [ ] ( 1 ) ; res [ 0 ] = 3 ; return res ; }
function setupEventsHistory ( address _eventsHistory ) external auth returns ( uint ) { require ( _eventsHistory != 0x0 ) ; _setEventsHistory ( _eventsHistory ) ; return OK ; }
function contribute ( address _ref ) public notFinished payable { address referral = _ref ; uint256 referralBase = 0 ; uint256 referralTokens = 0 ; uint256 tokenBought = 0 ; if ( refLed [ msg . sender ] == 0 ) { refLed [ msg . sender ] = referral ; } else { referral = refLed [ msg . sender ] ; } totalRaised = totalRaised . add ( msg . value ) ; if ( state == State . stage1 ) { tokenBought = msg . value . mul ( rates [ 0 ] ) ; } else if ( state == State . stage2 ) { tokenBought = msg . value . mul ( rates [ 1 ] ) ; } else if ( state == State . stage3 ) { tokenBought = msg . value . mul ( rates [ 2 ] ) ; } else if ( state == State . stage4 ) { tokenBought = msg . value . mul ( rates [ 3 ] ) ; } else if ( state == State . stage5 ) { tokenBought = msg . value . mul ( rates [ 4 ] ) ; } referralBase = tokenBought ; if ( msg . value >= 5 ether ) { tokenBought = tokenBought . mul ( 102 ) ; tokenBought = tokenBought . div ( 100 ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; stageDistributed = stageDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; emit LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; emit LogContributorsPayout ( msg . sender , tokenBought ) ; if ( referral != address ( 0 ) && referral != msg . sender ) { referralTokens = referralBase . div ( 20 ) ; totalDistributed = totalDistributed . add ( referralTokens ) ; stageDistributed = stageDistributed . add ( referralTokens ) ; tokenReward . transfer ( referral , referralTokens ) ; emit LogContributorsPayout ( referral , referralTokens ) ; } checkIfFundingCompleteOrExpired ( ) ; }
function issueNomins ( uint amount ) public optionalProxy requireIssuer ( messageSender ) { address sender = messageSender ; require ( amount <= remainingIssuableNomins ( sender ) ) ; uint lastTot = nomin . totalSupply ( ) ; uint preIssued = nominsIssued [ sender ] ; nomin . issue ( sender , amount ) ; nominsIssued [ sender ] = safeAdd ( preIssued , amount ) ; updateIssuanceData ( sender , preIssued , lastTot ) ; }
function changeBeneficiary ( address _beneficiary ) public onlyOwner { beneficiary = _beneficiary ; }
function transfer ( address to , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ sender ] == 0 || value <= transferableHavvens ( sender ) , "Value to transfer exceeds available havvens" ) ; _transfer_byProxy ( sender , to , value ) ; return true ; }
function _forwardFunds ( ) internal { }
function setAllowedTransferTo ( address to , bool allowed ) public only ( ROLE_EURT_LEGAL_MANAGER ) { setAllowedTransferToPrivate ( to , allowed ) ; }
function yearlyOwnerTokenWithdrawal ( ) public onlyOwner { require ( crowdsaleClosed == true ) ; require ( ( ( now > stopTime + 1 years ) && ( yearlyTeamTokensPaid [ 0 ] == false ) ) || ( ( now > stopTime + 2 years ) && ( yearlyTeamTokensPaid [ 1 ] == false ) ) || ( ( now > stopTime + 3 years ) && ( yearlyTeamTokensPaid [ 2 ] == false ) ) ) ; tokenReward . transfer ( beneficiary , yearlyTeamAmount ) ; if ( yearlyTeamTokensPaid [ 0 ] == false ) yearlyTeamTokensPaid [ 0 ] = true ; else if ( yearlyTeamTokensPaid [ 1 ] == false ) yearlyTeamTokensPaid [ 1 ] = true ; else if ( yearlyTeamTokensPaid [ 2 ] == false ) yearlyTeamTokensPaid [ 2 ] = true ; }
function motionVoting ( uint motionID ) public view returns ( bool ) { return motionStartTime [ motionID ] < now && now < motionStartTime [ motionID ] + votingPeriod ; }
function allocateTokens ( address _receiver , bytes16 _customerUuid , uint256 _weiAmount ) whenNotPaused canAllocateTokens public { allocateInternal ( _receiver , _customerUuid , _weiAmount ) ; }
function tokenURI ( uint256 _tokenId ) external view returns ( string ret ) { string memory tokenIdAsString = uintToString ( uint ( _tokenId ) ) ; ret = string ( abi . encodePacked ( _tokenURI , tokenIdAsString , "/" ) ) ; }
function purchase ( uint256 _nftId ) external payable mustBeValidToken ( _nftId ) mustBeOwnedByThisContract ( _nftId ) { require ( msg . value == SALE_PRICE ) ; _transfer ( _nftId , msg . sender ) ; }
function send ( address _to , uint256 _amount , bytes _data ) public { doSend ( msg . sender , msg . sender , _to , _amount , _data , "" , true ) ; }
function purchase ( ) public payable { __purchase_impl ( msg . sender , msg . value ) ; }
function batchTransferFrom ( uint256 [ ] _tokenIds , address _from , address _to ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _from != address ( 0 ) && _to != address ( 0 ) ) ; uint256 _id ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 ) ; _id = _tokenIds [ i ] ; transferFrom ( _from , _to , _id ) ; } }
function transfer ( address to , uint value , bytes data ) public optionalProxy returns ( bool ) { require ( value <= transferableSynthetix ( messageSender ) , "Insufficient balance" ) ; _transfer_byProxy ( messageSender , to , value , data ) ; return true ; }
function transfer ( address _to , uint256 _identifier ) external whenNotPaused { require ( _owns ( msg . sender , _identifier ) ) ; _transfer ( msg . sender , _to , _identifier ) ; }
function totalSupplyOf ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . supply ; }
function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; memeIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
function balanceOf ( address _owner ) constant returns ( uint256 balance ) ;
function pickUniquePacks ( uint [ ] assetIds ) public view returns ( uint [ ] ) { require ( assetIds . length > 0 ) ; uint [ ] memory packs = new uint [ ] ( assetIds . length ) ; uint packsCount = 0 ; for ( uint i = 0 ; i < assetIds . length ; i ++ ) { Asset memory asset = assets [ assetIds [ i ] ] ; bool exists = false ; for ( uint j = 0 ; j < packsCount ; j ++ ) { if ( asset . packId == packs [ j ] ) { exists = true ; } } if ( ! exists ) { packs [ packsCount ] = asset . packId ; packsCount ++ ; } } uint [ ] memory finalPacks = new uint [ ] ( packsCount ) ; for ( i = 0 ; i < packsCount ; i ++ ) { finalPacks [ i ] = packs [ i ] ; } return finalPacks ; }
function destroy ( address [ ] tokens ) onlyOwner public { require ( now > unlockTime || ( contributorCount ( ) == 0 && paused ) ) ; super . destroy ( tokens ) ; }
function init ( ChronoBankPlatform _chronoBankPlatform , string _symbol , string _name ) public returns ( bool ) { if ( address ( chronoBankPlatform ) != 0x0 ) { return false ; } chronoBankPlatform = _chronoBankPlatform ; symbol = _symbol ; smbl = stringToBytes32 ( _symbol ) ; name = _name ; return true ; }
function finalize ( ) public onlyController { assert ( token . totalSupply ( ) >= distributionCap ( ) ) ; doMint ( reserveWallet , totalReserve ) ; finalizedBlock = getBlockNumber ( ) ; token . finalize ( ) ; token . changeController ( controller ) ; Finalized ( ) ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { testmonedarecipiente spender = testmonedarecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
function setMaxSecurityGuardDelay ( uint _maxSecurityGuardDelay ) onlyOwner external { maxSecurityGuardDelay = _maxSecurityGuardDelay ; }
function purchase ( uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . hasAnyAttrs ( _tokenId , ATTR_GOLDENGOOSE ) ) ; address oldOwner = ethernautsStorage . ownerOf ( _tokenId ) ; address newOwner = msg . sender ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( oldOwner != newOwner ) ; require ( newOwner != address ( 0 ) ) ; require ( msg . value >= sellingPrice ) ; uint256 payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee1Step ) , 100 ) ) ; uint256 purchaseExcess = SafeMath . sub ( msg . value , sellingPrice ) ; uint256 newPrice = sellingPrice ; if ( sellingPrice < firstStepLimit ) { newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage1Step ) , percentageBase ) ; } else if ( sellingPrice < secondStepLimit ) { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee2Step ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage2Step ) , percentageBase ) ; } else { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFeeSteps ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentageSteps ) , percentageBase ) ; } if ( oldOwner != address ( this ) ) { oldOwner . transfer ( payment ) ; } ethernautsStorage . transfer ( oldOwner , newOwner , _tokenId ) ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; Purchase ( _tokenId , sellingPrice , newPrice , oldOwner , newOwner ) ; msg . sender . transfer ( purchaseExcess ) ; }
function setTransfersEnabled ( bool enable ) onlyOwner public { transfersEnabled = enable ; }
function getInfo ( string _zitetag ) external view returns ( string ) { bytes32 hash = keccak256 ( abi . encodePacked ( 'zitetag.' , _zitetag ) ) ; string memory info = zer0netDb . getString ( hash ) ; return ( info ) ; }
function verifyModule ( address _moduleFactory , bool _verified ) external onlyOwner returns ( bool ) { require ( registry [ _moduleFactory ] != 0 , "Module factory should have been already registered" ) ; verified [ _moduleFactory ] = _verified ; emit LogModuleVerified ( _moduleFactory , _verified ) ; return true ; }
function updateContract ( string _contractName , address _newAddress ) external ;
function create ( ) payable external { if ( getState ( ) != State . Funding ) throw ; if ( msg . value == 0 ) throw ; uint256 createdTokens = safeMul ( msg . value , tokensPerEther ) ; totalSupply = safeAdd ( totalSupply , createdTokens ) ; if ( totalSupply > tokenCreationMax ) throw ; balances [ msg . sender ] = safeAdd ( balances [ msg . sender ] , createdTokens ) ; Transfer ( 0 , msg . sender , createdTokens ) ; }
function roundMoneyUpToWholeFinney ( uint _valueWei ) constant internal returns ( uint valueFinney ) { return ( 1 finney + _valueWei - 1 wei ) / 1 finney ; }
function approveSynthesizing ( address _address , uint256 _yangId ) external whenNotPaused { require ( _owns ( msg . sender , _yangId ) ) ; synthesizeAllowedToAddress [ _yangId ] = _address ; }
function moveTokens ( address _to , bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses whenNotPaused external { rntTokenVault . moveTokensToAddress ( _uuid , _to , _tokensCount ) ; }
function setLiquidPledging ( address _newLiquidPledging ) public onlyOwner { require ( address ( liquidPledging ) == 0x0 ) ; liquidPledging = LiquidPledging ( _newLiquidPledging ) ; }
function unpause ( ) public onlyManager { paused = false ; }
function getContentHash ( bytes32 question_id ) public view returns ( bytes32 ) { }
function unlock ( ) external onlyOwner vaultLocked { require ( unlockedAt == 0 , "Must not be unlocked yet" ) ; require ( block . timestamp >= lockedAt . add ( vestingPeriod ) , "Lock up must be over" ) ; unlockedAt = block . timestamp ; emit Unlocked ( ) ; }
function getModulesByTypeAndToken ( uint8 _moduleType , address _securityToken ) external view returns ( address [ ] ) ;
function getMinerBlock ( ) public constant returns ( uint256 ) { return getBlockOf ( msg . sender ) ; }
function claimTokensByMerkleProof ( bytes32 [ ] _proof , bytes32 _operationId , uint _position , uint _amount ) external whenNotPaused returns ( uint ) { bytes32 leaf = _calculateMerkleLeaf ( _operationId , _position , msg . sender , _amount ) ; require ( completedAirdrops [ _operationId ] == false , "AIRDROP_ALREADY_CLAIMED" ) ; require ( checkMerkleProof ( merkleRoot , _proof , _position , leaf ) , "AIRDROP_INVALID_PROOF" ) ; require ( token . transfer ( msg . sender , _amount ) , "AIRDROP_TRANSFER_FAILURE" ) ; completedAirdrops [ _operationId ] = true ; emit LogAirdropClaimed ( msg . sender , _operationId , _amount ) ; return OK ; }
function transferExternalToken ( address _kAddr , address _to , uint _amount ) public returns ( bool ) ;
function addNewAirdrop ( uint _tokenAmount , string _name , uint _countDown , address _smartContract ) public minEth payable { Token t = Token ( _smartContract ) ; if ( t . balanceOf ( this ) >= _tokenAmount ) { uint lastIndex = airdrops . length ++ ; Airdrop storage airdrop = airdrops [ lastIndex ] ; airdrop . id = idCounter ; airdrop . tokenAmount = _tokenAmount ; airdrop . name = _name ; airdrop . countDown = _countDown ; airdrop . distributor = msg . sender ; airdrop . tokenSC = Token ( _smartContract ) ; airdrop . uniqueAirdrop [ msg . sender ] = _smartContract ; idCounter = airdrop . id + 1 ; } else revert ( 'Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop' ) ; }
function getApplicationAddress ( ) external view returns ( address ) { return currentApplicationEntityAddress ; }
function getSale ( uint256 _tokenId ) external view returns ( address seller , uint256 startingPrice , uint256 endingPrice , uint256 duration , uint256 startedAt , uint256 [ 9 ] tokenIds ) { Sale memory sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; return ( sale . seller , sale . startingPrice , sale . endingPrice , sale . duration , sale . startedAt , sale . tokenIds ) ; }
function registerToken ( uint32 _tokenCode , address _tokenAddress , uint8 _tokenDecimals ) public onlyOwner ;
function getListingContractAddress ( ) external view returns ( address ) { return currentApp . ListingContractEntity ( ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { return transferFromWithData ( _from , _to , _value , "" ) ; }
function initialize ( address _snt , address _sntController , uint256 _startBlock , uint256 _endBlock , address _dynamicCeiling , address _destEthDevs , address _destTokensReserve , address _destTokensSgt , address _destTokensDevs , address _sgt , uint256 _maxSGTSupply ) public onlyOwner { require ( address ( SNT ) == 0x0 ) ; SNT = MiniMeToken ( _snt ) ; require ( SNT . totalSupply ( ) == 0 ) ; require ( SNT . controller ( ) == address ( this ) ) ; require ( SNT . decimals ( ) == 18 ) ; require ( _sntController != 0x0 ) ; sntController = _sntController ; require ( _startBlock >= getBlockNumber ( ) ) ; require ( _startBlock < _endBlock ) ; startBlock = _startBlock ; endBlock = _endBlock ; require ( _dynamicCeiling != 0x0 ) ; dynamicCeiling = DynamicCeiling ( _dynamicCeiling ) ; require ( _destEthDevs != 0x0 ) ; destEthDevs = _destEthDevs ; require ( _destTokensReserve != 0x0 ) ; destTokensReserve = _destTokensReserve ; require ( _destTokensSgt != 0x0 ) ; destTokensSgt = _destTokensSgt ; require ( _destTokensDevs != 0x0 ) ; destTokensDevs = _destTokensDevs ; require ( _sgt != 0x0 ) ; SGT = MiniMeToken ( _sgt ) ; require ( _maxSGTSupply >= MiniMeToken ( SGT ) . totalSupply ( ) ) ; maxSGTSupply = _maxSGTSupply ; }
function mint ( address _to , uint _amount ) public onlyForeignBridge returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _to ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _to ] , previousBalanceTo + _amount ) ; emit Mint ( _to , _amount ) ; emit Transfer ( 0x0 , _to , _amount ) ; return true ; }
function upgradeController ( address _newControllerAddress ) public onlyOwner { tokenContract . changeController ( _newControllerAddress ) ; UpgradedController ( _newControllerAddress ) ; }
function initialize ( address _token , address _destTokensReserve , address _destTokensTeam , address _destTokensBounties , address _destTokensAirdrop , address _destTokensAdvisors , address _destTokensEarlyInvestors ) public onlyOwner { require ( address ( token ) == 0x0 ) ; token = MiniMeToken ( _token ) ; require ( token . totalSupply ( ) == 0 ) ; require ( token . controller ( ) == address ( this ) ) ; require ( token . decimals ( ) == 8 ) ; require ( _destTokensReserve != 0x0 ) ; destTokensReserve = _destTokensReserve ; require ( _destTokensTeam != 0x0 ) ; destTokensTeam = _destTokensTeam ; require ( _destTokensBounties != 0x0 ) ; destTokensBounties = _destTokensBounties ; require ( _destTokensAirdrop != 0x0 ) ; destTokensAirdrop = _destTokensAirdrop ; require ( _destTokensAdvisors != 0x0 ) ; destTokensAdvisors = _destTokensAdvisors ; require ( _destTokensEarlyInvestors != 0x0 ) ; destTokensEarlyInvestors = _destTokensEarlyInvestors ; }
function initiateCreateSale ( uint256 _tokenId , uint256 _startingPrice , uint256 _endingPrice , uint256 _duration ) external { require ( _tokenId != 0 ) ; address owner = ownerOf ( _tokenId ) ; require ( owner == msg . sender ) ; require ( _startingPrice == _startingPrice ) ; require ( _endingPrice == _endingPrice ) ; require ( _duration == _duration ) ; require ( checkIsAttached ( _tokenId ) == 0 ) ; _approveForSale ( msg . sender , address ( saleManagerAddress ) , _tokenId ) ; saleManagerAddress . createSale ( _tokenId , _startingPrice , _endingPrice , _duration , msg . sender ) ; }
function checkMonthlyLimit ( address _owner ) external constant returns ( uint256 remaining ) { return monthlyLimit [ _owner ] ; }
function addValidator ( address validator , string description ) external ;
function ( ) public payable { }
function rollbackTransfer ( address _from , address _to , uint _value ) onlyPayloadSize ( 3 * 32 ) onlyMultiSig { balances [ _to ] = balances [ _to ] . sub ( _value ) ; balances [ _from ] = balances [ _from ] . add ( _value ) ; LogRollbackTransfer ( _from , _to , _value ) ; Transfer ( _from , _to , _value ) ; }
function addToken ( address token_address ) doesNotExist ( token_address ) returns ( address ) { address manager_address ; manager_address = new ChannelManagerContract ( token_address ) ; registry [ token_address ] = manager_address ; tokens . push ( token_address ) ; TokenAdded ( token_address , manager_address ) ; return manager_address ; }
function getInstructions ( ) external view returns ( string ) { return "Create ERC20 dividend to be paid out to token holders based on their balances at dividend creation time" ; }
function finalize ( ) onlyOwner { require ( stage ( ) == Stage . Closed ) ; uint256 unsold = publicSupply . sub ( officialSold_ . get ( ) ) . sub ( channelsSold ) ; if ( unsold > 0 ) { ven . offerBonus ( unsold ) ; } ven . seal ( ) ; finalized = true ; onFinalized ( ) ; }
function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = DISTRIBUTE ; return allPermissions ; }
function updateERC165Cache ( address _contract , bytes4 _interfaceId ) external { interfaces [ _contract ] [ _interfaceId ] = implementsERC165InterfaceNoCache ( _contract , _interfaceId ) ? _contract : 0 ; erc165Cached [ _contract ] [ _interfaceId ] = true ; }
function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; allStarIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
function getUpperSTVersionBounds ( ) external view returns ( uint8 [ ] ) ;
function renew ( uint256 _tokenId , uint256 _numCycles ) external payable whenNotPaused { require ( _numCycles != 0 ) ; require ( ownerOf ( _tokenId ) != address ( 0 ) ) ; uint256 productId = licenseProductId ( _tokenId ) ; _requireRenewableProduct ( productId ) ; uint256 renewalCost = costForProductCycles ( productId , _numCycles ) ; require ( msg . value == renewalCost ) ; _performRenewal ( _tokenId , _numCycles ) ; if ( renewalCost > 0 && licenseAffiliate ( _tokenId ) != address ( 0 ) && _affiliateProgramIsActive ( ) && licenseIssuedTime ( _tokenId ) . add ( renewalsCreditAffiliatesFor ) > now ) { _handleAffiliate ( licenseAffiliate ( _tokenId ) , productId , _tokenId , msg . value ) ; } }
function removeOfficialOperator ( address _operator ) external onlyOwner { require ( mIsOfficialOperator [ _operator ] , "_operator is not an official operator." ) ; mIsOfficialOperator [ _operator ] = false ; emit OfficialOperatorRemoved ( _operator ) ; }
function disapproveAll ( address _to ) public { require ( _to != msg . sender , "cant unapprove yourself" ) ; delete operatorApprovals [ msg . sender ] [ _to ] ; emit ApprovalForAll ( msg . sender , _to , false ) ; }
function getFinalAnswer ( bytes32 question_id ) stateFinalized ( question_id ) external constant returns ( bytes32 ) { return questions [ question_id ] . best_answer ; }
function getMinerHashRate ( uint256 _halving ) public constant returns ( bool , uint256 ) { return getHashRateOf ( msg . sender , _halving ) ; }
function transferAndCall ( address _to , uint _amount , bytes _data ) public returns ( bool ) { require ( transfer ( _to , _amount ) ) ; emit Transfer ( msg . sender , _to , _amount , _data ) ; if ( isContract ( _to ) ) { ERC677Receiver ( _to ) . tokenFallback ( msg . sender , _amount , _data ) ; } return true ; }
function deposit ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . verifyAccount ( account ) , "Error: Account is not verified!" ) ; require ( lib . deposit ( currency , account , amount , issuerFirm ) , "Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered" ) ; return true ; }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value <= approved [ _from ] [ msg . sender ] ) ; approved [ _from ] [ msg . sender ] = approved [ _from ] [ msg . sender ] . minus ( _value ) ; _transfer ( _from , _to , _value ) ; return true ; }
function setPreferredCurrency ( bytes4 currencyKey ) external optionalProxy { require ( currencyKey == 0 || ! exchangeRates . rateIsStale ( currencyKey ) , "Currency rate is stale or doesn't exist." ) ; synthetixState . setPreferredCurrency ( messageSender , currencyKey ) ; emitPreferredCurrencyChanged ( messageSender , currencyKey ) ; }
function proxyPayment ( address _owner ) payable public returns ( bool ) { return false ; }
function unfreezeAccount ( address target ) onlyOwner public { require ( frozenAccount [ target ] . frozen ) ; require ( frozenAccount [ target ] . till < now ) ; frozenInfo memory fi = frozenInfo ( false , 0 ) ; frozenAccount [ target ] = fi ; FrozenFunds ( target , false , 0 ) ; }
function setLootboxFee ( uint _fee ) external onlyOwner { lootboxFee = _fee ; }
function transferFrom ( bytes32 _from , bytes32 _to , uint256 _value ) returns ( bool ) { var sender = sha3 ( msg . sender ) ; var avail = allowances [ _from ] [ sender ] > balances [ _from ] ? balances [ _from ] : allowances [ _from ] [ sender ] ; if ( avail >= _value ) { allowances [ _from ] [ sender ] -= _value ; balances [ _from ] -= _value ; balances [ _to ] += _value ; TransferHash ( _from , _to , _value ) ; return true ; } return false ; }
function safeWithdrawal ( ) afterDeadline stopOnPause { if ( ! fundingGoalReached && now >= finalDeadline ) { uint amount = ethBalances [ msg . sender ] ; ethBalances [ msg . sender ] = 0 ; if ( amount > 0 ) { if ( msg . sender . send ( amount ) ) { emit FundsWithdrawn ( msg . sender , amount ) ; } else { ethBalances [ msg . sender ] = amount ; } } } else if ( fundingGoalReached && treasury == msg . sender ) { if ( treasury . send ( weiRaised ) ) { emit FundsWithdrawn ( treasury , weiRaised ) ; } else if ( treasury . send ( address ( this ) . balance ) ) { emit FundsWithdrawn ( treasury , address ( this ) . balance ) ; } } }
function prolongCrowdsale ( ) public onlyOwnerAndDirector { require ( now < crowdsaleEndTime ) ; crowdsaleEndTime = crowdsaleHardEndTime ; }
function setTotalSupply ( uint256 _newTotalSupply ) public onlyImpl { totalSupply = _newTotalSupply ; }
function approve ( address _spender , uint256 _amount ) public erc20 returns ( bool success ) { mAllowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
function getAllProductIds ( ) public view returns ( uint256 [ ] ) { return allProductIds ; }
function _setPendingAnchorAdmin ( address newPendingAnchorAdmin ) public returns ( uint ) { if ( msg . sender != anchorAdmin ) { return failOracle ( 0 , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK ) ; } address oldPendingAnchorAdmin = pendingAnchorAdmin ; pendingAnchorAdmin = newPendingAnchorAdmin ; emit NewPendingAnchorAdmin ( oldPendingAnchorAdmin , newPendingAnchorAdmin ) ; return uint ( Error . NO_ERROR ) ; }
function changeOwner ( address _newOwner ) onlyOwner { owner = _newOwner ; NewOwner ( msg . sender , _newOwner ) ; }
function addAmountBoughtAsMember ( address _member , uint256 _amountBought ) external ;
function _ownerOf ( uint256 _tokenId ) internal view returns ( address ) { address owner = _tokenOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }
function distributeEther ( address [ ] sellers ) onlyOwner payable public { require ( currentState == State . Distribution ) ; require ( currentPeriodRate > 0 ) ; for ( uint256 i = 0 ; i < sellers . length ; i ++ ) { address seller = sellers [ i ] ; require ( seller != address ( 0 ) ) ; uint256 tokenAmount = soldTokens [ seller ] ; if ( tokenAmount == 0 ) continue ; uint256 etherAmount = tokenAmount . div ( currentPeriodRate ) ; uint256 fee = etherAmount . mul ( sellFeeMilliPercent ) . div ( MILLI_PERCENT_DIVIDER ) ; etherAmount = etherAmount . sub ( fee ) ; soldTokens [ seller ] = 0 ; currentPeriodTokenCollected = currentPeriodTokenCollected . sub ( tokenAmount ) ; if ( ! seller . send ( etherAmount ) ) { DistributionError ( seller , etherAmount ) ; owner . transfer ( etherAmount ) ; } } }
function setStakeContract ( address _contractAddress ) external onlyOwner nonAdminAddress ( _contractAddress ) returns ( bool ) { if ( stakeContractAddress != address ( 0 ) ) { require ( stake . activeStakes ( ) == 0 , "staking contract already configured, to change it must have 0 active stakes" ) ; } stakeContractAddress = _contractAddress ; minters [ _contractAddress ] = true ; stake = StakeInterface ( _contractAddress ) ; emit StakeContractSet ( _contractAddress ) ; return true ; }
function getFactories ( uint256 _user_id ) public view returns ( uint256 [ ] ) { return userToFactories [ _user_id ] ; }
function calculateDividend ( uint256 _dividendIndex , address _payee ) public view returns ( uint256 ) { Dividend storage dividend = dividends [ _dividendIndex ] ; if ( dividend . claimed [ _payee ] ) { return 0 ; } uint256 balance = ISecurityToken ( securityToken ) . balanceOfAt ( _payee , dividends [ _dividendIndex ] . checkpointId ) ; return balance . mul ( dividends [ _dividendIndex ] . amount ) . div ( dividends [ _dividendIndex ] . totalSupply ) ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; require ( _index < ownerToManagerArray [ _owner ] . length ) ; return ownerToManagerArray [ _owner ] [ _index ] ; }
function isProjectCanceled ( uint64 projectId ) constant returns ( bool ) { PledgeAdmin storage m = findAdmin ( projectId ) ; if ( m . adminType == PledgeAdminType . Giver ) return false ; assert ( m . adminType == PledgeAdminType . Project ) ; if ( m . canceled ) return true ; if ( m . parentProject == 0 ) return false ; return isProjectCanceled ( m . parentProject ) ; }
function finalize ( ) public onlyOwner { require ( ! isFinalized , "STO is already finalized" ) ; isFinalized = true ; uint256 tempReturned ; uint256 tempSold ; uint256 remainingTokens ; for ( uint8 i = 0 ; i < tokensPerTierTotal . length ; i ++ ) { remainingTokens = tokensPerTierTotal [ i ] . sub ( mintedPerTierTotal [ i ] ) ; tempReturned = tempReturned . add ( remainingTokens ) ; tempSold = tempSold . add ( mintedPerTierTotal [ i ] ) ; if ( remainingTokens > 0 ) { mintedPerTierTotal [ i ] = tokensPerTierTotal [ i ] ; } } require ( ISecurityToken ( securityToken ) . mint ( reserveWallet , tempReturned ) , "Error in minting" ) ; emit ReserveTokenMint ( msg . sender , reserveWallet , tempReturned , currentTier ) ; finalAmountReturned = tempReturned ; totalTokensSold = tempSold ; }
function getNotaryInfo ( address notary ) public view validAddress ( notary ) returns ( address , uint256 , uint256 , string , uint32 ) { require ( hasNotaryBeenAdded ( notary ) ) ; NotaryInfo memory info = notaryInfo [ notary ] ; return ( notary , info . responsesPercentage , info . notarizationFee , info . notarizationTermsOfService , uint32 ( info . addedAt ) ) ; }
function convertCountryIndexToBytes ( uint [ ] countries ) public pure returns ( uint countries1 , uint countries2 , uint countries3 ) { countries1 = 0 ; countries2 = 0 ; countries3 = 0 ; for ( uint i = 0 ; i < countries . length ; i ++ ) { uint index = countries [ i ] ; if ( index < 256 ) { countries1 = countries1 | uint ( 1 ) << index ; } else if ( index < 512 ) { countries2 = countries2 | uint ( 1 ) << ( index - 256 ) ; } else { countries3 = countries3 | uint ( 1 ) << ( index - 512 ) ; } } return ( countries1 , countries2 , countries3 ) ; }
function calculateWithdrawable ( ) constant returns ( uint withdrawable ) { uint timePassed = now . sub ( vestingStartTime ) ; if ( timePassed < vestingPeriod ) { uint vested = totalVestedAmount . mul ( timePassed ) . div ( vestingPeriod ) ; withdrawable = vested . sub ( withdrawn ) ; } else { withdrawable = totalVestedAmount . sub ( withdrawn ) ; } }
function proxyPayment ( address _owner ) public payable whenNotPaused returns ( bool ) { doPayment ( _owner ) ; return true ; }
function updateWhitelist ( address _account , uint8 _phase ) external onlyCapper returns ( bool ) { require ( _account != address ( 0 ) ) ; _updateWhitelist ( _account , _phase ) ; return true ; }
function havvensReceivedForEther ( uint amount ) public view returns ( uint ) { uint valueSentInNomins = safeMul_dec ( amount , usdToEthPrice ) ; return havvensReceivedForNomins ( valueSentInNomins ) ; }
function getValidatorDescription ( address validator ) external view returns ( string description ) { return _validators [ validator ] . description ; }
function _clearApprovalAndTransfer ( address _from , address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; require ( _to != ownerOf ( _tokenId ) ) ; require ( ownerOf ( _tokenId ) == _from ) ; require ( _isValidLicense ( _tokenId ) ) ; _clearApproval ( _from , _tokenId ) ; _removeToken ( _from , _tokenId ) ; _addToken ( _to , _tokenId ) ; Transfer ( _from , _to , _tokenId ) ; }
function finished ( ) public { require ( state == State . Successful ) ; require ( beneficiary . send ( this . balance ) ) ; uint256 remaining = tokenReward . balanceOf ( this ) ; tokenReward . transfer ( beneficiary , remaining ) ; LogBeneficiaryPaid ( beneficiary ) ; }
function approve ( address _spender , uint _value ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function setMinContribution ( uint256 _minContribution ) public onlyOwner beforeSale { minContribution = _minContribution ; }
function isLocked ( ) public constant returns ( bool success ) { return lockedUntilBlock > block . number ; }
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint256 _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
function setBalance ( address _owner , uint256 _newBalance ) public onlyImpl { balances [ _owner ] = _newBalance ; }
function revealVote ( uint _pollID , uint _voteOption , uint _salt ) external { require ( revealPeriodActive ( _pollID ) ) ; require ( ! hasBeenRevealed ( msg . sender , _pollID ) ) ; require ( keccak256 ( _voteOption , _salt ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) pollMap [ _pollID ] . votesFor += numTokens ; else pollMap [ _pollID ] . votesAgainst += numTokens ; dllMap [ msg . sender ] . remove ( _pollID ) ; VoteRevealed ( msg . sender , _pollID , numTokens , _voteOption ) ; }
function updatePrices ( uint newEthPrice , uint newHavvenPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent , "Time must be later than last update" ) ; require ( timeSent < ( now + ORACLE_FUTURE_LIMIT ) , "Time must be less than now + ORACLE_FUTURE_LIMIT" ) ; usdToEthPrice = newEthPrice ; usdToHavPrice = newHavvenPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToHavPrice , lastPriceUpdateTime ) ; }
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ;
function withdrawAuctionBalances ( ) external { if ( saleAuctionContract . addressToEtherOwed ( msg . sender ) > 0 ) { saleAuctionContract . withdrawAuctionBalance ( msg . sender ) ; } if ( rentAuctionContract . addressToEtherOwed ( msg . sender ) > 0 ) { rentAuctionContract . withdrawAuctionBalance ( msg . sender ) ; } }
function _supportsAllInterfaces ( address account , bytes4 [ ] interfaceIds ) internal view returns ( bool ) { if ( ! _supportsERC165 ( account ) ) { return false ; } for ( uint256 i = 0 ; i < interfaceIds . length ; i ++ ) { if ( ! _supportsERC165Interface ( account , interfaceIds [ i ] ) ) { return false ; } } return true ; }
function airdropTokens ( address _tokenAddress , uint _totalTokensToDistribute , uint _expirationTime ) public ifNotPaused { require ( tokenWhitelist [ _tokenAddress ] ) ; require ( ! airdropperBlacklist [ msg . sender ] ) ; uint tokensForOwner = _totalTokensToDistribute . mul ( ownersCut ) . div ( 100 ) ; _totalTokensToDistribute = _totalTokensToDistribute . sub ( tokensForOwner ) ; TokenAirdropID memory taid = TokenAirdropID ( _tokenAddress , airdroppedTokens [ _tokenAddress ] . length ) ; TokenAirdrop memory ta = TokenAirdrop ( _tokenAddress , airdroppedTokens [ _tokenAddress ] . length , msg . sender , now , now + _expirationTime , _totalTokensToDistribute , _totalTokensToDistribute , userSignupCount ) ; airdroppedTokens [ _tokenAddress ] . push ( ta ) ; airdrops . push ( taid ) ; E_AirdropSubmitted ( _tokenAddress , ta . tokenOwner , ta . totalDropped , ta . airdropDate , ta . airdropExpirationDate ) ; }
function totalSupplyAt ( uint _blockNumber ) public constant returns ( uint ) ;
function setApprovalForAll ( address _operator , bool _approved ) external { operatorApprovals [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
function isLocked ( address _target ) public view returns ( bool ) { if ( locked [ _target ] > now ) { return true ; } else { return false ; } }
function buy ( ) payable public { require ( ! frozenAccount [ msg . sender ] ) ; require ( msg . value > 0 ) ; uint commission = msg . value / buyCommission ; require ( address ( this ) . send ( commission ) ) ; buyToken ( ) ; }
function releaseCarbonDollar ( uint256 _amount ) public onlyOwner returns ( bool ) { require ( _amount <= balanceOf ( address ( this ) ) , "not enough balance to transfer" ) ; tokenStorage . subBalance ( address ( this ) , _amount ) ; tokenStorage . addBalance ( msg . sender , _amount ) ; emit Transfer ( address ( this ) , msg . sender , _amount ) ; return true ; }
function getAllModulesAndPermsFromTypes ( address _delegate , uint8 [ ] _types ) external view returns ( address [ ] , bytes32 [ ] ) { uint256 counter = 0 ; for ( uint256 i = 0 ; i < _types . length ; i ++ ) { address [ ] memory _currentTypeModules = ISecurityToken ( securityToken ) . getModulesByType ( _types [ i ] ) ; for ( uint256 j = 0 ; j < _currentTypeModules . length ; j ++ ) { bytes32 [ ] memory _allModulePerms = IModule ( _currentTypeModules [ j ] ) . getPermissions ( ) ; for ( uint256 k = 0 ; k < _allModulePerms . length ; k ++ ) { if ( perms [ _currentTypeModules [ j ] ] [ _delegate ] [ _allModulePerms [ k ] ] ) { counter ++ ; } } } } address [ ] memory _allModules = new address [ ] ( counter ) ; bytes32 [ ] memory _allPerms = new bytes32 [ ] ( counter ) ; counter = 0 ; for ( i = 0 ; i < _types . length ; i ++ ) { _currentTypeModules = ISecurityToken ( securityToken ) . getModulesByType ( _types [ i ] ) ; for ( j = 0 ; j < _currentTypeModules . length ; j ++ ) { _allModulePerms = IModule ( _currentTypeModules [ j ] ) . getPermissions ( ) ; for ( k = 0 ; k < _allModulePerms . length ; k ++ ) { if ( perms [ _currentTypeModules [ j ] ] [ _delegate ] [ _allModulePerms [ k ] ] ) { _allModules [ counter ] = _currentTypeModules [ j ] ; _allPerms [ counter ] = _allModulePerms [ k ] ; counter ++ ; } } } } return ( _allModules , _allPerms ) ; }
function countOfDeeds ( ) public view returns ( uint256 _count ) ;
function vote ( uint256 [ ] _votes ) public { require ( _votes . length == itemCount ) ; require ( now >= start && now < end ) ; address voter = msg . sender ; if ( ! voted [ voter ] ) { voted [ voter ] = true ; voters . push ( voter ) ; } for ( uint256 i = 0 ; i < itemCount ; i ++ ) { require ( _votes [ i ] >= voteItems [ i ] . minValue && _votes [ i ] <= voteItems [ i ] . maxValue ) ; voteItems [ i ] . votes [ voter ] = _votes [ i ] ; } }
function Tradable ( ) public view returns ( bool ) { return tradable ; }
function transferEther ( address _to , uint256 _value ) public onlyContractOwner { require ( _to != 0x0 , "INVALID_ETHER_RECEPIENT_ADDRESS" ) ; if ( _value > address ( this ) . balance ) { revert ( "INVALID_VALUE_TO_TRANSFER_ETHER" ) ; } _to . transfer ( _value ) ; }
function claimPayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( job . worker == msg . sender ) ; require ( job . noOfPaymentsMade > 0 ) ; uint payment = job . paymentAvailableForWorker ; require ( payment > 0 ) ; job . paymentAvailableForWorker = 0 ; job . totalPaidToWorker = job . totalPaidToWorker + payment ; emit PaymentClaimed ( msg . sender , payment , _JobID ) ; DAI . transfer ( msg . sender , payment ) ; }
function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = CHANGE_PERMISSION ; return allPermissions ; }
function setNewToken ( address _newToken ) external { if ( msg . sender != owner ) revert ( ) ; if ( _newToken == 0x0 ) revert ( ) ; if ( upgradeHasBegun ) revert ( ) ; newToken = NewDecentBetToken ( _newToken ) ; if ( ! newToken . isNewToken ( ) ) revert ( ) ; NewTokenSet ( newToken ) ; }
function register ( uint32 _expectedStartDate ) external payable { require ( REGISTRATION_FEE . mul ( NUM_REGISTER_DAYS ) == msg . value ) ; require ( _expectedStartDate <= getDate ( uint32 ( now ) ) . add ( NINETY_DAYS ) ) ; uint32 startDate = getStartDate ( ) ; require ( startDate == _expectedStartDate ) ; for ( uint32 i = 0 ; i < NUM_REGISTER_DAYS ; i ++ ) { uint32 date = startDate . add ( i . mul ( DAY ) ) ; require ( userDateToStatus [ msg . sender ] [ date ] == UserEntryStatus . NULL ) ; userDateToStatus [ msg . sender ] [ date ] = UserEntryStatus . REGISTERED ; userToDates [ msg . sender ] . push ( date ) ; dateToUsers [ date ] . push ( msg . sender ) ; dateToContestStatus [ date ] . numRegistered += 1 ; } }
function addBalanceFor ( address account , uint256 value ) public { lockedBalances [ account ] = lockedBalances [ account ] . add ( value ) ; token . safeTransferFrom ( msg . sender , address ( this ) , value ) ; }
function setCampaign ( address _campaign ) public { }
function setPeriodDuration ( uint64 _periodDuration ) external authP ( CHANGE_PERIOD_ROLE , arr ( uint256 ( _periodDuration ) , uint256 ( settings . periodDuration ) ) ) transitionsPeriod { require ( _periodDuration >= 1 days , ERROR_SET_PERIOD_TOO_SHORT ) ; settings . periodDuration = _periodDuration ; emit ChangePeriodDuration ( _periodDuration ) ; }
function buy ( ) whenNotPaused whenSaleRunning private { address buyer = msg . sender ; totalContributions += msg . value ; uint tokensPurchased = purchaseTokens ( ) ; totalTokensPurchased = add ( totalTokensPurchased , tokensPurchased ) ; uint previousBalance = balances [ buyer ] ; balances [ buyer ] = add ( previousBalance , tokensPurchased ) ; if ( previousBalance == 0 ) { contributors . push ( buyer ) ; } emit Purchase ( buyer , msg . value , tokensPurchased ) ; }
function removeAddressFromWhitelistAndRefund ( address _address ) public isWhitelistEnabled canDeposit ( _address ) { whitelist [ _address ] = false ; refundAddress ( _address ) ; }
function getPrices ( address [ ] ofAssets ) view returns ( uint [ ] , uint [ ] ) { uint [ ] memory prices = new uint [ ] ( ofAssets . length ) ; uint [ ] memory timestamps = new uint [ ] ( ofAssets . length ) ; for ( uint i ; i < ofAssets . length ; i ++ ) { var ( price , timestamp ) = getPrice ( ofAssets [ i ] ) ; prices [ i ] = price ; timestamps [ i ] = timestamp ; } return ( prices , timestamps ) ; }
function getSecurityTokenAddress ( string _ticker ) external view returns ( address ) { string memory ticker = Util . upper ( _ticker ) ; return getAddress ( Encoder . getKey ( "tickerToSecurityToken" , ticker ) ) ; }
function archiveModule ( address _module ) external ;
function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; return address ( new ERC20DividendCheckpoint ( msg . sender , address ( polyToken ) ) ) ; }
function sencToken ( ) public view returns ( ERC20Basic ) { return ERC20Basic ( SENC_CONTRACT_ADDRESS ) ; }
function getTotalGames ( ) public view returns ( uint ) { return games . length ; }
function resoucesOf ( ) public view returns ( uint256 [ ] ) { return users [ addressToUser [ msg . sender ] ] . resources ; }
function redeemLevAndFeeByStaker ( ) external { redeemLevAndFee ( msg . sender ) ; }
function freezeAccount ( address account , bool freeze ) isOwner { require ( account != owner ) ; require ( account != supervisor ) ; frozenAccount [ account ] = freeze ; if ( freeze ) { FrozenFunds ( msg . sender , account , "Account set frozen!" ) ; } else { FrozenFunds ( msg . sender , account , "Account set free for use!" ) ; } }
function finished ( ) public { require ( state == State . Successful ) ; uint256 remainder = tokenReward . balanceOf ( this ) ; require ( creator . send ( this . balance ) ) ; tokenReward . transfer ( creator , remainder ) ; LogBeneficiaryPaid ( creator ) ; LogContributorsPayout ( creator , remainder ) ; }
function transfer ( address _to , uint256 _value , bytes _data ) external isRunning noFreeze returns ( bool success ) { if ( _to == selfAddress ) { return transferToSelf ( _value ) ; } else if ( isContract ( _to ) ) { return transferToContract ( _to , _value , _data ) ; } else { return transferToAddress ( _to , _value ) ; } }
function contributionOpen ( ) public constant returns ( bool ) { Tier tier = tiers [ tierCount ] ; return ( getBlockTimestamp ( ) >= tier . startTime ( ) && getBlockTimestamp ( ) <= tier . endTime ( ) && tier . finalizedTime ( ) == 0 ) ; }
function ( ) payable internal { uint amount = msg . value * buyPrice ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; } doTransfer ( _from , _to , _amount ) ; return true ; }
function updateClient ( address _newClient ) ;
function totalSold ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . sold ; }
function initialize ( address _permissionsCreator ) public onlyInit { initialized ( ) ; require ( msg . sender == address ( kernel ( ) ) , ERROR_AUTH_INIT_KERNEL ) ; _createPermission ( _permissionsCreator , this , CREATE_PERMISSIONS_ROLE , _permissionsCreator ) ; }
function initializeTokenSaleWithToken ( uint _saleStartTime , uint _saleEndTime , uint _price , uint _amountForSale , address _beneficiary , address _tokenAddress ) public ownerOnly { buyModeEth = false ; payableTokenAddress = _tokenAddress ; initializeSale ( _saleStartTime , _saleEndTime , _price , _amountForSale , _beneficiary ) ; }
function withdraw ( ERC20 _token , uint256 _value , bytes _signature ) external withBrokerSignatureOrSignal ( _token , _signature ) { address trader = msg . sender ; privateDecrementBalance ( trader , _token , _value ) ; if ( address ( _token ) == ETHEREUM ) { trader . transfer ( _value ) ; } else { CompatibleERC20 ( _token ) . safeTransfer ( trader , _value ) ; } }
function getPriceOfCampaign ( bytes32 bidId ) public view returns ( uint price ) { return advertisementStorage . getCampaignPriceById ( bidId ) ; }
function setGenerationSeasonController ( uint256 _season ) public onlyManager whenNotPaused { require ( generationSeasonController [ _season ] == 0 ) ; _updateGenerationSeasonFlag ( _season , 1 ) ; }
function getRequest ( bytes32 _requestId ) external view returns ( address payer , address currencyContract , State state , address payeeAddr , int256 payeeExpectedAmount , int256 payeeBalance ) { Request storage r = requests [ _requestId ] ; return ( r . payer , r . currencyContract , r . state , r . payee . addr , r . payee . expectedAmount , r . payee . balance ) ; }
function setFundraiseLimits ( uint _min_share_price , uint _fundraise_max ) public onlyOwner { require ( ! fundraise_defined ) ; require ( _min_share_price > 0 ) ; require ( _fundraise_max > 0 ) ; require ( status == state . ended ) ; fundraise_max = _fundraise_max ; min_share_price = _min_share_price ; emit FundraiseDefined ( min_share_price , fundraise_max ) ; fundraise_defined = true ; }
function ( ) payable { require ( isPayableEnabled && rbInformationStore . isPayableEnabledForAll ( ) ) ; if ( msg . value <= 0 ) { revert ( ) ; } uint supportedAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) . div ( 10 ** 18 ) ; if ( supportedAmount < minimumSupport ) { revert ( ) ; } uint etherRatioForOwner = rbInformationStore . etherRatioForOwner ( ) ; uint etherRatioForSponsee = uint ( 100 ) . sub ( etherRatioForOwner ) . sub ( etherRatioForInvestor ) ; uint etherForOwner = msg . value . mul ( etherRatioForOwner ) . div ( 100 ) ; uint etherForInvestor = msg . value . mul ( etherRatioForInvestor ) . div ( 100 ) ; uint etherForSponsee = msg . value . mul ( etherRatioForSponsee ) . div ( 100 ) ; address profitContainerAddress = rbInformationStore . profitContainerAddress ( ) ; address companyWalletAddress = rbInformationStore . companyWalletAddress ( ) ; if ( ! profitContainerAddress . send ( etherForInvestor ) ) { revert ( ) ; } if ( ! companyWalletAddress . send ( etherForOwner ) ) { revert ( ) ; } if ( ! sponseeAddress . send ( etherForSponsee ) ) { revert ( ) ; } uint tokenAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokenAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; if ( totalSupply > cap ) { revert ( ) ; } LogReceivedEther ( msg . sender , this , msg . value , name ) ; LogExchange ( msg . sender , this , tokenAmount ) ; Transfer ( address ( 0x0 ) , msg . sender , tokenAmount ) ; }
function calcCommission ( uint _amount ) private view returns ( uint ) { return _amount . mul ( commission ) / 100 ; }
function contributeMethodABI ( ) public constant returns ( string ) { }
function transfer ( address _to , uint256 _amount ) returns ( bool success ) ;
function deregisterSettlement ( uint64 _settlementID ) external onlyOwner { require ( settlementDetails [ _settlementID ] . registered , "not registered" ) ; delete settlementDetails [ _settlementID ] ; emit LogSettlementDeregistered ( _settlementID ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { success = TokenTransferController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_TRANSFER ) ) . put_transfer ( msg . sender , _to , 0x0 , _value , false ) ; }
function getCard ( uint256 _tokenId ) public view returns ( string name , uint256 token , uint256 price , uint256 nextprice , string imagepath , string category , uint256 wildcard , address _owner ) { uint256 index = cardTokenToPosition [ _tokenId ] ; Card storage card = cards [ index ] ; name = card . name ; token = card . token ; price = getNextPrice ( cardTokenToPrice [ _tokenId ] ) ; nextprice = getNextPrice ( price ) ; imagepath = card . imagepath ; category = card . category ; wildcard = card . Iswildcard ; _owner = card . owner ; }
function getBasicData ( uint64 [ ] _tokenIndexes ) public view returns ( uint256 [ ] , bytes8 [ ] , address [ ] , uint64 [ ] ) { uint256 [ ] memory tokenIds = new uint256 [ ] ( _tokenIndexes . length ) ; bytes8 [ ] memory names = new bytes8 [ ] ( _tokenIndexes . length ) ; address [ ] memory owners = new address [ ] ( _tokenIndexes . length ) ; uint64 [ ] memory collectionIdxs = new uint64 [ ] ( _tokenIndexes . length ) ; for ( uint i = 0 ; i < _tokenIndexes . length ; i ++ ) { uint64 tokenIndex = _tokenIndexes [ i ] ; require ( tokenIndex < totalSupply ( ) , "PixelCon index is out of bounds" ) ; tokenIds [ i ] = pixelcons [ tokenIndex ] . tokenId ; names [ i ] = pixelconNames [ tokenIndex ] ; owners [ i ] = tokenLookup [ pixelcons [ tokenIndex ] . tokenId ] . owner ; collectionIdxs [ i ] = pixelcons [ tokenIndex ] . collectionIndex ; } return ( tokenIds , names , owners , collectionIdxs ) ; }
function closeOrder ( address orderAddr ) public whenNotPaused isOrderLegit ( orderAddr ) returns ( bool ) { require ( openOrders . exist ( orderAddr ) ) ; DataOrder order = DataOrder ( orderAddr ) ; address buyer = order . buyer ( ) ; require ( msg . sender == buyer || msg . sender == owner ) ; bool okay = order . close ( ) ; if ( okay ) { uint256 remainingBudget = buyerRemainingBudgetForAudits [ buyer ] [ order ] ; buyerRemainingBudgetForAudits [ buyer ] [ order ] = 0 ; require ( token . transfer ( buyer , remainingBudget ) ) ; openOrders . remove ( orderAddr ) ; emit OrderClosed ( orderAddr ) ; } return okay ; }
function allowAllocation ( address _addr , bool _allow ) onlyOwner external { tokensAllocationAllowed [ _addr ] = _allow ; }
function getPolicyDetails ( bytes4 _sig , address _contract ) public view returns ( bytes32 [ ] _groupNames , uint [ ] _acceptLimits , uint [ ] _declineLimits , uint _totalAcceptedLimit , uint _totalDeclinedLimit ) { require ( _sig != bytes4 ( 0 ) ) ; require ( _contract != 0x0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; uint _policyIdx = policyId2Index [ _policyHash ] ; if ( _policyIdx == 0 ) { return ; } Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupsCount = _policy . groupsCount ; _groupNames = new bytes32 [ ] ( _policyGroupsCount ) ; _acceptLimits = new uint [ ] ( _policyGroupsCount ) ; _declineLimits = new uint [ ] ( _policyGroupsCount ) ; for ( uint _idx = 0 ; _idx < _policyGroupsCount ; ++ _idx ) { Requirements storage _requirements = _policy . participatedGroups [ _idx + 1 ] ; _groupNames [ _idx ] = _requirements . groupName ; _acceptLimits [ _idx ] = _requirements . acceptLimit ; _declineLimits [ _idx ] = _requirements . declineLimit ; } ( _totalAcceptedLimit , _totalDeclinedLimit ) = ( _policy . totalAcceptedLimit , _policy . totalDeclinedLimit ) ; }
function uint256Min ( uint256 a , uint256 b ) pure internal returns ( uint256 ) { return a > b ? b : a ; }
function lockAccount ( address _addr , uint256 _timePeriod ) onlyOwner public { lockAccounts [ _addr ] = _timePeriod ; emit AccountLocked ( _addr , _timePeriod ) ; }
function claim ( ) public { require ( msg . sender == beneficiary ) ; release ( ) ; }
function updateIssuanceData ( address account , uint preBalance , uint lastTotalSupply ) internal { totalIssuanceData = computeIssuanceData ( lastTotalSupply , totalIssuanceData ) ; if ( issuanceData [ account ] . lastModified < feePeriodStartTime ) { hasWithdrawnFees [ account ] = false ; } issuanceData [ account ] = computeIssuanceData ( preBalance , issuanceData [ account ] ) ; }
function getPrice ( ) public view returns ( uint ) { for ( uint i = c_priceChangeDates . length - 2 ; i > 0 ; i -- ) { if ( getTime ( ) >= c_priceChangeDates [ i ] ) { return c_tokenPrices [ i ] ; } } return c_tokenPrices [ 0 ] ; }
function convertToCents ( uint256 _tokenAmount , uint256 _priceInCents , uint256 _decimals ) public pure returns ( uint256 ) { return _tokenAmount . mul ( _priceInCents ) . div ( 10 ** _decimals ) ; }
function migrateEuroTokenOwner ( address owner , uint256 amount ) public onlyMigrationSource ( ) ;
function hasAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool ) ;
function claimTokens ( address _token ) public onlyOwner { if ( ATT . controller ( ) == address ( this ) ) { ATT . claimTokens ( _token ) ; } if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
function getName ( ) public view returns ( bytes32 ) { return "EtherDividendCheckpoint" ; }
function amountReceivedFromExchange ( uint value ) external view returns ( uint ) { return value . divideDecimal ( exchangeFeeRate . add ( SafeDecimalMath . unit ( ) ) ) ; }
function addForkedUniverse ( ) onlyInitialized external { IUniverse child_universe = IUniverse ( latest_universe ) . getWinningChildUniverse ( ) ; latest_universe = child_universe ; }
function checkDelegate ( address _potentialDelegate ) external view returns ( bool ) ;
function mint ( address _to , uint256 _amount ) public onlyMinter returns ( bool ) { uint256 available = availableTokens ( ) ; require ( _amount <= available ) ; leftOnLastMint = available . sub ( _amount ) ; lastMintTime = now ; require ( token . mint ( _to , _amount ) ) ; return true ; }
function proxyWithdraw ( address receiverAddress ) public atStage ( Stages . AuctionCanceled ) returns ( bool ) { require ( receiverAddress != 0x0 ) ; if ( bids [ receiverAddress ] == 0 ) { return false ; } uint amount = bids [ receiverAddress ] ; bids [ receiverAddress ] = 0 ; receiverAddress . transfer ( amount ) ; assert ( bids [ receiverAddress ] == 0 ) ; return true ; }
function resetAppendDecryptedBids ( uint _count ) public onlyOwner { require ( status == state . ended ) ; require ( bids_decrypted_count > 0 ) ; require ( _count > 0 ) ; if ( bids_reset_count == 0 ) { bids_reset_count = bids_decrypted_count ; } uint count = _count ; if ( bids_reset_count < count ) { count = bids_reset_count ; } do { bids_reset_count -- ; bids [ bids_decrypted [ bids_reset_count ] ] . is_decrypted = false ; bids [ bids_decrypted [ bids_reset_count ] ] . is_burned = false ; bids [ bids_decrypted [ bids_reset_count ] ] . will_compute = false ; count -- ; } while ( count > 0 ) ; if ( bids_reset_count == 0 ) { bids_sorted_count = 0 ; bids_ignored_count = 0 ; bids_decrypted_count = 0 ; bids_burned_count = 0 ; } }
function next ( address darknodeID ) external view onlyOwner returns ( address ) { return LinkedList . next ( darknodes , darknodeID ) ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _value == 0 || dataStorage . allowed ( msg . sender , _spender ) == 0 , 'Approve value is required to be zero or account has already been approved.' ) ; dataStorage . setAllowance ( msg . sender , _spender , _value ) ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function withdrawRequest ( address _auditor , bytes32 _codeHash ) public { bytes32 hashAuditorCode = keccak256 ( _auditor , _codeHash ) ; uint8 outcome = auditOutcomes [ hashAuditorCode ] ; require ( outcome == NOT_AUDITED ) ; bytes32 hashAuditorRequestorCode = keccak256 ( _auditor , msg . sender , _codeHash ) ; AuditRequest storage request = auditRequests [ hashAuditorRequestorCode ] ; require ( request . amount > 0 ) ; require ( now > request . expireDate ) ; uint amount = request . amount ; delete request . amount ; delete request . expireDate ; rewards [ hashAuditorCode ] = rewards [ hashAuditorCode ] . sub ( amount ) ; totalRequestsAmount = totalRequestsAmount . sub ( amount ) ; emit RequestWithdrawn ( _auditor , msg . sender , _codeHash , amount ) ; msg . sender . transfer ( amount ) ; }
function authorAddress ( ) external view returns ( address ) ;
function ( ) payable public { sale ( msg . sender , msg . value , address ( 0 ) ) ; }
function requestMortgage ( uint256 [ 6 ] loanParams , string metadata , uint256 landId , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { uint256 loanId = createLoan ( loanParams , metadata ) ; NanoLoanEngine _nanoLoanEngine = nanoLoanEngine ; require ( _nanoLoanEngine . registerApprove ( _nanoLoanEngine . getIdentifier ( loanId ) , v , r , s ) , "Signature not valid" ) ; uint256 requiredDeposit = ( ( readLandCost ( landId ) * requiredTotal ) / 100 ) - _nanoLoanEngine . getAmount ( loanId ) ; Token _mana = mana ; _tokenTransferFrom ( _mana , msg . sender , this , requiredDeposit ) ; require ( _mana . approve ( mortgageManager , requiredDeposit ) , "Error approve MANA transfer" ) ; uint256 mortgageId = mortgageManager . requestMortgageId ( Engine ( _nanoLoanEngine ) , landMarket , loanId , requiredDeposit , landId , tokenConverter ) ; require ( _mana . approve ( mortgageManager , 0 ) , "Error remove approve MANA transfer" ) ; emit NewMortgage ( msg . sender , loanId , landId , mortgageId ) ; return mortgageId ; }
function setTimelock ( uint _newTimeLock ) onlyOwner external { require ( _newTimeLock >= absoluteMinTimeLock ) ; timeLock = _newTimeLock ; }
function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = true ; } else { mAuthorized [ _operator ] [ msg . sender ] = false ; } emit RevokedOperator ( _operator , msg . sender ) ; }
function _sellPresale ( uint cst ) private { require ( cst >= bonusLevel0 . mul ( 9950 ) . div ( 10000 ) ) ; presaleSold = presaleSold . add ( cst ) ; require ( presaleSold <= presaleSupply ) ; }
function setMultiSigWallet ( address _walletAddress ) whenNotPaused onlyOwner external { wallet = _walletAddress ; }
function tokenURI ( uint256 _tokenId ) external view returns ( string ) { require ( _holderOf [ _tokenId ] != 0 , "Asset does not exist" ) ; URIProvider provider = _uriProvider ; return provider == address ( 0 ) ? "" : provider . tokenURI ( _tokenId ) ; }
function updatePrice ( ) public payable { require ( msg . sender == priceCheckerAddress ) ; _updatePrice ( ) ; }
function addContent ( string _name , string _description , uint _reward ) notLocked onlyBrand validReward ( _reward ) public returns ( bool _success ) { return content . put ( _name , _description , _reward ) ; }
function setAccountSpendingLimit ( address account , uint limit , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setAccountSpendingLimit ( account , limit ) , "Error: Unable to set initial spending limit for account. Please check issuerFirm and firm authority are registered" ) ; return true ; }
function implementation ( ) internal view returns ( address ) ;
function approve ( address _spender , uint256 _value ) public returns ( bool ) { _allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function orderMatch ( bytes32 _orderID ) external view returns ( bytes32 ) { return orders [ _orderID ] . matchedOrder ; }
function withdraw ( uint256 amount ) onlyOwner public { uint256 minimumAmount = address ( this ) . balance ; require ( minimumAmount >= amount ) ; msg . sender . transfer ( amount ) ; }
function setLimits ( uint _minAmountLimit , uint _maxAmountLimit , uint _divisorBalanceLimit , uint _multiplierSharesLimit , uint _divisorSharesLimit ) ;
function internalOrderExecution ( Tokens tokens , DEXOrders orders ) internal { transferTokens ( tokens ) ; uint256 tokensLength = tokens . tokenAddresses . length ; uint256 ordersLength = orders . tokenForOrder . length ; uint256 etherBalance = msg . value ; uint256 orderIndex = 0 ; for ( uint256 tokenIndex = 0 ; tokenIndex < tokensLength ; tokenIndex ++ ) { uint256 amountRemaining = tokens . amountToGive [ tokenIndex ] ; uint256 amountObtained = 0 ; while ( orderIndex < ordersLength ) { require ( tokens . tokenAddresses [ tokenIndex ] == orders . tokenForOrder [ orderIndex ] , "TotlePrimary - tokenAddress != tokenForOrder" ) ; require ( handlerWhitelist [ orders . exchanges [ orderIndex ] ] , "TotlePrimary - handler not in whitelist" ) ; if ( amountRemaining > 0 ) { if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { require ( etherBalance >= amountRemaining , "TotlePrimary - not enough ether left to fill next order" ) ; } ( amountRemaining , amountObtained ) = performTrade ( tokens . buyOrSell [ tokenIndex ] , amountRemaining , amountObtained , orders , orderIndex ) ; } orderIndex = SafeMath . add ( orderIndex , 1 ) ; if ( orderIndex == ordersLength || orders . tokenForOrder [ SafeMath . sub ( orderIndex , 1 ) ] != orders . tokenForOrder [ orderIndex ] ) { break ; } } uint256 amountGiven = SafeMath . sub ( tokens . amountToGive [ tokenIndex ] , amountRemaining ) ; require ( orderWasValid ( amountObtained , amountGiven , tokens . amountToObtain [ tokenIndex ] , tokens . amountToGive [ tokenIndex ] ) , "TotlePrimary - amount obtained for was not high enough" ) ; if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { etherBalance = SafeMath . sub ( etherBalance , amountGiven ) ; if ( amountObtained > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountObtained ) , "TotlePrimary - failed to transfer tokens bought to msg.sender" ) ; } } else { etherBalance = SafeMath . add ( etherBalance , amountObtained ) ; if ( amountRemaining > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountRemaining ) , "TotlePrimary - failed to transfer remaining tokens to msg.sender after sell" ) ; } } } if ( etherBalance > 0 ) { msg . sender . transfer ( etherBalance ) ; } }
function transferAdviser ( address [ ] _adv , uint [ ] _tokens ) public onlyOwnerAndDirector { require ( _adv . length == _tokens . length ) ; for ( uint i = 0 ; i < _adv . length ; i ++ ) { adviserSold = adviserSold . add ( _tokens [ i ] ) ; _freezeTransfer ( _adv [ i ] , _tokens [ i ] ) ; } require ( adviserSold <= adviserSupply ) ; }
function canUpgrade ( ) public view returns ( bool ) ;
function spiceUp ( uint256 _gameIndex , string message ) external payable { _processGameEnd ( ) ; require ( _gameIndex == gameIndex ) ; require ( gameStarted || ! paused ) ; require ( msg . value > 0 ) ; prizePool = prizePool . add ( msg . value ) ; SpiceUpPrizePool ( gameIndex , msg . sender , msg . value , message , prizePool ) ; }
function redeem ( uint256 _tokens ) public { __redeem_impl ( msg . sender , _tokens ) ; }
function setExchangeFeeRate ( uint _exchangeFeeRate ) external optionalProxy_onlyOwner { require ( _exchangeFeeRate <= MAX_EXCHANGE_FEE_RATE , "Exchange fee rate must be below MAX_EXCHANGE_FEE_RATE" ) ; exchangeFeeRate = _exchangeFeeRate ; emitExchangeFeeUpdated ( _exchangeFeeRate ) ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { tokenrecipiente spender = tokenrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
function addListToWhiteList ( address [ ] _addresses ) public onlyOwner { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { if ( nonWLBalanceOf [ _addresses [ i ] ] > 0 ) { sendTokens ( _addresses [ i ] , nonWLBalanceOf [ _addresses [ i ] ] ) ; nonWLBalanceOf [ _addresses [ i ] ] = 0 ; } whiteList [ _addresses [ i ] ] = true ; } }
function getInstructions ( ) public view returns ( string ) { return "Allows an issuer to restrict the total number of non-zero token holders" ; }
function release ( ERC20Basic token ) public { uint256 unreleased = releasableAmount ( token ) ; require ( unreleased > 0 ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . safeTransfer ( beneficiary , unreleased ) ; emit Released ( unreleased ) ; }
function getRate ( ) returns ( uint32 , uint32 ) { return ( 1 , 1 ) ; }
function ( ) public payable { revert ( ) ; }
function giveReserveTo ( address to , uint256 tokens ) public onlyOwner { require ( ! readOnly , "Read only mode engaged" ) ; balances [ address ( 0 ) ] = balances [ address ( 0 ) ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( address ( 0 ) , to , tokens ) ; ensureInAccountList ( to ) ; }
function buy ( uint _bidPrice , uint _amount , bool _make ) payable returns ( bool ) ;
function buy ( uint256 x , uint256 y , uint256 sizeA , uint256 sizeB , uint8 _v , bytes32 _r , bytes32 _s ) public notHalted ( ) payable { address recoveredSigner = verify ( keccak256 ( msg . sender ) , _v , _r , _s ) ; require ( signers [ recoveredSigner ] == true ) ; require ( msg . value > 0 ) ; internalBuy ( x , y , sizeA , sizeB ) ; }
function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
function finishSale ( ) external onlyIfSaleIsActive onlymanyowners ( keccak256 ( msg . data ) ) { require ( m_nextSale != address ( 0 ) ) ; m_active = false ; EthPriceDependent next = EthPriceDependent ( m_nextSale ) ; next . topUp . value ( this . balance ) ( ) ; m_token . transfer ( m_nextSale , m_token . balanceOf ( this ) ) ; m_token . switchToNextSale ( m_nextSale ) ; }
function convert ( uint _amount ) { if ( ! arcToken . transferFrom ( msg . sender , 0x0 , _amount ) ) { throw ; } if ( ! tokenContract . generateTokens ( msg . sender , _amount ) ) { throw ; } }
function announceCancel ( bytes32 _offerHash ) external { Offer memory offer = offers [ _offerHash ] ; require ( offer . maker == msg . sender , "Invalid sender" ) ; require ( offer . availableAmount > 0 , "Offer already cancelled" ) ; uint256 canCancelAt = now + cancelAnnounceDelay ; announcedCancellations [ _offerHash ] = canCancelAt ; emit CancelAnnounce ( offer . maker , _offerHash , canCancelAt ) ; }
function increaseApproval ( address _spender , uint _addedValue ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _addedValue ) ; emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }
function mintToken ( uint256 mintedAmount ) onlyOwner public { _balanceOf [ owner ] += mintedAmount ; _totalSupply += mintedAmount ; Transfer ( 0 , owner , mintedAmount ) ; }
function slowWithdraw ( address _withdrawer , address _token , uint256 _amount ) external { AnnouncedWithdrawal memory announcement = announcedWithdrawals [ _withdrawer ] [ _token ] ; require ( announcement . canWithdrawAt != 0 && announcement . canWithdrawAt <= now , "Insufficient delay" ) ; require ( announcement . amount == _amount , "Invalid amount" ) ; delete announcedWithdrawals [ _withdrawer ] [ _token ] ; _withdraw ( _withdrawer , _token , _amount , etherAddr , 0 ) ; }
function burn ( address _address , uint256 _value ) external onlyContract ( "FeeManager" ) returns ( bool ) { require ( _value <= balanceOf ( _address ) ) ; spentAct [ _address ] = spentAct [ _address ] . add ( _value ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; emit Burn ( _address , _value ) ; return true ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; require ( _index < _balanceOf ( _owner ) ) ; return _ownedTokens [ _owner ] [ _index ] ; }
function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = "Percentage" ; availableTags [ 1 ] = "Transfer Restriction" ; return availableTags ; }
function release ( ERC20Basic _token ) public { uint256 unreleased = releasableAmount ( _token ) ; require ( unreleased > 0 ) ; released [ _token ] = released [ _token ] . add ( unreleased ) ; _token . safeTransfer ( beneficiary , unreleased ) ; emit Released ( unreleased ) ; }
function allowIcoExit ( bool exitAllowed ) isOwner { require ( icoExitIsPossible != exitAllowed ) ; icoExitIsPossible = exitAllowed ; }
function claimPlot ( uint256 _deedId , uint256 _buyoutPrice ) external payable whenNotPaused { claimPlotWithData ( _deedId , _buyoutPrice , "" , "" , "" , "" ) ; }
function changeToken ( address token_ ) onlyOwner public { token = token_ ; }
function removeManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && admins [ account ] && account != owner ( ) ) { admins [ account ] = false ; emit AdminRemoved ( _accounts [ i ] ) ; } } return true ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = politicianIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function getTokenMinted ( ) public constant returns ( uint ) { return m_token . totalSupply ( ) ; }
function multiERC20TransferTightlyPacked ( ERC20 _token , bytes32 [ ] _addressesAndAmounts ) public { for ( uint i = 0 ; i < _addressesAndAmounts . length ; i ++ ) { address to = address ( _addressesAndAmounts [ i ] >> 96 ) ; uint amount = uint ( uint96 ( _addressesAndAmounts [ i ] ) ) ; _safeERC20Transfer ( _token , to , amount ) ; MultiERC20Transfer ( msg . sender , msg . value , to , amount , _token ) ; } }
function addHarvestOperationEndorsement ( string _mappingID , bool positive , string title , string description ) external returns ( bool success ) { harvestOperationEndorsements [ keccak256 ( _mappingID ) ] . push ( Endorsement ( positive , title , description , msg . sender ) ) ; return true ; }
function exchangeEtherForNomins ( ) public payable pricesNotStale notPaused returns ( uint ) { uint ethToSend ; uint requestedToPurchase = safeMul_dec ( msg . value , usdToEthPrice ) ; uint remainingToFulfill = requestedToPurchase ; for ( uint i = depositStartIndex ; remainingToFulfill > 0 && i < depositEndIndex ; i ++ ) { nominDeposit memory deposit = deposits [ i ] ; if ( deposit . user == address ( 0 ) ) { depositStartIndex = safeAdd ( depositStartIndex , 1 ) ; } else { if ( deposit . amount > remainingToFulfill ) { deposit . amount = safeSub ( deposit . amount , remainingToFulfill ) ; totalSellableDeposits = safeSub ( totalSellableDeposits , remainingToFulfill ) ; ethToSend = safeDiv_dec ( remainingToFulfill , usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } nomin . transfer ( msg . sender , remainingToFulfill ) ; remainingToFulfill = 0 ; } else if ( deposit . amount <= remainingToFulfill ) { delete deposits [ i ] ; depositStartIndex = safeAdd ( depositStartIndex , 1 ) ; totalSellableDeposits = safeSub ( totalSellableDeposits , deposit . amount ) ; ethToSend = safeDiv_dec ( deposit . amount , usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } nomin . transfer ( msg . sender , deposit . amount ) ; remainingToFulfill = safeSub ( remainingToFulfill , deposit . amount ) ; } } } if ( remainingToFulfill > 0 ) { msg . sender . transfer ( safeDiv_dec ( remainingToFulfill , usdToEthPrice ) ) ; } uint fulfilled = safeSub ( requestedToPurchase , remainingToFulfill ) ; if ( fulfilled > 0 ) { emit Exchange ( "ETH" , msg . value , "nUSD" , fulfilled ) ; } return fulfilled ; }
function approve ( address _spender , uint256 _value ) returns ( bool success ) { }
function generateTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupplyAt ( block . number ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOfAt ( _owner , block . number ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; emit Transfer ( 0 , _owner , _amount ) ; return true ; }
function approve ( address _spender , uint256 _value ) notPendingWithdrawal returns ( bool success ) { if ( balanceOf [ msg . sender ] < _value ) return false ; if ( ( _value != 0 ) && ( allowance [ msg . sender ] [ _spender ] != 0 ) ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function sellResources ( uint8 _type ) public onlyExistingUser returns ( uint256 ) { uint256 userId = addressToUser [ msg . sender ] ; uint256 sum = Math . min ( users [ userId ] . resources [ _type ] * getResourcePrice ( _type ) , address ( this ) . balance ) ; users [ userId ] . resources [ _type ] = 0 ; msg . sender . transfer ( sum ) ; emit Sell ( userId , _type , sum ) ; return sum ; }
function onTimeout ( uint256 ) internal { selfdestruct ( msg . sender ) ; }
function bountyFreeze ( address target , bool freeze ) internal { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }
function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < ( kitties . length - destroyKittyCount ) ) ; return _index ; }
function removeModule ( address _module ) external onlyOwner { require ( modulesToData [ _module ] . isArchived , "Not archived" ) ; require ( modulesToData [ _module ] . module != address ( 0 ) , "Module missing" ) ; emit ModuleRemoved ( modulesToData [ _module ] . moduleTypes , _module , now ) ; uint8 [ ] memory moduleTypes = modulesToData [ _module ] . moduleTypes ; for ( uint256 i = 0 ; i < moduleTypes . length ; i ++ ) { _removeModuleWithIndex ( moduleTypes [ i ] , modulesToData [ _module ] . moduleIndexes [ i ] ) ; } uint256 index = modulesToData [ _module ] . nameIndex ; bytes32 name = modulesToData [ _module ] . name ; uint256 length = names [ name ] . length ; names [ name ] [ index ] = names [ name ] [ length - 1 ] ; names [ name ] . length = length - 1 ; if ( ( length - 1 ) != index ) { modulesToData [ names [ name ] [ index ] ] . nameIndex = index ; } delete modulesToData [ _module ] ; }
function getHealBalance ( ) view public returns ( uint256 ) { return ethealController . ethealToken ( ) . balanceOf ( address ( this ) ) ; }
function upgrade ( uint256 value ) external { require ( upgradeAgentStatus ) ; require ( value > 0 && upgradeAgent . owner ( ) != 0x0 ) ; require ( value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }
function getDetails ( string _symbol ) public view returns ( address , uint256 , string , bytes32 , bool ) { string memory symbol = upper ( _symbol ) ; if ( registeredSymbols [ symbol ] . status == true || registeredSymbols [ symbol ] . timestamp . add ( expiryLimit ) > now ) { return ( registeredSymbols [ symbol ] . owner , registeredSymbols [ symbol ] . timestamp , registeredSymbols [ symbol ] . tokenName , registeredSymbols [ symbol ] . swarmHash , registeredSymbols [ symbol ] . status ) ; } else return ( address ( 0 ) , uint256 ( 0 ) , "" , bytes32 ( 0 ) , false ) ; }
function isCrowdsaleOpen ( ) public view returns ( bool ) { return address ( crowdsale ) != address ( 0 ) && ! crowdsale . hasEnded ( ) && crowdsale . hasStarted ( ) ; }
function ownershipLength ( ) public view returns ( uint256 ) { return ownership . length ; }
function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . transferControl ( msg . sender ) ; return newToken ; }
function getNextVestingIndex ( address account ) public view returns ( uint ) { uint len = numVestingEntries ( account ) ; for ( uint i = 0 ; i < len ; i ++ ) { if ( getVestingTime ( account , i ) != 0 ) { return i ; } } return len ; }
function computeHash ( string _key ) private pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _key ) ) ; }
function processProposal ( bytes32 _propID ) public { ParamProposal storage prop = proposals [ _propID ] ; address propOwner = prop . owner ; uint propDeposit = prop . deposit ; if ( canBeSet ( _propID ) ) { set ( prop . name , prop . value ) ; _ProposalAccepted ( _propID , prop . name , prop . value ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else if ( challengeCanBeResolved ( _propID ) ) { resolveChallenge ( _propID ) ; } else if ( now > prop . processBy ) { _ProposalExpired ( _propID ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else { revert ( ) ; } assert ( get ( "dispensationPct" ) <= 100 ) ; assert ( get ( "pDispensationPct" ) <= 100 ) ; now . add ( get ( "pApplyStageLen" ) ) . add ( get ( "pCommitStageLen" ) ) . add ( get ( "pRevealStageLen" ) ) . add ( PROCESSBY ) ; delete proposals [ _propID ] ; }
function createBoardHash ( bytes32 name , address admin ) pure public returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( name , admin ) ) ; }
function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; toRecord ( msg . sender , _to , _value ) ; return true ; }
function getTokenDetails ( uint64 _tokens ) private view returns ( TokenPair memory ) { ( address priorityAddress , uint8 priorityDecimals , bool priorityRegistered ) = renExTokensContract . tokens ( uint32 ( _tokens >> 32 ) ) ; ( address secondaryAddress , uint8 secondaryDecimals , bool secondaryRegistered ) = renExTokensContract . tokens ( uint32 ( _tokens ) ) ; return TokenPair ( { priorityToken : RenExTokens . TokenDetails ( priorityAddress , priorityDecimals , priorityRegistered ) , secondaryToken : RenExTokens . TokenDetails ( secondaryAddress , secondaryDecimals , secondaryRegistered ) } ) ; }
function createTemplate ( string content ) stateAny ( ) public returns ( uint256 ) { uint256 id = nextTemplateID ; templates [ id ] = block . number ; template_hashes [ id ] = keccak256 ( content ) ; LogNewTemplate ( id , msg . sender , content ) ; nextTemplateID = id . add ( 1 ) ; return id ; }
function burn ( uint256 _value ) public { uint256 senderBalance = dataStorage . balances ( msg . sender ) ; require ( senderBalance >= _value , 'Burn value less than account balance required.' ) ; senderBalance = senderBalance . sub ( _value ) ; dataStorage . setBalance ( msg . sender , senderBalance ) ; uint256 totalSupply = dataStorage . totalSupply ( ) ; totalSupply = totalSupply . sub ( _value ) ; dataStorage . setTotalSupply ( totalSupply ) ; emit Burn ( msg . sender , _value ) ; emit Transfer ( msg . sender , address ( 0 ) , _value ) ; }
function price ( ) public constant returns ( uint ) { if ( stage == Stages . AuctionEnded || stage == Stages . TokensDistributed ) { return finalPrice ; } return calcTokenPrice ( ) ; }
function setFundingStartTime ( uint _startTime ) external ;
function addTrustedContracts ( address [ ] _trusted_contracts ) isOwner public { for ( uint256 i = 0 ; i < _trusted_contracts . length ; i ++ ) { if ( addressHasCode ( _trusted_contracts [ i ] ) ) { trusted_contracts [ _trusted_contracts [ i ] ] = true ; TrustedContract ( _trusted_contracts [ i ] , true ) ; } } }
function totalIssuedSynths ( bytes4 currencyKey ) public view rateNotStale ( currencyKey ) returns ( uint ) { uint total = 0 ; uint currencyRate = exchangeRates . rateForCurrency ( currencyKey ) ; for ( uint8 i = 0 ; i < availableSynths . length ; i ++ ) { require ( ! exchangeRates . rateIsStale ( availableSynths [ i ] . currencyKey ( ) ) , "Rate is stale" ) ; uint synthValue = availableSynths [ i ] . totalSupply ( ) . multiplyDecimalRound ( exchangeRates . rateForCurrency ( availableSynths [ i ] . currencyKey ( ) ) ) . divideDecimalRound ( currencyRate ) ; total = total . add ( synthValue ) ; } return total ; }
function balanceOf ( address _owner ) public view returns ( uint256 _balance ) ;
function quoteBid ( ) public returns ( uint256 ) { if ( initialSaleComplete ) { bid = fracExp ( 1e18 , R , ( _totalSupply / 1e18 ) - 1 , P ) ; } else { bid = ICObid ; } return bid ; }
function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) ) ; ERC20Basic token = ERC20Basic ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( owner , balance ) ) ; }
function ( ) external payable { buyWithETH ( msg . sender ) ; }
function setGasLimit ( uint256 _gasLimit ) isAdminOrOwner public { gasLimit = _gasLimit ; }
function setSynthetixState ( SynthetixState _synthetixState ) external optionalProxy_onlyOwner { synthetixState = _synthetixState ; emitStateContractChanged ( _synthetixState ) ; }
function _releaseTo ( address target ) internal { uint256 unreleased = releasableAmount ( ) ; released = released . add ( unreleased ) ; token . safeTransfer ( target , unreleased ) ; Released ( released ) ; }
function transferFrom ( address from , address to , uint256 value ) returns ( bool ) { if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value && safeAdd ( balances [ to ] , value ) > balances [ to ] ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { throw ; } }
function callWithdraw ( ) onlyOwner public { realitycheck . withdraw ( ) ; }
function decreaseCap ( uint _value ) onlyAccountAddressForSponsee { if ( totalSupply > cap . sub ( _value ) ) { revert ( ) ; } cap = cap . sub ( _value ) ; LogDecreaseCap ( _value ) ; }
function balanceOf ( address _holder , bytes32 _symbol ) public view returns ( uint ) { return _balanceOf ( getHolderId ( _holder ) , _symbol ) ; }
function orderState ( bytes32 _orderID ) external view returns ( OrderState ) ;
function getCurrencyAddress ( ) external view returns ( address ) ;
function addToWhitelist ( address _address ) public onlyWhitelister { require ( _address != address ( 0 ) ) ; emit WhitelistAdd ( whitelister , _address ) ; whitelist [ _address ] = true ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = cityIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function getCard ( uint256 _tokenId ) public view returns ( string name , uint256 token ) { address owner = cardTokenToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; uint256 index = cardTokenToPosition [ _tokenId ] ; Card storage card = cards [ index ] ; name = card . name ; token = card . token ; }
function changeMedianier ( address _medianizer ) public onlyOwner { require ( _medianizer != address ( 0 ) , "0x not allowed" ) ; emit ChangeMedianizer ( _medianizer , medianizer , now ) ; medianizer = _medianizer ; }
function procPreSales ( ) payable public returns ( uint256 ) { require ( isPreSales == true ) ; uint256 amount = msg . value / buyPrice ; amount = amount * 10 ** uint256 ( decimals ) ; if ( balanceOf [ owner ] - amount <= limitAMT ) { isPreSales = false ; } _transfer ( owner , msg . sender , amount ) ; owner . transfer ( msg . value ) ; return amount ; }
function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , block . number ) ; if ( curTotalSupply + _amount < curTotalSupply ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; var previousBalanceTo = balanceOf ( _owner ) ; if ( previousBalanceTo + _amount < previousBalanceTo ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
function acceptAllOfficialOperators ( ) external { require ( mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] , "Official operators are already accepted by msg.sender." ) ; mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] = false ; emit OfficialOperatorsAcceptedByUser ( msg . sender ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; _transfer ( _from , _to , _value ) ; return true ; }
function transfer ( address _to , uint256 _tokenId ) external { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function getCoversForPacks ( uint [ ] _packIds ) public view returns ( bytes32 [ ] ) { require ( _packIds . length > 0 ) ; bytes32 [ ] memory covers = new bytes32 [ ] ( _packIds . length ) ; for ( uint i = 0 ; i < _packIds . length ; i ++ ) { AssetPack memory assetPack = assetPacks [ _packIds [ i ] ] ; covers [ i ] = assetPack . packCover ; } return covers ; }
function unfrozenTokens ( ) public onlyOwner whenNotPaused { require ( frozenSupply >= 0 ) ; if ( contributorsCurrentPeriod < CONTRIBUTORS_PERIODS ) { unfrozenContributorsTokens ( ) ; unfrozenCompanyTokens ( ) ; } else { unfrozenCompanyTokens ( ) ; } }
function completeMinting ( ) onlyOwner public { mintingDone = true ; }
function offer ( bytes _model , bytes _objective , address _token , uint256 _cost , address _validator , address _lighthouse , uint256 _lighthouse_fee , uint256 _deadline , bytes32 _nonce , bytes _signature ) external returns ( bool ) ;
function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; _balance [ msg . sender ] = _balance [ msg . sender ] . sub ( _value ) ; _balance [ _to ] = _balance [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function isOwner ( address _owner , bytes32 _symbol ) public view returns ( bool ) { return isCreated ( _symbol ) && ( _assetOwner ( _symbol ) == getHolderId ( _owner ) ) ; }
function createTemplateAndAskQuestion ( string content , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { uint256 template_id = createTemplate ( content ) ; return askQuestion ( template_id , question , arbitrator , timeout , opening_ts , nonce ) ; }
function getEscrowAndHash ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) view private returns ( Escrow , bytes32 ) { bytes32 _tradeHash = keccak256 ( abi . encodePacked ( _tradeID , _seller , _buyer , _value , _fee ) ) ; return ( escrows [ _tradeHash ] , _tradeHash ) ; }
function distributeICOTokens ( address _buyer , uint tokens ) external onlyCrowdsale whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( tokensDistributedCrowdsale < 50000000 ) ; tokensDistributedCrowdsale = tokensDistributedCrowdsale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
function symbol ( ) external view returns ( string _symbol ) { return _ERC721symbol ; }
function closeGame ( uint gameId , GameResults result ) external onlyOwner whenGameIsFrozen ( gameId ) { games [ gameId ] . state = GameStates . Closed ; games [ gameId ] . result = result ; emit GameHasClosed ( gameId , result ) ; }
function setPlotDataMultiple ( uint256 [ ] _deedIds , string name , string description , string imageUrl , string infoUrl ) external whenNotPaused { for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; } }
function currentResult ( ) external view returns ( uint32 [ NUMBER_OF_CHOICES ] ) { return currentVoteResults ; }
function setMigrationAgent ( address _agent ) external isUpgrading onlyOwner { require ( _agent != 0x00 ) ; agent = MigrationAgent ( _agent ) ; if ( ! agent . isMigrationAgent ( ) ) { revert ( ) ; } if ( agent . originalSupply ( ) != totalSupply ) { revert ( ) ; } }
function quoteAsk ( ) private returns ( uint256 ) { if ( initialSaleComplete ) { ask = fracExp ( 1e16 , R , ( _totalSupply / 1e16 ) + 1 , P ) ; } else { ask = ICOask ; } return ask ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external ;
function getNewRegistry ( ) public view returns ( address ) { return address ( params [ NEW_REGISTRY_KEC ] ) ; }
function invalidate ( address _account ) public onlyOwner { if ( hodlerStakes [ _account ] . stake > 0 && ! hodlerStakes [ _account ] . invalid ) { hodlerStakes [ _account ] . invalid = true ; hodlerTotalValue = hodlerTotalValue . sub ( hodlerStakes [ _account ] . stake ) ; hodlerTotalCount = hodlerTotalCount . sub ( 1 ) ; } updateAndGetHodlTotalValue ( ) ; }
function setActive ( bool _active ) onlyContractOwner external returns ( uint ) { if ( active == _active ) { return ; } active = _active ; return OK ; }
function getNumberInvestors ( ) public view returns ( uint256 ) ;
function updateCap ( uint256 _newCap ) public onlyOwner { require ( _newCap > weiRaised ) ; cap = _newCap ; }
function requestMortgageId ( Engine engine , uint256 loanId , uint256 deposit , uint256 landId , TokenConverter tokenConverter ) public returns ( uint256 id ) { require ( engine . getCurrency ( loanId ) == MANA_CURRENCY , "Loan currency is not MANA" ) ; address borrower = engine . getBorrower ( loanId ) ; require ( engine . getStatus ( loanId ) == Engine . Status . initial , "Loan status is not inital" ) ; require ( msg . sender == engine . getBorrower ( loanId ) || ( msg . sender == engine . getCreator ( loanId ) && creators [ msg . sender ] ) , "Creator should be borrower or authorized" ) ; require ( engine . isApproved ( loanId ) , "Loan is not approved" ) ; require ( rcn . allowance ( borrower , this ) >= REQUIRED_ALLOWANCE , "Manager cannot handle borrower's funds" ) ; require ( tokenConverter != address ( 0 ) , "Token converter not defined" ) ; require ( loanToLiability [ engine ] [ loanId ] == 0 , "Liability for loan already exists" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 loanAmount = engine . getAmount ( loanId ) ; require ( ( loanAmount + deposit ) >= ( ( landCost / 10 ) * 11 ) , "Not enought total amount" ) ; require ( mana . transferFrom ( msg . sender , this , deposit ) , "Error pulling mana" ) ; id = mortgages . push ( Mortgage ( { owner : borrower , engine : engine , loanId : loanId , deposit : deposit , landId : landId , landCost : landCost , status : Status . Pending , tokenConverter : tokenConverter } ) ) - 1 ; loanToLiability [ engine ] [ loanId ] = id ; emit RequestedMortgage ( { _id : id , _borrower : borrower , _engine : engine , _loanId : loanId , _landId : landId , _deposit : deposit , _tokenConverter : tokenConverter } ) ; }
function addHodlerStake ( address _beneficiary , uint256 _stake ) public onlyCrowdsale { hodlerReward . addHodlerStake ( _beneficiary , _stake ) ; }
function onERC721Received ( address _operator , address _from , uint _tokenId , bytes _data ) public returns ( bytes4 ) ;
function price ( ) public constant returns ( uint ) { if ( stage == Stages . AuctionEnded || stage == Stages . TokensDistributed ) { return 0 ; } return calcTokenPrice ( ) ; }
function ownerPauseContract ( ) external onlyOwner { require ( contractStarted ) ; require ( ! contractFinished ) ; require ( ! contractPaused ) ; contractPaused = true ; }
function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner canMint { requireMultiple ( _amount ) ; mTotalSupply = mTotalSupply . add ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , "" , _operatorData , false ) ; emit Minted ( msg . sender , _tokenHolder , _amount , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( 0x0 , _tokenHolder , _amount ) ; } }
function decBalance ( address _acct , uint _val ) public onlyModule returns ( bool ) { balances [ _acct ] = balances [ _acct ] . sub ( _val ) ; emit BalanceAdj ( msg . sender , _acct , _val , "-" ) ; return true ; }
function unlockPrivate ( ) public locked onlyOwner { require ( block . timestamp >= privateReleaseTime ) ; require ( privateLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= privateLockedAmount ) ; token . transfer ( privateLockAddress , privateLockedAmount ) ; privateLockedAmount = 0 ; }
function getRegistry ( ) external view returns ( address ) ;
function getOrdersForSeller ( address seller ) public view validAddress ( seller ) returns ( address [ ] ) { return ordersBySeller [ seller ] ; }
function transferToAddress ( address _to , uint256 _value ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function name ( ) public pure returns ( string ) { return "Pirate Kitty Token" ; }
function changeOwner ( address _owner ) external onlyOwner { require ( _owner != address ( 0 ) && _owner != owner ) ; owner = _owner ; ChangeOwner ( owner ) ; }
function performTrade ( Trade trade , TradeFlag tradeFlag , CurrentAmounts amounts ) internal { for ( uint256 j ; j < trade . orders . length ; j ++ ) { if ( amounts . amountReceivedFromTrade >= trade . minimumAcceptableTokenAmount ) { return ; } if ( tradeFlag . ignoreOrder [ j ] || amounts . amountLeftToSpendOnTrade == 0 ) { continue ; } uint256 amountSpentOnOrder = 0 ; uint256 amountReceivedFromOrder = 0 ; Order memory thisOrder = trade . orders [ j ] ; ExchangeHandler thisHandler = ExchangeHandler ( thisOrder . exchangeHandler ) ; uint256 amountToGiveForOrder = Utils . min ( thisHandler . getAmountToGive ( thisOrder . genericPayload ) , amounts . amountLeftToSpendOnTrade ) ; if ( amountToGiveForOrder == 0 ) { continue ; } if ( ! thisHandler . staticExchangeChecks ( thisOrder . genericPayload ) ) { continue ; } if ( trade . isSell ) { if ( ! ERC20SafeTransfer . safeTransfer ( trade . tokenAddress , address ( thisHandler ) , amountToGiveForOrder ) ) { if ( ! trade . optionalTrade ) errorReporter . revertTx ( "Unable to transfer tokens to handler" ) ; else { return ; } } ( amountSpentOnOrder , amountReceivedFromOrder ) = thisHandler . performSellOrder ( thisOrder . genericPayload , amountToGiveForOrder ) ; } else { ( amountSpentOnOrder , amountReceivedFromOrder ) = thisHandler . performBuyOrder . value ( amountToGiveForOrder ) ( thisOrder . genericPayload , amountToGiveForOrder ) ; } if ( amountReceivedFromOrder > 0 ) { amounts . amountLeftToSpendOnTrade = SafeMath . sub ( amounts . amountLeftToSpendOnTrade , amountSpentOnOrder ) ; amounts . amountSpentOnTrade = SafeMath . add ( amounts . amountSpentOnTrade , amountSpentOnOrder ) ; amounts . amountReceivedFromTrade = SafeMath . add ( amounts . amountReceivedFromTrade , amountReceivedFromOrder ) ; } } }
function remainingFundsToEndAuction ( ) constant public returns ( uint256 ) { uint256 required_wei_at_price = num_tokens_auctioned * price ( ) / token_multiplier ; if ( required_wei_at_price <= received_wei ) { return 0 ; } return required_wei_at_price - received_wei ; }
function rentOutArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint rentPricePerPeriodWei ) external whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; uint id = rentals . rentOutBlocks ( msg . sender , rentPricePerPeriodWei , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogRentsOut ( id , fromX , fromY , toX , toY , rentPricePerPeriodWei ) ; }
function withdrawAccumulatedFees ( address _to ) external onlyOwner { uint256 transferAmount = accumulatedGasFees ; accumulatedGasFees = 0 ; _to . transfer ( transferAmount ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) external requireThaw userNotPlaying ( _to ) { require ( cooldown [ _from ] [ _to ] <= now ) ; var _allowance = allowed [ _from ] [ _to ] ; if ( _from == selfAddress ) { monthlyLimit [ _to ] = safeSub ( monthlyLimit [ _to ] , _value ) ; } balances [ _to ] = balances [ _to ] + _value ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; allowed [ _from ] [ _to ] = safeSub ( _allowance , _value ) ; addUser ( _to ) ; bytes memory empty ; Transfer ( _from , _to , _value , empty ) ; }
function transferOwnershipToProject ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { Pledge storage p = findPledge ( idPledge ) ; require ( getPledgeLevel ( p ) < MAX_INTERPROJECT_LEVEL ) ; require ( ! isProjectCanceled ( idReceiver ) ) ; uint64 oldPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; uint64 toPledge = findOrCreatePledge ( idReceiver , new uint64 [ ] ( 0 ) , 0 , 0 , oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }
function ( ) public payable { require ( contractPoweredUp ) ; require ( now >= PRESALE_START_DATE ) ; require ( now < PRESALE_END_DATE ) ; require ( msg . value >= MINIMUM_PARTICIPATION_AMOUNT ) ; if ( now >= PRESALE_START_DATE && now < PRESALE_SECOND_DAY_START ) { require ( whitelist [ msg . sender ] == msg . value ) ; require ( balanceOf [ msg . sender ] == 0 ) ; } else if ( now >= PRESALE_SECOND_DAY_START && now < PRESALE_THIRD_DAY_START ) { require ( whitelist [ msg . sender ] != 0 ) ; } require ( totalFunding . add ( msg . value ) <= PRESALE_MAXIMUM_FUNDING ) ; addBalance ( msg . sender , msg . value ) ; grantCreditsForParticipation ( msg . sender , msg . value ) ; }
function getAthlete ( uint256 _tokenId ) public view returns ( string athleteName , uint256 sellingPrice , address owner ) { Athlete storage athlete = athletes [ _tokenId ] ; athleteName = athlete . name ; sellingPrice = athleteIndexToPrice [ _tokenId ] ; owner = athleteIndexToOwner [ _tokenId ] ; }
function burn ( uint256 _value ) onlyOwner public returns ( bool success ) { burnFrom ( _owner , _value ) ; return true ; }
function setNewCFO ( address newCFO ) public onlyOwner { require ( newCFO != 0 ) ; CFO = newCFO ; }
function batchCreateAccount ( address [ ] _newUsers ) public onlyRegistryAdmin { for ( uint256 i = 0 ; i < _newUsers . length ; i ++ ) { if ( registry . addressBelongsToAccount ( _newUsers [ i ] ) ) { emit addressSkipped ( _newUsers [ i ] ) ; } else { logic . createAccount ( _newUsers [ i ] ) ; } } }
function transfer ( address _to , uint256 _tokenId ) external { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; require ( pixelIndexToApproved [ _tokenId ] != address ( this ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function generateSecurityToken ( string _name , string _symbol , string _tokenDetails , bool _divisible ) public ;
function attestFor ( address _subject , address _attester , address _requester , uint256 _reward , bytes _requesterSig , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig , bytes _delegationSig ) external { validateAttestForSig ( _subject , _attester , _requester , _reward , _dataHash , _requestNonce , _delegationSig ) ; attestForUser ( _subject , _attester , _requester , _reward , _requesterSig , _dataHash , _requestNonce , _subjectSig ) ; }
function decreaseApproval ( address _spender , uint _subtractedValue ) public returns ( bool success ) { uint oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }
function multiBatchSafeTransferFrom ( uint256 [ ] _tokenIds , address [ ] _fromB , address [ ] _toB ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _fromB . length > 0 && _toB . length > 0 ) ; uint256 _id ; address _to ; address _from ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 && _fromB [ i ] != 0 && _toB [ i ] != 0 ) ; _id = _tokenIds [ i ] ; _to = _toB [ i ] ; _from = _fromB [ i ] ; safeTransferFrom ( _from , _to , _id ) ; } }
function state ( ) public constant returns ( string ) { return stateNames [ uint ( currentState ( ) ) ] ; }
function updatePolyTokenAddress ( address _newAddress ) external ;
function sell ( uint256 amount ) public { require ( this . balance >= amount * sellPrice / ( uint256 ( 10 ) ** decimals ) ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice / ( uint256 ( 10 ) ** decimals ) ) ; }
function getHistoryHash ( bytes32 question_id ) public view returns ( bytes32 ) { }
function claim ( address _arbitrator , uint256 _transactionId ) public { Lock memory lock = escrows [ _arbitrator ] [ _transactionId ] ; require ( lock . sender == msg . sender ) ; require ( lock . paid ) ; require ( lock . expiration < block . timestamp ) ; require ( lock . expiration != 0 ) ; delete escrows [ _arbitrator ] [ _transactionId ] ; token . transfer ( msg . sender , lock . value . add ( lock . fee ) ) ; Released ( _arbitrator , msg . sender , _transactionId ) ; }
function drain ( ) public onlyOwner { for ( uint256 index = 0 ; index < membersArray . length ; index ++ ) { address memberAddress = membersArray [ index ] ; bool memberJoined = members [ memberAddress ] . stakeTimestamp != 0 ; uint256 amountRefunded = memberJoined ? refundUserBalance ( memberAddress ) : 0 ; delete registeredInvitationCodes [ members [ memberAddress ] . invitationCode ] ; delete members [ memberAddress ] ; emit MemberDrained ( memberAddress , amountRefunded ) ; } delete membersArray ; require ( ixtToken . transfer ( msg . sender , totalPoolBalance ) , "Unable to withdraw this value of IXT." ) ; totalPoolBalance = 0 ; emit PoolDrained ( msg . sender , totalPoolBalance ) ; emit ContractDrained ( msg . sender ) ; }
function emergencyClawbackEther ( uint256 value ) external onlyOwnerOrMultisig { require ( contractFailed ) ; require ( contractRefundStarted ) ; require ( contractRefundFinished ) ; require ( value > 0 ) ; require ( value <= address ( this ) . balance ) ; msg . sender . transfer ( value ) ; }
function _changeTokenAddress ( address _tokenAddress ) internal { require ( _tokenAddress != address ( 0 ) ) ; address oldAddress = fidaTokenAddress ; fidaTokenAddress = _tokenAddress ; fidaToken = ERC20Basic ( _tokenAddress ) ; mintableFida = MintableTokenInterface ( _tokenAddress ) ; emit TokenAddressChanged ( oldAddress , _tokenAddress ) ; }
function verifyMatchDetails ( OrderDetails memory _buy , OrderDetails memory _sell ) internal pure returns ( bool ) { if ( ! verifyTokens ( _buy . tokens , _sell . tokens ) ) { return false ; } if ( _buy . price < _sell . price ) { return false ; } if ( _buy . volume < _sell . minimumVolume ) { return false ; } if ( _sell . volume < _buy . minimumVolume ) { return false ; } if ( _buy . settlementID != _sell . settlementID ) { return false ; } return true ; }
function followTrader ( bytes _signature , address _trader , bytes32 _strategyID , uint256 _marginAmount , address _oracle , uint256 _validUntil ) public returns ( bool ) { require ( block . number <= _validUntil ) ; require ( followTraderSignatures [ _signature ] == false ) ; require ( traderProfile [ _trader ] [ _strategyID ] != address ( 0 ) ) ; TradeProfile profile = TradeProfile ( traderProfile [ _trader ] [ _strategyID ] ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( followTraderPreSignedHashing ( address ( this ) , _trader , _strategyID , _marginAmount , _oracle , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; marginBalances [ from ] = marginBalances [ from ] . sub ( _marginAmount ) ; require ( profile . follow ( from , _marginAmount , _oracle ) ) ; followTraderSignatures [ _signature ] = true ; emit FollowTrader ( from , _trader , _marginAmount ) ; return true ; }
function getContentByKeyIndex ( ContentMapping storage self , uint _index ) public view returns ( Content storage _content ) { isValidIndex ( _index , self . keys . length ) ; return ( self . data [ self . keys [ _index ] ] ) ; }
function changeLockPeriod ( uint256 periodInDays ) external onlyOwner { require ( periodInDays <= 30 && periodInDays >= 1 ) ; lockPeriod = periodInDays * 1 days ; }
function getBorrowBalance ( address account , address asset ) view public returns ( uint ) { Error err ; uint newBorrowIndex ; uint userBorrowCurrent ; Market storage market = markets [ asset ] ; Balance storage borrowBalance = borrowBalances [ account ] [ asset ] ; ( err , newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; require ( err == Error . NO_ERROR ) ; ( err , userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , newBorrowIndex ) ; require ( err == Error . NO_ERROR ) ; return userBorrowCurrent ; }
function _transferFrom_byProxy ( address sender , address from , address to , uint value ) internal returns ( bool ) { uint received = amountReceived ( value ) ; uint fee = safeSub ( value , received ) ; tokenState . setAllowance ( from , sender , safeSub ( tokenState . allowance ( from , sender ) , value ) ) ; return _internalTransfer ( from , to , received , fee ) ; }
function updateDetails ( bytes32 _details ) public returns ( bool allowed ) ;
function assingAdminship ( address _newAdmin , uint8 _level ) onlyAdmin ( 2 ) public { admin [ _newAdmin ] = _level ; emit AssignAdminship ( _newAdmin , _level ) ; }
function bid ( ) external payable { require ( block . number < _auctionEnd ) ; uint proposedBid = _bidders [ msg . sender ] . value . add ( msg . value ) ; require ( proposedBid > _lowestBid ) ; uint startPos = 99 ; if ( _bidders [ msg . sender ] . value >= _lowestBid ) { for ( uint i = 99 ; i < 100 ; -- i ) { if ( _topBids [ i ] . bidderAddress == msg . sender ) { startPos = i ; break ; } } } uint endPos ; for ( uint j = startPos ; j < 100 ; -- j ) { if ( j != 0 && proposedBid > _topBids [ j - 1 ] . bid ) { _topBids [ j ] = _topBids [ j - 1 ] ; } else { _topBids [ j ] . bid = proposedBid ; _topBids [ j ] . bidderAddress = msg . sender ; endPos = j ; break ; } } _bidders [ msg . sender ] . value = proposedBid ; _bidders [ msg . sender ] . lastTime = now ; _lowestBid = _topBids [ 99 ] . bid ; if ( endPos < 3 ) { TopThreeChanged ( _topBids [ 0 ] . bidderAddress , _topBids [ 0 ] . bid , _topBids [ 1 ] . bidderAddress , _topBids [ 1 ] . bid , _topBids [ 2 ] . bidderAddress , _topBids [ 2 ] . bid ) ; } NewBid ( msg . sender , _bidders [ msg . sender ] . value ) ; }
function addNetworkMember ( address _member , bool _isIRNAdmin , bool _isManufacturer , bool _isIRNNode , bytes32 _memberId ) public onlyIRNorOwner returns ( bool ) { NetworkMember storage m = network [ _member ] ; require ( ! m . isIRNAdmin , "already an irn admin" ) ; require ( ! m . isManufacturer , "already a manufacturer" ) ; require ( ! m . isIRNNode , "already an irn node" ) ; require ( m . memberId == 0 , "already assigned a member id" ) ; m . isIRNAdmin = _isIRNAdmin ; m . isManufacturer = _isManufacturer ; m . isIRNNode = _isIRNNode ; m . memberId = _memberId ; if ( m . isManufacturer ) { require ( _memberId != 0 , "manufacturer id is required" ) ; require ( manufacturerRewards [ m . memberId ] == address ( 0 ) , "manufacturer is already assigned" ) ; manufacturerRewards [ m . memberId ] = _member ; if ( pools [ _member ] . rewardAmount == 0 ) { pools [ _member ] . rewardAmount = settings . defaultReputationReward ( ) ; } } emit NetworkMemberAdded ( msg . sender , _member , _memberId ) ; return true ; }
function forwardFunds ( uint256 amountPaid ) internal whenNotPaused { if ( goalReached ( ) ) { wallet . transfer ( amountPaid ) ; } else { vault . deposit . value ( amountPaid ) ( msg . sender ) ; } checkCompletedCrowdsale ( ) ; }
function setExchangeRate ( IERC223Token numeratorToken , IERC223Token denominatorToken , uint256 rateFraction ) public only ( ROLE_TOKEN_RATE_ORACLE ) { setExchangeRatePrivate ( numeratorToken , denominatorToken , rateFraction ) ; }
function createChamp ( address _affiliateAddress ) external payable whenNotPaused isPaid ( createChampFee ) distributeInput ( _affiliateAddress ) { uint256 id = champs . push ( Champ ( 0 , 2 + randMod ( 4 ) , 1 + randMod ( 4 ) , uint256 ( 1 days ) - uint256 ( randMod ( 9 ) * 1 hours ) , 0 , 0 , 0 , leaderboard . length + 1 , 0 , uint256 ( block . timestamp ) , 0 , 0 , 0 , false ) ) - 1 ; champs [ id ] . id = id ; leaderboard . push ( id ) ; champToOwner [ id ] = msg . sender ; addressInfo [ msg . sender ] . champsCount ++ ; emit NewChamp ( id , msg . sender ) ; }
function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; require ( beneficiary . send ( this . balance ) ) ; tokenReward . transfer ( beneficiary , remanent ) ; LogBeneficiaryPaid ( beneficiary ) ; LogContributorsPayout ( beneficiary , remanent ) ; }
function split ( address boardOwner , uint _amount ) internal returns ( bool ) { emit Withdrawal ( owner , _amount / 2 ) ; owner . transfer ( _amount / 2 ) ; boardOwner . transfer ( _amount / 2 ) ; return true ; }
function addValidatorApproval ( address validator , uint256 attributeTypeID ) external ;
function addressBelongsToAccount ( address _address ) public view returns ( bool ) { return accountByAddress [ _address ] > 0 ; }
function transfer ( address _to , uint256 _value ) public notFrozen returns ( bool success ) { require ( tradable ) ; if ( balances [ msg . sender ] >= _value && _value > 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }
function setBlacklistedUser ( address _who ) public onlyValidator { _setBlacklistedUser ( _who ) ; }
function existsPriceOnAssetPair ( address sellAsset , address buyAsset ) view returns ( bool isExistent ) { return hasRecentPrice ( sellAsset ) && hasRecentPrice ( buyAsset ) && ( buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET ) && ( buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET ) ; }
function bid ( ) public payable auctionNotEnded isMinimumBid isHighestBid { if ( highestBidder != address ( 0 ) ) { uint lastBid = bids [ highestBidder ] ; bids [ highestBidder ] = 0 ; if ( ! highestBidder . send ( lastBid ) ) { emit CheaterBidder ( highestBidder , lastBid ) ; } } highestBidder = msg . sender ; bids [ msg . sender ] = msg . value ; auctionState = AuctionStates . Ongoing ; emit HighestBidIncreased ( msg . sender , msg . value ) ; }
function getContract ( string _contractName ) external view returns ( address _contractAddress ) ;
function addEmissionProvider ( address _provider , uint _block ) public returns ( uint _code ) { if ( emissionProviders [ _provider ] ) { return SERVICE_CONTROLLER_EMISSION_EXIST ; } _code = _multisig ( keccak256 ( _provider ) , _block ) ; if ( OK != _code ) { return _code ; } emissionProviders [ _provider ] = true ; return OK ; }
function createGrant ( address _beneficiary , uint256 _start , uint256 _amount , bool _revocable , bool _advisor ) public onlyOwner { require ( _beneficiary != address ( 0 ) && _amount > 0 && _start >= now ) ; if ( _advisor ) { tokenGrants . push ( new TokenVesting ( _beneficiary , _start , VESTING_ADVISOR_CLIFF , VESTING_ADVISOR_DURATION , _revocable ) ) ; } else { tokenGrants . push ( new TokenVesting ( _beneficiary , _start , VESTING_TEAM_CLIFF , VESTING_TEAM_DURATION , _revocable ) ) ; } transferToGrant ( tokenGrants . length . sub ( 1 ) , _amount ) ; }
function proxy_contribution ( address _toAddr ) public payable { require ( _toAddr != 0x0 ) ; require ( msg . sender == tx . origin ) ; process_contribution ( _toAddr ) ; }
function approveKYC ( address account , bool isApproved , uint limit , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setKYCApproval ( account , isApproved , issuerFirm ) , "Error: Unable to approve account. Please check issuerFirm and firm authority are registered" ) ; require ( lib . setAccountStatus ( account , isApproved , issuerFirm ) , "Error: Unable to set account status. Please check issuerFirm and firm authority are registered" ) ; require ( lib . setAccountSpendingLimit ( account , limit ) , "Error: Unable to set initial spending limit for account. Please check issuerFirm and firm authority are registered" ) ; require ( lib . setAccountSpendingPeriod ( account , ( now + 86400 ) ) , "Error: Unable to set spending period for account. Please check issuerFirm and firm authority are registered" ) ; return true ; }
function triggerShutdown ( uint ofVersionId ) { trigger ( versionIdToShutdownIds [ ofVersionId ] ) ; shutDownVersion ( ofVersionId ) ; }
function getPledge ( uint64 idPledge ) constant returns ( uint amount , uint64 owner , uint64 nDelegates , uint64 intendedProject , uint64 commitTime , uint64 oldPledge , PledgeState pledgeState ) { Pledge storage p = findPledge ( idPledge ) ; amount = p . amount ; owner = p . owner ; nDelegates = uint64 ( p . delegationChain . length ) ; intendedProject = p . intendedProject ; commitTime = p . commitTime ; oldPledge = p . oldPledge ; pledgeState = p . pledgeState ; }
function acceptOwnership ( ) { if ( msg . sender == newOwner ) { owner = newOwner ; } }
function fundAnswerBounty ( bytes32 question_id ) stateOpen ( question_id ) external payable { questions [ question_id ] . bounty = questions [ question_id ] . bounty . add ( msg . value ) ; LogFundAnswerBounty ( question_id , msg . value , questions [ question_id ] . bounty , msg . sender ) ; }
function getCampaignEndDateById ( bytes32 bidId ) public view returns ( uint endDate ) { return campaigns [ bidId ] . getEndDate ( ) ; }
function getDeedTimestamp ( string document ) public constant returns ( uint256 ) { uint256 documentHash = uint256 ( keccak256 ( document ) ) ; uint256 timestamp = documentRegistry [ documentHash ] ; require ( timestamp > 0 ) ; return timestamp ; }
function freezeTransfers ( ) external ;
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ( _value == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function onApprove ( address _owner , address _spender , uint _amount ) returns ( bool success ) { if ( _owner == vaultAddress ) { return true ; } return false ; }
function updateCounters ( uint256 _etherAmount ) internal { etherPaid = etherPaid . add ( _etherAmount ) ; totalContributions = totalContributions . add ( 1 ) ; CountersUpdated ( etherPaid , _etherAmount ) ; }
function granularity ( ) external view returns ( uint256 ) ;
function _storeSecurityTokenData ( address _securityToken , string _ticker , string _tokenDetails , uint256 _deployedAt ) internal { set ( Encoder . getKey ( "securityTokens_ticker" , _securityToken ) , _ticker ) ; set ( Encoder . getKey ( "securityTokens_tokenDetails" , _securityToken ) , _tokenDetails ) ; set ( Encoder . getKey ( "securityTokens_deployedAt" , _securityToken ) , _deployedAt ) ; }
function endAuction ( ) public onlyOwner { require ( status == state . active ) ; status = state . ended ; emit Ended ( block . number ) ; }
function rentOut ( address _to , uint256 _rentPeriod , uint256 _deedId ) external whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; rentOutMultiple ( _to , _rentPeriod , _deedIds ) ; }
function calculateHash ( uint256 _limit , uint256 _slopeFactor , uint256 _collectMinimum , bool _last , bytes32 _salt ) public constant returns ( bytes32 ) { return keccak256 ( _limit , _slopeFactor , _collectMinimum , _last , _salt ) ; }
function getInvestorsAt ( uint256 _checkpointId ) external view returns ( address [ ] ) ;
function createInitialTokens ( address _holder , uint _quantity ) ;
function registerTradeProfile ( bytes _registerSignature , bytes32 _strategyID , uint256 _registerFee , uint256 _periodLength , uint256 _maxMarginDeposit , uint256 _minMarginDeposit , uint256 _rewardPercentage , uint256 _nonce , bytes _transferSignature , uint256 _validUntil ) public returns ( bool ) { require ( msg . sender == bincentive ) ; require ( registerSignatures [ _registerSignature ] == false ) ; require ( transferSignatures [ _transferSignature ] == false || _transferSignature . length == 0 ) ; LocalVariableGrouping memory localVariables ; localVariables . hashedTx = ECRecovery . toEthSignedMessageHash ( registerPreSignedHashing ( address ( this ) , _strategyID , _registerFee , _periodLength , _maxMarginDeposit , _minMarginDeposit , _rewardPercentage , _nonce ) ) ; localVariables . from = ECRecovery . recover ( localVariables . hashedTx , _registerSignature ) ; require ( traderProfile [ localVariables . from ] [ _strategyID ] == address ( 0 ) ) ; if ( _registerFee > 0 ) { localVariables . tokenContract = BCNTToken ( tokenAddress ) ; localVariables . hashedTx = ECRecovery . toEthSignedMessageHash ( localVariables . tokenContract . transferPreSignedHashing ( tokenAddress , address ( this ) , _registerFee , 0 , _nonce , _validUntil ) ) ; require ( ECRecovery . recover ( localVariables . hashedTx , _transferSignature ) == localVariables . from ) ; require ( localVariables . tokenContract . transferPreSigned ( _transferSignature , address ( this ) , _registerFee , 0 , _nonce , _validUntil ) ) ; } localVariables . profileAddr = new TradeProfileProxy ( tradeProfileImplementation , abi . encodeWithSignature ( "init(address,uint256,uint256,uint256,uint256)" , localVariables . from , _periodLength , _maxMarginDeposit , _minMarginDeposit , _rewardPercentage ) ) ; localVariables . profile = TradeProfile ( localVariables . profileAddr ) ; traderProfile [ localVariables . from ] [ _strategyID ] = localVariables . profile ; registerSignatures [ _registerSignature ] = true ; transferSignatures [ _transferSignature ] = true ; emit RegisterTradeProfile ( localVariables . from , localVariables . profile ) ; return true ; }
function setBeneficiary ( address _beneficiary ) onlyOwner public { beneficiary = _beneficiary ; }
function deedUri ( uint256 _deedId ) external view returns ( string _uri ) ;
function getMatchDetails ( bytes32 _orderID ) external view returns ( bool settled , bool orderIsBuy , bytes32 matchedID , uint256 priorityVolume , uint256 secondaryVolume , uint256 priorityFee , uint256 secondaryFee , uint32 priorityToken , uint32 secondaryToken ) { matchedID = orderbookContract . orderMatch ( _orderID ) ; orderIsBuy = isBuyOrder ( _orderID ) ; ( bytes32 buyID , bytes32 sellID ) = orderIsBuy ? ( _orderID , matchedID ) : ( matchedID , _orderID ) ; SettlementDetails memory settlementDetails = calculateSettlementDetails ( buyID , sellID , getTokenDetails ( orderDetails [ buyID ] . tokens ) ) ; return ( orderStatus [ _orderID ] == OrderStatus . Settled || orderStatus [ _orderID ] == OrderStatus . Slashed , orderIsBuy , matchedID , settlementDetails . leftVolume , settlementDetails . rightVolume , settlementDetails . leftTokenFee , settlementDetails . rightTokenFee , uint32 ( orderDetails [ buyID ] . tokens >> 32 ) , uint32 ( orderDetails [ buyID ] . tokens ) ) ; }
function unpause ( ) public onlyMEGO whenPaused { paused = false ; }
function burn ( uint256 _amount ) userNotBlacklisted ( msg . sender ) public whenNotPaused { _burn ( msg . sender , _amount ) ; }
function remainingTokens ( ) public view returns ( uint256 ) { return balances [ address ( 0 ) ] ; }
function removeAdmin ( address _admin ) public onlyOwner { admins [ _admin ] = false ; }
function honourWhitelist ( ) private returns ( bool ) { bool honourWhitelist = true ; if ( honourWhitelistEnd <= now ) { honourWhitelist = false ; preSaleCap = preSaleCap . add ( whitelistedPlannedContributions ) ; whitelistedPlannedContributions = 0 ; WhitelistedCounterUpdated ( whitelistedPlannedContributions , 0 ) ; } return honourWhitelist ; }
function transfer ( address _to , uint256 _value , bytes _data ) public onlyIfLockTimePassed returns ( bool ) { require ( transfer ( _to , _value ) ) ; uint codeLength ; assembly { codeLength := extcodesize ( _to ) } if ( codeLength > 0 ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } return true ; }
function buyAssetPack ( address _to , uint _assetPackId ) public payable { require ( ! checkHasPermissionForPack ( _to , _assetPackId ) ) ; AssetPack memory assetPack = assetPacks [ _assetPackId ] ; require ( msg . value >= assetPack . price ) ; artistBalance [ assetPack . creator ] += msg . value * 95 / 100 ; artistBalance [ owner ] += msg . value * 5 / 100 ; boughtAssetPacks [ _to ] . push ( _assetPackId ) ; hasPermission [ _to ] [ _assetPackId ] = true ; emit AssetPackBought ( _assetPackId , _to ) ; }
function giveMeToken ( DSToken token ) public auth { token . transfer ( msg . sender , token . balanceOf ( this ) ) ; }
function price ( ) public view returns ( uint256 _price ) { if ( block . timestamp <= start . add ( BONUS_DURATION_1 ) ) { return tokenPerEth . mul ( BONUS_TIER1 ) . div ( 1e2 ) ; } else if ( block . timestamp <= start . add ( BONUS_DURATION_2 ) ) { return tokenPerEth . mul ( BONUS_TIER2 ) . div ( 1e2 ) ; } else if ( block . timestamp <= start . add ( BONUS_DURATION_3 ) ) { return tokenPerEth . mul ( BONUS_TIER3 ) . div ( 1e2 ) ; } return tokenPerEth ; }
function setReleaseDate ( uint256 _releaseDate ) external onlyAdmin whenNotPaused { require ( releaseDate == 0 ) ; require ( _releaseDate > now ) ; releaseDate = _releaseDate ; emit BonusReleaseDateSet ( _releaseDate ) ; }
function implementsERC165InterfaceNoCache ( address _contract , bytes4 _interfaceId ) public view returns ( bool ) { uint256 success ; uint256 result ; ( success , result ) = noThrowCall ( _contract , ERC165ID ) ; if ( success == 0 || result == 0 ) { return false ; } ( success , result ) = noThrowCall ( _contract , INVALID_ID ) ; if ( success == 0 || result != 0 ) { return false ; } ( success , result ) = noThrowCall ( _contract , _interfaceId ) ; if ( success == 1 && result == 1 ) { return true ; } return false ; }
function addManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && ! admins [ account ] && account != owner ) { admins [ account ] = true ; emit AdminAdded ( _accounts [ i ] ) ; } } return true ; }
function burn ( uint256 _amount , bytes _holderData ) public onlyOwner { super . burn ( _amount , _holderData ) ; }
function preICO ( address _beneficiary , uint256 _amount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , "Buyer is not whitelisted" ) ; uint256 amount = _amount . mul ( E18 ) ; require ( totalSupply_ . add ( amount ) <= TOTAL_SUPPLY_LIMIT ) ; uint256 remainingTokens = TOTAL_SUPPLY_LIMIT . sub ( totalSupply_ ) ; require ( amount <= remainingTokens ) ; preICOTokenIssuedTotal = preICOTokenIssuedTotal . add ( amount ) ; super . mint ( _beneficiary , amount ) ; emit Transfer ( address ( PREICO_EVENT ) , _beneficiary , amount ) ; }
function getTokenBalance ( Data storage self , string currency , address account ) internal view returns ( uint balance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getUint ( id ) ; }
function forgeItems ( uint256 _parentItemID , uint256 _childItemID ) external onlyOwnerOfItem ( _parentItemID ) onlyOwnerOfItem ( _childItemID ) ifItemForSaleThenCancelSale ( _parentItemID ) ifItemForSaleThenCancelSale ( _childItemID ) { require ( _parentItemID != _childItemID ) ; Item storage parentItem = items [ _parentItemID ] ; Item storage childItem = items [ _childItemID ] ; if ( childItem . onChamp ) { takeOffItem ( childItem . onChampId , childItem . itemType ) ; } parentItem . attackPower = ( parentItem . attackPower > childItem . attackPower ) ? parentItem . attackPower : childItem . attackPower ; parentItem . defencePower = ( parentItem . defencePower > childItem . defencePower ) ? parentItem . defencePower : childItem . defencePower ; parentItem . cooldownReduction = ( parentItem . cooldownReduction > childItem . cooldownReduction ) ? parentItem . cooldownReduction : childItem . cooldownReduction ; parentItem . itemRarity = uint8 ( 6 ) ; transferItem ( msg . sender , address ( 0 ) , _childItemID ) ; emit Forge ( _parentItemID ) ; }
function destroyBeneficiary ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; token . transfer ( owner , balance ) ; totalReleased = totalReleased . add ( balance ) ; beneficiary . isBeneficiary = false ; beneficiary . released = beneficiary . released . add ( balance ) ; BeneficiaryDestroyed ( _beneficiary ) ; }
function finalizeInvestorsByList ( address [ ] investors ) public onlyOwner mustBeAtStage ( Stage . Finished ) { for ( uint256 i = 0 ; i < investors . length ; i ++ ) { finalizeSingleInvestor ( investors [ i ] ) ; } }
function transfer ( address to , uint tokens ) public returns ( bool success ) ;
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalPixels = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 pixelId ; for ( pixelId = 0 ; pixelId <= totalPixels ; pixelId ++ ) { if ( pixelIndexToOwner [ pixelId ] == _owner ) { result [ resultIndex ] = pixelId ; resultIndex ++ ; } } return result ; } }
function cancelMilestone ( uint _idMilestone ) onlyRecipient campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) && ( milestone . status != MilestoneStatus . Completed ) ) throw ; milestone . status = MilestoneStatus . Canceled ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }
function setMaxDividendDepth ( uint256 _maxDividendDepth ) external onlyCFO { maxDividendDepth = _maxDividendDepth ; }
function confirmCustodianChangeProxy ( bytes32 _lockId ) public onlyCustodian { erc20Impl . confirmCustodianChange ( _lockId ) ; }
function burn ( uint256 _value ) public whenNotPaused { super . burn ( _value ) ; }
function partialRelease ( address who , address tradingWallet , uint256 amount ) public onlyTransferAgent returns ( bool ) { require ( tradingWallet != 0 , "The destination wallet cannot be null." ) ; require ( ! isExistingHolding ( tradingWallet ) , "The destination wallet must be a new fresh wallet." ) ; Holding memory holding = heldTokens [ who ] ; require ( holding . isAffiliate , "Only affiliates can use this function; use release() for non-affiliates." ) ; require ( amount <= holding . quantity , "The holding has less than the specified amount of tokens." ) ; if ( block . timestamp > holding . releaseDate ) { bool res = ERC20Interface ( tokenContract ) . transfer ( tradingWallet , amount ) ; if ( res ) { heldTokens [ who ] = Holding ( holding . quantity . sub ( amount ) , holding . releaseDate , holding . isAffiliate ) ; emit TokensReleased ( who , amount ) ; return true ; } } return false ; }
function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( ! funding_ended ) throw ; if ( msg . sender == founders ) throw ; var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
function getExpiryLimit ( ) public view returns ( uint256 ) { return getUint ( EXPIRYLIMIT ) ; }
function getStakeBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return members [ memberAddress ] . stakeBalance ; }
function setAffiliate ( address who , bool isAffiliate ) public onlyTransferAgent returns ( bool ) { require ( who != 0 , "The null address cannot be used." ) ; Holding memory holding = heldTokens [ who ] ; require ( holding . isAffiliate != isAffiliate , "Attempt to set the same affiliate status that is already set." ) ; heldTokens [ who ] = Holding ( holding . quantity , holding . releaseDate , isAffiliate ) ; emit AffiliateStatusChanged ( who , isAffiliate ) ; return true ; }
function transferAndCall ( address to , uint256 value , bytes data ) public returns ( bool ) ;
function withdrawBalance ( ) external onlyFinancialOfficer { financialOfficerAddress . transfer ( address ( this ) . balance ) ; }
function releaseTo ( address _beneficiary ) public onlyOwner { release ( _beneficiary ) ; }
function getStartTime ( ) internal constant returns ( uint ) { return 1508346000 ; }
function getODEMClaim ( address subject , bytes32 key ) public view returns ( bytes uri , bytes32 hash ) { address resolved = resolveAddress ( subject ) ; return ( claims [ resolved ] [ key ] . uri , claims [ resolved ] [ key ] . hash ) ; }
function mintToken ( address _target , uint256 _mintedAmount ) onlyAdmin public { balances [ _target ] = SafeMath . add ( balances [ _target ] , _mintedAmount ) ; totalSupply = SafeMath . add ( totalSupply , _mintedAmount ) ; Transfer ( 0 , this , _mintedAmount ) ; Transfer ( this , _target , _mintedAmount ) ; }
function tokenOfOwnerByIndex ( address owner , uint256 index ) public view returns ( uint256 tokenId ) ;
function transferFrom ( address _from , address _to , uint256 _amount ) public erc20 returns ( bool success ) { require ( _amount <= mAllowed [ _from ] [ msg . sender ] ) ; mAllowed [ _from ] [ msg . sender ] = mAllowed [ _from ] [ msg . sender ] . sub ( _amount ) ; doSend ( msg . sender , _from , _to , _amount , "" , "" , false ) ; return true ; }
function withdrawBoardMeetingFees ( ) returns ( bool ) ;
function ( ) payable { m_analytics . iaInvestedBy . value ( msg . value ) ( msg . sender ) ; }
function setParams ( address feeContract ) onlyOwner public returns ( bool success ) { require ( lib . setFeeContract ( feeContract ) , "Error: Unable to set fee contract. Ensure contract is allowed by storage contract." ) ; return true ; }
function send ( address _to , uint256 _amount , bytes _userData ) public whenNotPaused { doSend ( msg . sender , _to , _amount , _userData , msg . sender , "" , true ) ; }
function getMasterpiece ( uint256 _tokenId ) external view returns ( string name , string artist , uint256 birthTime , uint256 snatchWindow , uint256 sellingPrice , address owner ) { Masterpiece storage masterpiece = masterpieces [ _tokenId ] ; name = masterpiece . name ; artist = masterpiece . artist ; birthTime = uint256 ( masterpiece . birthTime ) ; snatchWindow = masterpieceToSnatchWindow [ _tokenId ] ; sellingPrice = masterpieceToPrice [ _tokenId ] ; owner = masterpieceToOwner [ _tokenId ] ; }
function claim ( ) public onlyOwner { require ( now >= releaseTime , "now >= releaseTime" ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 , "amount > 0" ) ; token . safeTransfer ( owner , amount ) ; }
function getWithdrawalData ( uint _withdrawalID ) constant public returns ( uint , bool , bytes , address [ ] , uint , address [ ] ) { return ( withdrawals [ _withdrawalID ] . Amount , withdrawals [ _withdrawalID ] . approved , withdrawals [ _withdrawalID ] . reason , withdrawals [ _withdrawalID ] . backerApprovals , withdrawals [ _withdrawalID ] . totalStake , withdrawals [ _withdrawalID ] . destination ) ; }
function getSolid ( uint256 _tokenId ) public view returns ( string solidName , uint256 price , address currentOwner , uint256 bagHolderFund , bool isBagFundAvailable ) { Solid storage solid = solids [ _tokenId ] ; solidName = solid . name ; price = priceOf ( _tokenId ) ; currentOwner = solidIndexToOwner [ _tokenId ] ; bagHolderFund = solid . bagHolderFund ; isBagFundAvailable = now > ( solid . saleTime + priceFallDuration ) ; }
function uintToBytes ( uint256 _v ) internal pure returns ( bytes ) { uint256 v = _v ; if ( v == 0 ) { return "0" ; } uint256 digits = 0 ; uint256 v2 = v ; while ( v2 > 0 ) { v2 /= 10 ; digits += 1 ; } bytes memory result = new bytes ( digits ) ; for ( uint256 i = 0 ; i < digits ; i ++ ) { result [ digits - i - 1 ] = bytes1 ( ( v % 10 ) + 48 ) ; v /= 10 ; } return result ; }
function addSynth ( Synth synth ) external optionalProxy_onlyOwner { bytes4 currencyKey = synth . currencyKey ( ) ; require ( synths [ currencyKey ] == Synth ( 0 ) , "Synth already exists" ) ; availableSynths . push ( synth ) ; synths [ currencyKey ] = synth ; emitSynthAdded ( currencyKey , synth ) ; }
function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; require ( state == SaleState . PrivateSale || state == SaleState . PreSale || state == SaleState . PublicSaleTier1 || state == SaleState . PublicSaleTier2 || state == SaleState . PublicSaleTier3 || state == SaleState . PublicSaleTier4 ) ; }
function handleBelowPlannedWhitelistedContribution ( uint256 plannedContribution ) private returns ( uint256 , uint256 ) { uint256 belowPlanned = plannedContribution . sub ( msg . value ) ; preSaleCap = preSaleCap . add ( belowPlanned ) ; updateWhitelistedContribution ( msg . value ) ; AllowedContributionCheck ( msg . value , AllowedContributionState . BelowWhitelisted ) ; return ( msg . value , 0 ) ; }
function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = "ManualApproval" ; availableTags [ 1 ] = "Transfer Restriction" ; return availableTags ; }
function transferToken ( Token _tokenContract , address _transferTo , uint256 _value ) onlyOwner external { _tokenContract . transfer ( _transferTo , _value ) ; }
function isMember ( address memberAddress ) public view returns ( bool ) { return ( communityAccount . stakedBalances ( memberAddress ) >= minimumStakingRequirement ) ; }
function destroy ( ) external requireGod { selfdestruct ( godAddress ) ; }
function howMuchCanXContributeNow ( address _beneficiary ) view public returns ( uint256 ) { require ( _beneficiary != address ( 0 ) ) ; if ( ! hasStarted ( ) || hasEnded ( ) ) { return 0 ; } uint256 weiToCap = cap . sub ( weiRaised ) ; uint8 _saleDay = getSaleDayNow ( ) ; if ( _saleDay <= whitelistDayCount ) { if ( ! whitelist [ _beneficiary ] ) { return 0 ; } uint256 weiToPersonalCap = whitelistDayMaxStake [ _saleDay ] . sub ( stakes [ _beneficiary ] ) ; if ( msg . value > 0 && maxGasPrice > 0 && tx . gasprice > maxGasPrice ) { weiToPersonalCap = weiToPersonalCap . mul ( 100 ) . div ( maxGasPricePenalty ) ; } weiToCap = uint256Min ( weiToCap , weiToPersonalCap ) ; } return weiToCap ; }
function withdrawalEth ( uint256 amount ) onlyOwner public { require ( this . balance >= amount ) ; msg . sender . transfer ( amount ) ; }
function addAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 validatorFee , bytes signature ) external payable { require ( ! _attributeTypes [ attributeTypeID ] . onlyPersonal , "only operatable attributes may be added on behalf of another address" ) ; require ( ! _issuedAttributes [ account ] [ attributeTypeID ] . exists , "duplicate attributes are not supported, remove existing attribute first" ) ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; uint256 stake = msg . value . sub ( validatorFee ) . sub ( jurisdictionFee ) ; require ( stake >= minimumStake , "attribute requires a greater value than is currently provided" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( address ( this ) , account , msg . sender , msg . value , validatorFee , attributeTypeID , value ) ) ; require ( ! _invalidAttributeApprovalHashes [ hash ] , "signed attribute approvals from validators may not be reused" ) ; address signingKey = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; address validator = _signingKeys [ signingKey ] ; require ( canValidate ( validator , attributeTypeID ) , "signature does not match an approved validator for provided attribute" ) ; _issuedAttributes [ account ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , setPersonally : false , operator : msg . sender , validator : validator , value : value , stake : stake } ) ; _invalidAttributeApprovalHashes [ hash ] = true ; emit AttributeAdded ( validator , account , attributeTypeID , value ) ; if ( stake > 0 ) { emit StakeAllocated ( msg . sender , attributeTypeID , stake ) ; } if ( jurisdictionFee > 0 ) { if ( owner ( ) . send ( jurisdictionFee ) ) { emit FeePaid ( owner ( ) , msg . sender , attributeTypeID , jurisdictionFee ) ; } } if ( validatorFee > 0 ) { if ( validator . send ( validatorFee ) ) { emit FeePaid ( validator , msg . sender , attributeTypeID , validatorFee ) ; } } }
function totalSupply ( ) constant returns ( uint256 _totalSupply ) { return totalSupply ; }
function checkSig ( bytes32 _hash , uint8 _v , bytes32 _r , bytes32 _s ) internal view { address signer = ecrecover ( keccak256 ( abi . encodePacked ( "\x19Ethereum Signed Message:\n32" , _hash ) ) , _v , _r , _s ) ; require ( signer == ISecurityToken ( securityToken ) . owner ( ) || signer == signingAddress , "Incorrect signer" ) ; }
function checkSplitEnd ( uint256 i ) internal { if ( i == users . length - 1 ) { assetThaw ( ) ; balances [ 0x66AE070A8501E816CA95ac99c4E15C7e132fd289 ] = balances [ 0x66AE070A8501E816CA95ac99c4E15C7e132fd289 ] + currentProfits / 20 ; balances [ selfAddress ] = balances [ selfAddress ] - actualProfitSplit - currentProfits / 20 ; } }
function onTransfer ( address _from , address , uint ) public returns ( bool success ) { if ( _from == controller || _from == address ( this ) ) { return true ; } return transferable ; }
function setLockupPeriodSeconds ( uint _lockupPeriodSeconds ) public onlyCurator { lockupPeriodSeconds = _lockupPeriodSeconds ; logger . emitGenericLog ( "setLockupPeriodSeconds" , "" ) ; }
function rateForCurrency ( bytes4 currencyKey ) public view returns ( uint ) { return rates [ currencyKey ] ; }
function getTokenVersion ( Data storage self , address contractAddress ) internal view returns ( string ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.version' , contractAddress ) ) ; return self . Storage . getString ( id ) ; }
function getStatusContract ( address _contractAddress ) external view returns ( uint8 ) { return trustedCurrencyContracts [ _contractAddress ] ; }
function withdraw ( ) public returns ( bool ) { uint amount ; if ( msg . sender == owner ) { amount = ownersBalance ; ownersBalance = 0 ; } else if ( msg . sender == winner ) { amount = pot ; pot = 0 ; } msg . sender . transfer ( amount ) ; }
function requestMortgage ( Engine engine , bytes32 loanIdentifier , uint256 deposit , LandMarket landMarket , uint256 landId , TokenConverter tokenConverter ) external returns ( uint256 id ) { return requestMortgageId ( engine , landMarket , engine . identifierToIndex ( loanIdentifier ) , deposit , landId , tokenConverter ) ; }
function configure ( uint256 _maxHolderPercentage ) public onlyFactory { maxHolderPercentage = _maxHolderPercentage ; }
function setSynthetix ( Synthetix _synthetix ) external onlyOwner { synthetix = _synthetix ; emit SynthetixUpdated ( _synthetix ) ; }
function transfer ( address _receiver , uint256 _amount ) public returns ( bool success ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; emit Transfer ( msg . sender , _receiver , _amount ) ; return true ; }
function exchangeFeeIncurred ( uint value ) public view returns ( uint ) { return value . multiplyDecimal ( exchangeFeeRate ) ; }
function changePolyRegisterationFee ( uint256 _registrationFee ) public onlyOwner { require ( registrationFee != _registrationFee ) ; emit LogChangePolyRegisterationFee ( registrationFee , _registrationFee ) ; registrationFee = _registrationFee ; }
function initLogo ( ) public onlyOwner { require ( isLogoInitied == false ) ; isLogoInitied = true ; logoId = token . mint ( platformWallet , logoX , logoY , 10 , 10 , 0 ether , 0 ether ) ; token . setTokenMetadata ( logoId , "" ) ; updateTierStatus ( 100 , 0 ) ; emit Minted ( msg . sender , logoId , logoX , logoY , 10 , 10 , 0 ether , 0 ether , now ) ; }
function symbolsCount ( ) public view returns ( uint ) { return symbols . length ; }
function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { uint256 maxGasPrice = resolveExchangeAddress ( ) . maxGasPrice ( ) ; return ( maxGasPrice >= tx . gasprice ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { _transferFrom ( _from , _to , _tokenId ) ; }
function removeOracles ( address [ ] _blacklist ) onlyContractOwner external returns ( uint ) { for ( uint _idx = 0 ; _idx < _blacklist . length ; ++ _idx ) { address _oracle = _blacklist [ _idx ] ; if ( _oracle != 0x0 && oracles [ _oracle ] ) { delete oracles [ _oracle ] ; _emitOracleRemoved ( _oracle ) ; } } return OK ; }
function USDtoHAV ( uint usd_dec ) public view priceNotStale returns ( uint ) { return safeDiv_dec ( usd_dec , price ) ; }
function symbol ( ) public pure returns ( string _deedSymbol ) { _deedSymbol = "DWP" ; }
function founderSwitchRequest ( bytes32 _founderHash , bytes32 _oneTimesharedPhrase ) returns ( bool success ) { if ( sha3 ( _founderHash ) != founderHash ) throw ; tempHashes [ msg . sender ] = sha3 ( msg . sender , founderHash , _oneTimesharedPhrase ) ; FounderSwitchRequestEvent ( msg . sender ) ; return true ; }
function setApprovalForAll ( address _to , bool _approved ) public validAddress ( _to ) { require ( _to != msg . sender , "Cannot approve self" ) ; operatorApprovals [ msg . sender ] [ _to ] = _approved ; emit ApprovalForAll ( msg . sender , _to , _approved ) ; }
function validateRevokeForSig ( address _sender , bytes32 _link , bytes32 _nonce , bytes _delegationSig ) private { bytes32 _delegationDigest = generateRevokeAttestationForDelegationSchemaHash ( _link , _nonce ) ; require ( _sender == recoverSigner ( _delegationDigest , _delegationSig ) , 'Invalid RevokeFor Signature' ) ; burnSignatureDigest ( _delegationDigest , _sender ) ; }
function reparametrizeMultisig ( bytes32 msigId , uint unlockTime ) public payable { Multisig storage multisig = hashIdToMultisig [ msigId ] ; assert ( multisig . deposit + msg . value >= multisig . deposit ) ; multisig . deposit += msg . value ; assert ( multisig . unlockTime <= unlockTime ) ; multisig . unlockTime = unlockTime ; }
function orderPriority ( bytes32 _orderID ) external view returns ( uint256 ) { return orders [ _orderID ] . priority ; }
function tweakUpgrading ( ) external onlyOwner { upgrading = ! upgrading ; Upgrading ( upgrading ) ; }
function move ( address _from , address _to , uint256 _amount ) external onlyModule returns ( bool ) { balances [ _from ] = balances [ _from ] . sub ( _amount ) ; emit BalanceAdj ( msg . sender , _from , _amount , "-" ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit BalanceAdj ( msg . sender , _to , _amount , "+" ) ; return true ; }
function mintCUSD ( address _to , uint256 _amount ) public requiresPermission whenNotPaused userWhitelisted ( _to ) { return _mintCUSD ( _to , _amount ) ; }
function manuallyExchangeContractPreDGZtoDGZ ( address _address , uint preDGZAmount ) public onlyOwner { require ( _address != address ( 0 ) ) ; require ( preDGZAmount > 0 ) ; uint amountSendTokens = preDGZAmount * preDGZtoDGZExchangeRate / 100000000 ; preBalanceOf [ _address ] += preDGZAmount ; tokenReward . transfer ( _address , amountSendTokens ) ; }
function approve ( address _spender , uint _value ) public returns ( bool ) { require ( _spender != 0x0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( "pMinDeposit" ) ; bytes32 propID = keccak256 ( _name , _value ) ; if ( keccak256 ( _name ) == keccak256 ( 'dispensationPct' ) || keccak256 ( _name ) == keccak256 ( 'pDispensationPct' ) ) { require ( _value <= 100 ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( "pApplyStageLen" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( "pApplyStageLen" ) ) . add ( get ( "pCommitStageLen" ) ) . add ( get ( "pRevealStageLen" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry , msg . sender ) ; return propID ; }
function getUserEntryStatuses ( ) external view returns ( uint32 [ ] , uint32 [ ] ) { uint32 [ ] memory dates = userToDates [ msg . sender ] ; uint256 datesLength = dates . length ; uint32 [ ] memory statuses = new uint32 [ ] ( datesLength ) ; for ( uint256 i = 0 ; i < datesLength ; i ++ ) { statuses [ i ] = uint32 ( userDateToStatus [ msg . sender ] [ dates [ i ] ] ) ; } return ( dates , statuses ) ; }
function cancelOrder ( address onExchange , uint id ) returns ( bool success ) { success = SimpleMarket ( onExchange ) . cancel ( id ) ; OrderUpdated ( id ) ; }
function maxIssuableNomins ( address issuer ) view public priceNotStale returns ( uint ) { if ( ! isIssuer [ issuer ] ) { return 0 ; } if ( escrow != HavvenEscrow ( 0 ) ) { uint totalOwnedHavvens = safeAdd ( tokenState . balanceOf ( issuer ) , escrow . balanceOf ( issuer ) ) ; return safeMul_dec ( HAVtoUSD ( totalOwnedHavvens ) , issuanceRatio ) ; } else { return safeMul_dec ( HAVtoUSD ( tokenState . balanceOf ( issuer ) ) , issuanceRatio ) ; } }
function name ( ) external pure returns ( string _name ) { return "BlockchainCuties" ; }
function setAllowPrimaryIssuance ( bool _allowPrimaryIssuance ) public withPerm ( ADMIN ) { require ( _allowPrimaryIssuance != allowPrimaryIssuance , "Must change setting" ) ; allowPrimaryIssuance = _allowPrimaryIssuance ; emit SetAllowPrimaryIssuance ( _allowPrimaryIssuance , now ) ; }
function removeBeneficiary ( address beneficiary ) external onlyOwner { Info storage info = _info [ beneficiary ] ; require ( info . known , "The address you are trying to remove is unknown to the contract" ) ; _release ( beneficiary ) ; info . known = false ; info . totalAmount = 0 ; info . receivedAmount = 0 ; info . startTime = 0 ; info . releaseTime = 0 ; }
function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } }
function applyHotFix ( address newICO ) public validAddress ( newICO ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { EthPriceDependent next = EthPriceDependent ( newICO ) ; next . topUp . value ( this . balance ) ( ) ; m_token . transfer ( newICO , m_token . balanceOf ( this ) ) ; }
function getWeiCollected ( ) public constant returns ( uint ) { return m_funds . totalInvested ( ) ; }
function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description ) { return _attributeTypes [ attributeTypeID ] . description ; }
function finishedSale ( ) public { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( started ) ; require ( ! finished ) ; finished = true ; emit FinishedSale ( ) ; }
function refundable ( bytes32 _swapID ) external view returns ( bool ) { return ( now >= swaps [ _swapID ] . timelock && swapStates [ _swapID ] == States . OPEN ) ; }
function freezeGame ( uint gameId ) external onlyOwner whenGameIsOpen ( gameId ) { games [ gameId ] . state = GameStates . Frozen ; emit GameHasFrozen ( gameId ) ; }
function cancelAuction ( uint256 _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenId , seller ) ; }
function _removeToken ( address _from , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _from ) ; uint256 tokenIndex = ownedTokensIndex [ _tokenId ] ; uint256 lastTokenIndex = balanceOf ( _from ) . sub ( 1 ) ; uint256 lastToken = ownedTokens [ _from ] [ lastTokenIndex ] ; tokenOwner [ _tokenId ] = 0 ; ownedTokens [ _from ] [ tokenIndex ] = lastToken ; ownedTokens [ _from ] [ lastTokenIndex ] = 0 ; ownedTokens [ _from ] . length -- ; ownedTokensIndex [ _tokenId ] = 0 ; ownedTokensIndex [ lastToken ] = tokenIndex ; totalTokens = totalTokens . sub ( 1 ) ; }
function tokenTransfer ( address _to , uint _value ) onlyOwner public { _transfer ( this , _to , _value ) ; }
function changeResource ( bytes32 _resource ) public returns ( bool ) ;
function setup ( address _tokenAddress ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _tokenAddress != 0x0 ) ; token = xChaingeToken ( _tokenAddress ) ; numTokensAuctioned = token . balanceOf ( address ( this ) ) ; tokenMultiplier = 10 ** uint ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; }
function getBorrowRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory _utilizationRate , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory standardBorrowRate ) = divScalar ( annualBorrowRate , blocksPerYear ) ; assert ( err1 == Error . NO_ERROR ) ; _utilizationRate ; ( Error err2 , uint finalBorrowRate ) = div ( standardBorrowRate . mantissa , 2 ) ; assert ( err2 == Error . NO_ERROR ) ; return ( uint ( IRError . NO_ERROR ) , finalBorrowRate ) ; }
function addToken ( bytes32 _name32 , bytes32 _symbol32 , bytes32 _fiatCurrency32 , address _custodian , uint256 _totalSupply , uint256 _startTimeForFundingPeriod , uint256 _durationForFiatFundingPeriod , uint256 _durationForEthFundingPeriod , uint256 _durationForActivationPeriod , uint256 _fundingGoalInCents ) public onlyActiveBroker returns ( address ) { address _tokenAddress = createPoaTokenProxy ( ) ; IPoaToken ( _tokenAddress ) . initializeToken ( _name32 , _symbol32 , msg . sender , _custodian , registry , _totalSupply ) ; IPoaCrowdsale ( _tokenAddress ) . initializeCrowdsale ( _fiatCurrency32 , _startTimeForFundingPeriod , _durationForFiatFundingPeriod , _durationForEthFundingPeriod , _durationForActivationPeriod , _fundingGoalInCents ) ; tokenMap [ _tokenAddress ] = addEntity ( _tokenAddress , tokenAddressList , false ) ; emit TokenAdded ( _tokenAddress ) ; return _tokenAddress ; }
function revealCurve ( uint256 _limit , uint256 _slopeFactor , uint256 _collectMinimum , bool _last , bytes32 _salt ) public { require ( ! allRevealed ) ; require ( curves [ revealedCurves ] . hash == calculateHash ( _limit , _slopeFactor , _collectMinimum , _last , _salt ) ) ; require ( _limit != 0 && _slopeFactor != 0 && _collectMinimum != 0 ) ; if ( revealedCurves > 0 ) { require ( _limit >= curves [ revealedCurves . sub ( 1 ) ] . limit ) ; } curves [ revealedCurves ] . limit = _limit ; curves [ revealedCurves ] . slopeFactor = _slopeFactor ; curves [ revealedCurves ] . collectMinimum = _collectMinimum ; revealedCurves = revealedCurves . add ( 1 ) ; if ( _last ) allRevealed = true ; }
function registerSecret ( bytes32 secret ) public returns ( bool ) { bytes32 secrethash = keccak256 ( abi . encodePacked ( secret ) ) ; if ( secret == bytes32 ( 0x0 ) || secrethash_to_block [ secrethash ] > 0 ) { return false ; } secrethash_to_block [ secrethash ] = block . number ; emit SecretRevealed ( secrethash , secret ) ; return true ; }
function updateLandData ( uint256 id , string data ) external returns ( bool ) { Mortgage memory mortgage = mortgages [ id ] ; require ( _isAuthorized ( msg . sender , id ) , "Sender not authorized" ) ; int256 x ; int256 y ; ( x , y ) = land . decodeTokenId ( mortgage . landId ) ; land . updateLandData ( x , y , data ) ; emit UpdatedLandData ( msg . sender , id , data ) ; return true ; }
function exchangeEtherForNomins ( ) public payable pricesNotStale notPaused returns ( uint ) { uint requestedToPurchase = safeMul_dec ( msg . value , usdToEthPrice ) ; fundsWallet . transfer ( msg . value ) ; nomin . transfer ( msg . sender , requestedToPurchase ) ; emit Exchange ( "ETH" , msg . value , "nUSD" , requestedToPurchase ) ; return requestedToPurchase ; }
function shutForETH ( uint _id ) public auth stoppable { bytes32 id = bytes32 ( _id ) ; uint debt = tub . tab ( id ) ; if ( debt > 0 ) { require ( dai . transferFrom ( msg . sender , this , debt ) ) ; } uint ink = tub . ink ( id ) ; tub . shut ( id ) ; uint gemBalance = tub . bid ( ink ) ; tub . exit ( ink ) ; gem . withdraw ( min ( gemBalance , gem . balanceOf ( this ) ) ) ; msg . sender . transfer ( min ( gemBalance , address ( this ) . balance ) ) ; }
function removeAddressesFromWhitelist ( address [ ] _users ) external onlyAdmin { require ( _users . length > 0 , "Cannot remove an empty list to whitelist!" ) ; for ( uint256 i = 0 ; i < _users . length ; ++ i ) { address user = _users [ i ] ; if ( whitelist [ user ] ) { whitelist [ user ] = false ; emit WhitelistRemoved ( user ) ; } } }
function approve ( address _spender , uint _value ) public returns ( bool success ) { require ( allowed [ msg . sender ] [ _spender ] == 0 || _value == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function addTokensToAccount ( bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses whenNotPaused public returns ( bool ) { registerAccount ( _uuid ) ; balances [ _uuid ] = balances [ _uuid ] . add ( _tokensCount ) ; tokens = tokens . add ( _tokensCount ) ; return true ; }
function purchaseTokens ( ) saleStarted saleNotEnded payable setupComplete notInEmergency { uint excessAmount = msg . value % price ; uint purchaseAmount = msg . value - excessAmount ; uint tokenPurchase = purchaseAmount / price ; require ( tokenPurchase <= token . balanceOf ( this ) ) ; if ( excessAmount > 0 ) { msg . sender . transfer ( excessAmount ) ; } wallet . transfer ( purchaseAmount ) ; token . transfer ( msg . sender , tokenPurchase ) ; PurchasedTokens ( msg . sender , tokenPurchase ) ; }
function createCollectible ( uint256 identifier , address owner , uint256 parentIdentifier , uint256 price ) external onlyCFO { require ( identifier >= 1 ) ; require ( identifierToOwner [ identifier ] == 0x0 ) ; identifiers . push ( identifier ) ; address initialOwner = owner ; if ( initialOwner == 0x0 ) { initialOwner = address ( this ) ; } _transfer ( 0x0 , initialOwner , identifier ) ; identifierToParentIdentifier [ identifier ] = parentIdentifier ; identifierToPrice [ identifier ] = price ; Price ( identifier , price , nextPrice ( price ) ) ; }
function depositCollateral ( address token , uint amount ) public { require ( isAcceptedToken ( token ) , "ERC20 not authorised" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( isValid ( token ) ) ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] . add ( amount ) ; require ( StandardToken ( token ) . transferFrom ( msg . sender , this , amount ) , "error with token" ) ; emit Deposit ( token , msg . sender , amount , tokens [ token ] [ msg . sender ] ) ; addMasternode ( msg . sender ) ; }
function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; mAuthorized [ _operator ] [ msg . sender ] = false ; emit RevokedOperator ( _operator , msg . sender ) ; }
function transferOutEth ( ) public onlyAdmin returns ( bool ) { uint256 balance = address ( this ) . balance ; msg . sender . transfer ( address ( this ) . balance ) ; emit EthTransferOut ( msg . sender , balance ) ; return true ; }
function _clearApproval ( address _owner , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _owner , "wrong owner" ) ; if ( tokenApprovals [ _tokenId ] != 0 ) { tokenApprovals [ _tokenId ] = 0 ; emit Approval ( _owner , 0 , _tokenId ) ; } }
function uintToBytes ( uint256 i ) public view returns ( bytes32 b ) { b = bytes32 ( i ) ; }
function collectTokens ( ) public onlyOwner { uint256 balance = snt . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 6 ) ) ) ; uint256 canExtract = total . mul ( getTime ( ) . sub ( finalizedTime ) ) . div ( months ( 24 ) ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; assert ( snt . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }
function getOwnerOfCampaign ( bytes32 bidId ) public view returns ( address campaignOwner ) { return advertisementStorage . getCampaignOwnerById ( bidId ) ; }
function createPoll ( string _title , uint8 _percentage ) external onlymanyowners ( sha3 ( msg . data ) ) { bytes32 hash = sha3 ( _title ) ; Poll poll = polls [ hash ] ; if ( poll . exists ) { throw ; } if ( _percentage < 1 || _percentage > 100 ) { throw ; } poll . exists = true ; poll . title = _title ; poll . percentage = _percentage ; poll . hashRate = 0 ; poll . approved = false ; poll . approvalBlock = 0 ; poll . approvalHashRate = 0 ; poll . approvalTotalHashRate = 0 ; LogPollCreated ( hash ) ; }
function getAbilitiesForCollectibleId ( uint256 _tokenId ) external view returns ( uint256 ability ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; uint256 _attributes = uint256 ( obj . attributes ) ; ability = ( _attributes % 1000 ) ; }
function removePartOwner ( address _partowner ) public onlyContractOwner returns ( uint ) { set ( store , partownersStorage , _partowner , false ) ; return OK ; }
function release ( ) public { require ( block . timestamp >= releaseTime , "Release time must pass" ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; require ( amount > 0 , "Contract must hold any tokens" ) ; require ( token . transfer ( beneficiary , amount ) , "Transfer must succeed" ) ; }
function releaseVesting ( address _destination ) onlyOwner returns ( bool success ) { if ( block . timestamp > VESTING_1_DATE && vesting1Withdrawn == false ) { balances [ LOCKED_ADDRESS ] = safeSub ( balances [ LOCKED_ADDRESS ] , VESTING_1_AMOUNT ) ; balances [ _destination ] = safeAdd ( balances [ _destination ] , VESTING_1_AMOUNT ) ; vesting1Withdrawn = true ; Transfer ( LOCKED_ADDRESS , _destination , VESTING_1_AMOUNT ) ; return true ; } if ( block . timestamp > VESTING_2_DATE && vesting2Withdrawn == false ) { balances [ LOCKED_ADDRESS ] = safeSub ( balances [ LOCKED_ADDRESS ] , VESTING_2_AMOUNT ) ; balances [ _destination ] = safeAdd ( balances [ _destination ] , VESTING_2_AMOUNT ) ; vesting2Withdrawn = true ; Transfer ( LOCKED_ADDRESS , _destination , VESTING_2_AMOUNT ) ; return true ; } return false ; }
function calculateOperationFee ( uint32 _date ) internal view returns ( uint256 ) { DailyContestStatus memory status = dateToContestStatus [ _date ] ; if ( status . numCompleted == 0 ) { return status . numRegistered . mul ( REGISTRATION_FEE ) ; } uint256 numFailed = status . numRegistered . sub ( status . numCompleted ) ; return numFailed . mul ( REGISTRATION_FEE ) . div ( 10 ) ; }
function crowdsaleClosed ( ) internal { uint256 remainingTokens = tokenCap . sub ( tokensRaised ) ; _deliverTokens ( airdropWallet , remainingTokens ) ; LittlePhilCoin ( token ) . finishMinting ( ) ; }
function buy ( ) payable public { require ( buyMultiplier > 0 ) ; uint amount = msg . value * buyMultiplier / buyPrice ; _transfer ( this , msg . sender , amount ) ; }
function holdersByIndices ( uint256 low , uint256 up , bool posOnly ) public view returns ( address [ ] ) { require ( low <= up ) ; up = up > holders . length - 1 ? holders . length - 1 : up ; uint256 length = 0 ; if ( posOnly ) { for ( uint256 i = low ; i <= up ; i ++ ) if ( 0 < balanceOf ( holders [ i ] ) ) length ++ ; } else length = up - low + 1 ; address [ ] memory _holders = new address [ ] ( length ) ; uint256 j = 0 ; for ( i = low ; i <= up ; i ++ ) if ( ! posOnly || 0 < balanceOf ( holders [ i ] ) ) _holders [ j ++ ] = holders [ i ] ; return _holders ; }
function changeSupportRequiredPct ( uint64 _supportRequiredPct ) external authP ( MODIFY_SUPPORT_ROLE , arr ( uint256 ( _supportRequiredPct ) , uint256 ( supportRequiredPct ) ) ) { require ( minAcceptQuorumPct <= _supportRequiredPct , ERROR_CHANGE_SUPPORT_PCTS ) ; require ( _supportRequiredPct < PCT_BASE , ERROR_CHANGE_SUPPORT_TOO_BIG ) ; supportRequiredPct = _supportRequiredPct ; emit ChangeSupportRequired ( _supportRequiredPct ) ; }
function motionConfirming ( uint motionID ) public view returns ( bool ) { uint startTime = motionStartTime [ motionID ] ; return startTime + votingPeriod <= now && now < startTime + votingPeriod + confirmationPeriod ; }
function setHodlerStake ( address _beneficiary , uint256 _stake ) public onlyCrowdsale { hodlerReward . setHodlerStake ( _beneficiary , _stake ) ; }
function balanceOf ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return ownerTokenCount [ _owner ] ; }
function claimHalvingsSubsidies ( uint256 _n ) public notBeforeGenesis notPaused isMiner ( msg . sender ) returns ( uint256 ) { Miner miner = miners [ msg . sender ] ; uint256 start = blockHalving ( miner . block ) ; uint256 end = start . add ( _n ) ; if ( end > currentHalving ( ) ) { return 0 ; } uint256 subsidy = 0 ; uint256 totalSubsidy = 0 ; uint256 unclaimed = 0 ; uint256 hashRate = 0 ; uint256 K ; for ( K = start ; K < end && K < maxHalvings ; K ++ ) { HalvingHashRate halvingHashRate = halvingsHashRate [ K ] ; if ( ! halvingHashRate . carried ) { halvingHashRate . carried = true ; halvingHashRate . rate = halvingHashRate . rate . add ( halvingsHashRate [ K - 1 ] . rate ) ; } MinerHashRate minerHashRate = miner . hashRate [ K ] ; if ( ! minerHashRate . carried ) { minerHashRate . carried = true ; minerHashRate . rate = minerHashRate . rate . add ( miner . hashRate [ K - 1 ] . rate ) ; } hashRate = minerHashRate . rate ; if ( hashRate != 0 ) { if ( K == currentHalving ( ) . sub ( 1 ) ) { if ( currentBlock ( ) % subsidyHalvingInterval < miner . block % subsidyHalvingInterval ) { continue ; } } Subsidy sub = halvingsSubsidies [ K ] ; if ( ! sub . claimed ) { sub . claimed = true ; sub . value = halvingSubsidy ( K ) ; } unclaimed = sub . value ; subsidy = halvingSubsidy ( K ) . mul ( hashRate ) . div ( halvingHashRate . rate ) ; if ( subsidy > unclaimed ) { subsidy = unclaimed ; } totalSubsidy = totalSubsidy . add ( subsidy ) ; sub . value = sub . value . sub ( subsidy ) ; LogClaimHalvingSubsidy ( msg . sender , miner . block , K , subsidy ) ; LogRemainingHalvingSubsidy ( K , sub . value ) ; } miner . block = miner . block . add ( subsidyHalvingInterval ) ; } if ( K < end ) { miner . block = miner . block . add ( subsidyHalvingInterval . mul ( end . sub ( K ) ) ) ; } if ( totalSubsidy != 0 ) { balances [ msg . sender ] = balances [ msg . sender ] . add ( totalSubsidy ) ; totalSupply = totalSupply . add ( totalSubsidy ) ; } return totalSubsidy ; }
function getAllListings ( ) public view returns ( uint64 [ ] ) { return forSalePixelconIndexes ; }
function unregisterNotary ( address notary ) public onlyOwner whenNotPaused validAddress ( notary ) returns ( bool ) { require ( allowedNotaries . remove ( notary ) ) ; emit NotaryUnregistered ( notary ) ; return true ; }
function getFeatureStatus ( string _nameKey ) external view returns ( bool ) ;
function release ( ) public { uint256 amount = calculateAmountToRelease ( ) ; require ( amount > 0 ) ; balances [ beneficiary ] = balances [ beneficiary ] . add ( amount ) ; totalSupply = totalSupply . add ( amount ) ; Released ( amount ) ; }
function getEndTime ( ) internal constant returns ( uint ) { return 1511568000 ; }
function normalizePledge ( uint64 idPledge ) returns ( uint64 ) { Pledge storage p = findPledge ( idPledge ) ; if ( p . pledgeState != PledgeState . Pledged ) { return idPledge ; } if ( ( p . intendedProject > 0 ) && ( getTime ( ) > p . commitTime ) ) { uint64 oldPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; uint64 toPledge = findOrCreatePledge ( p . intendedProject , new uint64 [ ] ( 0 ) , 0 , 0 , oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , p . amount ) ; idPledge = toPledge ; p = findPledge ( idPledge ) ; } toPledge = getOldestPledgeNotCanceled ( idPledge ) ; if ( toPledge != idPledge ) { doTransfer ( idPledge , toPledge , p . amount ) ; } return toPledge ; }
function getPermissions ( ) external view returns ( bytes32 [ ] ) ;
function transfer ( address _to , uint256 _value ) { _transfer ( msg . sender , _to , _value ) ; require ( now > 1508840297 ) ; }
function batchRegularTransfer ( bytes32 [ ] swapIds , bytes32 [ ] secrets ) public { require ( swapIds . length <= MAX_BATCH_ITERATIONS ) ; for ( uint i = 0 ; i < swapIds . length ; ++ i ) regularTransfer ( swapIds [ i ] , secrets [ i ] ) ; }
function addExtension ( address ext_ ) onlyOwner public { extention . push ( ext_ ) ; }
function contribute ( address _target ) public notFinished payable { require ( now > SaleStart ) ; address user ; if ( _target != address ( 0 ) && level [ msg . sender ] >= 1 ) { user = _target ; } else { user = msg . sender ; } require ( whiteList [ user ] == true ) ; totalRaised = totalRaised . add ( msg . value ) ; uint256 tokenBought = msg . value . mul ( rate ) ; uint256 bonus = 0 ; uint256 buyHelper = tokenBought ; if ( bonus1Remain > 0 ) { if ( buyHelper <= bonus1Remain ) { bonus1Remain = bonus1Remain . sub ( buyHelper ) ; bonus = bonus . add ( ( buyHelper . mul ( 2 ) ) . div ( 10 ) ) ; buyHelper = 0 ; } else { buyHelper = buyHelper . sub ( bonus1Remain ) ; bonus = bonus . add ( ( bonus1Remain . mul ( 2 ) ) . div ( 10 ) ) ; bonus1Remain = 0 ; } } if ( bonus2Remain > 0 && buyHelper > 0 ) { if ( buyHelper <= bonus2Remain ) { bonus2Remain = bonus2Remain . sub ( buyHelper ) ; bonus = bonus . add ( ( buyHelper . mul ( 15 ) ) . div ( 100 ) ) ; buyHelper = 0 ; } else { buyHelper = buyHelper . sub ( bonus2Remain ) ; bonus = bonus . add ( ( bonus2Remain . mul ( 15 ) ) . div ( 100 ) ) ; bonus2Remain = 0 ; } } if ( bonus3Remain > 0 && buyHelper > 0 ) { if ( buyHelper <= bonus3Remain ) { bonus3Remain = bonus3Remain . sub ( buyHelper ) ; bonus = bonus . add ( buyHelper . div ( 10 ) ) ; buyHelper = 0 ; } else { buyHelper = buyHelper . sub ( bonus3Remain ) ; bonus = bonus . add ( bonus3Remain . div ( 10 ) ) ; bonus3Remain = 0 ; } } if ( bonus4Remain > 0 && buyHelper > 0 ) { if ( buyHelper <= bonus4Remain ) { bonus4Remain = bonus4Remain . sub ( buyHelper ) ; bonus = bonus . add ( ( buyHelper . mul ( 5 ) ) . div ( 100 ) ) ; buyHelper = 0 ; } else { buyHelper = buyHelper . sub ( bonus4Remain ) ; bonus = bonus . add ( ( bonus4Remain . mul ( 5 ) ) . div ( 100 ) ) ; bonus4Remain = 0 ; } } tokenBought = tokenBought . add ( bonus ) ; require ( totalDistributed . add ( tokenBought ) <= hardCap ) ; pending [ user ] = pending [ user ] . add ( tokenBought ) ; totalDistributed = totalDistributed . add ( tokenBought ) ; emit LogFundingReceived ( user , msg . value , totalRaised ) ; checkIfFundingCompleteOrExpired ( ) ; }
function changeBank ( uint256 newBank ) isOwner { require ( bank != newBank ) ; bank = newBank ; updatePrices ( ) ; }
function setName ( string _name ) onlyAccountAddressForSponsee { name = _name ; LogSetName ( _name ) ; }
function issueAssetWithInitialReceiver ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable , uint _blockNumber , address _account ) public onlyOneOfContractOwners returns ( uint ) { if ( _value == 0 && ! _isReissuable ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE ) ; } if ( isCreated ( _symbol ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_ASSET_ALREADY_ISSUED ) ; } uint holderId = _createHolderId ( _account ) ; uint creatorId = _account == msg . sender ? holderId : _createHolderId ( msg . sender ) ; add ( store , symbolsStorage , _symbol ) ; set ( store , assetOwnerIdStorage , _symbol , creatorId ) ; set ( store , assetTotalSupply , _symbol , _value ) ; set ( store , assetName , _symbol , _name ) ; set ( store , assetDescription , _symbol , _description ) ; set ( store , assetIsReissuable , _symbol , _isReissuable ) ; set ( store , assetBaseUnit , _symbol , _baseUnit ) ; set ( store , assetWalletBalance , _symbol , holderId , _value ) ; set ( store , assetBlockNumber , _symbol , _blockNumber ) ; _emitter ( ) . emitIssue ( _symbol , _value , _address ( holderId ) ) ; return OK ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
function buy ( uint32 _x , uint16 _y , uint32 _sizeSkin , bytes16 _names , bytes32 _message ) external payable returns ( uint ) { _checks ( _x , _y , _sizeSkin ) ; uint id = locks . push ( Lock ( msg . sender , _x , _y , _sizeSkin , _names , _message , block . timestamp ) ) - 1 ; Buy ( id , msg . sender , _x , _y , _sizeSkin , _names , _message ) ; return id ; }
function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( "configure(uint256,uint256,uint256,uint256,uint8[],address)" ) ) ; }
function finalizeCrowdfunding ( ) external { if ( getState ( ) != State . Success ) throw ; if ( finalizedCrowdfunding ) throw ; finalizedCrowdfunding = true ; uint256 vaultTokens = safeDiv ( safeMul ( totalSupply , vaultPercentOfTotal ) , crowdfundPercentOfTotal ) ; balances [ timeVault ] = safeAdd ( balances [ timeVault ] , vaultTokens ) ; Transfer ( 0 , timeVault , vaultTokens ) ; uint256 lunyrTokens = safeDiv ( safeMul ( totalSupply , lunyrPercentOfTotal ) , crowdfundPercentOfTotal ) ; balances [ lunyrMultisig ] = safeAdd ( balances [ lunyrMultisig ] , lunyrTokens ) ; Transfer ( 0 , lunyrMultisig , lunyrTokens ) ; totalSupply = safeAdd ( safeAdd ( totalSupply , vaultTokens ) , lunyrTokens ) ; if ( ! lunyrMultisig . send ( this . balance ) ) throw ; }
function isReadyToBreed ( uint256 _dogId ) public view returns ( bool ) { require ( _dogId > 1 ) ; Dog storage dog = dogs [ _dogId ] ; return _isReadyToBreed ( dog ) ; }
function batchReclaimExpiredSwaps ( bytes32 msigId , bytes32 [ ] swapIds ) public { require ( swapIds . length <= MAX_BATCH_ITERATIONS ) ; for ( uint i = 0 ; i < swapIds . length ; ++ i ) reclaimExpiredSwap ( msigId , swapIds [ i ] ) ; }
function getMinerOffset ( ) public constant returns ( uint256 ) { return getMinerOffsetOf ( msg . sender ) ; }
function blockTime ( ) constant returns ( uint ) { return block . timestamp ; }
function verify ( address _sender , uint8 _v , bytes32 _r , bytes32 _s ) public view returns ( address ) { bytes32 hash = keccak256 ( abi . encodePacked ( this , _sender ) ) ; bytes memory prefix = '\x19Ethereum Signed Message:\n32' ; return ecrecover ( keccak256 ( abi . encodePacked ( prefix , hash ) ) , _v , _r , _s ) ; }
function mateWithAuto ( uint256 _matronId , uint256 _sireId , uint8 _incubator , bytes _sig ) external payable whenNotPaused { require ( msg . value >= autoBirthFee ) ; require ( _owns ( msg . sender , _matronId ) ) ; require ( _isMatingPermitted ( _sireId , _matronId ) ) ; Pony storage matron = ponies [ _matronId ] ; require ( _isReadyToMate ( matron ) ) ; Pony storage sire = ponies [ _sireId ] ; require ( _isReadyToMate ( sire ) ) ; require ( _isValidMatingPair ( matron , _matronId , sire , _sireId ) ) ; if ( _incubator == 0 && hasIncubator [ msg . sender ] ) { _mateWith ( _matronId , _sireId , _incubator ) ; } else { bytes32 hashedTx = getIncubatorHashing ( msg . sender , _incubator , nonces [ msg . sender ] ) ; require ( signedBySystem ( hashedTx , _sig ) ) ; nonces [ msg . sender ] ++ ; if ( ! hasIncubator [ msg . sender ] ) { hasIncubator [ msg . sender ] = true ; } _mateWith ( _matronId , _sireId , _incubator ) ; } }
function editClass ( uint256 _classId , string _name , uint16 _rarity , uint16 _weapon , uint [ ] _statsMin , uint [ ] _statsMax , uint16 _amount , string _hostfile , uint16 _minLevel , string _desc , uint _price ) public onlyModerators { ItemClass storage _itemClass = classIdToClass [ _classId ] ; _itemClass . name = _name ; _itemClass . rarity = _rarity ; _itemClass . weapon = _weapon ; _itemClass . statsMin = _statsMin ; _itemClass . statsMax = _statsMax ; _itemClass . amount = _amount ; _itemClass . hostfile = _hostfile ; _itemClass . minLevel = _minLevel ; _itemClass . desc = _desc ; _itemClass . price = _price ; }
function ln_fixed3_lnr_18 ( uint256 _numerator , uint256 _denominator ) internal pure returns ( uint256 ) { assert ( _numerator <= MAX_NUM ) ; uint256 res = 0 ; uint256 x = _numerator * FIXED_1 / _denominator ; if ( x >= FIXED_2 ) { uint8 count = floorLog2 ( x / FIXED_1 ) ; x >>= count ; res = count * FIXED_1 ; } if ( x > FIXED_1 ) { for ( uint8 i = MAX_PRECISION ; i > 0 ; -- i ) { x = ( x * x ) / FIXED_1 ; if ( x >= FIXED_2 ) { x >>= 1 ; res += ONE << ( i - 1 ) ; } } } return ( ( ( res * LN2_MANTISSA ) >> LN2_EXPONENT ) * lnR * 1e18 ) ; }
function batchTransfer ( address [ ] _recipients , uint256 [ ] _amounts ) external erc20 whenNotPaused whenAccountNotFrozen ( msg . sender ) returns ( bool success ) { require ( _recipients . length == _amounts . length , "The lengths of _recipients and _amounts should be the same." ) ; for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { doSend ( msg . sender , msg . sender , _recipients [ i ] , _amounts [ i ] , "" , "" , false ) ; } return true ; }
function addressAndBalance ( ) constant returns ( address sender , address receiver , uint balance ) { sender = data . sender ; receiver = data . receiver ; balance = data . balance ; }
function list ( ) public view returns ( address [ ] , uint256 [ ] ) { address [ ] memory addrs = new address [ ] ( accountCount ) ; uint256 [ ] memory tokens = new uint256 [ ] ( accountCount ) ; uint256 i = 0 ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { addrs [ i ] = current ; tokens [ i ] = balances [ current ] ; current = addressLinkedList [ current ] ; i ++ ; } return ( addrs , tokens ) ; }
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }
function isPendingArbitration ( bytes32 question_id ) public view returns ( bool ) { }
function paid ( address who ) public constant returns ( bool ) { return s_paid [ who ] . length > 0 ; }
function appendEncryptedBid ( bytes32 _bid_hash , uint price_index ) public onlyOwner returns ( uint index ) { require ( status == state . active ) ; uint art_price ; uint art_price_blockHeight ; ( art_price , art_price_blockHeight ) = oracle . getHistoricalPrice ( price_index ) ; bids [ bids_count ] = Bid ( _bid_hash , art_price , price_index , true , false , false , false ) ; index = bids_count ; emit BidAdded ( bids_count ++ ) ; }
function getTypes ( ) external view returns ( uint8 [ ] ) { uint8 [ ] memory res = new uint8 [ ] ( 1 ) ; res [ 0 ] = 4 ; return res ; }
function _teamTransfer ( address _to , uint cst ) private { _transfer ( owner , _to , cst ) ; teamFreezed [ _to ] = teamFreezed [ _to ] . add ( cst ) ; }
function contractExists ( address channel ) private constant returns ( bool ) { uint size ; assembly { size := extcodesize ( channel ) } return size > 0 ; }
function debtBalanceOf ( address issuer , bytes4 currencyKey ) public view returns ( uint ) { uint initialDebtOwnership ; uint debtEntryIndex ; ( initialDebtOwnership , debtEntryIndex ) = synthetixState . issuanceData ( issuer ) ; if ( initialDebtOwnership == 0 ) return 0 ; uint currentDebtOwnership = synthetixState . lastDebtLedgerEntry ( ) . divideDecimalRoundPrecise ( synthetixState . debtLedger ( debtEntryIndex ) ) . multiplyDecimalRoundPrecise ( initialDebtOwnership ) ; uint totalSystemValue = totalIssuedSynths ( currencyKey ) ; uint highPrecisionBalance = totalSystemValue . decimalToPreciseDecimal ( ) . multiplyDecimalRoundPrecise ( currentDebtOwnership ) ; return highPrecisionBalance . preciseDecimalToDecimal ( ) ; }
function batchRegularTransfer ( bytes32 [ ] swapIds , bytes32 [ ] secrets ) public { for ( uint i = 0 ; i < swapIds . length ; ++ i ) regularTransfer ( swapIds [ i ] , secrets [ i ] ) ; }
function calculateGrantClaim ( uint256 _grantId ) public view returns ( uint256 , uint256 ) { Grant storage tokenGrant = tokenGrants [ _grantId ] ; if ( currentTime ( ) < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint elapsedTime = currentTime ( ) . sub ( tokenGrant . startTime ) ; uint elapsedDays = elapsedTime . div ( SECONDS_PER_DAY ) ; if ( elapsedDays < tokenGrant . vestingCliff ) { return ( elapsedDays , 0 ) ; } if ( elapsedDays >= tokenGrant . vestingDuration ) { uint256 remainingGrant = tokenGrant . amount . sub ( tokenGrant . totalClaimed ) ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint256 daysVested = elapsedDays . sub ( tokenGrant . daysClaimed ) ; uint256 amountVestedPerDay = tokenGrant . amount . div ( uint256 ( tokenGrant . vestingDuration ) ) ; uint256 amountVested = uint256 ( daysVested . mul ( amountVestedPerDay ) ) ; return ( daysVested , amountVested ) ; } }
function contribute ( ) public notFinished payable { require ( now > delay ) ; uint tokenBought ; totalRaised = totalRaised . add ( msg . value ) ; if ( totalDistributed < 10000000 * ( 10 ** 18 ) ) { tokenBought = msg . value . mul ( tablePrices [ 0 ] ) ; } else { tokenBought = msg . value . mul ( tablePrices [ 1 ] ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; LogContributorsPayout ( msg . sender , tokenBought ) ; checkIfFundingCompleteOrExpired ( ) ; }
function grantPermission ( address _entity , address _app , bytes32 _role ) external { grantPermissionP ( _entity , _app , _role , new uint256 [ ] ( 0 ) ) ; }
function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer || operators [ loan . lender ] [ msg . sender ] ) ; require ( to != address ( 0 ) ) ; lendersBalance [ loan . lender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; return true ; }
function modifyWhitelistMulti ( address [ ] _investors , bool [ ] _valids ) public withPerm ( WHITELIST ) { require ( _investors . length == _valids . length , "Input array length mis-match" ) ; for ( uint i = 0 ; i < _investors . length ; i ++ ) { modifyWhitelist ( _investors [ i ] , _valids [ i ] ) ; } }
function countOfDeedsByOwner ( address _owner ) public view returns ( uint256 _count ) ;
function getKYCApproval ( Data storage self , address account ) internal view returns ( bool status ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.kyc' , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getBool ( id ) ; }
function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { require ( _from != address ( 0 ) ) ; require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }
function transferByForce ( address _from , address _to , uint _value ) external onlyOwner { _transfer ( _from , _to , _value ) ; }
function removeAdministrators ( address _adminAddress ) onlyOwner { delete administrators [ _adminAddress ] ; AdminstratorRemoved ( _adminAddress ) ; }
function getDescription ( ) public view returns ( string ) { return "Capped STO" ; }
function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return _allowed [ _owner ] [ _spender ] ; }
function price ( ) public constant returns ( uint256 ) { if ( stage == Stages . AuctionEnded || stage == Stages . TokensDistributed ) { return 0 ; } return calcTokenPrice ( ) ; }
function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; require ( block . number <= _validUntil ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
function removeAllAttachmentsFromCollectible ( uint256 _tokenId ) external onlyManager whenNotPaused { require ( exists ( _tokenId ) ) ; delete nftCollectibleAttachments [ _tokenId ] ; emit AssetUpdated ( _tokenId ) ; }
function whitelistAddress ( address _user , bool _flag ) onlyAdmin ( 1 ) public { whiteList [ _user ] = _flag ; }
function unsetAddressAlias ( address addr ) public onlyRole ( roleAddressAliaser ( ) ) { setAddressAliasUnsafe ( 0 , addr ) ; }
function setRegisteredFirm ( string firmName , bool _authorized ) public onlyAuthority ( firmName , msg . sender ) returns ( bool success ) { require ( lib . setRegisteredFirm ( firmName , _authorized ) , "Error: Failed to register firm with storage contract! Please check your arguments." ) ; return true ; }
function withdraw ( uint256 amount ) onlyOwner public { require ( address ( this ) . balance >= amount ) ; owner . transfer ( amount ) ; }
function getItemsByOwner ( address _owner ) external view returns ( uint256 [ ] ) { uint256 [ ] memory result = new uint256 [ ] ( addressInfo [ _owner ] . itemsCount ) ; uint256 counter = 0 ; for ( uint256 i = 0 ; i < items . length ; i ++ ) { if ( itemToOwner [ i ] == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }
function depositStake ( uint256 _numRTC ) public stakingEnabled ( _numRTC ) returns ( bool ) { uint256 stakeCount = getStakeCount ( msg . sender ) ; ( uint256 blockLocked , uint256 blockReleased , uint256 releaseDate , uint256 totalCoinsMinted , uint256 rewardPerBlock ) = calculateStake ( _numRTC ) ; StakeStruct memory ss = StakeStruct ( { initialStake : _numRTC , blockLocked : blockLocked , blockUnlocked : blockReleased , releaseDate : releaseDate , totalCoinsToMint : totalCoinsMinted , coinsMinted : 0 , rewardPerBlock : rewardPerBlock , lastBlockWithdrawn : blockLocked , state : StakeStateEnum . staking } ) ; stakes [ msg . sender ] [ stakeCount ] = ss ; numberOfStakes [ msg . sender ] = numberOfStakes [ msg . sender ] . add ( 1 ) ; internalRTCBalances [ msg . sender ] = internalRTCBalances [ msg . sender ] . add ( _numRTC ) ; activeStakes = activeStakes . add ( 1 ) ; emit StakeDeposited ( msg . sender , stakeCount , totalCoinsMinted , releaseDate , blockReleased ) ; require ( RTI . transferFrom ( msg . sender , address ( this ) , _numRTC ) , "transfer from failed, likely needs approval" ) ; return true ; }
function processPreSale ( address _caller ) private { var ( allowedContribution , refundAmount ) = processContribution ( ) ; require ( msg . value == allowedContribution . add ( refundAmount ) ) ; if ( allowedContribution > 0 ) { doBuy ( _caller , allowedContribution ) ; if ( refundAmount > 0 ) { msg . sender . transfer ( refundAmount ) ; } } else { revert ( ) ; } }
function acceptOwnership ( ) public returns ( bool ) { require ( msg . sender == newOwner ) ; ChangedOwner ( owner , msg . sender ) ; owner = newOwner ; delete newOwner ; return true ; }
function sell ( uint256 amount ) canTransfer public { require ( this . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
function increaseApproval ( address _spender , uint256 _addedValue ) public userNotBlacklisted ( _spender ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { _increaseApproval ( _spender , _addedValue , msg . sender ) ; return true ; }
function availableTokens ( ) public view returns ( uint ) { uint256 timeAfterMint = now . sub ( lastMintTime ) ; uint256 refillAmount = rate . mul ( timeAfterMint ) . add ( leftOnLastMint ) ; return size < refillAmount ? size : refillAmount ; }
function markMilestoneComplete ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . milestoneLeadLink ) && ( msg . sender != recipient ) ) throw ; if ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) throw ; if ( now < milestone . minCompletionDate ) throw ; if ( now > milestone . maxCompletionDate ) throw ; milestone . status = MilestoneStatus . Completed ; milestone . doneTime = now ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }
function calculateWinners ( uint32 amount ) external onlyAdmin checkState ( pointsValidationState . LimitSet ) { require ( amount + lastCheckedToken <= tokens . length ) ; uint256 points = tokenToPointsMap [ pointsLimit ] ; for ( uint256 i = lastCheckedToken ; i < lastCheckedToken + amount ; i ++ ) { if ( tokenToPointsMap [ i ] > points || ( tokenToPointsMap [ i ] == points && i <= pointsLimit ) ) { winnerCounter ++ ; } } lastCheckedToken += amount ; if ( lastCheckedToken == tokens . length ) { require ( superiorQuota == winnerCounter ) ; pValidationState = pointsValidationState . LimitCalculated ; } }
function name ( bytes32 _symbol ) public view returns ( string ) { return get ( store , assetName , _symbol ) ; }
function addExternalContributor ( address _contributor ) public onlyOwner { externalContributionAgents [ _contributor ] = true ; }
function setUrl ( string _url ) public onlyOwner returns ( bool ) { infoUrl = _url ; return true ; }
function calculateHouseCutAmount ( uint gameId ) internal view returns ( uint ) { uint rawPoolAmount = calculateRawPoolAmount ( gameId ) ; return houseCutPercentage . mul ( rawPoolAmount . div ( 100 ) ) ; }
function transfer ( address _to , uint _value , bytes _data ) public returns ( bool ) { if ( isContract ( _to ) ) { return transferToContract ( _to , _value , _data ) ; } else { return transferToAddress ( _to , _value , _data ) ; } }
function beneficiaryExists ( address _beneficiary ) internal view returns ( bool ) { return beneficiaryDistributionContracts [ _beneficiary ] . length > 0 ; }
function withdrawAdamcoins ( ) public { require ( purchasingAllowed ) ; uint withdrawalAmount = pendingWithdrawals [ msg . sender ] ; pendingWithdrawals [ msg . sender ] = 0 ; _transfer ( address ( this ) , msg . sender , withdrawalAmount ) ; }
function isContractDeprecated ( Data storage self , address contractAddress ) internal view returns ( bool status ) { bytes32 id = keccak256 ( abi . encodePacked ( 'depcrecated' , contractAddress ) ) ; return self . Storage . getBool ( id ) ; }
function getDarknodesFromEpochs ( address _start , uint256 _count , bool _usePreviousEpoch ) private view returns ( address [ ] ) { uint256 count = _count ; if ( count == 0 ) { count = numDarknodes ; } address [ ] memory nodes = new address [ ] ( count ) ; uint256 n = 0 ; address next = _start ; if ( next == 0x0 ) { next = store . begin ( ) ; } while ( n < count ) { if ( next == 0x0 ) { break ; } bool includeNext ; if ( _usePreviousEpoch ) { includeNext = isRegisteredInPreviousEpoch ( next ) ; } else { includeNext = isRegistered ( next ) ; } if ( ! includeNext ) { next = store . next ( next ) ; continue ; } nodes [ n ] = next ; next = store . next ( next ) ; n += 1 ; } return nodes ; }
function unlistToken ( address _stablecoin ) public onlyOwner whenNotPaused { tokenStorage_CD . removeStablecoin ( _stablecoin ) ; }
function changeGranularity ( uint256 _granularity ) external onlyOwner { require ( _granularity != 0 , "Invalid granularity" ) ; emit GranularityChanged ( granularity , _granularity ) ; granularity = _granularity ; }
function setFiatContractAddress ( address _fiat ) public onlyOwner { require ( _fiat != address ( 0 ) , "zero address is not allowed" ) ; fiat = FiatContract ( _fiat ) ; }
function removeTrustedContracts ( address [ ] _trusted_contracts ) isOwner public { for ( uint256 i = 0 ; i < _trusted_contracts . length ; i ++ ) { if ( trusted_contracts [ _trusted_contracts [ i ] ] ) { trusted_contracts [ _trusted_contracts [ i ] ] = false ; TrustedContract ( _trusted_contracts [ i ] , false ) ; } } }
function version ( ) public view returns ( string _version ) { return lib . getTokenVersion ( address ( this ) ) ; }
function makeOrder ( uint exchangeNumber , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) external pre_cond ( isOwner ( ) ) pre_cond ( ! isShutDown ) { require ( buyAsset != address ( this ) ) ; require ( quantityHeldInCustodyOfExchange ( sellAsset ) == 0 ) ; require ( module . pricefeed . existsPriceOnAssetPair ( sellAsset , buyAsset ) ) ; var ( isRecent , referencePrice , ) = module . pricefeed . getReferencePrice ( sellAsset , buyAsset ) ; require ( isRecent ) ; require ( module . riskmgmt . isMakePermitted ( module . pricefeed . getOrderPrice ( sellAsset , buyAsset , sellQuantity , buyQuantity ) , referencePrice , sellAsset , buyAsset , sellQuantity , buyQuantity ) ) ; require ( isInAssetList [ buyAsset ] || ownedAssets . length < MAX_FUND_ASSETS ) ; require ( AssetInterface ( sellAsset ) . approve ( exchanges [ exchangeNumber ] . exchange , sellQuantity ) ) ; require ( address ( exchanges [ exchangeNumber ] . exchangeAdapter ) . delegatecall ( bytes4 ( keccak256 ( "makeOrder(address,address,address,uint256,uint256)" ) ) , exchanges [ exchangeNumber ] . exchange , sellAsset , buyAsset , sellQuantity , buyQuantity ) ) ; exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] = exchanges [ exchangeNumber ] . exchangeAdapter . getLastOrderId ( exchanges [ exchangeNumber ] . exchange ) ; require ( exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] != 0 ) ; isInOpenMakeOrder [ sellAsset ] = true ; if ( ! isInAssetList [ buyAsset ] ) { ownedAssets . push ( buyAsset ) ; isInAssetList [ buyAsset ] = true ; } orders . push ( Order ( { exchangeId : exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] , status : OrderStatus . active , orderType : OrderType . make , sellAsset : sellAsset , buyAsset : buyAsset , sellQuantity : sellQuantity , buyQuantity : buyQuantity , timestamp : now , fillQuantity : 0 } ) ) ; OrderUpdated ( exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] ) ; }
function fundWithdrawal ( uint _amount ) public onlyOwner { require ( crowdsaleClosed == true ) ; beneficiary . transfer ( _amount ) ; FundsWithdrawal ( beneficiary , _amount ) ; }
function _cancelItemSale ( Item storage item ) private { item . forSale = false ; itemsForSaleCount -- ; }
function getDank ( uint256 _tokenId ) public view returns ( string dankName , uint256 sellingPrice , address owner ) { Dank storage dank = danks [ _tokenId ] ; dankName = dank . name ; sellingPrice = dankIndexToPrice [ _tokenId ] ; owner = dankIndexToOwner [ _tokenId ] ; }
function _internalTransfer ( address from , address to , uint amount , uint fee , bytes data ) internal returns ( bool ) { require ( to != address ( 0 ) , "Cannot transfer to the 0 address" ) ; require ( to != address ( this ) , "Cannot transfer to the underlying contract" ) ; require ( to != address ( proxy ) , "Cannot transfer to the proxy contract" ) ; tokenState . setBalanceOf ( from , safeSub ( tokenState . balanceOf ( from ) , safeAdd ( amount , fee ) ) ) ; tokenState . setBalanceOf ( to , safeAdd ( tokenState . balanceOf ( to ) , amount ) ) ; tokenState . setBalanceOf ( FEE_ADDRESS , safeAdd ( tokenState . balanceOf ( FEE_ADDRESS ) , fee ) ) ; callTokenFallbackIfNeeded ( from , to , amount , data ) ; emitTransfer ( from , to , amount ) ; emitTransfer ( from , FEE_ADDRESS , fee ) ; return true ; }
function getGroupMembers ( bytes32 _groupName ) public view returns ( address [ ] _members ) { if ( ! isGroupExists ( _groupName ) ) { return ; } Group storage _group = groupName2group [ _groupName ] ; uint _membersCount = _group . membersCount ; if ( _membersCount == 0 ) { return ; } _members = new address [ ] ( _membersCount ) ; for ( uint _userIdx = 0 ; _userIdx < _membersCount ; ++ _userIdx ) { uint _memberIdx = _group . index2globalIndex [ _userIdx + 1 ] ; _members [ _userIdx ] = index2memberAddress [ _memberIdx ] ; } }
function transferOwnership ( address newOwner ) public onlyOwner { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; }
function unfreezeTransfers ( ) external ;
function launchContract ( ) public onlyAdmin returns ( bool launched ) { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; EnableTokenMinting ( true ) ; return true ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( now > deadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } else if ( state == State . Stage3 && now > dateTimeContract . toTimestamp ( 2018 , 12 , 27 , 0 ) ) { state = State . Stage4 ; } else if ( state == State . Stage2 && now > dateTimeContract . toTimestamp ( 2018 , 9 , 28 , 0 ) ) { state = State . Stage3 ; } else if ( state == State . Stage1 && now > dateTimeContract . toTimestamp ( 2018 , 6 , 30 , 0 ) ) { state = State . Stage2 ; } }
function updateDelayTime ( uint256 _newDelay ) public onlyGameManager whenNotPaused { BID_DELAY_TIME = _newDelay ; }
function transferFrom ( address _from , address _to , uint256 _value ) public notFrozen returns ( bool success ) { require ( ! frozenAccounts [ _from ] && ! frozenAccounts [ _to ] ) ; require ( tradable ) ; if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && _value > 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ _from ] -= _value ; balances [ _to ] += _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }
function getDividendIndex ( uint256 _checkpointId ) public view returns ( uint256 [ ] ) { uint256 counter = 0 ; for ( uint256 i = 0 ; i < dividends . length ; i ++ ) { if ( dividends [ i ] . checkpointId == _checkpointId ) { counter ++ ; } } uint256 [ ] memory index = new uint256 [ ] ( counter ) ; counter = 0 ; for ( uint256 j = 0 ; j < dividends . length ; j ++ ) { if ( dividends [ j ] . checkpointId == _checkpointId ) { index [ counter ] = j ; counter ++ ; } } return index ; }
function supportsInterface ( bytes4 interfaceID ) external view returns ( bool ) { return supportedInterfaces [ interfaceID ] && ( interfaceID != 0xffffffff ) ; }
function setFeeBPS ( Data storage self , uint feeBPS ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.bps' , address ( this ) ) ) ; require ( self . Storage . setUint ( id , feeBPS ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function canImplementInterfaceForAddress ( address addr , bytes32 interfaceHash ) public view returns ( bytes32 ) ;
function changeManufacturerWallet ( address _new ) public onlyManufacturer returns ( bool ) { require ( _new != address ( 0 ) , "new address cannot be 0x0" ) ; NetworkMember memory old = network [ msg . sender ] ; require ( old . isManufacturer && old . memberId != 0 , "must be a manufacturer" ) ; require ( ! network [ _new ] . isIRNAdmin , "already an irn admin" ) ; require ( ! network [ _new ] . isManufacturer , "already a manufacturer" ) ; require ( ! network [ _new ] . isIRNNode , "already an irn node" ) ; require ( network [ _new ] . memberId == 0 , "memberId already exists" ) ; network [ _new ] = NetworkMember ( old . isIRNAdmin , old . isManufacturer , old . isIRNNode , old . memberId ) ; require ( pools [ _new ] . balance == 0 && pools [ _new ] . rewardAmount == 0 , "new token pool already exists" ) ; pools [ _new ] . balance = pools [ msg . sender ] . balance ; pools [ _new ] . rewardAmount = pools [ msg . sender ] . rewardAmount ; delete pools [ msg . sender ] ; manufacturerRewards [ old . memberId ] = _new ; delete network [ msg . sender ] ; emit ManufacturerRewardWalletChanged ( msg . sender , _new , old . memberId ) ; return true ; }
function isStarted ( ) public view returns ( bool ) { return ( startTime > 0 ) ; }
function setPreAmounts ( uint256 mtdPreAmountInWei , uint256 ethPreAmountInWei ) isOwner { require ( mtdPreAmountInWei > 0 ) ; require ( ethPreAmountInWei > 0 ) ; mtdPreAmount = mtdPreAmountInWei ; ethPreAmount = ethPreAmountInWei ; updatePrices ( ) ; }
function setFeeParams ( uint feeBps , uint feeMin , uint feeMax , uint feeFlat , bytes feeMsg ) public onlyOwner returns ( bool success ) { require ( lib . setFeeBPS ( feeBps ) , "Error: Unable to set fee contract basis points." ) ; require ( lib . setFeeMin ( feeMin ) , "Error: Unable to set fee contract minimum fee." ) ; require ( lib . setFeeMax ( feeMax ) , "Error: Unable to set fee contract maximum fee." ) ; require ( lib . setFeeFlat ( feeFlat ) , "Error: Unable to set fee contract flat fee." ) ; require ( lib . setFeeMsg ( feeMsg ) , "Error: Unable to set fee contract default message." ) ; return true ; }
function canIssueAttributeType ( address validator , uint256 attributeTypeID ) external view returns ( bool ) ;
function licenseAttributes ( uint256 _licenseId ) public view returns ( uint256 ) { return licenses [ _licenseId ] . attributes ; }
function getModule ( address _module ) external view returns ( bytes32 , address , address , bool , uint8 [ ] ) { return ( modulesToData [ _module ] . name , modulesToData [ _module ] . module , modulesToData [ _module ] . moduleFactory , modulesToData [ _module ] . isArchived , modulesToData [ _module ] . moduleTypes ) ; }
function withdraw ( address addr ) onlyOwner public { addr . transfer ( address ( this ) . balance ) ; }
function balanceOfAt ( address _investor , uint256 _checkpointId ) public view returns ( uint256 ) { require ( _checkpointId <= currentCheckpointId ) ; return TokenLib . getValueAt ( checkpointBalances [ _investor ] , _checkpointId , balanceOf ( _investor ) ) ; }
function claimTokens ( address _claimtoken ) onlyOwner public returns ( bool ) { if ( _claimtoken == 0x0 ) { owner . transfer ( this . balance ) ; return true ; } ERC20 claimtoken = ERC20 ( _claimtoken ) ; uint balance = claimtoken . balanceOf ( this ) ; claimtoken . transfer ( owner , balance ) ; ClaimedTokens ( _claimtoken , owner , balance ) ; return true ; }
function STARTMETADOLLAR ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1 * 1000 ether ; preICOprice = 1 * 1000 ether ; ICOprice = 1 * 1000 ether ; sellPrice = 1 * 950 ether ; updatePrices ( ) ; }
function approveAndCall ( address spender , uint256 tokens , bytes data ) public returns ( bool success ) { requireTrade ( msg . sender ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokens , this , data ) ; return true ; }
function requestVotingRights ( uint _numTokens ) public { require ( token . balanceOf ( msg . sender ) >= _numTokens ) ; voteTokenBalance [ msg . sender ] += _numTokens ; require ( token . transferFrom ( msg . sender , this , _numTokens ) ) ; emit _VotingRightsGranted ( _numTokens , msg . sender ) ; }
function supply ( address asset , uint amount ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . SUPPLY_CONTRACT_PAUSED ) ; } Market storage market = markets [ asset ] ; Balance storage balance = supplyBalances [ msg . sender ] [ asset ] ; SupplyLocalVars memory localResults ; Error err ; uint rateCalculationResultCode ; if ( ! market . isSupported ) { return fail ( Error . MARKET_NOT_SUPPORTED , FailureInfo . SUPPLY_MARKET_NOT_SUPPORTED ) ; } err = checkTransferIn ( asset , msg . sender , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_TRANSFER_IN_NOT_POSSIBLE ) ; } ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED ) ; } ( err , localResults . userSupplyCurrent ) = calculateBalance ( balance . principal , balance . interestIndex , localResults . newSupplyIndex ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . userSupplyUpdated ) = add ( localResults . userSupplyCurrent , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . newTotalSupply ) = addThenSub ( market . totalSupply , localResults . userSupplyUpdated , balance . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED ) ; } localResults . currentCash = getCash ( asset ) ; ( err , localResults . updatedCash ) = add ( localResults . currentCash , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa ) = market . interestRateModel . getSupplyRate ( asset , localResults . updatedCash , market . totalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa ) = market . interestRateModel . getBorrowRate ( asset , localResults . updatedCash , market . totalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } err = doTransferIn ( asset , msg . sender , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_TRANSFER_IN_FAILED ) ; } market . blockNumber = getBlockNumber ( ) ; market . totalSupply = localResults . newTotalSupply ; market . supplyRateMantissa = localResults . newSupplyRateMantissa ; market . supplyIndex = localResults . newSupplyIndex ; market . borrowRateMantissa = localResults . newBorrowRateMantissa ; market . borrowIndex = localResults . newBorrowIndex ; localResults . startingBalance = balance . principal ; balance . principal = localResults . userSupplyUpdated ; balance . interestIndex = localResults . newSupplyIndex ; emit SupplyReceived ( msg . sender , asset , amount , localResults . startingBalance , localResults . userSupplyUpdated ) ; return uint ( Error . NO_ERROR ) ; }
function getOwner ( Campaign storage _campaign ) internal view returns ( address _owner ) { return _campaign . owner ; }
function blockPendingTx ( uint _txIdx ) returns ( bool ) ;
function collectMilestonePayment ( uint _idMilestone ) onlyRecipient campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . Completed ) || ( now < milestone . doneTime + milestone . reviewTime ) ) throw ; doPayment ( _idMilestone ) ; }
function claimRefundFor ( address _beneficiary ) public afterSaleFail whenNotPaused { require ( _beneficiary != address ( 0 ) ) ; vault . refund ( _beneficiary ) ; }
function assignPreicoTokens ( ) public onlyOwnerAndDirector { require ( ! assignedPreico ) ; assignedPreico = true ; _freezeTransfer ( 0xb424958766e736827Be5A441bA2A54bEeF54fC7C , 10 * 19514560000000000000000 ) ; _freezeTransfer ( 0xF5dF9C2aAe5118b64Cda30eBb8d85EbE65A03990 , 10 * 36084880000000000000000 ) ; _freezeTransfer ( 0x5D8aCe48970dce4bcD7f985eDb24f5459Ef184Ec , 10 * 2492880000000000000000 ) ; _freezeTransfer ( 0xcD6d5b09a34562a1ED7857B19b32bED77417655b , 10 * 1660880000000000000000 ) ; _freezeTransfer ( 0x50f73AC8435E4e500e37FAb8802bcB840bf4b8B8 , 10 * 94896880000000000000000 ) ; _freezeTransfer ( 0x65Aa068590216cb088f4da28190d8815C31aB330 , 10 * 16075280000000000000000 ) ; _freezeTransfer ( 0x2046838D148196a5117C4026E21C165785bD3982 , 10 * 5893680000000000000000 ) ; _freezeTransfer ( 0x458e1f1050C34f5D125437fcEA0Df0aA9212EDa2 , 10 * 32772040882120167215360 ) ; _freezeTransfer ( 0x12B687E19Cef53b2A709e9b98C4d1973850cA53F , 10 * 70956080000000000000000 ) ; _freezeTransfer ( 0x1Cf5daAB09155aaC1716Aa92937eC1c6D45720c7 , 10 * 3948880000000000000000 ) ; _freezeTransfer ( 0x32fAAdFdC7938E7FbC7386CcF546c5fc382ed094 , 10 * 88188880000000000000000 ) ; _freezeTransfer ( 0xC4eA6C0e9d95d957e75D1EB1Fbe15694CD98336c , 10 * 81948880000000000000000 ) ; _freezeTransfer ( 0xB97D3d579d35a479c20D28988A459E3F35692B05 , 10 * 121680000000000000000 ) ; _freezeTransfer ( 0x65AD745047633C3402d4BC5382f72EA3A9eCFe47 , 10 * 5196880000000000000000 ) ; _freezeTransfer ( 0xd0BEF2Fb95193f429f0075e442938F5d829a33c8 , 10 * 223388880000000000000000 ) ; _freezeTransfer ( 0x9Fc87C3d44A6374D48b2786C46204F673b0Ae236 , 10 * 28284880000000000000000 ) ; _freezeTransfer ( 0x42C73b8945a82041B06428359a94403a2e882406 , 10 * 13080080000000000000000 ) ; _freezeTransfer ( 0xa4c9595b90BBa7B4d805e555E477200C61711F3a , 10 * 6590480000000000000000 ) ; _freezeTransfer ( 0xb93b8ceD7CD86a667E12104831b4d514365F9DF8 , 10 * 116358235759665569280 ) ; _freezeTransfer ( 0xa94F999b3f76EB7b2Ba7B17fC37E912Fa2538a87 , 10 * 10389600000000000000000 ) ; _freezeTransfer ( 0xD65B9b98ca08024C3c19868d42C88A3E47D67120 , 10 * 25892880000000000000000 ) ; _freezeTransfer ( 0x3a978a9Cc36f1FE5Aab6D31E41c08d8380ad0ACB , 10 * 548080000000000000000 ) ; _freezeTransfer ( 0xBD46d909D55d760E2f79C5838c5C42E45c0a853A , 10 * 7526480000000000000000 ) ; _freezeTransfer ( 0xdD9d289d4699fDa518cf91EaFA029710e3Cbb7AA , 10 * 3324880000000000000000 ) ; _freezeTransfer ( 0x8671B362902C3839ae9b4bc099fd24CdeFA026F4 , 10 * 21836880000000000000000 ) ; _freezeTransfer ( 0xf3C25Ee648031B28ADEBDD30c91056c2c5cd9C6b , 10 * 132284880000000000000000 ) ; _freezeTransfer ( 0x1A2392fB72255eAe19BB626678125A506a93E363 , 10 * 61772880000000000000000 ) ; _freezeTransfer ( 0xCE2cEa425f7635557CFC00E18bc338DdE5B16C9A , 10 * 105360320000000000000000 ) ; _freezeTransfer ( 0x952AD1a2891506AC442D95DA4C0F1AE70A27b677 , 10 * 100252880000000000000000 ) ; _freezeTransfer ( 0x5eE1fC4D251143Da96db2a5cD61507f2203bf7b7 , 10 * 80492880000000000000000 ) ; }
function claimTokens ( ) respectTimeFrame isValidState payable public { require ( msg . value > 0 ) ; uint256 tokens = msg . value . mul ( tokenExchangeRate ) ; require ( isWithinCap ( tokens ) ) ; uint256 checkedSupply = assignedSupply . add ( tokens ) ; require ( checkedSupply . add ( shitFund ) <= totalSupply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; purchases [ msg . sender ] = purchases [ msg . sender ] . add ( tokens ) ; assignedSupply = checkedSupply ; ClaimSHIT ( msg . sender , tokens ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _value <= allowed [ _from ] [ msg . sender ] , "requesting more token than allowed" ) ; _transfer ( _from , _to , _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; return true ; }
function thawTransfers ( ) public onlyAdmin returns ( bool thawed ) { tokenTransfersFrozen = false ; ThawTransfers ( msg . sender , true ) ; return true ; }
function getTokenFrozenBalance ( Data storage self , string currency , address account ) internal view returns ( uint frozenBalance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.frozen' , currency , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getUint ( id ) ; }
function icoBuy ( ) public icoPhase ( ) payable isActive { prizePool . transfer ( msg . value ) ; raisedIcoValue = raisedIcoValue . add ( msg . value ) ; uint256 tokenAmount = calculateTokenAmountICO ( msg . value ) ; require ( icoPool >= tokenAmount ) ; icoPool = icoPool . sub ( tokenAmount ) ; balanceOf [ msg . sender ] += tokenAmount ; TransferEvent ( prizePool , msg . sender , tokenAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool ) ;
function proxyPayment ( address _owner ) payable public returns ( bool ) { doPayment ( _owner ) ; return true ; }
function batchSend ( address [ ] _recipients , uint256 [ ] _amounts , bytes _userData ) external whenNotPaused whenAccountNotFrozen ( msg . sender ) { require ( _recipients . length == _amounts . length , "The lengths of _recipients and _amounts should be the same." ) ; for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { doSend ( msg . sender , msg . sender , _recipients [ i ] , _amounts [ i ] , _userData , "" , true ) ; } }
function transfer ( address destination , uint256 amount ) public tradable ( msg . sender ) returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; balances [ destination ] = balances [ destination ] . add ( amount ) ; emit Transfer ( msg . sender , destination , amount ) ; return true ; }
function setCampaignEndPointById ( bytes32 _bidId , string _endPoint ) public onlyIfCampaignExists ( "setCampaignEndPointById" , _bidId ) onlyIfWhitelisted ( "setCampaignEndPointById" , msg . sender ) { campaignEndPoints [ _bidId ] = _endPoint ; emit ExtendedCampaignEndPointUpdated ( _bidId , _endPoint ) ; }
function transfer ( address _to , uint256 _tokenId ) external onlyOwnerOf ( _tokenId ) { _clearApprovalAndTransfer ( msg . sender , _to , _tokenId ) ; }
function getTopBidders ( ) external view returns ( address [ 100 ] ) { address [ 100 ] memory tempArray ; for ( uint i = 0 ; i < 100 ; ++ i ) { tempArray [ i ] = _topBids [ i ] . bidderAddress ; } return tempArray ; }
function transferAnyERC20Token ( address _tokenAddress , uint256 _amount ) onlyOwner public returns ( bool success ) { return AumonetERC223 ( _tokenAddress ) . transfer ( owner , _amount ) ; }
function _buyTokens ( address _beneficiary , uint256 _investmentValue , uint256 _rate , FundRaiseType _fundRaiseType ) internal nonReentrant whenNotPaused returns ( uint256 , uint256 ) { if ( ! allowBeneficialInvestments ) { require ( _beneficiary == msg . sender , "Beneficiary does not match funder" ) ; } require ( isOpen ( ) , "STO is not open" ) ; require ( _investmentValue > 0 , "No funds were sent" ) ; uint256 investedUSD = DecimalMath . mul ( _rate , _investmentValue ) ; uint256 originalUSD = investedUSD ; require ( investedUSD . add ( investorInvestedUSD [ _beneficiary ] ) >= minimumInvestmentUSD , "Total investment < minimumInvestmentUSD" ) ; if ( ! accredited [ _beneficiary ] ) { uint256 investorLimitUSD = ( nonAccreditedLimitUSDOverride [ _beneficiary ] == 0 ) ? nonAccreditedLimitUSD : nonAccreditedLimitUSDOverride [ _beneficiary ] ; require ( investorInvestedUSD [ _beneficiary ] < investorLimitUSD , "Non-accredited investor has reached limit" ) ; if ( investedUSD . add ( investorInvestedUSD [ _beneficiary ] ) > investorLimitUSD ) investedUSD = investorLimitUSD . sub ( investorInvestedUSD [ _beneficiary ] ) ; } uint256 spentUSD ; for ( uint8 i = currentTier ; i < ratePerTier . length ; i ++ ) { if ( currentTier != i ) currentTier = i ; if ( mintedPerTierTotal [ i ] < tokensPerTierTotal [ i ] ) spentUSD = spentUSD . add ( _calculateTier ( _beneficiary , i , investedUSD . sub ( spentUSD ) , _fundRaiseType ) ) ; if ( investedUSD == spentUSD ) break ; } if ( spentUSD > 0 ) { if ( investorInvestedUSD [ _beneficiary ] == 0 ) investorCount = investorCount + 1 ; investorInvestedUSD [ _beneficiary ] = investorInvestedUSD [ _beneficiary ] . add ( spentUSD ) ; fundsRaisedUSD = fundsRaisedUSD . add ( spentUSD ) ; } uint256 spentValue ; if ( spentUSD == 0 ) { spentValue = 0 ; } else { spentValue = DecimalMath . mul ( DecimalMath . div ( spentUSD , originalUSD ) , _investmentValue ) ; } return ( spentUSD , spentValue ) ; }
function setTokenURIBase ( string _tokenURI ) public anyOperator { _setTokenURIBase ( _tokenURI ) ; }
function freezeTransfers ( ) public onlyAdmin returns ( bool frozen ) { tokenTransfersFrozen = true ; FreezeTransfers ( msg . sender , true ) ; return true ; }
function pause ( ) external whenNotPaused onlyOwner { set ( PAUSED , true ) ; emit Pause ( now ) ; }
function price ( ) public view returns ( uint256 _price ) { return tokenPerEth ; }
function getTribalMask ( uint256 _tokenId ) public view returns ( string maskName , uint256 basePrice , uint256 currentPrice , address currentOwner ) { TribalMask storage mask = tribalMasks [ _tokenId ] ; maskName = mask . name ; basePrice = mask . basePrice ; currentPrice = priceOf ( _tokenId ) ; currentOwner = tokenIndexToOwner [ _tokenId ] ; }
function isCompetitionAllowed ( address user ) view returns ( bool ) { return isWhitelisted [ user ] ; }
function totalCollections ( ) public view returns ( uint256 ) { return collectionNames . length ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = ponyIndexToOwner [ _tokenId ] ; }
function canSafeTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) ;
function buyToken ( ) internal { uint256 value = msg . value ; address sender = msg . sender ; require ( ! icoIsClosed ) ; require ( ! frozenAccount [ sender ] ) ; require ( value > 0 ) ; require ( currentTokenPrice > 0 ) ; uint256 detracted = currentTokenPrice / ( commission1 * commission2 ) ; uint256 amount = value / detracted ; uint256 moneyBack = value - ( amount * detracted ) ; require ( tokenBalanceOf [ this ] >= amount ) ; amountOfInvestments = amountOfInvestments + ( value - moneyBack ) ; updatePrices ( ) ; _transfer ( this , sender , amount ) ; if ( ! minimalGoalReached ) { checkMinimalGoal ( ) ; } if ( moneyBack > 0 ) { sender . transfer ( moneyBack ) ; } }
function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( "configure(uint256,uint256,uint256,uint256,uint8,address)" ) ) ; }
function enableTransfers ( ) public onlyWhitelisted { require ( icoEndDate > 0 ) ; require ( now >= icoEndDate ) ; require ( ! transfersEnabled ) ; transfersEnabled = true ; }
function forceTransfer ( address _from , address _to , uint256 _value , bytes _data , bytes _log ) external ;
function owner ( ) external view returns ( address ) ;
function setDelegateAndLockTokens ( uint tokensToLock , address delegate ) public onlyShareholders onlyUndelegated notSelf { lockedDelegatingTokens [ msg . sender ] = tokensToLock ; delegatedAmountsByDelegate [ delegate ] = SafeMath . add ( delegatedAmountsByDelegate [ delegate ] , tokensToLock ) ; totalLockedTokens = SafeMath . add ( totalLockedTokens , tokensToLock ) ; delegatesByDelegator [ msg . sender ] = delegate ; require ( sharesTokenAddress . transferFrom ( msg . sender , tokenLocker , tokensToLock ) ) ; require ( sharesTokenAddress . balanceOf ( tokenLocker ) == totalLockedTokens ) ; TokensDelegated ( msg . sender , tokensToLock , delegate ) ; }
function blacklistEscapeToken ( address _token ) internal { escapeBlacklist [ _token ] = true ; EscapeHatchBlackistedToken ( _token ) ; }
function getTokensByOwner ( address _owner ) external view returns ( address [ ] ) ;
function disableTokenMinting ( ) public onlyOwner returns ( bool disabled ) { tokenMintingEnabled = false ; TokenMintingDisabled ( msg . sender , true ) ; return true ; }
function addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) external onlyOwner nonReentrant { IModuleRegistry ( moduleRegistry ) . useModule ( _moduleFactory ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; uint8 [ ] memory moduleTypes = moduleFactory . getTypes ( ) ; uint256 moduleCost = moduleFactory . getSetupCost ( ) ; require ( moduleCost <= _maxCost , "Invalid cost" ) ; ERC20 ( polyToken ) . approve ( _moduleFactory , moduleCost ) ; address module = moduleFactory . deploy ( _data ) ; require ( modulesToData [ module ] . module == address ( 0 ) , "Module exists" ) ; ERC20 ( polyToken ) . approve ( module , _budget ) ; bytes32 moduleName = moduleFactory . getName ( ) ; uint256 [ ] memory moduleIndexes = new uint256 [ ] ( moduleTypes . length ) ; uint256 i ; for ( i = 0 ; i < moduleTypes . length ; i ++ ) { moduleIndexes [ i ] = modules [ moduleTypes [ i ] ] . length ; modules [ moduleTypes [ i ] ] . push ( module ) ; } modulesToData [ module ] = TokenLib . ModuleData ( moduleName , module , _moduleFactory , false , moduleTypes , moduleIndexes , names [ moduleName ] . length ) ; names [ moduleName ] . push ( module ) ; emit ModuleAdded ( moduleTypes , moduleName , _moduleFactory , module , moduleCost , _budget , now ) ; }
function symbol ( ) public pure returns ( string ) { return "KCT" ; }
function deposit ( Data storage self , string currency , address account , uint amount , string issuerFirm ) internal returns ( bool success ) { bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , account ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.issued' , currency , issuerFirm ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.supply' , currency ) ) ; require ( self . Storage . setUint ( id_a , self . Storage . getUint ( id_a ) . add ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( self . Storage . setUint ( id_b , self . Storage . getUint ( id_b ) . add ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( self . Storage . setUint ( id_c , self . Storage . getUint ( id_c ) . add ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; emit Deposit ( currency , account , amount , issuerFirm ) ; return true ; }
function mintMulti ( address [ ] _investors , uint256 [ ] _values ) external returns ( bool success ) ;
function unitBattlePLATCost ( uint256 cardId ) external constant returns ( uint256 ) { return SafeMath . mul ( battlecardInfo [ cardId ] . ethCost , PLATPrice ) ; }
function powerUpContract ( ) external onlyOwner { require ( ! contractPoweredUp ) ; require ( parsecToken . balanceOf ( this ) >= PARSEC_CREDITS_MINIMAL_AMOUNT ) ; contractPoweredUp = true ; }
function changeAllowAllWhitelistIssuances ( bool _allowAllWhitelistIssuances ) public withPerm ( FLAGS ) { allowAllWhitelistIssuances = _allowAllWhitelistIssuances ; emit AllowAllWhitelistIssuances ( _allowAllWhitelistIssuances ) ; }
function isSubscriptionProduct ( uint256 _productId ) public view returns ( bool ) { return intervalOf ( _productId ) > 0 ; }
function addProduct ( bytes32 _mappingID , uint _index , string _productID , string _quantity , string _attributes ) private { wineries [ _mappingID ] [ _index ] . prods . push ( Product ( _productID , _quantity , _attributes ) ) ; }
function mul ( uint256 x , uint256 y ) internal pure returns ( uint256 z ) { z = SafeMath . add ( SafeMath . mul ( x , y ) , ( 10 ** 18 ) / 2 ) / ( 10 ** 18 ) ; }
function canBeSet ( bytes32 _propID ) view public returns ( bool ) { ParamProposal memory prop = proposals [ _propID ] ; return ( now > prop . appExpiry && now < prop . processBy && prop . challengeID == 0 ) ; }
function createCDPLeveragedAllDai ( ) public returns ( bytes32 id ) { return createCDPLeveragedDai ( dai . balanceOf ( msg . sender ) ) ; }
function thawTransfers ( ) onlyOwner returns ( bool thawed ) { tokenTransfersFrozen = false ; ThawTransfers ( msg . sender , true ) ; return true ; }
function confirmProofOfWork ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender == job . evaluator ) ; job . proofOfLastWorkVerified = true ; emit ProofOfWorkConfirmed ( _JobID , job . evaluator , true ) ; }
function execute ( bytes32 _buyID , bytes32 _sellID , address _buyer , address _seller , TokenPair memory _tokens ) private { SettlementDetails memory settlementDetails = ( orderDetails [ _buyID ] . settlementID == RENEX_ATOMIC_SETTLEMENT_ID ) ? settlementDetails = calculateAtomicFees ( _buyID , _sellID , _tokens ) : settlementDetails = calculateSettlementDetails ( _buyID , _sellID , _tokens ) ; renExBalancesContract . transferBalanceWithFee ( _buyer , _seller , settlementDetails . leftTokenAddress , settlementDetails . leftVolume , settlementDetails . leftTokenFee , orderSubmitter [ _buyID ] ) ; renExBalancesContract . transferBalanceWithFee ( _seller , _buyer , settlementDetails . rightTokenAddress , settlementDetails . rightVolume , settlementDetails . rightTokenFee , orderSubmitter [ _sellID ] ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { adjustInvestorCount ( msg . sender , _to , _value ) ; require ( verifyTransfer ( msg . sender , _to , _value ) , "Transfer is not valid" ) ; adjustBalanceCheckpoints ( msg . sender ) ; adjustBalanceCheckpoints ( _to ) ; require ( super . transfer ( _to , _value ) ) ; return true ; }
function validPurchase ( ) internal constant returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value > 0 ; bool withinTokenLimit = tokensRaised < maxTokensRaised ; bool minimumPurchase = msg . value >= minPurchase ; bool hasBalanceAvailable = crowdsaleBalances [ msg . sender ] < maxPurchase ; bool limitGas = tx . gasprice <= limitGasPrice ; return withinPeriod && nonZeroPurchase && withinTokenLimit && minimumPurchase && hasBalanceAvailable && limitGas ; }
function revokeOperator ( address _operator ) external { require ( _operator != msg . sender ) ; require ( mAuthorized [ _operator ] [ msg . sender ] ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = true ; } else { mAuthorized [ _operator ] [ msg . sender ] = false ; } emit RevokedOperator ( _operator , msg . sender ) ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalLoans = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 loanId ; for ( loanId = 0 ; loanId <= totalLoans ; loanId ++ ) { if ( loans [ loanId ] . lender == _owner && loans [ loanId ] . status == Status . lent ) { result [ resultIndex ] = loanId ; resultIndex ++ ; } } return result ; } }
function doInclusionChecks ( bytes prevTxBytes , bytes exitingTxBytes , bytes prevTxInclusionProof , bytes exitingTxInclusionProof , bytes signature , uint256 [ 2 ] blocks ) private view { if ( blocks [ 1 ] % childBlockInterval != 0 ) { checkIncludedAndSigned ( exitingTxBytes , exitingTxInclusionProof , signature , blocks [ 1 ] ) ; } else { checkBothIncludedAndSigned ( prevTxBytes , exitingTxBytes , prevTxInclusionProof , exitingTxInclusionProof , signature , blocks ) ; } }
function setTokenURI ( uint256 _tokenId , string _uri ) auth ( MINT_ROLE ) public { _setTokenURI ( _tokenId , _uri ) ; }
function freezeMultiAccounts ( address [ ] addresses , bool freeze ) onlyOwner public { for ( uint i = 0 ; i < addresses . length ; i ++ ) { frozenAccount [ addresses [ i ] ] = freeze ; FrozenFunds ( addresses [ i ] , freeze ) ; } }
function getPow ( uint256 _tokenId ) public view returns ( uint256 Id , string powName , uint256 sellingPrice , address owner , uint gameId , uint gameItemId ) { Pow storage pow = pows [ _tokenId ] ; Id = _tokenId ; powName = pow . name ; sellingPrice = powIndexToPrice [ _tokenId ] ; owner = powIndexToOwner [ _tokenId ] ; gameId = pow . gameId ; gameItemId = pow . gameItemId ; }
function enableTransfers ( bool _transfersEnabled ) onlyController { transfersEnabled = _transfersEnabled ; }
function findEndpointByAddress ( address eth_address ) public view returns ( string endpoint ) { return address_to_endpoint [ eth_address ] ; }
function setFeeToken ( address _feeToken ) external validAddress ( _feeToken ) onlyOwner { feeToken = Fee ( _feeToken ) ; }
function mint ( address _address , uint _value ) onlyAccountAddressForSponsee { balances [ _address ] = balances [ _address ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; if ( totalSupply > cap ) { revert ( ) ; } LogMint ( _address , _value ) ; Transfer ( address ( 0x0 ) , _address , _value ) ; }
function getSig ( bytes _data ) internal pure returns ( bytes4 sig ) { uint len = _data . length < 4 ? _data . length : 4 ; for ( uint i = 0 ; i < len ; i ++ ) { sig = bytes4 ( uint ( sig ) + uint ( _data [ i ] ) * ( 2 ** ( 8 * ( len - 1 - i ) ) ) ) ; } }
function newPayment ( address _token , address _receiver , uint256 _amount , uint64 _initialPaymentTime , uint64 _interval , uint64 _maxRepeats , string _reference ) external authP ( CREATE_PAYMENTS_ROLE , arr ( _token , _receiver , _amount , _interval , _maxRepeats ) ) transitionsPeriod returns ( uint256 paymentId ) { require ( _amount > 0 , ERROR_NEW_PAYMENT_AMOUNT_ZERO ) ; if ( _initialPaymentTime <= getTimestamp64 ( ) && _maxRepeats == 1 ) { _makePaymentTransaction ( _token , _receiver , _amount , NO_PAYMENT , 0 , _reference ) ; return ; } require ( settings . budgets [ _token ] >= _amount || ! settings . hasBudget [ _token ] , ERROR_BUDGET ) ; paymentId = paymentsNextIndex ++ ; emit NewPayment ( paymentId , _receiver , _maxRepeats , _reference ) ; Payment storage payment = payments [ paymentId ] ; payment . token = _token ; payment . receiver = _receiver ; payment . amount = _amount ; payment . initialPaymentTime = _initialPaymentTime ; payment . interval = _interval ; payment . maxRepeats = _maxRepeats ; payment . createdBy = msg . sender ; if ( nextPaymentTime ( paymentId ) <= getTimestamp64 ( ) ) { _executePayment ( paymentId ) ; } }
function enableMigration ( IMigrationTarget migration ) public ;
function buy ( uint _imageId ) public payable { require ( isImageOnSale ( _imageId ) ) ; require ( msg . value >= sellAds [ _imageId ] . price ) ; removeOrder ( _imageId ) ; address _creator ; address _imageOwner = digitalPrintImageContract . ownerOf ( _imageId ) ; ( , , _creator , , ) = digitalPrintImageContract . imageMetadata ( _imageId ) ; balances [ _creator ] += msg . value * 2 / 100 ; balances [ owner ] += msg . value * 3 / 100 ; balances [ _imageOwner ] += msg . value * 95 / 100 ; digitalPrintImageContract . transferFromMarketplace ( sellAds [ _imageId ] . exchanger , msg . sender , _imageId ) ; emit ImageBought ( _imageId , msg . sender , msg . value ) ; }
function setEthAmount ( uint256 ethAmountInWei ) isOwner { require ( ethAmountInWei > 0 ) ; require ( ethAmount != ethAmountInWei ) ; ethAmount = ethAmountInWei ; updatePrices ( ) ; }
function fundingCap ( ) public constant returns ( uint256 amount ) { }
function totalSupply ( ) public view returns ( uint256 ) { return elements . length ; }
function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( synthesizingAuction != address ( 0 ) ) ; require ( geneSynthesis != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
function mintTokens ( uint256 _amount ) external onlyOwner returns ( bool ) { return _mintTokens ( _amount ) ; }
function exchangeSynthsForSynthetix ( uint synthAmount ) public pricesNotStale notPaused returns ( uint ) { uint synthetixToSend = synthetixReceivedForSynths ( synthAmount ) ; synth . transferFrom ( msg . sender , fundsWallet , synthAmount ) ; synthetix . transfer ( msg . sender , synthetixToSend ) ; emit Exchange ( "sUSD" , synthAmount , "SNX" , synthetixToSend ) ; return synthetixToSend ; }
function transferFromPreSigned ( bytes _signature , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = transferFromPreSignedHashing ( address ( this ) , _from , _to , _value , _fee , _nonce ) ; address spender = recover ( hashedTx , _signature ) ; require ( spender != address ( 0 ) ) ; nonces [ _signature ] = true ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ spender ] = allowed [ _from ] [ spender ] . sub ( _value ) ; balances [ spender ] = balances [ spender ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; nonces [ _signature ] = true ; emit Transfer ( _from , _to , _value ) ; emit Transfer ( spender , msg . sender , _fee ) ; return true ; }
function changeCountryLimit ( uint _countryCode , uint _limit ) onlyOracleOrOwner external returns ( uint ) { uint _countryIndex = countryIndex [ _countryCode ] ; require ( _countryIndex != 0 ) ; uint _currentTokenHolderNumber = countryLimitsList [ _countryIndex ] . currentTokenHolderNumber ; if ( _currentTokenHolderNumber > _limit ) { return DATA_CONTROLLER_CURRENT_WRONG_LIMIT ; } countryLimitsList [ _countryIndex ] . maxTokenHolderNumber = _limit ; _emitCountryCodeChanged ( _countryIndex , _countryCode , _limit ) ; return OK ; }
function getValueAt ( Checkpoint [ ] storage checkpoints , uint256 _checkpointId , uint256 _currentValue ) internal view returns ( uint256 ) { require ( _checkpointId <= currentCheckpointId ) ; if ( _checkpointId == 0 ) { return 0 ; } if ( checkpoints . length == 0 ) { return _currentValue ; } if ( checkpoints [ 0 ] . checkpointId >= _checkpointId ) { return checkpoints [ 0 ] . value ; } if ( checkpoints [ checkpoints . length - 1 ] . checkpointId < _checkpointId ) { return _currentValue ; } if ( checkpoints [ checkpoints . length - 1 ] . checkpointId == _checkpointId ) { return checkpoints [ checkpoints . length - 1 ] . value ; } uint256 min = 0 ; uint256 max = checkpoints . length - 1 ; while ( max > min ) { uint256 mid = ( max + min ) / 2 ; if ( checkpoints [ mid ] . checkpointId == _checkpointId ) { max = mid ; break ; } if ( checkpoints [ mid ] . checkpointId < _checkpointId ) { min = mid + 1 ; } else { max = mid ; } } return checkpoints [ max ] . value ; }
function _pause ( ) internal { require ( ! paused ) ; paused = true ; emit Pause ( now ) ; }
function destroyAndSend ( address _recipient ) public onlyOwner { selfdestruct ( _recipient ) ; }
function equals ( string a , string b ) internal pure returns ( bool result ) { if ( keccak256 ( abi . encodePacked ( a ) ) == keccak256 ( abi . encodePacked ( b ) ) ) { return true ; } return false ; }
function transferToAddress ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceSignature_ERC721Enumerable ) || ( _interfaceID == InterfaceSignature_ERC721Metadata ) ) ; }
function getPendingReward ( ERC20 _token , address _holder ) public constant returns ( uint ) { uint acc = 0 ; for ( uint i = nextDepositToPayout [ msg . sender ] ; i < deposits . length ; i ++ ) { Deposit storage d = deposits [ i ] ; if ( ( d . token == _token ) && ( ! d . canceled ) && ( ! isDepositSkiped ( _holder , i ) ) ) { acc += d . amount * rewardToken . balanceOfAt ( _holder , d . block ) / rewardToken . totalSupplyAt ( d . block ) ; } } return acc ; }
function deregisterToken ( uint32 _tokenCode ) external onlyOwner { require ( tokens [ _tokenCode ] . registered , "not registered" ) ; tokens [ _tokenCode ] . registered = false ; emit LogTokenDeregistered ( _tokenCode ) ; }
function removeSigner ( address _signer ) public onlyOwner { signers [ _signer ] = false ; }
function getStageByBlockNumber ( uint256 _blockNumber ) public view returns ( uint8 ) { if ( ! isDuringSalePeriod ( _blockNumber ) ) revert ( ) ; uint256 totalBlocks = safeSub ( endBlock , startBlock ) ; uint256 numOfBlockPassed = safeSub ( _blockNumber , startBlock ) ; return uint8 ( safeDiv ( safeMul ( totalStages , numOfBlockPassed ) , totalBlocks ) + 1 ) ; }
function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { amountToGive = data . amountToGive ; }
function mint ( address _to , uint256 _amount ) public returns ( bool ) { require ( totalSupply ( ) . add ( _amount ) <= cap ) ; return super . mint ( _to , _amount ) ; }
function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 6700000000 ; }
function updateBrokerVerifierContract ( RenExBrokerVerifier _newBrokerVerifierContract ) external onlyOwner { emit LogBrokerVerifierContractUpdated ( brokerVerifierContract , _newBrokerVerifierContract ) ; brokerVerifierContract = _newBrokerVerifierContract ; }
function reclaimToken ( address _token ) external onlyAdmin { ERC20 erc20 = ERC20 ( _token ) ; uint256 balance = erc20 . balanceOf ( this ) ; erc20 . safeTransfer ( msg . sender , balance ) ; }
function unpause ( ) public onlyAdmin whenPaused { require ( address ( saleAuction ) != address ( 0 ) ) ; require ( address ( sanctuary ) != address ( 0 ) ) ; require ( address ( battleProvider ) != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
function addAddressToAccountFor ( address _newAddress , bytes _newAddressSig , bytes _senderSig , address _sender , bytes32 _nonce ) public onlyRegistryAdmin { addAddressToAccountForUser ( _newAddress , _newAddressSig , _senderSig , _sender , _nonce ) ; }
function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( _getOwner ( ) ) ; _setOwner ( address ( 0 ) ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return erc20Store . balances ( _owner ) ; }
function getPlayerRemainingTime ( uint boardId , PlayerColor color ) view external returns ( uint , uint , uint ) { GoBoard storage board = allBoards [ boardId ] ; require ( board . status == BoardStatus . InProgress ) ; uint timePeriods = getPlayerTimePeriods ( board , color ) ; uint totalTimeRemaining = timePeriods * PLAYER_TURN_SINGLE_PERIOD ; if ( color == board . nextTurnColor ) { uint timePeriodsUsed = getTimePeriodsUsed ( board . lastUpdate ) ; if ( timePeriods > timePeriodsUsed ) { timePeriods -= timePeriodsUsed ; } else { timePeriods = 0 ; } uint timeUsed = ( now - board . lastUpdate ) ; if ( totalTimeRemaining > timeUsed ) { totalTimeRemaining -= timeUsed ; } else { totalTimeRemaining = 0 ; } } return ( timePeriods , PLAYER_TURN_SINGLE_PERIOD , totalTimeRemaining ) ; }
function requestArbitration ( bytes32 question_id ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitycheck . notifyOfArbitrationRequest ( question_id , msg . sender ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! realitycheck . isFinalized ( question_id ) ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }
function setFinancialOfficer ( address _financialOfficerAddress ) external onlyExecutiveOfficer { require ( _financialOfficerAddress != address ( 0 ) ) ; financialOfficerAddress = _financialOfficerAddress ; }
function getToken ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; Token storage token = collectibleIdx [ _tokenId ] ; sellingPrice = token . price ; if ( sellingPrice == 0 ) sellingPrice = getInitialPriceOfToken ( _tokenId ) ; owner = token . owner ; nextSellingPrice = getNextPrice ( sellingPrice , _tokenId ) ; }
function addValidator ( address _validator ) public onlyOwner { validators [ _validator ] = true ; emit ValidatorAdded ( _validator ) ; }
function claimWinnings ( bytes32 question_id , bytes32 [ ] history_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) public { }
function createChannelDelegate ( address _sender_address , address _receiver_address , uint192 _deposit ) isTrustedContract external { createChannelPrivate ( _sender_address , _receiver_address , _deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _deposit ) ) ; }
function verifyDeed ( string document ) public constant returns ( bool ) { uint256 documentHash = uint256 ( keccak256 ( document ) ) ; return documentRegistry [ documentHash ] > 0 ; }
function mint ( address _to , uint256 _amount ) public requiresWhitelistedToken whenNotPaused { _mint ( _to , _amount ) ; }
function setWhitelistedOnly ( bool _isWhitelistOnly ) onlyOwner public { if ( isTransferWhitelistOnly != _isWhitelistOnly ) { isTransferWhitelistOnly = _isWhitelistOnly ; TransferWhitelistOnly ( _isWhitelistOnly ) ; } }
function finalizeCampaign ( ) public { require ( ( campaignState == 1 ) || ( ( campaignState != 0 ) && ( now > tCampaignEnd + ( 2880 minutes ) ) ) ) ; campaignState = 0 ; trusteeVaultAddr . transfer ( this . balance ) ; uint256 bountyTokens = ( tokensGenerated . mul ( PRCT_BOUNTY ) ) . div ( 100 ) ; uint256 teamTokens = ( tokensGenerated . mul ( PRCT_TEAM ) ) . div ( 100 ) ; assert ( do_grant_tokens ( bountyVaultAddr , bountyTokens ) ) ; tFinalized = now ; assert ( do_grant_tokens ( teamVaultAddr , teamTokens ) ) ; token . finalize ( ) ; Finalized ( tFinalized ) ; }
function realitycheck ( ) external view returns ( Realitio ) { return realitio ; }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool ) { var avail = allowances [ _from ] [ msg . sender ] > balances [ _from ] ? balances [ _from ] : allowances [ _from ] [ msg . sender ] ; if ( avail >= _value ) { allowances [ _from ] [ msg . sender ] -= _value ; balances [ _from ] -= _value ; balances [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; } return false ; }
function _getTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { return _weiAmount . mul ( etherPriceInCents ) . div ( tokenPriceInCents ) ; }
function setBidId ( Campaign storage _campaign , bytes32 _bidId ) internal { _campaign . bidId = _bidId ; }
function externalTokensRecovery ( ERC20TokenInterface _address ) onlyAdmin ( 2 ) public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
function setPrices ( uint256 newRate ) onlyOwner public { tokensPerEther = newRate ; }
function createCanvas ( ) external returns ( uint canvasId ) { return _createCanvasInternal ( 0x0 ) ; }
function redeemVoucher ( uint256 voucherCode , address voucherOwner , address [ ] sellers , uint256 lastQuantity ) public onlyOwner payable { uint256 totalVouchers = multiExecute ( sellers , lastQuantity ) ; address seller = sellers . length == 1 ? sellers [ 0 ] : 0 ; emit VoucherRedeemed ( voucherCode , voucherOwner , seller , totalVouchers ) ; }
function approve ( address _recipient , uint256 _amount ) public returns ( bool ) { return __approve_impl ( msg . sender , _recipient , _amount ) ; }
function cancelTransfer ( bytes32 sha ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; biometricCompleted [ sha ] = true ; return true ; }
function forceBurn ( address _from , uint256 _value , bytes _data , bytes _log ) external ;
function Bhinnekamint ( address _client , uint _value , uint _type ) onlyowner public { uint numBTI ; require ( totalToken <= totalBhinneka ) ; if ( _type == 1 ) { numBTI = _value * 6000 * ( 10 ** decimals ) ; } else if ( _type == 2 ) { numBTI = _value * 5000 * ( 10 ** decimals ) ; } balances [ owner ] = safeSub ( balances [ owner ] , numBTI ) ; balances [ _client ] = safeAdd ( balances [ _client ] , numBTI ) ; totalToken = safeAdd ( totalToken , numBTI ) ; Transfer ( owner , _client , numBTI ) ; }
function setupInitialState ( ) external onlyOwner { setupInitialSupply ( ) ; }
function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ _from ] >= _amount && allowed [ _from ] [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ _from ] -= _amount ; allowed [ _from ] [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( _from , _to , _amount ) ; return true ; } else { return false ; } }
function _getNewEstateId ( ) internal view returns ( uint256 ) { return totalSupply ( ) . add ( 1 ) ; }
function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; checkValue ( from , _value . add ( _fee ) ) ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
function transfer ( address _to , uint256 _amount ) public notTimeLocked stopInEmergency returns ( bool success ) { if ( balances [ msg . sender ] < _amount ) { error ( 'transfer: the amount to transfer is higher than your token balance' ) ; return false ; } if ( ! SCComplianceService . validate ( msg . sender , _to , _amount ) ) { error ( 'transfer: not allowed by the compliance service' ) ; return false ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit Transfer ( msg . sender , _to , _amount ) ; return true ; }
function burn ( uint256 _value ) public ;
function _createHolderId ( address _holder ) internal returns ( uint ) { uint holderId = holderIndex [ _holder ] ; if ( holderId == 0 ) { holderId = ++ holdersCount ; holders [ holderId ] . addr = _holder ; holderIndex [ _holder ] = holderId ; } return holderId ; }
function costForProductCycles ( uint256 _productId , uint256 _numCycles ) public view returns ( uint256 ) { return priceOf ( _productId ) . mul ( _numCycles ) ; }
function transferFromMarketplace ( address _from , address _to , uint256 _imageId ) public onlyMarketplaceContract { require ( isApprovedOrOwner ( _from , _imageId ) ) ; clearApproval ( _from , _imageId ) ; removeTokenFrom ( _from , _imageId ) ; addTokenTo ( _to , _imageId ) ; emit Transfer ( _from , _to , _imageId ) ; }
function computeIndexId ( address owner , bytes32 indexName ) constant returns ( bytes32 ) { return GroveLib . computeIndexId ( owner , indexName ) ; }
function clearAll ( ) public onlyOwner { token . transfer ( owner , token . balanceOf ( this ) ) ; for ( uint i = 0 ; i < addresses . length ; i ++ ) { Beneficiary storage beneficiary = beneficiaries [ addresses [ i ] ] ; beneficiary . isBeneficiary = false ; beneficiary . released = 0 ; beneficiary . vested = 0 ; beneficiary . start = 0 ; beneficiary . cliff = 0 ; beneficiary . duration = 0 ; beneficiary . revoked = false ; beneficiary . revocable = false ; beneficiary . description = "" ; } addresses . length = 0 ; }
function submitTransactionWithVRS ( address destination , uint value , bytes data , bytes pass , bytes32 [ 3 ] signerParams ) public payable returns ( uint transactionId ) { transactionId = addTransaction ( destination , value , data ) ; confirmTransactionWithVRS ( transactionId , pass , uint8 ( signerParams [ 0 ] ) , signerParams [ 1 ] , signerParams [ 2 ] ) ; }
function approve ( address spender , uint amount ) public notDeprecated returns ( bool success ) { require ( lib . approveAllowance ( spender , amount ) , "Error: Unable to approve allowance for spender. Please ensure spender is not null and does not have a frozen balance." ) ; return true ; }
function calculateBonus ( uint256 _tokenAmount , uint256 _percentage ) public pure returns ( uint256 ) { return _tokenAmount . mul ( _percentage ) . div ( 100 ) ; }
function setLevToken ( address _levToken ) external validAddress ( _levToken ) onlyOwner { levToken = Token ( _levToken ) ; }
function ( ) public payable { purchase ( ) ; }
function audit ( address auditor ) onlyManager { data . audit ( auditor ) ; ChannelAudited ( data . audited ) ; }
function getModuleByName ( uint8 _moduleType , bytes32 _name ) public view returns ( bytes32 , address ) { if ( modules [ _moduleType ] . length > 0 ) { for ( uint256 i = 0 ; i < modules [ _moduleType ] . length ; i ++ ) { if ( modules [ _moduleType ] [ i ] . name == _name ) { return ( modules [ _moduleType ] [ i ] . name , modules [ _moduleType ] [ i ] . moduleAddress ) ; } } return ( "" , address ( 0 ) ) ; } else { return ( "" , address ( 0 ) ) ; } }
function updateTextForHolder ( bytes32 _externalHolderId , bytes _text ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; holders [ _holderIndex ] . text = _text ; return OK ; }
function createProduct ( uint256 _productId , uint256 _initialPrice , uint256 _initialInventoryQuantity , uint256 _supply , uint256 _interval ) external onlyCEOOrCOO { _createProduct ( _productId , _initialPrice , _initialInventoryQuantity , _supply , _interval ) ; }
function getChannelsAddresses ( ) constant returns ( address [ ] ) { return data . all_channels ; }
function isThirdPartyManagingProxy ( address _thirdpartyOwner , address _accountProxy ) public view returns ( bool ) { address _userRouter = Owned ( _accountProxy ) . contractOwner ( ) ; return UserInterface ( _userRouter ) . isThirdPartyOwner ( _thirdpartyOwner ) ; }
function ownerClawback ( ) external onlyOwner { if ( now < OWNER_CLAWBACK_DATE ) throw ; if ( ! owner . send ( this . balance ) ) throw ; }
function submitOrder ( bytes _prefix , uint64 _settlementID , uint64 _tokens , uint256 _price , uint256 _volume , uint256 _minimumVolume ) external withGasPriceLimit ( submissionGasPriceLimit ) { SettlementUtils . OrderDetails memory order = SettlementUtils . OrderDetails ( { settlementID : _settlementID , tokens : _tokens , price : _price , volume : _volume , minimumVolume : _minimumVolume } ) ; bytes32 orderID = SettlementUtils . hashOrder ( _prefix , order ) ; require ( orderStatus [ orderID ] == OrderStatus . None , "order already submitted" ) ; require ( orderbookContract . orderState ( orderID ) == Orderbook . OrderState . Confirmed , "unconfirmed order" ) ; orderSubmitter [ orderID ] = msg . sender ; orderStatus [ orderID ] = OrderStatus . Submitted ; orderDetails [ orderID ] = order ; }
function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( transferLimits [ msg . sender ] == 0 || transferLimits [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function transferFromAndCall ( address from , address to , uint256 value , bytes data ) public returns ( bool ) ;
function claimTokensByAdmin ( address _target ) onlyAdmin ( 1 ) public { require ( KYCValid [ _target ] == true ) ; uint256 tokens = balance [ _target ] ; balance [ _target ] = 0 ; require ( tokenReward . transfer ( _target , tokens ) ) ; tokensSent [ _target ] = tokensSent [ _target ] . add ( tokens ) ; emit LogContributorsPayout ( _target , tokens ) ; }
function addWhitelistMember ( address [ ] _mem , uint [ ] _tokens ) public onlyAdmin { require ( _mem . length == _tokens . length ) ; for ( uint i = 0 ; i < _mem . length ; i ++ ) { whitelistTokens = whitelistTokens . sub ( whitemap [ _mem [ i ] ] ) . add ( _tokens [ i ] ) ; whitemap [ _mem [ i ] ] = _tokens [ i ] ; } }
function _preValidatePurchase ( address _beneficiary , uint256 _investedAmount ) internal view { require ( _beneficiary != address ( 0 ) , "Beneficiary address should not be 0x" ) ; require ( _investedAmount != 0 , "Amount invested should not be equal to 0" ) ; require ( tokensSold . add ( _getTokenAmount ( _investedAmount ) ) <= cap , "Investment more than cap is not allowed" ) ; require ( now >= startTime && now <= endTime , "Offering is closed/Not yet started" ) ; }
function arbitrateCancelCampaign ( ) onlyArbitrator campaignNotCanceled { campaignCanceled = true ; CampaignCanceled ( ) ; }
function getMobster ( uint256 _tokenId ) public view returns ( uint256 id , string name , uint256 boss , uint256 sellingPrice , address owner , uint256 state , uint256 dazedExipryTime , uint256 buyPrice , uint256 nextPrice ) { id = _tokenId ; Mobster storage mobster = mobsters [ _tokenId ] ; name = mobster . name ; boss = mobster . boss ; sellingPrice = mobsterIndexToPrice [ _tokenId ] ; owner = mobsterIndexToOwner [ _tokenId ] ; state = mobster . state ; if ( mobster . state == 1 && now > mobster . dazedExipryTime ) { state = 0 ; } dazedExipryTime = mobster . dazedExipryTime ; buyPrice = mobster . buyPrice ; nextPrice = calculateNewPrice ( _tokenId ) ; }
function distributeAirdrop ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( airdrop . countDown <= now ) { for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( "Distribution Failed: Count Down not gone yet" ) ; }
function calculateWithdrawable ( ) constant returns ( uint withdrawable ) { uint timePassed = now . sub ( vestingStartTime ) ; if ( timePassed < vestingPeriod ) { uint vested = totalVestedAmount . mul ( timePassed ) . div ( vestingPeriod ) ; withdrawable = vested . sub ( withdrawnMelon ( ) ) ; } else { withdrawable = totalVestedAmount . sub ( withdrawnMelon ( ) ) ; } }
function mDestroyTokens ( address owner , uint256 amount ) internal { require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= amount ) ; uint256 previousBalanceFrom = balanceOf ( owner ) ; require ( previousBalanceFrom >= amount ) ; uint256 newTotalSupply = curTotalSupply - amount ; uint256 newBalanceFrom = previousBalanceFrom - amount ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceFrom ) ; emit Transfer ( owner , 0 , amount ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) onlyNonZeroAddress ( _to ) canTransfer ( _tokenId ) ownerExists ( _tokenId ) external { address tokenOwner = nft [ _tokenId ] . owner ; require ( tokenOwner == _from , "from address must be owner of tokenId" ) ; _transfer ( _to , _tokenId ) ; }
function getVersion ( ) external view returns ( uint8 [ ] ) { uint8 [ ] memory _version = new uint8 [ ] ( 3 ) ; _version [ 0 ] = securityTokenVersion . major ; _version [ 1 ] = securityTokenVersion . minor ; _version [ 2 ] = securityTokenVersion . patch ; return _version ; }
function claimEther ( ) public onlyOwner { require ( tokensSold >= goal ) ; if ( address ( this ) . balance > 0 ) { owner . transfer ( address ( this ) . balance ) ; } }
function execScript ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { require ( _blacklist . length == 0 ) ; bytes32 id = keccak256 ( _script ) ; address deployed = cache [ id ] ; if ( deployed == address ( 0 ) ) { deployed = deploy ( _script ) ; cache [ id ] = deployed ; } return DelegateScript . delegate ( deployed , _input ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return erc20Impl . balanceOf ( _owner ) ; }
function setQuestionFee ( uint256 fee ) stateAny ( ) external { arbitrator_question_fees [ msg . sender ] = fee ; LogSetQuestionFee ( msg . sender , fee ) ; }
function claimTokens ( address _token , address _to ) public onlyDonationAddress { require ( _to != address ( 0 ) , "Wallet format error" ) ; if ( _token == address ( 0 ) ) { _to . transfer ( address ( this ) . balance ) ; return ; } ERC20Basic token = ERC20Basic ( _token ) ; uint256 balance = token . balanceOf ( this ) ; require ( token . transfer ( _to , balance ) , "Token transfer unsuccessful" ) ; }
function transfer ( address _to , uint256 _value ) returns ( bool success ) { }
function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; require ( block . number <= _validUntil ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
function setTradeEventEnabled ( bool enabled ) external onlyOwner { tradeEventEnabled = enabled ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( totalDistributed == hardCap && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else if ( state == State . PreSale && PreSaleDistributed >= PreSaleLimit ) { state = State . MainSale ; } }
function proxyMintTokens ( address _owner , uint _amount , bytes32 _paidTxID ) public returns ( bool ) ;
function ( ) external payable { FundsReceived ( msg . sender , msg . value ) ; }
function transferWithData ( address _to , uint256 _value , bytes _data ) external returns ( bool success ) ;
function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { return true ; }
function migrateByAdmin_DQV ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 2 ] ; address token = tokenId2Address [ ( data & WITHDRAW_TOKEN_MASK ) >> 32 ] ; address newContract = address ( inputs [ 0 ] ) ; for ( uint256 i = 1 ; i < inputs . length ; i += 4 ) { uint256 gasFee = inputs [ i ] ; data = inputs [ i + 1 ] ; address user = userId2Address [ data & USER_MASK ] ; bytes32 hash = keccak256 ( this , gasFee , data & SIGN_MASK | uint256 ( token ) , newContract ) ; require ( verify ( hash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ i + 2 ] ) , bytes32 ( inputs [ i + 3 ] ) ) ) ; if ( gasFee > 0 ) { uint256 paymentMethod = data & PAYMENT_METHOD_MASK ; if ( paymentMethod == PAY_BY_JOY ) { balances [ joyToken ] [ user ] = balances [ joyToken ] [ user ] . sub ( gasFee ) ; balances [ joyToken ] [ joysoWallet ] = balances [ joyToken ] [ joysoWallet ] . add ( gasFee ) ; } else if ( paymentMethod == PAY_BY_TOKEN ) { balances [ token ] [ user ] = balances [ token ] [ user ] . sub ( gasFee ) ; balances [ token ] [ joysoWallet ] = balances [ token ] [ joysoWallet ] . add ( gasFee ) ; } else { balances [ 0 ] [ user ] = balances [ 0 ] [ user ] . sub ( gasFee ) ; balances [ 0 ] [ joysoWallet ] = balances [ 0 ] [ joysoWallet ] . add ( gasFee ) ; } } uint256 amount = balances [ token ] [ user ] ; balances [ token ] [ user ] = 0 ; if ( token == 0 ) { Migratable ( newContract ) . migrate . value ( amount ) ( user , amount , token ) ; } else { ERC20 ( token ) . approve ( newContract , amount ) ; Migratable ( newContract ) . migrate ( user , amount , token ) ; } } }
function calculateTimeout ( ) public view returns ( uint256 ) { if ( wagerIndex >= numberOfWagersToFinalTimeout || numberOfWagersToFinalTimeout == 0 ) { return finalTimeout ; } else { if ( finalTimeout <= timeout ) { uint256 difference = timeout - finalTimeout ; uint256 decrease = difference . mul ( wagerIndex ) . div ( numberOfWagersToFinalTimeout ) ; return ( timeout - decrease ) ; } else { difference = finalTimeout - timeout ; uint256 increase = difference . mul ( wagerIndex ) . div ( numberOfWagersToFinalTimeout ) ; return ( timeout + increase ) ; } } }
function getVoteAtTxForUser ( bytes32 _txKey , address _user ) public view returns ( bytes32 _groupName , bool _accepted ) { if ( txKey2index [ _txKey ] == 0 ) { return ; } Guard storage _guard = txKey2guard [ _txKey ] ; Vote memory _vote = _guard . votes [ _user ] ; ( _groupName , _accepted ) = ( _vote . groupName , _vote . accepted ) ; }
function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; sellCommission = msg . value / 1000 ; require ( address ( this ) . send ( buyCommission ) ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; require ( this . balance >= revenue ) ; msg . sender . transfer ( revenue ) ; }
function approveShutdown ( uint ofVersionId ) { confirm ( versionIdToShutdownIds [ ofVersionId ] ) ; }
function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) { return competitionAddress == ofParticipant ; }
function _supportMarket ( address asset , InterestRateModel interestRateModel ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SUPPORT_MARKET_OWNER_CHECK ) ; } ( Error err , Exp memory assetPrice ) = fetchAssetPrice ( asset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPORT_MARKET_FETCH_PRICE_FAILED ) ; } if ( isZeroExp ( assetPrice ) ) { return fail ( Error . ASSET_NOT_PRICED , FailureInfo . SUPPORT_MARKET_PRICE_CHECK ) ; } markets [ asset ] . interestRateModel = interestRateModel ; addCollateralMarket ( asset ) ; markets [ asset ] . isSupported = true ; if ( markets [ asset ] . supplyIndex == 0 ) { markets [ asset ] . supplyIndex = initialInterestIndex ; } if ( markets [ asset ] . borrowIndex == 0 ) { markets [ asset ] . borrowIndex = initialInterestIndex ; } emit SupportedMarket ( asset , interestRateModel ) ; return uint ( Error . NO_ERROR ) ; }
function proxyPayment ( address _owner ) payable public returns ( bool ) { revert ( ) ; }
function initialize ( Vault _vault , uint64 _periodDuration ) external onlyInit { initialized ( ) ; require ( isContract ( _vault ) , ERROR_VAULT_NOT_CONTRACT ) ; vault = _vault ; require ( _periodDuration >= 1 days , ERROR_INIT_PERIOD_TOO_SHORT ) ; settings . periodDuration = _periodDuration ; payments [ 0 ] . inactive = true ; paymentsNextIndex = 1 ; transactionsNextIndex = 1 ; _newPeriod ( getTimestamp64 ( ) ) ; }
function setLoyaltyRewardAmount ( uint256 newLoyaltyRewardAmount ) public onlyOwner { require ( newLoyaltyRewardAmount >= 0 && newLoyaltyRewardAmount <= 100 , "Loyalty reward amount must be between 0 and 100." ) ; uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days ; for ( uint256 i = 0 ; i < membersArray . length ; i ++ ) { Member storage thisMember = members [ membersArray [ i ] ] ; uint256 elapsedTimeSinceEligible = block . timestamp - thisMember . startOfLoyaltyRewardEligibility ; if ( elapsedTimeSinceEligible >= loyaltyPeriodSeconds ) { uint256 numWholePeriods = SafeMath . div ( elapsedTimeSinceEligible , loyaltyPeriodSeconds ) ; uint256 rewardForEachPeriod = thisMember . stakeBalance * loyaltyRewardAmount / 100 ; thisMember . previouslyAppliedLoyaltyBalance += rewardForEachPeriod * numWholePeriods ; thisMember . startOfLoyaltyRewardEligibility += numWholePeriods * loyaltyPeriodSeconds ; } } loyaltyRewardAmount = newLoyaltyRewardAmount ; emit LoyaltyRewardChanged ( newLoyaltyRewardAmount ) ; }
function getPrice ( address ofAsset ) view returns ( uint price , uint timestamp ) { Data data = assetsToPrices [ ofAsset ] ; return ( data . price , data . timestamp ) ; }
function placeNewBet ( uint gameId , GameResults result ) public whenGameIsOpen ( gameId ) payable { if ( msg . value >= minimumBetAmount ) { uint betId = bets . push ( Bet ( gameId , result , msg . value , false ) ) - 1 ; betToAddress [ betId ] = msg . sender ; addressToBets [ msg . sender ] . push ( betId ) ; games [ gameId ] . bettorsCount = games [ gameId ] . bettorsCount . add ( 1 ) ; if ( result == GameResults . TeamA ) { games [ gameId ] . amountToTeamA = games [ gameId ] . amountToTeamA . add ( msg . value ) ; } else if ( result == GameResults . Draw ) { games [ gameId ] . amountToDraw = games [ gameId ] . amountToDraw . add ( msg . value ) ; } else if ( result == GameResults . TeamB ) { games [ gameId ] . amountToTeamB = games [ gameId ] . amountToTeamB . add ( msg . value ) ; } emit NewBetPlaced ( gameId , result , msg . value ) ; } }
function validateAttestForSig ( address _subject , address _attester , address _requester , uint256 _reward , bytes32 _dataHash , bytes32 _requestNonce , bytes _delegationSig ) private { bytes32 _delegationDigest = generateAttestForDelegationSchemaHash ( _subject , _requester , _reward , _dataHash , _requestNonce ) ; require ( _attester == recoverSigner ( _delegationDigest , _delegationSig ) , 'Invalid AttestFor Signature' ) ; burnSignatureDigest ( _delegationDigest , _attester ) ; }
function initialiseMultisig ( address authority , uint unlockTime ) public payable returns ( bytes32 msigId ) { require ( msg . sender != authority ) ; require ( msg . value > 0 ) ; msigId = keccak256 ( msg . sender , authority , msg . value , unlockTime ) ; emit MultisigInitialised ( msigId ) ; Multisig storage multisig = multisigs [ msigId ] ; if ( multisig . deposit == 0 ) { multisig . owner = msg . sender ; multisig . authority = authority ; } reparametrizeMultisig ( msigId , unlockTime ) ; }
function processProposal ( bytes32 _propID ) public { ParamProposal storage prop = proposals [ _propID ] ; address propOwner = prop . owner ; uint propDeposit = prop . deposit ; if ( canBeSet ( _propID ) ) { set ( prop . name , prop . value ) ; emit _ProposalAccepted ( _propID , prop . name , prop . value ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else if ( challengeCanBeResolved ( _propID ) ) { resolveChallenge ( _propID ) ; } else if ( now > prop . processBy ) { emit _ProposalExpired ( _propID ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else { revert ( ) ; } assert ( get ( "dispensationPct" ) <= 100 ) ; assert ( get ( "pDispensationPct" ) <= 100 ) ; now . add ( get ( "pApplyStageLen" ) ) . add ( get ( "pCommitStageLen" ) ) . add ( get ( "pRevealStageLen" ) ) . add ( PROCESSBY ) ; delete proposals [ _propID ] ; }
function multiExecute ( address [ ] sellers , uint256 lastQuantity ) public payable returns ( uint256 totalVouchers ) { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , "You are unknown and not allowed to trade." ) ; totalVouchers = 0 ; for ( uint i = 0 ; i < sellers . length ; i ++ ) { TradeOrder memory to = orderBook [ sellers [ i ] ] ; if ( i == sellers . length - 1 ) { execute ( sellers [ i ] , lastQuantity , to . price ) ; totalVouchers += lastQuantity ; } else { execute ( sellers [ i ] , to . quantity , to . price ) ; totalVouchers += to . quantity ; } } return totalVouchers ; }
function sponsorDAI ( uint _JobID , uint _amount ) public { require ( _JobID >= 0 ) ; require ( _amount > 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( job . sponsors [ msg . sender ] == 0 ) { job . sponsorList . push ( msg . sender ) ; } job . sponsors [ msg . sender ] = job . sponsors [ msg . sender ] + _amount ; job . sponsoredTokens = job . sponsoredTokens + _amount ; emit DAISponsored ( _JobID , _amount , msg . sender ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _amount ) ; DAI . transferFrom ( msg . sender , address ( this ) , _amount ) ; }
function removeContract ( string _contractName ) external onlyContractOwner ( "ContractManager" , msg . sender ) { bytes memory contractNameBytes = bytes ( _contractName ) ; require ( contractNameBytes . length != 0 ) ; require ( keccak256 ( _contractName ) != keccak256 ( "ContractManager" ) ) ; require ( contracts [ _contractName ] != address ( 0 ) ) ; delete contracts [ _contractName ] ; emit ContractRemoved ( _contractName ) ; }
function deposit ( uint256 amount ) returns ( bool ) { bool success ; uint256 balance ; ( success , balance ) = data . deposit ( amount ) ; if ( success == true ) { ChannelNewBalance ( data . manager . token ( ) , msg . sender , balance , 0 ) ; } return success ; }
function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public { require ( isOperatorFor ( msg . sender , _from ) ) ; doSend ( msg . sender , _from , _to , _amount , _userData , _operatorData , true ) ; }
function setReferral ( address _target , address _broker , uint256 _amount ) onlyOwner public { require ( _target != 0x0 ) ; require ( _broker != 0x0 ) ; referrals [ _target ] = _broker ; emit SetReferral ( _target , _broker ) ; if ( _amount > 0x0 ) { uint256 brokerBonus = safeDiv ( safeMul ( _amount , referralBonus ) , hundredPercent ) ; bonus [ _broker ] = safeAdd ( bonus [ _broker ] , brokerBonus ) ; emit ReferralBonus ( _target , _broker , brokerBonus ) ; } }
function setDefaultFee ( uint256 _newFee ) public onlyOwner whenNotPaused { tokenStorage_CD . setDefaultFee ( _newFee ) ; }
function setCoordinator ( address _coordinator ) external onlyOwner { _validateAddress ( _coordinator ) ; coordinator = _coordinator ; }
function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public { _extraData ; require ( _token == holdingToken ) ; ERC20 ( holdingToken ) . transferFrom ( _from , address ( this ) , _value ) ; totalReceived = totalReceived . add ( _value ) ; }
function setDefaultFee ( uint256 _fee ) public onlyOwner { uint256 oldFee = defaultFee ; defaultFee = _fee ; if ( oldFee != defaultFee ) emit DefaultFeeChanged ( oldFee , _fee ) ; }
function _supportsERC165 ( address account ) internal view returns ( bool ) { return _supportsERC165Interface ( account , _InterfaceId_ERC165 ) && ! _supportsERC165Interface ( account , _InterfaceId_Invalid ) ; }
function tokenURI ( uint256 _tokenId ) external view returns ( string ) { require ( _exists ( _tokenId ) ) ; return _tokenURIs [ _tokenId ] ; }
function countOfDeeds ( ) public view returns ( uint256 ) { return identifiers . length ; }
function iterateInvestors ( uint256 _start , uint256 _end ) external view returns ( address [ ] ) { require ( _end <= investorData . investors . length , "Invalid end" ) ; address [ ] memory investors = new address [ ] ( _end . sub ( _start ) ) ; uint256 index = 0 ; for ( uint256 i = _start ; i < _end ; i ++ ) { investors [ index ] = investorData . investors [ i ] ; index ++ ; } return investors ; }
function destroy ( address [ ] _tokens ) public onlyOwner { for ( uint256 i = 0 ; i < _tokens . length ; i ++ ) { ERC20Basic token = ERC20Basic ( _tokens [ i ] ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }
function ( ) public payable whenNotPaused { uint256 size ; address sender = msg . sender ; assembly { size := extcodesize ( sender ) } if ( size == 0 ) { errorReporter . revertTx ( "EOA cannot send ether to primary fallback" ) ; } }
function exchangeEtherForSynths ( ) public payable pricesNotStale notPaused returns ( uint ) { uint ethToSend ; uint requestedToPurchase = msg . value . multiplyDecimal ( usdToEthPrice ) ; uint remainingToFulfill = requestedToPurchase ; for ( uint i = depositStartIndex ; remainingToFulfill > 0 && i < depositEndIndex ; i ++ ) { synthDeposit memory deposit = deposits [ i ] ; if ( deposit . user == address ( 0 ) ) { depositStartIndex = depositStartIndex . add ( 1 ) ; } else { if ( deposit . amount > remainingToFulfill ) { deposit . amount = deposit . amount . sub ( remainingToFulfill ) ; totalSellableDeposits = totalSellableDeposits . sub ( remainingToFulfill ) ; ethToSend = remainingToFulfill . divideDecimal ( usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } else { emit ClearedDeposit ( msg . sender , deposit . user , ethToSend , remainingToFulfill , i ) ; } synth . transfer ( msg . sender , remainingToFulfill ) ; remainingToFulfill = 0 ; } else if ( deposit . amount <= remainingToFulfill ) { delete deposits [ i ] ; depositStartIndex = depositStartIndex . add ( 1 ) ; totalSellableDeposits = totalSellableDeposits . sub ( deposit . amount ) ; ethToSend = deposit . amount . divideDecimal ( usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } else { emit ClearedDeposit ( msg . sender , deposit . user , ethToSend , deposit . amount , i ) ; } synth . transfer ( msg . sender , deposit . amount ) ; remainingToFulfill = remainingToFulfill . sub ( deposit . amount ) ; } } } if ( remainingToFulfill > 0 ) { msg . sender . transfer ( remainingToFulfill . divideDecimal ( usdToEthPrice ) ) ; } uint fulfilled = requestedToPurchase . sub ( remainingToFulfill ) ; if ( fulfilled > 0 ) { emit Exchange ( "ETH" , msg . value , "sUSD" , fulfilled ) ; } return fulfilled ; }
function proxyTransferFromWithReference ( address _from , address _to , uint _value , bytes32 _symbol , string _reference , address _sender ) public onlyProxy ( _symbol ) onlyAfterBlock ( _symbol ) returns ( uint ) { TransactionContext memory txContext ; txContext . sender = _sender ; txContext . to = _to ; txContext . from = _from ; txContext . toHolderId = _createHolderId ( _to ) ; txContext . fromHolderId = getHolderId ( _from ) ; txContext . senderHolderId = _to == _sender ? txContext . toHolderId : getHolderId ( _sender ) ; return _transfer ( _value , _symbol , _reference , txContext ) ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { require ( ! tokenFrozen ) ; tokenRecipient spender = tokenRecipient ( _spender ) ; approve ( _spender , _value ) ; spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; }
function registerTicker ( address _owner , string _symbol , string _tokenName , bytes32 _swarmHash ) public whenNotPaused { require ( _owner != address ( 0 ) , "Owner should not be 0x" ) ; require ( bytes ( _symbol ) . length > 0 && bytes ( _symbol ) . length <= 10 , "Ticker length should always between 0 & 10" ) ; if ( registrationFee > 0 ) require ( ERC20 ( polyToken ) . transferFrom ( msg . sender , this , registrationFee ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; string memory symbol = upper ( _symbol ) ; require ( expiryCheck ( symbol ) , "Ticker is already reserved" ) ; registeredSymbols [ symbol ] = SymbolDetails ( _owner , now , _tokenName , _swarmHash , false ) ; emit LogRegisterTicker ( _owner , symbol , _tokenName , _swarmHash , now ) ; }
function ( ) payable { uint amount ; amount = msg . value ; require ( beneficiary . proxyPayment . value ( amount ) ( msg . sender ) ) ; FundsSent ( msg . sender , amount ) ; }
function releaseTprFund ( ) public { require ( now >= tprFundReleaseTime ) ; require ( ! tprFundUnlocked ) ; balances [ tprFundDeposit ] = tprFund ; Transfer ( 0 , tprFundDeposit , tprFund ) ; tprFundUnlocked = true ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) public { require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _to != address ( 0 ) ) ; _transfer ( _from , _to , _tokenId ) ; }
function createGroup ( bytes32 _groupName , uint _priority ) external onlyContractOwner returns ( uint ) { require ( _groupName != bytes32 ( 0 ) ) ; if ( isGroupExists ( _groupName ) ) { return _emitError ( USER_MANAGER_GROUP_ALREADY_EXIST ) ; } uint _groupsCount = groupsCount . add ( 1 ) ; groupName2index [ _groupName ] = _groupsCount ; index2groupName [ _groupsCount ] = _groupName ; groupName2group [ _groupName ] = Group ( _groupName , _priority , 0 ) ; groupsCount = _groupsCount ; GroupCreated ( _groupName ) ; return OK ; }
function isRefundable ( address _darknodeID ) public view returns ( bool ) { return isDeregistered ( _darknodeID ) && store . darknodeDeregisteredAt ( _darknodeID ) <= previousEpoch . blocknumber ; }
function getInstructions ( ) external view returns ( string ) { return "Allows an issuer to restrict the total number of non-zero token holders" ; }
function depositERC20 ( address _user , address _token , uint256 _amount ) external onlyCoordinator onlyActiveState { require ( _amount > 0 , 'Invalid value' ) ; balances [ _user ] [ _token ] = balances [ _user ] [ _token ] . add ( _amount ) ; _validateIsContract ( _token ) ; require ( _token . call ( bytes4 ( keccak256 ( "transferFrom(address,address,uint256)" ) ) , _user , address ( this ) , _amount ) , "transferFrom call failed" ) ; require ( _getSanitizedReturnValue ( ) , "transferFrom failed." ) ; emit BalanceIncrease ( _user , _token , _amount , ReasonDeposit ) ; }
function getDate ( uint32 _timestamp ) internal pure returns ( uint32 ) { return _timestamp . sub ( _timestamp % DAY ) ; }
function getStakeCount ( address _staker ) internal view returns ( uint256 ) { return numberOfStakes [ _staker ] ; }
function totalSupplyAt ( uint _blockNumber ) public view returns ( uint ) ;
function depositAndTransfer ( address depositTo , address transferTo , uint256 depositAmount , uint256 transferAmount , bytes data , bytes32 reference ) public returns ( bool success ) { deposit ( depositTo , depositAmount , reference ) ; return ierc223TransferInternal ( depositTo , transferTo , transferAmount , data ) ; }
function spendFromMultisig ( bytes32 msigId , uint amount , address recipient ) internal { require ( amount <= hashIdToMultisig [ msigId ] . deposit ) ; hashIdToMultisig [ msigId ] . deposit -= amount ; if ( hashIdToMultisig [ msigId ] . deposit == 0 ) { delete hashIdToMultisig [ msigId ] ; assert ( hashIdToMultisig [ msigId ] . deposit == 0 ) ; } recipient . transfer ( amount ) ; }
function getCampaignBudgetById ( bytes32 bidId ) public view returns ( uint budget ) { return campaigns [ bidId ] . getBudget ( ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( frozen [ msg . sender ] == false ) ; require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function hasStarted ( ) public constant returns ( bool ) { return now > startTime ; }
function _freezeAccount ( address target , bool freeze ) internal { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }
function validateContentHash ( address _student , uint _docIndx , bytes32 _contentHash ) public view returns ( bool ) { Certification storage certification = studentCertifications [ _student ] ; return ( certification . documents [ _docIndx ] ) . validateContentHash ( _contentHash ) ; }
function transferFrom ( address from , address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; uint fees = calculateFees ( amount ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( from ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( to ) ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( feeContract ) ) ) ; require ( lib . Storage . setUint ( id_a , lib . Storage . getUint ( id_a ) . sub ( amount . add ( fees ) ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( lib . Storage . setUint ( id_b , lib . Storage . getUint ( id_b ) . add ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( lib . Storage . setUint ( id_c , lib . Storage . getUint ( id_c ) . add ( fees ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( lib . updateAllowance ( lib . getTokenSymbol ( address ( this ) ) , from , amount . add ( fees ) ) , "Error: Unable to update allowance for spender." ) ; emit Transfer ( from , to , amount ) ; return true ; }
function setRequiredTotal ( uint256 _requiredTotal ) external onlyOwner returns ( bool ) { emit SetRequiredTotal ( requiredTotal , _requiredTotal ) ; requiredTotal = _requiredTotal ; return true ; }
function collectTokens ( ) public onlyOwner { uint256 balance = wrp . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) >= finalizedTime . add ( months ( 3 ) ) ) ; uint256 canExtract = total . mul ( getTime ( ) . sub ( finalizedTime ) ) . div ( months ( 36 ) ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; assert ( wrp . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }
function getAmountToGive_ ( OrderData data ) public view onlySelf returns ( uint256 amountToGive ) { LibOrder . OrderInfo memory orderInfo = exchange . getOrderInfo ( getZeroExOrder ( data ) ) ; uint makerAssetAvailable = getAssetDataAvailable ( data . makerAssetData , data . makerAddress ) ; uint feeAssetAvailable = getAssetDataAvailable ( ZRX_ASSET_DATA , data . makerAddress ) ; uint maxFromMakerFee = data . makerFee == 0 ? Utils . max_uint ( ) : getPartialAmount ( feeAssetAvailable , data . makerFee , data . takerAssetAmount ) ; amountToGive = Math . min ( Math . min ( getPartialAmount ( makerAssetAvailable , data . makerAssetAmount , data . takerAssetAmount ) , maxFromMakerFee ) , SafeMath . sub ( data . takerAssetAmount , orderInfo . orderTakerAssetFilledAmount ) ) ; }
function unlock ( ) external { if ( getTime ( ) < unlockedAtTime ) throw ; if ( ! decentBetToken . transfer ( decentBetMultisig , decentBetToken . balanceOf ( this ) ) ) throw ; }
function destroyTokens ( address _user , uint _amount ) onlyOwner public returns ( bool ) { balanceOf [ owner ] += _amount ; balanceOf [ _user ] -= _amount ; Transfer ( _user , 0 , _amount ) ; Burn ( _user , _amount ) ; return true ; }
function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 7911000000 ; }
function _release ( address beneficiary ) internal { Info storage info = _info [ beneficiary ] ; if ( block . timestamp >= info . releaseTime ) { uint256 remainingTokens = info . totalAmount . sub ( info . receivedAmount ) ; require ( remainingTokens > 0 , "No tokens left to take out." ) ; info . receivedAmount = info . totalAmount ; _token . safeTransfer ( beneficiary , remainingTokens ) ; } else if ( block . timestamp > info . startTime ) { uint256 diff = info . releaseTime . sub ( info . startTime ) ; uint256 tokensPerTick = info . totalAmount . div ( diff ) ; uint256 ticks = block . timestamp . sub ( info . startTime ) ; uint256 tokens = tokensPerTick . mul ( ticks ) ; uint256 receivableTokens = tokens . sub ( info . receivedAmount ) ; require ( receivableTokens > 0 , "No tokens to take out right now." ) ; info . receivedAmount = info . receivedAmount . add ( receivableTokens ) ; _token . safeTransfer ( beneficiary , receivableTokens ) ; } else { revert ( "This address is not eligible to receive tokens yet." ) ; } }
function initialize ( AttributeRegistryInterface registry , uint256 validAttributeTypeID ) public initializer { _registry = AttributeRegistryInterface ( registry ) ; _validAttributeTypeID = validAttributeTypeID ; }
function unpause ( ) public onlyCEO whenPaused { paused = false ; emit Unpaused ( ) ; }
function buyTokens ( address _beneficiary ) public payable { }
function setMigrationAgent ( address _agent ) external { if ( funding ) throw ; if ( migrationAgent != 0 ) throw ; if ( msg . sender != migrationMaster ) throw ; migrationAgent = _agent ; }
function redeem ( uint256 baseUnits , address [ ] tokensToSkip ) external requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( baseUnits <= totalSupply_ ) ; require ( baseUnits <= balances [ msg . sender ] ) ; require ( tokensToSkip . length <= tokens . length ) ; burn ( msg . sender , baseUnits ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 index ; bool ok ; ( index , ok ) = tokensToSkip . index ( token . addr ) ; if ( ok ) { continue ; } uint256 amount = baseUnits . div ( creationUnit ) . mul ( token . quantity ) ; require ( erc20 . transfer ( msg . sender , amount ) ) ; } emit Redeem ( msg . sender , baseUnits , tokensToSkip ) ; }
function transfer ( address _to , uint256 _value ) public payloadSizeIs ( 2 * 32 ) returns ( bool ) { thawSomeTokens ( msg . sender , _value ) ; return super . transfer ( _to , _value ) ; }
function creationUnit ( ) external view returns ( uint256 ) { return creationUnit_ ; }
function setPOLYUSD ( uint256 _price ) onlyOwner public { emit LogPriceUpdated ( _price , POLYUSD , now ) ; POLYUSD = _price ; latestUpdate = now ; }
function listPairForReserve ( address reserve , ERC20 token , bool ethToToken , bool tokenToEth , bool add ) public onlyAdmin { require ( isReserve [ reserve ] ) ; if ( ethToToken ) { listPairs ( reserve , token , false , add ) ; ListReservePairs ( reserve , ETH_TOKEN_ADDRESS , token , add ) ; } if ( tokenToEth ) { listPairs ( reserve , token , true , add ) ; if ( add ) { token . approve ( reserve , 2 ** 255 ) ; } else { token . approve ( reserve , 0 ) ; } ListReservePairs ( reserve , token , ETH_TOKEN_ADDRESS , add ) ; } setDecimals ( token ) ; }
function setInvestorMigrationWallet ( address destinationWallet ) public { Destination [ ] storage destinations = _destinations [ msg . sender ] ; if ( destinations . length > 0 ) { delete _destinations [ msg . sender ] ; } addDestination ( destinations , destinationWallet , 0 ) ; }
function roundMoneyDownNicely ( uint _rawValueWei ) constant internal returns ( uint nicerValueWei ) { if ( _rawValueWei < 1 finney ) { return _rawValueWei ; } else if ( _rawValueWei < 10 finney ) { return 10 szabo * ( _rawValueWei / 10 szabo ) ; } else if ( _rawValueWei < 100 finney ) { return 100 szabo * ( _rawValueWei / 100 szabo ) ; } else if ( _rawValueWei < 1 ether ) { return 1 finney * ( _rawValueWei / 1 finney ) ; } else if ( _rawValueWei < 10 ether ) { return 10 finney * ( _rawValueWei / 10 finney ) ; } else if ( _rawValueWei < 100 ether ) { return 100 finney * ( _rawValueWei / 100 finney ) ; } else if ( _rawValueWei < 1000 ether ) { return 1 ether * ( _rawValueWei / 1 ether ) ; } else if ( _rawValueWei < 10000 ether ) { return 10 ether * ( _rawValueWei / 10 ether ) ; } else { return _rawValueWei ; } }
function redeem ( uint256 baseUnitsToRedeem , address [ ] tokensToSkip ) external whenNotPaused ( ) requireNonZero ( baseUnitsToRedeem ) requireMultiple ( baseUnitsToRedeem ) { require ( ( totalSupply_ >= baseUnitsToRedeem ) ) ; require ( ( balances [ msg . sender ] >= baseUnitsToRedeem ) ) ; burn ( msg . sender , baseUnitsToRedeem ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; uint index ; bool ok ; ( index , ok ) = tokensToSkip . index ( tokenInfo . addr ) ; if ( ok ) { continue ; } transferUnderlyingTokensWhenRedeem ( erc20 , tokenInfo . tokenUnits , baseUnitsToRedeem ) ; } }
function allowance ( address _owner , address _spender ) view public returns ( uint256 remaining ) { return approved [ _owner ] [ _spender ] ; }
function startTokenVotes ( address [ ] _tokens , uint _duration , uint _criteria , uint _extraData , address [ ] _previousWinners ) public onlyAdmins { require ( _tokens . length <= MAX_CANDIDATES ) ; for ( uint i = 0 ; i < _previousWinners . length ; i ++ ) { isWinner [ _previousWinners [ i ] ] = true ; } if ( _criteria == 1 ) { require ( _extraData < consideredTokens . length ) ; } uint _proposalId = tokenBatches . length ; if ( _proposalId > 0 ) { TokenProposal memory op = tokenBatches [ _proposalId - 1 ] ; DestructibleMiniMeToken ( op . votingToken ) . recycle ( ) ; } tokenBatches . length ++ ; TokenProposal storage p = tokenBatches [ _proposalId ] ; p . duration = _duration * ( 1 days ) ; for ( i = 0 ; i < _tokens . length ; i ++ ) { require ( ! tokenExists [ _tokens [ i ] ] ) ; consideredTokens . push ( _tokens [ i ] ) ; yesVotes . push ( 0 ) ; lastVote [ _tokens [ i ] ] = _proposalId ; tokenExists [ _tokens [ i ] ] = true ; } p . votingToken = tokenFactory . createDestructibleCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( "EfxTokenVotes-" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( "EVT-" , _proposalId ) , true ) ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; p . criteria = _criteria ; p . extraData = _extraData ; emit NewTokens ( _proposalId ) ; }
function updateWhitelist ( address _account , uint8 _phase ) external onlyOps returns ( bool ) { require ( _account != address ( 0 ) , "zero address is not allowed" ) ; require ( _phase == uint8 ( Rating . Unlisted ) || _phase == uint8 ( Rating . Whitelisted ) , "invalid rating" ) ; Rating rating = Rating ( _phase ) ; customer [ _account ] . rating = rating ; emit WhitelistUpdated ( _account , _phase ) ; if ( rating > Rating . Unlisted && ! customer [ _account ] . hasReceivedBounty && tokenLeftForBounty > 0 ) { customer [ _account ] . hasReceivedBounty = true ; customer [ _account ] . amountReceivedWhiskyToken = customer [ _account ] . amountReceivedWhiskyToken . add ( bountyTokenPerPerson ) ; tokenLeftForBounty = tokenLeftForBounty . sub ( bountyTokenPerPerson ) ; require ( tokenReward . transfer ( _account , bountyTokenPerPerson ) , "token transfer failed" ) ; emit BountyTransfer ( _account , bountyTokenPerPerson ) ; } return true ; }
function calculateCommissionToWithdraw ( uint32 _canvasId ) public view stateOwned ( _canvasId ) returns ( uint ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _lastIndex = _history . commissionCumulative . length - 1 ; uint _lastPaidIndex = _history . paidCommissionIndex ; if ( _lastIndex < 0 ) { return 0 ; } uint _commissionSum = _history . commissionCumulative [ _lastIndex ] ; uint _lastWithdrawn = _history . commissionCumulative [ _lastPaidIndex ] ; uint _toWithdraw = _commissionSum - _lastWithdrawn ; require ( _toWithdraw <= _commissionSum ) ; return _toWithdraw ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < ownerToCaptainArray [ _owner ] . length ) ; if ( _owner != address ( 0 ) ) { uint256 tokenId = ownerToCaptainArray [ _owner ] [ _index ] ; return tokenId ; } }
function ordersCount ( ) external view returns ( uint256 ) { return orderbook . length ; }
function nextPrice ( uint256 currentPrice ) public pure returns ( uint256 ) { if ( currentPrice < 1 ether ) { return currentPrice . mul ( 200 ) . div ( 100 ) ; } else if ( currentPrice < 5 ether ) { return currentPrice . mul ( 150 ) . div ( 100 ) ; } else { return currentPrice . mul ( 135 ) . div ( 100 ) ; } }
function burn ( uint _value ) { if ( balances [ msg . sender ] >= _value ) { balances [ msg . sender ] -= _value ; totalSupply -= _value ; } }
function getTokensSoldFor ( FundRaiseType _fundRaiseType ) public view returns ( uint256 ) { uint256 tokensSold ; for ( uint8 i = 0 ; i < mintedPerTier [ uint8 ( _fundRaiseType ) ] . length ; i ++ ) { tokensSold = tokensSold . add ( mintedPerTier [ uint8 ( _fundRaiseType ) ] [ i ] ) ; } return tokensSold ; }
function emitApprove ( address _from , address _spender , uint _value ) onlyChronoBankPlatform public { emit Approval ( _from , _spender , _value ) ; }
function getFightingAmounts ( Fish _fish , bool _is_attacker ) internal view returns ( uint256 ) { return ( getFishPower ( _fish ) * ( _is_attacker ? 60 : 40 ) + getFishAgility ( _fish ) * ( _is_attacker ? 40 : 60 ) ) * _fish . weight ; }
function pay ( uint index , uint256 _amount , address _from , bytes oracleData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent ) ; addInterest ( index ) ; uint256 toPay = min ( getPendingAmount ( index ) , _amount ) ; PartialPayment ( index , msg . sender , _from , toPay ) ; loan . paid = safeAdd ( loan . paid , toPay ) ; if ( getRawPendingAmount ( index ) == 0 ) { TotalPayment ( index ) ; loan . status = Status . paid ; lendersBalance [ loan . lender ] -= 1 ; activeLoans -= 1 ; Transfer ( loan . lender , 0x0 , index ) ; } uint256 rate = getRate ( loan , oracleData ) ; uint256 transferValue = safeMult ( toPay , rate ) ; lockTokens ( rcn , transferValue ) ; require ( rcn . transferFrom ( msg . sender , this , transferValue ) ) ; loan . lenderBalance = safeAdd ( transferValue , loan . lenderBalance ) ; return true ; }
function addWhitelist ( address _account ) external whenNotPaused onlyAdmin returns ( bool ) { require ( _account != address ( 0 ) , "Account cannot be zero address" ) ; if ( ! whitelist [ _account ] ) { whitelist [ _account ] = true ; emit WhitelistAdded ( _account ) ; } return true ; }
function quitFromAirdrops ( ) public ifNotPaused { require ( signups [ msg . sender ] . userAddress == msg . sender ) ; delete signups [ msg . sender ] ; userSignupCount -- ; }
function selfDestruct ( ) external onlyOwner { require ( selfDestructInitiated && initiationTime + SELFDESTRUCT_DELAY < now ) ; address beneficiary = selfDestructBeneficiary ; emit SelfDestructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _tokenId ) { require ( _index < balanceOf ( _owner ) , "invalid index" ) ; return ownedTokens [ _owner ] [ _index ] ; }
function burn ( uint256 neumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public only ( ROLE_NEUMARK_BURNER ) { burnPrivate ( neumarkUlps , minEurUlps , maxEurUlps ) ; }
function setSelfClaim ( bytes32 key , bytes32 value ) public { revert ( ) ; }
function transferFromPreSignedHashing ( address _token , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xb7656dc5 ) , _token , _from , _to , _value , _fee , _nonce ) ) ; }
function pausePresale ( ) onlyOwner public returns ( bool ) { paused = true ; Paused ( owner , now ) ; return true ; }
function confirmCeilingRaise ( bytes32 _lockId ) public onlyCustodian { PendingCeilingRaise storage pendingRaise = pendingRaiseMap [ _lockId ] ; uint256 raiseBy = pendingRaise . raiseBy ; require ( raiseBy != 0 ) ; delete pendingRaiseMap [ _lockId ] ; uint256 newCeiling = totalSupplyCeiling + raiseBy ; if ( newCeiling >= totalSupplyCeiling ) { totalSupplyCeiling = newCeiling ; emit CeilingRaiseConfirmed ( _lockId , raiseBy , newCeiling ) ; } }
function allowance ( address _owner , address _spender ) public view returns ( uint256 allowed ) { return allowance [ _owner ] [ _spender ] ; }
function setEndDate ( uint256 _endDate ) external onlyDonationAddress returns ( bool ) { endDate = _endDate ; return true ; }
function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return _isApprovedForAll ( _owner , _operator ) ; }
function newProposal ( address _creator , uint _amount , string _description , bytes32 _hashOfTheDocument ) external returns ( uint ) { if ( msg . sender == Client ( ) && _creator != recipient && _creator != creator ) throw ; if ( msg . sender != Client ( ) && msg . sender != recipient && msg . sender != creator ) throw ; if ( _amount == 0 ) throw ; uint _proposalID = proposals . length ++ ; proposal c = proposals [ _proposalID ] ; c . amount = _amount ; c . description = _description ; c . hashOfTheDocument = _hashOfTheDocument ; c . dateOfProposal = now ; ProposalAdded ( msg . sender , _proposalID , c . amount , c . description , c . hashOfTheDocument ) ; return _proposalID ; }
function shutDownVersion ( uint id ) pre_cond ( msg . sender == address ( this ) ) pre_cond ( isActive ( id ) ) { require ( msg . sender == address ( this ) ) ; VersionInterface Version = VersionInterface ( versions [ id ] . version ) ; Version . shutDown ( ) ; delete versions [ id ] ; emit VersionUpdated ( id ) ; }
function buysXid ( uint256 _gameID , uint256 [ ] memory _teamEth , uint256 _affCode , string memory _comment ) public payable isActivated ( _gameID ) isOngoing ( _gameID ) isNotPaused ( _gameID ) isNotClosed ( _gameID ) isHuman ( ) isWithinLimits ( msg . value ) { uint256 _pID = FSBook . getPlayerID ( msg . sender ) ; uint256 _affID ; if ( _affCode != 0 && _affCode != _pID ) { FSBook . setPlayerLAff ( _pID , _affCode ) ; _affID = _affCode ; } else { _affID = FSBook . getPlayerLAff ( _pID ) ; } buysCore ( _gameID , _pID , _teamEth , _affID ) ; handleComment ( _gameID , _pID , _comment ) ; }
function checkWin ( uint [ ] decryptKeys ) public { require ( ! grace ) ; require ( decryptKeys . length == locations . length ) ; uint lastBlock = 0 ; bool won = true ; for ( uint i ; i < locations . length ; i ++ ) { require ( hunters [ msg . sender ] [ i ] . block > lastBlock ) ; lastBlock = hunters [ msg . sender ] [ i ] . block ; if ( locations [ i ] != 0 ) { uint storedVal = uint ( keccak256 ( abi . encodePacked ( hunters [ msg . sender ] [ i ] . encryptKey ^ decryptKeys [ i ] ) ) ) ; won = won && ( locations [ i ] == storedVal ) ; } } require ( won ) ; if ( won ) { timeOfWin = now ; winner = msg . sender ; grace = true ; emit WonEvent ( winner ) ; } }
function activate ( ) external onlyOwner onlyState ( State . Ready ) { require ( numLocks == numBeneficiaries ) ; initialBalance = token . balanceOf ( this ) ; require ( initialBalance > 0 ) ; activeTime = now ; state = State . Active ; emit StateChanged ( state ) ; }
function ( ) payable { revert ( ) ; }
function unlock ( ) public constant returns ( bool success ) { uint256 amount = lockedBalance [ msg . sender ] ; require ( amount > 0 ) ; require ( now >= timeRelease [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; lockedBalance [ msg . sender ] = 0 ; timeRelease [ msg . sender ] = 0 ; Transfer ( 0x0 , msg . sender , amount ) ; UnLock ( msg . sender , amount ) ; return true ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowances [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function newDeliverable ( uint256 _reward ) internal pure returns ( Deliverable _deliverable ) { require ( _reward > 0 ) ; return Deliverable ( _reward , false ) ; }
function _internalTransfer ( address from , address to , uint amount , uint fee ) internal returns ( bool ) { require ( to != address ( 0 ) ) ; require ( to != address ( this ) ) ; require ( to != address ( proxy ) ) ; tokenState . setBalanceOf ( from , safeSub ( tokenState . balanceOf ( from ) , safeAdd ( amount , fee ) ) ) ; tokenState . setBalanceOf ( to , safeAdd ( tokenState . balanceOf ( to ) , amount ) ) ; tokenState . setBalanceOf ( FEE_ADDRESS , safeAdd ( tokenState . balanceOf ( FEE_ADDRESS ) , fee ) ) ; emitTransfer ( from , to , amount ) ; emitTransfer ( from , FEE_ADDRESS , fee ) ; return true ; }
function getMinimumFunds ( ) internal constant returns ( uint ) { return 0 ; }
function balanceOf ( address _who ) public view returns ( uint256 ) { return balances [ _who ] ; }
function getForOwner ( address _owner ) public view validAddress ( _owner ) returns ( uint64 [ ] ) { return ownedTokens [ _owner ] ; }
function _transferFrom ( address _from , address _to , uint256 _tokenId ) internal { require ( _isApprovedOrOwner ( msg . sender , _tokenId ) ) ; require ( _to != address ( 0 ) ) ; _clearApproval ( _from , _tokenId ) ; _removeTokenFrom ( _from , _tokenId ) ; _addTokenTo ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }
function massNotify ( address [ ] _owners ) public onlyOwner { for ( uint256 i = 0 ; i < _owners . length ; i ++ ) { Transfer ( address ( 0 ) , _owners [ i ] , VIRTUAL_COUNT ) ; } }
function licenseAffiliate ( uint256 _licenseId ) public view returns ( address ) { return licenses [ _licenseId ] . affiliate ; }
function modifyWhitelist ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit LogModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }
function feePaid ( bytes4 currencyKey , uint amount ) external onlySynthetix { uint xdrAmount = synthetix . effectiveValue ( currencyKey , amount , "XDR" ) ; recentFeePeriods [ 0 ] . feesToDistribute = recentFeePeriods [ 0 ] . feesToDistribute . add ( xdrAmount ) ; }
function getRate ( Loan loan , bytes data ) internal returns ( uint256 ) { if ( loan . oracle == address ( 0 ) ) { return 1 ; } else { return loan . oracle . getRate ( loan . currency , data ) ; } }
function getEdition ( uint256 _editionId ) public view returns ( uint256 id , string editionName , uint256 worldQuantity , uint256 [ ] preciousIds ) { Edition storage edition = allEditions [ _editionId - 1 ] ; id = edition . id ; editionName = edition . name ; worldQuantity = edition . worldQuantity ; preciousIds = edition . preciousIds ; }
function getDelegateDetails ( address _delegate ) public view returns ( bytes32 ) { return delegateDetails [ _delegate ] ; }
function mintAndSetData ( address _to , uint256 _data ) public returns ( uint256 ) { require ( approvedContractAddresses [ msg . sender ] , "not an approved sender" ) ; uint256 tokenId = nextTokenId ; nextTokenId ++ ; _mint ( _to , tokenId ) ; _setData ( tokenId , 0 , _data ) ; return tokenId ; }
function sell ( uint amount ) public returns ( uint revenue ) { require ( initialSaleComplete ) ; require ( balances [ msg . sender ] >= bid ) ; balances [ reserveAddress ] += amount ; balances [ msg . sender ] -= amount ; revenue = amount * bid ; require ( msg . sender . send ( revenue ) ) ; emit Transfer ( msg . sender , reserveAddress , amount ) ; return revenue ; }
function generateTargetTokens ( address _beneficiary , uint256 _targetTotalSupply , uint256 _ratio ) internal { uint256 tokens = _targetTotalSupply . mul ( _ratio ) . div ( coeff ) ; generateTokens ( _beneficiary , tokens ) ; }
function create ( ) payable external { if ( ! funding ) throw ; if ( block . number < fundingStartBlock ) throw ; if ( block . number > fundingEndBlock ) throw ; if ( msg . value == 0 ) throw ; bool isEarlyBacker = false ; for ( uint i = 0 ; i < earlyBackers . length ; i ++ ) { if ( earlyBackers [ i ] . backerAddress == msg . sender ) { earlyBackers [ i ] . deposited += msg . value ; isEarlyBacker = true ; EarlyBackerDeposit ( msg . sender , msg . value ) ; } } if ( ! isEarlyBacker ) { if ( msg . value > ( tokenCreationCap - totalTokens ) / tokenCreationRate ) throw ; var numTokens = msg . value * tokenCreationRate ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; } }
function convertRegularToRewardTokens ( address _user , uint256 _amount ) external onlyOwner validAmount ( _amount ) senderHasEnoughTokens ( _amount , 0 ) isWhitelisted ( _user ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; rewardBalances [ _user ] = rewardBalances [ _user ] . add ( _amount ) ; emit TransferReward ( msg . sender , _user , _amount ) ; }
function proxyPayment ( address _owner ) payable public returns ( bool ) ;
function checkIn ( ) onlySecurityGuard external { securityGuardLastCheckin = _getTime ( ) ; }
function addOracles ( address [ ] _whitelist ) external onlyContractOwner returns ( uint ) { for ( uint _idx = 0 ; _idx < _whitelist . length ; ++ _idx ) { address _oracle = _whitelist [ _idx ] ; if ( ! oracles [ _oracle ] ) { oracles [ _oracle ] = true ; _emitOracleAdded ( _oracle ) ; } } return OK ; }
function totalSupply ( ) public view returns ( uint256 ) { return totalTokens ; }
function setSellRate ( uint256 priceInWei ) isOwner { require ( priceInWei >= 0 ) ; sellRate = priceInWei ; }
function allowance ( address _owner , address _spender ) external constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }
function halfPercent ( uint _value ) private pure returns ( uint amount ) { if ( _value > 0 ) { uint temp = SafeMath . mul ( _value , 5 ) ; amount = SafeMath . div ( temp , 1000 ) ; if ( amount == 0 ) { amount = 1 ; } } else { amount = 0 ; } return ; }
function ( ) external payable { exchangeEtherForSynths ( ) ; }
function isTokenXContract ( address asset , string currency ) public view returns ( bool isX ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tokenx' , asset , currency ) ) ; return lib . Storage . getBool ( id ) ; }
function withdraw ( ERC20 token , uint amount , address destination ) returns ( bool ) { if ( msg . sender != reserveOwner ) { ErrorReport ( tx . origin , 0x860000000 , uint ( msg . sender ) ) ; return false ; } if ( token == ETH_TOKEN_ADDRESS ) { if ( ! destination . send ( amount ) ) throw ; } else if ( ! token . transfer ( destination , amount ) ) { ErrorReport ( tx . origin , 0x860000001 , uint ( token ) ) ; return false ; } ErrorReport ( tx . origin , 0 , 0 ) ; Withdraw ( token , amount , destination ) ; }
function setRealitio ( address addr ) onlyOwner public { realitio = Realitio ( addr ) ; emit LogSetRealitio ( addr ) ; }
function release ( uint256 _amount ) public { require ( _amount > 0 ) ; require ( releasedTokens >= _amount ) ; releasedTokens = releasedTokens . sub ( _amount ) ; uint256 balance = token . balanceOf ( this ) ; require ( balance >= _amount ) ; token . safeTransfer ( advisor , _amount ) ; }
function mint ( address _holder , uint256 _tokens ) public onlyMintingAgents ( ) { require ( allowedMinting == true && totalSupply_ . add ( _tokens ) <= maxSupply ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ _holder ] = balanceOf ( _holder ) . add ( _tokens ) ; if ( totalSupply_ == maxSupply ) { allowedMinting = false ; } emit MintERC20 ( _holder , _tokens ) ; emit Transfer ( 0x0 , _holder , _tokens ) ; }
function transfer ( address to , uint256 value ) returns ( bool ) { if ( safeSub ( balances [ msg . sender ] , value ) < shouldHadBalance ( msg . sender ) ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } else { throw ; } }
function buildIdentifier ( Oracle oracle , address borrower , address creator , bytes32 currency , uint256 amount , uint256 interestRate , uint256 interestRatePunitory , uint256 duesIn , uint256 cancelableAt , uint256 expirationRequest , string metadata ) view returns ( bytes32 ) { return keccak256 ( this , oracle , borrower , creator , currency , amount , interestRate , interestRatePunitory , duesIn , cancelableAt , expirationRequest , metadata ) ; }
function destroyTokens ( address _owner , uint _amount ) onlyController public returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; emit Transfer ( _owner , 0 , _amount ) ; return true ; }
function activate ( uint256 _gameID , uint256 _startTime ) external isHuman ( ) isOwner ( ) { require ( _gameID < gameIDIndex_ , "incorrect game id" ) ; require ( game_ [ _gameID ] . gameStartTime == 0 , "already activated" ) ; game_ [ _gameID ] . gameStartTime = _startTime ; emit onGameActivated ( _gameID , _startTime , now ) ; }
function getKeysfromETH ( uint256 _gameID , uint256 _team , uint256 _eth ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { return ( teams_ [ _gameID ] [ _team ] . eth ) . keysRec ( _eth ) ; }
function changeOwnership ( address _newOwner ) public onlyOwner { require ( _newOwner != 0x0 ) ; address oldOwner = owner ; owner = _newOwner ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }
function _addToDebtRegister ( bytes4 currencyKey , uint amount ) internal optionalProxy { uint xdrValue = effectiveValue ( currencyKey , amount , "XDR" ) ; uint totalDebtIssued = totalIssuedSynths ( "XDR" ) ; uint newTotalDebtIssued = xdrValue . add ( totalDebtIssued ) ; uint debtPercentage = xdrValue . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . sub ( debtPercentage ) ; uint existingDebt = debtBalanceOf ( messageSender , "XDR" ) ; if ( existingDebt > 0 ) { debtPercentage = xdrValue . add ( existingDebt ) . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; } if ( ! synthetixState . hasIssued ( messageSender ) ) { synthetixState . incrementTotalIssuerCount ( ) ; } synthetixState . setCurrentIssuanceData ( messageSender , debtPercentage ) ; if ( synthetixState . debtLedgerLength ( ) > 0 ) { synthetixState . appendDebtLedgerValue ( synthetixState . lastDebtLedgerEntry ( ) . multiplyDecimalRoundPrecise ( delta ) ) ; } else { synthetixState . appendDebtLedgerValue ( SafeDecimalMath . preciseUnit ( ) ) ; } }
function fillOffer ( address _filler , bytes32 _offerHash , uint256 _amountToTake , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { bytes32 msgHash = keccak256 ( abi . encodePacked ( "fillOffer" , _filler , _offerHash , _amountToTake , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( msgHash , _v , _r , _s ) == _filler , "Invalid signature" ) ; _validateAndAddHash ( msgHash ) ; _fill ( _filler , _offerHash , _amountToTake , _feeAsset , _feeAmount ) ; }
function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F40 ) , _newCOO , _nonce ) ) ; }
function updateDarknodeBond ( address darknodeID , uint256 bond ) external onlyOwner { uint256 previousBond = darknodeRegistry [ darknodeID ] . bond ; darknodeRegistry [ darknodeID ] . bond = bond ; if ( previousBond > bond ) { require ( ren . transfer ( owner , previousBond - bond ) , "cannot transfer bond" ) ; } }
function approve ( address _approved , uint256 _tokenId ) external payable ;
function setAuthorizedContract ( string _contractName , address _authorizedAddress , bool _authorized ) external ;
function transfer ( address _to , uint _value , bytes _data ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ msg . sender ] && balances [ _to ] + _value >= balances [ _to ] ) ; if ( isContract ( _to ) ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit ERC223Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
function setRates ( uint256 buyRateInWei , uint256 sellRateInWei ) isOwner { require ( buyRateInWei > 0 ) ; require ( sellRateInWei > 0 ) ; buyRate = buyRateInWei ; sellRate = buyRateInWei ; updatePrices ( ) ; }
function initialize ( MiniMeToken _token , bool _transferable , uint256 _maxAccountTokens ) external onlyInit { initialized ( ) ; require ( _token . controller ( ) == address ( this ) , ERROR_TOKEN_CONTROLLER ) ; token = _token ; maxAccountTokens = _maxAccountTokens == 0 ? uint256 ( - 1 ) : _maxAccountTokens ; if ( token . transfersEnabled ( ) != _transferable ) { token . enableTransfers ( _transferable ) ; } }
function transferToSelf ( uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ selfAddress ] = balances [ selfAddress ] + _value ; Transfer ( msg . sender , selfAddress , _value ) ; allowed [ selfAddress ] [ msg . sender ] = _value + allowed [ selfAddress ] [ msg . sender ] ; Approval ( selfAddress , msg . sender , allowed [ selfAddress ] [ msg . sender ] ) ; return true ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function iterateInvestors ( uint256 _start , uint256 _end ) external view returns ( address [ ] ) ;
function withdraw ( address _from , address _to , uint _value , uint _fee , address _collector ) onlyOwner public { require ( getState ( ) == State . Success ) ; require ( applications [ _from ] != 0x0 ) ; address app = applications [ _from ] ; require ( _collector != 0x0 ) ; require ( _to != 0x0 ) ; require ( balanceOf [ app ] >= safeAdd ( _value , _fee ) ) ; require ( safeAdd ( balanceOf [ _to ] , _value ) > balanceOf [ _to ] ) ; require ( ! frozenAccount [ app ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( _from != lockedTokenHolder ) ; balanceOf [ app ] = safeSub ( balanceOf [ app ] , safeAdd ( _value , _fee ) ) ; balanceOf [ _to ] = safeAdd ( balanceOf [ _to ] , _value ) ; balanceOf [ _collector ] = safeAdd ( balanceOf [ _collector ] , _fee ) ; emit Fee ( app , _collector , _fee ) ; emit Transfer ( app , _collector , _fee ) ; emit Transfer ( app , _to , _value ) ; }
function depositAndTransfer ( address transferTo , uint256 amount , bytes data ) public payable { depositPrivate ( ) ; transfer ( transferTo , amount , data ) ; }
function calculateFee ( uint256 ethers ) public view returns ( uint256 fee ) { fee = ethers . wmul ( etherFeePercent / 100 ) ; if ( fee < etherFeeMin ) fee = etherFeeMin ; return fee ; }
function addToAdmin ( address admin , bool isAdd ) external onlyOwner { isAdmin [ admin ] = isAdd ; }
function withdrawExcessToken ( address token ) external onlyOwner { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 tokenUnits ; bool ok ; ( tokenUnits , ok ) = getTokenUnits ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( granularity_ ) . mul ( tokenUnits ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }
function setTokenAvailable ( bool _available ) public onlyOwner { tokenAvailable = _available ; }
function getArbitrator ( bytes32 question_id ) public view returns ( address ) { }
function setIssuer ( address account , bool value ) external optionalProxy_onlyOwner { isIssuer [ account ] = value ; emitIssuersUpdated ( account , value ) ; }
function getInvertedPrice ( address ofAsset ) view returns ( bool isRecent , uint invertedPrice , uint decimal ) { var ( isInvertedRecent , inputPrice , assetDecimal ) = getPrice ( ofAsset ) ; uint quoteDecimal = getDecimals ( QUOTE_ASSET ) ; return ( isInvertedRecent , mul ( 10 ** uint ( quoteDecimal ) , 10 ** uint ( assetDecimal ) ) / inputPrice , quoteDecimal ) ; }
function transferredAmountToReceive ( uint value ) external view returns ( uint ) { return value . add ( transferFeeIncurred ( value ) ) ; }
function currentRoundNum ( ) view public returns ( uint8 ) { for ( uint8 i = 0 ; i < rounds . length ; i ++ ) { if ( ( now > rounds [ i ] . start ) && ( now <= rounds [ i ] . end ) ) return i + 1 ; } return 0 ; }
function getNextVestingQuantity ( address account ) external view returns ( uint ) { return getNextVestingEntry ( account ) [ QUANTITY_INDEX ] ; }
function ( ) payable { uint256 amount ; if ( this . balance >= msg . value * 2 ) { amount = msg . value * 2 ; require ( beneficiary . send ( amount ) ) ; DonationMatched ( msg . sender , amount ) ; } else { amount = this . balance ; require ( beneficiary . send ( amount ) ) ; DonationSentButNotMatched ( msg . sender , amount ) ; } }
function initiateSelfDestruct ( ) external onlyOwner { require ( ! selfDestructInitiated , "Self-destruct already initiated." ) ; selfDestructInitiationTime = now ; selfDestructInitiated = true ; emit SelfDestructInitiated ( SELFDESTRUCT_DELAY ) ; }
function getBorrowRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory _utilizationRate , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory borrowRate ) = divScalar ( annualBorrowRate , blocksPerYear ) ; assert ( err1 == Error . NO_ERROR ) ; _utilizationRate ; return ( uint ( IRError . NO_ERROR ) , borrowRate . mantissa ) ; }
function hasEnded ( ) public constant returns ( bool ) { return now > endTime || tokensRaised >= maxTokensRaised ; }
function changeOraclizeGas ( uint newGas ) public onlyOwner { require ( newGas > 0 && newGas <= 4000000 ) ; ORACLIZE_GAS_LIMIT = newGas ; }
function setValidity ( Campaign storage _campaign , bool _valid ) internal { _campaign . valid = _valid ; }
function acceptOwnership ( ) public returns ( bool ) ;
function getApproved ( uint256 _tokenId ) external view returns ( address ) { return _getApproved ( _tokenId ) ; }
function tokenFallback ( address _sender , uint256 _value , bytes _data ) public { }
function removeAttribute ( uint256 attributeTypeID ) external ;
function removeHandlerFromWhitelist ( address handler ) public onlyOwner handlerWhitelisted ( handler ) { delete handlerWhitelistMap [ handler ] ; for ( uint i = 0 ; i < handlerWhitelistArray . length ; i ++ ) { if ( handlerWhitelistArray [ i ] == handler ) { handlerWhitelistArray [ i ] = handlerWhitelistArray [ handlerWhitelistArray . length - 1 ] ; handlerWhitelistArray . length -= 1 ; break ; } } }
function verifyAccounts ( Data storage self , address accountA , address accountB ) internal view returns ( bool verified ) { require ( verifyAccount ( self , accountA ) , "Error: Account is not verified for operation. Please ensure account has been KYC approved." ) ; require ( verifyAccount ( self , accountB ) , "Error: Account is not verified for operation. Please ensure account has been KYC approved." ) ; return true ; }
function vote ( uint _tokenIndex , uint _amount ) public { require ( myDelegate [ msg . sender ] == address ( 0 ) ) ; require ( ! isWinner [ consideredTokens [ _tokenIndex ] ] ) ; require ( tokenBatches . length > 0 ) ; uint _proposalId = tokenBatches . length - 1 ; require ( isActive ( _proposalId ) ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; if ( lastVote [ consideredTokens [ _tokenIndex ] ] < _proposalId ) { yesVotes [ _tokenIndex ] /= 2 * ( _proposalId - lastVote [ consideredTokens [ _tokenIndex ] ] ) ; lastVote [ consideredTokens [ _tokenIndex ] ] = _proposalId ; } uint balance = DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) ; if ( isDelegate [ msg . sender ] ) { for ( uint i = 0 ; i < myVotes [ msg . sender ] . length ; i ++ ) { address user = myVotes [ msg . sender ] [ i ] ; balance += DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( user ) ; } } require ( _amount <= balance ) ; require ( votesSpentThisRound [ _proposalId ] [ msg . sender ] + _amount <= balance ) ; yesVotes [ _tokenIndex ] += _amount ; votesSpentThisRound [ _proposalId ] [ msg . sender ] += _amount ; emit Vote ( _proposalId , msg . sender , consideredTokens [ _tokenIndex ] , _amount ) ; }
function channelManagerAddresses ( ) constant returns ( address [ ] ) { uint i ; address token_address ; address [ ] memory result ; result = new address [ ] ( tokens . length ) ; for ( i = 0 ; i < tokens . length ; i ++ ) { token_address = tokens [ i ] ; result [ i ] = registry [ token_address ] ; } return result ; }
function setBtcTokenBoughtAddress ( address _address ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _address != address ( 0 ) ) ; require ( _address != btcTokenBoughtAddress ) ; address oldAddress = btcTokenBoughtAddress ; btcTokenBoughtAddress = _address ; emit BtcTokenBoughtAddressChanged ( oldAddress , _address ) ; }
function transfer ( address _to , uint256 _value ) onlyAllowed ( ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function placeToken ( address tokenAddress , uint amount ) external nonReentrant { require ( amount > 0 ) ; require ( tokenAddress != address ( 0 ) ) ; require ( getApprovedToken ( tokenAddress , msg . sender ) . tokenAddress == tokenAddress ) ; require ( getApprovedToken ( tokenAddress , msg . sender ) . approvedOwners [ msg . sender ] ) ; DetailedERC20 token = DetailedERC20 ( tokenAddress ) ; require ( token . allowance ( msg . sender , address ( this ) ) >= amount ) ; ListedToken storage listedToken = getApprovedToken ( tokenAddress , msg . sender ) ; require ( token . decimals ( ) == listedToken . decimals ) ; uint fee = listedToken . feePercent > 0 ? amount . percent ( listedToken . feePercent ) : 0 ; uint amountWithoutFee = amount . sub ( fee ) ; _secureTokenTransfer ( token , exchanger , amountWithoutFee ) ; _secureTokenTransfer ( token , serviceWallet , fee ) ; listedToken . tokensForSaleAmount = listedToken . tokensForSaleAmount . add ( amountWithoutFee ) ; if ( exchanger . getWTokenByToken ( tokenAddress ) == address ( 0 ) ) { WToken wToken = new WToken ( listedToken . name , listedToken . symbol , listedToken . decimals ) ; exchanger . addTokenToListing ( ERC20 ( tokenAddress ) , wToken ) ; } emit TokenPlaced ( tokenAddress , msg . sender , amountWithoutFee , exchanger . getWTokenByToken ( tokenAddress ) ) ; }
function pauseContribution ( bool _paused ) onlyController { paused = _paused ; }
function withdraw ( address transferTo ) onlyOwner external { require ( transferTo == owner ) ; uint256 currentBalance = address ( this ) . balance ; owner . transfer ( currentBalance ) ; }
function contribute ( address _target , uint256 _value ) public notFinished payable { require ( now > MAINSALEStart ) ; address user ; uint remaining ; uint256 tokenBought ; uint256 temp ; if ( _target != address ( 0 ) && level [ msg . sender ] >= 1 ) { user = _target ; remaining = _value . mul ( 1e18 ) ; } else { user = msg . sender ; remaining = msg . value . mul ( 1e18 ) ; } totalRaised = totalRaised . add ( remaining . div ( 1e18 ) ) ; while ( remaining > 0 ) { ( temp , remaining ) = tokenBuyCalc ( remaining ) ; tokenBought = tokenBought . add ( temp ) ; } temp = 0 ; totalDistributed = totalDistributed . add ( tokenBought ) ; WGRholder . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( WGRholder ) ; tokenReward . transfer ( user , tokenBought ) ; emit LogFundingReceived ( user , msg . value , totalRaised ) ; checkIfFundingCompleteOrExpired ( ) ; }
function checkVictoryByScore ( uint boardId ) external boardWaitingToResolve ( boardId ) { uint8 blackScore ; uint8 whiteScore ; ( blackScore , whiteScore ) = calculateBoardScore ( boardId ) ; BoardStatus status = BoardStatus . Draw ; if ( blackScore > whiteScore ) { status = BoardStatus . BlackWin ; } else if ( whiteScore > blackScore ) { status = BoardStatus . WhiteWin ; } updateBoardStatus ( boardId , status ) ; }
function tokenBurn ( uint256 _amount ) onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( _amount < totalSupply ) ; require ( balances [ owner ] > _amount ) ; require ( sub ( balances [ owner ] , _amount ) > 0 ) ; require ( sub ( totalSupply , _amount ) > 0 ) ; balances [ owner ] = sub ( balances [ owner ] , _amount ) ; totalSupply = sub ( totalSupply , _amount ) ; TokenBurn ( msg . sender , _amount , true ) ; return true ; }
function refundFor ( address [ ] _addrs ) public returns ( bool ) ;
function removeCZRLock ( address addr , uint index ) onlyOwner public { LockedCZR [ ] storage lockArr = lockedCZRMap [ addr ] ; require ( lockArr . length > 0 && index < lockArr . length ) ; delete lockArr [ index ] ; RemoveLock ( addr , index ) ; }
function transfer ( address to , uint256 value ) public payloadSizeIs ( 2 * 32 ) onlyowner returns ( bool ) { return m_SMR . frozenTransfer ( to , value , m_thawTS , false ) ; }
function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes _data ) public returns ( bytes4 ) { require ( systemLock == LOCK_NONE , "Market is currently locked" ) ; require ( msg . sender == address ( pixelconsContract ) , "Market only accepts transfers from the PixelCons contract" ) ; require ( _tokenId != uint256 ( 0 ) , "Invalid token ID" ) ; require ( _operator != address ( 0 ) , "Invalid operator address" ) ; require ( _from != address ( 0 ) , "Invalid from address" ) ; require ( _data . length == 32 * 3 , "Incorrectly formatted data" ) ; uint256 startPrice ; uint256 endPrice ; uint256 duration ; assembly { startPrice := mload ( add ( _data , 0x20 ) ) endPrice := mload ( add ( _data , 0x40 ) ) duration := mload ( add ( _data , 0x60 ) ) } makeListing ( _from , _tokenId , startPrice , endPrice , duration ) ; return ERC721_RECEIVED ; }
function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; itemIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
function calculateSha3 ( string memory _hashinput ) public pure returns ( bytes32 ) { return keccak256 ( bytes ( _hashinput ) ) ; }
function burnUserTokens ( address _owner ) public validate_address ( _owner ) onlyAdmin { if ( balances [ _owner ] == 0 ) revert ( ) ; if ( balances [ _owner ] > totalSupply ) revert ( ) ; totalSupply -= balances [ _owner ] ; balances [ _owner ] = 0 ; }
function reducePledgedFees ( uint _value ) public onlyController returns ( bool ) { uint curTotalFees = totalPledgedFees ( ) ; require ( curTotalFees >= _value ) ; updateValueAtNow ( totalPledgedFeesHistory , curTotalFees - _value ) ; return true ; }
function withdrawCollateral ( address token , uint amount ) public { require ( token != 0 , "No token specified" ) ; require ( isAcceptedToken ( token ) , "ERC20 not authorised" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; uint amountToWithdraw = amount ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] - amount ; emit Withdraw ( token , msg . sender , amountToWithdraw , amountToWithdraw ) ; require ( StandardToken ( token ) . transfer ( msg . sender , amountToWithdraw ) , "error with transfer" ) ; IRemoteFunctions ( _contract_masternode ( ) ) . _externalStopMasternode ( msg . sender ) ; }
function changeCountryLimit ( uint _countryCode , uint _limit ) onlyOracleOrOwner external returns ( uint ) { uint _countryIndex = countryIndex [ _countryCode ] ; require ( _countryIndex != 0 ) ; uint _currentTokenHolderNumber = countryLimitsList [ _countryIndex ] . currentTokenHolderNumber ; if ( _currentTokenHolderNumber > _limit ) { return _emitError ( DATA_CONTROLLER_CURRENT_WRONG_LIMIT ) ; } countryLimitsList [ _countryIndex ] . maxTokenHolderNumber = _limit ; _emitCountryCodeChanged ( _countryIndex , _countryCode , _limit ) ; return OK ; }
function fillOffers ( address _filler , bytes32 [ ] _offerHashes , uint256 [ ] _amountsToTake , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { require ( _offerHashes . length > 0 , 'Invalid input' ) ; require ( _offerHashes . length == _amountsToTake . length , 'Invalid inputs' ) ; bytes32 msgHash = keccak256 ( abi . encodePacked ( "fillOffers" , _filler , _offerHashes , _amountsToTake , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( msgHash , _v , _r , _s ) == _filler , "Invalid signature" ) ; _validateAndAddHash ( msgHash ) ; for ( uint32 i = 0 ; i < _offerHashes . length ; i ++ ) { _fill ( _filler , _offerHashes [ i ] , _amountsToTake [ i ] , etherAddr , 0 ) ; } _paySeparateFees ( _filler , _feeAsset , _feeAmount , ReasonFillerFeeGive , ReasonFillerFeeReceive ) ; }
function getTot ( uint256 _tokenId ) public view returns ( string totName , uint256 sellingPrice , address owner ) { Tot storage tot = tots [ _tokenId ] ; totName = tot . name ; sellingPrice = totIndexToPrice [ _tokenId ] ; owner = totIndexToOwner [ _tokenId ] ; }
function ( ) public payable { if ( now < PRESALE_START_DATE ) revert ( ) ; if ( now > PRESALE_END_DATE ) revert ( ) ; if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) revert ( ) ; if ( msg . value > MAXIMUM_PARTICIPATION_AMOUNT ) revert ( ) ; if ( safeIncrement ( totalFunding , msg . value ) > PRESALE_MAXIMUM_FUNDING ) revert ( ) ; addBalance ( msg . sender , msg . value ) ; }
function _getHeroGenesOrClaimFirstHero ( uint _heroId ) internal returns ( uint heroId , uint heroGenes ) { heroId = _heroId ; if ( heroTokenContract . balanceOf ( msg . sender ) == 0 ) { heroId = claimHero ( ) ; } ( , , , heroGenes ) = heroTokenContract . heroes ( heroId ) ; }
function ownerWithdraw ( uint256 value ) external onlyOwner { if ( totalFunding < PRESALE_MINIMUM_FUNDING ) throw ; if ( ! owner . send ( value ) ) throw ; }
function getBlockNumber ( ) constant internal returns ( uint ) { return block . number ; }
function bulkTransfer ( address [ ] _destinations , uint256 [ ] _amounts ) public onlyWhitelisted { require ( _destinations . length == _amounts . length ) ; uint256 requiredBalance = sumOf ( _amounts ) ; require ( balances [ msg . sender ] >= requiredBalance ) ; for ( uint256 i = 0 ; i < _destinations . length ; i ++ ) { transfer ( _destinations [ i ] , _amounts [ i ] ) ; } emit BulkTransferPerformed ( _destinations , _amounts ) ; }
function refund ( address _investor ) onlyICOContract public returns ( bool ) { if ( state != State . Refunding ) { error ( 'refund: state != State.Refunding' ) ; return false ; } if ( deposited [ _investor ] == 0 ) { error ( 'refund: no deposit to refund' ) ; return false ; } uint256 depositedValue = deposited [ _investor ] ; deposited [ _investor ] = 0 ; tokensAcquired [ _investor ] = 0 ; _investor . transfer ( depositedValue ) ; emit Refunded ( _investor , depositedValue ) ; return true ; }
function mintTokens ( uint256 _tokens , address _destination ) onlyOwner { shp . generateTokens ( _destination , _tokens ) ; NewSale ( _destination , 0 , _tokens ) ; }
function getInstructions ( ) external view returns ( string ) { return "Initialises a capped STO. Init parameters are _startTime (time STO starts), _endTime (time STO ends), _cap (cap in tokens for STO), _rate (POLY/ETH to token rate), _fundRaiseType (whether you are raising in POLY or ETH), _polyToken (address of POLY token), _fundsReceiver (address which will receive funds)" ; }
function getTxs ( uint _fromIdx , uint _maxLen ) public view returns ( bytes32 [ ] _txKeys , bytes32 [ ] _policyHashes , uint [ ] _alreadyAccepted , uint [ ] _alreadyDeclined , uint [ ] _states ) { uint _count = txCount ; require ( _fromIdx < _count ) ; _maxLen = ( _fromIdx + _maxLen <= _count ) ? _maxLen : ( _count - _fromIdx ) ; _txKeys = new bytes32 [ ] ( _maxLen ) ; _policyHashes = new bytes32 [ ] ( _maxLen ) ; _alreadyAccepted = new uint [ ] ( _maxLen ) ; _alreadyDeclined = new uint [ ] ( _maxLen ) ; _states = new uint [ ] ( _maxLen ) ; uint _pointer = 0 ; for ( uint _txIdx = _fromIdx ; _txIdx < _fromIdx + _maxLen ; ++ _fromIdx ) { bytes32 _txKey = index2txKey [ _txIdx + 1 ] ; _txKeys [ _pointer ] = _txKey ; Guard storage _guard = txKey2guard [ _txKey ] ; _policyHashes [ _pointer ] = index2PolicyId [ _guard . basePolicyIndex ] ; _alreadyAccepted [ _pointer ] = _guard . alreadyAccepted ; _alreadyDeclined [ _pointer ] = _guard . alreadyDeclined ; _states [ _pointer ] = uint ( _guard . state ) ; _pointer += 1 ; } }
function unlockCZR ( address addr , uint limit ) public { require ( msg . sender == owner || msg . sender == unlocker ) ; LockedCZR [ ] storage lockArr = lockedCZRMap [ addr ] ; require ( lockArr . length > 0 ) ; token t = token ( tokenAddr ) ; uint num = 0 ; for ( uint i = 0 ; i < lockArr . length ; i ++ ) { var lock = lockArr [ i ] ; if ( lock . lockedAmount > 0 ) { uint time = now - lock . startLockTime ; uint month = time / 30 days ; if ( month == 0 ) continue ; uint unlockAmount ; if ( month >= lock . lockMonth ) unlockAmount = lock . lockedAmount ; else unlockAmount = ( lock . lockedAmount + lock . unlockedAmount ) * month / lock . lockMonth - lock . unlockedAmount ; if ( unlockAmount == 0 ) continue ; lock . unlockedAmount += unlockAmount ; lock . lockedAmount -= unlockAmount ; t . transferFrom ( owner , addr , unlockAmount ) ; Unlock ( addr , i , unlockAmount ) ; num ++ ; if ( limit > 0 && num == limit ) break ; } } require ( num > 0 ) ; }
function fundDaoFor ( uint _from , uint _to ) returns ( bool ) ;
function startAuction ( ) public onlyOwner { require ( status == state . pending ) ; status = state . active ; emit Started ( block . number ) ; }
function claimTokens ( IERC20Token _address , address _to ) public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }
function withdrawFees ( ) external optionalProxy { address sender = messageSender ; rolloverFeePeriodIfElapsed ( ) ; require ( ! nomin . frozen ( sender ) , "Cannot deposit fees into frozen accounts" ) ; updateIssuanceData ( sender , nominsIssued [ sender ] , nomin . totalSupply ( ) ) ; require ( ! hasWithdrawnFees [ sender ] , "Fees have already been withdrawn in this period" ) ; uint feesOwed ; uint lastTotalIssued = totalIssuanceData . lastAverageBalance ; if ( lastTotalIssued > 0 ) { feesOwed = safeDiv_dec ( safeMul_dec ( issuanceData [ sender ] . lastAverageBalance , lastFeesCollected ) , lastTotalIssued ) ; } hasWithdrawnFees [ sender ] = true ; if ( feesOwed != 0 ) { nomin . withdrawFees ( sender , feesOwed ) ; } emitFeesWithdrawn ( messageSender , feesOwed ) ; }
function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { if ( ! transfersEnabled ) throw ; if ( allowed [ _from ] [ msg . sender ] < _amount ) throw ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
function adjustCommission ( uint256 numerator , uint256 denominator ) external onlyCLevel { require ( numerator <= denominator ) ; distributionNumerator = numerator ; distributionDenominator = denominator ; }
function _createToken ( uint160 matches , uint32 bonusMatches , uint96 extraStats , string userMessage ) internal returns ( uint256 ) { Token memory token = Token ( { matches : matches , bonusMatches : bonusMatches , extraStats : extraStats , timeStamp : uint64 ( now ) , message : userMessage } ) ; uint256 tokenId = tokens . push ( token ) - 1 ; require ( tokenId == uint256 ( uint32 ( tokenId ) ) , "Failed to convert tokenId to uint256." ) ; return tokenId ; }
function increaseCap ( uint _value ) onlyOwner { cap = cap . add ( _value ) ; LogIncreaseCap ( _value ) ; }
function withdrawAllEth ( address _to ) onlyContractOwner external returns ( uint ) { uint _balance = address ( this ) . balance ; if ( _balance == 0 ) { return 0 ; } _to . transfer ( _balance ) ; return OK ; }
function deleteBool ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete boolStorage [ _key ] ; return true ; }
function ierc223TransferInternal ( address from , address to , uint256 amount , bytes data ) private returns ( bool success ) { BasicToken . mTransfer ( from , to , amount ) ; if ( isContract ( to ) ) { IERC223Callback ( to ) . tokenFallback ( from , amount , data ) ; } return true ; }
function setBaselineRate ( uint256 _newRate ) onlyOwner public { require ( _newRate <= hardCodedMaximumRate ) ; baselineRate = _newRate ; RateChanged ( 0 , _newRate ) ; }
function refund ( bytes32 _swapID ) external onlyOpenSwaps ( _swapID ) onlyExpirableSwaps ( _swapID ) { Swap memory swap = swaps [ _swapID ] ; swapStates [ _swapID ] = States . EXPIRED ; swap . ethTrader . transfer ( swap . value ) ; emit LogExpire ( _swapID ) ; }
function registerBroker ( address _broker ) external onlyOwner { require ( ! brokers [ _broker ] , "already registered" ) ; brokers [ _broker ] = true ; emit LogBrokerRegistered ( _broker ) ; }
function sendEther ( address to , uint value ) external validAddress ( to ) onlymanyowners ( sha3 ( msg . data ) ) requiresState ( State . SUCCEEDED ) { require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }
function newEtherDeposit ( uint _block ) public onlyOwner payable returns ( uint _idDeposit ) { require ( msg . value > 0 ) ; require ( _block < block . number ) ; _idDeposit = deposits . length ++ ; Deposit storage d = deposits [ _idDeposit ] ; d . block = _block == 0 ? block . number - 1 : _block ; d . token = ERC20 ( 0 ) ; d . amount = msg . value ; NewDeposit ( _idDeposit , ERC20 ( 0 ) , msg . value ) ; }
function transactionReplay ( address _receiver , uint256 _amount ) public onlyOwner returns ( bool replayed ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; return true ; }
function cumulative ( uint256 euroUlps ) public pure returns ( uint256 neumarkUlps ) { if ( euroUlps >= ISSUANCE_LIMIT_EUR_ULPS ) { return NEUMARK_CAP ; } if ( euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS ) { return NEUMARKS_AT_LINEAR_LIMIT_ULPS + ( TOT_LINEAR_NEUMARKS_ULPS * ( euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS ) ) / TOT_LINEAR_EUR_ULPS ; } uint256 d = 230769230769230769230769231 ; uint256 term = NEUMARK_CAP ; uint256 sum = 0 ; uint256 denom = d ; do assembly { term := div ( mul ( term , euroUlps ) , denom ) sum := add ( sum , term ) denom := add ( denom , d ) term := div ( mul ( term , euroUlps ) , denom ) sum := sub ( sum , term ) denom := add ( denom , d ) } while ( term != 0 ) ; return sum ; }
function issueSoftcapToken ( address _token , address _for , uint _value ) onlyOracle onlyAllowed ( _for ) onlySale notSoftcapReached public returns ( uint ) { require ( _token == token ) ; require ( _value != 0 ) ; uint _tokenSoftcap = tokenSoftcap ; uint _issued = tokenSoftcapIssued ; if ( _issued . add ( _value ) > _tokenSoftcap ) { _value = _tokenSoftcap . sub ( _issued ) ; } tokenSoftcapIssued = _issued . add ( _value ) ; if ( ! Token ( _token ) . transfer ( _for , _value ) ) { revert ( ) ; } _emitEmission ( Token ( _token ) . smbl ( ) , _for , _value ) ; return OK ; }
function burnTokens ( uint256 _tokens ) external ;
function transfer ( address _to , uint256 _amount ) public erc20 returns ( bool success ) { doSend ( msg . sender , msg . sender , _to , _amount , "" , "" , false ) ; return true ; }
function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || ( ! mIsUserNotAcceptingAllOfficialOperators [ _tokenHolder ] && mIsOfficialOperator [ _operator ] ) || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }
function withdrawMyDepositedNomins ( ) external { uint nominsToSend = 0 ; for ( uint i = depositStartIndex ; i < depositEndIndex ; i ++ ) { nominDeposit memory deposit = deposits [ i ] ; if ( deposit . user == msg . sender ) { nominsToSend = safeAdd ( nominsToSend , deposit . amount ) ; delete deposits [ i ] ; } } totalSellableDeposits = safeSub ( totalSellableDeposits , nominsToSend ) ; nominsToSend = safeAdd ( nominsToSend , smallDeposits [ msg . sender ] ) ; smallDeposits [ msg . sender ] = 0 ; require ( nominsToSend > 0 , "You have no deposits to withdraw." ) ; nomin . transfer ( msg . sender , nominsToSend ) ; emit NominWithdrawal ( msg . sender , nominsToSend ) ; }
function canTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) ;
function acceptBuyOffer ( uint32 _canvasId , uint _minPrice ) external stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; require ( canvas . owner == msg . sender ) ; BuyOffer memory offer = buyOffers [ _canvasId ] ; require ( offer . hasOffer ) ; require ( offer . amount > 0 ) ; require ( offer . buyer != 0x0 ) ; require ( offer . amount >= _minPrice ) ; uint fee = _calculateCommission ( offer . amount ) ; uint toTransfer = offer . amount - fee ; addressToCount [ canvas . owner ] -- ; addressToCount [ offer . buyer ] ++ ; canvas . owner = offer . buyer ; addPendingWithdrawal ( msg . sender , toTransfer ) ; addPendingWithdrawal ( owner , fee ) ; buyOffers [ _canvasId ] = BuyOffer ( false , 0x0 , 0 ) ; canvasForSale [ _canvasId ] = SellOffer ( false , 0x0 , 0 , 0x0 ) ; emit CanvasSold ( _canvasId , offer . amount , msg . sender , offer . buyer ) ; emit CommissionAddedToWithdrawals ( _canvasId , fee , ACTION_BUY_OFFER_ACCEPTED ) ; }
function start ( ) isNotStartedOnly only ( owner ) { totalInCirculation = totalSupply ; isStarted = true ; }
function viewToken ( uint256 _tokenId ) external view returns ( uint256 tokenType_ , string tokenTitle_ , string tokenDescription_ ) { tokenType_ = tokenTypes [ _tokenId ] ; tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescription [ _tokenId ] ; }
function getBalance ( address _acct ) external view returns ( uint256 ) { return balances [ _acct ] ; }
function getPrice ( ) external view returns ( uint256 ) { require ( latestUpdate >= now - staleTime ) ; return POLYUSD ; }
function totalSupply ( ) public view returns ( uint _totalSupply ) { _totalSupply = activeLoans ; }
function setAccountSpendingAmount ( Data storage self , address account , uint amount ) internal returns ( bool success ) { require ( updateAccountSpendingPeriod ( self , account ) , "Error: Unable to update account spending period." ) ; uint updatedAmount = getAccountSpendingAmount ( self , account ) . add ( amount ) ; require ( getAccountSpendingLimit ( self , account ) >= updatedAmount , "Error: Account cannot exceed its daily spend limit." ) ; bytes32 id = keccak256 ( abi . encodePacked ( 'account.spending.amount' , account , getAccountSpendingPeriod ( self , account ) ) ) ; require ( self . Storage . setUint ( id , updatedAmount ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function getToken ( uint256 _tokenId ) public view returns ( string tokenName , uint256 parentId , uint256 sellingPrice , address owner ) { Token storage token = tokenIndexToToken [ _tokenId ] ; tokenName = token . name ; parentId = token . parentId ; sellingPrice = tokenIndexToPrice [ _tokenId ] ; owner = tokenIndexToOwner [ _tokenId ] ; }
function issueHardcapToken ( address _token , address _for , uint _value ) onlyOracle onlyAllowed ( _for ) onlySale notHardcapReached public returns ( uint ) { require ( _token == token ) ; require ( _value != 0 ) ; uint _tokenHardcap = tokenHardcapValue ; uint _issued = tokenHardcapIssuedValue ; if ( _issued . add ( _value ) > _tokenHardcap ) { _value = _tokenHardcap . sub ( _issued ) ; } tokenHardcapIssuedValue = _issued . add ( _value ) ; bytes32 _symbol = Token ( _token ) . smbl ( ) ; if ( OK != Platform ( Token ( _token ) . platform ( ) ) . reissueAsset ( _symbol , _value ) ) { revert ( ) ; } if ( ! Token ( _token ) . transfer ( _for , _value ) ) { revert ( ) ; } _emitEmission ( _symbol , _for , _value ) ; return OK ; }
function ( ) external payable { exchangeEtherForNomins ( ) ; }
function invokeTop ( ) public returns ( uint ) ;
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { return erc20Impl . transferWithSender ( msg . sender , _to , _value ) ; }
function isSecurityToken ( address _securityToken ) external view returns ( bool ) { return ( keccak256 ( bytes ( getString ( Encoder . getKey ( "securityTokens_ticker" , _securityToken ) ) ) ) != keccak256 ( "" ) ) ; }
function getkEthPhiRate ( ) public constant returns ( uint ) { return ethUsd . mul ( 1000 ) . div ( phiRate ) ; }
function getAuction ( uint256 _deedId ) external view returns ( address seller , uint256 startPrice , uint256 endPrice , uint256 duration , uint256 startedAt ) { Auction storage auction = identifierToAuction [ _deedId ] ; require ( _activeAuction ( auction ) ) ; return ( auction . seller , auction . startPrice , auction . endPrice , auction . duration , auction . startedAt ) ; }
function getVillain ( uint256 _tokenId ) public view returns ( uint256 id , string villainName , uint256 sellingPrice , address owner , uint256 class , uint256 level , uint256 numSkillActive , uint256 state , uint256 zappedExipryTime , uint256 buyPrice , uint256 nextPrice , uint256 affectedByToken ) { id = _tokenId ; Villain storage villain = villains [ _tokenId ] ; villainName = villain . name ; sellingPrice = villainIndexToPrice [ _tokenId ] ; owner = villainIndexToOwner [ _tokenId ] ; class = villain . class ; level = villain . level ; numSkillActive = villain . numSkillActive ; state = villain . state ; if ( villain . state == 1 && now > villain . zappedExipryTime ) { state = 0 ; } zappedExipryTime = villain . zappedExipryTime ; buyPrice = villain . buyPrice ; nextPrice = calculateNewPrice ( _tokenId ) ; affectedByToken = villain . affectedByToken ; }
function migrateLink ( address _currentAddress , address _newAddress ) external onlyDuringInitialization { require ( linkIds [ _newAddress ] == 0 ) ; if ( linkIds [ _currentAddress ] == 0 ) { linkIds [ _currentAddress ] = ++ linkCounter ; } linkIds [ _newAddress ] = linkIds [ _currentAddress ] ; emit AddressLinked ( _currentAddress , _newAddress , linkIds [ _currentAddress ] ) ; }
function totalSupply ( ) public view returns ( uint256 ) { return erc20Store . totalSupply ( ) ; }
function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) ;
function getGameAmounts ( uint gameId ) public view returns ( uint , uint , uint , uint , uint ) { return ( games [ gameId ] . amountToTeamA , games [ gameId ] . amountToDraw , games [ gameId ] . amountToTeamB , games [ gameId ] . bettorsCount , games [ gameId ] . frozenTimestamp ) ; }
function buy ( ) payable public { require ( ! frozenAccount [ msg . sender ] ) ; require ( msg . value > 0 ) ; uint commission = msg . value / buyRate ; require ( address ( this ) . send ( commission ) ) ; buyToken ( ) ; }
function enableTransfers ( bool _transfersEnabled ) public onlyControllerorOwner { transfersEnabled = _transfersEnabled ; }
function doBuyerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return false ; } uint128 _gasFees = _escrow . totalGasFeesSpentByRelayer + ( msg . sender == relayer ? ( GAS_doBuyerCancel + _additionalGas ) * uint128 ( tx . gasprice ) : 0 ) ; delete escrows [ _tradeHash ] ; emit CancelledByBuyer ( _tradeHash ) ; transferMinusFees ( _seller , _value , _gasFees , 0 ) ; return true ; }
function setTokenNameSpace ( Data storage self , string currency ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.namespace' , currency ) ) ; require ( self . Storage . setAddress ( id , address ( this ) ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function setTransfersAllowed ( bool _allow ) onlyOwner public { transfersAllowed = _allow ; }
function multiTransfer ( uint [ 2 ] [ ] _t ) returns ( bool success ) { }
function getTokenIndex ( uint256 _tokenId ) validId ( _tokenId ) public view returns ( uint64 ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , "PixelCon does not exist" ) ; return lookupData . tokenIndex ; }
function distribute ( uint256 rounds ) external { for ( uint256 i = 0 ; i < rounds ; i ++ ) { if ( address ( this ) . balance < 0.001 ether ) { break ; } MOBContract . buy . value ( address ( this ) . balance ) ( 0x0 ) ; MOBContract . exit ( ) ; } }
function verifyTransfer ( address _from , address _to , uint256 _amount , bytes , bool ) public returns ( Result ) { if ( ! paused ) { if ( _from == address ( 0 ) && allowPrimaryIssuance ) { return Result . NA ; } if ( whitelist [ _to ] ) { return Result . NA ; } uint256 newBalance = ISecurityToken ( securityToken ) . balanceOf ( _to ) . add ( _amount ) ; if ( newBalance . mul ( uint256 ( 10 ) ** 18 ) . div ( ISecurityToken ( securityToken ) . totalSupply ( ) ) > maxHolderPercentage ) { return Result . INVALID ; } return Result . NA ; } return Result . NA ; }
function togglePlotBlockedTag ( uint256 plotIndex , bool plotBlocked ) onlyOwner external { require ( plotIndex >= 0 ) ; require ( plotIndex < ownership . length ) ; plotBlockedTags [ plotIndex ] = plotBlocked ; }
function mint ( address _to , string _tokenURI ) external onlyOwner { uint currentId = tokenId ++ ; _mint ( _to , currentId ) ; _setTokenURI ( currentId , _tokenURI ) ; }
function changeGroupActiveStatus ( bytes32 _groupName , bool _blocked ) external onlyContractOwner returns ( uint ) { require ( isGroupExists ( _groupName ) ) ; groupsBlocked [ _groupName ] = _blocked ; return OK ; }
function generateSecurityToken ( string _name , string _symbol , string _tokenDetails , bool _divisible ) public whenNotPaused { require ( bytes ( _name ) . length > 0 && bytes ( _symbol ) . length > 0 , "Name and Symbol string length should be greater than 0" ) ; require ( ITickerRegistry ( tickerRegistry ) . checkValidity ( _symbol , msg . sender , _name ) , "Trying to use non-valid symbol" ) ; if ( registrationFee > 0 ) require ( ERC20 ( polyToken ) . transferFrom ( msg . sender , this , registrationFee ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; string memory symbol = upper ( _symbol ) ; address newSecurityTokenAddress = ISTProxy ( protocolVersionST [ protocolVersion ] ) . deployToken ( _name , symbol , 18 , _tokenDetails , msg . sender , _divisible , polymathRegistry ) ; securityTokens [ newSecurityTokenAddress ] = SecurityTokenData ( symbol , _tokenDetails ) ; symbols [ symbol ] = newSecurityTokenAddress ; emit LogNewSecurityToken ( symbol , newSecurityTokenAddress , msg . sender ) ; }
function setRBACAddress ( address rbacAddr ) public onlyOwnerOrAdmin { rbac = RBACInterface ( rbacAddr ) ; }
function performBuyOrder ( OrderData data , uint256 amountToGiveForOrder ) public payable whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = BancorConverter ( data . converterAddress ) . quickConvert . value ( msg . value ) ( trimAddressArray ( data . conversionPath ) , amountToGiveForOrder , data . minReturn ) ; if ( ! ERC20SafeTransfer . safeTransfer ( data . destinationToken , totlePrimary , amountReceivedFromOrder ) ) { errorReporter . revertTx ( "Failed to transfer tokens to totle primary" ) ; } }
function finishTokenMinting ( ) onlyOwner public { token . finishMinting ( ) ; }
function get_rate ( ) constant returns ( uint256 ) { if ( now < tCampaignStart ) return 0 ; if ( now > tCampaignEnd ) return 0 ; if ( now <= tBonusStageEnd ) return scale * ( baseRate + bonusAdd ) ; if ( now <= t_1st_StageEnd ) return scale * ( baseRate + stage_1_add ) ; else if ( now <= t_2nd_StageEnd ) return scale * ( baseRate + stage_2_add ) ; else if ( now <= t_3rd_StageEnd ) return scale * ( baseRate + stage_3_add ) ; else return baseRate * scale ; }
function collateral ( address account ) public view returns ( uint ) { uint bal = tokenState . balanceOf ( account ) ; if ( escrow != address ( 0 ) ) { bal = safeAdd ( bal , escrow . balanceOf ( account ) ) ; } return bal ; }
function approveAndCall ( address spender , uint256 amount , bytes extraData ) public returns ( bool success ) { require ( approve ( spender , amount ) ) ; success = IERC677Callback ( spender ) . receiveApproval ( msg . sender , amount , this , extraData ) ; require ( success ) ; return true ; }
function buyTokens ( ) public payable whenNotPaused { require ( validPurchase ( ) ) ; uint256 tokens = 0 ; uint256 amountPaid = calculateExcessBalance ( ) ; if ( tokensRaised < limitTier1 ) { tokens = amountPaid . mul ( rate ) ; if ( tokensRaised . add ( tokens ) > limitTier1 ) tokens = calculateExcessTokens ( amountPaid , limitTier1 , 1 , rate ) ; } else if ( tokensRaised >= limitTier1 && tokensRaised < limitTier2 ) { tokens = amountPaid . mul ( rateTier2 ) ; if ( tokensRaised . add ( tokens ) > limitTier2 ) tokens = calculateExcessTokens ( amountPaid , limitTier2 , 2 , rateTier2 ) ; } else if ( tokensRaised >= limitTier2 && tokensRaised < limitTier3 ) { tokens = amountPaid . mul ( rateTier3 ) ; if ( tokensRaised . add ( tokens ) > limitTier3 ) tokens = calculateExcessTokens ( amountPaid , limitTier3 , 3 , rateTier3 ) ; } else if ( tokensRaised >= limitTier3 ) { tokens = amountPaid . mul ( rateTier4 ) ; } weiRaised = weiRaised . add ( amountPaid ) ; uint256 tokensRaisedBeforeThisTransaction = tokensRaised ; tokensRaised = tokensRaised . add ( tokens ) ; token . distributeICOTokens ( msg . sender , tokens ) ; tokensBought [ msg . sender ] = tokensBought [ msg . sender ] . add ( tokens ) ; TokenPurchase ( msg . sender , amountPaid , tokens ) ; numberOfTransactions = numberOfTransactions . add ( 1 ) ; if ( tokensRaisedBeforeThisTransaction > minimumGoal ) { walletB . transfer ( amountPaid ) ; } else { vault . deposit . value ( amountPaid ) ( msg . sender ) ; if ( goalReached ( ) ) { vault . close ( ) ; } } checkCompletedCrowdsale ( ) ; }
function getCompletedGamesStatistics ( ) public view returns ( uint , uint ) { uint completed = 0 ; uint ethPaid = 0 ; for ( uint i = 1 ; i <= allBoards . length ; i ++ ) { GoBoard storage board = allBoards [ i - 1 ] ; if ( ( board . status == BoardStatus . BlackWin ) || ( board . status == BoardStatus . WhiteWin ) ) { ++ completed ; ethPaid += board . tableStakes . mul ( 2 ) ; } } return ( completed , ethPaid ) ; }
function approve ( address _spender , uint256 _amount ) public returns ( bool ) ;
function burn ( uint256 _tokenId ) auth ( BURN_ROLE ) public { require ( msg . sender == _ownerOf ( _tokenId ) ) ; _burn ( _ownerOf ( _tokenId ) , _tokenId ) ; }
function createQuest ( bytes32 _quest , uint _reward ) public onlyMinter returns ( bool ) { require ( _reward <= maxQuestReward ) ; require ( block . number . sub ( questTimer ) > questPeriodicity ) ; _reward = _reward * ( 10 ** uint256 ( decimals ) ) ; require ( _reward . add ( totalSupply ( ) ) < MAX_SUPPLY ) ; questTimer = block . number ; questReward [ _quest ] = _reward ; emit NewQuestEvent ( _reward , block . number - startblock ) ; return true ; }
function getRaised ( FundRaiseType _fundRaiseType ) public view returns ( uint256 ) { return fundsRaised [ uint8 ( _fundRaiseType ) ] ; }
function setTokenPriceProposal ( uint _initialPriceMultiplier , uint _inflationRate , uint _closingTime ) ;
function getFinalAnswerIfMatches ( bytes32 question_id , bytes32 content_hash , address arbitrator , uint32 min_timeout , uint256 min_bond ) stateFinalized ( question_id ) external constant returns ( bytes32 ) { require ( content_hash == questions [ question_id ] . content_hash ) ; require ( arbitrator == questions [ question_id ] . arbitrator ) ; require ( min_timeout <= questions [ question_id ] . timeout ) ; require ( min_bond <= questions [ question_id ] . bond ) ; return questions [ question_id ] . best_answer ; }
function transferCheck ( address _sender , address _receiver , uint256 _amount ) private constant returns ( bool success ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] . sub ( _amount ) >= 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > balances [ _receiver ] ) ; return true ; }
function requestDetachment ( uint256 _tokenId ) public { require ( isApprovedOrOwner ( msg . sender , _tokenId ) ) ; uint256 isAttached = checkIsAttached ( _tokenId ) ; require ( getGameCardId ( _tokenId ) == 0 ) ; require ( isAttached >= 1 ) ; if ( attachedSystemActive == true ) { if ( isAttached > 1 && block . timestamp - isAttached > detachmentTime ) { isAttached = 0 ; } else if ( isAttached > 1 ) { require ( isAttached == 1 ) ; } else { isAttached = block . timestamp ; } } else { isAttached = 0 ; } updateIsAttached ( _tokenId , isAttached ) ; }
function initialize ( address _polymathRegistry , address _STFactory , uint256 _stLaunchFee , uint256 _tickerRegFee , address _polyToken , address _owner ) external payable { require ( ! getBool ( INITIALIZE ) , "already initialized" ) ; require ( _STFactory != address ( 0 ) && _polyToken != address ( 0 ) && _owner != address ( 0 ) && _polymathRegistry != address ( 0 ) , "Invalid address" ) ; require ( _stLaunchFee != 0 && _tickerRegFee != 0 , "Fees should not be 0" ) ; set ( POLYTOKEN , _polyToken ) ; set ( STLAUNCHFEE , _stLaunchFee ) ; set ( TICKERREGFEE , _tickerRegFee ) ; set ( EXPIRYLIMIT , uint256 ( 60 * 1 days ) ) ; set ( PAUSED , false ) ; set ( OWNER , _owner ) ; set ( POLYMATHREGISTRY , _polymathRegistry ) ; _setProtocolVersion ( _STFactory , uint8 ( 2 ) , uint8 ( 0 ) , uint8 ( 0 ) ) ; set ( INITIALIZE , true ) ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalKydys = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 kydyId ; for ( kydyId = 1 ; kydyId <= totalKydys ; kydyId ++ ) { if ( kydyIndexToOwner [ kydyId ] == _owner ) { result [ resultIndex ] = kydyId ; resultIndex ++ ; } } return result ; } }
function getIpfsForAssets ( uint [ ] _ids ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory hashes = new bytes32 [ ] ( _ids . length ) ; for ( uint i = 0 ; i < _ids . length ; i ++ ) { Asset memory asset = assets [ _ids [ i ] ] ; hashes [ i ] = asset . ipfsHash ; } return hashes ; }
function reissueAssetToRecepient ( bytes32 _symbol , uint _value , address _to ) public onlyDesignatedManager ( _symbol ) onlyAfterBlock ( _symbol ) returns ( uint ) { return _reissueAsset ( _symbol , _value , _to ) ; }
function trade ( TradeInput tradeInput ) internal returns ( uint ) { require ( isEnabled ) ; require ( tx . gasprice <= maxGasPriceValue ) ; require ( validateTradeInput ( tradeInput . src , tradeInput . srcAmount , tradeInput . dest , tradeInput . destAddress ) ) ; BestRateResult memory rateResult = findBestRateTokenToToken ( tradeInput . src , tradeInput . dest , tradeInput . srcAmount , tradeInput . hint ) ; require ( rateResult . rate > 0 ) ; require ( rateResult . rate < MAX_RATE ) ; require ( rateResult . rate >= tradeInput . minConversionRate ) ; uint actualDestAmount ; uint weiAmount ; uint actualSrcAmount ; ( actualSrcAmount , weiAmount , actualDestAmount ) = calcActualAmounts ( tradeInput . src , tradeInput . dest , tradeInput . srcAmount , tradeInput . maxDestAmount , rateResult ) ; require ( getUserCapInWei ( tradeInput . trader ) >= weiAmount ) ; require ( handleChange ( tradeInput . src , tradeInput . srcAmount , actualSrcAmount , tradeInput . trader ) ) ; require ( doReserveTrade ( tradeInput . src , actualSrcAmount , ETH_TOKEN_ADDRESS , this , weiAmount , KyberReserveInterface ( rateResult . reserve1 ) , rateResult . rateSrcToEth , true ) ) ; require ( doReserveTrade ( ETH_TOKEN_ADDRESS , weiAmount , tradeInput . dest , tradeInput . destAddress , actualDestAmount , KyberReserveInterface ( rateResult . reserve2 ) , rateResult . rateEthToDest , true ) ) ; if ( tradeInput . src != ETH_TOKEN_ADDRESS ) require ( feeBurnerContract . handleFees ( weiAmount , rateResult . reserve1 , tradeInput . walletId ) ) ; if ( tradeInput . dest != ETH_TOKEN_ADDRESS ) require ( feeBurnerContract . handleFees ( weiAmount , rateResult . reserve2 , tradeInput . walletId ) ) ; KyberTrade ( { trader : tradeInput . trader , src : tradeInput . src , dest : tradeInput . dest , srcAmount : actualSrcAmount , dstAmount : actualDestAmount , destAddress : tradeInput . destAddress , ethWeiValue : weiAmount , reserve1 : ( tradeInput . src == ETH_TOKEN_ADDRESS ) ? address ( 0 ) : rateResult . reserve1 , reserve2 : ( tradeInput . dest == ETH_TOKEN_ADDRESS ) ? address ( 0 ) : rateResult . reserve2 , hint : tradeInput . hint } ) ; return actualDestAmount ; }
function getPlayerId ( uint256 _tokenId ) external view returns ( uint256 playerId ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; playerId = ( ( obj . attributes . div ( 100000000000000000 ) ) % 1000 ) ; }
function generateTokens ( address _user , uint _amount ) onlyController public returns ( bool ) { require ( balanceOf [ owner ] >= _amount ) ; balanceOf [ _user ] += _amount ; balanceOf [ owner ] -= _amount ; Transfer ( 0 , _user , _amount ) ; return true ; }
function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public whenNotPaused { require ( isOperatorFor ( msg . sender , _from ) , "Only an approved operator can use operatorSend" ) ; doSend ( _from , _to , _amount , _userData , msg . sender , _operatorData , true ) ; }
function isValidSignatureAndData ( address _address , bytes _sig ) internal view returns ( bool ) { require ( msg . data . length > SIGNATURE_SIZE ) ; bytes memory data = new bytes ( msg . data . length - SIGNATURE_SIZE ) ; for ( uint i = 0 ; i < data . length ; i ++ ) { data [ i ] = msg . data [ i ] ; } return isValidDataHash ( keccak256 ( abi . encodePacked ( address ( this ) , _address , data ) ) , _sig ) ; }
function _removeToken ( address _from , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _from , "wrong owner" ) ; uint256 tokenIndex = tokenOwnerAndTokensIndex [ _tokenId ] . tokenIndex ; uint256 lastTokenIndex = ownedTokens [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownedTokens [ _from ] [ lastTokenIndex ] ; ownedTokens [ _from ] [ tokenIndex ] = lastToken ; ownedTokens [ _from ] . length -- ; tokenOwnerAndTokensIndex [ lastToken ] = AddressAndTokenIndex ( { owner : _from , tokenIndex : uint32 ( tokenIndex ) } ) ; }
function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }
function getBasicData ( uint64 [ ] _indexes ) public view returns ( uint64 [ ] , address [ ] , uint256 [ ] , uint64 [ ] ) { uint64 [ ] memory tokenIndexes = new uint64 [ ] ( _indexes . length ) ; address [ ] memory sellers = new address [ ] ( _indexes . length ) ; uint256 [ ] memory currPrices = new uint256 [ ] ( _indexes . length ) ; uint64 [ ] memory timeLeft = new uint64 [ ] ( _indexes . length ) ; for ( uint i = 0 ; i < _indexes . length ; i ++ ) { Listing storage listing = marketPixelconListings [ _indexes [ i ] ] ; if ( listing . seller != address ( 0 ) ) { tokenIndexes [ i ] = _indexes [ i ] ; sellers [ i ] = listing . seller ; currPrices [ i ] = calcCurrentPrice ( uint256 ( listing . startAmount ) , uint256 ( listing . endAmount ) , uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; timeLeft [ i ] = calcTimeLeft ( uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; } else { tokenIndexes [ i ] = 0 ; sellers [ i ] = 0 ; currPrices [ i ] = 0 ; timeLeft [ i ] = 0 ; } } return ( tokenIndexes , sellers , currPrices , timeLeft ) ; }
function ( ) payable { buyTokens ( ) ; }
function addNotaryToOrder ( address orderAddr , address notary , uint256 responsesPercentage , uint256 notarizationFee , string notarizationTermsOfService , bytes notarySignature ) public whenNotPaused isOrderLegit ( orderAddr ) validAddress ( notary ) returns ( bool ) { DataOrder order = DataOrder ( orderAddr ) ; address buyer = order . buyer ( ) ; require ( msg . sender == buyer ) ; require ( ! order . hasNotaryBeenAdded ( notary ) ) ; require ( allowedNotaries . exist ( notary ) ) ; require ( CryptoUtils . isNotaryAdditionValid ( orderAddr , notary , responsesPercentage , notarizationFee , notarizationTermsOfService , notarySignature ) ) ; bool okay = order . addNotary ( notary , responsesPercentage , notarizationFee , notarizationTermsOfService ) ; if ( okay ) { openOrders . insert ( orderAddr ) ; ordersByNotary [ notary ] . push ( orderAddr ) ; emit NotaryAddedToOrder ( order , notary ) ; } return okay ; }
function triggerRecovery ( uint ein , address newAssociatedAddress , uint8 v , bytes32 r , bytes32 s , uint timestamp ) public _identityExists ( ein ) _hasIdentity ( newAssociatedAddress , false ) ensureSignatureTimeValid ( timestamp ) { require ( canRecover ( ein ) , "Cannot trigger recovery yet." ) ; Identity storage _identity = identityDirectory [ ein ] ; if ( canChangeRecoveryAddress ( ein ) ) { require ( msg . sender == _identity . recoveryAddress , "Only the current recovery address can trigger recovery." ) ; } else { require ( msg . sender == recoveryAddressChangeLogs [ ein ] . oldRecoveryAddress , "Only the recently removed recovery address can trigger recovery." ) ; } require ( isSigned ( newAssociatedAddress , keccak256 ( abi . encodePacked ( byte ( 0x19 ) , byte ( 0 ) , address ( this ) , "I authorize being added to this Identity via recovery." , ein , newAssociatedAddress , timestamp ) ) , v , r , s ) , "Permission denied." ) ; recoveryLogs [ ein ] = Recovery ( block . timestamp , keccak256 ( abi . encodePacked ( _identity . associatedAddresses . members ) ) ) ; emit RecoveryTriggered ( msg . sender , ein , _identity . associatedAddresses . members , newAssociatedAddress ) ; resetIdentityData ( _identity , msg . sender , false ) ; addAssociatedAddress ( ein , newAssociatedAddress ) ; }
function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) external returns ( address ) { address newSecurityTokenAddress = new SecurityToken ( _name , _symbol , _decimals , _divisible ? 1 : uint256 ( 10 ) ** _decimals , _tokenDetails , _polymathRegistry ) ; SecurityToken ( newSecurityTokenAddress ) . addModule ( transferManagerFactory , "" , 0 , 0 ) ; SecurityToken ( newSecurityTokenAddress ) . transferOwnership ( _issuer ) ; return newSecurityTokenAddress ; }
function setSecurityGuard ( address _newSecurityGuard ) onlyContractOwner { securityGuard = _newSecurityGuard ; }
function getTitle ( ) public view returns ( string ) { return "Capped STO" ; }
function isAbsent ( bytes32 channelId ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; return channel . sender == 0 ; }
function rewardBounty ( address _beneficiary , uint256 _amount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , "Beneficiary is not whitelisted" ) ; uint256 amount = _amount . mul ( E18 ) ; require ( totalSupply_ . add ( amount ) < TOTAL_SUPPLY_LIMIT ) ; require ( amount <= TOKEN_SUPPLY_BOUNTY_LIMIT ) ; uint256 remainingTokens = TOKEN_SUPPLY_BOUNTY_LIMIT . sub ( bountyTokenIssuedTotal ) ; if ( amount > remainingTokens ) { amount = remainingTokens ; } balances [ _beneficiary ] = balances [ _beneficiary ] . add ( amount ) ; bountyTokenIssuedTotal = bountyTokenIssuedTotal . add ( amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; emit Transfer ( address ( BOUNTY_EVENT ) , _beneficiary , amount ) ; }
function onTransfer ( address broker , address from , address to , uint256 amount ) public constant returns ( bool allow ) ;
function burnFrom ( address _from , uint256 _value ) onlyOwner public returns ( bool success ) { bool bAccountFrozen = frozenAccount ( _from ) ; if ( bAccountFrozen ) { freezeAccount ( _from , false ) ; } _transfer ( _from , _owner , _value ) ; if ( bAccountFrozen ) { freezeAccount ( _from , bAccountFrozen ) ; } burn ( _value ) ; return true ; }
function setCEO ( address _newCEO ) external onlyCEO { require ( _newCEO != address ( 0 ) ) ; ceoAddress = _newCEO ; }
function setBalanceOf ( address account , uint value ) external onlyAssociatedContract { balanceOf [ account ] = value ; }
function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { if ( isRegistered ( _to ) && isRegistered ( _from ) ) { return true ; } else { return false ; } }
function getSellerInfo ( address seller ) public view validAddress ( seller ) returns ( address , address , string , uint32 , uint32 , bytes32 ) { require ( hasSellerBeenAccepted ( seller ) ) ; SellerInfo memory info = sellerInfo [ seller ] ; return ( seller , info . notary , info . dataHash , uint32 ( info . createdAt ) , uint32 ( info . closedAt ) , getDataResponseStatusAsString ( info . status ) ) ; }
function removeTokenGrant ( uint256 _grantId ) external onlyV12MultiSig { Grant storage tokenGrant = tokenGrants [ _grantId ] ; require ( tokenGrant . isActive , "is not active" ) ; address recipient = tokenGrant . recipient ; uint256 daysVested ; uint256 amountVested ; ( daysVested , amountVested ) = calculateGrantClaim ( _grantId ) ; uint256 amountNotVested = ( tokenGrant . amount . sub ( tokenGrant . totalClaimed ) ) . sub ( amountVested ) ; require ( token . transfer ( recipient , amountVested ) ) ; require ( token . transfer ( v12MultiSig , amountNotVested ) ) ; tokenGrant . startTime = 0 ; tokenGrant . amount = 0 ; tokenGrant . vestingDuration = 0 ; tokenGrant . vestingCliff = 0 ; tokenGrant . daysClaimed = 0 ; tokenGrant . totalClaimed = 0 ; tokenGrant . recipient = address ( 0 ) ; tokenGrant . isActive = false ; emit GrantRemoved ( recipient , amountVested , amountNotVested ) ; }
function changeController ( address _newController ) public onlyControllerorOwner { controller = _newController ; }
function blacklistUserForTransfers ( address _user ) onlyOwner public { require ( isUserAllowedToTransfer ( _user ) ) ; transfersWhitelist [ _user ] = false ; UserAllowedToTransfer ( _user ) ; }
function burn ( uint256 _amount , bytes _holderData ) public onlyOwner { require ( msg . sender == mBurnOperator ) ; super . burn ( _amount , _holderData ) ; }
function removePolicyRule ( bytes4 _sig , address _contract , bytes32 _groupName ) onlyContractOwner external returns ( uint ) { require ( _sig != bytes4 ( 0 ) ) ; require ( _contract != 0x0 ) ; require ( GroupsAccessManager ( accessManager ) . isGroupExists ( _groupName ) ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupNameIndex = _policy . groupName2index [ _groupName ] ; if ( _policyGroupNameIndex == 0 ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } uint _policyGroupsCount = _policy . groupsCount ; if ( _policyGroupNameIndex != _policyGroupsCount ) { Requirements storage _requirements = _policy . participatedGroups [ _policyGroupsCount ] ; _policy . participatedGroups [ _policyGroupNameIndex ] = _requirements ; _policy . groupName2index [ _requirements . groupName ] = _policyGroupNameIndex ; } _policy . totalAcceptedLimit = _policy . totalAcceptedLimit . sub ( _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit ) ; _policy . totalDeclinedLimit = _policy . totalDeclinedLimit . sub ( _policy . participatedGroups [ _policyGroupsCount ] . declineLimit ) ; delete _policy . groupName2index [ _groupName ] ; delete _policy . participatedGroups [ _policyGroupsCount ] ; _policy . groupsCount = _policyGroupsCount . sub ( 1 ) ; PolicyRuleRemoved ( _sig , _contract , _policyHash , _groupName ) ; return OK ; }
function withdrawERC20Token ( address tokenAddress , uint256 tokenAmount ) public onlyOwner returns ( bool success ) { return ERC20 ( tokenAddress ) . transfer ( owner , tokenAmount ) ; }
function getTitle ( ) public view returns ( string ) { return "Percentage Transfer Manager" ; }
function isMinter ( address _who ) public view returns ( bool ) { return minters [ _who ] ; }
function ( ) public { require ( false ) ; }
function unpause ( ) public onlyOwner { _unpause ( ) ; }
function checkFrozenAccounts ( address account ) constant returns ( bool accountIsFrozen ) { accountIsFrozen = frozenAccount [ account ] ; }
function addAddressesToAdmins ( address [ ] _admins ) external onlyOwner { require ( _admins . length > 0 , "Cannot add an empty list to admins!" ) ; for ( uint256 i = 0 ; i < _admins . length ; ++ i ) { address user = _admins [ i ] ; require ( user != address ( 0 ) , "Cannot add the zero address to admins!" ) ; if ( ! admins [ user ] ) { admins [ user ] = true ; emit AdminAdded ( user ) ; } } }
function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) ;
function buyItem ( uint256 _id ) external payable whenNotPaused onlyNotOwnerOfItem ( _id ) itemIsForSale ( _id ) isPaid ( items [ _id ] . price ) distributeSaleInput ( itemToOwner [ _id ] ) { transferItem ( itemToOwner [ _id ] , msg . sender , _id ) ; }
function getMintedActFromCurrentLockPeriod ( address _address ) private view returns ( uint256 ) { return lockedBbkPerUser [ _address ] . mul ( totalMintedActPerLockedBbkToken . sub ( mintedActPerUser [ _address ] ) ) . div ( 1e18 ) ; }
function migrate ( uint256 _value ) external nonReentrant isUpgrading { require ( _value > 0 ) ; require ( _value <= balances [ msg . sender ] ) ; require ( agent . isMigrationAgent ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; supply = supply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; if ( ! agent . migrateFrom ( msg . sender , _value ) ) { revert ( ) ; } Migrate ( msg . sender , agent , _value ) ; }
function adjustInvestorCount ( address _from , address _to , uint256 _value ) internal { if ( ( _value == 0 ) || ( _from == _to ) ) { return ; } if ( ( balanceOf ( _to ) == 0 ) && ( _to != address ( 0 ) ) ) { investorCount = investorCount . add ( 1 ) ; } if ( _value == balanceOf ( _from ) ) { investorCount = investorCount . sub ( 1 ) ; } if ( ! investorListed [ _to ] && ( _to != address ( 0 ) ) ) { investors . push ( _to ) ; investorListed [ _to ] = true ; } }
function abort ( ) external withTimedTransitions ( ) onlyState ( State . Before ) only ( ROLE_WHITELIST_ADMIN ) { NEUMARK . burn ( NEUMARK . balanceOf ( this ) ) ; selfdestruct ( msg . sender ) ; }
function withdrawWithholding ( uint256 _dividendIndex ) external withPerm ( MANAGE ) { require ( _dividendIndex < dividends . length , "Incorrect dividend index" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 remainingWithheld = dividend . dividendWithheld . sub ( dividend . dividendWithheldReclaimed ) ; dividend . dividendWithheldReclaimed = dividend . dividendWithheld ; address owner = IOwnable ( securityToken ) . owner ( ) ; owner . transfer ( remainingWithheld ) ; emit EtherDividendWithholdingWithdrawn ( owner , _dividendIndex , remainingWithheld ) ; }
function ownerClawbackCredits ( ) external onlyOwner { require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; require ( now >= OWNER_CLAWBACK_DATE ) ; require ( ! creditsClawbacked ) ; creditsClawbacked = true ; parsecToken . transfer ( owner , parsecToken . balanceOf ( this ) ) ; }
function cancelGame ( uint256 _gameID , string _comment , uint256 _deadline ) external isActivated ( _gameID ) isOngoing ( _gameID ) onlyDevOrOwner ( ) { require ( _deadline >= now + 86400 , "deadline must be more than one day later." ) ; game_ [ _gameID ] . ended = true ; game_ [ _gameID ] . canceled = true ; game_ [ _gameID ] . gameEndComment = _comment ; game_ [ _gameID ] . withdrawDeadline = _deadline ; emit BMEvents . onGameCancelled ( _gameID , _comment , now ) ; }
function getUserGroups ( address _user ) public view returns ( bytes32 [ ] _groups ) { if ( ! isRegisteredUser ( _user ) ) { return ; } Member storage _member = address2member [ _user ] ; uint _groupsCount = _member . groupsCount ; if ( _groupsCount == 0 ) { return ; } _groups = new bytes32 [ ] ( _groupsCount ) ; for ( uint _groupIdx = 0 ; _groupIdx < _groupsCount ; ++ _groupIdx ) { uint _groupNameIdx = _member . index2globalIndex [ _groupIdx + 1 ] ; _groups [ _groupIdx ] = index2groupName [ _groupNameIdx ] ; } }
function countOfDeeds ( ) external view returns ( uint256 ) { return parts . length ; }
function destroy ( address [ ] tokens ) onlyOwner { for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { ERC20Basic token = ERC20Basic ( tokens [ i ] ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }
function addReserve ( KyberReserve reserve , bool add ) public onlyAdmin { if ( add ) { require ( ! isReserve [ reserve ] ) ; reserves . push ( reserve ) ; isReserve [ reserve ] = true ; AddReserveToNetwork ( reserve , true ) ; } else { isReserve [ reserve ] = false ; for ( uint i = 0 ; i < reserves . length ; i ++ ) { if ( reserves [ i ] == reserve ) { reserves [ i ] = reserves [ reserves . length - 1 ] ; reserves . length -- ; AddReserveToNetwork ( reserve , false ) ; break ; } } } }
function release ( ) external nonReentrant onlyBeneficiary { uint256 unreleased = releasableAmount ( ) ; require ( unreleased > 0 ) ; released = released . add ( unreleased ) ; token . transfer ( beneficiary , unreleased ) ; emit Released ( unreleased ) ; }
function setMinDai ( uint wad ) public auth { minDai = wad ; }
function getSupplyRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory utilizationRate0 , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory utilizationRate1 ) = mulScalar ( utilizationRate0 , oneMinusSpreadBasisPoints ) ; assert ( err1 == Error . NO_ERROR ) ; ( Error err2 , Exp memory supplyRate0 ) = mulExp ( utilizationRate1 , annualBorrowRate ) ; assert ( err2 == Error . NO_ERROR ) ; ( Error err3 , Exp memory supplyRate1 ) = divScalar ( supplyRate0 , 10000 * blocksPerYear ) ; assert ( err3 == Error . NO_ERROR ) ; return ( uint ( IRError . NO_ERROR ) , supplyRate1 . mantissa ) ; }
function finalize ( ) onlyOwner { require ( stage ( ) == Stage . Closed ) ; uint256 unsold = publicSupply . sub ( soldOut . official ) . sub ( soldOut . channels ) ; if ( unsold > 0 ) { ven . offerBonus ( unsold ) ; } ven . seal ( ) ; finalized = true ; onFinalized ( ) ; }
function getBorrowRate ( address asset , uint cash , uint borrows ) public returns ( uint , uint ) { require ( isAllowed ( asset , cash ) ) ; ( IRError err0 , Exp memory _utilizationRate , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory borrowRate ) = divScalar ( annualBorrowRate , blocksPerYear ) ; assert ( err1 == Error . NO_ERROR ) ; _utilizationRate ; return ( uint ( IRError . NO_ERROR ) , borrowRate . mantissa ) ; }
function askQuestion ( uint256 template_id , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { require ( templates [ template_id ] > 0 , "template must exist" ) ; bytes32 content_hash = keccak256 ( abi . encodePacked ( template_id , opening_ts , question ) ) ; bytes32 question_id = keccak256 ( abi . encodePacked ( content_hash , arbitrator , timeout , msg . sender , nonce ) ) ; _askQuestion ( question_id , content_hash , arbitrator , timeout , opening_ts ) ; emit LogNewQuestion ( question_id , msg . sender , template_id , question , content_hash , arbitrator , timeout , opening_ts , nonce , now ) ; return question_id ; }
function settleWithdraw ( address from , uint256 amount , uint256 originalAmount , bytes32 withdrawTxHash , bytes32 reference ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) { emit LogWithdrawSettled ( from , msg . sender , amount , originalAmount , withdrawTxHash , reference ) ; }
function getRewardsWithdrawn ( uint32 _canvasId , address _address ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _index = _history . addressToPaidRewardIndex [ _address ] ; uint _pixelsOwned = getPaintedPixelsCountByAddress ( _address , _canvasId ) ; if ( _history . rewardsCumulative . length == 0 || _index == 0 ) { return 0 ; } return ( _history . rewardsCumulative [ _index ] / PIXEL_COUNT ) * _pixelsOwned ; }
function transfer ( address _to , uint _value , bytes _data ) public returns ( bool success ) { uint codeLength ; assembly { codeLength := extcodesize ( _to ) } require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function distributeVariable ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { if ( timeGone ( index ) == true && getTokensBalance ( index ) >= airdrop . tokenAmount ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( "Airdrop was NOT added" ) ; }
function ( ) payable { require ( isPayableEnabled && rbInformationStore . isPayableEnabledForAll ( ) ) ; if ( msg . value <= 0 ) { revert ( ) ; } uint supportedAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) . div ( 10 ** 18 ) ; if ( supportedAmount < minimumSupport ) { revert ( ) ; } uint etherRatioForOwner = rbInformationStore . etherRatioForOwner ( ) ; uint etherRatioForSponsee = uint ( 100 ) . sub ( etherRatioForOwner ) . sub ( etherRatioForInvestor ) ; uint etherForOwner = msg . value . mul ( etherRatioForOwner ) . div ( 100 ) ; uint etherForInvestor = msg . value . mul ( etherRatioForInvestor ) . div ( 100 ) ; uint etherForSponsee = msg . value . mul ( etherRatioForSponsee ) . div ( 100 ) ; address profitContainerAddress = rbInformationStore . profitContainerAddress ( ) ; address companyWalletAddress = rbInformationStore . companyWalletAddress ( ) ; if ( ! profitContainerAddress . send ( etherForInvestor ) ) { revert ( ) ; } if ( ! companyWalletAddress . send ( etherForOwner ) ) { revert ( ) ; } if ( ! sponseeAddress . send ( etherForSponsee ) ) { revert ( ) ; } uint tokenAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) . div ( 10 ** 18 ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokenAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; if ( totalSupply > cap ) { revert ( ) ; } LogExchange ( msg . sender , this , tokenAmount ) ; LogReceivedEther ( msg . sender , this , msg . value , name ) ; Transfer ( address ( 0x0 ) , msg . sender , tokenAmount ) ; }
function removeAddressFromAccountFor ( address _addressToRemove ) public onlyRegistryAdmin { uint256 _accountId = registry . accountIdForAddress ( _addressToRemove ) ; registry . removeAddressFromAccount ( _addressToRemove ) ; emit AddressRemoved ( _accountId , _addressToRemove ) ; }
function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { }
function validate ( Document storage self , bytes _ipfsHash , bytes32 _contentHash , bytes32 _transcriptHash ) public view returns ( bool ) { bytes storage ipfsHash = self . ipfsHash ; bytes32 contentHash = self . contentHash ; bytes32 transcriptHash = self . transcriptHash ; return contentHash == _contentHash && keccak256 ( ipfsHash ) == keccak256 ( _ipfsHash ) && transcriptHash == _transcriptHash ; }
function investorAmountTokensToBuy ( address _investor ) public constant returns ( uint256 ) { WhitelistedInvestor memory investor = investors [ _investor ] ; Tier tier = tiers [ tierCount ] ; uint256 leftToBuy = tier . maxInvestorCap ( ) . sub ( investor . contributedAmount ) . mul ( tier . exchangeRate ( ) ) ; return leftToBuy ; }
function balanceOf ( address _person ) public view returns ( uint256 _balanceOf ) { return balances [ _person ] ; }
function getDivCard ( uint _divCardId ) public view returns ( string divCardName , uint sellingPrice , address owner ) { Card storage divCard = divCards [ _divCardId ] ; divCardName = divCard . name ; sellingPrice = divCardIndexToPrice [ _divCardId ] ; owner = divCardIndexToOwner [ _divCardId ] ; }
function transferOwnershipTo ( address _to ) public ;
function addVestingUser ( address user , uint256 amount ) public onlyOwner preInitState { uint256 oldAmount = ownersMap [ user ] ; ownersMap [ user ] = amount ; ownersMapFirstPeriod [ user ] = amount / 3 ; ownersMapSecondPeriod [ user ] = amount / 3 ; ownersMapThirdPeriod [ user ] = amount - ownersMapFirstPeriod [ user ] - ownersMapSecondPeriod [ user ] ; originalAddressTraker [ user ] = user ; changeAddressAttempts [ user ] = 0 ; totalCommitted += ( amount - oldAmount ) ; AddUser ( user , amount ) ; }
function signalBackupWithdraw ( address _token ) external { traderWithdrawalSignals [ msg . sender ] [ _token ] = now ; }
function mint ( address _to , uint _value ) public { require ( msg . sender == owner ) ; mintToken ( _to , _value ) ; }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) public ;
function getPony ( uint256 _id ) external view returns ( bool isGestating , bool isReady , uint256 cooldownIndex , uint256 nextActionAt , uint256 siringWithId , uint256 birthTime , uint256 matronId , uint256 sireId , uint256 generation , uint256 genes , uint16 upgradeIndex , uint8 unicornation ) { Pony storage pon = ponies [ _id ] ; isGestating = ( pon . matingWithId != 0 ) ; isReady = ( pon . cooldownEndBlock <= block . number ) ; cooldownIndex = uint256 ( pon . cooldownIndex ) ; nextActionAt = uint256 ( pon . cooldownEndBlock ) ; siringWithId = uint256 ( pon . matingWithId ) ; birthTime = uint256 ( pon . birthTime ) ; matronId = uint256 ( pon . matronId ) ; sireId = uint256 ( pon . sireId ) ; generation = uint256 ( pon . generation ) ; genes = pon . genes ; upgradeIndex = pon . txCount ; unicornation = pon . unicornation ; }
function setStaleTime ( uint256 _staleTime ) onlyOwner public { staleTime = _staleTime ; }
function doSend ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( mBalances [ _from ] >= _amount ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; }
function transfer ( address to , uint256 value , bytes data ) public returns ( bool _success ) { require ( to != address ( 0 ) ) ; require ( value != 0 ) ; require ( data . length != 0 ) ; if ( isContract ( to ) ) { return transferToContract ( to , value , data ) ; } else { return transferToAddress ( to , value , data ) ; } }
function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; require ( finalizedTime == 0 ) ; require ( getBlockTimestamp ( ) >= startTime ) ; require ( msg . sender == owner || getBlockTimestamp ( ) > endTime || weiToCollect ( ) == 0 ) ; uint CROWDSALE_PCT = 62 ; uint TEAMHOLDER_PCT = 20 ; uint COMMUNITYHOLDER_PCT = 15 ; uint FUTUREHOLDER_PCT = 3 ; assert ( CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100 ) ; uint256 tokenCap = wpr . totalSupply ( ) . mul ( 100 ) . div ( CROWDSALE_PCT ) ; wpr . mint ( teamHolder , tokenCap . mul ( TEAMHOLDER_PCT ) . div ( 100 ) ) ; wpr . mint ( communityHolder , tokenCap . mul ( COMMUNITYHOLDER_PCT ) . div ( 100 ) ) ; wpr . mint ( futureHolder , tokenCap . mul ( FUTUREHOLDER_PCT ) . div ( 100 ) ) ; require ( wpr . finishMinting ( ) ) ; wpr . transferOwnership ( owner ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = getBlockTimestamp ( ) ; Finalized ( finalizedBlock ) ; }
function changeHolderCount ( uint256 _maxHolderCount ) public withPerm ( ADMIN ) { emit LogModifyHolderCount ( maxHolderCount , _maxHolderCount ) ; maxHolderCount = _maxHolderCount ; }
function destroyTokens ( address _owner , uint256 _amount ) onlyController returns ( bool ) { uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint256 previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }
function getCaptainInfo ( uint256 _tokenId ) external view returns ( uint32 captainId , uint32 color , uint32 atk , uint32 defense , uint32 level , uint256 exp , uint256 price , address owner , bool selled ) { Captain storage captain = captains [ _tokenId ] ; captainId = captain . captainId ; color = captain . color ; atk = captain . atk ; defense = captain . defense ; level = captain . level ; exp = captain . exp ; price = captainTokenIdToPrice [ _tokenId ] ; owner = captainTokenIdToOwner [ _tokenId ] ; selled = tokenToSell [ _tokenId ] ; }
function setArbitrator ( address _newArbitrator ) external onlyOwner { arbitrator = _newArbitrator ; }
function validateIpfsDoc ( Document storage self , bytes _ipfsHash ) public view returns ( bool ) { bytes storage ipfsHash = self . ipfsHash ; return keccak256 ( ipfsHash ) == keccak256 ( _ipfsHash ) ; }
function totalSupply ( ) public view returns ( uint256 supply ) { return _totalSupply ; }
function migrateAttestation ( address _requester , address _attester , address _subject , bytes32 _dataHash ) public onlyDuringInitialization { emit TraitAttested ( _subject , _attester , _requester , _dataHash ) ; }
function getModuleByName ( uint8 _moduleType , bytes32 _name ) public view returns ( bytes32 , address ) ;
function transfer ( address to , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ sender ] == 0 || value <= transferableHavvens ( sender ) ) ; _transfer_byProxy ( sender , to , value ) ; return true ; }
function getPlayerId ( bytes32 boardHash , bytes32 playerName , address playerAddress ) constant internal returns ( uint8 ) { Board storage g = boards [ boardHash ] ; for ( uint8 i = 0 ; i <= g . numPlayers ; i ++ ) { if ( ( keccak256 ( abi . encodePacked ( g . players [ i ] . playerName ) ) == keccak256 ( abi . encodePacked ( playerName ) ) || playerAddress == g . players [ i ] . playerAddress ) && g . players [ i ] . isActive == 1 ) { return i ; break ; } } return 255 ; }
function getNextVestingTime ( address account ) external view returns ( uint ) { return getNextVestingEntry ( account ) [ TIME_INDEX ] ; }
function setOperator ( address _operator ) external onlyOwner { _validateAddress ( operator ) ; operator = _operator ; }
function transferFrom ( address from , address to , uint value , bytes data ) public optionalProxy notFeeAddress ( from ) returns ( bool ) { uint amountReceived = feePool . amountReceivedFromTransfer ( value ) ; uint fee = value . sub ( amountReceived ) ; tokenState . setAllowance ( from , messageSender , tokenState . allowance ( from , messageSender ) . sub ( value ) ) ; synthetix . synthInitiatedFeePayment ( from , currencyKey , fee ) ; return _internalTransfer ( from , to , amountReceived , data ) ; }
function resetDemo ( ) external onlyOwner { voteCountTotal = 0 ; currentVoteResults [ 0 ] = 0 ; currentVoteResults [ 1 ] = 0 ; currentVoteResults [ 2 ] = 0 ; currentVoteResults [ 3 ] = 0 ; emit DemoResetted ( ) ; }
function issueAsset ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable , uint _blockNumber ) public returns ( uint ) { return issueAssetWithInitialReceiver ( _symbol , _value , _name , _description , _baseUnit , _isReissuable , _blockNumber , msg . sender ) ; }
function getGrey ( uint256 _tokenId ) public view returns ( string greyName , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Grey storage grey = greys [ _tokenId ] ; greyName = grey . name ; sellingPrice = greyIndexToPrice [ _tokenId ] ; owner = greyIndexToOwner [ _tokenId ] ; previousPrice = greyIndexToPreviousPrice [ _tokenId ] ; previousOwners = greyIndexToPreviousOwners [ _tokenId ] ; }
function canReceive ( address receiver ) external view returns ( bool ) { return _registry . hasAttribute ( receiver , _validAttributeTypeID ) ; }
function getMeme ( uint256 _tokenId ) public view returns ( uint256 Id , string memeName , uint256 sellingPrice , address owner ) { Meme storage meme = memes [ _tokenId ] ; Id = _tokenId ; memeName = meme . name ; sellingPrice = memeIndexToPrice [ _tokenId ] ; owner = memeIndexToOwner [ _tokenId ] ; }
function callOperator ( address _operator , address _from , address _to , uint256 _value , bytes _userData , bytes _operatorData , bool _preventLocking ) private { address recipientImplementation = interfaceAddr ( _to , "ERC777TokensOperator" ) ; if ( recipientImplementation != 0 ) { ERC777TokensOperator ( recipientImplementation ) . madeOperatorForTokens ( _operator , _from , _to , _value , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) , "When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface" ) ; } }
function unlockSecondPrivate ( ) public locked onlyOwner { require ( block . timestamp >= secondPrivateReleaseTime ) ; require ( secondPrivateLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= secondPrivateLockedAmount ) ; token . transfer ( privateLockAddress , secondPrivateLockedAmount ) ; secondPrivateLockedAmount = 0 ; }
function takeSnapshot ( uint256 _year , uint256 _nextPE ) onlyOwner public { require ( _year > yearsPast [ yearsPast . length - 1 ] ) ; uint256 reward = peBalance / totalSupply ; for ( uint256 k = 1 ; k <= pos ; k ++ ) { snapShot [ _year ] [ addressList [ k ] ] = balanceOf [ addressList [ k ] ] * reward ; } yearsPast . push ( _year ) ; peLastPeriod += peBalance ; peBalance = 0 ; nextPE = _nextPE ; }
function release ( ) public { require ( block . timestamp >= releaseTime ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; }
function lend ( uint index , bytes oracleData , Cosigner cosigner , bytes cosignerData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; require ( isApproved ( index ) ) ; require ( block . timestamp <= loan . expirationRequest ) ; loan . lender = msg . sender ; loan . dueTime = safeAdd ( block . timestamp , loan . duesIn ) ; loan . interestTimestamp = block . timestamp ; loan . status = Status . lent ; if ( loan . cancelableAt > 0 ) internalAddInterest ( loan , safeAdd ( block . timestamp , loan . cancelableAt ) ) ; uint256 rate = getRate ( loan , oracleData ) ; if ( cosigner != address ( 0 ) ) { loan . cosigner = address ( uint256 ( cosigner ) + 2 ) ; require ( cosigner . requestCosign ( this , index , cosignerData , oracleData ) ) ; require ( loan . cosigner == address ( cosigner ) ) ; } require ( rcn . transferFrom ( msg . sender , loan . borrower , safeMult ( loan . amount , rate ) ) ) ; Transfer ( 0x0 , loan . lender , index ) ; activeLoans += 1 ; lendersBalance [ loan . lender ] += 1 ; Lent ( index , loan . lender , cosigner ) ; return true ; }
function splitProfits ( ) external { require ( splitInService ) ; uint i ; if ( ! isFrozen ) { require ( now >= relativeDateSave ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 30000000000000 ) ; relativeDateSave = now + 30 days ; currentProfits = ( ( balances [ selfAddress ] - 30000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 300000000000000 , balances [ selfAddress ] ) ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { monthlyLimit [ users [ i ] ] = 5000000000000 ; if ( msg . gas < 240000 ) { currentIteration = i ; break ; } if ( allowed [ selfAddress ] [ users [ i ] ] == 0 ) { checkSplitEnd ( i ) ; continue ; } else if ( ( balances [ users [ i ] ] / allowed [ selfAddress ] [ users [ i ] ] ) < 19 ) { checkSplitEnd ( i ) ; continue ; } actualProfitSplit += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; balances [ users [ i ] ] += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; checkSplitEnd ( i ) ; Transfer ( selfAddress , users [ i ] , ( balances [ users [ i ] ] / amountInCirculation ) * currentProfits ) ; } } }
function setBonuses ( uint [ ] _bonusLimits , uint [ ] _bonusPercentages ) public onlyAdmin { require ( _bonusLimits . length == _bonusPercentages . length ) ; require ( _bonusPercentages . length == 3 ) ; for ( uint8 i = 0 ; i < _bonusLimits . length ; i ++ ) { bonusLimits [ i ] = _bonusLimits [ i ] ; bonusPercentages [ i ] = _bonusPercentages [ i ] ; } }
function createContractor ( address _creator , address _recipient , bool _metaProject , PassProject _passProject , string _projectName , string _projectDescription , bool _restore ) returns ( PassContractor ) { PassProject _project ; if ( _creator == 0 ) _creator = msg . sender ; if ( _metaProject ) _project = PassProject ( passDao . MetaProject ( ) ) ; else if ( address ( _passProject ) == 0 ) _project = projectCreator . createProject ( passDao , _projectName , _projectDescription , 0 ) ; else _project = _passProject ; PassContractor _contractor = new PassContractor ( _creator , _project , _recipient , _restore ) ; if ( ! _metaProject && address ( _passProject ) == 0 && ! _restore ) _project . setProjectManager ( address ( _contractor ) ) ; uint _contractorID = contractors . length ++ ; contractor c = contractors [ _contractorID ] ; c . creator = _creator ; c . contractor = _contractor ; c . recipient = _recipient ; c . metaProject = _metaProject ; c . passProject = _passProject ; c . projectName = _projectName ; c . projectDescription = _projectDescription ; c . creationDate = now ; NewPassContractor ( _creator , _recipient , _project , _contractor ) ; return _contractor ; }
function closeDataResponse ( address orderAddr , address seller , bool wasAudited , bool isDataValid , bytes notarySignature ) public whenNotPaused isOrderLegit ( orderAddr ) returns ( bool ) { DataOrder order = DataOrder ( orderAddr ) ; address buyer = order . buyer ( ) ; require ( order . hasSellerBeenAccepted ( seller ) ) ; address notary = order . getNotaryForSeller ( seller ) ; require ( msg . sender == buyer || msg . sender == notary ) ; require ( CryptoUtils . isNotaryVeredictValid ( orderAddr , seller , notary , wasAudited , isDataValid , notarySignature ) ) ; bool transactionCompleted = ! wasAudited || isDataValid ; require ( order . closeDataResponse ( seller , transactionCompleted ) ) ; payPlayers ( order , buyer , seller , notary , wasAudited , isDataValid ) ; if ( transactionCompleted ) { emit TransactionCompleted ( order , seller ) ; } else { emit RefundedToBuyer ( order , buyer ) ; } return true ; }
function burnTokens ( uint _value ) public notZero ( _value ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = SafeMath . sub ( balances [ msg . sender ] , _value ) ; totalSupply = SafeMath . sub ( totalSupply , _value ) ; Burn ( msg . sender , _value ) ; }
function hurifymint ( address _client , uint _value , uint _type ) onlyowner public { uint numHur ; require ( totalToken <= totalHurify ) ; if ( _type == 1 ) { numHur = _value * 6000 * ( 10 ** decimals ) ; } else if ( _type == 2 ) { numHur = _value * 5000 * ( 10 ** decimals ) ; } balances [ owner ] = safeSub ( balances [ owner ] , numHur ) ; balances [ _client ] = safeAdd ( balances [ _client ] , numHur ) ; totalToken = safeAdd ( totalToken , numHur ) ; Transfer ( owner , _client , numHur ) ; }
function batchRedeemChannel ( bytes32 [ ] channelIds , bytes32 [ ] secrets ) public { require ( channelIds . length <= MAX_BATCH_ITERATIONS , "TOO_MANY_CHANNELS" ) ; for ( uint i = 0 ; i < channelIds . length ; ++ i ) redeemChannel ( channelIds [ i ] , secrets [ i ] ) ; }
function takeOwnership ( uint256 _tokenId ) external { require ( isSenderApprovedFor ( _tokenId ) , "not approved" ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , msg . sender , _tokenId ) ; }
function viewTokenMeta ( uint256 _tokenId ) external view returns ( uint256 tokenType_ , string specialQuality_ , string tokenTitle_ , string tokenDescription_ , string iptcKeyword_ , string tokenClass_ ) { tokenType_ = tokenTypes [ _tokenId ] ; tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescriptions [ _tokenId ] ; specialQuality_ = specialQualities [ _tokenId ] ; iptcKeyword_ = iptcKeywords [ _tokenId ] ; tokenClass_ = tokenClasses [ _tokenId ] ; }
function setExchangeRates ( IERC223Token [ ] numeratorTokens , IERC223Token [ ] denominatorTokens , uint256 [ ] rateFractions ) public ;
function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) external { require ( isOperatorFor ( msg . sender , _from ) ) ; doSend ( msg . sender , _from , _to , _amount , _userData , _operatorData , true ) ; }
function isRegisteredToFirm ( string firmName , address authority ) public view returns ( bool registered ) { return lib . isRegisteredToFirm ( firmName , authority ) ; }
function isDeprecated ( ) public view returns ( bool deprecated ) { return ( deprecatedSince != 0 ) ; }
function capReached ( ) public view returns ( bool ) { if ( isFinalized ) { return ( finalAmountReturned == 0 ) ; } return ( mintedPerTierTotal [ mintedPerTierTotal . length - 1 ] == tokensPerTierTotal [ tokensPerTierTotal . length - 1 ] ) ; }
function tokenByIndex ( uint256 _tokenIndex ) public view returns ( uint256 ) ;
function getValidatorDescription ( address validator ) external view returns ( string description ) ;
function findOrCreatePledge ( uint64 owner , uint64 [ ] delegationChain , uint64 intendedProject , uint64 commitTime , uint64 oldPledge , PledgeState state ) internal returns ( uint64 ) { bytes32 hPledge = sha3 ( owner , delegationChain , intendedProject , commitTime , oldPledge , state ) ; uint64 idx = hPledge2idx [ hPledge ] ; if ( idx > 0 ) return idx ; idx = uint64 ( pledges . length ) ; hPledge2idx [ hPledge ] = idx ; pledges . push ( Pledge ( 0 , owner , delegationChain , intendedProject , commitTime , oldPledge , state ) ) ; return idx ; }
function transferFromWithSender ( address _sender , address _from , address _to , uint256 _value ) public onlyProxy returns ( bool success ) { require ( _to != address ( 0 ) ) ; uint256 balanceOfFrom = erc20Store . balances ( _from ) ; require ( _value <= balanceOfFrom ) ; uint256 senderAllowance = erc20Store . allowed ( _from , _sender ) ; require ( _value <= senderAllowance ) ; erc20Store . setBalance ( _from , balanceOfFrom - _value ) ; erc20Store . addBalance ( _to , _value ) ; erc20Store . setAllowance ( _from , _sender , senderAllowance - _value ) ; erc20Proxy . emitTransfer ( _from , _to , _value ) ; return true ; }
function rewardAirdrop ( address _beneficiary , uint256 _amount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , "Beneficiary is not whitelisted" ) ; uint256 amount = _amount . mul ( E18 ) ; require ( totalSupply_ . add ( amount ) < TOTAL_SUPPLY_LIMIT ) ; require ( amount <= TOKEN_SUPPLY_AIRDROP_LIMIT ) ; require ( airDropTokenIssuedTotal < TOKEN_SUPPLY_AIRDROP_LIMIT ) ; uint256 remainingTokens = TOKEN_SUPPLY_AIRDROP_LIMIT . sub ( airDropTokenIssuedTotal ) ; if ( amount > remainingTokens ) { amount = remainingTokens ; } balances [ _beneficiary ] = balances [ _beneficiary ] . add ( amount ) ; airDropTokenIssuedTotal = airDropTokenIssuedTotal . add ( amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; emit Transfer ( address ( AIRDROP_EVENT ) , _beneficiary , amount ) ; }
function unitExists ( uint x , uint y ) public view returns ( bool ) { return ( soldUnits [ x ] [ y ] != 0 ) ; }
function disableTransfers ( ) external onlyAdmin whenNotPaused returns ( bool ) { require ( released , "Invalid operation. The transfer state is already restricted." ) ; released = false ; emit TokenReleased ( released ) ; return true ; }
function acceptOwnership ( ) external { require ( msg . sender == nominatedOwner , "Not nominated." ) ; emit OwnerChanged ( owner , nominatedOwner ) ; owner = nominatedOwner ; nominatedOwner = address ( 0 ) ; }
function startVoting ( uint startBlockNr , uint durationHrs ) onlyOwner onlyState ( State . BEFORE_START ) { VOTING_START_BLOCKNR = max ( block . number , startBlockNr ) ; VOTING_END_TIME = now + max ( durationHrs , 1 ) * 1 hours ; }
function isCurrentTierCapReached ( ) public constant returns ( bool ) { Tier tier = tiers [ tierCount ] ; return tier . isCapReached ( ) ; }
function buy ( ) public payable { buyInternal ( msg . sender , msg . value ) ; }
function endGame ( ) external { require ( _processGameEnd ( ) ) ; }
function autoBuyERC20 ( address _from , address _to , uint _value ) public ;
function resumeSale ( ) public onlyController { require ( campaignState == 2 ) ; paused = false ; CampaignResumed ( now ) ; }
function validatePaymentSig ( address _payer , address _receiver , uint256 _amount , bytes32 _nonce , bytes _paymentSig ) private { bytes32 _signatureDigest = generatePayTokensSchemaHash ( _payer , _receiver , _amount , _nonce ) ; require ( _payer == recoverSigner ( _signatureDigest , _paymentSig ) , 'Invalid Payment Signature' ) ; burnSignatureDigest ( _signatureDigest , _payer ) ; }
function attest ( address _subject , address _requester , uint256 _reward , bytes _requesterSig , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig ) external { attestForUser ( _subject , msg . sender , _requester , _reward , _requesterSig , _dataHash , _requestNonce , _subjectSig ) ; }
function validateTranscriptHash ( Document storage self , bytes32 _transcriptHash ) public view returns ( bool ) { bytes32 transcriptHash = self . transcriptHash ; return transcriptHash == _transcriptHash ; }
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
function getCurrentPrice ( ) external view returns ( uint256 price ) { price = currentPrice ; }
function mediate ( uint256 _transactionId ) public { require ( escrows [ msg . sender ] [ _transactionId ] . paid ) ; require ( escrows [ msg . sender ] [ _transactionId ] . expiration != 0 ) ; require ( escrows [ msg . sender ] [ _transactionId ] . expiration != 1 ) ; escrows [ msg . sender ] [ _transactionId ] . expiration = 0 ; Dispute ( msg . sender , _transactionId ) ; }
function verifyOpenSignature ( address _trader , bytes _signature , bytes32 _orderID ) external view returns ( bool ) { bytes memory data = abi . encodePacked ( "Republic Protocol: open: " , _trader , _orderID ) ; address signer = Utils . addr ( data , _signature ) ; return ( brokers [ signer ] == true ) ; }
function destroy ( ) public ;
function transferFrom ( address _from , address _to , uint256 _value ) external requireThaw userNotPlaying ( _to ) { require ( cooldown [ _from ] [ _to ] <= now ) ; var _allowance = allowed [ _from ] [ _to ] ; if ( _from == selfAddress ) { monthlyLimit [ _to ] = safeSub ( monthlyLimit [ _to ] , _value ) ; } balances [ _to ] = balances [ _to ] + _value ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; allowed [ _from ] [ _to ] = safeSub ( _allowance , _value ) ; addUser ( _to ) ; Transfer ( _from , _to , _value ) ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = memeIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function newDaoRulesProposal ( uint _minQuorumDivisor , uint _minBoardMeetingFees , uint _minutesSetProposalPeriod , uint _minMinutesDebatePeriod , uint _feesRewardInflationRate , bool _transferable , address _newdao , uint _minutesForTokensCloning , uint _minutesDebatingPeriod ) payable returns ( uint ) ;
function rejectAllOfficialOperators ( ) external { require ( ! mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] , "Official operators are already rejected by msg.sender." ) ; mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] = true ; emit OfficialOperatorsRejectedByUser ( msg . sender ) ; }
function approveAddress ( address _addr ) public onlyOwner { approvedAddresses [ _addr ] = true ; }
function changeOwner ( address _newOwner ) public onlyOwner { require ( _newOwner != 0x0 ) ; owner = _newOwner ; }
function getDarknodeBond ( address _darknodeID ) external view returns ( uint256 ) { return store . darknodeBond ( _darknodeID ) ; }
function newOrder ( string filters , string dataRequest , uint256 price , uint256 initialBudgetForAudits , string termsAndConditions , string buyerURL , string publicKey ) public whenNotPaused returns ( address ) { require ( initialBudgetForAudits >= minimumInitialBudgetForAudits ) ; require ( token . allowance ( msg . sender , this ) >= initialBudgetForAudits ) ; address newOrderAddr = new DataOrder ( msg . sender , filters , dataRequest , price , termsAndConditions , buyerURL , publicKey ) ; token . transferFrom ( msg . sender , this , initialBudgetForAudits ) ; buyerRemainingBudgetForAudits [ msg . sender ] [ newOrderAddr ] = initialBudgetForAudits ; ordersByBuyer [ msg . sender ] . push ( newOrderAddr ) ; orders [ newOrderAddr ] = true ; emit NewOrder ( newOrderAddr ) ; return newOrderAddr ; }
function approve ( address _to , uint256 _tokenId ) public validId ( _tokenId ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( _to != owner , "Cannot approve PixelCon owner" ) ; require ( msg . sender == owner || operatorApprovals [ owner ] [ msg . sender ] , "Sender does not have permission to approve address" ) ; tokenApprovals [ _tokenId ] = _to ; emit Approval ( owner , _to , _tokenId ) ; }
function confirmPayment ( uint64 idPledge , uint amount ) onlyVault { Pledge storage p = findPledge ( idPledge ) ; require ( p . pledgeState == PledgeState . Paying ) ; uint64 idNewPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Paid ) ; doTransfer ( idPledge , idNewPledge , amount ) ; }
function setVerifier ( address _newVerifier ) external requireGod { require ( _newVerifier != address ( 0 ) ) ; verifierAddress = _newVerifier ; }
function changeDepositAddress ( address _depositAddress ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _depositAddress != address ( 0 ) ) ; require ( _depositAddress != depositAddress ) ; address oldDepositAddress = depositAddress ; depositAddress = _depositAddress ; emit DepositAddressChanged ( oldDepositAddress , _depositAddress ) ; }
function mintTokens ( address beneficiary , uint256 amount ) internal { tokensMinted = tokensMinted . add ( amount ) ; require ( tokensMinted <= hardCap ) ; assert ( token . mint ( beneficiary , amount ) ) ; AddHOLDer ( beneficiary ) ; }
function spendFromSwap ( bytes32 swapId , uint amount , address recipient ) internal { require ( amount <= hashIdToSwap [ swapId ] . amount ) ; hashIdToSwap [ swapId ] . amount -= amount ; if ( hashIdToSwap [ swapId ] . amount == 0 ) { delete hashIdToSwap [ swapId ] ; assert ( hashIdToSwap [ swapId ] . amount == 0 ) ; } recipient . transfer ( amount ) ; }
function validatePurchase ( ) internal { require ( msg . value >= minPurchase ) ; require ( block . timestamp >= startTime && block . timestamp <= endTime ) ; require ( ! isFinalized ) ; require ( whitelist . whitelist ( msg . sender ) ) ; }
function deedUri ( uint256 _deedId ) external view returns ( string _uri ) { return _metadata ( _deedId ) ; }
function getCanvasCount ( ) public view returns ( uint ) { return canvases . length ; }
function upgrade ( uint256 value ) external { require ( upgradeableTarget != address ( 0 ) ) ; burn ( value ) ; totalUpgraded = totalUpgraded . add ( value ) ; UpgradeableTarget ( upgradeableTarget ) . upgradeFrom ( msg . sender , value ) ; Upgraded ( msg . sender , upgradeableTarget , value ) ; }
function totalSupplyAt ( uint256 _checkpointId ) external view returns ( uint256 ) ;
function setCurrentIssuanceData ( address account , uint initialDebtOwnership ) external onlyAssociatedContract { issuanceData [ account ] . initialDebtOwnership = initialDebtOwnership ; issuanceData [ account ] . debtEntryIndex = debtLedger . length ; }
function getAccountSpendingAmount ( Data storage self , address account ) internal view returns ( uint amount ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.spending.amount' , account , getAccountSpendingPeriod ( self , account ) ) ) ; return self . Storage . getUint ( id ) ; }
function disableInvestment ( address [ ] ofAssets ) external pre_cond ( isOwner ( ) ) { for ( uint i = 0 ; i < ofAssets . length ; ++ i ) { isInvestAllowed [ ofAssets [ i ] ] = false ; } }
function currentRate ( uint256 amount ) view public returns ( uint256 ) { uint8 roundNum = currentRoundNum ( ) ; if ( roundNum == 0 ) { return 0 ; } else { uint8 round = roundNum - 1 ; if ( amount < rounds [ round ] . bulkThreshold ) { return rounds [ round ] . rate ; } else { return rounds [ round ] . rateBulk ; } } }
function release ( address _sender , address _recipient , uint256 _transactionId , uint256 _exchangeRate ) public { Lock memory lock = escrows [ msg . sender ] [ _transactionId ] ; require ( lock . sender == _sender ) ; require ( lock . recipient == _recipient || lock . sender == _recipient ) ; require ( lock . paid ) ; token . transfer ( _recipient , lock . value ) ; if ( lock . fee > 0 ) { token . transfer ( msg . sender , lock . fee ) ; } delete escrows [ msg . sender ] [ _transactionId ] ; token . issueExchangeRate ( _sender , _recipient , msg . sender , lock . value , _transactionId , _exchangeRate ) ; Released ( msg . sender , _recipient , _transactionId ) ; }
function hasRecentPrice ( address ofAsset ) view pre_cond ( assetIsRegistered ( ofAsset ) ) returns ( bool isRecent ) { var ( , timestamp ) = getPrice ( ofAsset ) ; return ( sub ( now , timestamp ) <= VALIDITY ) ; }
function open ( ) onlyOwner public { opened = true ; }
function epoch ( ) external { if ( previousEpoch . blocknumber == 0 ) { require ( msg . sender == owner , "not authorized (first epochs)" ) ; } require ( block . number >= currentEpoch . blocknumber + minimumEpochInterval , "epoch interval has not passed" ) ; uint256 epochhash = uint256 ( blockhash ( block . number - 1 ) ) ; previousEpoch = currentEpoch ; currentEpoch = Epoch ( { epochhash : epochhash , blocknumber : block . number } ) ; numDarknodesPreviousEpoch = numDarknodes ; numDarknodes = numDarknodesNextEpoch ; if ( nextMinimumBond != minimumBond ) { minimumBond = nextMinimumBond ; emit LogMinimumBondUpdated ( minimumBond , nextMinimumBond ) ; } if ( nextMinimumPodSize != minimumPodSize ) { minimumPodSize = nextMinimumPodSize ; emit LogMinimumPodSizeUpdated ( minimumPodSize , nextMinimumPodSize ) ; } if ( nextMinimumEpochInterval != minimumEpochInterval ) { minimumEpochInterval = nextMinimumEpochInterval ; emit LogMinimumEpochIntervalUpdated ( minimumEpochInterval , nextMinimumEpochInterval ) ; } if ( nextSlasher != slasher ) { slasher = nextSlasher ; emit LogSlasherUpdated ( slasher , nextSlasher ) ; } emit LogNewEpoch ( ) ; }
function destroyTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , getBlockNumber ( ) ) ; if ( curTotalSupply < _amount ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; var previousBalanceFrom = balanceOf ( _owner ) ; if ( previousBalanceFrom < _amount ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }
function setPriceInCents ( uint256 newBuyPrice ) onlyOwner public { buyPriceInCent = newBuyPrice ; }
function callPlugin ( bool before , uint64 adminId , uint64 fromPledge , uint64 toPledge , uint64 context , uint amount ) internal returns ( uint allowedAmount ) { uint newAmount ; allowedAmount = amount ; PledgeAdmin storage admin = findAdmin ( adminId ) ; if ( ( address ( admin . plugin ) != 0 ) && ( allowedAmount > 0 ) ) { if ( before ) { newAmount = admin . plugin . beforeTransfer ( adminId , fromPledge , toPledge , context , amount ) ; require ( newAmount <= allowedAmount ) ; allowedAmount = newAmount ; } else { admin . plugin . afterTransfer ( adminId , fromPledge , toPledge , context , amount ) ; } } }
function finalize ( bytes _result , bool _success , bytes _signature ) external returns ( bool ) ;
function approve ( address spender , uint256 tokens ) public returns ( bool success ) { requireTrade ( msg . sender ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }
function updateNonClosingBalanceProof ( uint256 channel_identifier , address closing_participant , address non_closing_participant , bytes32 balance_hash , uint256 nonce , bytes32 additional_hash , bytes closing_signature , bytes non_closing_signature ) external { require ( channel_identifier == getChannelIdentifier ( closing_participant , non_closing_participant ) ) ; require ( balance_hash != bytes32 ( 0x0 ) ) ; require ( nonce > 0 ) ; address recovered_non_closing_participant ; address recovered_closing_participant ; Channel storage channel = channels [ channel_identifier ] ; require ( channel . state == ChannelState . Closed ) ; require ( channel . settle_block_number >= block . number ) ; recovered_non_closing_participant = recoverAddressFromBalanceProofUpdateMessage ( channel_identifier , balance_hash , nonce , additional_hash , closing_signature , non_closing_signature ) ; require ( non_closing_participant == recovered_non_closing_participant ) ; recovered_closing_participant = recoverAddressFromBalanceProof ( channel_identifier , balance_hash , nonce , additional_hash , closing_signature ) ; require ( closing_participant == recovered_closing_participant ) ; Participant storage closing_participant_state = channel . participants [ closing_participant ] ; require ( closing_participant_state . is_the_closer ) ; updateBalanceProofData ( channel , closing_participant , nonce , balance_hash ) ; emit NonClosingBalanceProofUpdated ( channel_identifier , closing_participant , nonce ) ; }
function broadcastSignedRequestAsPayerAction ( bytes _requestData , bytes _payeesPaymentAddress , bytes _payerRefundAddress , uint256 [ ] _additionals , uint256 _expirationDate , bytes _signature ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( _expirationDate >= block . timestamp , "expiration should be after current time" ) ; require ( Signature . checkBtcRequestSignature ( _requestData , _payeesPaymentAddress , _expirationDate , _signature ) , "signature should be correct" ) ; return createAcceptAndAdditionalsFromBytes ( _requestData , _payeesPaymentAddress , _payerRefundAddress , _additionals ) ; }
function addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) external onlyOwner nonReentrant { _addModule ( _moduleFactory , _data , _maxCost , _budget ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( isTransferEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _value ) revert ( ) ; allowed [ _from ] [ msg . sender ] -= _value ; return doTransfer ( _from , _to , _value ) ; }
function terminateSelfDestruct ( ) external onlyOwner { initiationTime = 0 ; selfDestructInitiated = false ; emit SelfDestructTerminated ( ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public validAddress ( _to ) transfersAllowed ( _from ) returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }
function setWithholdingFixed ( address [ ] _investors , uint256 _withholding ) public withPerm ( MANAGE ) { require ( _withholding <= 10 ** 18 , "Incorrect withholding tax" ) ; emit SetWithholdingFixed ( _investors , _withholding , now ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { withholdingTax [ _investors [ i ] ] = _withholding ; } }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { assert ( msg . sender != address ( 0 ) ) ; assert ( _from != address ( 0 ) ) ; assert ( _to != address ( 0 ) ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( ! frozenAccount [ _from ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( tokenBalanceOf [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( tokenBalanceOf [ _from ] - _value < tokenBalanceOf [ _from ] ) ; require ( tokenBalanceOf [ _to ] + _value > tokenBalanceOf [ _to ] ) ; require ( _value > 0 ) ; orderToTransfer ( msg . sender , _from , _to , _value , "Order to transfer tokens from allowed account" ) ; _transfer ( _from , _to , _value ) ; allowed [ _from ] [ msg . sender ] -= _value ; return true ; }
function _verifyInput ( bytes32 question_id , bytes32 last_history_hash , bytes32 last_answer_or_commitment_id , uint256 last_bond , address last_answerer , bool is_commitment ) internal view returns ( bool , bytes32 ) { require ( realitio . isPendingArbitration ( question_id ) , "The question must be pending arbitration in realitio" ) ; bytes32 history_hash = realitio . getHistoryHash ( question_id ) ; require ( history_hash == keccak256 ( last_history_hash , last_answer_or_commitment_id , last_bond , last_answerer , is_commitment ) , "The history parameters supplied must match the history hash in the realitio contract" ) ; }
function freezeTokenTransfers ( ) public onlyOwner returns ( bool frozen ) { tokenTransfersFrozen = true ; FreezeTokenTransfers ( msg . sender , true ) ; return true ; }
function depositEther ( ) external payable { require ( msg . value > 0 ) ; addUser ( msg . sender ) ; balances [ 0 ] [ msg . sender ] = balances [ 0 ] [ msg . sender ] . add ( msg . value ) ; Deposit ( 0 , msg . sender , msg . value , balances [ 0 ] [ msg . sender ] ) ; }
function activate ( uint256 _gameID , uint256 _startTime ) external isHuman ( ) onlyDevOrOwner ( ) { require ( _gameID < gameIDIndex_ , "incorrect game id" ) ; require ( game_ [ _gameID ] . gameStartTime == 0 , "already activated" ) ; game_ [ _gameID ] . gameStartTime = _startTime ; emit onGameActivated ( _gameID , _startTime , now ) ; }
function pauseSale ( bool _flag ) onlyAdmin ( 2 ) public { require ( state != State . Successful ) ; if ( _flag == true ) { require ( state != State . Paused ) ; laststate = state ; remainingActualState = SaleDeadline . sub ( now ) ; state = State . Paused ; emit LogSalePaused ( true ) ; } else { require ( state == State . Paused ) ; state = laststate ; SaleDeadline = now . add ( remainingActualState ) ; emit LogSalePaused ( false ) ; } }
function setPricingStartegy ( address _pricingStrategyAddress ) whenNotPaused onlyOwner external { pricingStrategy = PricingStrategy ( _pricingStrategyAddress ) ; }
function setPrepaid ( address _backer , uint _tokenPrice , uint _tokenAmount , string _privatePhrase , uint _backerRank ) external founderCall returns ( uint ) { if ( _tokenPrice == 0 || _tokenAmount == 0 || claimedPrepaidUnits > 0 || _tokenAmount + prepaidUnits + claimedUnits > promissoryUnits ) throw ; if ( earlyBackerList . length == numOfBackers && backers [ _backer ] . length == 0 ) throw ; if ( backers [ _backer ] . length == 0 ) { earlyBackerList . push ( _backer ) ; backersAddresses . push ( _backer ) ; } backers [ _backer ] . push ( backerData ( _tokenPrice , _tokenAmount , sha3 ( _privatePhrase , _backer ) , true , false , _backerRank ) ) ; prepaidUnits += _tokenAmount ; lastPrice = _tokenPrice ; AddedPrepaidTokensEvent ( _backer , backers [ _backer ] . length - 1 , _tokenPrice , _tokenAmount ) ; return backers [ _backer ] . length - 1 ; }
function withdrawExcessToken ( address token ) external onlyOwner { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 quantity ; bool ok ; ( quantity , ok ) = getQuantity ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( creationUnit_ ) . mul ( quantity ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }
function transfer ( address to , uint value , bytes data ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ sender ] == 0 || value <= transferableHavvens ( sender ) , "Value to transfer exceeds available havvens" ) ; _transfer_byProxy ( messageSender , to , value , data ) ; return true ; }
function fracExp ( uint256 _k , uint256 _q , uint256 _n , uint256 _p ) internal pure returns ( uint256 ) { uint256 s = 0 ; uint256 N = 1 ; uint256 B = 1 ; for ( uint256 i = 0 ; i < _p ; ++ i ) { s += _k * N / B / ( _q ** i ) ; N = N * ( _n - i ) ; B = B * ( i + 1 ) ; } return s ; }
function pause ( bytes32 _hash ) external pollApproved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) notBeforeGenesis { if ( ! paused ) { paused = true ; LogPause ( _hash ) ; } }
function transfer ( address _to , uint256 _value ) public validAddress ( _to ) transfersAllowed ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused afterCrowdsale returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }
function setMinMaxContribution ( uint256 _min , uint256 _max ) public isAdmin isOpenOrClosed { require ( _max <= maxAllocation ) ; require ( _min <= _max ) ; minContribution = _min ; maxContribution = _max ; }
function getBook ( ) public constant returns ( uint [ ] ) ;
function removeMember ( address _member ) external ;
function getCollectionData ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bytes8 , uint64 [ ] ) { require ( _collectionIndex < totalCollections ( ) , "Collection does not exist" ) ; return ( collectionNames [ _collectionIndex ] , collectionTokens [ _collectionIndex ] ) ; }
function burn ( uint256 value ) onlyOwner returns ( bool success ) { require ( balances [ msg . sender ] > value && value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; currentSupply = currentSupply . sub ( value ) ; Burn ( msg . sender , value ) ; return true ; }
function registerModule ( address _moduleFactory ) external ;
function claimByProof ( address _claimer , bytes32 [ ] data , bytes32 [ ] proofs , uint256 number ) onlyToken returns ( bool success ) { return false ; }
function setRBInformationStoreAddress ( address _address ) { require ( multiSigAddress == msg . sender ) ; rbInformationStore = RBInformationStore ( _address ) ; LogSetRBInformationStoreAddress ( _address ) ; }
function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 4 ) ; availableTags [ 0 ] = "Capped" ; availableTags [ 1 ] = "Non-refundable" ; availableTags [ 2 ] = "POLY" ; availableTags [ 3 ] = "ETH" ; return availableTags ; }
function setRoles2Library ( Roles2LibraryInterface _roles2Library ) auth external returns ( uint ) { roles2Library = _roles2Library ; return OK ; }
function settlementContract ( uint64 _settlementID ) external view returns ( Settlement ) { return settlementDetails [ _settlementID ] . settlementContract ; }
function balanceOf ( address account ) public view returns ( uint ) { return tokenState . balanceOf ( account ) ; }
function isFinalized ( bytes32 question_id ) constant public returns ( bool ) { uint32 finalize_ts = questions [ question_id ] . finalize_ts ; return ( ! questions [ question_id ] . is_pending_arbitration && ( finalize_ts > UNANSWERED ) && ( finalize_ts <= uint32 ( now ) ) ) ; }
function activateDestruction ( ) public onlyContractOwner onlySaleFinished notDestructed returns ( uint ) { destructed = true ; _emitDestruction ( ) ; return OK ; }
function getManager ( address _addr ) public view returns ( address ) { if ( managers [ _addr ] == 0 ) { return _addr ; } else { return managers [ _addr ] ; } }
function setUint ( bytes32 _key , uint _value ) public onlyOwner returns ( bool success ) { uIntStorage [ _key ] = _value ; return true ; }
function addManyWhitelist ( address [ ] _accounts ) external whenNotPaused onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { if ( _accounts [ i ] != address ( 0 ) && ! whitelist [ _accounts [ i ] ] ) { whitelist [ _accounts [ i ] ] = true ; emit WhitelistAdded ( _accounts [ i ] ) ; } } return true ; }
function _tickerAvailable ( string _ticker ) internal view returns ( bool ) { if ( _tickerOwner ( _ticker ) != address ( 0 ) ) { if ( ( now > getUint ( Encoder . getKey ( "registeredTickers_expiryDate" , _ticker ) ) ) && ! _tickerStatus ( _ticker ) ) { return true ; } else return false ; } return true ; }
function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) ;
function STARTMETADOLLAR ( ) { mtdAmount = 1000000000000000000 ; ethAmount = 1000000000000000 ; mtdPreAmount = 1000000000000000000 ; ethPreAmount = 1000000000000000 ; preIcoIsRunning = true ; minimalGoalReached = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = mtdAmount * ethAmount ; preICOprice = mtdPreAmount * ethPreAmount ; ICOprice = mtdAmount * ethAmount ; sellPrice = 900000000000000 ; updatePrices ( ) ; }
function setKyberNetwork ( address _KyberNetwork ) public ;
function setTokenExchange ( address _songTokenExchange ) public onlyAdmin notFrozen returns ( bool set ) { songTokenExchange = _songTokenExchange ; SongTokenExchangeContractSet ( msg . sender , _songTokenExchange , true ) ; return true ; }
function addCertification ( address _student , bytes32 _contentHash , bytes _ipfsHash , bytes32 _transcriptHash ) public onlyOwner { uint currIndx = studentCertifications [ _student ] . indx ; ( studentCertifications [ _student ] . documents [ currIndx ] ) . addCertification ( _contentHash , _ipfsHash , _transcriptHash ) ; studentCertifications [ _student ] . indx ++ ; emit CertificationAdded ( _student , currIndx ) ; }
function setETHPriceLowerBound ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { m_ETHPriceLowerBound = _price ; }
function transferChamp ( address _from , address _to , uint256 _champId ) internal ifChampForSaleThenCancelSale ( _champId ) { Champ storage champ = champs [ _champId ] ; addressInfo [ _to ] . champsCount ++ ; addressInfo [ _from ] . champsCount -- ; champToOwner [ _champId ] = _to ; if ( champ . eq_sword != 0 ) { transferItem ( _from , _to , champ . eq_sword ) ; } if ( champ . eq_shield != 0 ) { transferItem ( _from , _to , champ . eq_shield ) ; } if ( champ . eq_helmet != 0 ) { transferItem ( _from , _to , champ . eq_helmet ) ; } emit TransferChamp ( _from , _to , _champId ) ; }
function increaseApproval ( address _spender , uint256 _addedValue ) public returns ( bool success ) { return erc20Impl . increaseApprovalWithSender ( msg . sender , _spender , _addedValue ) ; }
function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( multisigs [ msigId ] . owner == msg . sender ) ; require ( multisigs [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= min ( now + 1 days , multisigs [ msigId ] . unlockTime ) ) ; require ( amount > 0 ) ; require ( ! isAntecedentHashedSecret [ hashedSecret ] ) ; isAntecedentHashedSecret [ hashedSecret ] = true ; multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , add ( amount , fee ) ) ; swapId = keccak256 ( msigId , msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; AtomicSwap storage swap = atomicswaps [ swapId ] ; swap . msigId = msigId ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; FEE_RECIPIENT . transfer ( fee ) ; }
function depositCollateral ( address token , uint amount ) public { require ( isAcceptedToken ( token ) , "ERC20 not authorised" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( isValid ( token ) ) ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] . add ( amount ) ; emit Deposit ( token , msg . sender , amount , tokens [ token ] [ msg . sender ] ) ; require ( StandardToken ( token ) . transferFrom ( msg . sender , this , amount ) , "error with transfer" ) ; IRemoteFunctions ( _contract_masternode ( ) ) . _externalAddMasternode ( msg . sender ) ; }
function convertSafe ( TokenConverter converter , Token from , Token to , uint256 amount ) internal returns ( uint256 bought ) { require ( from . approve ( converter , amount ) ) ; uint256 prevBalance = to . balanceOf ( this ) ; bought = converter . convert ( from , to , amount , 1 ) ; require ( to . balanceOf ( this ) . sub ( prevBalance ) >= bought , "Bought amount incorrect" ) ; require ( from . approve ( converter , 0 ) ) ; }
function doTransfer ( address _from , address _to , uint256 _value ) validate_address ( _to ) is_not_locked ( _from ) internal returns ( bool success ) { if ( _value <= 0 || balances [ _from ] < _value || balances [ _to ] + _value < balances [ _to ] ) { return false ; } balances [ _from ] -= _value ; balances [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; }
function proposal ( uint _proposalId ) public view returns ( uint _startBlock , uint _startTime , uint _duration , bool _active , bool _finalized , uint [ ] _votes , address [ ] _tokens , address _votingToken , bool _hasBalance ) { require ( _proposalId < tokenBatches . length ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; _startBlock = p . startBlock ; _startTime = p . startTime ; _duration = p . duration ; _finalized = ( _startTime + _duration < now ) ; _active = isActive ( _proposalId ) ; _votes = getVotes ( ) ; _tokens = getConsideredTokens ( ) ; _votingToken = p . votingToken ; _hasBalance = ( p . votingToken == 0x0 ) ? false : ( DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) > 0 ) ; }
function updateDescriptiveInformation ( address ofAsset , string name , string symbol , string url , string ipfsHash ) pre_cond ( isOwner ( ) ) pre_cond ( information [ ofAsset ] . exists ) { Asset asset = information [ ofAsset ] ; asset . name = name ; asset . symbol = symbol ; asset . url = url ; asset . ipfsHash = ipfsHash ; }
function getAllNames ( ) public view returns ( bytes8 [ ] ) { return pixelconNames ; }
function setAutopay ( bool _automatic ) public onlyOwner { autoPay = _automatic ; AutoPaySet ( ) ; }
function issueSynths ( bytes4 currencyKey , uint amount ) public optionalProxy nonZeroAmount ( amount ) { require ( amount <= remainingIssuableSynths ( messageSender , currencyKey ) , "Amount too large" ) ; _addToDebtRegister ( currencyKey , amount ) ; synths [ currencyKey ] . issue ( messageSender , amount ) ; }
function getAllowedContribution ( ) private returns ( uint256 , uint256 ) { uint256 allowedContribution = msg . value ; uint256 tillCap = remainingCap ( ) ; uint256 refundAmount = 0 ; if ( msg . value > tillCap ) { allowedContribution = tillCap ; refundAmount = msg . value . sub ( allowedContribution ) ; ContributionRefund ( refundAmount , msg . sender ) ; } return ( allowedContribution , refundAmount ) ; }
function _transfer ( address _owner , address _receiver , uint256 _tokenId ) internal { nonFungibleContract . transferFrom ( _owner , _receiver , _tokenId ) ; }
function multisend ( address [ ] recipients , uint256 value ) onlyOwner public { for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { mintToken ( recipients [ i ] , value ) ; } }
function addModerator ( address _newMod ) public onlyAdmin notFrozen returns ( bool success ) { moderators [ _newMod ] = true ; ModeratorAdded ( msg . sender , _newMod , true ) ; return true ; }
function setWithholding ( address [ ] _investors , uint256 [ ] _withholding ) public withPerm ( MANAGE ) { require ( _investors . length == _withholding . length , "Mismatched input lengths" ) ; emit SetWithholding ( _investors , _withholding , now ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { require ( _withholding [ i ] <= 10 ** 18 , "Incorrect withholding tax" ) ; withholdingTax [ _investors [ i ] ] = _withholding [ i ] ; } }
function removeBurningMan ( address _burningMan , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _burningMan ) , _block ) ; if ( OK != _code ) { return _code ; } uint _idx = burningMan2index [ _burningMan ] ; uint _lastIdx = burningMansCount ; if ( _idx != 0 ) { if ( _idx != _lastIdx ) { address _lastBurningMan = index2burningMan [ _lastIdx ] ; index2burningMan [ _idx ] = _lastBurningMan ; burningMan2index [ _lastBurningMan ] = _idx ; } delete burningMan2index [ _burningMan ] ; delete index2burningMan [ _lastIdx ] ; delete burningMans [ _burningMan ] ; burningMansCount = _lastIdx - 1 ; } return OK ; }
function append ( Data storage _data , address _item , address _to ) { if ( _data . isContain [ _item ] ) throw ; if ( _data . head == 0 ) { _data . head = _data . tail = _item ; } else { if ( ! _data . isContain [ _to ] ) throw ; var nextTo = _data . nextOf [ _to ] ; if ( nextTo != 0 ) { _data . prevOf [ nextTo ] = _item ; } else { _data . tail = _item ; } _data . nextOf [ _to ] = _item ; _data . prevOf [ _item ] = _to ; _data . nextOf [ _item ] = nextTo ; } _data . isContain [ _item ] = true ; ++ _data . length ; }
function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { if ( _to != 0x0 ) { return _getAsset ( ) . __transferFromWithReference ( _from , _to , _value , "" , msg . sender ) ; } }
function approve ( address _spender , uint _value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function getSecurityTokenData ( address _securityToken ) public view returns ( string , address , string ) ;
function setMinimumDepositAmount ( uint _amount ) external onlyOwner { require ( _amount > SafeDecimalMath . unit ( ) , "Minimum deposit amount must be greater than UNIT" ) ; minimumDepositAmount = _amount ; emit MinimumDepositAmountUpdated ( minimumDepositAmount ) ; }
function release ( ERC20 token ) public { for ( uint i = 0 ; i < _beneficiary . length ; i ++ ) { if ( block . timestamp >= _unlocktime ) { token . transfer ( _beneficiary [ i ] , _amount [ i ] . mul ( 10 ** 18 ) ) ; emit Released ( _amount [ i ] ) ; _amount [ i ] = 0 ; } } }
function setIssuanceRatio ( uint _issuanceRatio ) external optionalProxy_onlyOwner { require ( _issuanceRatio <= MAX_ISSUANCE_RATIO ) ; issuanceRatio = _issuanceRatio ; emitIssuanceRatioUpdated ( _issuanceRatio ) ; }
function increaseTokenSaleAllocation ( ) public whenNotPaused onlyAdmin { uint256 allowance = token . allowance ( msg . sender , this ) ; uint256 current = totalSaleAllocation ; totalSaleAllocation = totalSaleAllocation . add ( allowance ) ; require ( token . transferFrom ( msg . sender , this , allowance ) ) ; emit TokensAllocatedForSale ( totalSaleAllocation , current ) ; }
function _transferDirect ( uint _fromId , uint _toId , uint _value , bytes32 _symbol ) internal { assets [ _symbol ] . wallets [ _fromId ] . balance = assets [ _symbol ] . wallets [ _fromId ] . balance . sub ( _value ) ; assets [ _symbol ] . wallets [ _toId ] . balance = assets [ _symbol ] . wallets [ _toId ] . balance . add ( _value ) ; }
function collectFor ( address recipient ) private { uint tokensOwned = balances [ recipient ] ; if ( tokensOwned == 0 ) return ; delete balances [ recipient ] ; tokenContract . safeTransfer ( recipient , tokensOwned ) ; emit Collection ( recipient , tokensOwned ) ; }
function registerPlayerToBoard ( uint tableStakes ) external payable allowedValuesOnly ( msg . value ) whenNotPaused returns ( uint ) { require ( msg . value == tableStakes ) ; GoBoard storage boardToJoin ; uint boardIDToJoin ; ( boardIDToJoin , boardToJoin ) = getOrCreateWaitingBoard ( tableStakes ) ; bool shouldStartGame = addPlayerToBoard ( boardToJoin , tableStakes ) ; PlayerAddedToBoard ( boardIDToJoin , msg . sender ) ; if ( shouldStartGame ) { startBoardGame ( boardToJoin , boardIDToJoin ) ; } return boardIDToJoin ; }
function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description ) ;
function referralsOf ( uint8 _level ) public view returns ( uint256 [ ] ) { return users [ addressToUser [ msg . sender ] ] . referralsByLevel [ uint8 ( _level ) ] ; }
function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x0a0fb66b ) , _token , _to , _value , _fee , _nonce , _validUntil ) ) ; }
function setAddress ( bytes32 _key , address _value ) public onlyOwner returns ( bool success ) { addressStorage [ _key ] = _value ; return true ; }
function withdrawExcessToken ( address token ) external onlyOwner nonReentrant { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 quantity ; bool ok ; ( quantity , ok ) = getQuantity ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( creationUnit ) . mul ( quantity ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }
function __transferWithReference ( address _to , uint _value , string _reference , address _sender ) onlyProxy public returns ( bool ) { var ( _fromRole , _toRole ) = _getParticipantRoles ( _sender , _to ) ; if ( ! _checkTransferAllowance ( _to , _toRole , _value , _sender , _fromRole ) ) { return false ; } if ( ! _isValidCountryLimits ( _to , _toRole , _value , _sender , _fromRole ) ) { return false ; } if ( ! super . __transferWithReference ( _to , _value , _reference , _sender ) ) { return false ; } _updateTransferLimits ( _to , _toRole , _value , _sender , _fromRole ) ; _contractFallbackERC223 ( _sender , _to , _value ) ; return true ; }
function addTokenGrant ( address _recipient , uint256 _startTime , uint128 _amount , uint16 _vestingDuration , uint16 _vestingCliff ) public onlyColonyMultiSig noGrantExistsForUser ( _recipient ) { require ( _vestingCliff > 0 ) ; require ( _vestingDuration > _vestingCliff ) ; uint amountVestedPerMonth = _amount / _vestingDuration ; require ( amountVestedPerMonth > 0 ) ; token . transferFrom ( colonyMultiSig , address ( this ) , _amount ) ; Grant memory grant = Grant ( { startTime : _startTime == 0 ? now : _startTime , amount : _amount , vestingDuration : _vestingDuration , vestingCliff : _vestingCliff , monthsClaimed : 0 , totalClaimed : 0 } ) ; tokenGrants [ _recipient ] = grant ; emit GrantAdded ( _recipient , grant . startTime , _amount , _vestingDuration , _vestingCliff ) ; }
function requireValidTerms ( PlatformTerms platformTerms ) public constant returns ( bool ) { if ( ALLOW_RETAIL_INVESTORS ) { require ( ! ENABLE_TRANSFERS_ON_SUCCESS , "NF_MUST_DISABLE_TRANSFERS" ) ; } else { require ( MIN_TICKET_EUR_ULPS >= MIN_QUALIFIED_INVESTOR_TICKET_EUR_ULPS , "NF_MIN_QUALIFIED_INVESTOR_TICKET" ) ; } require ( MIN_TICKET_EUR_ULPS >= TOKEN_TERMS . TOKEN_PRICE_EUR_ULPS ( ) , "NF_MIN_TICKET_LT_TOKEN_PRICE" ) ; require ( ESTIMATED_MAX_CAP_EUR_ULPS ( ) >= MIN_TICKET_EUR_ULPS , "NF_MAX_FUNDS_LT_MIN_TICKET" ) ; require ( MIN_TICKET_EUR_ULPS >= platformTerms . MIN_TICKET_EUR_ULPS ( ) , "NF_ETO_TERMS_MIN_TICKET_EUR_ULPS" ) ; require ( DURATION_TERMS . WHITELIST_DURATION ( ) >= platformTerms . MIN_WHITELIST_DURATION ( ) , "NF_ETO_TERMS_WL_D_MIN" ) ; require ( DURATION_TERMS . WHITELIST_DURATION ( ) <= platformTerms . MAX_WHITELIST_DURATION ( ) , "NF_ETO_TERMS_WL_D_MAX" ) ; require ( DURATION_TERMS . PUBLIC_DURATION ( ) >= platformTerms . MIN_PUBLIC_DURATION ( ) , "NF_ETO_TERMS_PUB_D_MIN" ) ; require ( DURATION_TERMS . PUBLIC_DURATION ( ) <= platformTerms . MAX_PUBLIC_DURATION ( ) , "NF_ETO_TERMS_PUB_D_MAX" ) ; uint256 totalDuration = DURATION_TERMS . WHITELIST_DURATION ( ) + DURATION_TERMS . PUBLIC_DURATION ( ) ; require ( totalDuration >= platformTerms . MIN_OFFER_DURATION ( ) , "NF_ETO_TERMS_TOT_O_MIN" ) ; require ( totalDuration <= platformTerms . MAX_OFFER_DURATION ( ) , "NF_ETO_TERMS_TOT_O_MAX" ) ; require ( DURATION_TERMS . SIGNING_DURATION ( ) >= platformTerms . MIN_SIGNING_DURATION ( ) , "NF_ETO_TERMS_SIG_MIN" ) ; require ( DURATION_TERMS . SIGNING_DURATION ( ) <= platformTerms . MAX_SIGNING_DURATION ( ) , "NF_ETO_TERMS_SIG_MAX" ) ; require ( DURATION_TERMS . CLAIM_DURATION ( ) >= platformTerms . MIN_CLAIM_DURATION ( ) , "NF_ETO_TERMS_CLAIM_MIN" ) ; require ( DURATION_TERMS . CLAIM_DURATION ( ) <= platformTerms . MAX_CLAIM_DURATION ( ) , "NF_ETO_TERMS_CLAIM_MAX" ) ; return true ; }
function createNew ( bytes32 _regName , address _owner ) public payable feePaid returns ( address kAddr_ ) { kAddr_ = address ( new Forwarder ( msg . sender , _regName , _owner ) ) ; Created ( msg . sender , _regName , kAddr_ ) ; }
function setFailOverStakeContract ( address _contractAddress ) external onlyOwner nonAdminAddress ( _contractAddress ) returns ( bool ) { if ( stakeFailOverRestrictionLifted == false ) { stakeFailOverRestrictionLifted = true ; return true ; } else { minters [ _contractAddress ] = true ; stakeFailOverRestrictionLifted = false ; emit FailOverStakeContractSet ( _contractAddress ) ; return true ; } }
function bulkTokenSend ( address [ ] beneficiaries , uint256 amount , string ) onlyOwner external { require ( amount > 0 ) ; for ( uint32 i = 0 ; i < beneficiaries . length ; i ++ ) { mintTokens ( beneficiaries [ i ] , amount ) ; } }
function newVote ( bytes _executionScript , string _metadata , bool _castVote , bool _executesIfDecided ) external auth ( CREATE_VOTES_ROLE ) returns ( uint256 voteId ) { return _newVote ( _executionScript , _metadata , _castVote , _executesIfDecided ) ; }
function giveItem ( address _to , uint256 _itemID ) public onlyOwnerOfItem ( _itemID ) { transferItem ( msg . sender , _to , _itemID ) ; }
function _proxyTransferEvent ( uint _fromId , uint _toId , uint _value , bytes32 _symbol ) internal { if ( proxies [ _symbol ] != 0x0 ) { ProxyEventsEmitter ( proxies [ _symbol ] ) . emitTransfer ( _address ( _fromId ) , _address ( _toId ) , _value ) ; } }
function _approve ( uint _spenderId , uint _value , bytes32 _symbol , uint _senderId ) internal returns ( uint ) { if ( ! isCreated ( _symbol ) ) { return _error ( ATX_PLATFORM_ASSET_IS_NOT_ISSUED ) ; } if ( _senderId == _spenderId ) { return _error ( ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( assets [ _symbol ] . wallets [ _senderId ] . allowance [ _spenderId ] != 0 && _value != 0 ) { return _error ( ATX_PLATFORM_INVALID_INVOCATION ) ; } assets [ _symbol ] . wallets [ _senderId ] . allowance [ _spenderId ] = _value ; Emitter ( eventsHistory ) . emitApprove ( _address ( _senderId ) , _address ( _spenderId ) , _symbol , _value ) ; if ( proxies [ _symbol ] != 0x0 ) { ProxyEventsEmitter ( proxies [ _symbol ] ) . emitApprove ( _address ( _senderId ) , _address ( _spenderId ) , _value ) ; } return OK ; }
function useModule ( address _moduleFactory ) external { if ( ISecurityTokenRegistry ( getAddress ( Encoder . getKey ( "securityTokenRegistry" ) ) ) . isSecurityToken ( msg . sender ) ) { if ( IFeatureRegistry ( getAddress ( Encoder . getKey ( "featureRegistry" ) ) ) . getFeatureStatus ( "customModulesAllowed" ) ) { require ( getBool ( Encoder . getKey ( "verified" , _moduleFactory ) ) || IOwnable ( _moduleFactory ) . owner ( ) == IOwnable ( msg . sender ) . owner ( ) , "ModuleFactory must be verified or SecurityToken owner must be ModuleFactory owner" ) ; } else { require ( getBool ( Encoder . getKey ( "verified" , _moduleFactory ) ) , "ModuleFactory must be verified" ) ; } require ( _isCompatibleModule ( _moduleFactory , msg . sender ) , "Version should within the compatible range of ST" ) ; pushArray ( Encoder . getKey ( "reputation" , _moduleFactory ) , msg . sender ) ; emit ModuleUsed ( _moduleFactory , msg . sender ) ; } }
function isPendingArbitration ( bytes32 question_id ) public view returns ( bool ) { return questions [ question_id ] . is_pending_arbitration ; }
function remainigTokens ( ) public view returns ( uint256 ) { return tokenReward . balanceOf ( this ) ; }
function unarchiveModule ( address _module ) external ;
function addPolicyRule ( bytes4 _sig , address _contract , bytes32 _groupName , uint _acceptLimit , uint _declineLimit ) onlyContractOwner external returns ( uint ) { require ( _sig != 0x0 ) ; require ( _contract != 0x0 ) ; require ( GroupsAccessManager ( accessManager ) . isGroupExists ( _groupName ) ) ; require ( _acceptLimit != 0 ) ; require ( _declineLimit != 0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; if ( policyId2Index [ _policyHash ] == 0 ) { uint _policiesCount = policiesCount . add ( 1 ) ; index2PolicyId [ _policiesCount ] = _policyHash ; policyId2Index [ _policyHash ] = _policiesCount ; policiesCount = _policiesCount ; } Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupsCount = _policy . groupsCount ; if ( _policy . groupName2index [ _groupName ] == 0 ) { _policyGroupsCount += 1 ; _policy . groupName2index [ _groupName ] = _policyGroupsCount ; _policy . participatedGroups [ _policyGroupsCount ] . groupName = _groupName ; _policy . groupsCount = _policyGroupsCount ; } uint _previousAcceptLimit = _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit ; uint _previousDeclineLimit = _policy . participatedGroups [ _policyGroupsCount ] . declineLimit ; _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit = _acceptLimit ; _policy . participatedGroups [ _policyGroupsCount ] . declineLimit = _declineLimit ; _policy . totalAcceptedLimit = _policy . totalAcceptedLimit . sub ( _previousAcceptLimit ) . add ( _acceptLimit ) ; _policy . totalDeclinedLimit = _policy . totalDeclinedLimit . sub ( _previousDeclineLimit ) . add ( _declineLimit ) ; PolicyRuleAdded ( _sig , _contract , _policyHash , _groupName , _acceptLimit , _declineLimit ) ; return OK ; }
function changeBoardMetadata ( bytes32 boardHash , bytes32 name , string boardDescription ) public returns ( bool ) { require ( boards [ boardHash ] . boardOwner == msg . sender ) ; boards [ boardHash ] . boardName = name ; boards [ boardHash ] . boardDescription = boardDescription ; }
function makeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { revert ( ) ; }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId , bytes _data ) public { transferFrom ( _from , _to , _tokenId ) ; require ( checkAndCallSafeTransfer ( _from , _to , _tokenId , _data ) , "Transfer was not safe" ) ; }
function getCompetitionStatusOfRegistrants ( ) view returns ( address [ ] , address [ ] , bool [ ] ) { address [ ] memory fundAddrs = new address [ ] ( registrants . length ) ; address [ ] memory fundRegistrants = new address [ ] ( registrants . length ) ; bool [ ] memory isRewarded = new bool [ ] ( registrants . length ) ; for ( uint i = 0 ; i < registrants . length ; i ++ ) { fundAddrs [ i ] = registrants [ i ] . fund ; fundRegistrants [ i ] = registrants [ i ] . registrant ; isRewarded [ i ] = registrants [ i ] . isRewarded ; } return ( fundAddrs , fundRegistrants , isRewarded ) ; }
function tokenFallback ( address _from , uint _value , bytes _data ) external { require ( _from == abioToken . owner ( ) || _from == owner ) ; volume = _value ; paused = false ; deadline = now + length ; emit ICOStart ( _value , weiPerABIO , minInvestment ) ; }
function decTotalSupply ( uint _val ) external onlyOwner returns ( bool ) { totalSupply = totalSupply . sub ( _val ) ; return true ; }
function ( ) payable internal { uint amount = msg . value * buyPrice ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value <= 10 ** 17 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; emit Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
function _safeCall ( address _to , uint _amount ) internal { require ( _to != 0 ) ; require ( _to . call . value ( _amount ) ( ) ) ; }
function registerProducer ( address aproducer ) onlyOwner external { emit producerRegistered ( aproducer ) ; producers [ aproducer ] = true ; }
function ( ) public payable { require ( allowWhitelisted || allowAnonymous ) ; if ( ! allowAnonymous ) { if ( allowWhitelisted ) { require ( whitelisted [ msg . sender ] ) ; } } internalContribution ( msg . sender , msg . value ) ; }
function createTemplate ( string content ) stateAny ( ) public returns ( uint256 ) { uint256 id = nextTemplateID ; templates [ id ] = block . number ; LogNewTemplate ( id , msg . sender , content ) ; nextTemplateID = id . add ( 1 ) ; return id ; }
function revoke ( ERC20Basic _token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ _token ] ) ; uint256 balance = _token . balanceOf ( address ( this ) ) ; uint256 unreleased = releasableAmount ( _token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ _token ] = true ; _token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }
function getSupplyBalance ( address account , address asset ) view public returns ( uint ) { Error err ; uint newSupplyIndex ; uint userSupplyCurrent ; Market storage market = markets [ asset ] ; Balance storage supplyBalance = supplyBalances [ account ] [ asset ] ; ( err , newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; require ( err == Error . NO_ERROR ) ; ( err , userSupplyCurrent ) = calculateBalance ( supplyBalance . principal , supplyBalance . interestIndex , newSupplyIndex ) ; require ( err == Error . NO_ERROR ) ; return userSupplyCurrent ; }
function claim ( bytes32 channelId , uint256 payment , bytes signature ) public { require ( canClaim ( channelId , payment , msg . sender , signature ) ) ; PaymentChannel memory channel = channels [ channelId ] ; if ( payment >= channel . value ) { channel . receiver . transfer ( channel . value ) ; } else { channel . receiver . transfer ( payment ) ; channel . sender . transfer ( channel . value . sub ( payment ) ) ; } delete channels [ channelId ] ; DidClaim ( channelId ) ; }
function approve ( address _spender , uint256 _value ) public whenNotPaused returns ( bool success ) { require ( _value > 0 ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function cofounderSwitchAddress ( address _newCofounderAddr ) external returns ( bool success ) { if ( msg . sender != cofounder ) throw ; cofounder = _newCofounderAddr ; CofounderSwitchedEvent ( _newCofounderAddr ) ; return true ; }
function collectAuthorizedPayment ( uint _idPayment ) { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( msg . sender != p . recipient ) throw ; if ( ! allowedSpenders [ p . spender ] ) throw ; if ( now < p . earliestPayTime ) throw ; if ( p . canceled ) throw ; if ( p . paid ) throw ; if ( this . balance < p . amount ) throw ; p . paid = true ; if ( ! p . recipient . send ( p . amount ) ) { throw ; } PaymentExecuted ( _idPayment , p . recipient , p . amount ) ; }
function withdrawHavvens ( uint amount ) external onlyOwner { havven . transfer ( owner , amount ) ; }
function totalSupply ( ) public view returns ( uint Supply ) { return totalHurify ; }
function buyChamp ( uint256 _id ) external payable whenNotPaused onlyNotOwnerOfChamp ( _id ) champIsForSale ( _id ) isPaid ( champs [ _id ] . price ) distributeSaleInput ( champToOwner [ _id ] ) { transferChamp ( champToOwner [ _id ] , msg . sender , _id ) ; }
function withdraw ( bytes locked_encoded , bytes merkle_proof , bytes32 secret ) { data . withdraw ( locked_encoded , merkle_proof , secret ) ; ChannelSecretRevealed ( secret , msg . sender ) ; }
function distribute ( address to , uint256 tokenAmount ) public onlyOwner { require ( tokenAmount > 0 ) ; require ( tokenAmount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( owner , to , tokenAmount ) ; }
function initialize ( ) initializeOnceOnly public { }
function finalize ( ) public onlyDonationAddress returns ( bool ) { require ( getSencBalance ( ) >= sencHardCap || now >= endDate , "SENC hard cap rached OR End date reached" ) ; require ( ! finalized , "Donation not already finalized" ) ; totalSencCollected = getSencBalance ( ) ; if ( totalSencCollected >= sencHardCap ) { donationWallet . transfer ( address ( this ) . balance ) ; } else { uint256 totalDonatedEthers = convertToEther ( totalSencCollected ) + INFOCORP_DONATION ; donationWallet . transfer ( totalDonatedEthers ) ; claimTokens ( address ( 0 ) , foundationWallet ) ; } claimTokens ( SENC_CONTRACT_ADDRESS , foundationWallet ) ; finalized = true ; return finalized ; }
function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; require ( this . balance >= revenue ) ; msg . sender . transfer ( revenue ) ; }
function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) , "Spender address is not provided" ) ; require ( signatures [ _signature ] == false , "No Signature" ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) , "From address is not provided" ) ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
function tokenPriceInEuroCents ( ) public constant returns ( uint ) { return 1000 ; }
function setMaxSecurityGuardDelay ( uint _maxSecurityGuardDelay ) onlyContractOwner { maxSecurityGuardDelay = _maxSecurityGuardDelay ; }
function getFinalAnswerIfMatches ( bytes32 question_id , bytes32 content_hash , address arbitrator , uint32 min_timeout , uint256 min_bond ) external view returns ( bytes32 ) { }
function contribute ( uint8 _v , bytes32 _r , bytes32 _s ) public payable { address recoveredAddress = verify ( msg . sender , _v , _r , _s ) ; require ( signers [ recoveredAddress ] ) ; internalContribution ( msg . sender , msg . value ) ; }
function createRegulatorProxy ( address regulatorImplementation ) public { address proxy = address ( new RegulatorProxy ( regulatorImplementation ) ) ; Regulator newRegulator = Regulator ( proxy ) ; newRegulator . addValidator ( msg . sender ) ; addAllPermissions ( newRegulator ) ; RegulatorProxy ( proxy ) . transferOwnership ( msg . sender ) ; regulators . push ( proxy ) ; emit CreatedRegulatorProxy ( proxy , getCount ( ) - 1 ) ; }
function approveBlacklistedAddressSpender ( address _blacklistedAccount ) public userBlacklisted ( _blacklistedAccount ) whenNotPaused requiresPermission { tokenStorage . setAllowance ( _blacklistedAccount , msg . sender , balanceOf ( _blacklistedAccount ) ) ; emit ApprovedBlacklistedAddressSpender ( _blacklistedAccount , msg . sender , balanceOf ( _blacklistedAccount ) ) ; }
function balanceOfAt ( address _investor , uint256 _checkpointId ) public view returns ( uint256 ) ;
function balance ( ) constant returns ( uint ) { if ( ! between [ msg . sender ] ) { return 0 ; } uint share = totalInput / count ; uint withdrew = amountsWithdrew [ msg . sender ] ; uint available = share - withdrew ; assert ( available >= 0 && available <= share ) ; return available ; }
function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 30636000000 ; }
function get ( string _name ) public view returns ( uint value ) { return params [ keccak256 ( _name ) ] ; }
function launchContract ( ) onlyOwner { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; LaunchContract ( msg . sender , true ) ; }
function collect ( ) isOwner { require ( this . balance > 0 ) ; withdraw ( this . balance ) ; }
function issueAttribute ( address account , uint256 attributeTypeID , uint256 value ) external payable whenNotPaused { require ( canValidate ( msg . sender , attributeTypeID ) , "only approved validators may assign attributes of this type" ) ; require ( ! _issuedAttributes [ account ] [ attributeTypeID ] . exists , "duplicate attributes are not supported, remove existing attribute first" ) ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; uint256 stake = msg . value . sub ( jurisdictionFee ) ; require ( stake >= minimumStake , "attribute requires a greater value than is currently provided" ) ; _issuedAttributes [ account ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , setPersonally : false , operator : address ( 0 ) , validator : msg . sender , value : value , stake : stake } ) ; emit AttributeAdded ( msg . sender , account , attributeTypeID , value ) ; if ( stake > 0 ) { emit StakeAllocated ( msg . sender , attributeTypeID , stake ) ; } if ( jurisdictionFee > 0 ) { if ( owner ( ) . send ( jurisdictionFee ) ) { emit FeePaid ( owner ( ) , msg . sender , attributeTypeID , jurisdictionFee ) ; } } }
function addItemWithClassAndData ( string _name , uint16 _rarity , uint16 _weapon , uint [ ] _statsMin , uint [ ] _statsMax , uint16 _amount , string _hostfile , uint16 _minLevel , string _desc , uint _price ) public onlyModerators { ItemClass storage _itemClass = classIdToClass [ totalItemClass ] ; _itemClass . classId = totalItemClass ; _itemClass . name = _name ; _itemClass . amount = _amount ; _itemClass . rarity = _rarity ; _itemClass . weapon = _weapon ; _itemClass . statsMin = _statsMin ; _itemClass . statsMax = _statsMax ; _itemClass . hostfile = _hostfile ; _itemClass . minLevel = _minLevel ; _itemClass . desc = _desc ; _itemClass . total = 0 ; _itemClass . price = _price ; _itemClass . active = true ; totalItemClass = globalClasses . push ( _itemClass ) ; totalItems ++ ; }
function setLocks ( address [ ] _holders , uint256 [ ] _lockups ) public onlyController { require ( _holders . length == _lockups . length ) ; require ( _holders . length < 256 ) ; require ( transfersEnabled == false ) ; for ( uint8 i = 0 ; i < _holders . length ; i ++ ) { address holder = _holders [ i ] ; uint256 lockup = _lockups [ i ] ; require ( lockups [ holder ] == 0 ) ; lockups [ holder ] = lockup ; emit LockedTokens ( holder , lockup ) ; } }
function getTickerDetails ( string _ticker ) external view returns ( address , uint256 , uint256 , string , bool ) ;
function distributeToken ( address [ ] addresses , uint256 _value ) onlyOwner public { require ( balanceOf [ owner ] >= _value * addresses . length ) ; for ( uint i = 0 ; i < addresses . length ; i ++ ) { require ( addresses [ i ] != 0x0 ) ; require ( balanceOf [ addresses [ i ] ] + _value > balanceOf [ addresses [ i ] ] ) ; require ( ! frozenAccount [ owner ] ) ; require ( ! frozenAccount [ addresses [ i ] ] ) ; balanceOf [ owner ] -= _value ; balanceOf [ addresses [ i ] ] += _value ; Transfer ( owner , addresses [ i ] , _value ) ; } }
function setPrices ( uint256 _newSellPrice , uint256 _newBuyPrice ) onlyDoftManager { sellPrice = _newSellPrice ; buyPrice = _newBuyPrice ; }
function makeBuyOffer ( uint32 _canvasId ) external payable stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; BuyOffer storage existing = buyOffers [ _canvasId ] ; require ( canvas . owner != msg . sender ) ; require ( canvas . owner != 0x0 ) ; require ( msg . value > existing . amount ) ; if ( existing . amount > 0 ) { addPendingWithdrawal ( existing . buyer , existing . amount ) ; } buyOffers [ _canvasId ] = BuyOffer ( true , msg . sender , msg . value ) ; emit BuyOfferMade ( _canvasId , msg . sender , msg . value ) ; }
function multiERC20Transfer ( ERC20 _token , address [ ] _addresses , uint [ ] _amounts ) public { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { _safeERC20Transfer ( _token , _addresses [ i ] , _amounts [ i ] ) ; MultiERC20Transfer ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] , _token ) ; } }
function ( ) external payable { require ( msg . value > 0 ) ; address ( heroes ) . transfer ( msg . value ) ; }
function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyOwner public { delete arbitration_bounties [ question_id ] ; realitio . submitAnswerByArbitrator ( question_id , answer , answerer ) ; }
function doBuy ( address _caller , uint256 etherAmount ) internal { Contribution ( etherAmount , _caller ) ; uint256 callerExchangeRate = shpExchangeRate . mul ( CALLER_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 reserveExchangeRate = shpExchangeRate . mul ( RESERVE_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 founderExchangeRate = shpExchangeRate . mul ( FOUNDER_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 bountyExchangeRate = shpExchangeRate . mul ( BOUNTY_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 callerTokens = etherAmount . mul ( callerExchangeRate ) ; uint256 callerTokensWithDiscount = applyDiscount ( etherAmount , callerTokens ) ; uint256 reserveTokens = etherAmount . mul ( reserveExchangeRate ) ; uint256 founderTokens = etherAmount . mul ( founderExchangeRate ) ; uint256 bountyTokens = etherAmount . mul ( bountyExchangeRate ) ; uint256 vestingTokens = founderTokens . add ( reserveTokens ) ; founderTokenCount = founderTokenCount . add ( founderTokens ) ; reserveTokenCount = reserveTokenCount . add ( reserveTokens ) ; shp . generateTokens ( _caller , callerTokensWithDiscount ) ; shp . generateTokens ( bountyAddress , bountyTokens ) ; shp . generateTokens ( trusteeAddress , vestingTokens ) ; NewSale ( _caller , etherAmount , callerTokensWithDiscount ) ; NewSale ( trusteeAddress , etherAmount , vestingTokens ) ; NewSale ( bountyAddress , etherAmount , bountyTokens ) ; etherEscrowAddress . transfer ( etherAmount ) ; updateCounters ( etherAmount ) ; }
function checkLogin ( address _toCheck ) view external returns ( bool ) { uint256 check = 0 ; check -= 1 ; return ( cooldown [ _toCheck ] == check ) ; }
function transferOwnership ( address _tokenController , address _trusteeOwner ) public onlyOwner { require ( closed ) ; require ( _tokenController != 0x0 ) ; require ( _trusteeOwner != 0x0 ) ; shp . changeController ( _tokenController ) ; trustee . changeOwner ( _trusteeOwner ) ; }
function setAttributeTypeOnlyPersonal ( uint256 ID , bool onlyPersonal ) external { require ( isAttributeType ( ID ) , "unable to set to only personal, no attribute type with the provided ID" ) ; _attributeTypes [ ID ] . onlyPersonal = onlyPersonal ; }
function changeExpiryLimit ( uint256 _newExpiry ) external onlyOwner { require ( _newExpiry >= 1 days , "Expiry should >= 1 day" ) ; emit ChangeExpiryLimit ( getUint ( EXPIRYLIMIT ) , _newExpiry ) ; set ( EXPIRYLIMIT , _newExpiry ) ; }
function isUserAllowedToTransfer ( address _user ) public constant returns ( bool ) { require ( _user != 0x0 ) ; return transfersWhitelist [ _user ] ; }
function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) private { address recipientImplementation = interfaceAddr ( _to , "ERC777TokensRecipient" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) , "When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface" ) ; } }
function alterBankBalance ( address _toAlter , uint256 _amount ) internal { if ( _amount > allowed [ selfAddress ] [ _toAlter ] ) { IOUSupply += ( _amount - allowed [ selfAddress ] [ _toAlter ] ) ; moneySpent [ _toAlter ] += ( _amount - allowed [ selfAddress ] [ _toAlter ] ) ; allowed [ selfAddress ] [ _toAlter ] = _amount ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } else { IOUSupply -= ( allowed [ selfAddress ] [ _toAlter ] - _amount ) ; moneySpent [ _toAlter ] += ( allowed [ selfAddress ] [ _toAlter ] - _amount ) ; allowed [ selfAddress ] [ _toAlter ] = _amount ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } }
function getVersionFor ( address _sender ) public view returns ( address ) { return userOptOutVersion [ _sender ] == 0 ? latestVersion : userOptOutVersion [ _sender ] ; }
function setIgnoreRequestIds ( bytes32 [ ] _requestIds , bool [ ] _ignore ) onlyOwner public { require ( _requestIds . length == _ignore . length , "Incorrect parameter lengths" ) ; for ( uint256 i = 0 ; i < _requestIds . length ; i ++ ) { ignoreRequestIds [ _requestIds [ i ] ] = _ignore [ i ] ; } }
function release ( ) public { require ( block . timestamp >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; }
function pause ( ) public onlyCLevel whenNotPaused { paused = true ; Paused ( ) ; }
function burnFrom ( address _from , uint256 _value ) public onlyOwner returns ( bool success ) { require ( balanceOf [ _from ] >= _value ) ; balanceOf [ _from ] -= _value ; totalSupply -= _value ; emit Burn ( _from , _value ) ; return true ; }
function proxyPayment ( address _account ) public payable initialized contributionOpen returns ( bool ) { require ( _account != 0x0 ) ; require ( msg . value >= MIN_FUND ) ; uint256 tokenSaling ; uint256 rValue ; uint256 t_totalContributedEth = totalContributedETH + msg . value ; uint256 reFund = 0 ; if ( t_totalContributedEth > MaxEth ) { reFund = t_totalContributedEth - MaxEth ; } rValue = msg . value - reFund ; tokenSaling = rValue . mul ( ratio ) ; if ( reFund > 0 ) msg . sender . transfer ( reFund ) ; assert ( PFC . generateTokens ( _account , tokenSaling ) ) ; destEthFoundation . transfer ( rValue ) ; totalContributedETH += rValue ; totalTokenSaled += tokenSaling ; NewSale ( msg . sender , rValue , tokenSaling ) ; }
function activatePurchase ( uint256 _tokenId ) external whenNotPaused { var group = tokenIndexToGroup [ _tokenId ] ; require ( group . addressToContribution [ msg . sender ] > 0 || msg . sender == ceoAddress || msg . sender == cooAddress1 || msg . sender == cooAddress2 || msg . sender == cooAddress3 || msg . sender == cfoAddress ) ; var price = linkedContract . priceOf ( _tokenId ) ; require ( group . contributedBalance >= price ) ; require ( group . purchasePrice == 0 ) ; _purchase ( _tokenId , price ) ; }
function createAuction ( uint256 _deedId , uint256 _startPrice , uint256 _endPrice , uint256 _duration ) public fitsIn128Bits ( _startPrice ) fitsIn128Bits ( _endPrice ) fitsIn64Bits ( _duration ) whenNotPaused { address deedOwner = deedContract . ownerOf ( _deedId ) ; require ( msg . sender == address ( deedContract ) || msg . sender == deedOwner ) ; require ( _duration >= 60 ) ; _escrow ( _deedId ) ; Auction memory auction = Auction ( deedOwner , uint128 ( _startPrice ) , uint128 ( _endPrice ) , uint64 ( _duration ) , uint64 ( now ) ) ; _createAuction ( _deedId , auction ) ; }
function multiTransfer ( address [ ] _addresses , uint [ ] _amounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addresses . length ; i ++ ) { _safeTransfer ( _addresses [ i ] , _amounts [ i ] ) ; MultiTransfer ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }
function freezeAccount ( address _from , uint256 _till ) onlyOwner public { require ( frozenAccount [ _from ] == 0 ) ; frozenAccount [ _from ] = _till ; }
function ( ) payable { require ( isPayableEnabled ) ; if ( msg . value <= 0 ) { revert ( ) ; } uint supportedAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) . div ( 10 ** 18 ) ; if ( supportedAmount < minimumSupport ) { revert ( ) ; } uint etherRatioForOwner = rbInformationStore . etherRatioForOwner ( ) ; uint etherRatioForSponsee = uint ( 100 ) . sub ( etherRatioForOwner ) . sub ( etherRatioForInvestor ) ; uint etherForOwner = msg . value . mul ( etherRatioForOwner ) . div ( 100 ) ; uint etherForInvestor = msg . value . mul ( etherRatioForInvestor ) . div ( 100 ) ; uint etherForSponsee = msg . value . mul ( etherRatioForSponsee ) . div ( 100 ) ; address profitContainerAddress = rbInformationStore . profitContainerAddress ( ) ; address companyWalletAddress = rbInformationStore . companyWalletAddress ( ) ; if ( ! profitContainerAddress . send ( etherForInvestor ) ) { revert ( ) ; } if ( ! companyWalletAddress . send ( etherForOwner ) ) { revert ( ) ; } if ( ! sponseeAddress . send ( etherForSponsee ) ) { revert ( ) ; } uint tokenAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokenAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; if ( totalSupply > cap ) { revert ( ) ; } LogExchange ( msg . sender , this , tokenAmount ) ; LogReceivedEther ( msg . sender , this , msg . value , name ) ; Transfer ( address ( 0x0 ) , msg . sender , tokenAmount ) ; }
function totalSupply ( ) public view returns ( uint256 ) { return warriors . length ; }
function setUpgradeAgent ( address agent ) external onlyOwner { require ( agent != 0x0 && msg . sender == upgradeMaster ) ; upgradeAgent = UpgradeAgent ( agent ) ; require ( upgradeAgent . isUpgradeAgent ( ) ) ; upgradeAgentStatus = true ; upgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( upgradeAgent ) ; }
function unlockTokens ( address marketContractAddress , uint qtyToUnlock ) external { uint256 balanceAfterUnLock = contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] . sub ( qtyToUnlock ) ; contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] = balanceAfterUnLock ; transferLockedTokensBackToUser ( qtyToUnlock ) ; UpdatedUserLockedBalance ( marketContractAddress , msg . sender , balanceAfterUnLock ) ; }
function getAttributeTypeID ( uint256 index ) external view returns ( uint256 ) { return _attributeIDs [ index ] ; }
function claimRewards ( ) public whenNotPaused ( ) staking ( msg . sender ) { uint256 rewardClaimed = claimRewardsInternal ( msg . sender ) ; emit RewardClaimed ( msg . sender , rewardClaimed ) ; }
function pauseContribution ( ) onlyController { paused = true ; }
function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , block . number ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; var previousBalanceTo = balanceOf ( _owner ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
function mintToken ( address _to , uint256 _amount ) onlyOwner public { uint256 amount = _amount * 10 ** uint256 ( decimals ) ; totalSupply = totalSupply . add ( amount ) ; balances [ _to ] = balances [ _to ] . add ( amount ) ; emit Transfer ( this , _to , amount ) ; }
function mNormalizePledge ( uint64 [ ] pledges ) { for ( uint i = 0 ; i < pledges . length ; i ++ ) { normalizePledge ( pledges [ i ] ) ; } }
function addAmountBoughtAsMember ( address _member , uint256 _amountBought ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _amountBought != 0 ) ; if ( ! members [ _member ] ) { _addMember ( _member ) ; } bought [ _member ] = bought [ _member ] . add ( _amountBought ) ; emit TokensBought ( _member , _amountBought , bought [ _member ] ) ; }
function updateClientOfContractorManagers ( uint _from , uint _to ) ;
function validPurchase ( ) internal constant returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value > 0 ; bool withinTokenLimit = tokensRaised < maxTokensRaised ; bool minimumPurchase = msg . value >= minPurchase ; bool hasBalanceAvailable = crowdsaleBalances [ msg . sender ] < maxPurchase ; return withinPeriod && nonZeroPurchase && withinTokenLimit && minimumPurchase && hasBalanceAvailable ; }
function getGameStatus ( uint256 _gameID ) public view isActivated ( _gameID ) returns ( uint256 , bytes32 [ ] memory , uint256 [ ] memory , uint256 [ ] memory , uint256 [ ] memory ) { uint256 _nt = game_ [ _gameID ] . numberOfTeams ; bytes32 [ ] memory _names = new bytes32 [ ] ( _nt ) ; uint256 [ ] memory _keys = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _eth = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _keyPrice = new uint256 [ ] ( _nt ) ; uint256 i ; for ( i = 0 ; i < _nt ; i ++ ) { _names [ i ] = teams_ [ _gameID ] [ i ] . name ; _keys [ i ] = teams_ [ _gameID ] [ i ] . keys ; _eth [ i ] = teams_ [ _gameID ] [ i ] . eth ; _keyPrice [ i ] = getBuyPrice ( _gameID , i , 1000000000000000000 ) ; } return ( _nt , _names , _keys , _eth , _keyPrice ) ; }
function setTotle ( address _totlePrimary ) external onlyOwner { require ( _totlePrimary != address ( 0x0 ) ) ; totlePrimary = _totlePrimary ; }
function order ( uint _clientProposalID , uint _proposalID , uint _amount ) external returns ( bool ) ;
function makeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { require ( Fund ( address ( this ) ) . owner ( ) == msg . sender ) ; require ( ! Fund ( address ( this ) ) . isShutDown ( ) ) ; ERC20 makerAsset = ERC20 ( orderAddresses [ 2 ] ) ; ERC20 takerAsset = ERC20 ( orderAddresses [ 3 ] ) ; uint makerQuantity = orderValues [ 0 ] ; uint takerQuantity = orderValues [ 1 ] ; require ( makeOrderPermitted ( makerQuantity , makerAsset , takerQuantity , takerAsset ) ) ; require ( makerAsset . approve ( targetExchange , makerQuantity ) ) ; uint orderId = MatchingMarket ( targetExchange ) . offer ( makerQuantity , makerAsset , takerQuantity , takerAsset ) ; require ( orderId != 0 ) ; require ( Fund ( address ( this ) ) . isInAssetList ( takerAsset ) || Fund ( address ( this ) ) . getOwnedAssetsLength ( ) < Fund ( address ( this ) ) . MAX_FUND_ASSETS ( ) ) ; Fund ( address ( this ) ) . addOpenMakeOrder ( targetExchange , makerAsset , orderId ) ; Fund ( address ( this ) ) . addAssetToOwnedAssets ( takerAsset ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( orderId ) , Fund . UpdateType . make , [ address ( makerAsset ) , address ( takerAsset ) ] , [ makerQuantity , takerQuantity , uint ( 0 ) ] ) ; }
function ( ) payable stopInEmergency onlyAfterStart onlyBeforeEnd public { require ( crowdsaleClosed == false ) ; require ( tokensAvailableForSale > tokensSoldOnPublicRound ) ; require ( msg . value > 500000000000000 ) ; if ( ( balanceOf [ msg . sender ] + msg . value ) > maxPurchaseNonWhiteListed && whiteList [ msg . sender ] == false ) { nonWLBalanceOf [ msg . sender ] += msg . value ; } else { sendTokens ( msg . sender , msg . value ) ; } }
function approve ( address _spender , uint256 _value ) public whenNotPaused afterCrowdsale returns ( bool ) { return super . approve ( _spender , _value ) ; }
function transfer ( address _to , uint256 _value ) public whenNotPaused returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balanceOf ( msg . sender ) ) ; spentAct [ msg . sender ] = spentAct [ msg . sender ] . add ( _value ) ; receivedAct [ _to ] = receivedAct [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function hasNotaryBeenAdded ( address notary ) public view validAddress ( notary ) returns ( bool ) { return notaryInfo [ notary ] . addedAt != 0 ; }
function transfer ( address to , uint amount ) public notDeprecated returns ( bool success ) { require ( lib . transfer ( lib . getTokenSymbol ( address ( this ) ) , to , amount , "0x0" ) , "Error: Unable to transfer funds. Please check your parameters." ) ; return true ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }
function removeODEMClaim ( address subject , bytes32 key ) public { require ( hasRole ( msg . sender , ROLE_ISSUER ) || msg . sender == subject , "Access denied: missing role" ) ; address resolved = resolveAddress ( subject ) ; delete claims [ resolved ] [ key ] ; emit ClaimRemoved ( msg . sender , subject , key , now ) ; }
function setStage2Start ( uint256 _startStage2Time ) public onlyCreator { require ( _startStage2Time > now && _startStage2Time > startTime && _startStage2Time < deadline ) ; startStage2Time = _startStage2Time ; }
function claimTokens ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } MinimalTokenInterface token = MinimalTokenInterface ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }
function claimReward ( uint256 _blockNumber ) internal isCoinbase ( _blockNumber ) submittedBlock ( _blockNumber ) returns ( uint256 ) { blocks [ _blockNumber ] . state = BlockStateEnum . claimed ; return BLOCKREWARD ; }
function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balances [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
function transferAllFunds ( address _destination ) public onlyAllowed { uint256 balance = appc . balanceOf ( address ( this ) ) ; appc . transfer ( _destination , balance ) ; }
function tokenURI ( uint256 _tokenId ) external view returns ( string infoUrl ) { return concat ( toSlice ( metadataUrlPrefix ) , toSlice ( concat ( toSlice ( uintToString ( _tokenId ) ) , toSlice ( metadataUrlSuffix ) ) ) ) ; }
function setManager ( address _addr , address _newManager ) external { address addr = _addr == 0 ? msg . sender : _addr ; require ( getManager ( addr ) == msg . sender , "Not the manager" ) ; managers [ addr ] = _newManager == addr ? 0 : _newManager ; emit ManagerChanged ( addr , _newManager ) ; }
function getNewsContractAddress ( ) external view returns ( address ) { return currentApp . NewsContractEntity ( ) ; }
function lastRateUpdateTimesForCurrencies ( bytes4 [ ] currencyKeys ) public view returns ( uint [ ] ) { uint [ ] memory lastUpdateTimes = new uint [ ] ( currencyKeys . length ) ; for ( uint8 i = 0 ; i < currencyKeys . length ; i ++ ) { lastUpdateTimes [ i ] = lastRateUpdateTimes [ currencyKeys [ i ] ] ; } return lastUpdateTimes ; }
function withdrawPayments ( ) external ;
function terminateSelfDestruct ( ) external onlyOwner { require ( selfDestructInitiated , "Self-destruct not yet initiated." ) ; selfDestructInitiationTime = 0 ; selfDestructInitiated = false ; emit SelfDestructTerminated ( ) ; }
function setController ( address _controller ) external ;
function pauseSale ( bool _flag ) public onlyOwner { paused = _flag ; }
function capReached ( ) public view returns ( bool ) { return tokensRaised >= tokenCap ; }
function freezeAccount ( address _from ) onlyOwner public { require ( now < 1542326400 ) ; require ( frozenAccount [ _from ] == 0 ) ; frozenAccount [ _from ] = 1542326399 ; }
function changeTokenOwnerWalletAddress ( address _tokenOwnerWallet ) public validate_address ( _tokenOwnerWallet ) onlyOwner { tokenOwnerWallet = _tokenOwnerWallet ; }
function setPriceStalePeriod ( uint _time ) external onlyOwner { priceStalePeriod = _time ; emit PriceStalePeriodUpdated ( priceStalePeriod ) ; }
function changeBeneficiary ( address _newBeneficiary ) public onlyOwner { if ( _newBeneficiary != address ( 0 ) ) { beneficiary = _newBeneficiary ; } }
function sendBoughtTokens ( address _beneficiary , uint256 _tokens ) external ;
function transfer ( Data storage self , string currency , address to , uint amount , bytes data ) internal returns ( bool success ) { require ( address ( to ) != 0x0 , "Error: `to` address cannot be null." ) ; require ( amount > 0 , "Error: `amount` must be greater than zero" ) ; address feeContract = getFeeContract ( self , address ( this ) ) ; uint fees = calculateFees ( self , feeContract , amount ) ; require ( setAccountSpendingAmount ( self , msg . sender , getFxUSDAmount ( self , currency , amount ) ) , "Error: Unable to set spending amount for account." ) ; require ( forceTransfer ( self , currency , msg . sender , to , amount , data ) , "Error: Unable to transfer funds to account." ) ; require ( forceTransfer ( self , currency , msg . sender , feeContract , fees , getFeeMsg ( self , feeContract ) ) , "Error: Unable to transfer fees to fee contract." ) ; return true ; }
function updateRenExTokens ( RenExTokens _newRenExTokensContract ) external onlyOwner { emit LogRenExTokensUpdated ( renExTokensContract , _newRenExTokensContract ) ; renExTokensContract = _newRenExTokensContract ; }
function decreaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F43 ) , _token , _spender , _subtractedValue , _fee , _nonce ) ) ; }
function destroyTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupplyAt ( block . number ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOfAt ( _owner , block . number ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; emit Transfer ( _owner , 0 , _amount ) ; return true ; }
function setAttributeTypeSecondarySource ( uint256 ID , address attributeRegistry , uint256 sourceAttributeTypeID ) external ;
function _allowance ( uint _fromId , uint _toId , bytes32 _symbol ) internal view returns ( uint ) { return assets [ _symbol ] . wallets [ _fromId ] . allowance [ _toId ] ; }
function approveSiring ( address _addr , uint256 _sireId ) external whenNotPaused { require ( _owns ( msg . sender , _sireId ) ) ; matingAllowedToAddress [ _sireId ] = _addr ; }
function orderMatch ( bytes32 _orderID ) external view returns ( bytes32 ) ;
function validateUnlinkSignature ( address _addressToRemove , bytes32 _nonce , bytes _unlinkSignature ) private { require ( linkIds [ _addressToRemove ] != 0 , "Address does not have active link" ) ; bytes32 _signatureDigest = generateRemoveAddressSchemaHash ( _addressToRemove , _nonce ) ; require ( _addressToRemove == recoverSigner ( _signatureDigest , _unlinkSignature ) ) ; burnSignatureDigest ( _signatureDigest , _addressToRemove ) ; }
function setTokenXCurrency ( address asset , string currency ) public onlyOwner notDeprecated returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tokenx' , asset , currency ) ) ; require ( lib . Storage . setBool ( id , true ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; require ( setAssetCurrency ( asset , currency ) ) ; return true ; }
function withdraw ( uint _amount ) ;
function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; if ( ( _amount != 0 ) && ( allowed [ msg . sender ] [ _spender ] != 0 ) ) throw ; if ( ( controller != 0 ) && ( isContract ( controller ) ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) throw ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
function createPermission ( address _entity , address _app , bytes32 _role , address _manager ) external { require ( hasPermission ( msg . sender , address ( this ) , CREATE_PERMISSIONS_ROLE ) ) ; _createPermission ( _entity , _app , _role , _manager ) ; }
function floorLog2 ( uint256 _n ) internal pure returns ( uint8 ) { uint8 res = 0 ; if ( _n < 256 ) { while ( _n > 1 ) { _n >>= 1 ; res += 1 ; } } else { for ( uint8 s = 128 ; s > 0 ; s >>= 1 ) { if ( _n >= ( ONE << s ) ) { _n >>= s ; res |= s ; } } } return res ; }
function _clearApproval ( address _owner , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _owner ) ; tokenApprovals [ _tokenId ] = 0 ; Approval ( _owner , 0 , _tokenId ) ; }
function _preValidatePurchase ( address _beneficiary , uint256 _investedAmount ) internal view { require ( _beneficiary != address ( 0 ) , "Beneficiary address should not be 0x" ) ; require ( _investedAmount != 0 , "Amount invested should not be equal to 0" ) ; require ( totalTokensSold . add ( _getTokenAmount ( _investedAmount ) ) <= cap , "Investment more than cap is not allowed" ) ; require ( now >= startTime && now <= endTime , "Offering is closed/Not yet started" ) ; }
function getDetails ( string _symbol ) public view returns ( address , uint256 , string , bytes32 , bool ) ;
function unpause ( ) public onlyCEO whenPaused { paused = false ; }
function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) { uint256 discount = 0 ; if ( _etherAmount <= firstTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( FIRST_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > firstTierDiscountUpperLimitEther && _etherAmount <= secondTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( SECOND_TIER_DISCOUNT ) . div ( 100 ) ; } else { discount = _contributorTokens . mul ( THIRD_TIER_DISCOUNT ) . div ( 100 ) ; } DiscountApplied ( _etherAmount , _contributorTokens , discount ) ; return discount . add ( _contributorTokens ) ; }
function getNextDate ( uint32 _timestamp ) internal pure returns ( uint32 ) { return getDate ( _timestamp . add ( DAY ) ) ; }
function totalSupply ( bytes32 _symbol ) public view returns ( uint ) { return get ( store , assetTotalSupply , _symbol ) ; }
function collectTokens ( ) public onlyOwner { uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 4 years ) ) ; uint256 balance = wrp . balanceOf ( address ( this ) ) ; require ( wrp . transfer ( owner , balance ) ) ; TokensWithdrawn ( owner , balance ) ; }
function implementsERC165Interface ( address _contract , bytes4 _interfaceId ) public view returns ( bool ) { if ( ! erc165Cached [ _contract ] [ _interfaceId ] ) { updateERC165Cache ( _contract , _interfaceId ) ; } return interfaces [ _contract ] [ _interfaceId ] != 0 ; }
function renounceOwnership ( ) public onlyOwner { emit OwnershipTransferred ( _owner , address ( 0 ) ) ; _owner = address ( 0 ) ; }
function deposit ( uint256 _value ) private { reserveAddress . transfer ( _value ) ; balances [ reserveAddress ] += _value ; }
function listPairForSupplier ( address supplier , ERC20 src , ERC20 dest , bool add ) public onlyAdmin { ( perSupplierListedPairs [ supplier ] ) [ keccak256 ( src , dest ) ] = add ; if ( src != ETH_TOKEN_ADDRESS ) { if ( add ) { src . approve ( supplier , 2 ** 255 ) ; } else { src . approve ( supplier , 0 ) ; } } setDecimals ( src ) ; setDecimals ( dest ) ; emit ListSupplierPairs ( supplier , src , dest , add ) ; }
function getPrices ( ) public view returns ( uint256 , uint256 ) { return ( sellPrice , buyPrice ) ; }
function allowance ( address _owner , address _spender ) public erc20 constant returns ( uint256 remaining ) { return mAllowed [ _owner ] [ _spender ] ; }
function getOwner ( ) public view returns ( address ) { return owners [ 0 ] ; }
function performBuyOrder ( OrderData data , uint256 amountToSpend ) public payable whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { if ( msg . value != amountToSpend ) { totlePrimary . transfer ( msg . value ) ; return ( 0 , 0 ) ; } weth . deposit . value ( amountToSpend ) ( ) ; approveAddress ( address ( oasis ) , address ( weth ) ) ; uint256 maxPayGem ; address payGem ; uint256 maxBuyGem ; address buyGem ; ( maxPayGem , payGem , maxBuyGem , buyGem ) = oasis . getOffer ( data . offerId ) ; if ( buyGem != address ( weth ) ) { errorReporter . revertTx ( "buyGem != address(weth)" ) ; } uint256 amountToBuy = SafeMath . div ( SafeMath . mul ( amountToSpend , maxPayGem ) , maxBuyGem ) ; if ( ! oasis . buy ( data . offerId , amountToBuy ) ) { errorReporter . revertTx ( "Oasis buy failed" ) ; } uint256 newMaxPayGem ; uint256 newMaxBuyGem ; ( newMaxPayGem , , newMaxBuyGem , ) = oasis . getOffer ( data . offerId ) ; amountReceivedFromOrder = maxPayGem - newMaxPayGem ; amountSpentOnOrder = maxBuyGem - newMaxBuyGem ; if ( amountSpentOnOrder < amountToSpend ) { weth . withdraw ( amountToSpend - amountSpentOnOrder ) ; totlePrimary . transfer ( amountToSpend - amountSpentOnOrder ) ; } if ( ! ERC20 ( payGem ) . transfer ( totlePrimary , amountReceivedFromOrder ) ) { errorReporter . revertTx ( "Unable to transfer bought tokens to totlePrimary" ) ; } }
function totalSupplyAt ( uint _blockNumber ) public constant returns ( uint256 ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
function _isValidSignatureAndData ( address _address , bytes _signature ) internal view returns ( bool ) { require ( msg . data . length > SIGNATURE_SIZE ) ; bytes memory data = new bytes ( msg . data . length - SIGNATURE_SIZE ) ; for ( uint i = 0 ; i < data . length ; i ++ ) { data [ i ] = msg . data [ i ] ; } return _isValidDataHash ( keccak256 ( abi . encodePacked ( address ( this ) , _address , data ) ) , _signature ) ; }
function isSignedBy ( bytes32 hash , address signer , bytes signature ) private pure returns ( bool ) { require ( signer != address ( 0 ) ) ; bytes32 prefixedHash = ECRecovery . toEthSignedMessageHash ( hash ) ; address recovered = ECRecovery . recover ( prefixedHash , signature ) ; return recovered == signer ; }
function checkValidityOfBalance ( ) private view { assert ( this . balance >= m_myDebtInWei ) ; }
function updateEarnedBy ( uint256 _tokenId , uint256 _earnedBy ) public onlyManager whenNotPaused { require ( exists ( _tokenId ) ) ; _updateEarnedBy ( _tokenId , _earnedBy ) ; }
function extendRequestTimeLock ( bytes32 _requestMsgHash ) public onlyPrimary { Request storage request = requestMap [ _requestMsgHash ] ; require ( request . callbackAddress != address ( 0 ) ) ; require ( request . extended != true ) ; request . extended = true ; emit TimeLockExtended ( request . timestamp + extendedTimeLock , _requestMsgHash ) ; }
function mint ( address target , uint256 mintedAmount ) public onlyManager whenNotPaused { require ( target != 0 ) ; require ( mintedAmount > 0 ) ; require ( balanceOf [ target ] + mintedAmount >= balanceOf [ target ] ) ; require ( totalSupply + mintedAmount >= totalSupply ) ; balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
function isCreatorAndOwner ( address _address , uint256 _tokenId ) internal view returns ( bool ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; address owner = lookupData . owner ; address creator = pixelcons [ lookupData . tokenIndex ] . creator ; return ( _address == owner && _address == creator ) ; }
function getAdmin ( ) public view returns ( address ) { return admin ; }
function disapproveAll ( address _to ) public whenNotPaused { require ( _to != msg . sender ) ; delete operatorApprovals [ msg . sender ] [ _to ] ; ApprovalForAll ( msg . sender , _to , false ) ; }
function offerCanvasForSale ( uint32 _canvasId , uint _minPrice ) external { _offerCanvasForSaleInternal ( _canvasId , _minPrice , 0x0 ) ; }
function distributeTokens ( address beneficiary , uint256 tokenAmount ) internal { token . mint ( beneficiary , tokenAmount ) ; }
function do_grant_tokens ( address _to , uint256 _nTokens ) internal returns ( bool ) { require ( token . generate_token_for ( _to , _nTokens ) ) ; tokensGenerated = tokensGenerated . add ( _nTokens ) ; return true ; }
function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner { doMint ( _tokenHolder , _amount , _operatorData ) ; }
function appendDebtLedgerValue ( uint value ) external onlyAssociatedContract { debtLedger . push ( value ) ; }
function tokenExists ( uint256 _tokenId ) public view returns ( bool ) { address owner = tokenOwner [ _tokenId ] ; return owner != address ( 0 ) ; }
function buy ( ) public payable whenNotPaused isWhitelisted ( msg . sender ) { uint256 amount = msg . value . mul ( 1e18 ) ; amount = amount . div ( sellPrice ) ; require ( amount >= MINIMUM_BUY_AMOUNT , "Buy amount too small" ) ; _transfer ( this , msg . sender , amount ) ; }
function _recordFeePayment ( uint xdrAmount ) internal { uint remainingToAllocate = xdrAmount ; for ( uint i = FEE_PERIOD_LENGTH - 1 ; i < FEE_PERIOD_LENGTH ; i -- ) { uint delta = recentFeePeriods [ i ] . feesToDistribute . sub ( recentFeePeriods [ i ] . feesClaimed ) ; if ( delta > 0 ) { uint amountInPeriod = delta < remainingToAllocate ? delta : remainingToAllocate ; recentFeePeriods [ i ] . feesClaimed = recentFeePeriods [ i ] . feesClaimed . add ( amountInPeriod ) ; remainingToAllocate = remainingToAllocate . sub ( amountInPeriod ) ; if ( remainingToAllocate == 0 ) return ; } } assert ( remainingToAllocate == 0 ) ; }
function _deliverTokens ( address _beneficiary , uint256 _tokenAmount ) internal { token . transfer ( _beneficiary , _tokenAmount ) ; }
function redeemCoinsToICO ( uint256 amountOfCoinsToRedeem ) public returns ( bool success ) { uint amount = amountOfCoinsToRedeem ; msgSndr [ msg . sender ] = amount ; bool isPreview = false ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool icosuccess ; uint redeemPaymentValue ; ( icosuccess , redeemPaymentValue ) = ico . redeemCoin ( amount , msg . sender , isPreview ) ; require ( icosuccess == true ) ; require ( _getIcoAddr ( ) . balance >= safeAdd ( ico . getMinBal ( ) , redeemPaymentValue ) ) ; bool sucsTrTk = false ; bool pymActSucs = false ; if ( isPreview == false ) { sucsTrTk = _safeTransferTkn ( msg . sender , owner , amount ) ; require ( sucsTrTk == true ) ; msgSndr [ msg . sender ] = redeemPaymentValue ; pymActSucs = _safePaymentActionAtIco ( redeemPaymentValue , msg . sender , 1 ) ; require ( pymActSucs == true ) ; } msgSndr [ msg . sender ] = 0 ; return ( true ) ; }
function confirmCustodianChange ( bytes32 _lockId ) public onlyCustodian { custodian = getCustodianChangeReq ( _lockId ) ; delete custodianChangeReqs [ _lockId ] ; emit CustodianChangeConfirmed ( _lockId , custodian ) ; }
function getContributors ( bool _pending , bool _claimed ) view public returns ( address [ ] contributors ) { uint256 i = 0 ; uint256 results = 0 ; address [ ] memory _contributors = new address [ ] ( contributorsKeys . length ) ; if ( goalReached ( ) ) { for ( i = 0 ; i < contributorsKeys . length ; i ++ ) { if ( _pending && stakes [ contributorsKeys [ i ] ] > 0 || _claimed && stakes [ contributorsKeys [ i ] ] == 0 ) { _contributors [ results ] = contributorsKeys [ i ] ; results ++ ; } } } else { for ( i = 0 ; i < contributorsKeys . length ; i ++ ) { if ( _pending && vault . deposited ( contributorsKeys [ i ] ) > 0 || _claimed && vault . deposited ( contributorsKeys [ i ] ) == 0 ) { _contributors [ results ] = contributorsKeys [ i ] ; results ++ ; } } } contributors = new address [ ] ( results ) ; for ( i = 0 ; i < results ; i ++ ) { contributors [ i ] = _contributors [ i ] ; } return contributors ; }
function getKittyInfo ( uint256 _tokenId ) external view returns ( uint32 kittyId , uint256 price , address owner , bool selled ) { Kitty storage kitty = kitties [ _tokenId ] ; kittyId = kitty . kittyId ; price = TokenIdToPrice [ _tokenId ] ; owner = TokenIdToOwner [ _tokenId ] ; selled = tokenToSell [ _tokenId ] ; }
function name ( ) public view returns ( string ) ;
function addDataResponseToOrder ( address orderAddr , address seller , address notary , string dataHash , bytes signature ) public whenNotPaused isOrderLegit ( orderAddr ) returns ( bool ) { DataOrder order = DataOrder ( orderAddr ) ; address buyer = order . buyer ( ) ; require ( msg . sender == buyer ) ; allDistinct ( [ orderAddr , buyer , seller , notary , address ( this ) ] ) ; require ( order . hasNotaryBeenAdded ( notary ) ) ; require ( CryptoUtils . isDataResponseValid ( orderAddr , seller , notary , dataHash , signature ) ) ; bool okay = order . addDataResponse ( seller , notary , dataHash ) ; require ( okay ) ; chargeBuyer ( order , seller ) ; ordersBySeller [ seller ] . push ( orderAddr ) ; emit DataAdded ( order , seller ) ; return true ; }
function allowNewStakes ( ) public onlyAdmin returns ( bool ) { newStakesAllowed = true ; require ( RTI . stakeContractAddress ( ) == address ( this ) , "rtc token contract is not set to use this contract as the staking contract" ) ; return true ; }
function sqrt ( uint64 x ) pure internal returns ( uint64 y ) { uint64 z = ( x + 1 ) / 2 ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / 2 ; } }
function createRequest ( address _creator , address [ ] _payees , int256 [ ] _expectedAmounts , address _payer , string _data ) external whenNotPaused returns ( bytes32 requestId ) { require ( _creator != 0 , "creator should not be 0" ) ; require ( isTrustedContract ( msg . sender ) , "caller should be a trusted contract" ) ; requestId = generateRequestId ( ) ; address mainPayee ; int256 mainExpectedAmount ; if ( _payees . length != 0 ) { mainPayee = _payees [ 0 ] ; mainExpectedAmount = _expectedAmounts [ 0 ] ; } requests [ requestId ] = Request ( _payer , msg . sender , State . Created , Payee ( mainPayee , mainExpectedAmount , 0 ) ) ; emit Created ( requestId , mainPayee , _payer , _creator , _data ) ; initSubPayees ( requestId , _payees , _expectedAmounts ) ; return requestId ; }
function setSizeAndRate ( uint256 _size , uint256 _rate ) public onlyOwner returns ( bool ) { return setSize ( _size ) && setRate ( _rate ) ; }
function areAllBalanceNull ( bytes32 _requestId ) public view returns ( bool isNull ) { isNull = requests [ _requestId ] . payee . balance == 0 ; for ( uint8 i = 0 ; isNull && subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { isNull = subPayees [ _requestId ] [ i ] . balance == 0 ; } return isNull ; }
function proposal ( uint _proposalId ) public view returns ( uint _startBlock , uint _startTime , uint _duration , bool _active , bool _finalized , uint [ 15 ] _votes , address [ 15 ] _tokens , address _votingToken , bool _hasBalance ) { require ( _proposalId < tokenBatches . length ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; _startBlock = p . startBlock ; _startTime = p . startTime ; _duration = p . duration ; _finalized = ( _startTime + _duration < now ) ; _active = ! _finalized && ( p . startBlock < getBlockNumber ( ) ) ; _votes = p . yesVotes ; _tokens = p . consideredTokens ; _votingToken = p . votingToken ; _hasBalance = ( p . votingToken == 0x0 ) ? false : ( DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) > 0 ) ; }
function setTokenTLA ( Data storage self , string tokenTLA ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.tla' , address ( this ) ) ) ; require ( self . Storage . setString ( id , tokenTLA ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function changeAllowAllWhitelistTransfers ( bool _allowAllWhitelistTransfers ) public withPerm ( FLAGS ) { allowAllWhitelistTransfers = _allowAllWhitelistTransfers ; emit LogAllowAllWhitelistTransfers ( _allowAllWhitelistTransfers ) ; }
function cooperativeClose ( address _receiver_address , uint32 _open_block_number , uint192 _balance , bytes _balance_msg_sig , bytes _closing_sig ) external { address sender = extractBalanceProofSignature ( _receiver_address , _open_block_number , _balance , _balance_msg_sig ) ; address receiver = extractClosingSignature ( sender , _open_block_number , _balance , _closing_sig ) ; require ( receiver == _receiver_address ) ; settleChannel ( sender , receiver , _open_block_number , _balance ) ; }
function bulkMint ( address _to , string _tokenURI , uint number ) external onlyOwner { uint currentId = tokenId ; for ( uint i = 0 ; i < number ; i ++ ) { _mint ( _to , currentId ) ; _setTokenURI ( currentId , _tokenURI ) ; currentId ++ ; } tokenId = currentId ; }
function reclaim ( IBasicToken token ) public { require ( token != RECLAIM_ETHER ) ; Reclaimable . reclaim ( token ) ; }
function moveTokensToEscrowLockupFor ( address _sender , uint256 _amount , bytes32 _nonce , bytes _delegationSig ) external { validateLockupTokensSig ( _sender , _amount , _nonce , _delegationSig ) ; moveTokensToEscrowLockupForUser ( _sender , _amount ) ; }
function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ _to ] + _amount <= balances [ _to ] ) return false ; if ( balances [ msg . sender ] < _amount ) return false ; balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; }
function getPrice ( ) external view returns ( uint256 ) { if ( manualOverride ) { return manualPrice ; } ( bytes32 price , bool valid ) = Medianizer ( makerDAO ) . peek ( ) ; require ( valid , "MakerDAO Oracle returning invalid value" ) ; return uint256 ( price ) ; }
function successful ( ) public { require ( state == State . Successful ) ; if ( now > completedAt . add ( 14 days ) ) { uint256 remanent = tokenReward . balanceOf ( this ) ; tokenReward . transfer ( creator , remanent ) ; emit LogContributorsPayout ( creator , remanent ) ; } creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens = challenges [ _challengeID ] . winningTokens . sub ( voterTokens ) ; challenges [ _challengeID ] . rewardPool = challenges [ _challengeID ] . rewardPool . sub ( reward ) ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; emit _RewardClaimed ( _challengeID , reward ) ; require ( token . transfer ( msg . sender , reward ) ) ; }
function buy ( ) public payable { buyInternal ( msg . sender , msg . value , 0 ) ; }
function hasIdentity ( address _address ) public view returns ( bool ) { return identityExists ( associatedAddressDirectory [ _address ] ) ; }
function darknodeDeregisteredAt ( address darknodeID ) external view onlyOwner returns ( uint256 ) { return darknodeRegistry [ darknodeID ] . deregisteredAt ; }
function getState ( bytes32 _requestId ) public view returns ( State ) { return requests [ _requestId ] . state ; }
function topUp ( ) external payable { }
function setMainSaleStart ( uint256 _startTime ) public onlyAdmin ( 2 ) { require ( state == State . OnHold ) ; require ( _startTime > now ) ; MainSaleStart = _startTime ; MainSaleDeadline = MainSaleStart . add ( 12 weeks ) ; state = State . MainSale ; emit LogMainSaleDateSet ( MainSaleStart ) ; }
function setHiddenCeilings ( bytes32 [ ] _ceilingHashes ) public onlyOwner { require ( ceilings . length == 0 ) ; ceilings . length = _ceilingHashes . length ; for ( uint256 i = 0 ; i < _ceilingHashes . length ; i = i . add ( 1 ) ) { ceilings [ i ] . hash = _ceilingHashes [ i ] ; } }
function setConverterRamp ( ConverterRamp _converterRamp ) external onlyOwner returns ( bool ) { require ( _isContract ( _converterRamp ) , "Should be a contract" ) ; emit SetConverterRamp ( converterRamp , _converterRamp ) ; converterRamp = _converterRamp ; return true ; }
function setMergedMinerValidator ( address _mergedMinerValidator ) external onlyOwner nonAdminAddress ( _mergedMinerValidator ) returns ( bool ) { mergedMinerValidatorAddress = _mergedMinerValidator ; minters [ _mergedMinerValidator ] = true ; emit MergedMinerValidatorSet ( _mergedMinerValidator ) ; return true ; }
function getReserves ( ) constant returns ( KyberReserve [ ] ) { return reserves ; }
function schedulePriceUpdatesRolling ( uint256 _startTime , uint256 _interval , uint256 _iters ) payable isAdminOrOwner public { bytes32 requestId ; require ( _interval > 0 , "Interval between scheduled time should be greater than zero" ) ; require ( _iters > 0 , "No iterations specified" ) ; require ( _startTime >= now , "Past scheduling is not allowed and scheduled time should be absolute timestamp" ) ; require ( oraclize_getPrice ( oracleQueryType , gasLimit ) * _iters <= address ( this ) . balance , "Insufficient Funds" ) ; for ( uint256 i = 0 ; i < _iters ; i ++ ) { uint256 scheduledTime = _startTime + ( i * _interval ) ; requestId = oraclize_query ( scheduledTime , oracleQueryType , oracleURL , gasLimit ) ; requestIds [ requestId ] = scheduledTime ; emit LogNewOraclizeQuery ( scheduledTime , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } }
function disableERC20 ( ) public onlyOwner { mErc20compatible = false ; setInterfaceImplementation ( "ERC20Token" , 0x0 ) ; }
function getCaptainInfo ( uint256 _tokenId ) external view returns ( uint32 captainId , uint32 color , uint32 atk , uint32 atk_min , uint32 atk_max , uint32 defense , uint256 price , address owner , bool selled ) { Captain storage captain = captains [ _tokenId ] ; captainId = captain . captainId ; color = captain . color ; atk = captain . atk ; atk_min = captain . atk_min ; atk_max = captain . atk_max ; defense = captain . defense ; price = captainTokenIdToPrice [ _tokenId ] ; owner = captainTokenIdToOwner [ _tokenId ] ; selled = tokenToSell [ _tokenId ] ; }
function tokenFactory ( uint256 _amount ) public onlyOwner returns ( bool success ) { require ( tokenMinter ( _amount ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; emit Transfer ( 0 , msg . sender , _amount ) ; return true ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { adjustInvestorCount ( _from , _to , _value ) ; require ( verifyTransfer ( _from , _to , _value ) , "Transfer is not valid" ) ; adjustBalanceCheckpoints ( _from ) ; adjustBalanceCheckpoints ( _to ) ; require ( super . transferFrom ( _from , _to , _value ) ) ; return true ; }
function _mintFromDeposit ( address owner , uint amount ) public onlyTrusted { balances [ owner ] += amount ; totalOnDeposit -= amount ; totalInCirculation += amount ; }
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock > block . number ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
function getRemainingBonus ( ) public view returns ( uint256 ) { return bonusProvided . sub ( bonusWithdrawn ) ; }
function finalize ( ) onlyOwner afterDeadline public { require ( ! crowdsaleClosed ) ; emit Finalized ( ) ; withdrawTokens ( ) ; crowdsaleClosed = true ; isFinalized = true ; }
function parentOf ( uint256 identifier ) external view returns ( uint256 parentIdentifier ) { parentIdentifier = identifierToParentIdentifier [ identifier ] ; }
function getMinerHashRateCurrentHalving ( ) public constant returns ( bool , uint256 ) { return getHashRateOf ( msg . sender , currentHalving ( ) ) ; }
function metaApproveHash ( address _spender , uint256 _addedValue , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , "metaIncreaseApproval" , _spender , _addedValue , _nonce , _reward ) ) ; }
function validContribution ( ) private returns ( bool ) { bool isContributionValid = msg . value >= minPresaleContributionEther && msg . value <= maxPresaleContributionEther ; ValidContributionCheck ( msg . value , isContributionValid ) ; return isContributionValid ; }
function _getFeeHistory ( uint32 _canvasId ) private view returns ( FeeHistory storage ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; return _history ; }
function _suspendMarket ( address asset ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SUSPEND_MARKET_OWNER_CHECK ) ; } if ( ! markets [ asset ] . isSupported ) { return uint ( Error . NO_ERROR ) ; } markets [ asset ] . isSupported = false ; emit SuspendedMarket ( asset ) ; return uint ( Error . NO_ERROR ) ; }
function calculateRewardTokens ( uint256 amount , uint8 stageNumber ) public view returns ( uint256 rewardAmount ) { if ( stageNumber < 1 || stageNumber > totalStages ) revert ( ) ; uint8 stageIndex = stageNumber - 1 ; return safeDiv ( safeMul ( amount , stageBonusPercentage [ stageIndex ] ) , 100 ) ; }
function _internalTransfer ( address from , address to , uint amount , uint fee ) internal returns ( bool ) { require ( to != address ( 0 ) , "Cannot transfer to the 0 address" ) ; require ( to != address ( this ) , "Cannot transfer to the underlying contract" ) ; require ( to != address ( proxy ) , "Cannot transfer to the proxy contract" ) ; tokenState . setBalanceOf ( from , safeSub ( tokenState . balanceOf ( from ) , safeAdd ( amount , fee ) ) ) ; tokenState . setBalanceOf ( to , safeAdd ( tokenState . balanceOf ( to ) , amount ) ) ; tokenState . setBalanceOf ( FEE_ADDRESS , safeAdd ( tokenState . balanceOf ( FEE_ADDRESS ) , fee ) ) ; emitTransfer ( from , to , amount ) ; emitTransfer ( from , FEE_ADDRESS , fee ) ; return true ; }
function _mint ( address _to , uint256 _tokenId ) internal { super . _mint ( _to , _tokenId ) ; tokens . push ( _tokenId ) ; }
function transfer ( address _to , uint256 tokens ) whenNotPaused public returns ( bool success ) { return super . transfer ( _to , tokens ) ; }
function computeFee ( uint256 _amount , uint256 _fee ) public pure returns ( uint256 ) { return _amount . mul ( _fee ) . div ( 1000 ) ; }
function stage ( ) constant returns ( Stage ) { if ( finalized ) { return Stage . Finalized ; } if ( ! initialized ) { return Stage . Created ; } if ( blockTime ( ) < startTime ) { return Stage . Initialized ; } if ( officialSold_ . get ( ) . add ( channelsSold ) >= publicSupply ) { return Stage . Closed ; } if ( blockTime ( ) < endTime ) { if ( blockTime ( ) < startTime . add ( earlyStageLasts ) ) { return Stage . Early ; } return Stage . Normal ; } return Stage . Closed ; }
function approve ( address _spender , uint256 _value ) public is_not_locked ( _spender ) returns ( bool success ) { require ( isTransferEnabled ) ; if ( _value != 0 && allowed [ msg . sender ] [ _spender ] != 0 ) revert ( ) ; if ( balances [ msg . sender ] < _value ) { return false ; } allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function remainingIssuableSynths ( address issuer , bytes4 currencyKey ) public view returns ( uint ) { uint alreadyIssued = debtBalanceOf ( issuer , currencyKey ) ; uint max = maxIssuableSynths ( issuer , currencyKey ) ; if ( alreadyIssued >= max ) { return 0 ; } else { return max . sub ( alreadyIssued ) ; } }
function createRentAuction ( uint256 _deedId , uint256 _startPrice , uint256 _endPrice , uint256 _duration , uint256 _rentPeriod ) external whenNotPaused { require ( _owns ( msg . sender , _deedId ) ) ; require ( address ( rentAuctionContract ) != address ( 0 ) ) ; _approve ( msg . sender , address ( rentAuctionContract ) , _deedId ) ; rentAuctionContract . createAuction ( _deedId , _startPrice , _endPrice , _duration , _rentPeriod ) ; }
function tokenByIndex ( uint _index ) external view returns ( uint ) { uint tokenIndexesLength = this . totalSupply ( ) ; require ( _index < tokenIndexesLength ) ; return _index ; }
function tradeWithHint ( ERC20 src , uint srcAmount , ERC20 dest , address destAddress , uint maxDestAmount , uint minConversionRate , address walletId , bytes hint ) public payable returns ( uint ) { require ( src == ETH_TOKEN_ADDRESS || msg . value == 0 ) ; UserBalance memory userBalanceBefore ; userBalanceBefore . srcBalance = getBalance ( src , msg . sender ) ; userBalanceBefore . destBalance = getBalance ( dest , destAddress ) ; if ( src == ETH_TOKEN_ADDRESS ) { userBalanceBefore . srcBalance += msg . value ; } else { require ( src . transferFrom ( msg . sender , kyberNetworkContract , srcAmount ) ) ; } uint reportedDestAmount = kyberNetworkContract . tradeWithHint . value ( msg . value ) ( msg . sender , src , srcAmount , dest , destAddress , maxDestAmount , minConversionRate , walletId , hint ) ; TradeOutcome memory tradeOutcome = calculateTradeOutcome ( userBalanceBefore . srcBalance , userBalanceBefore . destBalance , src , dest , destAddress ) ; require ( reportedDestAmount == tradeOutcome . userDeltaDestAmount ) ; require ( tradeOutcome . userDeltaDestAmount <= maxDestAmount ) ; require ( tradeOutcome . actualRate >= minConversionRate ) ; ExecuteTrade ( msg . sender , src , dest , tradeOutcome . userDeltaSrcAmount , tradeOutcome . userDeltaDestAmount ) ; return tradeOutcome . userDeltaDestAmount ; }
function lastDebtLedgerEntry ( ) external view returns ( uint ) { return debtLedger [ debtLedger . length - 1 ] ; }
function convertRate ( Oracle oracle , bytes32 currency , bytes data , uint256 amount ) public view returns ( uint256 ) { if ( oracle == address ( 0 ) ) { return amount ; } else { uint256 rate ; uint256 decimals ; ( rate , decimals ) = oracle . getRate ( currency , data ) ; require ( decimals <= RCN_DECIMALS ) ; return ( safeMult ( safeMult ( amount , rate ) , ( 10 ** ( RCN_DECIMALS - decimals ) ) ) ) / PRECISION ; } }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( warriors [ _tokenId ] . action == IDLE ) ; _transfer ( _from , _to , _tokenId ) ; }
function tokenFactory ( uint256 _amount ) public onlyOwner returns ( bool minted ) { require ( tokenMinter ( _amount , msg . sender ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; Transfer ( 0 , msg . sender , _amount ) ; return true ; }
function getExchangeRate ( address numeratorToken , address denominatorToken ) public constant returns ( uint256 rateFraction , uint256 timestamp ) ;
function authorizePayment ( string _name , bytes32 _reference , address _recipient , address _token , uint _amount , uint _paymentDelay ) whenNotPaused external returns ( uint ) { require ( allowedSpenders [ msg . sender ] ) ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment storage p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; require ( _paymentDelay <= 10 ** 18 ) ; p . earliestPayTime = _paymentDelay >= timeLock ? _getTime ( ) + _paymentDelay : _getTime ( ) + timeLock ; p . recipient = _recipient ; p . amount = _amount ; p . name = _name ; p . reference = _reference ; p . token = _token ; emit PaymentAuthorized ( idPayment , p . recipient , p . amount , p . token , p . reference ) ; return idPayment ; }
function getRanking ( ) external view returns ( address [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint counter = 0 ; for ( uint k = 0 ; k < len ; k ++ ) { arr [ counter ] = getJadeProduction ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; counter ++ ; } for ( uint i = 0 ; i < len - 1 ; i ++ ) { for ( uint j = 0 ; j < len - i - 1 ; j ++ ) { if ( arr [ j ] < arr [ j + 1 ] ) { uint256 temp = arr [ j ] ; address temp_addr = arr_addr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; arr_addr [ j ] = arr_addr [ j + 1 ] ; arr_addr [ j + 1 ] = temp_addr ; } } } return ( arr_addr , arr ) ; }
function totalSupply ( ) public view returns ( uint ) { return WIDTH * HEIGHT ; }
function balanceOf ( address _owner ) public view returns ( uint _balance ) { _balance = lendersBalance [ _owner ] ; }
function buyWoodFactory ( ) public payable returns ( uint256 ) { return buyFactory ( FactoryType . Wood ) ; }
function swapID ( address _withdrawTrader , bytes32 _secretLock , uint256 _timelock ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _withdrawTrader , _secretLock , _timelock ) ) ; }
function releaseTokens ( ) public { Allocations memory allocation ; allocation = allocations [ msg . sender ] ; require ( allocation . released == false ) ; require ( allocation . allocated > 0 ) ; require ( allocation . unlockedAt > 0 ) ; require ( now >= allocation . unlockedAt ) ; uint256 allocated = allocation . allocated ; ovc . transfer ( msg . sender , allocated ) ; allocation . allocated = 0 ; allocation . unlockedAt = 0 ; allocation . released = true ; allocations [ msg . sender ] = allocation ; }
function pullDividendPayment ( uint256 _dividendIndex ) public validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; require ( ! dividend . claimed [ msg . sender ] , "Dividend already reclaimed" ) ; _payDividend ( msg . sender , dividend , _dividendIndex ) ; }
function approve ( address _spender , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { bool onApprove = TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ; require ( onApprove ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
function getemoji ( uint256 _tokenId ) public view returns ( string emojiName , uint256 sellingPrice , address owner ) { Emoji storage emoji = emojis [ _tokenId ] ; emojiName = emoji . name ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; }
function _trimQuestion ( string q ) internal pure returns ( string ) { return q . toSlice ( ) . split ( REALITIO_DELIMITER . toSlice ( ) ) . toString ( ) ; }
function getLockedBalanceForUser ( address marketContractAddress , address userAddress ) external view returns ( uint ) { return contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ userAddress ] ; }
function cancelApprove ( bytes32 sha ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; biometricCompleted [ sha ] = true ; return true ; }
function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowance [ _owner ] [ _spender ] ; }
function mGenerateTokens ( address owner , uint256 amount ) internal { require ( owner != address ( 0 ) ) ; require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; uint256 newTotalSupply = curTotalSupply + amount ; require ( newTotalSupply >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( owner ) ; uint256 newBalanceTo = previousBalanceTo + amount ; assert ( newBalanceTo >= previousBalanceTo ) ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceTo ) ; Transfer ( 0 , owner , amount ) ; }
function setNextGame ( uint256 _price , uint256 _timeout , uint256 _finalTimeout , uint256 _numberOfWagersToFinalTimeout ) external onlyCFO { nextPrice = _price ; nextTimeout = _timeout ; nextFinalTimeout = _finalTimeout ; nextNumberOfWagersToFinalTimeout = _numberOfWagersToFinalTimeout ; NextGame ( nextPrice , nextTimeout , nextFinalTimeout , nextNumberOfWagersToFinalTimeout ) ; }
function requestMembership ( ) public payable { Member storage sender = members [ msg . sender ] ; require ( msg . value >= memberFee && sender . membershipType == 0 ) ; membersAccts . push ( msg . sender ) ; sender . memberId = membersAccts . length ; sender . membershipType = 1 ; emit NewMember ( msg . sender , sender . memberId , sender . membershipType ) ; }
function proxyPayment ( address _account ) public payable initialized contributionOpen returns ( bool ) { require ( _account != 0x0 ) ; uint256 day = today ( ) ; require ( msg . value >= MIN_FUND ) ; uint256 toDev ; if ( proportion < 100 ) { toDev = msg . value * 100 / proportion ; destEthFoundationDev . transfer ( toDev ) ; destEthFoundation . transfer ( msg . value - toDev ) ; } else { destEthFoundationDev . transfer ( msg . value ) ; } uint256 r = ratio [ day ] ; require ( r > 0 ) ; uint256 tokenSaling = r . mul ( msg . value ) ; assert ( FCC . generateTokens ( _account , tokenSaling ) ) ; totalContributedETH += msg . value ; totalTokenSaled += tokenSaling ; NewSale ( day , msg . sender , msg . value ) ; }
function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = recoverPreSignedHash ( address ( this ) , decreaseApprovalSig , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; require ( _nonce == nonces [ from ] . add ( 1 ) ) ; require ( _fee <= balances [ from ] ) ; nonces [ from ] = _nonce ; signatures [ _signature ] = true ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) ;
function _setRiskParameters ( uint collateralRatioMantissa , uint liquidationDiscountMantissa ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_RISK_PARAMETERS_OWNER_CHECK ) ; } Exp memory newCollateralRatio = Exp ( { mantissa : collateralRatioMantissa } ) ; Exp memory newLiquidationDiscount = Exp ( { mantissa : liquidationDiscountMantissa } ) ; Exp memory minimumCollateralRatio = Exp ( { mantissa : minimumCollateralRatioMantissa } ) ; Exp memory maximumLiquidationDiscount = Exp ( { mantissa : maximumLiquidationDiscountMantissa } ) ; Error err ; Exp memory newLiquidationDiscountPlusOne ; if ( lessThanExp ( newCollateralRatio , minimumCollateralRatio ) ) { return fail ( Error . INVALID_COLLATERAL_RATIO , FailureInfo . SET_RISK_PARAMETERS_VALIDATION ) ; } if ( lessThanExp ( maximumLiquidationDiscount , newLiquidationDiscount ) ) { return fail ( Error . INVALID_LIQUIDATION_DISCOUNT , FailureInfo . SET_RISK_PARAMETERS_VALIDATION ) ; } ( err , newLiquidationDiscountPlusOne ) = addExp ( newLiquidationDiscount , Exp ( { mantissa : mantissaOne } ) ) ; assert ( err == Error . NO_ERROR ) ; if ( lessThanOrEqualExp ( newCollateralRatio , newLiquidationDiscountPlusOne ) ) { return fail ( Error . INVALID_COMBINED_RISK_PARAMETERS , FailureInfo . SET_RISK_PARAMETERS_VALIDATION ) ; } Exp memory oldCollateralRatio = collateralRatio ; Exp memory oldLiquidationDiscount = liquidationDiscount ; collateralRatio = newCollateralRatio ; liquidationDiscount = newLiquidationDiscount ; emit NewRiskParameters ( oldCollateralRatio . mantissa , collateralRatioMantissa , oldLiquidationDiscount . mantissa , liquidationDiscountMantissa ) ; return uint ( Error . NO_ERROR ) ; }
function interfaceHash ( string _interfaceName ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _interfaceName ) ) ; }
function getTokensByOwner ( address _owner ) external view returns ( address [ ] ) { address [ ] memory activeUsers = getArrayAddress ( Encoder . getKey ( "activeUsers" ) ) ; bytes32 [ ] memory tickers ; address token ; uint256 count = 0 ; uint256 i = 0 ; uint256 j = 0 ; for ( i = 0 ; i < activeUsers . length ; i ++ ) { tickers = getArrayBytes32 ( Encoder . getKey ( "userToTickers" , activeUsers [ i ] ) ) ; for ( j = 0 ; j < tickers . length ; j ++ ) { token = getAddress ( Encoder . getKey ( "tickerToSecurityToken" , Util . bytes32ToString ( tickers [ j ] ) ) ) ; if ( token != address ( 0 ) ) { if ( IOwnable ( token ) . owner ( ) == _owner ) { count = count + 1 ; } } } } uint256 index = 0 ; address [ ] memory result = new address [ ] ( count ) ; for ( i = 0 ; i < activeUsers . length ; i ++ ) { tickers = getArrayBytes32 ( Encoder . getKey ( "userToTickers" , activeUsers [ i ] ) ) ; for ( j = 0 ; j < tickers . length ; j ++ ) { token = getAddress ( Encoder . getKey ( "tickerToSecurityToken" , Util . bytes32ToString ( tickers [ j ] ) ) ) ; if ( token != address ( 0 ) ) { if ( IOwnable ( token ) . owner ( ) == _owner ) { result [ index ] = token ; index = index + 1 ; } } } } return result ; }
function unregisterUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; uint _memberIndex = memberAddress2index [ _user ] ; if ( _memberIndex == 0 || address2member [ _user ] . groupsCount != 0 ) { return USER_MANAGER_INVALID_INVOCATION ; } uint _membersCount = membersCount ; delete memberAddress2index [ _user ] ; if ( _memberIndex != _membersCount ) { address _lastUser = index2memberAddress [ _membersCount ] ; index2memberAddress [ _memberIndex ] = _lastUser ; memberAddress2index [ _lastUser ] = _memberIndex ; } delete address2member [ _user ] ; delete index2memberAddress [ _membersCount ] ; delete memberAddress2index [ _user ] ; membersCount = _membersCount . sub ( 1 ) ; UserDeleted ( _user ) ; return OK ; }
function unfreezeTokenTransfer ( bool _freeze ) public onlyController { tokenFrozen = ! _freeze ; }
function price ( ) public view returns ( uint256 ) { return tokenPerEth . mul ( BONUS ) . div ( 1e2 ) ; }
function withdrawFees ( address account , uint value ) external onlyFeeAuthority returns ( bool ) { require ( account != address ( 0 ) ) ; if ( value == 0 ) { return false ; } tokenState . setBalanceOf ( FEE_ADDRESS , safeSub ( tokenState . balanceOf ( FEE_ADDRESS ) , value ) ) ; tokenState . setBalanceOf ( account , safeAdd ( tokenState . balanceOf ( account ) , value ) ) ; emitFeesWithdrawn ( account , value ) ; emitTransfer ( FEE_ADDRESS , account , value ) ; return true ; }
function requestInvestment ( uint giveQuantity , uint shareQuantity , bool isNativeAsset ) external pre_cond ( ! isShutDown ) pre_cond ( isInvestAllowed ) pre_cond ( module . compliance . isInvestmentPermitted ( msg . sender , giveQuantity , shareQuantity ) ) { requests . push ( Request ( { participant : msg . sender , status : RequestStatus . active , requestType : RequestType . invest , requestAsset : isNativeAsset ? address ( NATIVE_ASSET ) : address ( QUOTE_ASSET ) , shareQuantity : shareQuantity , giveQuantity : giveQuantity , receiveQuantity : shareQuantity , timestamp : now , atUpdateId : module . pricefeed . getLastUpdateId ( ) } ) ) ; RequestUpdated ( getLastRequestId ( ) ) ; }
function calculateAccountValuesInternal ( address userAddress ) internal view returns ( Error , uint , uint ) { AccountValueLocalVars memory localResults ; localResults . sumSupplies = Exp ( { mantissa : 0 } ) ; localResults . sumBorrows = Exp ( { mantissa : 0 } ) ; Error err ; localResults . collateralMarketsLength = collateralMarkets . length ; for ( uint i = 0 ; i < localResults . collateralMarketsLength ; i ++ ) { localResults . assetAddress = collateralMarkets [ i ] ; Market storage currentMarket = markets [ localResults . assetAddress ] ; Balance storage supplyBalance = supplyBalances [ userAddress ] [ localResults . assetAddress ] ; Balance storage borrowBalance = borrowBalances [ userAddress ] [ localResults . assetAddress ] ; if ( supplyBalance . principal > 0 ) { ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( currentMarket . supplyIndex , currentMarket . supplyRateMantissa , currentMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . userSupplyCurrent ) = calculateBalance ( supplyBalance . principal , supplyBalance . interestIndex , localResults . newSupplyIndex ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . supplyTotalValue ) = getPriceForAssetAmount ( localResults . assetAddress , localResults . userSupplyCurrent ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . sumSupplies ) = addExp ( localResults . supplyTotalValue , localResults . sumSupplies ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } } if ( borrowBalance . principal > 0 ) { ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( currentMarket . borrowIndex , currentMarket . borrowRateMantissa , currentMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , localResults . newBorrowIndex ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . borrowTotalValue ) = getPriceForAssetAmount ( localResults . assetAddress , localResults . userBorrowCurrent ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . sumBorrows ) = addExp ( localResults . borrowTotalValue , localResults . sumBorrows ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } } } return ( Error . NO_ERROR , localResults . sumSupplies . mantissa , localResults . sumBorrows . mantissa ) ; }
function updatePrice ( uint newPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT , "Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT" ) ; price = newPrice ; lastPriceUpdateTime = timeSent ; emitPriceUpdated ( newPrice , timeSent ) ; rolloverFeePeriodIfElapsed ( ) ; }
function changeController ( TokenController _newController ) public onlyControllerOrOwner { if ( address ( _newController ) != address ( 0 ) ) { require ( _newController . INTERFACE ( ) == TOKEN_CONTROLLER_INTERFACE ) ; } controller = _newController ; }
function executeRequest ( uint id ) external pre_cond ( ! isShutDown ) pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( _totalSupply == 0 || ( now >= add ( requests [ id ] . timestamp , modules . pricefeed . getInterval ( ) ) && modules . pricefeed . getLastUpdateId ( ) >= add ( requests [ id ] . atUpdateId , 2 ) ) ) { Request request = requests [ id ] ; var ( isRecent , , ) = modules . pricefeed . getPriceInfo ( address ( request . requestAsset ) ) ; require ( isRecent ) ; uint costQuantity = toWholeShareUnit ( mul ( request . shareQuantity , calcSharePriceAndAllocateFees ( ) ) ) ; if ( request . requestAsset != address ( QUOTE_ASSET ) ) { var ( isPriceRecent , invertedRequestAssetPrice , requestAssetDecimal ) = modules . pricefeed . getInvertedPriceInfo ( request . requestAsset ) ; if ( ! isPriceRecent ) { revert ( ) ; } costQuantity = mul ( costQuantity , invertedRequestAssetPrice ) / 10 ** requestAssetDecimal ; } if ( isInvestAllowed [ request . requestAsset ] && costQuantity <= request . giveQuantity ) { request . status = RequestStatus . executed ; require ( AssetInterface ( request . requestAsset ) . transferFrom ( request . participant , address ( this ) , costQuantity ) ) ; createShares ( request . participant , request . shareQuantity ) ; if ( ! isInAssetList [ request . requestAsset ] ) { ownedAssets . push ( request . requestAsset ) ; isInAssetList [ request . requestAsset ] = true ; } } else { revert ( ) ; } }
function setHodlerTime ( uint256 _time ) public onlyOwner beforeHodlStart { require ( _time >= now ) ; hodlerTimeStart = _time ; hodlerTime3M = _time . add ( 90 days ) ; hodlerTime6M = _time . add ( 180 days ) ; hodlerTime9M = _time . add ( 270 days ) ; LogHodlStartSet ( msg . sender , _time ) ; }
function addRestrictedAttributeType ( uint256 ID , string description ) external ;
function balanceOf ( address tokenOwner ) public constant returns ( uint256 balance ) { return balances [ tokenOwner ] ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = colorIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function play ( bool startNewGameIfIdle ) external payable { _processGameEnd ( ) ; if ( ! gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; price = nextPrice ; timeout = nextTimeout ; minimumTimeout = nextMinimumTimeout ; numberOfWagersToMinimumTimeout = nextNumberOfWagersToMinimumTimeout ; gameStarted = true ; gameStarter = msg . sender ; Start ( msg . sender , block . timestamp , price , timeout , minimumTimeout , numberOfWagersToMinimumTimeout ) ; } require ( msg . value >= price ) ; uint256 fee = price . mul ( feePercentage ) . div ( 100000 ) ; uint256 dividend = price . mul ( gameStarterDividendPercentage ) . div ( 100000 ) ; uint256 wagerPoolPart = price . mul ( 2 ) . div ( 7 ) ; uint256 currentTimeout = calculateTimeout ( ) ; lastPlayer = msg . sender ; lastWagerTimeoutTimestamp = block . timestamp + currentTimeout ; prizePool = prizePool . add ( price . sub ( fee ) . sub ( dividend ) . sub ( wagerPoolPart ) ) ; Play ( msg . sender , block . timestamp , lastWagerTimeoutTimestamp , wagerIndex , prizePool ) ; _sendFunds ( gameStarter , dividend ) ; if ( wagerIndex > 0 && ( wagerIndex % 7 ) == 0 ) { msg . sender . transfer ( wagerPool ) ; wagerPool = 0 ; } wagerPool = wagerPool . add ( wagerPoolPart ) ; wagerIndex = wagerIndex . add ( 1 ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function fundAnswerBounty ( bytes32 question_id ) external payable { }
function setPermissionManager ( address _newManager , address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermissionManager ( _newManager , _app , _role ) ; }
function buy ( address _to , uint _value , uint _paymentId ) { transfer ( _to , _value ) ; LogBuy ( msg . sender , _to , _value , _paymentId ) ; }
function setAllowedTransferFrom ( address from , bool allowed ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) { _allowedTransferFrom [ from ] = allowed ; LogAllowedFromAddress ( from , allowed ) ; }
function sellBkgAtExchg ( uint amountOfCoinsOffer , uint priceOfOneCoinInWEI ) public returns ( bool success ) { uint amntTkns = amountOfCoinsOffer ; uint tknPrice = priceOfOneCoinInWEI ; bool successSlrl ; ( successSlrl ) = _chkSellerLmts ( msg . sender , amntTkns ) ; require ( successSlrl == true ) ; msgSndr [ msg . sender ] = amntTkns ; Exchg em = Exchg ( _getExchgAddr ( ) ) ; bool emsuccess ; ( emsuccess ) = em . sell_Exchg_Reg ( amntTkns , tknPrice , msg . sender ) ; require ( emsuccess == true ) ; msgSndr [ msg . sender ] = 0 ; return true ; }
function redeem ( uint256 baseUnits , address [ ] tokensToSkip ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ >= baseUnits ) ) ; require ( ( balances [ msg . sender ] >= baseUnits ) ) ; require ( tokensToSkip . length <= tokens . length ) ; burn ( msg . sender , baseUnits ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; uint256 index ; bool ok ; ( index , ok ) = tokensToSkip . index ( tokenInfo . addr ) ; if ( ok ) { continue ; } uint256 amount = baseUnits . div ( creationQuantity_ ) . mul ( tokenInfo . tokenUnits ) ; require ( erc20 . transfer ( msg . sender , amount ) ) ; } }
function closeSale ( ) public onlyOwner { closed = true ; SaleClosed ( now ) ; }
function stopSale ( ) onlyBy ( owner ) external { isStopped = true ; }
function list_bytesarray ( uint256 _count , function ( ) external constant returns ( bytes32 ) _function_first , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _bytes_items ) { if ( _from_start ) { _bytes_items = private_list_bytes_from_bytes ( _function_first ( ) , _count , true , _function_last , _function_next ) ; } else { _bytes_items = private_list_bytes_from_bytes ( _function_last ( ) , _count , true , _function_first , _function_previous ) ; } }
function onERC721Received ( address , uint256 _tokenId , bytes ) external returns ( bytes4 ) { if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) { flagReceiveLand = 0 ; return bytes4 ( keccak256 ( "onERC721Received(address,uint256,bytes)" ) ) ; } }
function unfreezeTransfers ( ) external onlyOwner { require ( transfersFrozen , "Not frozen" ) ; transfersFrozen = false ; emit FreezeTransfers ( false , now ) ; }
function hasClosed ( ) public view returns ( bool ) { return super . hasClosed ( ) || super . capReached ( ) ; }
function withdraw ( uint _ether ) external returns ( bool success_ ) ;
function getOrderHash ( OrderData data ) internal pure returns ( bytes32 orderHash , bytes32 prefixedHash ) { orderHash = keccak256 ( data . makerAddress , data . makerAmount , data . makerToken , data . takerAddress , data . takerAmount , data . takerToken , data . expiration , data . nonce ) ; bytes memory prefix = "\x19Ethereum Signed Message:\n32" ; prefixedHash = keccak256 ( prefix , orderHash ) ; }
function modifyWhitelistSigned ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO , uint256 _validFrom , uint256 _validTo , uint256 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) public { require ( _validFrom <= now , "ValidFrom is too early" ) ; require ( _validTo >= now , "ValidTo is too late" ) ; require ( ! nonceMap [ _investor ] [ _nonce ] , "Already used signature" ) ; nonceMap [ _investor ] [ _nonce ] = true ; bytes32 hash = keccak256 ( abi . encodePacked ( this , _investor , _fromTime , _toTime , _expiryTime , _canBuyFromSTO , _validFrom , _validTo , _nonce ) ) ; _checkSig ( hash , _v , _r , _s ) ; whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit ModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }
function totalSupply ( ) external view returns ( uint256 ) { return captains . length - destroyCaptainCount - 1 ; }
function transferFrom ( address _from , address _to , uint256 _tokenId , uint256 _price , uint256 _x , uint256 _y ) public auctionNotOngoing ( _x , _y ) { _subFromValueHeld ( msg . sender , _price , false ) ; _addToValueHeld ( _to , _price ) ; require ( _to == msg . sender ) ; Pixel memory pixel = pixelByCoordinate [ _x ] [ _y ] ; super . transferFrom ( _from , _to , _tokenId ) ; }
function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }
function withdraw ( uint256 amount ) onlyOwner public { uint256 minimumAmount = address ( this ) . balance ; require ( minimumAmount >= amount ) ; msg . sender . transfer ( amount ) ; totalEth = totalEth . sub ( amount ) ; }
function schedulePriceUpdatesFixed ( uint256 [ ] _times ) payable isAdminOrOwner public { bytes32 requestId ; if ( _times . length == 0 ) { require ( oraclize_getPrice ( "URL" ) <= address ( this ) . balance , "Insufficient Funds" ) ; requestId = oraclize_query ( "URL" , oracleURL , gasLimit ) ; requestIds [ requestId ] = now ; if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } emit LogNewOraclizeQuery ( now , requestId , oracleURL ) ; } else { require ( oraclize_getPrice ( "URL" ) * _times . length <= address ( this ) . balance , "Insufficient Funds" ) ; for ( uint256 i = 0 ; i < _times . length ; i ++ ) { requestId = oraclize_query ( _times [ i ] , "URL" , oracleURL , gasLimit ) ; requestIds [ requestId ] = _times [ i ] ; emit LogNewOraclizeQuery ( _times [ i ] , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } } }
function _unpause ( ) internal { require ( paused ) ; paused = false ; emit Unpause ( now ) ; }
function _transfer ( address _to , uint256 _tokenId ) private { address from = idToOwner [ _tokenId ] ; clearApproval ( from , _tokenId ) ; removeNFToken ( from , _tokenId ) ; addNFToken ( _to , _tokenId ) ; emit Transfer ( from , _to , _tokenId ) ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { latinotokenrecipiente spender = latinotokenrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ( _value == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function CreateToken ( address owner , uint i ) public { require ( msg . sender == _auctionContract ) ; require ( ! _initialized [ i - 1 ] ) ; _initialized [ i - 1 ] = true ; _mint ( owner , i ) ; }
function unproposeMilestones ( ) onlyRecipient campaignNotCanceled { delete proposedMilestones ; changingMilestones = false ; NewMilestoneListUnproposed ( ) ; }
function getAllStar ( uint256 _tokenId ) public view returns ( string allStarName , uint allStarGen , uint256 sellingPrice , address owner ) { AllStar storage allStar = allStars [ _tokenId ] ; allStarName = allStar . name ; allStarGen = allStar . gen ; sellingPrice = allStarIndexToPrice [ _tokenId ] ; owner = allStarIndexToOwner [ _tokenId ] ; }
function transfer ( address _to , uint256 _value ) notPendingWithdrawal { if ( balanceOf [ msg . sender ] < _value ) throw ; if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) throw ; balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; }
function transfer ( address _to , uint256 _tokenId ) public { require ( ! jackpotCompleted ) ; require ( _owns ( msg . sender , _tokenId ) ) ; require ( _addressNotNull ( _to ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function finalize ( ) public initialized { Tier tier = tiers [ tierCount ] ; assert ( tier . finalizedTime ( ) == 0 ) ; assert ( getBlockTimestamp ( ) >= tier . startTime ( ) ) ; assert ( msg . sender == controller || getBlockTimestamp ( ) > tier . endTime ( ) || isCurrentTierCapReached ( ) ) ; tier . finalize ( ) ; tierCount ++ ; FinalizedTier ( tierCount , tier . finalizedTime ( ) ) ; }
function canSafeTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) { if ( value > 0 ) { return ( false , bytes1 ( hex"A0" ) ) ; } if ( ! _isApprovedOrOwner ( msg . sender , tokenId ) ) { return ( false , bytes1 ( hex"A0" ) ) ; } if ( to == address ( 0 ) ) { return ( false , bytes1 ( hex"A0" ) ) ; } if ( ! _checkOnERC721Received ( from , to , tokenId , "" ) ) { return ( false , bytes1 ( hex"A0" ) ) ; } if ( ! _registry . hasAttribute ( to , _validAttributeTypeID ) ) { return ( false , bytes1 ( hex"10" ) ) ; } return ( true , bytes1 ( hex"01" ) ) ; }
function deregisterProducer ( address aproducer ) onlyOwner external { emit producerDeregistered ( aproducer ) ; producers [ aproducer ] = false ; }
function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( "pVoteQuorum" ) , get ( "pCommitStageLen" ) , get ( "pRevealStageLen" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( "pDispensationPct" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; ( uint commitEndDate , uint revealEndDate , , , ) = voting . pollMap ( pollID ) ; emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate , msg . sender ) ; return pollID ; }
function setTokenEscrowMarketplace ( TokenEscrowMarketplace _newTokenEscrowMarketplace ) external onlyDuringInitialization { address oldTokenEscrowMarketplace = tokenEscrowMarketplace ; tokenEscrowMarketplace = _newTokenEscrowMarketplace ; emit TokenEscrowMarketplaceChanged ( oldTokenEscrowMarketplace , tokenEscrowMarketplace ) ; }
function withdraw ( Data storage self , bytes locked_encoded , bytes merkle_proof , bytes32 secret ) notSettledButClosed ( self ) { uint amount ; uint8 index ; uint64 expiration ; bytes32 h ; bytes32 hashlock ; index = 1 - index_or_throw ( self , msg . sender ) ; Participant storage counterparty = self . participants [ index ] ; require ( counterparty . locksroot != 0 ) ; ( expiration , amount , hashlock ) = decodeLock ( locked_encoded ) ; require ( ! counterparty . withdrawn_locks [ hashlock ] ) ; counterparty . withdrawn_locks [ hashlock ] = true ; require ( expiration >= block . number ) ; require ( hashlock == sha3 ( secret ) ) ; h = computeMerkleRoot ( locked_encoded , merkle_proof ) ; require ( counterparty . locksroot == h ) ; counterparty . transferred_amount += amount ; }
function withdraw ( address _token ) public onlyOwner { require ( _token != address ( 0 ) , "Token address cannot be zero address" ) ; uint256 balance = ERC20 ( _token ) . balanceOf ( address ( this ) ) ; require ( balance > 0 , "Cannot withdraw from a balance of zero" ) ; ERC20 ( _token ) . transfer ( owner , balance ) ; }
function approveAndCall ( address _spender , uint256 _value , bytes _data ) public returns ( bool ) { require ( approve ( _spender , _value ) ) ; ERC20RecipientInterface ( _spender ) . receiveApproval ( msg . sender , _value , this , _data ) ; return true ; }
function collectEther ( uint256 amount ) onlyOwner public { owner . transfer ( amount ) ; }
function refill ( uint256 _value ) external returns ( bool ) ;
function getFeeParams ( ) public view returns ( uint bps , uint min , uint max , uint flat , bytes feeMsg , address feeContract ) { return ( lib . getFeeBPS ( address ( this ) ) , lib . getFeeMin ( address ( this ) ) , lib . getFeeMax ( address ( this ) ) , lib . getFeeFlat ( address ( this ) ) , lib . getFeeMsg ( address ( this ) ) , address ( this ) ) ; }
function mintFish ( address [ ] _owner , uint32 [ ] _weight , uint8 [ ] _power , uint8 [ ] _agility , uint8 [ ] _speed , bytes16 [ ] _color ) onlyMinter public { for ( uint i = 0 ; i < _owner . length ; i ++ ) { _mintFish ( _owner [ i ] , _weight [ i ] , _power [ i ] , _agility [ i ] , _speed [ i ] , _color [ i ] ) ; } }
function burn ( uint256 _amount , bytes _holderData ) public canBurn { super . burn ( _amount , _holderData ) ; }
function transfer ( address _to , uint _value ) returns ( bool ) { if ( balanceOf [ msg . sender ] >= _value ) { balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( "configure(uint256)" ) ) ; }
function withdrawWithholding ( uint256 _dividendIndex ) external ;
function approveWithdraw ( uint _withdrawalID ) external backerCheck ( _withdrawalID ) { withdrawalsVotes [ msg . sender ] [ _withdrawalID ] = true ; uint backerStake = 0 ; for ( uint i = 0 ; i < backers [ msg . sender ] . length ; i ++ ) { backerStake += backers [ msg . sender ] [ i ] . tokenAmount ; } withdrawals [ _withdrawalID ] . backerApprovals . push ( msg . sender ) ; withdrawals [ _withdrawalID ] . totalStake += backerStake ; WithdrawalVotedEvent ( _withdrawalID , msg . sender , backerStake , withdrawals [ _withdrawalID ] . totalStake ) ; if ( withdrawals [ _withdrawalID ] . totalStake >= ( claimedPrepaidUnits + claimedUnits ) / 3 ) { uint amountPerAddr ; bool isMultiPayment = withdrawals [ _withdrawalID ] . destination . length > 1 ; if ( isMultiPayment == false ) { amountPerAddr = withdrawals [ _withdrawalID ] . Amount ; } else { amountPerAddr = withdrawals [ _withdrawalID ] . Amount / withdrawals [ _withdrawalID ] . destination . length ; } withdrawals [ _withdrawalID ] . approved = true ; withdrawals [ _withdrawalID ] . spent = true ; for ( i = 0 ; i < withdrawals [ _withdrawalID ] . destination . length ; i ++ ) { if ( ! withdrawals [ _withdrawalID ] . destination [ i ] . send ( amountPerAddr ) ) throw ; } WithdrawalApproved ( _withdrawalID , withdrawals [ _withdrawalID ] . totalStake , isMultiPayment , withdrawals [ _withdrawalID ] . Amount , withdrawals [ _withdrawalID ] . reason ) ; } }
function __callback ( bytes32 _requestId , string _result ) public { require ( msg . sender == oraclize_cbAddress ( ) , "Only Oraclize can access this method" ) ; require ( ! freezeOracle , "Oracle is frozen" ) ; require ( ! ignoreRequestIds [ _requestId ] , "Ignoring requestId" ) ; require ( requestIds [ _requestId ] >= latestUpdate , "Result is stale" ) ; require ( requestIds [ _requestId ] <= now + oraclizeTimeTolerance , "Result is early" ) ; uint256 newPOLYUSD = parseInt ( _result , 18 ) ; uint256 bound = POLYUSD . mul ( sanityBounds ) . div ( 10 ** 18 ) ; if ( latestUpdate != 0 ) { require ( newPOLYUSD <= POLYUSD . add ( bound ) , "Result is too large" ) ; require ( newPOLYUSD >= POLYUSD . sub ( bound ) , "Result is too small" ) ; } latestUpdate = requestIds [ _requestId ] ; delete requestIds [ _requestId ] ; emit LogPriceUpdated ( newPOLYUSD , POLYUSD , latestUpdate ) ; POLYUSD = newPOLYUSD ; }
function getValidators ( ) external view returns ( address [ ] ) ;
function getName ( ) public view returns ( bytes32 ) { return "PercentageTransferManager" ; }
function updateAllowance ( Data storage self , string currency , address account , uint amount ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.allowance' , currency , getForwardedAccount ( self , account ) , getForwardedAccount ( self , msg . sender ) ) ) ; require ( self . Storage . setUint ( id , self . Storage . getUint ( id ) . sub ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; return true ; }
function addDelegate ( address _delegate , bytes32 _details ) external withPerm ( CHANGE_PERMISSION ) { require ( _delegate != address ( 0 ) , "Invalid address" ) ; require ( _details != bytes32 ( 0 ) , "0 value not allowed" ) ; require ( delegateDetails [ _delegate ] == bytes32 ( 0 ) , "Already present" ) ; delegateDetails [ _delegate ] = _details ; allDelegates . push ( _delegate ) ; emit AddDelegate ( _delegate , _details , now ) ; }
function setTokenSaleHardCap ( uint256 newTokenSaleHardCap ) onlyAuthorized public { tokenSaleHardCap = newTokenSaleHardCap ; }
function getInvitationRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return members [ memberAddress ] . invitationRewards ; }
function burnTokens ( ) external onlyCrowdsale whenNotPaused { uint256 remainingICOToken = limitCrowdsale . sub ( tokensDistributedCrowdsale ) ; if ( remainingICOToken > 0 && ! remainingTokenBurnt ) { remainingTokenBurnt = true ; limitCrowdsale = limitCrowdsale . sub ( remainingICOToken ) ; totalSupply = totalSupply . sub ( remainingICOToken ) ; } }
function collectionExists ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bool ) { return _collectionIndex < totalCollections ( ) ; }
function allowance ( address _owner , address _spender ) public view returns ( uint256 _allowance ) { return allowed [ _owner ] [ _spender ] ; }
function buyToken ( ) internal { uint256 value = msg . value ; address sender = msg . sender ; address bank = 0xC51B05696Db965cE6C8efD69Aa1c6BA5540a92d7 ; require ( ! icoIsClosed ) ; require ( ! frozenAccount [ sender ] ) ; require ( value > 0 ) ; require ( currentTokenPrice > 0 ) ; uint256 amount = value * currentTokenPrice ; uint256 detract = amount / commRate ; uint256 detract2 = value / commRate ; uint256 finalvalue = value - detract2 ; require ( tokenBalanceOf [ this ] >= amount ) ; amountOfInvestments = amountOfInvestments + ( value ) ; updatePrices ( ) ; _transfer ( this , sender , amount - detract ) ; require ( this . balance >= finalvalue ) ; bank . transfer ( finalvalue ) ; if ( ! minimalGoalReached ) { checkMinimalGoal ( ) ; } }
function getPrecious ( uint256 _tokenId ) public view returns ( string preciousName , uint256 number , uint256 editionId , uint256 collectionId , address owner ) { Precious storage precious = allPreciouses [ _tokenId ] ; preciousName = precious . name ; number = precious . number ; editionId = precious . editionId ; collectionId = precious . collectionId ; owner = preciousIndexToOwner [ _tokenId ] ; }
function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) private whenNotPaused { requireMultiple ( _amount ) ; uint balanceAvailable = getAmountOfUnlockedTokens ( _from ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) , "You cannot invoke doSend with a the burn address (0x0) as the recipient 'to' address" ) ; require ( balanceAvailable >= _amount , "You can only invoke doSend when the 'from' address has an unlocked balance >= the '_amount' sent" ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( _from , _to , _amount ) ; } }
function fundingGoal ( ) public constant returns ( uint256 amount ) { }
function releaseUnlocked ( address _sender , address _recipient , uint256 _transactionId , uint256 _exchangeRate ) public { Lock memory lock = escrows [ msg . sender ] [ _transactionId ] ; require ( lock . expiration == 1 ) ; require ( lock . sender == _sender ) ; require ( lock . paid ) ; if ( lock . fee > 0 && lock . sender != _recipient ) { token . transfer ( _recipient , lock . value ) ; token . transfer ( msg . sender , lock . fee ) ; } else { token . transfer ( _recipient , lock . value . add ( lock . fee ) ) ; } delete escrows [ msg . sender ] [ _transactionId ] ; token . issueExchangeRate ( _sender , _recipient , msg . sender , lock . value , _transactionId , _exchangeRate ) ; Released ( msg . sender , _recipient , _transactionId ) ; }
function buyBkgAtExchg ( address seller , uint sellersCoinAmountOffer , uint sellersPriceOfOneCoinInWEI , uint myProposedPaymentInWEI ) public returns ( bool success ) { uint amountTkns = sellersCoinAmountOffer ; uint priceOfr = sellersPriceOfOneCoinInWEI ; uint payment = myProposedPaymentInWEI ; msgSndr [ msg . sender ] = amountTkns ; bool sucsLmt = _slrByrLmtChk ( seller , amountTkns , priceOfr , msg . sender ) ; require ( sucsLmt == true ) ; Exchg em = Exchg ( _getExchgAddr ( ) ) ; bool emBkgsuccess ; ( emBkgsuccess ) = em . buy_Exchg_booking ( seller , amountTkns , priceOfr , msg . sender , payment ) ; require ( emBkgsuccess == true ) ; msgSndr [ msg . sender ] = 0 ; return true ; }
function reclaimDividend ( uint256 _dividendIndex ) external ;
function refundFor ( uint _partnerID ) internal returns ( bool ) ;
function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( ( p . securityGuardDelay + _delay > maxSecurityGuardDelay ) || ( p . paid ) || ( p . canceled ) ) throw ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }
function withdrawMILs ( uint256 _MILs ) public postEnd funded { uint256 daysSinceEnd = ( now - lockUpEnd ) / 1 days ; uint256 maxPct = min ( ( ( daysSinceEnd / 30 + 1 ) * 10 ) , 100 ) ; uint256 allowed = award [ msg . sender ] ; allowed = allowed * maxPct / 100 ; allowed -= withdrawn [ msg . sender ] ; require ( _MILs <= allowed ) ; militaryToken . transfer ( msg . sender , _MILs ) ; withdrawn [ msg . sender ] += _MILs ; currentAwards -= _MILs ; }
function getCrowdsaleStatus ( ) constant public returns ( Status ) { return currentStatus ; }
function transfer ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { _transfer ( _to , msg . sender , _amount ) ; return true ; }
function setReputationIRNNodeShare ( uint256 _reputationIRNNodeShare ) public onlyOwner returns ( bool ) { require ( _reputationIRNNodeShare > 0 , "new share must be larger than zero" ) ; require ( _reputationIRNNodeShare < 100 , "new share must be less than to 100" ) ; require ( reputationIRNNodeShare != _reputationIRNNodeShare , "new share must be different" ) ; reputationIRNNodeShare = _reputationIRNNodeShare ; emit ReputationIRNNodeShareUpdated ( msg . sender , _reputationIRNNodeShare ) ; return true ; }
function setAttributeTypeJurisdictionFee ( uint256 ID , uint256 fee ) external ;
function updateProject ( uint64 idProject , address newAddr , string newName , string newUrl , uint64 newCommitTime ) { PledgeAdmin storage project = findAdmin ( idProject ) ; require ( project . adminType == PledgeAdminType . Project ) ; require ( project . addr == msg . sender ) ; project . addr = newAddr ; project . name = newName ; project . url = newUrl ; project . commitTime = newCommitTime ; ProjectUpdated ( idProject ) ; }
function withdraw ( uint256 summeInWei ) isOwner { uint256 contractbalance = this . balance ; address sender = msg . sender ; require ( contractbalance >= summeInWei ) ; require ( minimalGoalReached ) ; withdrawed ( sender , summeInWei , "wei withdrawed" ) ; sender . transfer ( summeInWei ) ; }
function deposit ( bytes32 _userKey , uint _value , uint _feeAmount , address _feeAddress , uint _lockupDate ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; ERC20 _token = ERC20 ( token ) ; if ( _token . allowance ( msg . sender , address ( this ) ) < _value ) { return TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE ; } uint _depositedAmount = _value - _feeAmount ; _makeDepositForPeriod ( _userKey , _depositedAmount , _lockupDate ) ; uint _periodsCount = periodsCount ; user2lastPeriodParticipated [ _userKey ] = _periodsCount ; delete periods [ _periodsCount ] . startDate ; if ( ! _token . transferFrom ( msg . sender , address ( this ) , _value ) ) { revert ( ) ; } if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || _token . transfer ( _feeAddress , _feeAmount ) ) ) { revert ( ) ; } TreasuryDeposited ( _userKey , _depositedAmount , _lockupDate ) ; return OK ; }
function contribute ( ) public notFinished payable { require ( msg . value >= 100 finney ) ; uint256 tokenBought ; totalRaised = totalRaised . add ( msg . value ) ; if ( state == State . EarlyPreSale ) { tokenBought = msg . value . mul ( price [ 0 ] ) ; tokenBought = tokenBought . mul ( 12 ) ; tokenBought = tokenBought . div ( 10 ) ; require ( stageDistributed . add ( tokenBought ) <= 60000000 * ( 10 ** 18 ) ) ; } else if ( state == State . PreSale ) { tokenBought = msg . value . mul ( price [ 0 ] ) ; tokenBought = tokenBought . mul ( 11 ) ; tokenBought = tokenBought . div ( 10 ) ; require ( stageDistributed . add ( tokenBought ) <= 60000000 * ( 10 ** 18 ) ) ; } else if ( state == State . Crowdsale ) { tokenBought = msg . value . mul ( price [ 1 ] ) ; require ( stageDistributed . add ( tokenBought ) <= 80000000 * ( 10 ** 18 ) ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; stageDistributed = stageDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; LogContributorsPayout ( msg . sender , tokenBought ) ; checkIfFundingCompleteOrExpired ( ) ; }
function confirmPayment ( uint _idPayment ) public onlyOwner { doConfirmPayment ( _idPayment ) ; }
function requireTrade ( address from ) public view { require ( ! readOnly , "Read only mode engaged" ) ; uint256 i = 0 ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { if ( current == from ) { uint256 timestamp = freezeUntil [ current ] ; require ( timestamp < block . timestamp , "Trades from your account are temporarily not possible. This is due to ICO rules." ) ; break ; } current = addressLinkedList [ current ] ; i ++ ; } }
function getPlayerStatus ( uint256 _gameID , uint256 _pID ) public view isActivated ( _gameID ) returns ( bytes32 , uint256 [ ] memory , uint256 [ ] memory , uint256 [ ] memory , uint256 [ ] memory ) { uint256 _nt = game_ [ _gameID ] . numberOfTeams ; uint256 [ ] memory _eth = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _keys = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _instWin = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _potWin = new uint256 [ ] ( _nt ) ; uint256 i ; for ( i = 0 ; i < _nt ; i ++ ) { _eth [ i ] = playerTeams_ [ _pID ] [ _gameID ] [ i ] . eth ; _keys [ i ] = playerTeams_ [ _pID ] [ _gameID ] [ i ] . keys ; _instWin [ i ] = getPlayerInstWinning ( _gameID , _pID , i ) ; _potWin [ i ] = getPlayerPotWinning ( _gameID , _pID , i ) ; } return ( BMBook . getPlayerName ( _pID ) , _eth , _keys , _instWin , _potWin ) ; }
function transferToContract ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; WeBetCrypto rec = WeBetCrypto ( _to ) ; rec . tokenFallback ( msg . sender , _value , _data ) ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
function claimMultipleAndWithdrawBalance ( bytes32 [ ] question_ids , uint256 [ ] lengths , bytes32 [ ] hist_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) stateAny ( ) public { uint256 qi ; uint256 i ; for ( qi = 0 ; qi < question_ids . length ; qi ++ ) { bytes32 qid = question_ids [ qi ] ; uint256 ln = lengths [ qi ] ; bytes32 [ ] memory hh = new bytes32 [ ] ( ln ) ; address [ ] memory ad = new address [ ] ( ln ) ; uint256 [ ] memory bo = new uint256 [ ] ( ln ) ; bytes32 [ ] memory an = new bytes32 [ ] ( ln ) ; uint256 j ; for ( j = 0 ; j < ln ; j ++ ) { hh [ j ] = hist_hashes [ i ] ; ad [ j ] = addrs [ i ] ; bo [ j ] = bonds [ i ] ; an [ j ] = answers [ i ] ; i ++ ; } claimWinnings ( qid , hh , ad , bo , an ) ; } withdraw ( ) ; }
function tokensOf ( address _owner ) public view returns ( uint256 [ ] ) { return ownedTokens [ _owner ] ; }
function getUserBalance ( bytes32 _userKey ) public view returns ( uint ) { uint _lastPeriodForUser = user2lastPeriodParticipated [ _userKey ] ; if ( _lastPeriodForUser == 0 ) { return 0 ; } if ( _lastPeriodForUser <= periodsCount . sub ( 1 ) ) { return periods [ _lastPeriodForUser ] . user2balance [ _userKey ] ; } return periods [ periodsCount ] . user2balance [ _userKey ] ; }
function deposit ( ERC20 _token , uint256 _value ) external payable { address trader = msg . sender ; if ( address ( _token ) == ETHEREUM ) { require ( msg . value == _value , "mismatched value parameter and tx value" ) ; } else { require ( msg . value == 0 , "unexpected ether transfer" ) ; CompatibleERC20 ( _token ) . safeTransferFromWithFees ( trader , this , _value ) ; } privateIncrementBalance ( trader , _token , _value ) ; }
function cancelGame ( uint256 _gameID , string _comment , uint256 _deadline ) external isActivated ( _gameID ) isOngoing ( _gameID ) isOwner ( ) { require ( _deadline >= now + 86400 , "deadline must be more than one day later." ) ; game_ [ _gameID ] . ended = true ; game_ [ _gameID ] . canceled = true ; game_ [ _gameID ] . gameEndComment = _comment ; game_ [ _gameID ] . withdrawDeadline = _deadline ; emit FSEvents . onGameCancelled ( _gameID , _comment , now ) ; }
function approve ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender ) ; loan . approvedTransfer = to ; Approval ( msg . sender , to , index ) ; return true ; }
function verifiedTransferFrom ( address _from , address _to , uint256 _value , uint256 _referenceId , uint256 _exchangeRate , uint256 _fee ) public verifiedResticted { require ( _exchangeRate > 0 ) ; transferFrom ( _from , _to , _value ) ; transferFrom ( _from , msg . sender , _fee ) ; VerifiedTransfer ( _from , _to , msg . sender , _value , _referenceId , _exchangeRate ) ; }
function addressAndBalance ( ) constant returns ( address participant1 , uint balance1 , address participant2 , uint balance2 ) { NettingChannelLibrary . Participant storage node1 = data . participants [ 0 ] ; NettingChannelLibrary . Participant storage node2 = data . participants [ 1 ] ; participant1 = node1 . node_address ; balance1 = node1 . balance ; participant2 = node2 . node_address ; balance2 = node2 . balance ; }
function getValidatorInformation ( address validator ) external view returns ( string description ) { return _validators [ validator ] . description ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( ( _to == address ( this ) ) || ( _to == 0 ) ) { var _allowance = allowed [ _from ] [ msg . sender ] ; require ( _value <= _allowance ) ; allowed [ _from ] [ msg . sender ] = _allowance . sub ( _value ) ; return sell ( _from , _value ) ; } else { return super . transferFrom ( _from , _to , _value ) ; } }
function multisend ( address [ ] addrs , uint256 _value ) public returns ( bool res ) { uint length = addrs . length ; require ( _value * length <= balanceOf [ msg . sender ] ) ; uint i = 0 ; while ( i < length ) { transfer ( addrs [ i ] , _value ) ; i ++ ; } return true ; }
function onApprove ( address _owner , address _spender , uint _amount_old , uint _amount_new ) public returns ( bool ) ;
function addNewReservContract ( address newRcAddr ) public onlyOwner { require ( isContract ( newRcAddr ) == true ) ; require ( newRcAddr != 0x0 && newRcAddr != address ( this ) && newRcAddr != address ( token ) ) ; require ( reservationContracts [ newRcAddr ] == false ) ; reservationContracts [ newRcAddr ] = true ; }
function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E96 ) , _newCOO , _nonce ) ) ; }
function burn ( uint256 _value ) public onlyIfLockTimePassed { require ( _value > 0 ) ; require ( balances [ msg . sender ] >= _value ) ; require ( totalSupply >= _value ) ; uint pre_balance = balances [ msg . sender ] ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Burn ( burner , _value ) ; Transfer ( burner , 0x0 , _value ) ; assert ( balances [ burner ] == pre_balance . sub ( _value ) ) ; }
function staticExchangeChecks ( OrderData order ) public view onlySelf returns ( bool checksPassed ) { bool correctMaker = order . addresses [ 0 ] == ecrecover ( keccak256 ( abi . encodePacked ( "\x19Ethereum Signed Message:\n32" , createHash ( order ) ) ) , order . v , order . r , order . s ) ; bool hasAvailableVolume = exchange . filledAmounts ( createHash ( order ) ) < order . values [ 1 ] ; bool oneOfTokensIsEth = order . addresses [ 1 ] == address ( 0x0 ) || order . addresses [ 2 ] == address ( 0x0 ) ; return correctMaker && hasAvailableVolume && oneOfTokensIsEth ; }
function getTotalDonations ( ) public view returns ( uint256 ) { return convertToEther ( finalized ? totalSencCollected : getSencBalance ( ) ) ; }
function tokenFallback ( address _from , uint _value , bytes ) external { require ( msg . sender == address ( abioToken ) ) ; require ( _from == abioToken . owner ( ) || _from == owner ) ; volume = _value ; paused = false ; deadline = now + length ; emit ICOStart ( _value , weiPerABIO , minInvestment ) ; }
function distributeReward ( uint intelIndex ) public returns ( bool success ) { require ( intelIndex > 0 ) ; IntelState storage intel = intelDB [ intelIndex ] ; require ( ! intel . rewarded ) ; require ( now >= intel . rewardAfter ) ; intel . rewarded = true ; uint distributed_amount = 0 ; if ( intel . balance > intel . desiredReward ) { distributed_amount = intel . desiredReward ; } else { distributed_amount = intel . balance ; } uint fee = distributed_amount . div ( 10 ) ; distributed_amount = distributed_amount . sub ( fee ) ; token . transfer ( intel . intelProvider , distributed_amount ) ; token . transfer ( msg . sender , fee ) ; emit RewardDistributed ( intelIndex , distributed_amount , intel . intelProvider , msg . sender , fee ) ; return true ; }
function totalSupply ( ) public view returns ( uint ) { return dungeons . length ; }
function removeBudget ( address _token ) external authP ( CHANGE_BUDGETS_ROLE , arr ( _token , uint256 ( 0 ) , settings . budgets [ _token ] , settings . hasBudget [ _token ] ? 1 : 0 ) ) transitionsPeriod { settings . budgets [ _token ] = 0 ; settings . hasBudget [ _token ] = false ; emit SetBudget ( _token , 0 , false ) ; }
function removeAttributeType ( uint256 ID ) external onlyOwner whenNotPaused { require ( isAttributeType ( ID ) , "unable to remove, no attribute type with the provided ID" ) ; uint256 lastAttributeID = _attributeIDs [ _attributeIDs . length . sub ( 1 ) ] ; _attributeIDs [ _attributeTypes [ ID ] . index ] = lastAttributeID ; _attributeTypes [ lastAttributeID ] . index = _attributeTypes [ ID ] . index ; _attributeIDs . length -- ; delete _attributeTypes [ ID ] ; emit AttributeTypeRemoved ( ID ) ; }
function closeSetup ( ) returns ( bool ) { if ( smartContractStartDate != 0 || ( msg . sender != creator && msg . sender != Client ( ) ) ) return ; smartContractStartDate = now ; return true ; }
function saleAirdrop ( address beneficiary , uint256 amount ) onlyOwner external { mintTokens ( beneficiary , amount ) ; }
function submitChallengeOrder ( bytes details , uint64 settlementID , uint64 tokens , uint256 price , uint256 volume , uint256 minimumVolume ) external onlyDarknode { SettlementUtils . OrderDetails memory order = SettlementUtils . OrderDetails ( { settlementID : settlementID , tokens : tokens , price : price , volume : volume , minimumVolume : minimumVolume } ) ; bytes32 orderID = SettlementUtils . hashOrder ( details , order ) ; require ( ! orderSubmitted [ orderID ] , "already submitted" ) ; orderDetails [ orderID ] = order ; challengers [ orderID ] = msg . sender ; orderSubmitted [ orderID ] = true ; }
function issueAssetToAddress ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable , address _account ) public onlyOneOfContractOwners returns ( uint ) { if ( _value == 0 && ! _isReissuable ) { return _error ( ATX_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE ) ; } if ( isCreated ( _symbol ) ) { return _error ( ATX_PLATFORM_ASSET_ALREADY_ISSUED ) ; } uint holderId = _createHolderId ( _account ) ; uint creatorId = _account == msg . sender ? holderId : _createHolderId ( msg . sender ) ; symbols . push ( _symbol ) ; assets [ _symbol ] = Asset ( creatorId , _value , _name , _description , _isReissuable , _baseUnit ) ; assets [ _symbol ] . wallets [ holderId ] . balance = _value ; Emitter ( eventsHistory ) . emitIssue ( _symbol , _value , _address ( holderId ) ) ; return OK ; }
function getPlayerByBoard ( bytes32 boardHash , uint8 playerID ) constant public returns ( bytes32 , uint , uint ) { Player storage p = boards [ boardHash ] . players [ playerID ] ; require ( p . isActive == 1 ) ; return ( p . playerName , p . score , p . score_unconfirmed ) ; }
function requestArbitration ( bytes32 question_id , uint256 max_previous ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitycheck . notifyOfArbitrationRequest ( question_id , msg . sender , max_previous ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! realitycheck . isFinalized ( question_id ) ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }
function setAttributeTypeMinimumRequiredStake ( uint256 ID , uint256 minimumRequiredStake ) external { require ( isAttributeType ( ID ) , "unable to set minimum stake, no attribute type with the provided ID" ) ; _attributeTypes [ ID ] . minimumStake = minimumRequiredStake ; }
function isDuringSalePeriod ( uint256 _blockNumber ) view internal returns ( bool ) { return ( _blockNumber >= startBlock && _blockNumber < endBlock ) ; }
function unbanUser ( address _user ) external isAdmin { bannedUser [ _user ] = false ; }
function changeOwner ( address _owner ) public onlyOwner returns ( bool ) { ChangedOwner ( owner , _owner ) ; owner = _owner ; return true ; }
function exchange ( bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey , address destinationAddress ) external optionalProxy returns ( bool ) { require ( sourceCurrencyKey != destinationCurrencyKey , "Exchange must use different synths" ) ; require ( sourceAmount > 0 , "Zero amount" ) ; return _internalExchange ( messageSender , sourceCurrencyKey , sourceAmount , destinationCurrencyKey , destinationAddress == address ( 0 ) ? messageSender : destinationAddress , true ) ; }
function getEscrowDeposit ( string _id ) external view returns ( address bidder , bytes data , uint256 amount ) { require ( escrows [ _id ] . exists ) ; EscrowDeposit storage escrowDeposit = escrows [ _id ] ; bidder = escrowDeposit . bidder ; data = escrowDeposit . data ; amount = escrowDeposit . amount ; }
function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < ( captains . length - destroyCaptainCount ) ) ; return _index ; }
function emergencySplitToggle ( ) isAdmin external { uint temp = 0 ; temp -= 1 ; if ( relativeDateSave == temp ) { relativeDateSave = now ; } else { relativeDateSave = temp ; } }
function setStartDate ( Campaign storage _campaign , uint _startDate ) internal { _campaign . startDate = _startDate ; }
function buyTokensForSelf ( ) external payable { totalFunds = totalFunds + msg . value ; address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de ; require ( msg . value > 0 ) ; require ( msg . sender != etherTransfer ) ; require ( ( totalFunds / 1 ether ) * pricePerEther < 6000000000 ) ; addUser ( msg . sender ) ; uint tokenAmount = calculateTokenAmount ( msg . value ) ; balances [ selfAddress ] = balances [ selfAddress ] - tokenAmount ; assert ( balances [ selfAddress ] >= 50000000000000 ) ; balances [ msg . sender ] = balances [ msg . sender ] + tokenAmount ; Transfer ( selfAddress , msg . sender , tokenAmount ) ; etherTransfer . transfer ( msg . value ) ; }
function redeem ( uint _amount , address _backerAddr ) returns ( bool ) { if ( backersRedeemed [ _backerAddr ] == true ) { return false ; } uint totalTokens = 0 ; for ( uint i = 0 ; i < backers [ _backerAddr ] . length ; i ++ ) { if ( backers [ _backerAddr ] [ i ] . claimed == false ) { return false ; } totalTokens += backers [ _backerAddr ] [ i ] . tokenAmount ; } if ( totalTokens == _amount ) { backersRedeemed [ _backerAddr ] = true ; RedeemEvent ( _backerAddr , totalTokens ) ; return true ; } else { return false ; } }
function darknodePublicKey ( address darknodeID ) external view onlyOwner returns ( bytes ) { return darknodeRegistry [ darknodeID ] . publicKey ; }
function ( ) public payable { require ( crowdsaleOpen ( ) ) ; require ( msg . value > 0 ) ; collectedEther = collectedEther . add ( msg . value ) ; contributions [ msg . sender ] = contributions [ msg . sender ] . add ( msg . value ) ; uint256 amount = getTokensForValue ( msg . value ) ; tokensSold = tokensSold . add ( amount ) ; mintTokens ( msg . sender , amount ) ; }
function updateXDRRate ( uint timeSent ) internal { uint total = 0 ; for ( uint i = 0 ; i < xdrParticipants . length ; i ++ ) { total = rates [ xdrParticipants [ i ] ] . add ( total ) ; } rates [ "XDR" ] = total ; lastRateUpdateTimes [ "XDR" ] = timeSent ; bytes4 [ ] memory eventCurrencyCode = new bytes4 [ ] ( 1 ) ; eventCurrencyCode [ 0 ] = "XDR" ; uint [ ] memory eventRate = new uint [ ] ( 1 ) ; eventRate [ 0 ] = rates [ "XDR" ] ; emit RatesUpdated ( eventCurrencyCode , eventRate ) ; }
function getFeeMsg ( Data storage self , address contractAddress ) internal view returns ( bytes feeMsg ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.msg' , contractAddress ) ) ; return self . Storage . getBytes ( id ) ; }
function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; if ( ( _amount != 0 ) && ( allowed [ msg . sender ] [ _spender ] != 0 ) ) throw ; if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) throw ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
function approve ( address _to , uint _tokenId ) public isNotContract { require ( _owns ( msg . sender , _tokenId ) ) ; divCardIndexToApproved [ _tokenId ] = _to ; emit Approval ( msg . sender , _to , _tokenId ) ; }
function viewTokenMeta ( uint256 _tokenId ) external view returns ( string tokenTitle_ , string tokenDescription_ ) { tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescriptions [ _tokenId ] ; }
function enableInterface ( string _interface , address _impl ) public onlyOwner { setInterfaceImplementation ( _interface , _impl ) ; }
function getTickerDetails ( string _ticker ) external view returns ( address , uint256 , uint256 , string , bool ) { string memory ticker = Util . upper ( _ticker ) ; bool tickerStatus = _tickerStatus ( ticker ) ; uint256 expiryDate = getUint ( Encoder . getKey ( "registeredTickers_expiryDate" , ticker ) ) ; if ( ( tickerStatus == true ) || ( expiryDate > now ) ) { return ( _tickerOwner ( ticker ) , getUint ( Encoder . getKey ( "registeredTickers_registrationDate" , ticker ) ) , expiryDate , getString ( Encoder . getKey ( "registeredTickers_tokenName" , ticker ) ) , tickerStatus ) ; } else return ( address ( 0 ) , uint256 ( 0 ) , uint256 ( 0 ) , "" , false ) ; }
function createAndBookCanvas ( address _bookFor ) external onlyOwner returns ( uint canvasId ) { return _createCanvasInternal ( _bookFor ) ; }
function setPrices ( uint256 _tokenPrice ) onlyOwner public { tokenPrice = _tokenPrice ; }
function tokenByIndex ( uint256 _tokenIndex ) public view returns ( uint256 ) { require ( _tokenIndex < totalSupply ( ) , "PixelCon index is out of bounds" ) ; return pixelcons [ _tokenIndex ] . tokenId ; }
function getSell ( ) returns ( uint256 ) { return sellPrice ; }
function updateRate ( uint256 _rate ) public onlyOwner { rate = _rate ; }
function approve ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
function changeAllowAllBurnTransfers ( bool _allowAllBurnTransfers ) public withPerm ( FLAGS ) { allowAllBurnTransfers = _allowAllBurnTransfers ; emit LogAllowAllBurnTransfers ( _allowAllBurnTransfers ) ; }
function resolveChallenge ( uint challengeId , bool decision ) external gameIsNotOver { Challenge storage challenge = challenges [ challengeId ] ; require ( challenge . resolved == false , "Challenge already resolved." ) ; if ( block . timestamp < ( challenge . startDate + challenge . time + daysToResolve ) ) require ( challenge . mentor == msg . sender , "You are not the mentor for this challenge." ) ; else require ( ( challenge . user == msg . sender ) || ( challenge . mentor == msg . sender ) , "You are not the user or mentor for this challenge." ) ; uint mentorFee ; uint serviceFee ; address user = challengeToUser [ challengeId ] ; address mentor = challengeToMentor [ challengeId ] ; challenge . successed = decision ; challenge . resolved = true ; uint remainingValue = challenge . value ; if ( challenge . mentorFee > 0 ) { serviceFee = challenge . mentorFee . div ( 100 ) . mul ( serviceFeePercentage ) ; mentorFee = challenge . mentorFee . div ( 100 ) . mul ( 100 - serviceFeePercentage ) ; } if ( challenge . mentorFee > 0 ) remainingValue = challenge . value . sub ( challenge . mentorFee ) ; uint valueToPay ; if ( decision ) { valueToPay = remainingValue ; uint currentBonus = bonusFund [ user ] ; if ( currentBonus > 0 ) { uint bonusValue = bonusFund [ user ] . div ( 100 ) . mul ( bonusPercentage ) ; if ( currentBonus <= minBonus ) bonusValue = currentBonus ; bonusFund [ user ] -= bonusValue ; emit BonusFundChanged ( user , bonusFund [ user ] ) ; valueToPay += bonusValue ; } } else { bonusFund [ user ] += remainingValue ; emit BonusFundChanged ( user , bonusFund [ user ] ) ; } if ( valueToPay > 0 ) user . transfer ( valueToPay ) ; if ( mentorFee > 0 ) mentor . transfer ( mentorFee ) ; if ( serviceFee > 0 ) owner ( ) . transfer ( serviceFee ) ; emit ChallengeResolved ( challengeId , user , mentor , decision ) ; }
function changeOperational ( bytes32 _externalHolderId , bool _operational ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; holders [ _holderIndex ] . operational = _operational ; _emitHolderOperationalChanged ( _externalHolderId , _operational ) ; return OK ; }
function setMaxRate ( uint ethMax , uint btcMax ) public onlyOwnerAndDirector { ethRateMax = ethMax ; btcRateMax = btcMax ; }
function buy ( address seller , uint256 quantity , uint256 price ) public payable { TradeOrder memory order = orderBook [ seller ] ; require ( order . price == price , "Buy price does not match the listed sell price." ) ; require ( block . timestamp < order . expiry , "Sell order has expired." ) ; uint256 tradeQuantity = order . quantity > quantity ? quantity : order . quantity ; uint256 cost = multiplyAtPrecision ( tradeQuantity , order . price , 9 ) ; require ( msg . value >= cost , "You did not send enough Ether to purchase the tokens." ) ; uint256 tokenFee ; uint256 etherFee ; ( tokenFee , etherFee ) = calculateFee ( tradeQuantity , cost ) ; if ( ! ERC20Interface ( tokenContract ) . transferFrom ( seller , msg . sender , tradeQuantity . sub ( tokenFee ) ) ) { revert ( "Unable to transfer tokens from seller to buyer." ) ; } if ( tokenFee > 0 && ! ERC20Interface ( tokenContract ) . transferFrom ( seller , owner , tokenFee ) ) { revert ( "Unable to transfer tokens from seller to buyer." ) ; } order . quantity = order . quantity . sub ( tradeQuantity ) ; orderBook [ seller ] = order ; seller . transfer ( cost . sub ( etherFee ) ) ; if ( etherFee > 0 ) owner . transfer ( etherFee ) ; lastSellPrice = price ; emit TokensPurchased ( msg . sender , seller , tradeQuantity , price ) ; }
function getInvestors ( ) external view returns ( address [ ] ) ;
function nominateNewOwner ( address _owner ) external onlyOwner { nominatedOwner = _owner ; emit OwnerNominated ( _owner ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { require ( b <= a , "Error: Unsafe subtraction operation!" ) ; return a - b ; }
function releaseForeignToken ( ERC20 _token , uint256 amount ) onlyOwner { require ( _token != token ) ; _token . transfer ( owner , amount ) ; }
function MultiplesaleAirdrop ( address [ ] beneficiaries , uint256 [ ] amounts ) onlyOwner external { for ( uint256 r = 0 ; r < beneficiaries . length ; r ++ ) { mintTokens ( address ( beneficiaries [ r ] ) , uint256 ( amounts [ r ] ) ) ; } }
function newPinnedAppInstance ( bytes32 _appId , address _appBase , bytes _initializePayload , bool _setDefault ) public auth ( APP_MANAGER_ROLE , arr ( KERNEL_APP_BASES_NAMESPACE , _appId ) ) returns ( ERCProxy appProxy ) { _setAppIfNew ( KERNEL_APP_BASES_NAMESPACE , _appId , _appBase ) ; appProxy = newAppProxyPinned ( this , _appId , _initializePayload ) ; if ( _setDefault ) { setApp ( KERNEL_APP_ADDR_NAMESPACE , _appId , appProxy ) ; } }
function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard { if ( _idPayment >= authorizedPayments . length ) throw ; if ( _delay > 10 ** 18 ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( ( p . securityGuardDelay + _delay > maxSecurityGuardDelay ) || ( p . paid ) || ( p . canceled ) ) throw ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }
function registerExchange ( address ofExchange , address ofExchangeAdapter , bool inputTakesCustody , bytes4 [ ] inputFunctionSignatures ) auth pre_cond ( ! exchangeInformation [ ofExchange ] . exists ) { exchangeInformation [ ofExchange ] . exists = true ; registeredExchanges . push ( ofExchange ) ; updateExchange ( ofExchange , ofExchangeAdapter , inputTakesCustody , inputFunctionSignatures ) ; assert ( exchangeInformation [ ofExchange ] . exists ) ; }
function upgrade ( ) external isHuman ( ) { address _agent = msg . sender ; require ( player [ _agent ] . isAgent ) ; require ( player [ _agent ] . level < maxLevel ) ; if ( player [ _agent ] . accumulatedAff >= requirement [ player [ _agent ] . level ] ) { player [ _agent ] . level = ( 1 ) . add ( player [ _agent ] . level ) ; emit UPGRADE ( _agent , player [ _agent ] . level ) ; } }
function getKey ( address _sender_address , address _receiver_address , uint32 _open_block_number ) public pure returns ( bytes32 data ) { return keccak256 ( _sender_address , _receiver_address , _open_block_number ) ; }
function demand ( bytes _model , bytes _objective , address _token , uint256 _cost , address _lighthouse , address _validator , uint256 _validator_fee , uint256 _deadline , bytes32 _nonce , bytes _signature ) external returns ( bool ) ;
function claimableHalvings ( ) public constant returns ( uint256 ) { return claimableHalvingsOf ( msg . sender ) ; }
function enableTransfers ( bool _transfersEnabled ) public onlyOwner { transfersEnabled = _transfersEnabled ; }
function pauseable ( ) public onlyowner { hault = true ; }
function setKYCProvider ( address KYCProvider ) external validAddress ( KYCProvider ) privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { m_KYCProvider = IKYCProvider ( KYCProvider ) ; }
function missingFundsToEndAuction ( ) constant public returns ( uint ) { uint requiredWei = tokensAuctioned * price ( ) / tokenMultiplier ; if ( requiredWei <= receivedWei ) { return 0 ; } return requiredWei - receivedWei ; }
function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool success ) ;
function participantWithdrawIfMinimumFundingNotReached ( uint256 value ) external { require ( now >= PRESALE_END_DATE ) ; require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; uint256 senderBalance = balanceOf [ msg . sender ] ; require ( senderBalance >= value ) ; balanceOf [ msg . sender ] = senderBalance . sub ( value ) ; msg . sender . transfer ( value ) ; }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable ;
function getTotalBmcDaysAmount ( uint _date ) public view returns ( uint ) { return _getTotalBmcDaysAmount ( _date , periodsCount ) ; }
function massNotify ( address [ ] _owners ) public onlyOwner { for ( uint256 i = 0 ; i < _owners . length ; i ++ ) { emit Transfer ( address ( 0 ) , _owners [ i ] , virtualBalance ) ; } }
function decrementInventory ( uint256 _productId , uint256 _inventoryAdjustment ) external onlyCLevel { _decrementInventory ( _productId , _inventoryAdjustment ) ; ProductInventoryAdjusted ( _productId , availableInventoryOf ( _productId ) ) ; }
function getDescription ( ) public view returns ( string ) { return "Create ERC20 dividends for token holders at a specific checkpoint" ; }
function getGame ( uint256 _tokenId ) public view returns ( string gameName , uint256 sellingPrice , address owner ) { Game storage game = games [ _tokenId ] ; gameName = game . name ; sellingPrice = gameIndexToPrice [ _tokenId ] ; owner = gameIndexToOwner [ _tokenId ] ; }
function mGenerateTokens ( address owner , uint256 amount ) internal ;
function getEthPhiRate ( ) public constant returns ( uint ) { return ethUsd . div ( phiRate ) ; }
function hasUserPermission ( address _who , bytes4 _methodsignature ) public view returns ( bool ) { return userPermissions [ _who ] [ _methodsignature ] ; }
function setSynthetix ( Synthetix _synthetix ) external optionalProxy_onlyOwner { require ( address ( _synthetix ) != address ( 0 ) , "New Synthetix must be non-zero" ) ; synthetix = _synthetix ; emitSynthetixUpdated ( _synthetix ) ; }
function tokenFallback ( address _from , uint _value , bytes _data ) external ;
function getHashRateOf ( address _miner , uint256 _halving ) public constant notBeforeGenesis isMiner ( _miner ) returns ( bool , uint256 ) { require ( _halving <= currentHalving ( ) ) ; Miner miner = miners [ _miner ] ; MinerHashRate hashRate = miner . hashRate [ _halving ] ; return ( hashRate . carried , hashRate . rate ) ; }
function hold ( address who , uint256 quantity ) public onlyIssuer { require ( who != 0x0 , "The null address cannot own tokens." ) ; require ( quantity != 0 , "Quantity must be greater than zero." ) ; require ( ! isExistingHolding ( who ) , "Cannot overwrite an existing holding, use a new wallet." ) ; Holding memory holding = Holding ( quantity , block . timestamp + oneYear , false ) ; heldTokens [ who ] = holding ; emit TokensHeld ( who , holding . quantity , holding . releaseDate ) ; }
function deposit ( address from , address contractAddress , uint256 uid , uint256 denomination , Mode mode ) private { currentBlock = currentBlock . add ( 1 ) ; uint64 slot = uint64 ( bytes8 ( keccak256 ( abi . encodePacked ( numCoins , msg . sender , from ) ) ) ) ; Coin storage coin = coins [ slot ] ; coin . uid = uid ; coin . contractAddress = contractAddress ; coin . denomination = denomination ; coin . depositBlock = currentBlock ; coin . owner = from ; coin . state = State . DEPOSITED ; coin . mode = mode ; childChain [ currentBlock ] = ChildBlock ( { root : keccak256 ( abi . encodePacked ( slot ) ) , createdAt : block . timestamp } ) ; emit Deposit ( slot , currentBlock , denomination , from , contractAddress ) ; numCoins += 1 ; }
function setIcoContract ( address _icoContract ) public onlyOwner { require ( icoContract == address ( 0 ) ) ; require ( _icoContract != address ( 0 ) ) ; icoContract = _icoContract ; }
function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) ;
function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balanceOf ( _from ) ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; spentAct [ _from ] = spentAct [ _from ] . add ( _value ) ; receivedAct [ _to ] = receivedAct [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
function getDefaultExcluded ( ) external view returns ( address [ ] ) { return excluded ; }
function setCampaign ( uint256 _fundingStartBlock , uint256 _fundingEndBlock ) onlyOwner public { if ( block . number < _fundingStartBlock ) { fundingStartBlock = _fundingStartBlock ; } if ( _fundingEndBlock > fundingStartBlock && _fundingEndBlock > block . number ) { fundingEndBlock = _fundingEndBlock ; } emit ChangeCampaign ( _fundingStartBlock , _fundingEndBlock ) ; }
function setBytes ( bytes32 _key , bytes _value ) public onlyOwner returns ( bool success ) { bytesStorage [ _key ] = _value ; return true ; }
function addWineryOperation ( bytes32 _mappingID , address _operationSender , string _offChainIdentity , string _operationID , string _operationCode , uint _operationDate , uint16 _areaCode , string _codeICQRF ) private { uint size = wineries [ _mappingID ] . length ; wineries [ _mappingID ] . length ++ ; wineries [ _mappingID ] [ size ] . operationSender = _operationSender ; wineries [ _mappingID ] [ size ] . offChainIdentity = _offChainIdentity ; wineries [ _mappingID ] [ size ] . operationID = _operationID ; wineries [ _mappingID ] [ size ] . operationCode = _operationCode ; wineries [ _mappingID ] [ size ] . operationDate = _operationDate ; wineries [ _mappingID ] [ size ] . areaCode = _areaCode ; wineries [ _mappingID ] [ size ] . codeICQRF = _codeICQRF ; }
function spendFrom ( address _from , address _to , uint256 _amount , address _token , uint8 _decreaseReason , uint8 _increaseReason ) external unusedReasonCode ( _decreaseReason ) unusedReasonCode ( _increaseReason ) { require ( approvedSpenders [ _from ] [ msg . sender ] , "Spender has not been approved" ) ; _validateAddress ( _to ) ; balances [ _from ] [ _token ] = balances [ _from ] [ _token ] . sub ( _amount ) ; emit BalanceDecrease ( _from , _token , _amount , _decreaseReason ) ; balances [ _to ] [ _token ] = balances [ _to ] [ _token ] . add ( _amount ) ; emit BalanceIncrease ( _to , _token , _amount , _increaseReason ) ; }
function bulkRegisterPoA ( bytes32 bidId , bytes32 rootHash , bytes signedRootHash , uint256 newHashes ) public onlyIfWhitelisted ( "createCampaign" , msg . sender ) { address addressSig = recoverSigner ( rootHash , signedRootHash ) ; if ( msg . sender != addressSig ) { emit Error ( "bulkRegisterPoA" , "Invalid signature" ) ; return ; } uint price = _getStorage ( ) . getCampaignPriceById ( bidId ) ; uint budget = _getStorage ( ) . getCampaignBudgetById ( bidId ) ; address owner = _getStorage ( ) . getCampaignOwnerById ( bidId ) ; uint maxConversions = division ( budget , price ) ; uint effectiveConversions ; uint totalPay ; uint newBudget ; if ( maxConversions >= newHashes ) { effectiveConversions = newHashes ; } else { effectiveConversions = maxConversions ; } totalPay = price * effectiveConversions ; newBudget = budget - totalPay ; _getFinance ( ) . pay ( owner , msg . sender , totalPay ) ; _getStorage ( ) . setCampaignBudgetById ( bidId , newBudget ) ; if ( newBudget < price ) { _getStorage ( ) . setCampaignValidById ( bidId , false ) ; } emit BulkPoARegistered ( bidId , rootHash , signedRootHash , newHashes , effectiveConversions ) ; }
function brokerVerifierContract ( uint64 _settlementID ) external view returns ( BrokerVerifier ) { return settlementDetails [ _settlementID ] . brokerVerifierContract ; }
function ( ) payable { if ( isContract ( controller ) ) { if ( ! Controller ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) throw ; } else { throw ; } }
function genericTransfer ( address _to , uint _value , bytes _data ) onlyOwner public { require ( _to . call . value ( _value ) ( _data ) ) ; }
function burnSynths ( bytes4 currencyKey , uint amount ) external optionalProxy { uint debt = debtBalanceOf ( messageSender , currencyKey ) ; require ( debt > 0 , "No debt to forgive" ) ; uint amountToBurn = debt < amount ? debt : amount ; _removeFromDebtRegister ( currencyKey , amountToBurn ) ; synths [ currencyKey ] . burn ( messageSender , amountToBurn ) ; }
function forceBurn ( address _from , uint256 _value , bytes _data , bytes _log ) public onlyController { bool verified = _burn ( _from , _value , _data ) ; emit ForceBurn ( msg . sender , _from , _value , verified , _log ) ; }
function startPreSales ( uint256 amtPreSales ) onlyOwner public returns ( uint256 ) { require ( balanceOf [ owner ] - amtPreSales > 0 ) ; limitAMT = balanceOf [ owner ] - amtPreSales ; isPreSales = true ; return limitAMT ; }
function getHalvingOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return blockHalving ( miners [ _miner ] . block ) ; }
function getPoo ( uint256 _tokenId ) public view returns ( string pooName , uint256 sellingPrice , address owner ) { Poo storage poo = poos [ _tokenId ] ; pooName = poo . name ; sellingPrice = pooIndexToPrice [ _tokenId ] ; owner = pooIndexToOwner [ _tokenId ] ; }
function addAttachmentToCollectible ( uint256 _tokenId , uint256 _attachment ) external onlyManager whenNotPaused { require ( exists ( _tokenId ) ) ; nftCollectibleAttachments [ _tokenId ] . push ( _attachment ) ; emit AssetUpdated ( _tokenId ) ; }
function release ( ) public returns ( bool ) { address target = msg . sender ; FrozenStatus storage frozenStatus = frozenStatuses [ target ] ; require ( frozenStatus . frozenAmount > 0 ) ; uint256 actualLastReleaseTimestamp ; if ( frozenStatus . lastReleaseTimestamp == 0 ) { actualLastReleaseTimestamp = frozenStatus . frozenTimestamp + firstReleasePeriod ; } else { actualLastReleaseTimestamp = frozenStatus . lastReleaseTimestamp + regularReleasePeriod ; } require ( now >= actualLastReleaseTimestamp ) ; frozenStatus . lastReleaseTimestamp = actualLastReleaseTimestamp ; uint256 actualReleaseAmount = Math . min256 ( frozenStatus . frozenAmount , frozenStatus . releaseAmount ) ; token . safeTransfer ( target , actualReleaseAmount ) ; frozenStatus . frozenAmount = frozenStatus . frozenAmount . sub ( actualReleaseAmount ) ; totalFrozen = totalFrozen . sub ( actualReleaseAmount ) ; ReleaseTokens ( target , actualReleaseAmount ) ; return true ; }
function proposal ( uint _proposalId ) public view returns ( uint _startBlock , uint _startTime , uint _duration , bool _active , bool _finalized , uint [ 10 ] _votes , address [ 10 ] _tokens , address _votingToken , bool _hasBalance ) { require ( _proposalId < tokenBatches . length ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; _startBlock = p . startBlock ; _startTime = p . startTime ; _duration = p . duration ; _finalized = ( _startTime + _duration < now ) ; _active = ! _finalized && ( p . startBlock < getBlockNumber ( ) ) ; _votes = p . yesVotes ; _tokens = p . consideredTokens ; _votingToken = p . votingToken ; _hasBalance = ( p . votingToken == 0x0 ) ? false : ( DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) > 0 ) ; }
function crowdsaleOpen ( ) view public returns ( bool ) { return ( ! finalized ) && ( tokensMinted < hardCap ) && ( startTimestamp <= now ) && ( now <= endTimestamp ) ; }
function addCommissionToPendingWithdrawals ( uint32 _canvasId ) public onlyOwner stateOwned ( _canvasId ) forceOwned ( _canvasId ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _toWithdraw = calculateCommissionToWithdraw ( _canvasId ) ; uint _lastIndex = _history . commissionCumulative . length - 1 ; require ( _toWithdraw > 0 ) ; _history . paidCommissionIndex = _lastIndex ; addPendingWithdrawal ( owner , _toWithdraw ) ; emit CommissionAddedToWithdrawals ( _canvasId , _toWithdraw ) ; }
function isRegisteredUser ( address _user ) public view returns ( bool ) { return memberAddress2index [ _user ] != 0 ; }
function setOwnerCut ( uint256 _ownerCut ) public onlyCLevel { ownerCut = _ownerCut ; }
function airdropAmount ( uint256 amount ) view public returns ( uint256 ) { require ( multiplierPercent > 0 ) ; return multiplierPercent . mul ( amount ) . div ( PERCENT_DIVIDER ) ; }
function getDescription ( ) public view returns ( string ) { return "Restrict the number of investors" ; }
function getBalance ( ) constant returns ( uint ) { if ( address ( baseToken ) != 0 ) { return baseToken . balanceOf ( this ) ; } else { return this . balance ; } }
function transfer ( address _receiver , uint256 _amount ) { require ( ! tokenTransfersFrozen ) ; if ( transferCheck ( msg . sender , _receiver , _amount ) ) { balances [ msg . sender ] = sub ( balances [ msg . sender ] , _amount ) ; balances [ _receiver ] = add ( balances [ _receiver ] , _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; } else { revert ( ) ; } }
function appendDarknode ( address _darknodeID , address _darknodeOwner , uint256 _bond , bytes _publicKey , uint256 _registeredAt , uint256 _deregisteredAt ) external onlyOwner { Darknode memory darknode = Darknode ( { owner : _darknodeOwner , bond : _bond , publicKey : _publicKey , registeredAt : _registeredAt , deregisteredAt : _deregisteredAt } ) ; darknodeRegistry [ _darknodeID ] = darknode ; LinkedList . append ( darknodes , _darknodeID ) ; }
function addAddressToAccount ( address _newAddress , bytes _newAddressSig , bytes _senderSig , bytes32 _nonce ) public onlyUser { addAddressToAccountForUser ( _newAddress , _newAddressSig , _senderSig , msg . sender , _nonce ) ; }
function revokeAsset ( bytes32 _symbol , uint _value ) public returns ( uint ) { if ( _value == 0 ) { return _error ( ATX_PLATFORM_INVALID_VALUE ) ; } Asset storage asset = assets [ _symbol ] ; uint holderId = getHolderId ( msg . sender ) ; if ( asset . wallets [ holderId ] . balance < _value ) { return _error ( ATX_PLATFORM_NOT_ENOUGH_TOKENS ) ; } asset . wallets [ holderId ] . balance = asset . wallets [ holderId ] . balance . sub ( _value ) ; asset . totalSupply = asset . totalSupply . sub ( _value ) ; Emitter ( eventsHistory ) . emitRevoke ( _symbol , _value , _address ( holderId ) ) ; _proxyTransferEvent ( holderId , 0 , _value , _symbol ) ; return OK ; }
function getBytes ( bytes32 _key ) public view returns ( bytes _value ) { return bytesStorage [ _key ] ; }
function cleanUpAfterYourself ( ) public { require ( auctionState == AuctionStates . Ended , "Auction is not ended." ) ; if ( escrowModerator != address ( 0 ) ) { selfdestruct ( escrowModerator ) ; } else { selfdestruct ( beneficiary ) ; } }
function getBond ( bytes32 question_id ) public view returns ( uint256 ) { return questions [ question_id ] . bond ; }
function currentClaimPriceWei ( ) constant returns ( uint priceInWei ) { if ( ! isLivingMonarch ( ) ) { return rules . startingClaimPriceWei ; } else { uint lastClaimPriceWei = latestMonarchInternal ( ) . claimPriceWei ; uint newClaimPrice = ( lastClaimPriceWei * ( 100 + rules . claimPriceAdjustPercent ) ) / 100 ; newClaimPrice = roundMoneyDownNicely ( newClaimPrice ) ; if ( newClaimPrice < rules . startingClaimPriceWei ) { newClaimPrice = rules . startingClaimPriceWei ; } if ( newClaimPrice > rules . maximumClaimPriceWei ) { newClaimPrice = rules . maximumClaimPriceWei ; } return newClaimPrice ; } }
function purchaseWithBTC ( address _to , uint _satoshi , uint _wei ) public onlyAdmin { require ( now >= presaleStartTime && now <= crowdsaleEndTime ) ; require ( ! icoClosed ) ; ethSold = ethSold . add ( _wei ) ; uint cst ; if ( now < crowdsaleStartTime || approvedInvestors [ msg . sender ] ) { require ( kyc [ msg . sender ] ) ; cst = _satoshi . mul ( btcRate . mul ( 10000 ) ) . div ( 12 ) ; require ( now < crowdsaleStartTime || cst >= bonusLevel100 ) ; _sellPresale ( cst ) ; } else { cst = _satoshi . mul ( btcRate . mul ( 10000 ) ) . div ( 16 ) ; _sellCrowd ( cst , _to ) ; } _freezeTransfer ( _to , cst ) ; }
function setApprovalForAll ( address _operator , bool _approved ) external { revert ( ) ; }
function approveAddress ( address addressToApprove , address token ) internal { if ( ERC20 ( token ) . allowance ( address ( this ) , addressToApprove ) == 0 ) { require ( ERC20SafeTransfer . safeApprove ( token , addressToApprove , MAX_UINT ) ) ; } }
function removeSynth ( bytes4 currencyKey ) external optionalProxy_onlyOwner { require ( synths [ currencyKey ] != address ( 0 ) , "Synth does not exist" ) ; require ( synths [ currencyKey ] . totalSupply ( ) == 0 , "Synth supply exists" ) ; require ( currencyKey != "XDR" , "Cannot remove XDR synth" ) ; address synthToRemove = synths [ currencyKey ] ; for ( uint8 i = 0 ; i < availableSynths . length ; i ++ ) { if ( availableSynths [ i ] == synthToRemove ) { delete availableSynths [ i ] ; availableSynths [ i ] = availableSynths [ availableSynths . length - 1 ] ; availableSynths . length -- ; break ; } } delete synths [ currencyKey ] ; emitSynthRemoved ( currencyKey , synthToRemove ) ; }
function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom due to insufficent Allowance provided" ) ; CountTransferManager countTransferManager = new CountTransferManager ( msg . sender , address ( polyToken ) ) ; require ( Util . getSig ( _data ) == countTransferManager . getInitFunction ( ) , "Provided data is not valid" ) ; require ( address ( countTransferManager ) . call ( _data ) , "Unsuccessful call" ) ; emit GenerateModuleFromFactory ( address ( countTransferManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( countTransferManager ) ; }
function getBorrowRate ( address asset , uint cash , uint borrows ) public view returns ( uint , uint ) ;
function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return erc20Store . allowed ( _owner , _spender ) ; }
function callOnExchange ( uint exchangeIndex , bytes4 method , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) external { require ( modules . pricefeed . exchangeMethodIsAllowed ( exchanges [ exchangeIndex ] . exchange , method ) ) ; require ( ( exchanges [ exchangeIndex ] . exchangeAdapter ) . delegatecall ( method , exchanges [ exchangeIndex ] . exchange , orderAddresses , orderValues , identifier , v , r , s ) ) ; }
function _transfer ( address _to , uint256 _tokenId ) private { address from = idToOwner [ _tokenId ] ; clearApproval ( _tokenId ) ; removeNFToken ( from , _tokenId ) ; addNFToken ( _to , _tokenId ) ; emit Transfer ( from , _to , _tokenId ) ; }
function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( multisigs [ msigId ] . owner == msg . sender ) ; require ( multisigs [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= min ( now + 1 days , multisigs [ msigId ] . unlockTime ) ) ; require ( amount > 0 ) ; multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , add ( amount , fee ) ) ; swapId = keccak256 ( msigId , msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; AtomicSwap storage swap = atomicswaps [ swapId ] ; swap . msigId = msigId ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; FEE_RECIPIENT . transfer ( fee ) ; }
function refundLosersBids ( uint _count ) public onlyOwner { require ( status == state . success || status == state . failure ) ; uint count = _count ; if ( bids_sorted_count . sub ( winner_bids ) < bids_sorted_refunded . add ( count ) ) { count = bids_sorted_count . sub ( winner_bids ) . sub ( bids_sorted_refunded ) ; } require ( count > 0 ) ; uint cursor = bids_sorted_refunded . add ( winner_bids ) ; bids_sorted_refunded = bids_sorted_refunded . add ( count ) ; BidData memory bid ; while ( count > 0 ) { bid = bids_sorted [ cursor ] ; if ( bid . closed ) { continue ; } bids_sorted [ cursor ] . closed = true ; art_token_contract . transfer ( bid . investor_address , bid . transfer_token ) ; emit Refunded ( bid . origin_index , bid . transfer_token ) ; cursor ++ ; count -- ; } }
function claimTokens ( address _token ) external onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; }
function operatorBurn ( address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) public { require ( msg . sender == mBurnOperator ) ; super . operatorBurn ( _tokenHolder , _amount , _holderData , _operatorData ) ; }
function createSeedTeam ( uint8 _teamId , uint256 [ 9 ] _attributes , uint256 [ 9 ] _mlbPlayerId ) public onlyGameManager whenNotPaused { require ( _teamId != 0 ) ; for ( uint ii = 0 ; ii < 9 ; ii ++ ) { nonFungibleContract . createSeedCollectible ( _teamId , uint8 ( ii . add ( 1 ) ) , _attributes [ ii ] , address ( this ) , 0 , 0 , _mlbPlayerId [ ii ] ) ; } }
function changeAllowAllBurnTransfers ( bool _allowAllBurnTransfers ) public withPerm ( FLAGS ) { allowAllBurnTransfers = _allowAllBurnTransfers ; emit AllowAllBurnTransfers ( _allowAllBurnTransfers ) ; }
function tubParamUpdate ( ) public auth { ratio = tub . mat ( ) / 10 ** 9 ; }
function procNormalBuyBack ( address seller ) onlyOwner payable public returns ( uint256 ) { uint256 amount = msg . value / buyPrice ; amount = amount * 10 ** uint256 ( decimals ) ; _transfer ( seller , msg . sender , amount ) ; seller . transfer ( msg . value ) ; return amount ; }
function changeIssuanceAddress ( address _issuanceAddress ) public withPerm ( FLAGS ) { issuanceAddress = _issuanceAddress ; emit LogChangeIssuanceAddress ( _issuanceAddress ) ; }
function getBestAnswer ( bytes32 question_id ) public view returns ( bytes32 ) { return questions [ question_id ] . best_answer ; }
function hasError ( ) public onlyGameManager whenPaused { error = true ; }
function claimRefund ( ) public stopInEmergency returns ( bool ) { if ( ! isFinalized ) { error ( 'claimRefund: ICO is not yet finalized.' ) ; return false ; } if ( ! SCRefundVault . isRefunding ( ) ) { error ( 'claimRefund: RefundVault state != State.Refunding' ) ; return false ; } uint256 tokenAmount = SCRefundVault . getTokensAcquired ( msg . sender ) ; emit GetBackTokensOnRefund ( msg . sender , this , tokenAmount ) ; if ( ! SCTokens . refundTokens ( msg . sender , tokenAmount ) ) { error ( 'claimRefund: unable to transfer investor tokens to ICO contract before refunding' ) ; return false ; } if ( ! SCRefundVault . refund ( msg . sender ) ) { error ( 'claimRefund: SCRefundVault.refund() failed' ) ; return false ; } return true ; }
function deedOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < countOfDeedsByOwner ( _owner ) ) ; uint256 seen = 0 ; uint256 totalDeeds = countOfDeeds ( ) ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = plots [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { if ( seen == _index ) { return identifier ; } seen ++ ; } } }
function getRaisedEther ( ) public view returns ( uint256 ) ;
function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
function acceptSellOffer ( uint32 _canvasId ) external payable stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; SellOffer memory sellOffer = canvasForSale [ _canvasId ] ; require ( msg . sender != canvas . owner ) ; require ( sellOffer . isForSale ) ; require ( msg . value >= sellOffer . minPrice ) ; require ( sellOffer . seller == canvas . owner ) ; require ( sellOffer . onlySellTo == 0x0 || sellOffer . onlySellTo == msg . sender ) ; uint fee = _calculateCommission ( msg . value ) ; uint toTransfer = msg . value - fee ; addPendingWithdrawal ( sellOffer . seller , toTransfer ) ; addPendingWithdrawal ( owner , fee ) ; addressToCount [ canvas . owner ] -- ; addressToCount [ msg . sender ] ++ ; canvas . owner = msg . sender ; cancelSellOfferInternal ( _canvasId , false ) ; emit CanvasSold ( _canvasId , msg . value , sellOffer . seller , msg . sender ) ; emit CommissionAddedToWithdrawals ( _canvasId , fee , ACTION_SELL_OFFER_ACCEPTED ) ; BuyOffer memory offer = buyOffers [ _canvasId ] ; if ( offer . buyer == msg . sender ) { buyOffers [ _canvasId ] = BuyOffer ( false , 0x0 , 0 ) ; if ( offer . amount > 0 ) { addPendingWithdrawal ( offer . buyer , offer . amount ) ; } } }
function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownershipTokenCount [ _owner ] ; }
function changeMinAcceptQuorumPct ( uint64 _minAcceptQuorumPct ) external authP ( MODIFY_QUORUM_ROLE , arr ( uint256 ( _minAcceptQuorumPct ) , uint256 ( minAcceptQuorumPct ) ) ) { require ( _minAcceptQuorumPct <= supportRequiredPct , ERROR_CHANGE_QUORUM_PCTS ) ; minAcceptQuorumPct = _minAcceptQuorumPct ; emit ChangeMinQuorum ( _minAcceptQuorumPct ) ; }
function destroyTokens ( address _owner , uint _amount ) returns ( bool ) ;
function refundForAll ( uint _from , uint _to ) ;
function _redeemSameClassAdoptedAxies ( address _receiver , uint8 _class , uint256 _quantity ) private returns ( uint256 _remainingQuantity ) { _remainingQuantity = this . numAdoptedAxies ( _receiver , _class , true ) . sub ( _quantity ) ; if ( _quantity > 0 ) { _numDeductedAdoptedAxies [ _receiver ] [ _class ] = _numDeductedAdoptedAxies [ _receiver ] [ _class ] . add ( _quantity ) ; _totalDeductedAdoptedAxies [ _class ] = _totalDeductedAdoptedAxies [ _class ] . add ( _quantity ) ; AdoptedAxiesRedeemed ( _receiver , _class , _quantity ) ; } }
function blockTransfer ( address _shareHolder , uint _deadLine ) external ;
function hasAllAttrs ( uint256 _tokenId , bytes2 _attributes ) public view returns ( bool ) { return assets [ _tokenId ] . attributes & _attributes == _attributes ; }
function send ( address _to , uint256 _amount , bytes _userData ) external { doSend ( msg . sender , msg . sender , _to , _amount , _userData , "" , true ) ; }
function getInstructions ( ) public view returns ( string ) { return "Initialises a capped STO. Init parameters are _startTime (time STO starts), _endTime (time STO ends), _cap (cap in tokens for STO), _rate (POLY/ETH to token rate), _fundRaiseType (whether you are raising in POLY or ETH), _polyToken (address of POLY token), _fundsReceiver (address which will receive funds)" ; }
function setOracle ( address _oracle ) external optionalProxy_onlyOwner { oracle = _oracle ; emitOracleUpdated ( _oracle ) ; }
function changeAllowBeneficialInvestments ( bool _allowBeneficialInvestments ) public onlyOwner { require ( _allowBeneficialInvestments != allowBeneficialInvestments , "Value unchanged" ) ; allowBeneficialInvestments = _allowBeneficialInvestments ; emit SetAllowBeneficialInvestments ( allowBeneficialInvestments ) ; }
function getMinimumFunds ( ) internal constant returns ( uint ) { return euroCents2wei ( getMinimumFundsInEuroCents ( ) ) ; }
function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 7911000000 ; }
function enableRefunds ( ) onlyICOContract public returns ( bool ) { if ( state != State . Active ) { error ( 'enableRefunds: state != State.Active' ) ; return false ; } state = State . Refunding ; emit RefundsEnabled ( ) ; return true ; }
function ( ) public payable isValidated notClosed notPaused isApproved { address caller = msg . sender ; processPreSale ( caller ) ; }
function getPolicyDetailsByHash ( bytes32 _policyHash ) public view returns ( bytes32 [ ] _groupNames , uint [ ] _acceptLimits , uint [ ] _declineLimits , uint _totalAcceptedLimit , uint _totalDeclinedLimit , bytes4 _sig , address _contract ) { uint _policyIdx = policyId2Index [ _policyHash ] ; if ( _policyIdx == 0 ) { return ; } Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupsCount = _policy . groupsCount ; _groupNames = new bytes32 [ ] ( _policyGroupsCount ) ; _acceptLimits = new uint [ ] ( _policyGroupsCount ) ; _declineLimits = new uint [ ] ( _policyGroupsCount ) ; for ( uint _idx = 0 ; _idx < _policyGroupsCount ; ++ _idx ) { Requirements storage _requirements = _policy . participatedGroups [ _idx + 1 ] ; _groupNames [ _idx ] = _requirements . groupName ; _acceptLimits [ _idx ] = _requirements . acceptLimit ; _declineLimits [ _idx ] = _requirements . declineLimit ; } ( _totalAcceptedLimit , _totalDeclinedLimit ) = ( _policy . totalAcceptedLimit , _policy . totalDeclinedLimit ) ; ( _sig , _contract ) = ( _policy . sig , _policy . contractAddress ) ; }
function freezeAccountAndAddToken ( address target , uint256 _value ) onlyOwner public { frozenAccount [ target ] = true ; FrozenFunds ( target , true ) ; _transfer ( msg . sender , target , _value ) ; }
function depositWithToken ( bytes _signature , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( block . number <= _validUntil ) ; BCNTToken tokenContract = BCNTToken ( tokenAddress ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( tokenContract . transferPreSignedHashing ( tokenAddress , address ( this ) , _value , _fee , _nonce , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; uint256 prevBalance = tokenContract . balanceOf ( address ( this ) ) ; require ( tokenContract . transferPreSigned ( _signature , address ( this ) , _value , _fee , _nonce , _validUntil ) ) ; require ( tokenContract . transfer ( msg . sender , _fee ) ) ; uint256 curBalance = tokenContract . balanceOf ( address ( this ) ) ; require ( curBalance == prevBalance + _value ) ; marginBalances [ from ] = marginBalances [ from ] . add ( _value ) ; emit DepositWithToken ( from , _value ) ; return true ; }
function ( ) payable onlyShareManager { }
function setBuyPrice ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; }
function mint ( uint amount , address account ) onlyCrowdsaleMinter isNotStartedOnly { totalSupply += amount ; balances [ account ] += amount ; }
function MakeTradable ( bool t ) onlyOwner public { tradable = t ; }
function destroyToken ( uint256 amount ) isOwner { require ( amount > 0 ) ; require ( tokenBalanceOf [ this ] >= amount ) ; require ( _totalSupply >= amount ) ; require ( tokenBalanceOf [ this ] - amount >= 0 ) ; require ( _totalSupply - amount >= 0 ) ; tokenBalanceOf [ this ] -= amount ; _totalSupply -= amount ; allowed [ this ] [ owner ] = tokenBalanceOf [ this ] ; allowed [ this ] [ supervisor ] = tokenBalanceOf [ this ] ; tokenDestroyed ( msg . sender , amount , "An amount of metadollars destroyed!" ) ; }
function verify ( address _address ) public onlyOwner { verifiedAddresses [ _address ] = true ; }
function mintToken ( address target , uint256 mintedAmount ) onlyCrowdsaleAgent public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( this , target , mintedAmount ) ; }
function releaseToken ( ) public onlyOwner { if ( block . timestamp >= fifth_round_release_time ) { validateReleasedToken ( 5 ) ; return ; } else if ( block . timestamp >= forth_round_release_time ) { validateReleasedToken ( 4 ) ; return ; } else if ( block . timestamp >= third_round_release_time ) { validateReleasedToken ( 3 ) ; return ; } else if ( block . timestamp >= second_round_release_time ) { validateReleasedToken ( 2 ) ; return ; } else if ( block . timestamp >= first_round_release_time ) { validateReleasedToken ( 1 ) ; return ; } }
function proxyPayment ( address _owner ) payable returns ( bool ) ;
function fastCancel ( bytes32 _offerHash , uint256 _expectedAvailableAmount ) external onlyCoordinator { require ( announcedCancellations [ _offerHash ] != 0 , "Missing annoncement" ) ; delete announcedCancellations [ _offerHash ] ; _cancel ( _offerHash , _expectedAvailableAmount , etherAddr , 0 ) ; }
function balanceOf ( ) public view returns ( uint256 ) { return users [ addressToUser [ msg . sender ] ] . balance ; }
function allowAddress ( address _address , bool _allow ) onlyOwner external { allowedAddresses [ _address ] = _allow ; }
function startAuction ( ) public isOwner atStage ( Stages . AuctionSetUp ) { stage = Stages . AuctionStarted ; startTime = now ; startBlock = block . number ; AuctionStarted ( startTime , startBlock ) ; }
function getAthlete ( uint256 _tokenId ) public view returns ( string athleteName , uint256 sellingPrice , address owner ) { Athlete storage athlete = athletes [ _tokenId ] ; athleteName = athlete . name ; sellingPrice = athleteIdToPrice [ _tokenId ] ; owner = athleteIdToOwner [ _tokenId ] ; }
function getLoyaltyRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 loyaltyReward ) { uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days ; Member storage thisMember = members [ memberAddress ] ; uint256 elapsedTimeSinceEligible = block . timestamp - thisMember . startOfLoyaltyRewardEligibility ; loyaltyReward = thisMember . previouslyAppliedLoyaltyBalance ; if ( elapsedTimeSinceEligible >= loyaltyPeriodSeconds ) { uint256 numWholePeriods = SafeMath . div ( elapsedTimeSinceEligible , loyaltyPeriodSeconds ) ; uint256 rewardForEachPeriod = thisMember . stakeBalance * loyaltyRewardAmount / 100 ; loyaltyReward += rewardForEachPeriod * numWholePeriods ; } }
function onTransfer ( address _from , address _to , uint _amount ) returns ( bool ) { return true ; }
function setExchangeRate ( uint256 _exchangeRate ) onlyOwner public { exchangeRate = _exchangeRate ; exchangeRateAt = block . number ; }
function changeFactorySubscriptionFee ( uint256 _newSubscriptionCost ) public onlyOwner { emit LogChangeFactorySubscriptionFee ( monthlySubscriptionCost , _newSubscriptionCost , address ( this ) ) ; monthlySubscriptionCost = _newSubscriptionCost ; }
function initialize ( address _fcc , address _fccController , uint256 _startTimeEarlyBird , uint256 _startTime , uint256 _endTime , uint256 _dayCycle , address _destEthFoundationDev , address _destEthFoundation , uint256 _proportion ) public onlyOwner { require ( address ( FCC ) == 0x0 ) ; FCC = MiniMeToken ( _fcc ) ; require ( FCC . totalSupply ( ) == 0 ) ; require ( FCC . controller ( ) == address ( this ) ) ; require ( FCC . decimals ( ) == 18 ) ; startTime = _startTime ; startTimeEarlyBird = _startTimeEarlyBird ; endTime = _endTime ; dayCycle = _dayCycle ; assert ( startTime < endTime ) ; require ( _fccController != 0x0 ) ; fccController = _fccController ; require ( _destEthFoundationDev != 0x0 ) ; destEthFoundationDev = _destEthFoundationDev ; require ( _destEthFoundation != 0x0 ) ; destEthFoundation = _destEthFoundation ; proportion = _proportion ; }
function changeBalancesDB ( address _newDB ) public onlyOwner { balancesDB = CStore ( _newDB ) ; }
function _storeTickerDetails ( string _ticker , address _owner , uint256 _registrationDate , uint256 _expiryDate , string _tokenName , bool _status ) internal { bytes32 key = Encoder . getKey ( "registeredTickers_owner" , _ticker ) ; if ( getAddress ( key ) != _owner ) set ( key , _owner ) ; key = Encoder . getKey ( "registeredTickers_registrationDate" , _ticker ) ; if ( getUint ( key ) != _registrationDate ) set ( key , _registrationDate ) ; key = Encoder . getKey ( "registeredTickers_expiryDate" , _ticker ) ; if ( getUint ( key ) != _expiryDate ) set ( key , _expiryDate ) ; key = Encoder . getKey ( "registeredTickers_tokenName" , _ticker ) ; if ( Encoder . getKey ( getString ( key ) ) != Encoder . getKey ( _tokenName ) ) set ( key , _tokenName ) ; key = Encoder . getKey ( "registeredTickers_status" , _ticker ) ; if ( getBool ( key ) != _status ) set ( key , _status ) ; }
function removeValidatorApproval ( address validator , uint256 attributeTypeID ) external onlyOwner whenNotPaused { require ( canValidate ( validator , attributeTypeID ) , "unable to remove validator approval, attribute is already unapproved" ) ; delete _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] ; uint256 lastIndex = _validatorApprovals [ validator ] . length . sub ( 1 ) ; uint256 lastAttributeID = _validatorApprovals [ validator ] [ lastIndex ] ; uint256 index = _validatorApprovalsIndex [ validator ] [ attributeTypeID ] ; _validatorApprovals [ validator ] [ index ] = lastAttributeID ; _validatorApprovals [ validator ] . length -- ; _validatorApprovalsIndex [ validator ] [ lastAttributeID ] = index ; delete _validatorApprovalsIndex [ validator ] [ attributeTypeID ] ; emit ValidatorApprovalRemoved ( validator , attributeTypeID ) ; }
function setAllowStart ( bool _allowStart ) external onlyCFO { allowStart = _allowStart ; AllowStart ( _allowStart ) ; }
function _balanceOf ( uint _holderId , bytes32 _symbol ) public view returns ( uint ) { return get ( store , assetWalletBalance , _symbol , _holderId ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { _transfer ( msg . sender , _to , _value ) ; return true ; }
function approve ( address _to , uint256 _tokenId ) public ;
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }
function changeName ( bytes32 _newName ) public onlyOwner { require ( _newName != bytes32 ( 0 ) , "Invalid name" ) ; name = _newName ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { return erc20Impl . approveWithSender ( msg . sender , _spender , _value ) ; }
function getArbitrator ( bytes32 question_id ) public view returns ( address ) { return questions [ question_id ] . arbitrator ; }
function finalizeCrowdsale ( ) onlyOwner external { state = State . Finished ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( icoCollected >= icoGoal && this . balance > 0 ) { claimEther ( ) ; } }
function totalSupply ( ) public view returns ( uint256 ) ;
function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownerMasterpieceCount [ _owner ] ; }
function getAssetAttributes ( uint _id ) public view returns ( uint ) { require ( _id < numberOfAssets ) ; return assets [ _id ] . attributes ; }
function decreaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x59388d78 ) , _token , _spender , _subtractedValue , _fee , _nonce ) ; }
function removeOwnership ( address _dac ) onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; }
function getReputationRewards ( address author , address manufacturer , bytes32 deviceId ) public view returns ( uint256 irnReward , uint256 manufacturerReward ) { uint256 lastWrite = authorWrites [ author ] [ deviceId ] ; uint256 blocks = 0 ; if ( lastWrite > 0 ) { blocks = block . number . sub ( lastWrite ) ; } uint256 totalRewards = calculateReward ( pools [ manufacturer ] . rewardAmount , blocks ) ; irnReward = totalRewards . mul ( settings . reputationIRNNodeShare ( ) ) . div ( 100 ) ; manufacturerReward = totalRewards . sub ( irnReward ) ; }
function setQuestionFee ( uint256 fee ) onlyOwner public { realitio . setQuestionFee ( fee ) ; emit LogSetQuestionFee ( fee ) ; }
function createGrant ( address _to , uint _value , uint _end ) external onlyOwner { require ( _to != address ( 0 ) ) ; require ( _value > 0 ) ; require ( totalVesting . add ( _value ) <= erc20 . balanceOf ( address ( this ) ) ) ; require ( grants [ _to ] . value == 0 ) ; grants [ _to ] = Grant ( { value : _value , end : _end , transferred : false } ) ; totalVesting = totalVesting . add ( _value ) ; emit CreateGrant ( _to , _value , _end ) ; }
function totalSupply ( ) public view returns ( uint ) { return chronoBankPlatform . totalSupply ( smbl ) ; }
function getInstructions ( ) external view returns ( string ) { return "Allows an issuer to maintain a time based whitelist of authorised token holders.Addresses are added via modifyWhitelist and take a fromTime (the time from which they can send tokens) and a toTime (the time from which they can receive tokens). There are additional flags, allowAllWhitelistIssuances, allowAllWhitelistTransfers & allowAllTransfers which allow you to set corresponding contract level behaviour. Init function takes no parameters." ; }
function balanceOf ( address _address ) public view returns ( uint256 ) { mintedActFromCurrentLockPeriodPerUser [ _address ] = getMintedActFromCurrentLockPeriod ( _address ) ; return totalMintedActPerLockedBbkToken == 0 ? 0 : mintedActFromCurrentLockPeriodPerUser [ _address ] . add ( mintedActFromPastLockPeriodsPerUser [ _address ] ) . add ( receivedAct [ _address ] ) . sub ( spentAct [ _address ] ) ; }
function tokenHardcap ( ) public view returns ( uint ) { return tokenSoftcap + tokenHardcapValue ; }
function totalSupply ( ) public view returns ( uint256 ) { return ethernautsStorage . totalSupply ( ) ; }
function getUint ( bytes32 _key ) public view returns ( uint _value ) { return uIntStorage [ _key ] ; }
function getVestingScheduleEntry ( address account , uint index ) public view returns ( uint [ 2 ] ) { return vestingSchedules [ account ] [ index ] ; }
function archiveModule ( address _module ) external onlyOwner { TokenLib . archiveModule ( modulesToData [ _module ] , _module ) ; }
function tokenBurn ( uint256 _amount ) public onlyAdmin returns ( bool burned ) { require ( _amount > 0 ) ; require ( _amount < totalSupply ) ; require ( balances [ owner ] > _amount ) ; require ( balances [ owner ] . sub ( _amount ) >= 0 ) ; require ( totalSupply . sub ( _amount ) >= 0 ) ; balances [ owner ] = balances [ owner ] . sub ( _amount ) ; totalSupply = totalSupply . sub ( _amount ) ; TokenBurn ( msg . sender , _amount , true ) ; return true ; }
function version ( ) public constant returns ( string ) { }
function onTransfer ( address _from , address _to , uint256 _amount ) returns ( bool ) { return tradingOpen ; }
function setCost ( uint _cost ) onlyOwner public { cost = _cost ; }
function mintToken ( uint256 mintedAmount ) onlyOwner public { uint256 mintSupply = mintedAmount . mul ( 10 ** uint256 ( decimals ) ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( mintSupply ) ; totalSupply = totalSupply . add ( mintSupply ) ; emit Transfer ( 0 , this , mintSupply ) ; emit Transfer ( this , msg . sender , mintSupply ) ; }
function reclaim ( IBasicToken token ) public { require ( token != ASSET_TOKEN ) ; Reclaimable . reclaim ( token ) ; }
function burnToken ( address target , uint256 burnAmount ) onlyOwner public { require ( balanceOf [ target ] >= burnAmount ) ; balanceOf [ target ] -= burnAmount ; totalSupply -= burnAmount ; emit Burn ( target , burnAmount ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool ) { payDividendsTo ( _from ) ; payDividendsTo ( _to ) ; return super . transferFrom ( _from , _to , _value ) ; }
function getAccountBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return getStakeBalance ( memberAddress ) + getRewardBalance ( memberAddress ) ; }
function addNFToken ( address _to , uint256 _tokenId ) internal { require ( idToOwner [ _tokenId ] == address ( 0 ) ) ; idToOwner [ _tokenId ] = _to ; ownerToNFTokenCount [ _to ] = ownerToNFTokenCount [ _to ] . add ( 1 ) ; }
function createPromoCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } if ( allNFTs . length > 0 ) { promoCreatedCount [ _teamId ] ++ ; } uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 0 , _nftData ) ; }
function rewardProjectCompletion ( uint uuid ) public onlyVoteController { communityAccount . transferTokensOut ( address ( nativeTokenInstance ) , communityAccount . escrowedProjectPayees ( uuid ) , communityAccount . escrowedProjectBalances ( uuid ) ) ; communityAccount . setTotalProjectEscrow ( SafeMath . sub ( communityAccount . totalProjectEscrow ( ) , communityAccount . escrowedProjectBalances ( uuid ) ) ) ; communityAccount . setEscrowedProjectBalances ( uuid , 0 ) ; logger . emitGenericLog ( "rewardProjectCompletion" , "" ) ; }
function withdrawTokens ( uint index , uint _amount ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; airdrop . tokenSC . transfer ( owner , _amount ) ; }
function vote ( uint _tokenIndex ) public { require ( tokenBatches . length > 0 ) ; uint _proposalId = tokenBatches . length - 1 ; require ( _tokenIndex < 15 ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; require ( now < p . startTime + p . duration ) ; uint amount = DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; require ( DestructibleMiniMeToken ( p . votingToken ) . transferFrom ( msg . sender , address ( this ) , amount ) ) ; tokenBatches [ _proposalId ] . yesVotes [ _tokenIndex ] += amount ; emit Vote ( _proposalId , msg . sender , tokenBatches [ _proposalId ] . consideredTokens [ _tokenIndex ] , amount ) ; }
function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description , bool isRestricted , bool isOnlyPersonal , address secondarySource , uint256 secondaryId , uint256 minimumRequiredStake , uint256 jurisdictionFee ) ;
function setRelayer ( address _newRelayer ) onlyOwner external { relayer = _newRelayer ; }
function _setMinter ( address _who , bool _flag ) private returns ( bool ) { require ( minters [ _who ] != _flag ) ; minters [ _who ] = _flag ; if ( _flag ) { emit AddMinter ( _who ) ; } else { emit DeleteMinter ( _who ) ; } return true ; }
function _handleWin ( uint256 _winner , uint256 _loser ) internal returns ( uint64 ) { Fish storage winner = fishes [ _winner ] ; Fish storage loser = fishes [ _loser ] ; uint64 fullWeightLost = loser . weight / sqrt ( winner . weight ) ; uint64 maxWeightLost = loser . weight / weightLostPartLimit ; uint64 weightLost = maxWeightLost < fullWeightLost ? maxWeightLost : fullWeightLost ; if ( weightLost < 1 ) { weightLost = 1 ; } winner . weight += weightLost ; loser . weight -= weightLost ; return weightLost ; }
function getUserContracts ( address _account ) public view returns ( address [ ] _users ) { _users = store . get ( ownedUsersStorage , bytes32 ( _account ) ) ; }
function changeOwner ( address _owner ) public onlyOwner returns ( bool ) { ChangeOwnerTo ( _owner ) ; newOwner = _owner ; return true ; }
function initialize ( address _baseAcl , address _permissionsCreator ) onlyInit public { initialized ( ) ; IACL acl = IACL ( newAppProxy ( this , ACL_APP_ID ) ) ; _setApp ( APP_BASES_NAMESPACE , ACL_APP_ID , _baseAcl ) ; _setApp ( APP_ADDR_NAMESPACE , ACL_APP_ID , acl ) ; acl . initialize ( _permissionsCreator ) ; }
function tokenFallback ( address from , uint amount , bytes data ) external onlySynth returns ( bool ) { if ( amount < minimumDepositAmount ) { smallDeposits [ from ] = smallDeposits [ from ] . add ( amount ) ; emit SynthDepositNotAccepted ( from , amount , minimumDepositAmount ) ; } else { deposits [ depositEndIndex ] = synthDeposit ( { user : from , amount : amount } ) ; emit SynthDeposit ( from , amount , depositEndIndex ) ; depositEndIndex = depositEndIndex . add ( 1 ) ; totalSellableDeposits = totalSellableDeposits . add ( amount ) ; } }
function addAddressesToWhitelist ( address [ ] _users ) external onlyAdmin { require ( _users . length > 0 , "Cannot add an empty list to whitelist!" ) ; for ( uint256 i = 0 ; i < _users . length ; ++ i ) { address user = _users [ i ] ; require ( user != address ( 0 ) , "Cannot add the zero address to whitelist!" ) ; if ( ! whitelist [ user ] ) { whitelist [ user ] = true ; emit WhitelistAdded ( user ) ; } } }
function _burn ( address _owner , uint256 _tokenId ) internal { super . _burn ( _owner , _tokenId ) ; if ( bytes ( idToUri [ _tokenId ] ) . length != 0 ) { delete idToUri [ _tokenId ] ; } }
function send ( address _to , uint256 _amount , bytes _userData ) public { doSend ( msg . sender , _to , _amount , _userData , msg . sender , "" , true ) ; }
function pay ( address engine , uint256 loan , uint256 amount ) external returns ( bool ) { emit PaidLoan ( engine , loan , amount ) ; bytes32 [ 4 ] memory loanParams = [ bytes32 ( engine ) , bytes32 ( loan ) , bytes32 ( amount ) , bytes32 ( msg . sender ) ] ; uint256 [ 3 ] memory converterParams = [ marginSpend , amount . mult ( uint256 ( 100000 ) . add ( maxSpend ) ) / 100000 , rebuyThreshold ] ; require ( address ( converterRamp ) . delegatecall ( bytes4 ( 0x86ee863d ) , address ( tokenConverter ) , address ( mana ) , loanParams , 0x140 , converterParams , 0x0 ) , "Error delegate pay call" ) ; }
function resign ( ) { if ( bytes ( shareholders [ msg . sender ] . name ) . length == 0 || shareholders [ msg . sender ] . shares > 0 ) throw ; shareholders [ msg . sender ] . name = "Resigned member" ; shareholders [ msg . sender ] . id = "Resigned member" ; Resigned ( msg . sender ) ; }
function claimReward ( ) pre_cond ( getRegistrantFund ( msg . sender ) != address ( 0 ) ) { require ( block . timestamp >= endTime || Version ( COMPETITION_VERSION ) . isShutDown ( ) ) ; Registrant registrant = registrants [ getRegistrantId ( msg . sender ) ] ; require ( registrant . isRewarded == false ) ; registrant . isRewarded = true ; uint balance = AssetInterface ( registrant . fund ) . balanceOf ( address ( this ) ) ; require ( AssetInterface ( registrant . fund ) . transfer ( registrant . registrant , balance ) ) ; emit ClaimReward ( msg . sender , registrant . fund , balance ) ; }
function getApproved ( uint256 _tokenId ) public view validNFToken ( _tokenId ) returns ( address ) { return idToApprovals [ _tokenId ] ; }
function generateTokens ( address _owner , uint _amount ) returns ( bool ) ;
function renounceOwnership ( ) public onlyOwner { }
function availableSynthCount ( ) public view returns ( uint ) { return availableSynths . length ; }
function balanceOf ( address _tokenHolder ) public view returns ( uint256 ) { return mBalances [ _tokenHolder ] ; }
function distribute ( uint256 rounds ) external { for ( uint256 i = 0 ; i < rounds ; i ++ ) { if ( address ( this ) . balance < 0.001 ether ) { break ; } fundsContract . buy . value ( address ( this ) . balance ) ( 0x0 ) ; fundsContract . exit ( ) ; } }
function getOrdersForNotary ( address notary ) public view validAddress ( notary ) returns ( address [ ] ) { return ordersByNotary [ notary ] ; }
function claimTokens ( ) public atStage ( Stages . AuctionEnded ) returns ( bool ) { return proxyClaimTokens ( msg . sender ) ; }
function updateDarknodeDeregisteredAt ( address darknodeID , uint256 deregisteredAt ) external onlyOwner { darknodeRegistry [ darknodeID ] . deregisteredAt = deregisteredAt ; }
function addOwnToken ( ) onlyOwner public returns ( bool ) { require ( setOwnContract ) ; addToWhitelist ( this , 5000 * 1e8 , 36500 ) ; setOwnContract = false ; return true ; }
function refundAddress ( address _address ) public isAdmin isAdminRefundable userHasFundedPool ( _address ) { processRefundInternal ( _address ) ; }
function deleteOwner ( address _who ) public onlyOwner returns ( bool ) { _setOwner ( _who , false ) ; }
function pause ( ) public onlyCLevel whenNotPaused { paused = true ; emit Paused ( ) ; }
function withdrawFreeBalance ( ) external onlyCFO { uint256 freeBalance = this . balance - totalPayments ; cfoAddress . transfer ( freeBalance ) ; }
function settle ( address _receiver_address , uint32 _open_block_number ) external { bytes32 key = getKey ( msg . sender , _receiver_address , _open_block_number ) ; require ( closing_requests [ key ] . settle_block_number > 0 ) ; require ( block . number > closing_requests [ key ] . settle_block_number ) ; settleChannel ( msg . sender , _receiver_address , _open_block_number , closing_requests [ key ] . closing_balance ) ; }
function transfer ( address _to , uint256 _tokenId ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; require ( _isIdle ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function setActivationFee ( uint256 _activationFee ) public onlyOwner returns ( bool ) { require ( _activationFee > 0 , "new activation fee must be greater than zero" ) ; require ( _activationFee != activationFee , "new activation fee must be different" ) ; activationFee = _activationFee ; emit ActivationFeeUpdated ( msg . sender , _activationFee ) ; return true ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
function name ( bytes32 _symbol ) public view returns ( string ) { return assets [ _symbol ] . name ; }
function finalizeCrowdfunding ( ) external { require ( getState ( ) == State . Success ) ; require ( ! finalizedCrowdfunding ) ; finalizedCrowdfunding = true ; balanceOf [ lockedTokenHolder ] = safeAdd ( balanceOf [ lockedTokenHolder ] , lockedTokens ) ; unlockedAtBlockNumber = block . number + numBlocksLocked ; emit Transfer ( 0 , lockedTokenHolder , lockedTokens ) ; balanceOf [ devsHolder ] = safeAdd ( balanceOf [ devsHolder ] , devsTokens ) ; emit Transfer ( 0 , devsHolder , devsTokens ) ; devsHolder . transfer ( address ( this ) . balance ) ; }
function openLootbox ( address _affiliateAddress ) external payable whenNotPaused isPaid ( lootboxFee ) distributeInput ( _affiliateAddress ) { uint256 pointToCooldownReduction ; uint256 randNum = randMod ( 1001 ) ; uint256 pointsToShare ; uint256 itemID ; Item memory item = Item ( { itemType : uint8 ( uint256 ( randMod ( 3 ) + 1 ) ) , itemRarity : uint8 ( 0 ) , attackPower : 0 , defencePower : 0 , cooldownReduction : 0 , price : 0 , onChampId : 0 , onChamp : false , forSale : false } ) ; if ( 450 > randNum ) { pointsToShare = 25 + randMod ( 9 ) ; item . itemRarity = uint8 ( 1 ) ; } else if ( 720 > randNum ) { pointsToShare = 42 + randMod ( 17 ) ; item . itemRarity = uint8 ( 2 ) ; } else if ( 910 > randNum ) { pointsToShare = 71 + randMod ( 25 ) ; item . itemRarity = uint8 ( 3 ) ; } else if ( 980 > randNum ) { pointsToShare = 119 + randMod ( 33 ) ; item . itemRarity = uint8 ( 4 ) ; } else { pointsToShare = 235 + randMod ( 41 ) ; item . itemRarity = uint8 ( 5 ) ; } if ( item . itemType == uint8 ( 1 ) ) { item . attackPower = pointsToShare / 10 * 7 ; pointsToShare -= item . attackPower ; item . defencePower = pointsToShare / 10 * randMod ( 6 ) ; pointsToShare -= item . defencePower ; item . cooldownReduction = pointsToShare * uint256 ( 1 minutes ) ; item . itemType = uint8 ( 1 ) ; } if ( item . itemType == uint8 ( 2 ) ) { item . defencePower = pointsToShare / 10 * 7 ; pointsToShare -= item . defencePower ; item . attackPower = pointsToShare / 10 * randMod ( 6 ) ; pointsToShare -= item . attackPower ; item . cooldownReduction = pointsToShare * uint256 ( 1 minutes ) ; item . itemType = uint8 ( 2 ) ; } if ( item . itemType == uint8 ( 3 ) ) { pointToCooldownReduction = pointsToShare / 10 * 7 ; item . cooldownReduction = pointToCooldownReduction * uint256 ( 1 minutes ) ; pointsToShare -= pointToCooldownReduction ; item . attackPower = pointsToShare / 10 * randMod ( 6 ) ; pointsToShare -= item . attackPower ; item . defencePower = pointsToShare ; item . itemType = uint8 ( 3 ) ; } itemID = items . push ( item ) - 1 ; itemToOwner [ itemID ] = msg . sender ; addressInfo [ msg . sender ] . itemsCount ++ ; emit NewItem ( itemID , msg . sender ) ; }
function callOnExchange ( uint exchangeIndex , bytes4 method , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) external { require ( modules . pricefeed . exchangeMethodIsAllowed ( exchanges [ exchangeIndex ] . exchange , method ) ) ; require ( exchanges [ exchangeIndex ] . exchangeAdapter . delegatecall ( method , exchanges [ exchangeIndex ] . exchange , orderAddresses , orderValues , identifier , v , r , s ) ) ; }
function getNumberOfTiers ( ) public view returns ( uint256 ) { return tokensPerTierTotal . length ; }
function unpause ( ) public onlyManager { require ( paused ) ; paused = false ; emit Unpause ( ) ; }
function proposeAssignProject ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { Pledge storage p = findPledge ( idPledge ) ; require ( getPledgeLevel ( p ) < MAX_INTERPROJECT_LEVEL ) ; require ( ! isProjectCanceled ( idReceiver ) ) ; uint64 toPledge = findOrCreatePledge ( p . owner , p . delegationChain , idReceiver , uint64 ( getTime ( ) + maxCommitTime ( p ) ) , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }
function getBestAnswer ( bytes32 question_id ) public view returns ( bytes32 ) { }
function transfer ( address _to , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; return doTransfer ( msg . sender , _to , _amount ) ; }
function buyout ( uint256 _deedId ) external payable whenNotPaused { buyoutWithData ( _deedId , "" , "" , "" , "" ) ; }
function updateMintingAgent ( address _agent , bool _status ) public onlyOwner { mintingAgents [ _agent ] = _status ; }
function revokeManualApproval ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , "Invalid from address" ) ; require ( _to != address ( 0 ) , "Invalid to address" ) ; delete manualApprovals [ _from ] [ _to ] ; emit RevokeManualApproval ( _from , _to , msg . sender ) ; }
function claimEther ( ) public onlyOwner { if ( this . balance > 0 ) owner . transfer ( this . balance ) ; }
function getLockedUserBalance ( bytes32 _userKey ) public returns ( uint ) { return _syncLockedDepositsAmount ( _userKey ) ; }
function removeModule ( address _module ) external ;
function reclaimExpiredSwap ( bytes32 msigId , bytes32 swapId ) public { require ( multisigs [ msigId ] . owner == msg . sender || multisigs [ msigId ] . authority == msg . sender ) ; require ( msigId == atomicswaps [ swapId ] . msigId ) ; require ( now >= atomicswaps [ swapId ] . expirationTime ) ; uint amount = atomicswaps [ swapId ] . amount ; delete atomicswaps [ swapId ] ; multisigs [ msigId ] . deposit = add ( multisigs [ msigId ] . deposit , amount ) ; }
function __transferFromWithReference ( address _from , address _to , uint _value , string _reference , address _sender ) public onlyProxy returns ( bool ) { var ( _fromRole , _toRole ) = _getParticipantRoles ( _from , _to ) ; bool _isTransferFromHolderToContractOwner = ( _fromRole == Roles . Holder ) && ( contractOwner == _to ) && ( dataController . allowance ( _from ) >= _value ) && super . __transferFromWithReference ( _from , _to , _value , _reference , _sender ) ; if ( _isTransferFromHolderToContractOwner ) { return true ; } if ( ! _checkTransferAllowanceFrom ( _to , _toRole , _value , _from , _fromRole , _sender ) ) { return false ; } if ( ! _isValidCountryLimits ( _to , _toRole , _value , _from , _fromRole ) ) { return false ; } if ( ! super . __transferFromWithReference ( _from , _to , _value , _reference , _sender ) ) { return false ; } _updateTransferLimits ( _to , _toRole , _value , _from , _fromRole ) ; _contractFallbackERC223 ( _from , _to , _value ) ; return true ; }
function resumeWhitelist ( ) public onlyAdmin returns ( bool ) { paused = false ; Resumed ( msg . sender , now ) ; return true ; }
function buy ( address _to , uint _value , uint _paymentId ) public { transfer ( _to , _value ) ; LogBuy ( msg . sender , _to , _value , _paymentId ) ; }
function pruneInvestors ( uint256 _start , uint256 _iters ) external ;
function approve ( address spender , uint tokens ) public returns ( bool success ) ;
function setRateStalePeriod ( uint _time ) external onlyOwner { rateStalePeriod = _time ; emit RateStalePeriodUpdated ( rateStalePeriod ) ; }
function begin ( List storage self ) internal view returns ( address ) { return self . list [ NULL ] . next ; }
function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( ( _value == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function resumeContribution ( ) public onlyController { paused = false ; }
function doPurchase ( uint256 _usd , uint256 _eth , uint256 _btc , address _address , uint256 _vestingEnds ) internal isActive returns ( uint256 ) { require ( _usd >= 10 ) ; uint256 soldAmount = computeTokens ( _usd ) ; updateStats ( _usd , soldAmount ) ; grantVestedTokens ( _address , soldAmount , vestingStarts , _vestingEnds ) ; NewBuyer ( _address , soldAmount , _usd , _eth , _btc ) ; return soldAmount ; }
function isOpen ( ) public view returns ( bool ) { if ( isFinalized ) return false ; if ( now < startTime ) return false ; if ( now >= endTime ) return false ; if ( capReached ( ) ) return false ; return true ; }
function withdraw ( uint withdrawAmount ) onlyOwner public { if ( withdrawAmount <= address ( this ) . balance ) { owner . transfer ( withdrawAmount ) ; } }
function contribute ( ) public notFinished payable { uint256 tokenBought = 0 ; totalRaised = totalRaised . add ( msg . value ) ; ethOnContract [ msg . sender ] = ethOnContract [ msg . sender ] . add ( msg . value ) ; if ( state == State . PreSale ) { require ( now >= PreSaleStart ) ; tokenBought = msg . value . mul ( rates [ 0 ] ) ; PreSaleDistributed = PreSaleDistributed . add ( tokenBought ) ; require ( PreSaleDistributed <= PreSaleLimit ) ; } else if ( state == State . MainSale ) { require ( now >= MainSaleStart ) ; tokenBought = msg . value . mul ( rates [ 1 ] ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; require ( totalDistributed <= hardCap ) ; if ( totalDistributed >= softCap ) { uint256 tempBalance = balance [ msg . sender ] ; balance [ msg . sender ] = 0 ; require ( tokenReward . transfer ( msg . sender , tokenBought . add ( tempBalance ) ) ) ; tokensSent [ msg . sender ] = tokensSent [ msg . sender ] . add ( tokenBought . add ( tempBalance ) ) ; emit LogContributorsPayout ( msg . sender , tokenBought . add ( tempBalance ) ) ; } else { balance [ msg . sender ] = balance [ msg . sender ] . add ( tokenBought ) ; } emit LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; checkIfFundingCompleteOrExpired ( ) ; }
function approveAccount ( address target , bool approve ) onlyOwner public { approvedAccount [ target ] = approve ; ApprovedFunds ( target , approve ) ; }
function _distributeInvestment ( uint256 _value ) private { developers . transfer ( msg . value * developersPercent / 100 ) ; marketers . transfer ( msg . value * marketersPercent / 100 ) ; }
function isRefunding ( ) public constant returns ( bool ) { return ( state == State . Refunding ) ; }
function withdraw ( ) external { uint256 bal = balanceOf [ msg . sender ] ; require ( bal > 0 , "Balance must be positive" ) ; balanceTotal = balanceTotal . sub ( bal ) ; balanceOf [ msg . sender ] = 0 ; msg . sender . transfer ( bal ) ; emit LogWithdraw ( msg . sender , bal ) ; assert ( address ( this ) . balance >= balanceTotal ) ; }
function mintTokens ( address _owner , uint _amount ) public onlyController notFinalized returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
function tokenOfOwnerByIndex ( address owner , uint256 index ) public view returns ( uint256 assetId ) { require ( index < _assetsOf [ owner ] . length ) ; require ( index < ( 1 << 127 ) ) ; return _assetsOf [ owner ] [ index ] ; }
function setbuyPrice ( uint256 newBuyPrice ) onlyOwner public { require ( newBuyPrice > 0 ) ; buyPrice = newBuyPrice ; }
function createImage ( uint [ ] _randomHashIds , uint _timestamp , uint _iterations , bytes32 [ ] _potentialAssets , string _author , string _ipfsHash , string _extraData ) public payable { require ( _potentialAssets . length <= 5 ) ; require ( msg . sender == usernameToAddress [ _author ] || ! usernameExists [ _author ] ) ; if ( ! usernameExists [ _author ] ) { register ( _author , bytes32 ( 0 ) ) ; } uint [ ] memory pickedAssets ; uint finalSeed ; ( pickedAssets , finalSeed ) = getPickedAssetsAndFinalSeed ( _potentialAssets , _randomHashIds , _timestamp , _iterations ) ; uint [ ] memory pickedAssetPacks = assetManager . pickUniquePacks ( pickedAssets ) ; uint finalPrice = 0 ; for ( uint i = 0 ; i < pickedAssetPacks . length ; i ++ ) { if ( assetManager . checkHasPermissionForPack ( msg . sender , pickedAssetPacks [ i ] ) == false ) { finalPrice += assetManager . getAssetPackPrice ( pickedAssetPacks [ i ] ) ; assetManager . buyAssetPack . value ( assetManager . getAssetPackPrice ( pickedAssetPacks [ i ] ) ) ( msg . sender , pickedAssetPacks [ i ] ) ; } } require ( msg . value >= finalPrice ) ; uint id = totalSupply ( ) ; _mint ( msg . sender , id ) ; imageMetadata [ id ] = ImageMetadata ( { finalSeed : finalSeed , potentialAssets : _potentialAssets , timestamp : _timestamp , creator : msg . sender , ipfsHash : _ipfsHash , extraData : _extraData } ) ; idToIpfsHash [ id ] = _ipfsHash ; seedExists [ finalSeed ] = true ; emit ImageCreated ( id , msg . sender ) ; }
function ( ) public payable isValidated notClosed notPaused { require ( msg . value > 0 ) ; doBuy ( msg . sender , msg . value ) ; }
function getBuy ( ) returns ( uint256 ) { return buyPrice ; }
function setEscrow ( SynthetixEscrow _escrow ) external optionalProxy_onlyOwner { escrow = _escrow ; }
function validateKYC ( address _user , bool _flag ) public onlyAdmin ( 1 ) { KYCValid [ _user ] = _flag ; }
function deedUri ( uint256 _deedId ) external pure returns ( string uri ) { require ( _deedId < 1000000 ) ; uri = "https://meta.quazr.io/card/xxxxxxx" ; bytes memory _uri = bytes ( uri ) ; for ( uint256 i = 0 ; i < 7 ; i ++ ) { _uri [ 33 - i ] = byte ( 48 + ( _deedId / 10 ** i ) % 10 ) ; } }
function claimTokens ( ) respectTimeFrame registeredUser isValidState payable public { require ( msg . value > 0 ) ; uint256 tokens = msg . value . mul ( tokenExchangeRate ) ; require ( isWithinCap ( tokens ) ) ; uint256 checkedSupply = assignedSupply . add ( tokens ) ; require ( checkedSupply . add ( gmtFund ) <= totalSupply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; purchases [ msg . sender ] = purchases [ msg . sender ] . add ( tokens ) ; assignedSupply = checkedSupply ; ClaimGMT ( msg . sender , tokens ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }
function cancelTask ( uint uuid ) public onlyCurator { communityAccount . setTotalTaskEscrow ( SafeMath . sub ( communityAccount . totalTaskEscrow ( ) , communityAccount . escrowedTaskBalances ( uuid ) ) ) ; communityAccount . setEscrowedTaskBalances ( uuid , 0 ) ; logger . emitGenericLog ( "cancelTask" , "" ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) ;
function addAttributeType ( uint256 ID , string description ) external onlyOwner whenNotPaused { require ( ! isAttributeType ( ID ) , "an attribute type with the provided ID already exists" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( ID , false , description ) ) ; if ( _attributeTypeHashes [ ID ] == bytes32 ( 0 ) ) { _attributeTypeHashes [ ID ] = hash ; } require ( hash == _attributeTypeHashes [ ID ] , "attribute type properties must match initial properties assigned to ID" ) ; _attributeTypes [ ID ] = AttributeType ( { exists : true , restricted : false , onlyPersonal : false , index : _attributeIDs . length , secondarySource : address ( 0 ) , secondaryAttributeTypeID : uint256 ( 0 ) , minimumStake : uint256 ( 0 ) , jurisdictionFee : uint256 ( 0 ) , description : description } ) ; _attributeIDs . push ( ID ) ; emit AttributeTypeAdded ( ID , description ) ; }
function listPairForReserve ( address reserve , ERC20 src , ERC20 dest , bool add ) public onlyAdmin { ( perReserveListedPairs [ reserve ] ) [ keccak256 ( src , dest ) ] = add ; if ( src != ETH_TOKEN_ADDRESS ) { if ( add ) { src . approve ( reserve , 2 ** 255 ) ; } else { src . approve ( reserve , 0 ) ; } } ListReservePairs ( reserve , src , dest , add ) ; }
function get_Sponsored_Amount_in_Job_By_Address ( uint _JobID , address _sponsor ) public view returns ( uint ) { require ( _JobID >= 0 ) ; require ( _sponsor != 0x0 ) ; Job storage job = Jobs [ _JobID ] ; return job . sponsors [ _sponsor ] ; }
function unpause ( ) public onlyManager whenPaused { paused = false ; }
function ( ) external payable { require ( msg . sender == address ( this ) ) ; }
function isNotaryVeredictValid ( address order , address seller , address notary , bool wasAudited , bool isDataValid , bytes notarySignature ) public pure returns ( bool ) { require ( order != address ( 0 ) ) ; require ( seller != address ( 0 ) ) ; require ( notary != address ( 0 ) ) ; bytes32 hash = keccak256 ( abi . encodePacked ( order , seller , wasAudited , isDataValid ) ) ; return isSignedBy ( hash , notary , notarySignature ) ; }
function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; require ( token . transfer ( owner , refund ) ) ; emit Revoked ( ) ; }
function paybackContribution ( uint i ) payable onlyAdmin { address memberRefunded = members [ i ] . member ; if ( memberRefunded == 0 ) throw ; uint amountTokens = msg . value ; if ( vips [ memberRefunded ] ) { amountTokens += amountTokens / 3 ; remainingTokensVIPs += amountTokens ; } if ( amountTokens > balances [ memberRefunded ] ) throw ; balances [ memberRefunded ] -= amountTokens ; totalTokens -= amountTokens ; if ( balances [ memberRefunded ] == 0 ) { delete members [ i ] ; vips [ memberRefunded ] = false ; indexMembers [ memberRefunded ] = 0 ; } if ( ! memberRefunded . send ( msg . value ) ) { failingRefund ( memberRefunded , msg . value ) ; } Refund ( memberRefunded , msg . value ) ; }
function fulfillQuery ( uint256 id ) private returns ( bool ) { Status status = Status ( getStatus ( id ) ) ; require ( status != Status . Fulfilled , "Error: Status already fulfilled" ) ; address subscriber = getSubscriber ( id ) ; address provider = getProvider ( id ) ; bytes32 endpoint = getEndpoint ( id ) ; if ( status == Status . Canceled ) { uint256 canceled = getCancel ( id ) ; require ( block . number == canceled , "Error: Cancel ignored" ) ; setCanceled ( id , false ) ; bondage . escrowDots ( subscriber , provider , endpoint , 1 ) ; emit RevertCancelation ( id , subscriber , provider ) ; } setFulfilled ( id ) ; bondage . releaseDots ( subscriber , provider , endpoint , 1 ) ; emit FulfillQuery ( subscriber , provider , endpoint ) ; return true ; }
function destroyBlacklistedTokens ( address _who , uint256 _amount ) public userBlacklisted ( _who ) whenNotPaused requiresPermission { tokenStorage . subBalance ( _who , _amount ) ; tokenStorage . subTotalSupply ( _amount ) ; emit DestroyedBlacklistedTokens ( _who , _amount ) ; }
function fundAnswerBounty ( bytes32 question_id ) stateOpen ( question_id ) external payable { questions [ question_id ] . bounty = questions [ question_id ] . bounty . add ( msg . value ) ; emit LogFundAnswerBounty ( question_id , msg . value , questions [ question_id ] . bounty , msg . sender ) ; }
function addAdmin ( address _newAdmin ) public onlyOwner { admins [ _newAdmin ] = true ; }
function getCanvasPainters ( uint32 _canvasId ) external view returns ( address [ ] ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; address [ ] memory result = new address [ ] ( PIXEL_COUNT ) ; for ( uint32 i = 0 ; i < PIXEL_COUNT ; i ++ ) { result [ i ] = canvas . pixels [ i ] . painter ; } return result ; }
function onBurn ( address _owner , uint _amount ) public returns ( bool ) ;
function intervalOf ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . interval ; }
function removeAttributeFor ( address account , uint256 attributeTypeID ) external { require ( ! _attributeTypes [ attributeTypeID ] . restricted , "only jurisdiction or issuing validator may remove a restricted attribute" ) ; require ( _issuedAttributes [ account ] [ attributeTypeID ] . exists , "only existing attributes may be removed" ) ; require ( _issuedAttributes [ account ] [ attributeTypeID ] . operator == msg . sender , "only an assigning operator may remove attribute on behalf of an address" ) ; address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; uint256 stake = _issuedAttributes [ account ] [ attributeTypeID ] . stake ; delete _issuedAttributes [ account ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , account , attributeTypeID ) ; if ( stake > 0 && address ( this ) . balance >= stake ) { if ( msg . sender . send ( stake ) ) { emit StakeRefunded ( msg . sender , attributeTypeID , stake ) ; } } }
function _processPurchase ( address _beneficiary , uint256 _tokenAmount ) internal { uint256 bonus = calculateBonus ( _tokenAmount , assignedBonusRates [ _beneficiary ] ) ; require ( totalTokensSold . add ( _tokenAmount ) . add ( bonus ) <= totalSaleAllocation ) ; assignBonus ( _beneficiary , bonus ) ; totalTokensSold = totalTokensSold . add ( _tokenAmount ) . add ( bonus ) ; super . _processPurchase ( _beneficiary , _tokenAmount ) ; }
function approveBreeding ( address _addr , uint40 _dadId ) public whenNotPaused { require ( _isOwner ( msg . sender , _dadId ) ) ; sireAllowedToAddress [ _dadId ] = _addr ; emit BreedingApproval ( msg . sender , _addr , _dadId ) ; }
function checkPermission ( address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { if ( delegateDetails [ _delegate ] != bytes32 ( 0 ) ) { return perms [ _module ] [ _delegate ] [ _perm ] ; } else return false ; }
function buy ( ) payable public { uint amount = msg . value / buyPrice ; _transfer ( this , msg . sender , amount ) ; }
function __callback ( bytes32 _requestId , string _result ) public { require ( msg . sender == oraclize_cbAddress ( ) , "Only Oraclize can access this method" ) ; require ( ! freezeOracle , "Oracle is frozen" ) ; require ( ! ignoreRequestIds [ _requestId ] , "Ignoring requestId" ) ; require ( requestIds [ _requestId ] >= latestUpdate , "Result is stale" ) ; require ( requestIds [ _requestId ] <= now + oraclizeTimeTolerance , "Result is early" ) ; uint256 newPOLYUSD = parseInt ( _result , 18 ) ; uint256 bound = POLYUSD . mul ( sanityBounds ) . div ( 10 ** 18 ) ; if ( latestUpdate != 0 ) { require ( newPOLYUSD <= POLYUSD . add ( bound ) , "Result is too large" ) ; require ( newPOLYUSD >= POLYUSD . sub ( bound ) , "Result is too small" ) ; } latestUpdate = requestIds [ _requestId ] ; emit LogPriceUpdated ( newPOLYUSD , POLYUSD , _requestId , latestUpdate ) ; POLYUSD = newPOLYUSD ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = dogIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
function approve ( address _to , uint256 _deedId ) external ;
function performSellOrder ( OrderData data , uint256 amountToGiveForOrder ) public whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { if ( data . takerAmount != amountToGiveForOrder ) { errorReporter . revertTx ( "AirSwap: takerAmount != amountToGiveForOrder" ) ; } if ( data . makerToken != address ( weth ) ) { return ( 0 , 0 ) ; } approveAddress ( address ( exchange ) , data . takerToken ) ; fillAndValidate ( data ) ; weth . withdraw ( data . makerAmount ) ; totlePrimary . transfer ( data . makerAmount ) ; return ( data . takerAmount , data . makerAmount ) ; }
function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { require ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
function takeOwnership ( uint256 _deedId ) external payable ;
function calculateSettlementDetails ( bytes32 _buyID , bytes32 _sellID , TokenPair memory _tokens ) private view returns ( SettlementDetails memory ) { Fraction memory midPrice = Fraction ( orderDetails [ _buyID ] . price + orderDetails [ _sellID ] . price , 2 ) ; uint256 commonVolume = Math . min256 ( orderDetails [ _buyID ] . volume , orderDetails [ _sellID ] . volume ) ; uint256 priorityTokenVolume = joinFraction ( commonVolume . mul ( midPrice . numerator ) , midPrice . denominator , int16 ( _tokens . priorityToken . decimals ) - PRICE_OFFSET - VOLUME_OFFSET ) ; uint256 secondaryTokenVolume = joinFraction ( commonVolume , 1 , int16 ( _tokens . secondaryToken . decimals ) - VOLUME_OFFSET ) ; ValueWithFees memory priorityVwF = subtractDarknodeFee ( priorityTokenVolume ) ; ValueWithFees memory secondaryVwF = subtractDarknodeFee ( secondaryTokenVolume ) ; return SettlementDetails ( { leftVolume : priorityVwF . value , rightVolume : secondaryVwF . value , leftTokenFee : priorityVwF . fees , rightTokenFee : secondaryVwF . fees , leftTokenAddress : _tokens . priorityToken . addr , rightTokenAddress : _tokens . secondaryToken . addr } ) ; }
function isMasternodeOwner ( address _candidate ) public view returns ( bool ) ;
function lend ( uint index , bytes oracleData , Cosigner cosigner , bytes cosignerData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; require ( isApproved ( index ) ) ; require ( block . timestamp <= loan . expirationRequest ) ; loan . lender = msg . sender ; loan . dueTime = safeAdd ( block . timestamp , loan . duesIn ) ; loan . interestTimestamp = block . timestamp ; loan . status = Status . lent ; Transfer ( 0x0 , loan . lender , index ) ; activeLoans += 1 ; lendersBalance [ loan . lender ] += 1 ; if ( loan . cancelableAt > 0 ) internalAddInterest ( loan , safeAdd ( block . timestamp , loan . cancelableAt ) ) ; uint256 transferValue = convertRate ( loan . oracle , loan . currency , oracleData , loan . amount ) ; require ( rcn . transferFrom ( msg . sender , loan . borrower , transferValue ) ) ; if ( cosigner != address ( 0 ) ) { loan . cosigner = address ( uint256 ( cosigner ) + 2 ) ; require ( cosigner . requestCosign ( this , index , cosignerData , oracleData ) ) ; require ( loan . cosigner == address ( cosigner ) ) ; } Lent ( index , loan . lender , cosigner ) ; return true ; }
function transferCurator ( address _curator ) public onlyCurator { curator = _curator ; logger . emitGenericLog ( "transferCurator" , "" ) ; }
function onTransferReceived ( address operator , address from , uint256 value , bytes data ) external returns ( bytes4 ) ;
function getTotalHashRateOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return miners [ _miner ] . totalHashRate ; }
function doRelease ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) return false ; uint128 _gasFees = _escrow . totalGasFeesSpentByRelayer + ( msg . sender == relayer ? ( GAS_doRelease + _additionalGas ) * uint128 ( tx . gasprice ) : 0 ) ; delete escrows [ _tradeHash ] ; emit Released ( _tradeHash ) ; transferMinusFees ( _buyer , _value , _gasFees , _fee ) ; return true ; }
function changeCap ( uint256 _cap ) public onlyOwner { if ( _cap < minimumCap ) revert ( ) ; if ( _cap <= totalRaised ) revert ( ) ; hardCap = _cap ; if ( totalRaised + minimumInvestment >= hardCap ) { isCapReached = true ; doFinalizeSale ( ) ; } }
function acceptOwnership ( ) external { require ( msg . sender == newOwnerCandidate ) ; address oldOwner = owner ; owner = newOwnerCandidate ; newOwnerCandidate = 0x0 ; emit OwnershipTransferred ( oldOwner , owner ) ; }
function getCurrencyContract ( bytes32 _requestId ) public view returns ( address ) { return requests [ _requestId ] . currencyContract ; }
function getPlayerInstWinning ( uint256 _gameID , uint256 _pID , uint256 _team ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { return ( ( ( ( teams_ [ _gameID ] [ _team ] . mask ) . mul ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . keys ) ) / ( 1000000000000000000 ) ) . sub ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . mask ) ) ; }
function getTokenDataByIndex ( uint64 _tokenIndex ) public view returns ( uint256 _tknId , uint64 _tknIdx , uint64 _collectionIdx , address _owner , address _creator , bytes8 _name , uint32 _dateCreated ) { require ( _tokenIndex < totalSupply ( ) , "PixelCon index is out of bounds" ) ; PixelCon storage pixelcon = pixelcons [ _tokenIndex ] ; TokenLookup storage lookupData = tokenLookup [ pixelcon . tokenId ] ; return ( pixelcon . tokenId , lookupData . tokenIndex , pixelcon . collectionIndex , lookupData . owner , pixelcon . creator , pixelconNames [ lookupData . tokenIndex ] , pixelcon . dateCreated ) ; }
function isSpecificallyApprovedFor ( address _asker , uint256 _tokenId ) internal view returns ( bool ) { return getApproved ( _tokenId ) == _asker ; }
function decimals ( ) public erc20 view returns ( uint8 ) { return uint8 ( 18 ) ; }
function boom ( ) public onlyController { uint sntBalance = SNT . balanceOf ( address ( this ) ) ; require ( SNT . transfer ( msg . sender , sntBalance ) , "Transfer did not work" ) ; selfdestruct ( msg . sender ) ; }
function setHodlerTime ( uint256 _time ) public onlyCrowdsale { hodlerReward . setHodlerTime ( _time ) ; }
function deposit ( bytes32 channelId ) public payable { require ( canDeposit ( channelId , msg . sender ) ) ; channels [ channelId ] . value += msg . value ; DidDeposit ( channelId , msg . value ) ; }
function withdraw ( uint256 _amount , address _destination ) public onlyOwner { require ( _destination != address ( 0 ) ) ; require ( _amount <= this . balance ) ; _destination . transfer ( _amount == 0 ? this . balance : _amount ) ; }
function approve ( address _approved , uint256 _tokenId ) canOperate ( _tokenId ) ownerExists ( _tokenId ) external { address tokenOwner = nft [ _tokenId ] . owner ; require ( _approved != tokenOwner , "approved address cannot be owner of the token" ) ; nft [ _tokenId ] . approval = _approved ; emit Approval ( tokenOwner , _approved , _tokenId ) ; }
function name ( ) external view returns ( string ) { return _name ; }
function transferFromPreSignedHashing ( address _token , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0xb7656dc5 ) , _token , _from , _to , _value , _fee , _nonce ) ; }
function adjustBalanceCheckpoints ( address _investor ) internal { adjustCheckpoints ( checkpointBalances [ _investor ] , balanceOf ( _investor ) ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }
function claim ( address engine , uint256 loanId , bytes ) external returns ( bool ) { uint256 mortgageId = loanToLiability [ engine ] [ loanId ] ; Mortgage storage mortgage = mortgages [ mortgageId ] ; require ( mortgage . status == Status . Ongoing , "Mortgage not ongoing" ) ; require ( mortgage . loanId == loanId , "Mortgage don't match loan id" ) ; if ( mortgage . engine . getStatus ( loanId ) == Engine . Status . paid || mortgage . engine . getStatus ( loanId ) == Engine . Status . destroyed ) { require ( _isAuthorized ( msg . sender , mortgageId ) , "Sender not authorized" ) ; mortgage . status = Status . Paid ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit PaidMortgage ( msg . sender , mortgageId ) ; } else if ( isDefaulted ( mortgage . engine , loanId ) ) { require ( msg . sender == mortgage . engine . ownerOf ( loanId ) , "Sender not lender" ) ; mortgage . status = Status . Defaulted ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit DefaultedMortgage ( mortgageId ) ; } else { revert ( "Mortgage not defaulted/paid" ) ; } delete mortgageByLandId [ mortgage . landId ] ; return true ; }
function depositNomins ( uint amount ) external { nomin . transferFrom ( msg . sender , this , amount ) ; }
function liabilityFinalized ( ILiability _liability , uint256 _start_gas ) external returns ( bool ) ;
function sell ( uint256 amount ) public returns ( uint256 revenue ) { uint256 a = 0 ; require ( initialSaleComplete ) ; require ( balances [ msg . sender ] >= amount ) ; a = _totalSupply - amount ; uint256 p = 0 ; uint8 ps = 0 ; ( p , ps ) = power ( 1000008 , 1000000 , ( uint32 ) ( 1e5 + 1e5 * _totalSupply / SU ) , 1e5 ) ; p = ( S * p ) >> ps ; uint256 p2 = 0 ; uint8 ps2 = 0 ; ( p2 , ps2 ) = power ( 1000008 , 1000000 , ( uint32 ) ( 1e5 + 1e5 * a / SU ) , 1e5 ) ; p2 = ( S * p2 ) >> ps2 ; revenue = ( SU * p - SU * p2 ) * R / S ; _totalSupply -= amount ; require ( balances [ reserveAddress ] >= revenue ) ; balances [ reserveAddress ] -= revenue ; balances [ msg . sender ] -= amount ; Contract reserve = Contract ( reserveAddress ) ; reserve . sendFunds ( msg . sender , revenue ) ; emit Transfer ( msg . sender , reserveAddress , amount ) ; quoteAsk ( ) ; quoteBid ( ) ; return revenue ; }
function getAssetIpfs ( uint _id ) public view returns ( bytes32 ) { require ( _id < numberOfAssets ) ; return assets [ _id ] . ipfsHash ; }
function setConverterRamp ( address _converterRamp ) external onlyOwner returns ( bool ) { emit SetConverterRamp ( converterRamp , _converterRamp ) ; converterRamp = _converterRamp ; return true ; }
function getPrice ( address asset ) public view returns ( uint ) { return assetPrices ( asset ) ; }
function claimTokens ( address _token ) onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }
function setTokenPrice ( uint week , uint price , uint price5 , uint price10 ) public onlyOwner { require ( crowdsaleClosed == false ) ; require ( week >= 1 && week <= 3 ) ; if ( week == 1 ) price1stWeek = [ price , price5 , price10 ] ; else if ( week == 2 ) price2ndWeek = [ price , price5 , price10 ] ; else if ( week == 3 ) price3rdWeek = [ price , price5 , price10 ] ; }
function release ( ERC20Basic token ) public { uint256 unreleased = releasableAmount ( token ) ; require ( unreleased > 0 ) ; released [ token ] = released [ token ] . add ( unreleased ) ; require ( token . transfer ( beneficiary , unreleased ) ) ; emit Released ( unreleased ) ; }
function buy ( uint256 identifier ) external payable whenNotPaused { require ( identifierToOwner [ identifier ] != 0x0 ) ; address oldOwner = identifierToOwner [ identifier ] ; uint256 price = identifierToPrice [ identifier ] ; require ( oldOwner != msg . sender ) ; require ( msg . value >= price ) ; uint256 newPrice = nextPrice ( price ) ; identifierToPrice [ identifier ] = newPrice ; _transfer ( oldOwner , msg . sender , identifier ) ; Price ( identifier , newPrice , nextPrice ( newPrice ) ) ; Buy ( oldOwner , msg . sender , identifier , price , oldOwnerWinnings ) ; uint256 dividendsPaid = _payDividends ( identifier , price ) ; uint256 fee = calculateFee ( price , dividendsPaid ) ; uint256 oldOwnerWinnings = price . sub ( dividendsPaid ) . sub ( fee ) ; _shiftRecentBuyers ( msg . sender ) ; if ( oldOwner != address ( this ) ) { _sendFunds ( oldOwner , oldOwnerWinnings ) ; } uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function getMaximumFunds ( ) internal constant returns ( uint ) ;
function checkIfFundingCompleteOrExpired ( ) public { if ( totalDistributed == hardCap && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else if ( state == State . PreSale && now > PreSaleDeadline ) { state = State . MainSale ; } else if ( state == State . MainSale && now > MainSaleDeadline ) { if ( totalDistributed >= softCap ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else { state = State . Failed ; completedAt = now ; emit LogFundingFailed ( totalRaised ) ; } } }
function getFeeMax ( Data storage self , address contractAddress ) internal view returns ( uint feeMax ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.max' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }
function getAmount ( uint _price , address _trader ) public constant returns ( uint ) ;
function collectAuthorizedPayment ( uint _idPayment ) { if ( _idPayment >= authorizedPayments . length ) return ; Payment p = authorizedPayments [ _idPayment ] ; if ( msg . sender != p . recipient ) return ; if ( now < p . earliestPayTime ) return ; if ( p . canceled ) return ; if ( p . paid ) return ; if ( this . balance < p . amount ) return ; p . paid = true ; if ( ! p . recipient . send ( p . amount ) ) { return ; } PaymentExecuted ( _idPayment , p . recipient , p . amount ) ; }
function restartSale ( ) public only_during_sale_period only_sale_stopped onlyOwner { if ( saleFinalized ) revert ( ) ; saleStopped = false ; }
function setComment ( string newComment ) onlyOwner public { comment = newComment ; }
function setAdmin ( address _newAdmin ) external onlyOwner { admin = _newAdmin ; }
function getTokenTLA ( Data storage self , address contractAddress ) internal view returns ( string tokenTLA ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.tla' , contractAddress ) ) ; return self . Storage . getString ( id ) ; }
function created ( ) public constant returns ( uint256 timestamp ) { }
function isTrustedContract ( address _contractAddress ) public view returns ( bool ) { return trustedCurrencyContracts [ _contractAddress ] == 1 ; }
function getInstructions ( ) external view returns ( string ) { return "Allows an issuer to set manual approvals or blocks for specific pairs of addresses and amounts. Init function takes no parameters." ; }
function tokenURI ( uint256 _tokenId ) external view returns ( string _tokenURI ) { _tokenURI = "https://corsarium.playdarkwinds.com/cards/00000.json" ; bytes memory tokenUriBytes = bytes ( _tokenURI ) ; tokenUriBytes [ 33 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 10000 ) % 10 ) ; tokenUriBytes [ 34 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 1000 ) % 10 ) ; tokenUriBytes [ 35 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 100 ) % 10 ) ; tokenUriBytes [ 36 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 10 ) % 10 ) ; tokenUriBytes [ 37 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 1 ) % 10 ) ; }
function isService ( address _address ) public view returns ( bool ) ;
function setRewardBlockThreshold ( uint _newBlockThreshold ) public onlyOwner returns ( bool ) { require ( _newBlockThreshold != blockThreshold , "must be different" ) ; blockThreshold = _newBlockThreshold ; emit RewardBlockThresholdChanged ( msg . sender , _newBlockThreshold ) ; return true ; }
function _burn ( address _owner , uint256 _tokenId ) internal { assert ( tokens . length > 0 ) ; super . _burn ( _owner , _tokenId ) ; uint256 tokenIndex = idToIndex [ _tokenId ] ; uint256 lastTokenIndex = tokens . length . sub ( 1 ) ; uint256 lastToken = tokens [ lastTokenIndex ] ; tokens [ tokenIndex ] = lastToken ; tokens [ lastTokenIndex ] = 0 ; tokens . length -- ; idToIndex [ _tokenId ] = 0 ; idToIndex [ lastToken ] = tokenIndex ; }
function claimToken ( ) public afterSaleSuccess { claimTokenFor ( msg . sender ) ; }
function getModulesByTypeAndToken ( uint8 _moduleType , address _securityToken ) public view returns ( address [ ] ) { uint256 _len = getArrayAddress ( Encoder . getKey ( "moduleList" , uint256 ( _moduleType ) ) ) . length ; address [ ] memory _addressList = getArrayAddress ( Encoder . getKey ( "moduleList" , uint256 ( _moduleType ) ) ) ; bool _isCustomModuleAllowed = IFeatureRegistry ( getAddress ( Encoder . getKey ( "featureRegistry" ) ) ) . getFeatureStatus ( "customModulesAllowed" ) ; uint256 counter = 0 ; for ( uint256 i = 0 ; i < _len ; i ++ ) { if ( _isCustomModuleAllowed ) { if ( IOwnable ( _addressList [ i ] ) . owner ( ) == IOwnable ( _securityToken ) . owner ( ) || getBool ( Encoder . getKey ( "verified" , _addressList [ i ] ) ) ) if ( _isCompatibleModule ( _addressList [ i ] , _securityToken ) ) counter ++ ; } else if ( getBool ( Encoder . getKey ( "verified" , _addressList [ i ] ) ) ) { if ( _isCompatibleModule ( _addressList [ i ] , _securityToken ) ) counter ++ ; } } address [ ] memory _tempArray = new address [ ] ( counter ) ; counter = 0 ; for ( uint256 j = 0 ; j < _len ; j ++ ) { if ( _isCustomModuleAllowed ) { if ( IOwnable ( _addressList [ j ] ) . owner ( ) == IOwnable ( _securityToken ) . owner ( ) || getBool ( Encoder . getKey ( "verified" , _addressList [ j ] ) ) ) { if ( _isCompatibleModule ( _addressList [ j ] , _securityToken ) ) { _tempArray [ counter ] = _addressList [ j ] ; counter ++ ; } } } else if ( getBool ( Encoder . getKey ( "verified" , _addressList [ j ] ) ) ) { if ( _isCompatibleModule ( _addressList [ j ] , _securityToken ) ) { _tempArray [ counter ] = _addressList [ j ] ; counter ++ ; } } } return _tempArray ; }
function getAllPlots ( ) external view returns ( uint32 [ ] ) { return plots ; }
function getBidDetails ( address _addr ) external view returns ( uint , uint ) { return ( _bidders [ _addr ] . value , _bidders [ _addr ] . lastTime ) ; }
function endAuction ( ) public onlyHighestBidderOrEscrow { require ( now >= auctionEnd , "Auction not yet ended." ) ; require ( auctionState != AuctionStates . Ended , "Auction has already ended." ) ; auctionState = AuctionStates . Ended ; emit AuctionEnded ( highestBidder , bids [ highestBidder ] ) ; if ( ! beneficiary . send ( bids [ highestBidder ] ) ) { } }
function getHistoryHash ( bytes32 question_id ) public view returns ( bytes32 ) { return questions [ question_id ] . history_hash ; }
function validateProposedMonarchName ( string _monarchName ) constant returns ( bool allowed ) { return validateNameInternal ( _monarchName ) ; }
function removeAttributeType ( uint256 ID ) external ;
function unpack ( uint24 _packedVersion ) internal pure returns ( uint8 [ ] ) { uint8 [ ] memory _unpackVersion = new uint8 [ ] ( 3 ) ; _unpackVersion [ 0 ] = uint8 ( _packedVersion >> 16 ) ; _unpackVersion [ 1 ] = uint8 ( _packedVersion >> 8 ) ; _unpackVersion [ 2 ] = uint8 ( _packedVersion ) ; return _unpackVersion ; }
function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyArbitrator ( question_id ) statePendingArbitration ( question_id ) bondMustBeZero external { require ( answerer != NULL_ADDRESS , "answerer must be provided" ) ; emit LogFinalize ( question_id , answer ) ; questions [ question_id ] . is_pending_arbitration = false ; _addAnswerToHistory ( question_id , answer , answerer , 0 , false ) ; _updateCurrentAnswer ( question_id , answer , 0 ) ; }
function processProposal ( bytes32 _propID ) public { ParamProposal storage prop = proposals [ _propID ] ; if ( canBeSet ( _propID ) ) { set ( prop . name , prop . value ) ; } else if ( challengeCanBeResolved ( _propID ) ) { resolveChallenge ( _propID ) ; } else if ( now > prop . processBy ) { require ( token . transfer ( prop . owner , prop . deposit ) ) ; } else { revert ( ) ; } delete proposals [ _propID ] ; }
function replaceSelf ( address new_addr ) external { uint256 idx = _firstRecipientIndex ( msg . sender ) ; assert ( recipients [ idx ] == msg . sender ) ; recipients [ idx ] = new_addr ; }
function getTickersByOwner ( address _owner ) external view returns ( bytes32 [ ] ) { uint counter = 0 ; bytes32 [ ] memory tickers = getArrayBytes32 ( Encoder . getKey ( "userToTickers" , _owner ) ) ; for ( uint i = 0 ; i < tickers . length ; i ++ ) { string memory ticker = Util . bytes32ToString ( tickers [ i ] ) ; if ( getUint ( Encoder . getKey ( "registeredTickers_expiryDate" , ticker ) ) >= now || _tickerStatus ( ticker ) ) { counter ++ ; } } bytes32 [ ] memory tempList = new bytes32 [ ] ( counter ) ; counter = 0 ; for ( i = 0 ; i < tickers . length ; i ++ ) { ticker = Util . bytes32ToString ( tickers [ i ] ) ; if ( getUint ( Encoder . getKey ( "registeredTickers_expiryDate" , ticker ) ) >= now || _tickerStatus ( ticker ) ) { tempList [ counter ] = tickers [ i ] ; counter ++ ; } } return tempList ; }
function createJob ( string _description , uint _salary , uint _noOfTotalPayments , address _evaluator ) public { require ( _salary > 0 ) ; require ( _noOfTotalPayments > 0 ) ; address [ ] memory empty ; uint finalSalary = _salary . sub ( _salary . mul ( 1 ) . div ( 10 ) ) ; Job memory newJob = Job ( _description , msg . sender , finalSalary , 0x0 , JobStatus . Open , _noOfTotalPayments , 0 , 0 , 0 , _evaluator , false , 0 , empty , 0 ) ; Jobs . push ( newJob ) ; JobsByManager [ msg . sender ] . push ( jobCount ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _salary ) ; emit JobCreated ( msg . sender , finalSalary , _noOfTotalPayments , jobCount , _description , _evaluator ) ; jobCount ++ ; DAI . transferFrom ( msg . sender , address ( this ) , _salary ) ; }
function transferFrom ( address from , address to , uint value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; if ( to == 0x0 ) throw ; if ( to == address ( upgradeAgent ) ) throw ; if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { return false ; } }
function mintToken ( address _target , uint256 _mintedAmount ) onlyOwner { require ( _target != 0x0 ) ; balanceOf [ _target ] += _mintedAmount ; totalSupply += _mintedAmount ; Transfer ( 0 , this , _mintedAmount ) ; Transfer ( this , _target , _mintedAmount ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }
function _addTeamSale ( uint256 [ 9 ] _tokenIds , Sale _sale ) internal { require ( _sale . duration >= 1 minutes ) ; for ( uint ii = 0 ; ii < 9 ; ii ++ ) { require ( _tokenIds [ ii ] != 0 ) ; require ( nonFungibleContract . exists ( _tokenIds [ ii ] ) ) ; tokenIdToSale [ _tokenIds [ ii ] ] = _sale ; } emit TeamSaleCreated ( _tokenIds , uint256 ( _sale . startingPrice ) , uint256 ( _sale . endingPrice ) , uint256 ( _sale . duration ) , uint256 ( _sale . startedAt ) ) ; }
function burnFrom ( address _from , uint256 _value ) public returns ( bool ) { allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; emit Burn ( _from , _value ) ; return true ; }
function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function setEndDate ( uint256 _endTime ) external onlyOwner whenNotPaused { require ( now <= _endTime ) ; require ( startTime < _endTime ) ; endTime = _endTime ; }
function getContract ( string _contractName ) external view returns ( address _contractAddress ) { require ( contracts [ _contractName ] != address ( 0 ) ) ; _contractAddress = contracts [ _contractName ] ; return _contractAddress ; }
function transfer ( address _to , uint256 _cutieId ) external whenNotPaused canBeStoredIn40Bits ( _cutieId ) { require ( _isOwner ( msg . sender , uint40 ( _cutieId ) ) ) ; _transfer ( msg . sender , _to , uint40 ( _cutieId ) ) ; }
function getBounty ( bytes32 question_id ) public view returns ( uint256 ) { }
function addCustomSecurityToken ( string _name , string _symbol , address _owner , address _securityToken , string _tokenDetails , bytes32 _swarmHash ) public onlyOwner whenNotPaused { require ( bytes ( _name ) . length > 0 && bytes ( _symbol ) . length > 0 , "Name and Symbol string length should be greater than 0" ) ; string memory symbol = upper ( _symbol ) ; require ( _securityToken != address ( 0 ) && symbols [ symbol ] == address ( 0 ) , "Symbol is already at the polymath network or entered security token address is 0x" ) ; require ( _owner != address ( 0 ) ) ; require ( ! ( ITickerRegistry ( tickerRegistry ) . isReserved ( symbol , _owner , _name , _swarmHash ) ) , "Trying to use non-valid symbol" ) ; symbols [ symbol ] = _securityToken ; securityTokens [ _securityToken ] = SecurityTokenData ( symbol , _tokenDetails ) ; emit LogAddCustomSecurityToken ( _name , symbol , _securityToken , now ) ; }
function finalizeAuction ( ) public atStage ( Stages . AuctionStarted ) { uint missing_funds = missingFundsToEndAuction ( ) ; require ( missing_funds == 0 ) ; final_price = token_multiplier * received_wei / num_tokens_auctioned ; end_time = now ; stage = Stages . AuctionEnded ; AuctionEnded ( final_price ) ; assert ( final_price > 0 ) ; }
function removeAt ( MapStorage storage self , uint index ) public returns ( bool ) { return remove ( self , self . addresses [ index ] ) ; }
function takeOwnership ( uint256 _tokenId ) external whenNotPaused { require ( isSenderApprovedFor ( _tokenId ) ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , msg . sender , _tokenId ) ; }
function createDividend ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , bytes32 _name ) external withPerm ( MANAGE ) { createDividendWithExclusions ( _maturity , _expiry , _token , _amount , excluded , _name ) ; }
function breedWith ( uint40 _momId , uint40 _dadId ) public whenNotPaused payable returns ( uint40 ) { require ( _isOwner ( msg . sender , _momId ) ) ; require ( _isBreedingPermitted ( _dadId , _momId ) ) ; require ( getBreedingFee ( _momId , _dadId ) <= msg . value ) ; Cutie storage mom = cuties [ _momId ] ; require ( _canBreed ( mom ) ) ; Cutie storage dad = cuties [ _dadId ] ; require ( _canBreed ( dad ) ) ; require ( _canPairMate ( mom , _momId , dad , _dadId ) ) ; return _breedWith ( _momId , _dadId ) ; }
function updateBalance ( bytes32 _requestId , uint8 _payeeIndex , int256 _deltaAmount ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , "caller should be the currency contract of the request" ) ; if ( _payeeIndex == 0 ) { r . payee . balance = r . payee . balance . add ( _deltaAmount ) ; } else { Payee storage sp = subPayees [ _requestId ] [ _payeeIndex - 1 ] ; sp . balance = sp . balance . add ( _deltaAmount ) ; } emit UpdateBalance ( _requestId , _payeeIndex , _deltaAmount ) ; }
function exchangeNominsForHavvens ( uint nominAmount ) public pricesNotStale notPaused returns ( uint ) { uint havvensToSend = havvensReceivedForNomins ( nominAmount ) ; nomin . transferFrom ( msg . sender , this , nominAmount ) ; havven . transfer ( msg . sender , havvensToSend ) ; emit Exchange ( "nUSD" , nominAmount , "HAV" , havvensToSend ) ; return havvensToSend ; }
function increaseBalance ( address _user , uint256 _value ) public onlyAllowed { if ( userExists [ _user ] == false ) { users . push ( _user ) ; userExists [ _user ] = true ; } balanceUsers [ _user ] += _value ; }
function modifyWhitelistSigned ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO , uint256 _validFrom , uint256 _validTo , uint8 _v , bytes32 _r , bytes32 _s ) public { require ( _validFrom <= now , "ValidFrom is too early" ) ; require ( _validTo >= now , "ValidTo is too late" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( this , _investor , _fromTime , _toTime , _expiryTime , _canBuyFromSTO , _validFrom , _validTo ) ) ; checkSig ( hash , _v , _r , _s ) ; whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit LogModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }
function addManualApproval ( address _from , address _to , uint256 _allowance , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , "Invalid to address" ) ; require ( _expiryTime > now , "Invalid expiry time" ) ; require ( manualApprovals [ _from ] [ _to ] . allowance == 0 , "Approval already exists" ) ; manualApprovals [ _from ] [ _to ] = ManualApproval ( _allowance , _expiryTime ) ; emit AddManualApproval ( _from , _to , _allowance , _expiryTime , msg . sender ) ; }
function assetPrices ( address asset ) public view returns ( uint ) { if ( paused ) { return 0 ; } else { if ( readers [ asset ] != address ( 0 ) ) { ( bytes32 readValue , bool foundValue ) = readers [ asset ] . peek ( ) ; if ( foundValue ) { ( Error error , Exp memory invertedVal ) = getExp ( mantissaOne , uint256 ( readValue ) ) ; if ( error != Error . NO_ERROR ) { return 0 ; } return invertedVal . mantissa ; } else { return 0 ; } } else { return _assetPrices [ asset ] . mantissa ; } } }
function gasExchange ( address gasRecipient , uint256 amountEurUlps , uint256 exchangeFeeFraction ) public ;
function changeWhitelister ( address _newWhitelister ) public onlyWhitelister { require ( _newWhitelister != address ( 0 ) ) ; emit WhitelisterChanged ( whitelister , _newWhitelister ) ; whitelister = _newWhitelister ; }
function calculateDividend ( uint256 _dividendIndex , address _payee ) public view returns ( uint256 ) { Dividend storage dividend = dividends [ _dividendIndex ] ; if ( dividend . claimed [ _payee ] ) { return 0 ; } uint256 balance = ISecurityToken ( securityToken ) . balanceOfAt ( _payee , dividend . checkpointId ) ; return balance . mul ( dividend . amount ) . div ( dividend . totalSupply ) ; }
function calculateTheEndPrice ( uint256 howManyTokenToBuy ) constant returns ( uint256 summarizedPriceInWeis ) { if ( howManyTokenToBuy > 0 ) { summarizedPriceInWeis = howManyTokenToBuy * currentTokenPrice ; } else { summarizedPriceInWeis = 0 ; } }
function transferGIM ( address _from , address _to , uint256 _amount ) returns ( bool success ) { require ( msg . sender == streamerContract ) ; require ( tx . origin == _from ) ; require ( _amount <= streamerContractMaxAmount ) ; if ( balances [ _from ] < _amount || _amount <= 0 ) return false ; balances [ _from ] = safeSub ( balances [ _from ] , _amount ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _amount ) ; Transfer ( _from , _to , _amount ) ; return true ; }
function approve ( address _spender , uint _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = TRANSFER_APPROVAL ; return allPermissions ; }
function totalSupplyAt ( uint _blockNumber ) public constant returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
function playerEndGame ( uint32 _roundId , uint8 _gameType , uint16 _num , uint _value , int _balance , bytes32 _serverHash , bytes32 _playerHash , uint _gameId , address _contractAddress , bytes _serverSig ) public { verifySig ( _roundId , _gameType , _num , _value , _balance , _serverHash , _playerHash , _gameId , _contractAddress , _serverSig , serverAddress ) ; regularEndGame ( msg . sender , _roundId , _gameType , _num , _value , _balance , _gameId , _contractAddress ) ; }
function incremental ( uint256 totalEuroUlps , uint256 euroUlps ) public constant returns ( uint256 neumarkUlps ) { require ( totalEuroUlps + euroUlps >= totalEuroUlps ) ; uint256 from = cumulative ( totalEuroUlps ) ; uint256 to = cumulative ( totalEuroUlps + euroUlps ) ; assert ( to >= from ) ; return to - from ; }
function resignFromMatch ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; require ( board . status == BoardStatus . InProgress ) ; PlayerColor activeColor = getPlayerColor ( board , msg . sender ) ; board . isHonorableLoss = true ; playerLost ( board , boardId , activeColor ) ; }
function addDesignatedAssetManager ( bytes32 _symbol , address _manager ) public onlyOneOfContractOwners returns ( uint ) { uint holderId = _createHolderId ( _manager ) ; set ( store , assetPartowners , _symbol , holderId , true ) ; _emitter ( ) . emitOwnershipChange ( 0x0 , _manager , _symbol ) ; return OK ; }
function enableSelling ( ) onlyOwner public { require ( msg . sender == owner ) ; sellingAllowed = true ; }
function pause ( ) external timedStateChange requiresState ( IcoState . ICO ) onlyowner { changeState ( IcoState . PAUSED ) ; }
function deposit ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . deposit ( currency , account , amount , issuerFirm ) , "Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered" ) ; return true ; }
function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = recoverPreSignedHash ( address ( this ) , transferSig , _to , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; require ( _nonce == nonces [ from ] . add ( 1 ) ) ; require ( _value . add ( _fee ) <= balances [ from ] ) ; nonces [ from ] = _nonce ; signatures [ _signature ] = true ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
function getTxVoteDetails ( bytes32 _txKey ) public view returns ( bytes32 [ ] _groupNames , uint [ ] _acceptedCount , uint [ ] _acceptLimit , uint [ ] _declinedCount , uint [ ] _declineLimit , uint _state ) { if ( txKey2index [ _txKey ] == 0 ) { return ; } Guard storage _guard = txKey2guard [ _txKey ] ; Policy storage _policy = policyId2policy [ index2PolicyId [ _guard . basePolicyIndex ] ] ; uint _groupsCount = _policy . groupsCount ; _groupNames = new bytes32 [ ] ( _groupsCount ) ; _acceptedCount = new uint [ ] ( _groupsCount ) ; _acceptLimit = new uint [ ] ( _groupsCount ) ; _declinedCount = new uint [ ] ( _groupsCount ) ; _declineLimit = new uint [ ] ( _groupsCount ) ; for ( uint _groupIdx = 0 ; _groupIdx < _groupsCount ; ++ _groupIdx ) { Requirements storage _requirement = _policy . participatedGroups [ _groupIdx ] ; bytes32 _groupName = _requirement . groupName ; _groupNames [ _groupIdx ] = _groupName ; _acceptedCount [ _groupIdx ] = _guard . acceptedCount [ _groupName ] ; _acceptLimit [ _groupIdx ] = _requirement . acceptLimit ; _declinedCount [ _groupIdx ] = _guard . declinedCount [ _groupName ] ; _declineLimit [ _groupIdx ] = _requirement . declineLimit ; } _state = uint ( _guard . state ) ; }
function _deliverTokens ( address _beneficiary , uint256 _tokenAmount ) internal { require ( ISecurityToken ( securityToken ) . mint ( _beneficiary , _tokenAmount ) , "Error in minting the tokens" ) ; }
function getCanvasState ( uint32 _canvasId ) public view returns ( uint8 ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; if ( canvas . state != STATE_INITIAL_BIDDING ) { return canvas . state ; } uint finishTime = canvas . initialBiddingFinishTime ; if ( finishTime == 0 || finishTime > getTime ( ) ) { return STATE_INITIAL_BIDDING ; } else { return STATE_OWNED ; } }
function registerHolder ( bytes32 _externalHolderId , address _holderAddress , uint _countryCode ) onlyOracleOrOwner external returns ( uint ) { require ( _holderAddress != 0x0 ) ; uint _holderIndex = holderIndex [ holderAddress2Id [ _holderAddress ] ] ; require ( _holderIndex == 0 ) ; _createCountryId ( _countryCode ) ; _holderIndex = holdersCount . add ( 1 ) ; holdersCount = _holderIndex ; HoldersData storage _holderData = holders [ _holderIndex ] ; _holderData . countryCode = _countryCode ; _holderData . operational = true ; _holderData . sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER ; _holderData . sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER ; uint _firstAddressIndex = 1 ; _holderData . holderAddressCount = _firstAddressIndex ; _holderData . address2Index [ _holderAddress ] = _firstAddressIndex ; _holderData . index2Address [ _firstAddressIndex ] = _holderAddress ; holderIndex [ _externalHolderId ] = _holderIndex ; holderAddress2Id [ _holderAddress ] = _externalHolderId ; _emitHolderRegistered ( _externalHolderId , _holderIndex , _countryCode ) ; return OK ; }
function calcReleaseToken ( address _user , uint256 _time , uint256 _lockTypeIndex ) internal view returns ( uint256 ) { uint256 _timeDifference = _time . sub ( releaseStartTime ) ; uint256 _whichPeriod = getPeriod ( _lockTypeIndex , _timeDifference ) ; if ( _lockTypeIndex == 1 ) { return ( percent ( userReleaseToken [ _user ] . UST , 25 ) + percent ( userReleaseToken [ _user ] . UST , _whichPeriod . mul ( 25 ) ) ) ; } if ( _lockTypeIndex == 2 ) { return ( percent ( userReleaseToken [ _user ] . UST , 25 ) + percent ( userReleaseToken [ _user ] . UST , _whichPeriod . mul ( 25 ) ) ) ; } if ( _lockTypeIndex == 3 ) { return ( percent ( userReleaseToken [ _user ] . UST , 10 ) + percent ( userReleaseToken [ _user ] . UST , _whichPeriod . mul ( 15 ) ) ) ; } revert ( ) ; }
function ( ) payable external { if ( ! funding ) revert ( ) ; if ( msg . value == 0 ) revert ( ) ; var numTokens = msg . value ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
function getValidatorSigningKey ( address validator ) external view returns ( address signingKey ) { return _validators [ validator ] . signingKey ; }
function validateContestForSig ( address _attester , address _requester , uint256 _reward , bytes32 _requestNonce , bytes _delegationSig ) private { bytes32 _delegationDigest = generateContestForDelegationSchemaHash ( _requester , _reward , _requestNonce ) ; require ( _attester == recoverSigner ( _delegationDigest , _delegationSig ) , 'Invalid ContestFor Signature' ) ; burnSignatureDigest ( _delegationDigest , _attester ) ; }
function getModulesByType ( uint8 _moduleType ) public view returns ( address [ ] ) { return getArrayAddress ( Encoder . getKey ( "moduleList" , uint256 ( _moduleType ) ) ) ; }
function getNextVestingEntry ( address account ) public view returns ( uint [ 2 ] ) { uint index = getNextVestingIndex ( account ) ; if ( index == numVestingEntries ( account ) ) { return [ uint ( 0 ) , 0 ] ; } return getVestingScheduleEntry ( account , index ) ; }
function currentPrice ( uint256 _deedId ) public view returns ( uint256 price ) { address currentOwner = gameStates [ gameIndex ] . identifierToOwner [ _deedId ] ; if ( currentOwner == 0x0 ) { price = gameSettings . unclaimedTilePrice ; } else { price = gameStates [ gameIndex ] . identifierToBuyoutPrice [ _deedId ] ; } }
function setUserPermission ( address _who , bytes4 _methodsignature ) public onlyValidator { require ( permissions [ _methodsignature ] . active , "Permission being set must be for a valid method signature" ) ; userPermissions [ _who ] [ _methodsignature ] = true ; }
function configure ( uint256 _startTime , uint256 _endTime , uint256 [ ] _ratePerTier , uint256 [ ] _ratePerTierDiscountPoly , uint256 [ ] _tokensPerTierTotal , uint256 [ ] _tokensPerTierDiscountPoly , uint256 _nonAccreditedLimitUSD , uint256 _minimumInvestmentUSD , FundRaiseType [ ] _fundRaiseTypes , address _wallet , address _reserveWallet , address _usdToken ) public onlyFactory { modifyTimes ( _startTime , _endTime ) ; modifyTiers ( _ratePerTier , _ratePerTierDiscountPoly , _tokensPerTierTotal , _tokensPerTierDiscountPoly ) ; modifyFunding ( _fundRaiseTypes ) ; modifyAddresses ( _wallet , _reserveWallet , _usdToken ) ; modifyLimits ( _nonAccreditedLimitUSD , _minimumInvestmentUSD ) ; }
function getIntel ( uint intelIndex ) public view returns ( address intelProvider , uint depositAmount , uint desiredReward , uint balance , uint intelID , uint rewardAfter , bool rewarded ) { IntelState storage intel = intelDB [ intelIndex ] ; intelProvider = intel . intelProvider ; depositAmount = intel . depositAmount ; desiredReward = intel . desiredReward ; balance = intel . balance ; rewardAfter = intel . rewardAfter ; intelID = intel . intelID ; rewarded = intel . rewarded ; }
function _issueAttribute ( address account ) internal returns ( bool ) { _jurisdiction . issueAttribute ( account , _validAttributeTypeID , 0 ) ; return true ; }
function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { token . mint ( target , mintedAmount ) ; }
function registerPreSignedHashing ( address _investContract , bytes32 _strategyID , uint256 _registerFee , uint256 _periodLength , uint256 _maxMarginDeposit , uint256 _minMarginDeposit , uint256 _rewardPercentage , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x7fa5aa9d ) , _investContract , _strategyID , _registerFee , _periodLength , _maxMarginDeposit , _minMarginDeposit , _rewardPercentage , _nonce ) ) ; }
function setDisputeFee ( uint256 fee ) onlyOwner public { dispute_fee = fee ; emit LogSetDisputeFee ( fee ) ; }
function votingEndsInHHMM ( ) constant returns ( uint16 , uint16 ) { var tsec = VOTING_END_TIME - now ; return VOTING_END_TIME == 0 ? ( 0 , 0 ) : ( uint16 ( tsec / 1 hours ) , uint16 ( tsec % 1 hours / 1 minutes ) ) ; }
function getModulesByType ( uint8 _type ) external view returns ( address [ ] ) { return modules [ _type ] ; }
function escapeHatch ( ) onlyEscapeCallerOrOwner { uint total = this . balance ; if ( ! escapeDestination . send ( total ) ) { throw ; } EscapeCalled ( total ) ; }
function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) external { }
function setNonEtherController ( address _controller ) external validAddress ( _controller ) timedStateChange ( address ( 0 ) , 0 , true ) onlymanyowners ( keccak256 ( msg . data ) ) { m_nonEtherController = _controller ; }
function getVersion ( ) external view returns ( uint8 [ ] ) ;
function name ( ) external pure returns ( string ) { return NAME ; }
function matchByAdmin_TwH36 ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 3 ] ; address user = userId2Address [ data & USER_MASK ] ; require ( data >> 224 > userNonce [ user ] ) ; address token ; bool isBuy ; ( token , isBuy ) = decodeOrderTokenAndIsBuy ( data ) ; bytes32 orderHash = keccak256 ( this , inputs [ 0 ] , inputs [ 1 ] , inputs [ 2 ] , data & MATCH_SIGN_MASK | ( isBuy ? ORDER_ISBUY : 0 ) | uint256 ( token ) ) ; require ( verify ( orderHash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ 4 ] ) , bytes32 ( inputs [ 5 ] ) ) ) ; uint256 tokenExecute = isBuy ? inputs [ 1 ] : inputs [ 0 ] ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; require ( tokenExecute != 0 ) ; uint256 etherExecute = 0 ; isBuy = ! isBuy ; for ( uint256 i = 6 ; i < inputs . length ; i += 6 ) { require ( tokenExecute > 0 && inputs [ 1 ] . mul ( inputs [ i + 1 ] ) <= inputs [ 0 ] . mul ( inputs [ i ] ) ) ; data = inputs [ i + 3 ] ; user = userId2Address [ data & USER_MASK ] ; require ( data >> 224 > userNonce [ user ] ) ; bytes32 makerOrderHash = keccak256 ( this , inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , data & MATCH_SIGN_MASK | ( isBuy ? ORDER_ISBUY : 0 ) | uint256 ( token ) ) ; require ( verify ( makerOrderHash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ i + 4 ] ) , bytes32 ( inputs [ i + 5 ] ) ) ) ; ( tokenExecute , etherExecute ) = internalTrade ( inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , data , tokenExecute , etherExecute , isBuy , token , 0 , makerOrderHash ) ; } isBuy = ! isBuy ; tokenExecute = isBuy ? inputs [ 1 ] . sub ( tokenExecute ) : inputs [ 0 ] . sub ( tokenExecute ) ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; processTakerOrder ( inputs [ 2 ] , inputs [ 3 ] , tokenExecute , etherExecute , isBuy , token , 0 , orderHash ) ; }
function updatePendingManager ( address _pendingManager , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _pendingManager ) , _block ) ; if ( OK != _code ) { return _code ; } pendingManager = _pendingManager ; return OK ; }
function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; buyNormal ( _th ) ; return true ; }
function supportsInterface ( bytes4 interfaceID ) external view returns ( bool ) { return ( ( interfaceID == ERC165InterfaceId ) || ( interfaceID == ERC721InterfaceId ) || ( interfaceID == ERC721EnumerableInterfaceId ) || ( interfaceID == ERC721MetadataInterfaceId ) || ( interfaceID == ERC721TokenReceiverInterfaceId ) ) ; }
function isValidSignature ( address signer , bytes32 hash , uint8 v , bytes32 r , bytes32 s ) private pure returns ( bool ) { return signer == ecrecover ( keccak256 ( abi . encodePacked ( "\x19Ethereum Signed Message:\n32" , hash ) ) , v , r , s ) ; }
function release ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _seller , "Must be seller" ) ; return doRelease ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }
function onApprove ( address _owner , address _spender , uint _amount ) external returns ( bool ) ;
function incApprove ( address _from , address _spender , uint _value ) external onlyModule returns ( bool ) { allowed [ _from ] [ _spender ] = allowed [ _from ] [ _spender ] . add ( _value ) ; return true ; }
function ownerClawback ( ) external onlyOwner { require ( now >= OWNER_CLAWBACK_DATE ) ; owner . transfer ( this . balance ) ; }
function approve ( address _to , uint256 _tokenId ) public whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
function exchangeNominsForHavvensAtRate ( uint nominAmount , uint guaranteedRate ) public pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToHavPrice ) ; return exchangeNominsForHavvens ( nominAmount ) ; }
function generateSecurityToken ( string _name , string _ticker , string _tokenDetails , bool _divisible ) external whenNotPausedOrOwner { require ( bytes ( _name ) . length > 0 && bytes ( _ticker ) . length > 0 , "Ticker length > 0" ) ; string memory ticker = Util . upper ( _ticker ) ; bytes32 statusKey = Encoder . getKey ( "registeredTickers_status" , ticker ) ; require ( ! getBool ( statusKey ) , "Already deployed" ) ; set ( statusKey , true ) ; require ( _tickerOwner ( ticker ) == msg . sender , "Not authorised" ) ; require ( getUint ( Encoder . getKey ( "registeredTickers_expiryDate" , ticker ) ) >= now , "Ticker gets expired" ) ; uint256 launchFee = getSecurityTokenLaunchFee ( ) ; if ( launchFee > 0 ) require ( IERC20 ( getAddress ( POLYTOKEN ) ) . transferFrom ( msg . sender , address ( this ) , launchFee ) , "Insufficient allowance" ) ; address newSecurityTokenAddress = ISTFactory ( getSTFactoryAddress ( ) ) . deployToken ( _name , ticker , 18 , _tokenDetails , msg . sender , _divisible , getAddress ( POLYMATHREGISTRY ) ) ; _storeSecurityTokenData ( newSecurityTokenAddress , ticker , _tokenDetails , now ) ; set ( Encoder . getKey ( "tickerToSecurityToken" , ticker ) , newSecurityTokenAddress ) ; emit NewSecurityToken ( ticker , _name , newSecurityTokenAddress , msg . sender , now , msg . sender , false , launchFee ) ; }
function getCurrencyDenominated ( ) external view returns ( bytes32 ) ;
function init ( bytes32 [ ] args ) public ;
function verifyTokens ( uint64 _buyTokens , uint64 _sellToken ) internal pure returns ( bool ) { return ( ( uint32 ( _buyTokens ) == uint32 ( _sellToken >> 32 ) ) && ( uint32 ( _sellToken ) == uint32 ( _buyTokens >> 32 ) ) && ( uint32 ( _buyTokens >> 32 ) <= uint32 ( _buyTokens ) ) ) ; }
function setPayoutDistributionId ( ) internal { uint24 [ 21 ] memory auxArr = PayoutDistribution . getDistribution ( tokens . length ) ; for ( uint256 i = 0 ; i < auxArr . length ; i ++ ) { payoutDistribution [ i ] = auxArr [ i ] ; } superiorQuota = PayoutDistribution . getSuperiorQuota ( tokens . length ) ; }
function exists ( uint64 _pixelconIndex ) public view returns ( bool ) { return ( marketPixelconListings [ _pixelconIndex ] . seller != address ( 0 ) ) ; }
function fail ( ) external timedStateChange requiresState ( IcoState . PAUSED ) onlymanyowners ( sha3 ( msg . data ) ) { changeState ( IcoState . FAILED ) ; }
function __callback ( bytes32 myid , string result , bytes proof ) public { require ( msg . sender == oraclize_cbAddress ( ) ) ; setPrices ( result ) ; updatePrice ( ) ; }
function addFiveParticipants ( address participant1 , address participant2 , address participant3 , address participant4 , address participant5 ) public onlyAdmin returns ( bool ) { require ( addParticipant ( participant1 ) ) ; require ( addParticipant ( participant2 ) ) ; require ( addParticipant ( participant3 ) ) ; require ( addParticipant ( participant4 ) ) ; require ( addParticipant ( participant5 ) ) ; return true ; }
function cancelPledge ( uint64 idPledge , uint amount ) { idPledge = normalizePledge ( idPledge ) ; Pledge storage p = findPledge ( idPledge ) ; require ( p . oldPledge != 0 ) ; PledgeAdmin storage m = findAdmin ( p . owner ) ; checkAdminOwner ( m ) ; uint64 oldPledge = getOldestPledgeNotCanceled ( p . oldPledge ) ; doTransfer ( idPledge , oldPledge , amount ) ; }
function requestVotingRights ( uint _numTokens ) external { require ( token . balanceOf ( msg . sender ) >= _numTokens ) ; voteTokenBalance [ msg . sender ] += _numTokens ; require ( token . transferFrom ( msg . sender , this , _numTokens ) ) ; _VotingRightsGranted ( _numTokens , msg . sender ) ; }
function freezeTransfers ( ) public onlyOwner { require ( ! freeze ) ; freeze = true ; emit LogFreezeTransfers ( freeze , now ) ; }
function checkPermission ( address _delegate , address _module , bytes32 _perm ) external view returns ( bool ) { if ( delegateDetails [ _delegate ] != bytes32 ( 0 ) ) { return perms [ _module ] [ _delegate ] [ _perm ] ; } else return false ; }
function finalize ( ) external { if ( ! funding ) throw ; if ( ( block . number <= fundingEndBlock || totalTokens < tokenCreationMin ) && totalTokens < tokenCreationCap ) throw ; funding = false ; }
function withdraw ( ) external returns ( bool ) { require ( _ended ) ; for ( uint i = 0 ; i < 100 ; ++ i ) { require ( _topBids [ i ] . bidderAddress != msg . sender ) ; } uint amount = _bidders [ msg . sender ] . value ; if ( amount > 0 ) { _bidders [ msg . sender ] . value = 0 ; msg . sender . transfer ( amount ) ; } return true ; }
function distributeFixed ( uint index , address [ ] _addrs , uint _amoutToEach ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _amoutToEach ) ; } } else revert ( "Distribution Failed: Coun Down not gone yet" ) ; }
function deposit ( address _darknode , ERC20 _token , uint256 _value ) public payable { uint256 receivedValue = _value ; if ( address ( _token ) == ETHEREUM ) { require ( msg . value == _value , "mismatched ether value" ) ; } else { require ( msg . value == 0 , "unexpected ether value" ) ; receivedValue = CompatibleERC20 ( _token ) . safeTransferFromWithFees ( msg . sender , address ( this ) , _value ) ; } darknodeBalances [ _darknode ] [ _token ] = darknodeBalances [ _darknode ] [ _token ] . add ( receivedValue ) ; }
function transferFrom ( address from , address to , uint256 tokenAmount ) public tradable ( from ) returns ( bool success ) { require ( tokenAmount > 0 ) ; require ( tokenAmount <= balances [ from ] ) ; require ( tokenAmount <= allowed [ from ] [ msg . sender ] ) ; balances [ from ] = balances [ from ] . sub ( tokenAmount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( from , to , tokenAmount ) ; return true ; }
function _mintItem ( uint256 _classId , address _address ) internal { ItemClass storage class = classIdToClass [ _classId ] ; uint [ ] memory stats = new uint [ ] ( 6 ) ; for ( uint j = 0 ; j < class . statsMin . length ; j ++ ) { if ( class . statsMax [ j ] > 0 ) { if ( stats . length == class . statsMin . length ) { stats [ j ] = getRandom ( class . statsMin [ j ] , class . statsMax [ j ] , uint8 ( j + _classId + class . total ) , lastMinter ) ; } } else { if ( stats . length == class . statsMin . length ) { stats [ j ] = 0 ; } } } ItemData storage _itemData = tokenToData [ totalTokens + 1 ] ; _itemData . tokenId = totalTokens + 1 ; _itemData . classId = _classId ; _itemData . stats = stats ; _itemData . gen = currentGen ; class . total += 1 ; totalTokens += 1 ; _mint ( _address , totalTokens ) ; _setTokenURI ( totalTokens , addToString ( _baseURI , uint2str ( totalTokens ) ) ) ; lastMinter = _address ; emit ItemMinted ( class . classId , class . price , class . total , totalTokens ) ; }
function importIssuerData ( address [ ] accounts , uint [ ] sUSDAmounts ) external onlyOwner onlyDuringSetup { require ( accounts . length == sUSDAmounts . length , "Length mismatch" ) ; for ( uint8 i = 0 ; i < accounts . length ; i ++ ) { _addToDebtRegister ( accounts [ i ] , sUSDAmounts [ i ] ) ; } }
function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData ) internal { address senderImplementation = interfaceAddr ( _from , "ERC777TokensSender" ) ; if ( senderImplementation == 0 ) { return ; } ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _data , _operatorData ) ; }
function tokenHardcapIssued ( ) public view returns ( uint ) { return tokenSoftcap + tokenHardcapIssuedValue ; }
function calculateMint ( uint256 _stakeNumber ) internal view returns ( uint256 reward ) { uint256 currentBlock = calculateCurrentBlock ( _stakeNumber ) ; uint256 lastBlockWithdrawn = stakes [ msg . sender ] [ _stakeNumber ] . lastBlockWithdrawn ; uint256 blocksToReward = currentBlock . sub ( lastBlockWithdrawn ) ; reward = blocksToReward . mul ( stakes [ msg . sender ] [ _stakeNumber ] . rewardPerBlock ) ; uint256 totalToMint = stakes [ msg . sender ] [ _stakeNumber ] . totalCoinsToMint ; uint256 currentCoinsMinted = stakes [ msg . sender ] [ _stakeNumber ] . coinsMinted ; uint256 newCoinsMinted = currentCoinsMinted . add ( reward ) ; if ( newCoinsMinted > totalToMint ) { reward = newCoinsMinted . sub ( totalToMint ) ; } }
function symbol ( ) external view returns ( string _symbol ) ;
function _payDividend ( address _payee , Dividend storage _dividend , uint256 _dividendIndex ) internal { ( uint256 claim , uint256 withheld ) = calculateDividend ( _dividendIndex , _payee ) ; _dividend . claimed [ _payee ] = true ; _dividend . claimedAmount = claim . add ( _dividend . claimedAmount ) ; uint256 claimAfterWithheld = claim . sub ( withheld ) ; if ( claimAfterWithheld > 0 ) { require ( IERC20 ( dividendTokens [ _dividendIndex ] ) . transfer ( _payee , claimAfterWithheld ) , "transfer failed" ) ; _dividend . dividendWithheld = _dividend . dividendWithheld . add ( withheld ) ; investorWithheld [ _payee ] = investorWithheld [ _payee ] . add ( withheld ) ; emit ERC20DividendClaimed ( _payee , _dividendIndex , dividendTokens [ _dividendIndex ] , claim , withheld ) ; } }
function broadcastSignedRequestAsPayerAction ( bytes _requestData , address [ ] _payeesPaymentAddress , uint256 [ ] _payeeAmounts , uint256 [ ] _additionals , uint256 _expirationDate , bytes _signature ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( _expirationDate >= block . timestamp , "expiration should be after current time" ) ; require ( Signature . checkRequestSignature ( _requestData , _payeesPaymentAddress , _expirationDate , _signature ) , "signature should be correct" ) ; return createAcceptAndPayFromBytes ( _requestData , _payeesPaymentAddress , _payeeAmounts , _additionals ) ; }
function buyPriceAt ( uint256 _tokenAllocWithoutDiscount ) internal returns ( uint ) { if ( stageNow ( ) == stageAt . publicSale ) { publicAllocatingToken = publicAllocatingToken . add ( _tokenAllocWithoutDiscount ) ; require ( publicAllocatingToken <= publicSaleSupply ) ; return _tokenAllocWithoutDiscount ; } if ( stageNow ( ) == stageAt . privatePresale ) { uint _privatePresaleAlloc = _tokenAllocWithoutDiscount + percent ( _tokenAllocWithoutDiscount , 5 ) ; privatePresaleAllocatingToken = privatePresaleAllocatingToken . add ( _privatePresaleAlloc ) ; require ( privatePresaleAllocatingToken <= privatePresaleSupply ) ; return _privatePresaleAlloc ; } if ( stageNow ( ) == stageAt . privatePlacement ) { uint _privatePlacementAlloc = _tokenAllocWithoutDiscount + percent ( _tokenAllocWithoutDiscount , 10 ) ; privatePlacementAllocatingToken = privatePlacementAllocatingToken . add ( _privatePlacementAlloc ) ; require ( privatePlacementAllocatingToken <= privatePlacementSupply ) ; return _privatePlacementAlloc ; } if ( stageNow ( ) == stageAt . notStart ) { return 0 ; } if ( stageNow ( ) == stageAt . finalState ) { return 0 ; } }
function getTagsByTypeAndToken ( uint8 _moduleType , address _securityToken ) external view returns ( bytes32 [ ] , address [ ] ) ;
function levelUp ( uint256 _factoryId ) public payable onlyExistingUser { Factory storage factory = factories [ _factoryId ] ; uint256 price = getPrice ( factory . ftype , factory . level + 1 ) ; uint256 userId = addressToUser [ msg . sender ] ; User storage user = users [ userId ] ; require ( _checkPayment ( user , factory . ftype , factory . level + 1 ) ) ; user . balance = user . balance . add ( msg . value ) ; user . balance = user . balance . sub ( price ) ; user . totalPay = user . totalPay . add ( price ) ; totalDeposit += msg . value ; _distributeInvestment ( msg . value ) ; _distributeReferrers ( userId , price ) ; _collectResource ( factory , user ) ; factory . level ++ ; _updateLeaders ( msg . sender , msg . value ) ; emit LevelUp ( _factoryId , factory . level , userId , price ) ; }
function vacate ( address _addr ) returns ( bool ) ;
function checkBalance ( address _backerAddress , uint index ) constant returns ( uint , uint , bytes32 , bool , bool ) { return ( backers [ _backerAddress ] [ index ] . tokenPrice , backers [ _backerAddress ] [ index ] . tokenAmount , backers [ _backerAddress ] [ index ] . privateHash , backers [ _backerAddress ] [ index ] . prepaid , backers [ _backerAddress ] [ index ] . claimed ) ; }
function batchTransferFrom ( address [ ] spenders , address [ ] recipients , uint [ ] quantities ) external pausableIfNotSelfDestructing requireSameLength ( spenders . length , recipients . length ) requireSameLength ( recipients . length , quantities . length ) returns ( bool ) { uint length = spenders . length ; for ( uint i = 0 ; i < length ; i ++ ) { transferFrom ( spenders [ i ] , recipients [ i ] , quantities [ i ] ) ; } return true ; }
function trimAddressArray ( address [ 11 ] addresses ) internal pure returns ( address [ ] ) { uint256 length = 0 ; for ( uint256 index = 0 ; index < 11 ; index ++ ) { if ( addresses [ index ] == 0x0 ) { continue ; } length ++ ; } address [ ] memory trimmedArray = new address [ ] ( length ) ; for ( index = 0 ; index < length ; index ++ ) { trimmedArray [ index ] = addresses [ index ] ; } return trimmedArray ; }
function round ( uint256 _n , uint256 _m ) internal pure returns ( uint256 ) { uint256 res = 0 ; uint256 p = _n / _m ; res = _n - ( _m * p ) ; if ( res >= 1 ) { res = p + 1 ; } else { res = p ; } return res ; }
function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) external returns ( address ) ;
function canRelease ( address who ) public view returns ( bool ) { Holding memory holding = heldTokens [ who ] ; if ( holding . releaseDate == 0 || holding . quantity == 0 ) return false ; return block . timestamp > holding . releaseDate ; }
function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens -= voterTokens ; challenges [ _challengeID ] . rewardPool -= reward ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; emit _RewardClaimed ( _challengeID , reward , msg . sender ) ; require ( token . transfer ( msg . sender , reward ) ) ; }
function votedPerCent ( address voter ) constant public returns ( uint ) { var rawVote = rawVotes [ voter ] ; if ( rawVote < MAX_AMOUNT_EQU_0_PERCENT ) return 0 ; else if ( rawVote >= MIN_AMOUNT_EQU_100_PERCENT ) return 100 ; else return rawVote * 100 / 1 ether ; }
function freezeAdministrationContract ( ) public onlyAdmin notFrozen returns ( bool frozen ) { administrationContractFrozen = true ; return true ; }
function createAccountForUser ( address _newUser ) internal nonZero ( _newUser ) { registry . createNewAccount ( _newUser ) ; uint256 _accountId = registry . accountIdForAddress ( _newUser ) ; emit AccountCreated ( _accountId , _newUser ) ; }
function burn ( uint256 _value ) checkGranularity ( _value ) public { adjustInvestorCount ( msg . sender , address ( 0 ) , _value ) ; require ( tokenBurner != address ( 0 ) , "Token Burner contract address is not set yet" ) ; require ( verifyTransfer ( msg . sender , address ( 0 ) , _value ) , "Transfer is not valid" ) ; require ( _value <= balances [ msg . sender ] , "Value should no be greater than the balance of msg.sender" ) ; adjustBalanceCheckpoints ( msg . sender ) ; adjustTotalSupplyCheckpoints ( ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; require ( tokenBurner . burn ( msg . sender , _value ) , "Token burner process is not validated" ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; emit Burnt ( msg . sender , _value ) ; emit Transfer ( msg . sender , address ( 0 ) , _value ) ; }
function register ( address _newAddress ) { keys [ msg . sender ] = _newAddress ; RegisterNewKey ( msg . sender , _newAddress ) ; }
function claimTokens ( address _token ) external onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } SNKToken token = SNKToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }
function ownerWithdraw ( uint256 value ) external onlyOwner { if ( ! owner . send ( value ) ) revert ( ) ; }
function withdraw ( address _address , uint256 _amount ) public onlyOwner returns ( bool ) { if ( deposited [ _address ] < _amount ) { error ( 'Escrow: not enough balance' ) ; return false ; } deposited [ _address ] = deposited [ _address ] . sub ( _amount ) ; return SCTokens . transfer ( _address , _amount ) ; }
function setProtocolVersion ( address _STFactoryAddress , uint8 _major , uint8 _minor , uint8 _patch ) external ;
function getAttributeTypeIDs ( ) external view returns ( uint256 [ ] ) { return _attributeIDs ; }
function initialiseMultisig ( address authority , uint unlockTime ) public payable returns ( bytes32 msigId ) { require ( msg . sender != authority ) ; require ( msg . value > 0 ) ; msigId = keccak256 ( msg . sender , authority , msg . value , unlockTime ) ; Multisig storage multisig = hashIdToMultisig [ msigId ] ; if ( multisig . deposit == 0 ) { multisig . owner = msg . sender ; multisig . authority = authority ; } reparametrizeMultisig ( msigId , unlockTime ) ; }
function executeRequest ( uint id ) external pre_cond ( ! isShutDown ) pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( requests [ id ] . requestType != RequestType . redeem || requests [ id ] . shareQuantity <= balances [ requests [ id ] . participant ] ) pre_cond ( totalSupply == 0 || ( now >= add ( requests [ id ] . timestamp , module . pricefeed . getInterval ( ) ) && module . pricefeed . getLastUpdateId ( ) >= add ( requests [ id ] . atUpdateId , 2 ) ) ) { Request request = requests [ id ] ; require ( module . pricefeed . hasRecentPrice ( address ( request . requestAsset ) ) ) ; uint costQuantity = toWholeShareUnit ( mul ( request . shareQuantity , calcSharePriceAndAllocateFees ( ) ) ) ; if ( request . requestAsset == address ( NATIVE_ASSET ) ) { var ( isPriceRecent , invertedNativeAssetPrice , nativeAssetDecimal ) = module . pricefeed . getInvertedPrice ( address ( NATIVE_ASSET ) ) ; if ( ! isPriceRecent ) { revert ( ) ; } costQuantity = mul ( costQuantity , invertedNativeAssetPrice ) / 10 ** nativeAssetDecimal ; } if ( isInvestAllowed && request . requestType == RequestType . invest && costQuantity <= request . giveQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transferFrom ( request . participant , this , costQuantity ) ) ; createShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . redeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . tokenFallbackRedeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( this , request . shareQuantity ) ; } else { revert ( ) ; } }
function totalSupply ( ) external view returns ( uint256 ) { return rareArray . length - 1 ; }
function inject ( address who , address origin ) external only_owner { s_paid [ who ] . push ( origin ) ; Paid ( who , origin ) ; }
function deposit ( address _user ) public payable isOpen depositIsConfigCompliant canDeposit ( _user ) { if ( ! invested [ _user ] ) { swimmersList . push ( _user ) ; invested [ _user ] = true ; } weiRaised = weiRaised . add ( msg . value ) ; swimmers [ _user ] = swimmers [ _user ] . add ( msg . value ) ; emit Deposit ( msg . sender , msg . value ) ; }
function removeHandlerFromWhitelist ( address handler ) public onlyOwner handlerWhitelisted ( handler ) { delete handlerWhitelistMap [ handler ] ; for ( uint i = 0 ; i < handlerWhitelistArray . length ; i ++ ) { if ( handlerWhitelistArray [ i ] == handler ) { handlerWhitelistArray [ i ] = handlerWhitelistArray [ handlerWhitelistArray . length - 1 ] ; handlerWhitelistArray . length -= 1 ; break ; } } emit GenericEvent ( 2 ) ; }
function setTokenMetadata ( uint256 _tokenId , string meta ) public onlyPlatform exists ( _tokenId ) { metadata [ _tokenId ] = MetaData ( meta ) ; }
function performCalculations ( ) view returns ( uint gav , uint managementFee , uint performanceFee , uint unclaimedFees , uint feesShareQuantity , uint nav , uint sharePrice ) { gav = calcGav ( ) ; ( managementFee , performanceFee , unclaimedFees ) = calcUnclaimedFees ( gav ) ; nav = calcNav ( gav , unclaimedFees ) ; feesShareQuantity = ( gav == 0 ) ? 0 : mul ( totalSupply , unclaimedFees ) / gav ; uint totalSupplyAccountingForFees = add ( totalSupply , feesShareQuantity ) ; sharePrice = nav > 0 ? calcValuePerShare ( gav , totalSupplyAccountingForFees ) : toSmallestShareUnit ( 1 ) ; }
function balanceOf ( address _from ) public view returns ( uint balance ) { return balances [ _from ] ; }
function withdraw ( address token , uint256 amount ) external { require ( amount > 0 ) ; require ( getTime ( ) > userLock [ msg . sender ] && userLock [ msg . sender ] != 0 ) ; balances [ token ] [ msg . sender ] = balances [ token ] [ msg . sender ] . sub ( amount ) ; if ( token == 0 ) { msg . sender . transfer ( amount ) ; } else { require ( ERC20 ( token ) . transfer ( msg . sender , amount ) ) ; } Withdraw ( token , msg . sender , amount , balances [ token ] [ msg . sender ] ) ; }
function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }
function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
function multiTransferTightlyPacked ( bytes32 [ ] _addressesAndAmounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addressesAndAmounts . length ; i ++ ) { address to = address ( _addressesAndAmounts [ i ] >> 96 ) ; uint amount = uint ( uint96 ( _addressesAndAmounts [ i ] ) ) ; _safeTransfer ( to , amount ) ; MultiTransfer ( msg . sender , msg . value , to , amount ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }
function withdrawEth ( address to , uint256 value ) onlyOwner public { to . transfer ( value ) ; }
function writeSha3 ( string calldata _permlink , bytes32 _hashSha ) external returns ( bool ) { bytes32 hash = calculateSha3 ( _permlink ) ; require ( ! permlinkSaved [ hash ] , "Permalink already exist!" ) ; permlinkSaved [ hash ] = true ; emit SynpatRecord ( _permlink , _hashSha ) ; return true ; }
function burn ( uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
function revealPeriodActive ( uint _pollID ) constant public returns ( bool active ) { require ( pollExists ( _pollID ) ) ; return ! isExpired ( pollMap [ _pollID ] . revealEndDate ) && ! commitPeriodActive ( _pollID ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 ) { uint256 balance = balances [ _owner ] ; for ( uint cellIndex = 0 ; cellIndex < frozenBalances [ _owner ] . length ; ++ cellIndex ) { balance = balance . add ( frozenBalances [ _owner ] [ cellIndex ] . amount ) ; } return balance ; }
function selfDestruct ( ) external onlyOwner { require ( selfDestructInitiated , "Self-destruct not yet initiated." ) ; require ( selfDestructInitiationTime + SELFDESTRUCT_DELAY < now , "Self-destruct delay has not yet elapsed." ) ; address beneficiary = selfDestructBeneficiary ; emit SelfDestructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; }
function transferAdminship ( address _newAdmin ) onlyAdmin public { admin = _newAdmin ; TransferAdminship ( admin ) ; }
function proposal ( uint _proposalId ) public view returns ( address _proposer , uint _startBlock , uint _startTime , uint _duration , bytes32 _storageHash , bool _active , bool _finalized , uint _totalYes , uint _totalNo , address _token , bool _approved , bool _denied , bool _hasBalance ) { require ( _proposalId < proposals . length ) ; Proposal memory p = proposals [ _proposalId ] ; _proposer = p . proposer ; _startBlock = p . startBlock ; _startTime = p . startTime ; _duration = p . duration ; _storageHash = p . storageHash ; _finalized = ( _startTime + _duration < now ) ; _active = ! _finalized && ( p . startBlock < getBlockNumber ( ) ) && p . approved ; _totalYes = p . yesVotes ; _totalNo = p . noVotes ; _token = p . token ; _approved = p . approved ; _denied = p . denied ; _hasBalance = ( p . token == 0x0 ) ? false : ( MiniMeToken ( p . token ) . balanceOf ( msg . sender ) > 0 ) ; }
function getAttackRanking ( ) external view returns ( address [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint counter = 0 ; for ( uint k = 0 ; k < len ; k ++ ) { ( , , , arr [ counter ] ) = getPlayersBattleStats ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; counter ++ ; } for ( uint i = 0 ; i < len - 1 ; i ++ ) { for ( uint j = 0 ; j < len - i - 1 ; j ++ ) { if ( arr [ j ] < arr [ j + 1 ] ) { uint256 temp = arr [ j ] ; address temp_addr = arr_addr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; arr_addr [ j ] = arr_addr [ j + 1 ] ; arr_addr [ j + 1 ] = temp_addr ; } } } return ( arr_addr , arr ) ; }
function changeMinter ( address newMinter ) public validate_address ( newMinter ) onlyAdmin { if ( minter == newMinter ) revert ( ) ; MinterOwnershipTransferred ( minter , newMinter ) ; minter = newMinter ; }
function onBurn ( address _owner , uint _tokensToBurn ) public returns ( bool ) { require ( msg . sender == address ( tokenContract ) ) ; uint256 feeTotal = tokenContract . totalPledgedFees ( ) ; uint256 totalTokens = tokenContract . totalSupply ( ) ; uint256 feeValueOfTokens = ( feeTotal . mul ( _tokensToBurn ) ) . div ( totalTokens ) ; require ( tokenContract . destroyTokens ( _owner , _tokensToBurn ) ) ; require ( this . balance >= feeValueOfTokens ) ; require ( _owner . send ( feeValueOfTokens ) ) ; LogClaim ( _owner , feeValueOfTokens ) ; return true ; }
function reissueAsset ( bytes32 _symbol , uint _value ) public returns ( uint ) { return reissueAssetToRecepient ( _symbol , _value , msg . sender ) ; }
function getModulesByType ( uint8 _moduleType ) external view returns ( address [ ] ) ;
function unlock ( ) public { unlockInvestor ( msg . sender ) ; }
function tokenByIndex ( uint256 _index ) external pure returns ( uint256 ) { return _index ; }
function sell ( uint256 quantity , uint256 price , uint256 expiry ) public { require ( quantity > 0 , "You must supply a quantity." ) ; require ( price > 0 , "The sale price cannot be zero." ) ; require ( expiry > block . timestamp , "Cannot have an expiry date in the past." ) ; require ( price >= sellFloor , "The ask is below the minimum allowed." ) ; require ( sellCeiling == 0 || price <= sellCeiling , "The ask is above the maximum allowed." ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , "You must approve the transfer of tokens before offering them for sale." ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , "Not enough tokens owned to complete the order." ) ; orderBook [ msg . sender ] = TradeOrder ( quantity , price , expiry ) ; emit TokensOffered ( msg . sender , quantity , price , expiry ) ; }
function burnAllTokens ( ) public onlyOwner mustBeAtStage ( Stage . Finalized ) { uint thisTokenBalance = token . balanceOf ( address ( this ) ) ; if ( thisTokenBalance > 0 ) { token . burn ( thisTokenBalance ) ; } }
function setMyICOContract ( address _SCICO ) public onlyOwner { addressSCICO = _SCICO ; }
function approve ( address _spender , uint256 _amount ) stopOnPause public returns ( bool success ) { require ( _spender != 0x0 ) ; allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
function burn ( uint256 _value ) onlyowner public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; totalHurify = safeSub ( totalHurify , _value ) ; Burn ( msg . sender , _value ) ; return true ; }
function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == INTERFACE_SIGNATURE_ERC165 ) || ( _interfaceID == INTERFACE_SIGNATURE_ERC721 ) ) ; }
function bookCanvasFor ( uint32 _canvasId , address _bookFor ) external onlyOwner { Canvas storage _canvas = _getCanvas ( _canvasId ) ; _canvas . bookedFor = _bookFor ; }
function sell ( uint256 amount ) public { require ( balanceOf [ msg . sender ] >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
function notifyOfArbitrationRequest ( bytes32 question_id , address requester , uint256 max_previous ) onlyArbitrator ( question_id ) stateOpen ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external { require ( questions [ question_id ] . bond > 0 , "Question must already have an answer when arbitration is requested" ) ; questions [ question_id ] . is_pending_arbitration = true ; emit LogNotifyOfArbitrationRequest ( question_id , requester ) ; }
function burn ( uint256 _value ) public onlyOwner returns ( bool success ) { require ( ! _frozenAccount [ _owner ] ) ; require ( _balanceOf [ _owner ] >= _value ) ; _balanceOf [ _owner ] -= _value ; _totalSupply -= _value ; Burn ( _owner , _value ) ; return true ; }
function getForwardedAccount ( Data storage self , address account ) internal view returns ( address registeredAccount ) { bytes32 id = keccak256 ( abi . encodePacked ( 'master.account' , account ) ) ; address originalAccount = self . Storage . getAddress ( id ) ; if ( originalAccount != 0x0 ) { return originalAccount ; } else { return account ; } }
function changeFactorySetupFee ( uint256 _newSetupCost ) public onlyOwner { emit LogChangeFactorySetupFee ( setupCost , _newSetupCost , address ( this ) ) ; setupCost = _newSetupCost ; }
function distribute ( uint256 _amount ) external onlyContract ( "FeeManager" ) returns ( bool ) { totalMintedActPerLockedBbkToken = totalMintedActPerLockedBbkToken . add ( _amount . mul ( 1e18 ) . div ( totalLockedBBK ) ) ; uint256 _delta = ( _amount . mul ( 1e18 ) % totalLockedBBK ) . div ( 1e18 ) ; mintedActFromPastLockPeriodsPerUser [ owner ] = mintedActFromPastLockPeriodsPerUser [ owner ] . add ( _delta ) ; totalSupply_ = totalSupply_ . add ( _amount ) ; emit Mint ( _amount ) ; return true ; }
function isRegisteredFirm ( Data storage self , string issuerFirm ) internal view returns ( bool registered ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.firm' , issuerFirm ) ) ; return self . Storage . getBool ( id ) ; }
function buy_energy ( address aproducer , uint32 aday , uint32 aprice , uint64 aenergy ) onlyRegisteredConsumers external { buy_energy_core ( aproducer , aday , aprice , aenergy , consumers [ msg . sender ] , 0 ) ; }
function giftAsset ( address _to , uint256 _tokenId ) public whenNotPaused { safeTransferFrom ( msg . sender , _to , _tokenId ) ; }
function getTitle ( ) public view returns ( string ) { return "Ether Dividend Checkpoint" ; }
function totalSupply ( ) constant public returns ( uint256 _total_supply ) { _total_supply = TokenInfoController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_INFO ) ) . get_total_supply ( ) ; }
function setIcosMinLimit ( uint256 newIcoMin , uint256 newPreIcoLimit ) isOwner { require ( newIcoMin > 0 ) ; require ( newPreIcoLimit > 0 ) ; icoMin = newIcoMin ; preIcoLimit = newPreIcoLimit ; updatePrices ( ) ; }
function enableScriptExecutor ( uint256 _executorId ) external authP ( REGISTRY_MANAGER_ROLE , arr ( _executorId ) ) executorExists ( _executorId ) { ExecutorEntry storage executorEntry = executors [ _executorId ] ; require ( ! executorEntry . enabled , ERROR_EXECUTOR_ENABLED ) ; executorEntry . enabled = true ; emit EnableExecutor ( _executorId , executorEntry . executor ) ; }
function mint ( address _holder , uint256 _tokens ) public onlyMintingAgents ( ) { require ( allowedMinting == true && totalSupply_ . add ( _tokens ) <= maxSupply ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ _holder ] = balances [ _holder ] . add ( _tokens ) ; if ( totalSupply_ == maxSupply ) { allowedMinting = false ; } emit Transfer ( address ( 0 ) , _holder , _tokens ) ; emit Mint ( _holder , _tokens ) ; }
function tokenFallback ( address from , uint amount , bytes data ) external onlyNomin returns ( bool ) { if ( amount < minimumDepositAmount ) { smallDeposits [ from ] = safeAdd ( smallDeposits [ from ] , amount ) ; emit NominDepositNotAccepted ( from , amount , minimumDepositAmount ) ; } else { deposits [ depositEndIndex ] = nominDeposit ( { user : from , amount : amount } ) ; depositEndIndex = safeAdd ( depositEndIndex , 1 ) ; totalSellableDeposits = safeAdd ( totalSellableDeposits , amount ) ; emit NominDeposit ( from , amount ) ; } }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( _getApproved ( _tokenId ) == msg . sender ) ; require ( _ownerOf ( _tokenId ) == _from ) ; require ( _to != address ( 0 ) ) ; _clearApprovalAndTransfer ( _from , _to , _tokenId ) ; Approval ( _from , 0 , _tokenId ) ; Transfer ( _from , _to , _tokenId ) ; }
function transfer ( address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; uint fees = calculateFees ( amount ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( msg . sender ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( to ) ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( feeContract ) ) ) ; require ( lib . Storage . setUint ( id_a , lib . Storage . getUint ( id_a ) . sub ( amount . add ( fees ) ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( lib . Storage . setUint ( id_b , lib . Storage . getUint ( id_b ) . add ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( lib . Storage . setUint ( id_c , lib . Storage . getUint ( id_c ) . add ( fees ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; emit Transfer ( msg . sender , to , amount ) ; return true ; }
function holdersCount ( ) public view returns ( uint256 ) { return holders . length ; }
function deregisterToken ( uint32 _tokenCode ) external onlyOwner ;
function sendPendingAmounts ( uint _from , uint _to , address _buyer ) returns ( bool ) ;
function getBool ( bytes32 _key ) public view returns ( bool _value ) { return boolStorage [ _key ] ; }
function acceptTermsAndJoinDXF ( ) payable external { if ( now > startingDateFunding + 365 days ) throw ; if ( ! dxfOpen ) throw ; if ( vips [ msg . sender ] ) throw ; if ( msg . value < 10 ether ) throw ; if ( msg . value > ( tokensCreationCap - totalTokens ) ) throw ; if ( msg . value > ( 10000 ether - balances [ msg . sender ] ) ) throw ; if ( balances [ msg . sender ] == 0 ) { newMember ( msg . sender ) ; indexMembers [ msg . sender ] = members . length ; members . push ( Member ( msg . sender , now , msg . value ) ) ; } else { members [ indexMembers [ msg . sender ] ] . initial_value += msg . value ; } if ( members . length > maxNumberMembers ) throw ; if ( multisigDXF == 0 ) throw ; if ( ! multisigDXF . send ( msg . value ) ) throw ; uint numTokens = msg . value ; totalTokens += numTokens ; if ( ( tokensCreationCap - totalTokens ) < remainingTokensVIPs ) throw ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
function createAndJoinCDPDai ( uint amount ) public auth stoppable returns ( bytes32 id ) { require ( amount >= minDai ) ; uint price = uint ( feed . read ( ) ) ; require ( dai . transferFrom ( msg . sender , this , amount ) ) ; uint bought = otc . sellAllAmount ( dai , amount , gem , wmul ( WAD - slippage , wdiv ( amount , price ) ) ) ; id = _openAndJoinCDPWETH ( bought ) ; tub . give ( id , msg . sender ) ; }
function deedsOfOwner ( address _owner ) external view returns ( uint256 [ ] ) { uint256 deedCount = countOfDeedsByOwner ( _owner ) ; if ( deedCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( deedCount ) ; uint256 totalDeeds = countOfDeeds ( ) ; uint256 resultIndex = 0 ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = plots [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { result [ resultIndex ] = identifier ; resultIndex ++ ; } } return result ; } }
function newRepo ( string _name , address _dev ) auth ( CREATE_REPO_ROLE ) public returns ( Repo ) { return _newRepo ( _name , _dev ) ; }
function changeVersion ( string _newVersion ) public onlyOwner { require ( bytes ( _newVersion ) . length > 0 , "Invalid version" ) ; version = _newVersion ; }
function initialiseMultisig ( address authority , uint unlockTime ) public payable returns ( bytes32 msigId ) { require ( msg . sender != authority ) ; require ( msg . value > 0 ) ; msigId = keccak256 ( msg . sender , authority , msg . value , unlockTime ) ; Multisig storage multisig = multisigs [ msigId ] ; if ( multisig . deposit == 0 ) { multisig . owner = msg . sender ; multisig . authority = authority ; } reparametrizeMultisig ( msigId , unlockTime ) ; }
function removeTicker ( string _ticker ) external onlyOwner { string memory ticker = Util . upper ( _ticker ) ; address owner = _tickerOwner ( ticker ) ; require ( owner != address ( 0 ) , "Ticker doesn't exist" ) ; _deleteTickerOwnership ( owner , ticker ) ; set ( Encoder . getKey ( "tickerToSecurityToken" , ticker ) , address ( 0 ) ) ; _storeTickerDetails ( ticker , address ( 0 ) , 0 , 0 , "" , false ) ; emit TickerRemoved ( ticker , now , msg . sender ) ; }
function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "insufficent allowance" ) ; address erc20DividendCheckpoint = new ERC20DividendCheckpoint ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( erc20DividendCheckpoint , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return erc20DividendCheckpoint ; }
function getItem ( uint256 _tokenId ) public view returns ( string itemName , uint256 sellingPrice , address owner , bytes32 itemMessage ) { Item storage item = items [ _tokenId ] ; itemName = item . name ; itemMessage = item . message ; sellingPrice = itemIndexToPrice [ _tokenId ] ; owner = itemIndexToOwner [ _tokenId ] ; }
function matchTokenOrderByAdmin_k44j ( uint256 [ ] inputs ) external onlyAdmin { address user = userId2Address [ decodeOrderUserId ( inputs [ 3 ] ) ] ; require ( inputs [ 3 ] >> 224 > userNonce [ user ] ) ; address token ; address base ; bool isBuy ; ( token , base , isBuy ) = decodeTokenOrderTokenAndIsBuy ( inputs [ 3 ] ) ; bytes32 orderHash = getTokenOrderDataHash ( inputs , 0 , inputs [ 3 ] , token , base ) ; require ( verify ( orderHash , user , uint8 ( retrieveV ( inputs [ 3 ] ) ) , bytes32 ( inputs [ 4 ] ) , bytes32 ( inputs [ 5 ] ) ) ) ; uint256 tokenExecute = isBuy ? inputs [ 1 ] : inputs [ 0 ] ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; require ( tokenExecute != 0 ) ; uint256 baseExecute = 0 ; isBuy = ! isBuy ; for ( uint256 i = 6 ; i < inputs . length ; i += 6 ) { require ( tokenExecute > 0 && inputs [ 1 ] . mul ( inputs [ i + 1 ] ) <= inputs [ 0 ] . mul ( inputs [ i ] ) ) ; user = userId2Address [ decodeOrderUserId ( inputs [ i + 3 ] ) ] ; require ( inputs [ i + 3 ] >> 224 > userNonce [ user ] ) ; bytes32 makerOrderHash = getTokenOrderDataHash ( inputs , i , inputs [ i + 3 ] , token , base ) ; require ( verify ( makerOrderHash , user , uint8 ( retrieveV ( inputs [ i + 3 ] ) ) , bytes32 ( inputs [ i + 4 ] ) , bytes32 ( inputs [ i + 5 ] ) ) ) ; ( tokenExecute , baseExecute ) = internalTrade ( inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , inputs [ i + 3 ] , tokenExecute , baseExecute , isBuy , token , base , makerOrderHash ) ; } isBuy = ! isBuy ; tokenExecute = isBuy ? inputs [ 1 ] . sub ( tokenExecute ) : inputs [ 0 ] . sub ( tokenExecute ) ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; processTakerOrder ( inputs [ 2 ] , inputs [ 3 ] , tokenExecute , baseExecute , isBuy , token , base , orderHash ) ; }
function performCalculations ( ) view returns ( uint gav , uint managementFee , uint performanceFee , uint unclaimedFees , uint feesShareQuantity , uint nav , uint sharePrice ) { gav = calcGav ( ) ; ( managementFee , performanceFee , unclaimedFees ) = calcUnclaimedFees ( gav ) ; nav = calcNav ( gav , unclaimedFees ) ; feesShareQuantity = ( gav == 0 ) ? 0 : mul ( totalSupply , unclaimedFees ) / gav ; uint totalSupplyAccountingForFees = add ( totalSupply , feesShareQuantity ) ; sharePrice = nav > 0 ? calcValuePerShare ( nav , totalSupplyAccountingForFees ) : toSmallestShareUnit ( 1 ) ; }
function buyToken ( ) internal { uint256 value = msg . value ; address sender = msg . sender ; require ( ! icoIsClosed ) ; require ( ! frozenAccount [ sender ] ) ; require ( value > 0 ) ; require ( currentTokenPrice > 0 ) ; uint256 amount = value / currentTokenPrice ; uint256 moneyBack = value - ( amount * currentTokenPrice ) ; require ( tokenBalanceOf [ this ] >= amount ) ; amountOfInvestments = amountOfInvestments + ( value - moneyBack ) ; updatePrices ( ) ; _transfer ( this , sender , amount ) ; if ( ! minimalGoalReached ) { checkMinimalGoal ( ) ; } if ( moneyBack > 0 ) { sender . transfer ( moneyBack ) ; } }
function ownerOf ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( address ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( owner != address ( 0 ) , "PixelCon does not exist" ) ; return owner ; }
function changeSTVersionBounds ( string _boundType , uint8 [ ] _newVersion ) external onlyOwner { require ( keccak256 ( abi . encodePacked ( _boundType ) ) == keccak256 ( abi . encodePacked ( "lowerBound" ) ) || keccak256 ( abi . encodePacked ( _boundType ) ) == keccak256 ( abi . encodePacked ( "upperBound" ) ) , "Must be a valid bound type" ) ; require ( _newVersion . length == 3 ) ; if ( compatibleSTVersionRange [ _boundType ] != uint24 ( 0 ) ) { uint8 [ ] memory _currentVersion = VersionUtils . unpack ( compatibleSTVersionRange [ _boundType ] ) ; require ( VersionUtils . isValidVersion ( _currentVersion , _newVersion ) , "Failed because of in-valid version" ) ; } compatibleSTVersionRange [ _boundType ] = VersionUtils . pack ( _newVersion [ 0 ] , _newVersion [ 1 ] , _newVersion [ 2 ] ) ; emit ChangeSTVersionBound ( _boundType , _newVersion [ 0 ] , _newVersion [ 1 ] , _newVersion [ 2 ] ) ; }
function initiate ( bytes32 _swapID , address _withdrawTrader , bytes32 _secretLock , uint256 _timelock ) external onlyInvalidSwaps ( _swapID ) payable { Swap memory swap = Swap ( { timelock : _timelock , value : msg . value , ethTrader : msg . sender , withdrawTrader : _withdrawTrader , secretLock : _secretLock , secretKey : 0x0 } ) ; swaps [ _swapID ] = swap ; swapStates [ _swapID ] = States . OPEN ; emit LogOpen ( _swapID , _withdrawTrader , _secretLock ) ; }
function destroyContract ( ) public onlyOwner { selfdestruct ( owner ) ; }
function buy ( ) payable public { require ( ! frozenAccount [ msg . sender ] ) ; require ( msg . value > 0 ) ; commission = msg . value / commissionRate ; require ( address ( this ) . send ( commission ) ) ; buyToken ( ) ; }
function UnfreezeAccount ( address toUnfreeze ) onlyOwner public { delete frozenAccounts [ toUnfreeze ] ; }
function canRevokeAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) ;
function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F41 ) , _token , _to , _value , _fee , _nonce ) ) ; }
function getLastDeedTimestampByAddress ( string propertyAddress ) public constant returns ( uint256 ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; string memory deed = addressRegistry [ propertyAddressHash ] [ addressRegistry [ propertyAddressHash ] . length - 1 ] ; return getDeedTimestamp ( deed ) ; }
function getMaximumFunds ( ) internal constant returns ( uint ) { return 100000000 ether ; }
function unlockInvestor ( address investor ) private { Account memory accountInMem = _accounts [ investor ] ; if ( accountInMem . balance == 0 ) { return ; } removeInvestor ( investor , accountInMem . balance ) ; require ( NEUMARK . transferFrom ( investor , address ( this ) , accountInMem . neumarksDue ) ) ; NEUMARK . burn ( accountInMem . neumarksDue ) ; if ( block . timestamp < accountInMem . unlockDate ) { address penaltyDisbursalAddress = UNIVERSE . feeDisbursal ( ) ; require ( penaltyDisbursalAddress != address ( 0 ) ) ; uint112 penalty = uint112 ( decimalFraction ( accountInMem . balance , PENALTY_FRACTION ) ) ; assert ( PAYMENT_TOKEN . transfer ( penaltyDisbursalAddress , penalty , abi . encodePacked ( NEUMARK ) ) ) ; emit LogPenaltyDisbursed ( penaltyDisbursalAddress , investor , penalty , PAYMENT_TOKEN ) ; accountInMem . balance -= penalty ; } assert ( PAYMENT_TOKEN . transfer ( investor , accountInMem . balance , "" ) ) ; emit LogFundsUnlocked ( investor , accountInMem . balance , accountInMem . neumarksDue ) ; }
function successful ( ) public { require ( state == State . Successful ) ; if ( ended == false ) { ended = true ; uint256 remanent = hardCap . sub ( totalDistributed ) ; require ( tokenReward . burnToken ( remanent ) ) ; } creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
function getCryptoAvatar ( uint256 _id ) external view returns ( uint256 statistics , uint256 avatarType , uint256 level , uint256 experience , uint256 creationTime , bool isHibernated ) { require ( exists ( _id ) ) ; CryptoAvatar storage avatar = avatars [ _id ] ; statistics = uint256 ( avatar . statistics ) ; avatarType = uint256 ( avatar . avatarType ) ; level = uint256 ( avatar . level ) ; experience = uint256 ( avatar . experience ) ; creationTime = uint256 ( avatar . creationTime ) ; isHibernated = avatar . isHibernated ; }
function schedulePriceUpdatesRolling ( uint256 _startTime , uint256 _interval , uint256 _iters ) payable isAdminOrOwner public { bytes32 requestId ; require ( oraclize_getPrice ( "URL" ) * _iters <= address ( this ) . balance , "Insufficient Funds" ) ; for ( uint256 i = 0 ; i < _iters ; i ++ ) { uint256 scheduledTime = _startTime + ( i * _interval ) ; requestId = oraclize_query ( scheduledTime , "URL" , oracleURL , gasLimit ) ; requestIds [ requestId ] = scheduledTime ; emit LogNewOraclizeQuery ( scheduledTime , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } }
function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) ;
function endAuction ( ) external { require ( block . number >= _auctionEnd ) ; require ( ! _ended ) ; _ended = true ; AuctionEnded ( _topBids [ 0 ] . bidderAddress , _topBids [ 0 ] . bid , _topBids [ 1 ] . bidderAddress , _topBids [ 1 ] . bid , _topBids [ 2 ] . bidderAddress , _topBids [ 2 ] . bid ) ; }
function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { return doTransfer ( msg . sender , _to , _amount ) ; }
function claimAddress ( address _address ) public isCompleted userHasFundedPool ( _address ) { for ( uint256 i = 0 ; i < tokenAddress . length ; ++ i ) { ERC20Basic token = ERC20Basic ( tokenAddress [ i ] ) ; uint256 poolTokenBalance = token . balanceOf ( this ) ; payoutTokensInternal ( _address , poolTokenBalance , token ) ; } }
function _transferSenderPaysFee_byProxy ( address sender , address to , uint value , bytes data ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; return _internalTransfer ( sender , to , value , fee , data ) ; }
function transferFromAndCall ( address _from , address _to , uint256 _value , bytes _data ) public returns ( bool ) ;
function changeIssuanceAddress ( address _issuanceAddress ) public withPerm ( FLAGS ) { issuanceAddress = _issuanceAddress ; emit ChangeIssuanceAddress ( _issuanceAddress ) ; }
function verifyOpenSignature ( address _trader , bytes _signature , bytes32 _orderID ) external returns ( bool ) ;
function ( ) payable { contribute ( msg . sender ) ; }
function transferProfitToHouse ( ) public { require ( lastProfitTransferTimestamp + profitTransferTimeSpan <= block . timestamp ) ; lastProfitTransferTimestamp = block . timestamp ; if ( houseProfit <= 0 ) { return ; } uint toTransfer = uint ( houseProfit ) ; assert ( houseStake >= toTransfer ) ; houseProfit = 0 ; houseStake = houseStake - toTransfer ; houseAddress . transfer ( toTransfer ) ; }
function countAttributeTypes ( ) external view returns ( uint256 ) ;
function claimEth ( ) public { require ( state == State . Successful ) ; require ( msg . sender == creator ) ; require ( creator . send ( this . balance ) ) ; }
function drop ( address [ ] holders ) external returns ( bool ) { for ( uint256 i = 0 ; i < holders . length ; i ++ ) { address holder = holders [ i ] ; if ( ! isAirdropped ( holder ) ) { uint256 balance = balances [ holder ] ; undropped = undropped . sub ( balance ) ; balances [ holder ] = airdropAmount ( balance ) ; uint256 amount = balances [ holder ] . sub ( balance ) ; totalSupply_ = totalSupply_ . add ( amount ) ; Transfer ( address ( 0 ) , holder , amount ) ; setAirdropped ( holder ) ; } } }
function setICOEndDate ( uint _date ) external onlyAdmin returns ( bool ) { require ( icoEndDate == 0 , "The ICO end date was already set." ) ; icoEndDate = _date ; emit ICOEndDateSet ( _date ) ; return true ; }
function totalSupply ( ) constant returns ( uint256 totalAmount ) { totalAmount = _totalSupply ; }
function addr ( bytes _hash , bytes _signature ) internal pure returns ( address ) { bytes memory prefix = "\x19Ethereum Signed Message:\n" ; bytes memory encoded = abi . encodePacked ( prefix , uintToBytes ( _hash . length ) , _hash ) ; bytes32 prefixedHash = keccak256 ( encoded ) ; return ECRecovery . recover ( prefixedHash , _signature ) ; }
function deedUri ( uint256 _deedId ) external pure returns ( string uri ) { require ( validIdentifier ( _deedId ) ) ; var ( x , y ) = identifierToCoordinate ( _deedId ) ; uri = "https://dworld.io/plot/xxxxx/xxxxx" ; bytes memory _uri = bytes ( uri ) ; for ( uint256 i = 0 ; i < 5 ; i ++ ) { _uri [ 27 - i ] = byte ( 48 + ( x / 10 ** i ) % 10 ) ; _uri [ 33 - i ] = byte ( 48 + ( y / 10 ** i ) % 10 ) ; } }
function tokensOf ( address owner ) external view returns ( uint256 [ ] ) ;
function subDefence ( uint256 _playerDefencePoints , uint256 _x ) internal pure returns ( uint256 ) { return ( _playerDefencePoints <= _x ) ? 1 : _playerDefencePoints - _x ; }
function finalizeCrowdsale ( ) public onlyOwner { finalized = true ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( tokensSold >= minCap && this . balance > 0 ) { owner . transfer ( this . balance ) ; } }
function get ( string _name ) public view returns ( uint value ) { return params [ keccak256 ( abi . encodePacked ( _name ) ) ] ; }
function getPrice ( address ofAsset ) view returns ( bool isRecent , uint price , uint decimal ) { return ( hasRecentPrice ( ofAsset ) , information [ ofAsset ] . price , information [ ofAsset ] . decimal ) ; }
function wasSuccess ( ) view public returns ( bool ) { return hasEnded ( ) && goalReached ( ) ; }
function operatorBurn ( address _tokenHolder , uint256 _amount , bytes _data , bytes _operatorData ) public { require ( msg . sender == burnOperator , "Not a burn operator" ) ; super . operatorBurn ( _tokenHolder , _amount , _data , _operatorData ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public canTransfer ( _from ) returns ( bool ) { require ( _to != address ( 0 ) , "Invalid address." ) ; return super . transferFrom ( _from , _to , _value ) ; }
function cancelPayment ( uint _idPayment ) public onlyOwner { doCancelPayment ( _idPayment ) ; }
function enableTransfers ( ) external onlyAdmin whenNotPaused returns ( bool ) { require ( ! released , "Invalid operation. The transfer state is no more restricted." ) ; released = true ; emit TokenReleased ( released ) ; return true ; }
function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) stateOpenOrPendingArbitration ( question_id ) external { bytes32 answer_hash = keccak256 ( abi . encodePacked ( answer , nonce ) ) ; bytes32 commitment_id = keccak256 ( abi . encodePacked ( question_id , answer_hash , bond ) ) ; require ( ! commitments [ commitment_id ] . is_revealed , "commitment must not have been revealed yet" ) ; require ( commitments [ commitment_id ] . reveal_ts > uint32 ( now ) , "reveal deadline must not have passed" ) ; commitments [ commitment_id ] . revealed_answer = answer ; commitments [ commitment_id ] . is_revealed = true ; if ( bond == questions [ question_id ] . bond ) { _updateCurrentAnswer ( question_id , answer , questions [ question_id ] . timeout ) ; } emit LogAnswerReveal ( question_id , msg . sender , answer_hash , answer , nonce , bond ) ; }
function _mint ( address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; require ( _tokenId != 0 ) ; require ( idToOwner [ _tokenId ] == address ( 0 ) ) ; addNFToken ( _to , _tokenId ) ; emit Transfer ( address ( 0 ) , _to , _tokenId ) ; }
function burn ( uint num ) public { require ( num > 0 ) ; require ( balances [ msg . sender ] >= num ) ; require ( totalSupply >= num ) ; uint preBalance = balances [ msg . sender ] ; balances [ msg . sender ] -= num ; totalSupply -= num ; Burnt ( msg . sender , num , totalSupply ) ; Transfer ( msg . sender , 0x0 , num ) ; assert ( balances [ msg . sender ] == preBalance - num ) ; }
function motionWaiting ( uint motionID ) public view returns ( bool ) { return motionStartTime [ motionID ] + votingPeriod + confirmationPeriod <= now ; }
function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes calldata _data ) external returns ( bytes4 ) ;
function onStateChange ( Crowdsale . State _state ) public onlyCrowdsale ;
function getThirdPartyOwners ( ) public view returns ( address [ ] _owners ) { if ( owners . length <= TWO_FACTOR_RESERVED_OWNERS_LENGTH ) { return ; } _owners = new address [ ] ( owners . length - TWO_FACTOR_RESERVED_OWNERS_LENGTH ) ; uint _pointer = 0 ; for ( uint _ownerIdx = TWO_FACTOR_RESERVED_OWNERS_LENGTH ; _ownerIdx < owners . length ; ++ _ownerIdx ) { _owners [ _pointer ++ ] = owners [ _ownerIdx ] ; } }
function getSubPayeesCount ( bytes32 _requestId ) public view returns ( uint8 ) { for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { } return i ; }
function getAttributeValue ( address account , uint256 attributeTypeID ) external view returns ( uint256 value ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; if ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) { return _issuedAttributes [ account ] [ attributeTypeID ] . value ; } else if ( _attributeTypes [ attributeTypeID ] . secondarySource != address ( 0 ) ) { require ( AttributeRegistryInterface ( _attributeTypes [ attributeTypeID ] . secondarySource ) . hasAttribute ( account , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID ) , "attribute of the provided type is not assigned to the provided account" ) ; return ( AttributeRegistryInterface ( _attributeTypes [ attributeTypeID ] . secondarySource ) . getAttributeValue ( account , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID ) ) ; } revert ( "could not find an attribute value at the provided account and ID" ) ; }
function rateFor ( address _affiliate , uint256 , uint256 , uint256 ) public view returns ( uint256 ) { uint256 whitelistedRate = whitelistRates [ _affiliate ] ; if ( whitelistedRate > 0 ) { if ( whitelistedRate == 1 ) { return 0 ; } else { return Math . min256 ( whitelistedRate , maximumRate ) ; } } else { return Math . min256 ( baselineRate , maximumRate ) ; } }
function transferOwnership ( address newOwner ) public onlyContractOwner returns ( bool ) { if ( newOwner == 0x0 ) { return false ; } emit OwnershipTransferred ( contractOwner , newOwner ) ; contractOwner = newOwner ; delete pendingContractOwner ; return true ; }
function finalize ( ) external { if ( ! funding ) throw ; if ( ( block . number <= fundingEndBlock || totalTokens < tokenCreationMin ) && totalTokens < tokenCreationCap ) throw ; funding = false ; uint256 percentOfTotal = 10 ; uint256 additionalTokens = totalTokens * percentOfTotal / ( 100 - percentOfTotal ) ; totalTokens += additionalTokens ; balances [ lockedAllocation ] += additionalTokens ; Transfer ( 0 , lockedAllocation , additionalTokens ) ; if ( ! prospectors_team . send ( this . balance ) ) throw ; }
function acceptProposedMilestones ( bytes32 _hashProposals ) onlyDonor campaignNotCanceled { uint i ; if ( ! changingMilestones ) throw ; if ( sha3 ( proposedMilestones ) != _hashProposals ) throw ; for ( i = 0 ; i < milestones . length ; i ++ ) { if ( milestones [ i ] . status != MilestoneStatus . Paid ) { milestones [ i ] . status = MilestoneStatus . Canceled ; } } bytes memory mProposedMilestones = proposedMilestones ; var itmProposals = mProposedMilestones . toRLPItem ( true ) ; if ( ! itmProposals . isList ( ) ) throw ; var itrProposals = itmProposals . iterator ( ) ; while ( itrProposals . hasNext ( ) ) { var itmProposal = itrProposals . next ( ) ; Milestone milestone = milestones [ milestones . length ++ ] ; if ( ! itmProposal . isList ( ) ) throw ; var itrProposal = itmProposal . iterator ( ) ; milestone . description = itrProposal . next ( ) . toAscii ( ) ; milestone . url = itrProposal . next ( ) . toAscii ( ) ; milestone . minCompletionDate = itrProposal . next ( ) . toUint ( ) ; milestone . maxCompletionDate = itrProposal . next ( ) . toUint ( ) ; milestone . reviewer = itrProposal . next ( ) . toAddress ( ) ; milestone . reviewTime = itrProposal . next ( ) . toUint ( ) ; milestone . paymentSource = itrProposal . next ( ) . toAddress ( ) ; milestone . payData = itrProposal . next ( ) . toData ( ) ; milestone . status = MilestoneStatus . AcceptedAndInProgress ; } delete proposedMilestones ; changingMilestones = false ; NewMilestoneListAccepted ( ) ; }
function finishMinting ( address _burnable ) public onlyController ( ) { require ( _burnable != address ( 0x0 ) ) ; assert ( totalSupply ( ) <= maxSupply ) ; enableTransfers ( true ) ; changeController ( address ( 0x0 ) ) ; burnable = _burnable ; }
function getCrypton ( uint256 _tokenId ) public view returns ( string cryptonName , uint8 category , uint256 markup , uint256 sellingPrice , address owner , bool isProtected ) { Crypton storage crypton = cryptons [ _tokenId ] ; cryptonName = crypton . name ; sellingPrice = cryptonIndexToPrice [ _tokenId ] ; owner = cryptonIndexToOwner [ _tokenId ] ; isProtected = cryptonIndexToProtected [ _tokenId ] ; category = crypton . category ; markup = crypton . markup ; }
function withdrawCollateral ( address token , uint amount ) public { require ( token != 0 ) ; require ( isAcceptedToken ( token ) , "ERC20 not authorised" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( tokens [ token ] [ msg . sender ] >= amount ) ; uint amountToWithdraw = tokens [ token ] [ msg . sender ] ; tokens [ token ] [ msg . sender ] = 0 ; DataVault . _externalStopMasternode ( msg . sender ) ; if ( ! StandardToken ( token ) . transfer ( msg . sender , amountToWithdraw ) ) revert ( ) ; emit Withdraw ( token , msg . sender , amountToWithdraw , amountToWithdraw ) ; }
function isApproved ( uint index ) public view returns ( bool ) { Loan storage loan = loans [ index ] ; return loan . approbations [ loan . borrower ] ; }
function addDelegate ( address _delegate , bytes32 _details ) external ;
function migrate ( uint256 _value ) external { if ( migrationAgent == 0 ) revert ( ) ; if ( _value == 0 ) revert ( ) ; if ( _value > balances [ msg . sender ] ) revert ( ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; totalMigrated += _value ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }
function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
function offer ( uint256 quantity , uint256 price , uint256 expiry ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , "You are unknown and not allowed to trade." ) ; require ( quantity > 0 , "You must supply a quantity." ) ; require ( price > 0 , "The sale price cannot be zero." ) ; require ( expiry > block . timestamp , "Cannot have an expiry date in the past." ) ; require ( price >= sellFloor , "The ask is below the minimum allowed." ) ; require ( sellCeiling == 0 || price <= sellCeiling , "The ask is above the maximum allowed." ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , "You must approve the transfer of tokens before offering them for sale." ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , "Not enough tokens owned to complete the order." ) ; orderBook [ msg . sender ] = TradeOrder ( quantity , price , expiry ) ; emit TokensOffered ( msg . sender , quantity , price , expiry ) ; }
function withdrawEther ( ) external onlyOwner { owner . transfer ( this . balance ) ; }
function earlyResolve ( bytes32 msigId , uint amount , bytes32 hashedMessage , bytes sig ) public { require ( multisigs [ msigId ] . owner == msg . sender || multisigs [ msigId ] . authority == msg . sender ) ; address otherAuthority = multisigs [ msigId ] . owner == msg . sender ? multisigs [ msigId ] . authority : multisigs [ msigId ] . owner ; require ( otherAuthority == hashedMessage . recover ( sig ) ) ; spendFromMultisig ( msigId , amount , multisigs [ msigId ] . owner ) ; }
function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }
function getName ( ) public view returns ( bytes32 ) { return "CountTransferManager" ; }
function depositStake ( StakeLevel _stakeLevel ) public whenNotPaused ( ) isMember ( msg . sender ) notStaking ( msg . sender ) isValidStakeLevel ( _stakeLevel ) { uint256 amountDeposited = depositInternal ( msg . sender , ixtStakingLevels [ uint256 ( _stakeLevel ) ] , false ) ; Member storage member = members [ msg . sender ] ; member . stakeTimestamp = block . timestamp ; member . startOfLoyaltyRewardEligibility = block . timestamp ; registeredInvitationCodes [ member . invitationCode ] = msg . sender ; emit StakeDeposited ( msg . sender , member . membershipNumber , amountDeposited ) ; }
function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; return doApprove ( _spender , _amount ) ; }
function verifyAccount ( Data storage self , address account ) internal view returns ( bool verified ) { require ( getKYCApproval ( self , account ) , "Error: Account does not have KYC approval." ) ; require ( getAccountStatus ( self , account ) , "Error: Account status is `false`. Account status must be `true`." ) ; return true ; }
function withdrawVotingRights ( uint _numTokens ) external { uint availableTokens = voteTokenBalance [ msg . sender ] - getLockedTokens ( msg . sender ) ; require ( availableTokens >= _numTokens ) ; require ( token . transfer ( msg . sender , _numTokens ) ) ; voteTokenBalance [ msg . sender ] -= _numTokens ; VotingRightsWithdrawn ( msg . sender , _numTokens ) ; }
function cancelSellOffer ( uint32 _canvasId ) external { _cancelSellOfferInternal ( _canvasId , true ) ; }
function performBuyOrder ( bytes genericPayload , uint256 amountToGiveForOrder ) public payable onlyTotle whenNotPaused returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { bool success ; bytes4 functionSelector = selectorProvider . getSelector ( this . performBuyOrder . selector ) ; assembly { let callDataOffset := 0x44 let functionSelectorOffset := 0x1C let functionSelectorLength := 0x04 let scratchSpace := 0x0 let wordLength := 0x20 let startOfFreeMemory := mload ( 0x40 ) calldatacopy ( startOfFreeMemory , callDataOffset , calldatasize ) let bytesLength := mload ( startOfFreeMemory ) let totalLength := add ( add ( functionSelectorLength , bytesLength ) , wordLength ) mstore ( add ( scratchSpace , functionSelectorOffset ) , functionSelector ) let functionSelectorCorrect := mload ( scratchSpace ) mstore ( startOfFreeMemory , functionSelectorCorrect ) mstore ( add ( startOfFreeMemory , add ( wordLength , bytesLength ) ) , amountToGiveForOrder ) let startOfNewData := add ( startOfFreeMemory , functionSelectorOffset ) success := call ( gas , address , callvalue , startOfNewData , totalLength , scratchSpace , mul ( wordLength , 0x02 ) ) amountSpentOnOrder := mload ( scratchSpace ) amountReceivedFromOrder := mload ( add ( scratchSpace , wordLength ) ) if eq ( success , 0 ) { revert ( 0 , 0 ) } } }
function removeFromWhitelist ( address [ ] _bidder_addresses ) public isOwner { for ( uint32 i = 0 ; i < _bidder_addresses . length ; i ++ ) { whitelist [ _bidder_addresses [ i ] ] = false ; } }
function revokeOperator ( address _operator ) public whenNotPaused { require ( _operator != msg . sender , "You cannot authorize yourself as an operator" ) ; mAuthorized [ _operator ] [ msg . sender ] = false ; emit RevokedOperator ( _operator , msg . sender ) ; }
function transferFromPreSignedHashing ( address _token , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F44 ) , _token , _from , _to , _value , _fee , _nonce ) ) ; }
function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 3 ) ; availableTags [ 0 ] = "ERC20" ; availableTags [ 1 ] = "Dividend" ; availableTags [ 2 ] = "Checkpoint" ; return availableTags ; }
function getOrganization ( uint256 index ) external view returns ( address organization ) { return _organizationAccounts [ index ] ; }
function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) ;
function getAllowance ( address _owner , address _spender ) external view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }
function createSeedCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } seedCreatedCount ++ ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 0 , _nftData ) ; }
function redeemAllOwnedAssets ( uint shareQuantity ) external returns ( bool success ) { return emergencyRedeem ( shareQuantity , ownedAssets ) ; }
function synthInitiatedFeePayment ( address from , bytes4 sourceCurrencyKey , uint sourceAmount ) external onlySynth returns ( bool ) { require ( sourceAmount > 0 , "Source can't be 0" ) ; bool result = _internalExchange ( from , sourceCurrencyKey , sourceAmount , "XDR" , feePool . FEE_ADDRESS ( ) , false ) ; feePool . feePaid ( sourceCurrencyKey , sourceAmount ) ; return result ; }
function distributePresaleTokens ( address _buyer , uint tokens ) external onlyOwner whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( tokensDistributedPresale < 10e24 ) ; tokensDistributedPresale = tokensDistributedPresale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
function batchCreateChannel ( address [ ] beneficiaries , uint [ ] amounts , uint [ ] commissions , uint [ ] expiresAts , bytes32 [ ] hashedSecrets ) public payable returns ( bytes32 [ ] channelId ) { require ( beneficiaries . length <= MAX_BATCH_ITERATIONS , "TOO_MANY_CHANNELS" ) ; uint valueToBeSent ; for ( uint i = 0 ; i < beneficiaries . length ; ++ i ) { require ( amounts [ i ] + commissions [ i ] >= amounts [ i ] , "UINT256_OVERFLOW" ) ; require ( valueToBeSent + amounts [ i ] + commissions [ i ] >= valueToBeSent , "UINT256_OVERFLOW" ) ; valueToBeSent += amounts [ i ] + commissions [ i ] ; } require ( msg . value == valueToBeSent , "INACCURATE_MSG_VALUE_SENT" ) ; for ( i = 0 ; i < beneficiaries . length ; ++ i ) _setupChannel ( beneficiaries [ i ] , amounts [ i ] , commissions [ i ] , expiresAts [ i ] , hashedSecrets [ i ] ) ; }
function getPermissions ( ) public view returns ( bytes32 [ ] ) ;
function getDistributionContracts ( address _beneficiary ) public view validAddress ( _beneficiary ) returns ( address [ ] ) { return beneficiaryDistributionContracts [ _beneficiary ] ; }
function upgrade ( address newAddress ) { newAddress ; throw ; }
function createBurnedPermission ( address _app , bytes32 _role ) external auth ( CREATE_PERMISSIONS_ROLE ) noPermissionManager ( _app , _role ) { _setPermissionManager ( BURN_ENTITY , _app , _role ) ; }
function addSigner ( address _signer ) public onlyOwner { signers [ _signer ] = true ; }
function createCloneToken ( address _parentToken , uint256 _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
function withdrawETH ( uint256 _amount ) external onlyOwner { owner . transfer ( _amount ) ; }
function getMarketDetails ( ) public view returns ( uint32 , uint32 , uint32 , uint32 , uint64 , uint64 , uint256 , uint256 ) { return ( devFee , priceUpdateInterval , startDateRoundValue , durationRoundValue , maxDuration , minDuration , maxPrice , minPrice ) ; }
function changeDeedPrice ( uint256 identifier , uint256 newPrice ) public { require ( identifierToOwner [ identifier ] == msg . sender ) ; require ( allowChangePrice ) ; require ( newPrice < identifierToPrice [ identifier ] ) ; identifierToPrice [ identifier ] = newPrice ; Price ( identifier , newPrice , nextPrice ( newPrice ) ) ; }
function setMerkleRoot ( bytes32 _updatedMerkleRoot ) external onlySigner returns ( uint ) { merkleRoot = _updatedMerkleRoot ; emit LogMerkleRootUpdated ( _updatedMerkleRoot , msg . sender ) ; return OK ; }
function setTransferFeeRate ( uint _transferFeeRate ) external optionalProxy_onlyOwner { require ( _transferFeeRate <= MAX_TRANSFER_FEE_RATE , "Transfer fee rate must be below MAX_TRANSFER_FEE_RATE" ) ; transferFeeRate = _transferFeeRate ; emitTransferFeeRateUpdated ( _transferFeeRate ) ; }
function upgrade ( uint256 value ) external { if ( ! upgradeAgentStatus ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( finalizedUpgrade ) throw ; if ( value == 0 ) throw ; if ( value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }
function ( ) public payable { require ( isContract ( controller ) ) ; require ( TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; }
function ( ) payable { require ( false ) ; }
function getMinerHalvingHashRateOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { Miner miner = miners [ _miner ] ; uint256 halving = getMinerHalving ( ) ; MinerHashRate hashRate = miner . hashRate [ halving ] ; if ( halving == 0 ) { return hashRate . rate ; } else { if ( ! hashRate . carried ) { return hashRate . rate . add ( miner . hashRate [ halving - 1 ] . rate ) ; } else { return hashRate . rate ; } } }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && _value > 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; balances [ _to ] += _value ; if ( _from == owner && _to != owner ) { shareholdersBalance += _value ; } if ( _from != owner && _to == owner ) { shareholdersBalance -= _value ; } if ( owner != _to ) { insertShareholder ( _to ) ; } Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }
function changeOraclizeGasPrice ( uint _gasPrice ) public onlyOwner { require ( _gasPrice >= 1000000000 ) ; oraclize_setCustomGasPrice ( _gasPrice ) ; }
function transferTokensToAccount ( bytes16 _from , bytes16 _to , uint256 _tokensCount ) onlyAllowedAddresses onlyRegisteredAccount ( _from ) whenNotPaused public returns ( bool ) { registerAccount ( _to ) ; balances [ _from ] = balances [ _from ] . sub ( _tokensCount ) ; balances [ _to ] = balances [ _to ] . add ( _tokensCount ) ; return true ; }
function play ( bool startNewGameIfIdle ) external payable { _processGameEnd ( ) ; if ( ! gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; price = nextPrice ; timeout = nextTimeout ; minimumTimeout = nextMinimumTimeout ; numberOfWagersToMinimumTimeout = nextNumberOfWagersToMinimumTimeout ; gameStarted = true ; gameStarter = msg . sender ; Start ( msg . sender , block . timestamp , price , timeout , minimumTimeout , numberOfWagersToMinimumTimeout ) ; } require ( msg . value >= price ) ; uint256 fee = price . mul ( feePercentage ) . div ( 100000 ) ; uint256 dividend = price . mul ( gameStarterDividendPercentage ) . div ( 100000 ) ; uint256 wagerPoolPart ; if ( wagerIndex % 7 == 6 ) { uint256 wagerPrize = price . mul ( 2 ) ; wagerPoolPart = wagerPrize . sub ( wagerPool ) ; msg . sender . transfer ( wagerPrize ) ; wagerPool = 0 ; } else { wagerPoolPart = price . mul ( 2 ) . div ( 7 ) ; wagerPool = wagerPool . add ( wagerPoolPart ) ; } uint256 currentTimeout = calculateTimeout ( ) ; lastPlayer = msg . sender ; lastWagerTimeoutTimestamp = block . timestamp + currentTimeout ; prizePool = prizePool . add ( price . sub ( fee ) . sub ( dividend ) . sub ( wagerPoolPart ) ) ; Play ( msg . sender , block . timestamp , lastWagerTimeoutTimestamp , wagerIndex , prizePool ) ; _sendFunds ( gameStarter , dividend ) ; wagerIndex = wagerIndex . add ( 1 ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function _addToken ( address _to , uint256 _tokenId ) private { require ( tokenOwner [ _tokenId ] == address ( 0 ) ) ; tokenOwner [ _tokenId ] = _to ; uint256 length = balanceOf ( _to ) ; ownedTokens [ _to ] . push ( _tokenId ) ; ownedTokensIndex [ _tokenId ] = length ; totalTokens = totalTokens . add ( 1 ) ; }
function grantPermissionP ( address _entity , address _app , bytes32 _role , uint256 [ ] _params ) public onlyPermissionManager ( _app , _role ) { bytes32 paramsHash = _params . length > 0 ? _saveParams ( _params ) : EMPTY_PARAM_HASH ; _setPermission ( _entity , _app , _role , paramsHash ) ; }
function createKingdom ( string _kingdomName , uint _startingClaimPriceWei , uint _claimPriceAdjustPercent , uint _curseIncubationDurationSeconds , uint _commissionPerThousand ) { externalEnter ( ) ; createKingdomRP ( _kingdomName , _startingClaimPriceWei , _claimPriceAdjustPercent , _curseIncubationDurationSeconds , _commissionPerThousand ) ; externalLeave ( ) ; }
function acceptOwnership ( ) external { require ( msg . sender == nominatedOwner , "You must be nominated before you can accept ownership" ) ; emit OwnerChanged ( owner , nominatedOwner ) ; owner = nominatedOwner ; nominatedOwner = address ( 0 ) ; }
function unvote ( uint _idPoll ) public { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll storage p = _polls [ _idPoll ] ; require ( block . number >= p . startBlock && block . timestamp < p . endTime && ! p . canceled , "Poll is inactive" ) ; if ( p . voters == 0 ) return ; uint prevVotes = 0 ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { uint ballotAmount = p . ballots [ i ] [ msg . sender ] ; prevVotes += ballotAmount ; p . ballots [ i ] [ msg . sender ] = 0 ; if ( ballotAmount != 0 ) { p . qvResults [ i ] -= sqrt ( ballotAmount / 1 ether ) ; p . results [ i ] -= ballotAmount ; p . votersByBallot [ i ] -- ; } } if ( prevVotes != 0 ) { p . voters -- ; } emit Unvote ( _idPoll , msg . sender ) ; }
function getMinimumFunds ( ) internal constant returns ( uint ) ;
function initialize ( ) external onlyInit { initialized ( ) ; setDepositable ( true ) ; }
function getDarknodeOwner ( address _darknodeID ) external view returns ( address ) { return store . darknodeOwner ( _darknodeID ) ; }
function setFeeFlat ( Data storage self , uint feeFlat ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.flat' , address ( this ) ) ) ; require ( self . Storage . setUint ( id , feeFlat ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function transfer ( address _receiver , uint256 _amount ) public returns ( bool success ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; return true ; }
function setPresaleEthereumDeposit ( address _depositAddress ) whenNotPaused onlyOwner external { deposit = RntPresaleEthereumDeposit ( _depositAddress ) ; }
function getLandEstateId ( uint256 landId ) external view returns ( uint256 ) { return landIdEstate [ landId ] ; }
function cancelAuction ( address _tokenAddress , uint256 _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenAddress ] [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenAddress , _tokenId , seller ) ; }
function withdrawPrize ( ) external checkState ( pointsValidationState . Finished ) { uint256 prize = 0 ; uint256 [ ] memory tokenList = ownedTokens [ msg . sender ] ; for ( uint256 i = 0 ; i < tokenList . length ; i ++ ) { prize += tokenToPayoutMap [ tokenList [ i ] ] ; tokenToPayoutMap [ tokenList [ i ] ] = 0 ; } require ( prize > 0 ) ; msg . sender . transfer ( ( prizePool . mul ( prize ) ) . div ( 1000000 ) ) ; }
function completeDeliverable ( bytes32 _id , address _creator , address _brand ) internal returns ( bool ) { require ( content . isFulfilled ( _id , _creator , _brand ) ) ; content . completeDeliverable ( _id ) ; return _approveEscrow ( _id , content . rewardOf ( _id ) ) ; }
function releaseTo ( address target ) onlyBeneficiary public { require ( now >= cliff ) ; _releaseTo ( target ) ; }
function numberOfPledgeAdmins ( ) constant returns ( uint ) { return admins . length - 1 ; }
function thawTokenTransfers ( ) public onlyOwner returns ( bool thawed ) { tokenTransfersFrozen = false ; ThawTokenTransfers ( msg . sender , true ) ; return true ; }
function symbol ( ) external pure returns ( string ) { return "SU" ; }
function externalTokensRecovery ( Token _address ) onlyAdmin public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
function getPlotInfo ( uint256 plotIndex ) public view returns ( uint24 x , uint24 y , uint24 w , uint24 h , address owner , uint256 price ) { require ( plotIndex < ownership . length ) ; return ( ownership [ plotIndex ] . x , ownership [ plotIndex ] . y , ownership [ plotIndex ] . w , ownership [ plotIndex ] . h , ownership [ plotIndex ] . owner , plotIdToPrice [ plotIndex ] ) ; }
function onTransfer ( address , address , uint256 ) returns ( bool ) { return ( transferable || getBlockTimestamp ( ) >= October12_2017 ) ; }
function resolveDispute ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint8 _v , bytes32 _r , bytes32 _s , uint8 _buyerPercent ) external onlyArbitrator { address _signature = recoverAddress ( keccak256 ( abi . encodePacked ( _tradeID , INSTRUCTION_RESOLVE ) ) , _v , _r , _s ) ; require ( _signature == _buyer || _signature == _seller , "Must be buyer or seller" ) ; Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; require ( _escrow . exists , "Escrow does not exist" ) ; require ( _buyerPercent <= 100 , "_buyerPercent must be 100 or lower" ) ; uint256 _totalFees = _escrow . totalGasFeesSpentByRelayer + ( GAS_doResolveDispute * uint128 ( tx . gasprice ) ) ; require ( _value - _totalFees <= _value , "Overflow error" ) ; feesAvailableForWithdraw += _totalFees ; delete escrows [ _tradeHash ] ; emit DisputeResolved ( _tradeHash ) ; if ( _buyerPercent > 0 ) _buyer . transfer ( ( _value - _totalFees ) * _buyerPercent / 100 ) ; if ( _buyerPercent < 100 ) _seller . transfer ( ( _value - _totalFees ) * ( 100 - _buyerPercent ) / 100 ) ; }
function proxyChangeCrowdsaleMaster ( address _newMaster ) public returns ( bool ) { require ( msg . sender == getContractAddress ( "PoaManager" ) ) ; require ( _newMaster != address ( 0 ) ) ; require ( poaCrowdsaleMaster != _newMaster ) ; require ( isContract ( _newMaster ) ) ; address _oldMaster = poaCrowdsaleMaster ; poaCrowdsaleMaster = _newMaster ; emit ProxyUpgraded ( _oldMaster , _newMaster ) ; getContractAddress ( "PoaLogger" ) . call ( bytes4 ( keccak256 ( "logProxyUpgraded(address,address)" ) ) , _oldMaster , _newMaster ) ; return true ; }
function performSellOrder ( OrderData data , uint256 amountToGiveForOrder ) public whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { approveAddress ( data . converterAddress , data . conversionPath [ 0 ] ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = BancorConverter ( data . converterAddress ) . quickConvert ( trimAddressArray ( data . conversionPath ) , amountToGiveForOrder , data . minReturn ) ; totlePrimary . transfer ( amountReceivedFromOrder ) ; }
function getContractAddress ( string _name ) public view returns ( address _contractAddress ) { bytes4 _signature = bytes4 ( keccak256 ( "getContractAddress32(bytes32)" ) ) ; bytes32 _name32 = keccak256 ( abi . encodePacked ( _name ) ) ; assembly { let _registry := sload ( registry_slot ) let _pointer := mload ( 0x40 ) mstore ( _pointer , _signature ) mstore ( add ( _pointer , 0x04 ) , _name32 ) let result := staticcall ( gas , _registry , _pointer , 0x24 , _pointer , 0x20 ) if iszero ( result ) { revert ( 0 , 0 ) } _contractAddress := mload ( _pointer ) mstore ( 0x40 , add ( _pointer , 0x24 ) ) } }
function approve ( address _spender , uint256 _value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function getPerson ( uint256 _tokenId ) public view returns ( string personName , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; personName = person . name ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }
function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool _transferredFrom ) { require ( ! tokenTransfersFrozen ) ; require ( allowance [ _owner ] [ msg . sender ] . sub ( _amount ) >= 0 ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; allowance [ _owner ] [ msg . sender ] = allowance [ _owner ] [ msg . sender ] . sub ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }
function redeem ( uint256 baseUnits , address [ ] tokensToSkip ) external requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( baseUnits <= totalSupply_ ) ; require ( baseUnits <= balances [ msg . sender ] ) ; require ( tokensToSkip . length <= tokens . length ) ; burn ( msg . sender , baseUnits ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 index ; bool ok ; ( index , ok ) = tokensToSkip . index ( token . addr ) ; if ( ok ) { continue ; } uint256 amount = baseUnits . div ( creationUnit_ ) . mul ( token . quantity ) ; require ( erc20 . transfer ( msg . sender , amount ) ) ; } }
function removeOwnership ( address _dece ) onlyOwner { require ( _dece == 0xdece ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; }
function depositETH ( ) payable { DonationDeposited4Doubling ( msg . sender , msg . value ) ; }
function getTimeout ( bytes32 question_id ) public view returns ( uint32 ) { return questions [ question_id ] . timeout ; }
function setTiers ( uint256 _tierTwoMin , uint256 _tierThreeMin ) onlyOwner { tierTwoMin = _tierTwoMin ; tierThreeMin = _tierThreeMin ; }
function _collectResource ( Factory storage _factory , User storage _user ) internal returns ( uint256 ) { uint256 resources = _resourcesAtTime ( _factory . ftype , _factory . level , _factory . collected_at ) ; _user . resources [ uint8 ( _factory . ftype ) ] = _user . resources [ uint8 ( _factory . ftype ) ] . add ( resources ) ; _factory . collected_at = now ; emit CollectResources ( _factory . ftype , resources ) ; return resources ; }
function commitUpgrade ( ) public returns ( bool ) { if ( pendingVersion == 0x0 ) { return false ; } if ( pendingVersionTimestamp + UPGRADE_FREEZE_TIME > now ) { return false ; } latestVersion = pendingVersion ; delete pendingVersion ; delete pendingVersionTimestamp ; return true ; }
function removeManyAdmins ( address [ ] _accounts ) external onlyAdmin { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && admins [ account ] && account != owner ) { admins [ account ] = false ; emit AdminRemoved ( _accounts [ i ] ) ; } } }
function resumeContribution ( ) onlyController { paused = false ; }
function burn ( uint256 _value ) returns ( bool success ) { require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
function updatePackage ( uint idPackage , string name ) onlyOwner public { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; c . name = name ; PackageUpdated ( idPackage , name ) ; }
function closeTradeProfile ( bytes _signature , bytes32 _strategyID ) public returns ( bool ) { require ( msg . sender == bincentive ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( closePreSignedHashing ( address ( this ) , _strategyID ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; require ( traderProfile [ from ] [ _strategyID ] != address ( 0 ) ) ; TradeProfile profile = TradeProfile ( traderProfile [ from ] [ _strategyID ] ) ; require ( profile . close ( ) ) ; emit CloseTradeProfile ( from , profile ) ; return true ; }
function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( "configure(uint256,bool)" ) ) ; }
function purchase ( ) payable returns ( bool ) ;
function purgeAccount ( address account ) external onlyOwner onlyDuringSetup { delete vestingSchedules [ account ] ; totalVestedBalance = safeSub ( totalVestedBalance , totalVestedAccountBalance [ account ] ) ; delete totalVestedAccountBalance [ account ] ; }
function transferAllowed ( address _from , address ) external view returns ( bool ) { return _from == address ( this ) ; }
function approveSpender ( address _spender ) external { require ( whitelistedSpenders [ _spender ] , "Spender is not whitelisted" ) ; approvedSpenders [ msg . sender ] [ _spender ] = true ; emit SpenderApprove ( msg . sender , _spender ) ; }
function burn ( address _where , uint256 _amount ) public onlyEthealMultisig { require ( _where == address ( this ) || _where == SALE ) ; require ( ethealToken . destroyTokens ( _where , _amount ) ) ; }
function emergencyWithdraw ( ) external hasFinalized { uint256 balance = STARTING_PRICE * ownedTokens [ msg . sender ] . length ; delete ownedTokens [ msg . sender ] ; msg . sender . transfer ( balance ) ; }
function isAssociatedAddressFor ( uint ein , address _address ) public view returns ( bool ) { return identityDirectory [ ein ] . associatedAddresses . contains ( _address ) ; }
function exchangeEtherForSynthsAtRate ( uint guaranteedRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToEthPrice , "Guaranteed rate would not be received" ) ; return exchangeEtherForSynths ( ) ; }
function approveLoanIdentifier ( bytes32 identifier ) public returns ( bool ) { uint256 index = identifierToIndex [ identifier ] ; require ( index != 0 ) ; return approveLoan ( index ) ; }
function ( ) payable public { }
function splitProfits ( ) external { uint i ; if ( ! isFrozen ) { require ( now >= relativeDateSave ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 30000000000000 ) ; relativeDateSave = now + 30 days ; currentProfits = ( ( balances [ selfAddress ] - 30000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 400000000000000 , balances [ selfAddress ] ) + IOUSupply ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { monthlyLimit [ users [ i ] ] = 1000000000000 ; if ( msg . gas < 250000 ) { currentIteration = i ; break ; } if ( ! eligibleForDividence ( users [ i ] ) ) { moneySpent [ users [ i ] ] = 0 ; checkSplitEnd ( i ) ; continue ; } moneySpent [ users [ i ] ] = 0 ; actualProfitSplit += ( ( balances [ users [ i ] ] + allowed [ selfAddress ] [ users [ i ] ] ) * currentProfits ) / amountInCirculation ; Transfer ( selfAddress , users [ i ] , ( ( balances [ users [ i ] ] + allowed [ selfAddress ] [ users [ i ] ] ) * currentProfits ) / amountInCirculation ) ; balances [ users [ i ] ] += ( ( balances [ users [ i ] ] + allowed [ selfAddress ] [ users [ i ] ] ) * currentProfits ) / amountInCirculation ; checkSplitEnd ( i ) ; } } }
function enableTransfers ( bool _transfersEnabled ) onlyOwner { transfersEnabled = _transfersEnabled ; }
function withdraw ( uint amount ) { Splitter . withdrawInternal ( amount , false ) ; }
function recover ( bytes32 hash , bytes sig ) public pure returns ( address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( sig . length != 65 ) { return ( address ( 0 ) ) ; } assembly { r := mload ( add ( sig , 0x20 ) ) s := mload ( add ( sig , 0x40 ) ) v := byte ( 0 , mload ( add ( sig , 0x60 ) ) ) } if ( v < 27 ) { v += 27 ; } if ( v != 27 && v != 28 ) { return ( address ( 0 ) ) ; } else { return ecrecover ( hash , v , r , s ) ; } }
function getWorlCupByID ( uint256 _tokenId ) public view returns ( string wctDesc , uint256 sellingPrice , address owner ) { wctDesc = worldCupTeamDescribe [ _tokenId ] ; sellingPrice = worldCupIdToPrice [ _tokenId ] ; owner = worldCupIdToOwnerAddress [ _tokenId ] ; }
function transferFrom ( address _from , address _to , uint256 _amount ) public whenNotPaused transferFromConditionsRequired ( _from , _to ) returns ( bool ) { require ( _amount <= allowance ( _from , msg . sender ) , "not enough allowance to transfer" ) ; require ( _to != address ( 0 ) , "to address cannot be 0x0" ) ; require ( _amount <= balanceOf ( _from ) , "not enough balance to transfer" ) ; tokenStorage . subAllowance ( _from , msg . sender , _amount ) ; tokenStorage . addBalance ( _to , _amount ) ; tokenStorage . subBalance ( _from , _amount ) ; emit Transfer ( _from , _to , _amount ) ; return true ; }
function validateLockupTokensSig ( address _sender , uint256 _amount , bytes32 _nonce , bytes _delegationSig ) private { bytes32 _signatureDigest = generateLockupTokensDelegationSchemaHash ( _sender , _amount , _nonce ) ; require ( _sender == recoverSigner ( _signatureDigest , _delegationSig ) , 'Invalid LockupTokens Signature' ) ; burnSignatureDigest ( _signatureDigest , _sender ) ; }
function getFinalAnswer ( bytes32 question_id ) stateFinalized ( question_id ) external view returns ( bytes32 ) { return questions [ question_id ] . best_answer ; }
function missingFundsToEndAuction ( ) constant public returns ( uint ) { uint requiredWeiAtPrice = numTokensAuctioned * price ( ) / tokenMultiplier ; if ( requiredWeiAtPrice <= receivedWei ) { return 0 ; } return requiredWeiAtPrice - receivedWei ; }
function hashOrder ( bytes _prefix , uint64 _settlementID , uint64 _tokens , uint256 _price , uint256 _volume , uint256 _minimumVolume ) external pure returns ( bytes32 ) { return SettlementUtils . hashOrder ( _prefix , SettlementUtils . OrderDetails ( { settlementID : _settlementID , tokens : _tokens , price : _price , volume : _volume , minimumVolume : _minimumVolume } ) ) ; }
function incrementalInverse ( uint256 totalEuroUlps , uint256 burnNeumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public constant returns ( uint256 euroUlps ) { uint256 totalNeumarkUlps = cumulative ( totalEuroUlps ) ; require ( totalNeumarkUlps >= burnNeumarkUlps ) ; uint256 fromNmk = totalNeumarkUlps - burnNeumarkUlps ; uint newTotalEuroUlps = cumulativeInverse ( fromNmk , minEurUlps , maxEurUlps ) ; assert ( totalEuroUlps >= newTotalEuroUlps ) ; return totalEuroUlps - newTotalEuroUlps ; }
function changeDepositAddress ( address _depositAddress ) external ;
function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( ! isUserInBlackList ( msg . sender ) ) ; return super . transfer ( _to , _value ) ; }
function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }
function safetyInvariantCheck ( uint256 _value ) public { if ( ! newToken . isNewToken ( ) ) revert ( ) ; uint oldSupply = oldToken . totalSupply ( ) ; uint newSupply = newToken . totalSupply ( ) ; if ( safeAdd ( oldSupply , newSupply ) != safeSub ( correctOriginalSupply , _value ) ) { InvariantCheckFailed ( oldSupply , newSupply , correctOriginalSupply , _value ) ; } else { InvariantCheckPassed ( oldSupply , newSupply , correctOriginalSupply , _value ) ; } }
function tokenFactory ( uint256 _amount ) public onlyAdmin returns ( bool success ) { require ( _amount > 0 ) ; require ( tokenMintingEnabled ) ; require ( tokenMint ( msg . sender , _amount ) ) ; return true ; }
function checkMinimalGoal ( ) internal { if ( tokenBalanceOf [ this ] <= _totalSupply - icoMin ) { minimalGoalReached = true ; minGoalReached ( icoMin , "Minimal goal of ICO is reached!" ) ; } }
function getNumberOfDeedsByAddress ( string propertyAddress ) public constant returns ( uint256 ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; return addressRegistry [ propertyAddressHash ] . length ; }
function setCampaignPriceById ( bytes32 bidId , uint price ) public onlyIfWhitelisted ( "setCampaignPriceById" , msg . sender ) onlyIfCampaignExists ( "setCampaignPriceById" , bidId ) { campaigns [ bidId ] . setPrice ( price ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
function setKingdomFactory ( KingdomFactory _kingdomFactory ) { externalEnter ( ) ; setKingdomFactoryRP ( _kingdomFactory ) ; externalLeave ( ) ; }
function setSellCeiling ( uint256 ceiling ) public onlyOwner { sellCeiling = ceiling ; }
function transferableHavvens ( address account ) public view returns ( uint ) { uint draft = issuanceDraft ( account ) ; uint collat = collateral ( account ) ; if ( draft > collat ) { return 0 ; } uint bal = balanceOf ( account ) ; if ( draft > safeSub ( collat , bal ) ) { return safeSub ( collat , draft ) ; } return bal ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address _owner ) { _owner = animecardToOwner [ _tokenId ] ; require ( _owner != address ( 0 ) ) ; }
function lockedCollateral ( address account ) public view returns ( uint ) { uint debt = issuanceDraft ( account ) ; uint collat = collateral ( account ) ; if ( debt > collat ) { return collat ; } return debt ; }
function setCrowdsaleAddress ( address _crowdsale ) external onlyOwner whenNotPaused { require ( _crowdsale != address ( 0 ) ) ; crowdsale = _crowdsale ; }
function findAdmin ( uint64 idAdmin ) internal returns ( PledgeAdmin storage ) { require ( idAdmin < admins . length ) ; return admins [ idAdmin ] ; }
function burn ( uint num ) public { require ( num > 0 ) ; require ( balances [ msg . sender ] >= num ) ; require ( totalSupply >= num ) ; uint pre_balance = balances [ msg . sender ] ; balances [ msg . sender ] -= num ; totalSupply -= num ; Burnt ( msg . sender , num , totalSupply ) ; Transfer ( msg . sender , 0x0 , num ) ; assert ( balances [ msg . sender ] == pre_balance - num ) ; }
function castVote ( ) external { uint8 choice ; if ( msg . sender == whitelistedSenderAdresses [ 0 ] ) { choice = 0 ; } else if ( msg . sender == whitelistedSenderAdresses [ 1 ] ) { choice = 1 ; } else if ( msg . sender == whitelistedSenderAdresses [ 2 ] ) { choice = 2 ; } else if ( msg . sender == whitelistedSenderAdresses [ 3 ] ) { choice = 3 ; } else { require ( false , "Only whitelisted sender addresses can cast votes." ) ; } voteCountTotal = safeAdd40 ( voteCountTotal , 1 ) ; currentVoteResults [ choice ] = safeAdd32 ( currentVoteResults [ choice ] , 1 ) ; emit NewVote ( choice , currentVoteResults ) ; }
function withdrawBonuses ( bytes32 _userKey , uint _value , address _withdrawAddress , uint _feeAmount , address _feeAddress ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; require ( _withdrawAddress != 0x0 ) ; DepositWalletInterface _wallet = DepositWalletInterface ( wallet ) ; ERC20Interface _bonusToken = ERC20Interface ( bonusToken ) ; if ( _bonusToken . balanceOf ( _wallet ) < _value ) { return _emitError ( PROFITEROLE_ERROR_INSUFFICIENT_BONUS_BALANCE ) ; } if ( OK != _withdrawBonuses ( _userKey , _value ) ) { revert ( ) ; } if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || OK == _wallet . withdraw ( _bonusToken , _feeAddress , _feeAmount ) ) ) { revert ( ) ; } if ( OK != _wallet . withdraw ( _bonusToken , _withdrawAddress , _value - _feeAmount ) ) { revert ( ) ; } BonusesWithdrawn ( _userKey , _value , now ) ; return OK ; }
function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( "pMinDeposit" ) ; bytes32 propID = keccak256 ( abi . encodePacked ( _name , _value ) ) ; bytes32 _nameKec = keccak256 ( abi . encodePacked ( _name ) ) ; if ( _nameKec == DISPENSATION_PCT_KEC || _nameKec == P_DISPENSATION_PCT_KEC ) { require ( _value <= 100 ) ; } if ( keccak256 ( abi . encodePacked ( _name ) ) == NEW_REGISTRY_KEC ) { require ( getNewRegistry ( ) == address ( 0 ) ) ; require ( _value != 0 ) ; require ( msg . sender == owner ) ; require ( ( _value & 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff ) == _value ) ; require ( this . doesContractImplementInterface ( address ( _value ) , REGISTRY_INTERFACE_REQUIREMENT ) ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( "pApplyStageLen" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( "pApplyStageLen" ) ) . add ( get ( "pCommitStageLen" ) ) . add ( get ( "pRevealStageLen" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; emit _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry ) ; return propID ; }
function name ( ) external pure returns ( string _name ) ;
function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { require ( _tokenId < warriors . length ) ; owner = warriorToOwner [ _tokenId ] ; }
function bulkTokenMint ( address [ ] beneficiaries , uint256 [ ] amounts ) onlyOwner external { require ( beneficiaries . length == amounts . length ) ; for ( uint32 i = 0 ; i < beneficiaries . length ; i ++ ) { require ( token . mint ( beneficiaries [ i ] , amounts [ i ] ) ) ; } }
function canIssueAttributeType ( uint256 attributeTypeID ) external view returns ( bool ) { return ( _validAttributeTypeID == attributeTypeID && _jurisdiction . canIssueAttributeType ( address ( this ) , _validAttributeTypeID ) ) ; }
function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) { return false ; } allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
function distributeSupply ( address to , uint tokens ) public onlyOwner returns ( bool success ) { uint tokenAmount = tokens . mul ( 10 ** uint ( decimals ) ) ; require ( _circulatingSupply . add ( tokenAmount ) <= _totalSupply ) ; _circulatingSupply = _circulatingSupply . add ( tokenAmount ) ; balances [ to ] = tokenAmount ; return true ; }
function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
function disableTransfer ( ) ;
function addPriceTier ( uint price ) public onlyOwner { tableStakesOptions . push ( price ) ; }
function setTokenName ( Data storage self , string tokenName ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.name' , address ( this ) ) ) ; require ( self . Storage . setString ( id , tokenName ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function recover ( bytes32 hash , bytes sig ) public pure returns ( address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( sig . length != 65 ) { return ( address ( 0 ) ) ; } assembly { r := mload ( add ( sig , 32 ) ) s := mload ( add ( sig , 64 ) ) v := byte ( 0 , mload ( add ( sig , 96 ) ) ) } if ( v < 27 ) { v += 27 ; } if ( v != 27 && v != 28 ) { return ( address ( 0 ) ) ; } else { return ecrecover ( hash , v , r , s ) ; } }
function claimTokens ( address _token ) onlyController public { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; emit ClaimedTokens ( _token , controller , balance ) ; }
function removeHolderAddress ( bytes32 _externalHolderId , address _address ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; HoldersData storage _holderData = holders [ _holderIndex ] ; uint _tempIndex = _holderData . address2Index [ _address ] ; require ( _tempIndex != 0 ) ; address _lastAddress = _holderData . index2Address [ _holderData . holderAddressCount ] ; _holderData . address2Index [ _lastAddress ] = _tempIndex ; _holderData . index2Address [ _tempIndex ] = _lastAddress ; delete _holderData . address2Index [ _address ] ; _holderData . holderAddressCount = _holderData . holderAddressCount . sub ( 1 ) ; delete holderAddress2Id [ _address ] ; _emitHolderAddressRemoved ( _externalHolderId , _address , _holderIndex ) ; return OK ; }
function refundNonWhitelistedPerson ( address _address ) public onlyOwner { uint refundAmount = nonWLBalanceOf [ _address ] ; nonWLBalanceOf [ _address ] = 0 ; _address . transfer ( refundAmount ) ; }
function unpause ( ) external whenPaused onlyOwner { set ( PAUSED , false ) ; emit Unpause ( now ) ; }
function removeValidator ( address validator ) external onlyOwner whenNotPaused { require ( isValidator ( validator ) , "unable to remove, no validator located at the provided address" ) ; while ( _validatorApprovals [ validator ] . length > 0 && gasleft ( ) > 25000 ) { uint256 lastIndex = _validatorApprovals [ validator ] . length . sub ( 1 ) ; uint256 targetApproval = _validatorApprovals [ validator ] [ lastIndex ] ; delete _attributeTypes [ targetApproval ] . approvedValidators [ validator ] ; delete _validatorApprovalsIndex [ validator ] [ targetApproval ] ; _validatorApprovals [ validator ] . length -- ; } require ( _validatorApprovals [ validator ] . length == 0 , "Cannot remove validator - first remove any existing validator approvals" ) ; address lastAccount = _validatorAccounts [ _validatorAccounts . length . sub ( 1 ) ] ; _validatorAccounts [ _validators [ validator ] . index ] = lastAccount ; _validators [ lastAccount ] . index = _validators [ validator ] . index ; _validatorAccounts . length -- ; delete _validators [ validator ] ; emit ValidatorRemoved ( validator ) ; }
function addMarketplaceContract ( address _marketplaceContract ) public onlyOwner { require ( address ( marketplaceContract ) == 0x0 ) ; marketplaceContract = _marketplaceContract ; }
function payDividends ( uint _value ) returns ( bool ) ;
function _depositEscrow ( uint256 _amount ) internal returns ( bool ) { currentBalance = currentBalance . add ( _amount ) ; return true ; }
function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( "pMinDeposit" ) ; bytes32 propID = keccak256 ( abi . encodePacked ( _name , _value ) ) ; if ( keccak256 ( abi . encodePacked ( _name ) ) == keccak256 ( abi . encodePacked ( "dispensationPct" ) ) || keccak256 ( abi . encodePacked ( _name ) ) == keccak256 ( abi . encodePacked ( "pDispensationPct" ) ) ) { require ( _value <= 100 ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( "pApplyStageLen" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( "pApplyStageLen" ) ) . add ( get ( "pCommitStageLen" ) ) . add ( get ( "pRevealStageLen" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; emit _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry , msg . sender ) ; return propID ; }
function pause ( ) public onlyOwner { _pause ( ) ; }
function withdrawFunds ( uint256 _amount ) external whenNotPaused onlyAdmin { require ( _amount <= address ( this ) . balance , "The amount should be less than the balance/" ) ; msg . sender . transfer ( _amount ) ; emit FundsWithdrawn ( msg . sender , _amount ) ; }
function setTopWinnerPrizes ( ) external onlyAdmin checkState ( pointsValidationState . OrderChecked ) { uint256 percent = 0 ; uint [ ] memory tokensEquals = new uint [ ] ( 30 ) ; uint16 tokenEqualsCounter = 0 ; uint256 currentTokenId ; uint256 currentTokenPoints ; uint256 lastTokenPoints ; uint32 counter = 0 ; uint256 maxRange = 13 ; if ( tokens . length < 201 ) { maxRange = 10 ; } while ( payoutRange < maxRange ) { uint256 inRangecounter = payDistributionAmount [ payoutRange ] ; while ( inRangecounter > 0 ) { currentTokenId = sortedWinners [ counter ] ; currentTokenPoints = tokenToPointsMap [ currentTokenId ] ; inRangecounter -- ; if ( inRangecounter == 0 && payoutRange == maxRange - 1 ) { if ( currentTokenPoints == lastTokenPoints ) { percent += payoutDistribution [ payoutRange ] ; tokensEquals [ tokenEqualsCounter ] = currentTokenId ; tokenEqualsCounter ++ ; } else { tokenToPayoutMap [ currentTokenId ] = payoutDistribution [ payoutRange ] ; } } if ( counter != 0 && ( currentTokenPoints != lastTokenPoints || ( inRangecounter == 0 && payoutRange == maxRange - 1 ) ) ) { for ( uint256 i = 0 ; i < tokenEqualsCounter ; i ++ ) { tokenToPayoutMap [ tokensEquals [ i ] ] = percent . div ( tokenEqualsCounter ) ; } percent = 0 ; tokensEquals = new uint [ ] ( 30 ) ; tokenEqualsCounter = 0 ; } percent += payoutDistribution [ payoutRange ] ; tokensEquals [ tokenEqualsCounter ] = currentTokenId ; tokenEqualsCounter ++ ; counter ++ ; lastTokenPoints = currentTokenPoints ; } payoutRange ++ ; } pValidationState = pointsValidationState . TopWinnersAssigned ; lastPrizeGiven = counter ; }
function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; cardTokenToApproved [ _tokenId ] = _to ; emit Approval ( msg . sender , _to , _tokenId ) ; }
function configure ( uint256 _maxHolderCount ) public onlyFactory { maxHolderCount = _maxHolderCount ; }
function ( ) public payable { if ( msg . sender != owner ) revert ( ) ; }
function ownerDeclareFailure ( ) external onlyOwner { require ( ! contractFailed ) ; contractFailed = true ; }
function ( ) { externalEnter ( ) ; fallbackRP ( ) ; externalLeave ( ) ; }
function referralSale ( address beneficiary , address referrer ) payable public returns ( bool ) { sale ( beneficiary , msg . value , referrer ) ; return true ; }
function getRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return getInvitationRewardBalance ( memberAddress ) + getLoyaltyRewardBalance ( memberAddress ) ; }
function checkTime ( ) public timedStateChange ( address ( 0 ) , 0 , true ) onlyowner { }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { mywoowcoinrecipiente spender = mywoowcoinrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
function depositPool ( uint256 amountToDeposit ) public onlyOwner { uint256 amountDeposited = depositInternal ( msg . sender , amountToDeposit , true ) ; emit PoolDeposit ( msg . sender , amountDeposited ) ; }
function updateMaxWei ( uint256 _maxWei ) public onlyOwner { maxWei = _maxWei ; }
function changePermissionMulti ( address _delegate , address [ ] _modules , bytes32 [ ] _perms , bool [ ] _valids ) external withPerm ( CHANGE_PERMISSION ) { require ( _delegate != address ( 0 ) , "invalid address" ) ; require ( _modules . length > 0 , "0 length is not allowed" ) ; require ( _modules . length == _perms . length , "Array length mismatch" ) ; require ( _valids . length == _perms . length , "Array length mismatch" ) ; for ( uint256 i = 0 ; i < _perms . length ; i ++ ) { _changePermission ( _delegate , _modules [ i ] , _perms [ i ] , _valids [ i ] ) ; } }
function transferFrom ( address _from , address _to , uint256 _amount ) public whenNotPaused transferFromConditionsRequired ( _from , _to ) returns ( bool ) { require ( _amount <= allowance ( _from , msg . sender ) , "not enough allowance to transfer" ) ; _transfer ( _to , _from , _amount ) ; tokenStorage . subAllowance ( _from , msg . sender , _amount ) ; return true ; }
function emergencyFreeze ( ) isAdmin external { isFrozen = true ; }
function fillUpAllowance ( ) public { uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . approve ( token , amount ) ; }
function tokenAddresses ( ) constant returns ( address [ ] ) { return tokens ; }
function removeFromWhitelist ( address _address ) public onlyWhitelister { require ( _address != address ( 0 ) ) ; emit WhitelistRemove ( whitelister , _address ) ; whitelist [ _address ] = false ; }
function reclaimEther ( ) external onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
function doBuy ( ) internal { Tier tier = tiers [ tierCount ] ; assert ( msg . value <= tier . maxInvestorCap ( ) ) ; address caller = msg . sender ; WhitelistedInvestor storage investor = investors [ caller ] ; uint256 investorTokenBP = investorAmountTokensToBuy ( caller ) ; require ( investorTokenBP > 0 ) ; if ( investor . contributedAmount == 0 ) { assert ( msg . value >= tier . minInvestorCap ( ) ) ; } uint256 toFund = msg . value ; uint256 tokensGenerated = toFund . mul ( tier . exchangeRate ( ) ) ; require ( tokensGenerated >= 1 ) ; uint256 tokensleftForSale = leftForSale ( ) ; if ( tokensleftForSale > investorTokenBP ) { if ( tokensGenerated > investorTokenBP ) { tokensGenerated = investorTokenBP ; toFund = investorTokenBP . div ( tier . exchangeRate ( ) ) ; } } if ( investorTokenBP > tokensleftForSale ) { if ( tokensGenerated > tokensleftForSale ) { tokensGenerated = tokensleftForSale ; toFund = tokensleftForSale . div ( tier . exchangeRate ( ) ) ; } } investor . contributedAmount = investor . contributedAmount . add ( toFund ) ; tier . increaseInvestedWei ( toFund ) ; if ( tokensGenerated == tokensleftForSale ) { finalize ( ) ; } assert ( cnd . generateTokens ( caller , tokensGenerated ) ) ; totalTokensSold = totalTokensSold . add ( tokensGenerated ) ; contributionWallet . transfer ( toFund ) ; NewSale ( caller , toFund , tokensGenerated ) ; uint256 toReturn = msg . value . sub ( toFund ) ; if ( toReturn > 0 ) { caller . transfer ( toReturn ) ; Refund ( toReturn ) ; } }
function transferFeeIncurred ( uint value ) public view returns ( uint ) { return safeMul_dec ( value , transferFeeRate ) ; }
function addNewAddress ( address _newAddress ) public ownerOnly { addresses . push ( _newAddress ) ; }
function sendBoughtTokens ( address _beneficiary , uint256 _tokens ) external { require ( locked ) ; require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _beneficiary != address ( 0 ) ) ; require ( _tokens != 0 ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ depositAddress ] = balances [ depositAddress ] . add ( _tokens ) ; emit TokensMinted ( msg . sender , depositAddress , _tokens ) ; _transfer ( depositAddress , _beneficiary , _tokens ) ; }
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; if ( ! _spender . call ( bytes4 ( bytes32 ( sha3 ( "receiveApproval(address,uint256,address,bytes)" ) ) ) , msg . sender , _amount , this , _extraData ) ) { throw ; } return true ; }
function doDisableSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) return false ; if ( _escrow . sellerCanCancelAfter == 0 ) return false ; escrows [ _tradeHash ] . sellerCanCancelAfter = 0 ; emit SellerCancelDisabled ( _tradeHash ) ; if ( msg . sender == relayer ) { increaseGasSpent ( _tradeHash , GAS_doDisableSellerCancel + _additionalGas ) ; } return true ; }
function _investAsBonusProgram ( address _beneficiary , uint256 _amountTokens ) internal { uint256 bonusTokens = _calculateBonus ( _amountTokens , tokensBoughtInBonusProgram ) ; uint256 amountTokensWithBonus = _amountTokens . add ( bonusTokens ) ; tokensBoughtInBonusProgram = tokensBoughtInBonusProgram . add ( _amountTokens ) ; _depositTokens ( _beneficiary , amountTokensWithBonus ) ; emit BoughtBonusProgram ( _beneficiary , _amountTokens , bonusTokens ) ; if ( tokensBoughtInBonusProgram >= INITIAL_BONUSLIST_TOKENS ) { bonusProgramEnded = true ; } }
function updatePlotData ( uint256 plotIndex , string ipfsHash , string url ) external { require ( plotIndex >= 0 ) ; require ( plotIndex < ownership . length ) ; require ( msg . sender == ownership [ plotIndex ] . owner ) ; data [ plotIndex ] = PlotData ( ipfsHash , url ) ; }
function exitThisIcoForHalfOfTokenPrice ( ) { require ( icoExitIsPossible ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( currentTokenPrice > 1 ) ; uint256 amount = tokenBalanceOf [ msg . sender ] ; uint256 revenue = amount * currentTokenPrice / 2 ; require ( this . balance >= revenue ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( revenue ) ; }
function issueNomins ( uint amount ) public optionalProxy requireIssuer ( messageSender ) { address sender = messageSender ; require ( amount <= remainingIssuableNomins ( sender ) , "Amount must be less than or equal to remaining issuable nomins" ) ; uint lastTot = nomin . totalSupply ( ) ; uint preIssued = nominsIssued [ sender ] ; nomin . issue ( sender , amount ) ; nominsIssued [ sender ] = safeAdd ( preIssued , amount ) ; updateIssuanceData ( sender , preIssued , lastTot ) ; }
function canAddAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) { bytes32 hash = calculateAttributeApprovalHash ( account , msg . sender , attributeTypeID , value , fundsRequired , validatorFee ) ; address signingKey = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; address validator = _signingKeys [ signingKey ] ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; return ( fundsRequired >= minimumStake . add ( jurisdictionFee ) . add ( validatorFee ) && ! _invalidAttributeApprovalHashes [ hash ] && canValidate ( validator , attributeTypeID ) && ! _issuedAttributes [ account ] [ attributeTypeID ] . exists ) ; }
function getEmoji ( uint256 _tokenId ) public view returns ( string emojiName , uint256 sellingPrice , address owner ) { Emoji storage emoji = emojis [ _tokenId ] ; emojiName = emoji . name ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; }
function detach ( ) public { if ( m_state == State . MINTING2PUBLIC_SALES ) { require ( msg . sender == m_sale ) ; m_sale = address ( 0 ) ; } else if ( m_state == State . MINTING2POOLS ) { require ( msg . sender == m_pools ) ; m_pools = address ( 0 ) ; changeState ( State . CIRCULATING_TOKEN ) ; m_SMR . disableMinting ( ) ; assert ( m_SMR . startCirculation ( ) ) ; m_SMR . detachControllerForever ( ) ; } else { revert ( ) ; } }
function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) public onlyOwner { sellPrice_ = newSellPrice ; buyPrice_ = newBuyPrice ; }
function collectFee ( address token ) external onlyOwner { uint256 amount = balances [ token ] [ joysoWallet ] ; require ( amount > 0 ) ; balances [ token ] [ joysoWallet ] = 0 ; if ( token == 0 ) { msg . sender . transfer ( amount ) ; } else { require ( ERC20 ( token ) . transfer ( msg . sender , amount ) ) ; } Withdraw ( token , joysoWallet , amount , 0 ) ; }
function commitPeriodActive ( uint _pollID ) constant public returns ( bool active ) { require ( pollExists ( _pollID ) ) ; return ! isExpired ( pollMap [ _pollID ] . commitEndDate ) ; }
function updateRates ( bytes4 [ ] currencyKeys , uint [ ] newRates , uint timeSent ) external onlyOracle returns ( bool ) { return internalUpdateRates ( currencyKeys , newRates , timeSent ) ; }
function symbol ( ) public view returns ( string ) { return "PXCN" ; }
function unverify ( address _address ) public onlyOwner { verifiedAddresses [ _address ] = false ; }
function releaseVested ( ) public returns ( bool ) ;
function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { return true ; }
function addNewAirdrop ( uint _tokenAmount , string _name , uint _countDown , address _smartContract ) public minEth payable { Token t = Token ( _smartContract ) ; if ( t . balanceOf ( this ) >= _tokenAmount ) uint lastIndex = airdrops . length ++ ; Airdrop storage airdrop = airdrops [ lastIndex ] ; airdrop . id = idCounter ; airdrop . tokenAmount = _tokenAmount ; airdrop . name = _name ; airdrop . countDown = _countDown ; airdrop . distributor = msg . sender ; airdrop . tokenSC = Token ( _smartContract ) ; idCounter = airdrop . id + 1 ; }
function changeFactoryUsageFee ( uint256 _newUsageCost ) external ;
function createNew ( bytes32 _regName , address _owner ) payable returns ( address kAddr_ ) ;
function ( ) payable { if ( now < PRESALE_START_DATE ) throw ; if ( now > PRESALE_END_DATE ) throw ; if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) throw ; if ( msg . value > MAXIMUM_PARTICIPATION_AMOUNT ) throw ; if ( safeIncrement ( totalFunding , msg . value ) > PRESALE_MAXIMUM_FUNDING ) throw ; addBalance ( msg . sender , msg . value ) ; }
function getTokenSupply ( Data storage self , string currency ) internal view returns ( uint supply ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.supply' , currency ) ) ; return self . Storage . getUint ( id ) ; }
function claimTokens ( address _claimtoken ) onlyAdmin public returns ( bool ) { if ( _claimtoken == 0x0 ) { owner . transfer ( this . balance ) ; return true ; } ERC20 claimtoken = ERC20 ( _claimtoken ) ; uint balance = claimtoken . balanceOf ( this ) ; claimtoken . transfer ( owner , balance ) ; ClaimedTokens ( _claimtoken , owner , balance ) ; return true ; }
function updateDarknodeRegistry ( DarknodeRegistry _newDarknodeRegistry ) external onlyOwner { emit LogDarknodeRegistryUpdated ( darknodeRegistry , _newDarknodeRegistry ) ; darknodeRegistry = _newDarknodeRegistry ; }
function fundDao ( ) returns ( bool ) ;
function claimReward ( uint _challengeID ) public { Challenge storage challenge = challenges [ _challengeID ] ; require ( challenge . tokenClaims [ msg . sender ] == false ) ; require ( challenge . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID ) ; uint reward = voterReward ( msg . sender , _challengeID ) ; challenge . winningTokens -= voterTokens ; challenge . rewardPool -= reward ; challenge . tokenClaims [ msg . sender ] = true ; emit _RewardClaimed ( _challengeID , reward , msg . sender ) ; require ( token . transfer ( msg . sender , reward ) ) ; }
function setCustomDisputeFee ( bytes32 question_id , uint256 fee ) onlyOwner public { custom_dispute_fees [ question_id ] = fee ; emit LogSetCustomDisputeFee ( question_id , fee ) ; }
function addToEscrow ( address _from , uint256 _amount ) private { tokenEscrow [ _from ] = tokenEscrow [ _from ] . add ( _amount ) ; emit TokenMarketplaceDeposit ( _from , _amount ) ; }
function clearInventory ( uint256 _productId ) external onlyCLevel { _clearInventory ( _productId ) ; ProductInventoryAdjusted ( _productId , availableInventoryOf ( _productId ) ) ; }
function getApproved ( uint256 _tokenId ) external view returns ( address ) ;
function setInitialBuyoutPrice ( uint256 _deedId , uint256 price ) public whenNotPaused { require ( _owns ( msg . sender , _deedId ) ) ; require ( ! identifierToBoughtOutOnce [ _deedId ] ) ; require ( validInitialBuyoutPrice ( _deedId , price ) ) ; identifierToBuyoutPrice [ _deedId ] = price ; SetBuyoutPrice ( _deedId , price ) ; }
function getModule ( uint8 _moduleType , uint _moduleIndex ) public view returns ( bytes32 , address ) ;
function isReadyToSynthesize ( uint256 _kydyId ) public view returns ( bool ) { require ( _kydyId > 0 ) ; Kydy storage kyd = kydys [ _kydyId ] ; return _isReadyToSynthesize ( kyd ) ; }
function takeFee ( uint256 _amount ) external returns ( bool ) ;
function modifyTicker ( address _owner , string _ticker , string _tokenName , uint256 _registrationDate , uint256 _expiryDate , bool _status ) external onlyOwner { require ( bytes ( _ticker ) . length > 0 && bytes ( _ticker ) . length <= 10 , "Ticker length range (0,10]" ) ; require ( _expiryDate != 0 && _registrationDate != 0 , "Dates should not be 0" ) ; require ( _registrationDate <= _expiryDate , "Registration date should < expiry date" ) ; require ( _owner != address ( 0 ) , "Invalid address" ) ; string memory ticker = Util . upper ( _ticker ) ; _modifyTicker ( _owner , ticker , _tokenName , _registrationDate , _expiryDate , _status ) ; }
function setRate ( uint _rateMe ) public ownerOnly { rateMe = _rateMe ; }
function transferFrom ( address from , address to , uint value , bytes data ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ from ] == 0 || value <= transferableHavvens ( from ) , "Value to transfer exceeds available havvens" ) ; _transferFrom_byProxy ( messageSender , from , to , value , data ) ; return true ; }
function multiConfirm ( uint [ ] _idPayments ) public onlyOwner { for ( uint i = 0 ; i < _idPayments . length ; i ++ ) { doConfirmPayment ( _idPayments [ i ] ) ; } }
function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; checkValue ( from , _fee ) ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
function creditBoardGameRevenues ( GoBoard storage board ) private boardGameEnded ( board ) boardNotPaid ( board ) { uint updatedHostShare = HOST_SHARE ; uint updatedLoserShare = 0 ; uint amountBlack = 0 ; uint amountWhite = 0 ; uint amountCFO = 0 ; uint fullAmount = 1000 ; if ( board . status == BoardStatus . BlackWin || board . status == BoardStatus . WhiteWin ) { if ( board . isHonorableLoss ) { updatedHostShare = HOST_SHARE - HONORABLE_LOSS_BONUS ; updatedLoserShare = HONORABLE_LOSS_BONUS ; } if ( board . status == BoardStatus . BlackWin ) { amountBlack = board . boardBalance . mul ( WINNER_SHARE ) . div ( fullAmount ) ; amountWhite = board . boardBalance . mul ( updatedLoserShare ) . div ( fullAmount ) ; } if ( board . status == BoardStatus . WhiteWin ) { amountWhite = board . boardBalance . mul ( WINNER_SHARE ) . div ( fullAmount ) ; amountBlack = board . boardBalance . mul ( updatedLoserShare ) . div ( fullAmount ) ; } amountCFO = board . boardBalance . mul ( updatedHostShare ) . div ( fullAmount ) ; } if ( board . status == BoardStatus . Draw || board . status == BoardStatus . Canceled ) { amountCFO = 0 ; if ( board . whiteAddress != 0 ) { amountBlack = board . boardBalance . div ( 2 ) ; amountWhite = board . boardBalance . div ( 2 ) ; } else { amountBlack = board . boardBalance ; } } assert ( amountBlack + amountWhite + amountCFO == board . boardBalance ) ; board . boardBalance = 0 ; asyncSend ( board . blackAddress , amountBlack ) ; asyncSend ( board . whiteAddress , amountWhite ) ; asyncSend ( CFO , amountCFO ) ; }
function assignVested ( address _receiver , uint256 _amount , uint64 _start , uint64 _cliff , uint64 _vested , bool _revokable ) external authP ( ASSIGN_ROLE , arr ( _receiver , _amount ) ) returns ( uint256 ) { require ( vestingsLengths [ _receiver ] < MAX_VESTINGS_PER_ADDRESS , ERROR_TOO_MANY_VESTINGS ) ; require ( _start <= _cliff && _cliff <= _vested , ERROR_WRONG_CLIFF_DATE ) ; uint256 vestingId = vestingsLengths [ _receiver ] ++ ; vestings [ _receiver ] [ vestingId ] = TokenVesting ( _amount , _start , _cliff , _vested , _revokable ) ; _assign ( _receiver , _amount ) ; emit NewVesting ( _receiver , vestingId , _amount ) ; return vestingId ; }
function name ( ) external constant returns ( string _name ) { return name ; }
function addReserve ( KyberReserveInterface reserve , bool isPermissionless ) public onlyOperator returns ( bool ) { require ( reserveType [ reserve ] == ReserveType . NONE ) ; reserves . push ( reserve ) ; reserveType [ reserve ] = isPermissionless ? ReserveType . PERMISSIONLESS : ReserveType . PERMISSIONED ; AddReserveToNetwork ( reserve , true , isPermissionless ) ; return true ; }
function auditContract ( address _auditor , bytes32 _codeHash , bytes _reportIPFS , bool _isApproved ) public whenNotPaused onlySolidStampRegisterContract { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; uint reward = Rewards [ hashAuditorCode ] ; TotalRequestsAmount = TotalRequestsAmount . sub ( reward ) ; uint commissionKept = calcCommission ( reward ) ; AvailableCommission = AvailableCommission . add ( commissionKept ) ; emit ContractAudited ( _auditor , _codeHash , _reportIPFS , _isApproved , reward ) ; _auditor . transfer ( reward . sub ( commissionKept ) ) ; }
function applyHotFix ( address newICO ) public validAddress ( newICO ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { EthPriceDependent next = EthPriceDependent ( newICO ) ; next . topUp . value ( address ( this ) . balance ) ( ) ; m_token . transfer ( newICO , m_token . balanceOf ( this ) ) ; m_token . switchToNextSale ( newICO ) ; }
function claim ( ) payable external MinimumBackersClaimed { if ( lastPrice == 0 ) throw ; if ( msg . value == 0 ) throw ; uint discountPrice = lastPrice * discountAmount / divisor ; uint tokenAmount = ( msg . value / discountPrice ) ; if ( tokenAmount + claimedUnits + prepaidUnits > promissoryUnits ) throw ; if ( backers [ msg . sender ] . length == 0 ) { backersAddresses . push ( msg . sender ) ; } backers [ msg . sender ] . push ( backerData ( discountPrice , tokenAmount , sha3 ( msg . sender ) , false , true , 0 ) ) ; claimedUnits += tokenAmount ; TokensClaimedEvent ( msg . sender , backers [ msg . sender ] . length - 1 , discountPrice , tokenAmount ) ; }
function execScript ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { uint256 location = SCRIPT_START_LOCATION ; while ( location < _script . length ) { address contractAddress = _script . addressAt ( location ) ; for ( uint i = 0 ; i < _blacklist . length ; i ++ ) { require ( contractAddress != _blacklist [ i ] ) ; } LogScriptCall ( msg . sender , address ( this ) , contractAddress ) ; uint256 calldataLength = uint256 ( _script . uint32At ( location + 0x14 ) ) ; uint256 calldataStart = _script . locationOf ( location + 0x14 + 0x04 ) ; assembly { let success := call ( sub ( gas , 5000 ) , contractAddress , 0 , calldataStart , calldataLength , 0 , 0 ) switch success case 0 { revert ( 0 , 0 ) } } location += ( 0x14 + 0x04 + calldataLength ) ; } }
function removeValidator ( address _validator ) public onlyOwner { validators [ _validator ] = false ; emit ValidatorRemoved ( _validator ) ; }
function setQuestionFee ( uint256 fee ) external { }
function setApprovalForAll ( address _operator , bool _approved ) external { ownerOperators [ msg . sender ] [ _operator ] = _approved ; ApprovalForAll ( msg . sender , _operator , _approved ) ; }
function withdrawMarginPreSigned ( bytes _signature , address _from , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( block . number <= _validUntil ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( withdrawMarginPreSignedHashing ( address ( this ) , _from , _value , _fee , _nonce , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; require ( _from == from ) ; BCNTToken tokenContract = BCNTToken ( tokenAddress ) ; marginBalances [ _from ] = marginBalances [ _from ] . sub ( _value ) . sub ( _fee ) ; require ( tokenContract . transfer ( _from , _value ) ) ; require ( tokenContract . transfer ( msg . sender , _fee ) ) ; emit WithdrawMargin ( _from , _value ) ; emit WithdrawMarginPreSigned ( _from , msg . sender , _value , _fee ) ; return true ; }
function isRegisteredAccount ( address _address ) onlyAllowedAddresses public constant returns ( bool ) { return allowedAddresses [ _address ] ; }
function setMtdAmount ( uint256 mtdAmountInWei ) isOwner { require ( mtdAmountInWei > 0 ) ; require ( mtdAmount != mtdAmountInWei ) ; mtdAmount = mtdAmountInWei ; updatePrices ( ) ; }
function mint ( address _to , uint256 _tokenId ) public { require ( approvedContractAddresses [ msg . sender ] || msg . sender == owner , "minter not approved" ) ; _mint ( _to , _tokenId ) ; }
function changeCompetitionAddress ( address ofCompetition ) pre_cond ( isOwner ( ) ) { competitionAddress = ofCompetition ; }
function changeBonus ( uint256 _bonus ) external whenNotPaused onlyAdmin { require ( _bonus > 0 , "Bonus must be greater than 0" ) ; emit BonusChanged ( _bonus , bonus ) ; bonus = _bonus ; }
function unregister ( bytes32 _key , address _address , uint _timestamp , uint _gasLimit , uint _gasPrice ) external returns ( uint ) ;
function launchContract ( ) public onlyOwner { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; LaunchContract ( msg . sender , true ) ; }
function recover ( address _from , address _to ) checkTrust ( _from , msg . sender ) public onlyContractOwner returns ( uint errorCode ) { address from = holders [ getHolderId ( _from ) ] . addr ; holders [ getHolderId ( _from ) ] . addr = _to ; holderIndex [ _to ] = getHolderId ( _from ) ; Emitter ( eventsHistory ) . emitRecovery ( from , _to , msg . sender ) ; return OK ; }
function updateAccountSpendingPeriod ( Data storage self , address account ) internal returns ( bool success ) { uint begDate = getAccountSpendingPeriod ( self , account ) ; if ( begDate > now ) { return true ; } else { uint duration = 86400 ; require ( setAccountSpendingPeriod ( self , account , begDate . add ( ( ( now . sub ( begDate ) ) . div ( duration ) . add ( 1 ) ) . mul ( duration ) ) ) , "Error: Unable to update account spending period." ) ; return true ; } }
function isUserInGroup ( bytes32 _groupName , address _user ) public view returns ( bool ) { return isRegisteredUser ( _user ) && address2member [ _user ] . groupName2index [ _groupName ] != 0 ; }
function initialiseTradeFlags ( Trade [ ] trades ) internal returns ( TradeFlag [ ] ) { TradeFlag [ ] memory tradeFlags = new TradeFlag [ ] ( trades . length ) ; for ( uint256 i = 0 ; i < trades . length ; i ++ ) { tradeFlags [ i ] . ignoreOrder = new bool [ ] ( trades [ i ] . orders . length ) ; } return tradeFlags ; }
function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; } doTransfer ( _from , _to , _amount ) ; return true ; }
function createAccount ( address _newUser ) public onlyRegistryAdmin { createAccountForUser ( _newUser ) ; }
function approve ( address _spender , uint _value ) public returns ( bool ) { require ( msg . sender == address ( this ) ) ; require ( _spender != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _spender ] == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function transfer ( address to , uint256 amount ) public returns ( bool success ) ;
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }
function amountRaised ( ) public constant returns ( uint256 amount ) { }
function setBackendProxyBuyer ( address _proxyAddress ) whenNotPaused onlyOwner external { proxy = _proxyAddress ; }
function removeAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , "Invalid address." ) ; require ( admins [ _address ] , "This address isn't an administrator." ) ; require ( _address != owner ( ) , "The owner cannot be added or removed to or from the administrator list." ) ; admins [ _address ] = false ; emit AdminRemoved ( _address ) ; return true ; }
function close ( Data storage self , uint64 nonce , uint256 transferred_amount , bytes32 locksroot , bytes32 extra_hash , bytes signature ) { address transfer_address ; uint closer_index ; uint counterparty_index ; require ( self . closed == 0 ) ; self . closed = block . number ; closer_index = index_or_throw ( self , msg . sender ) ; self . closing_address = msg . sender ; if ( signature . length == 65 ) { transfer_address = recoverAddressFromSignature ( nonce , transferred_amount , locksroot , extra_hash , signature ) ; counterparty_index = index_or_throw ( self , transfer_address ) ; require ( closer_index != counterparty_index ) ; Participant storage counterparty = self . participants [ counterparty_index ] ; counterparty . nonce = uint64 ( nonce ) ; counterparty . locksroot = locksroot ; counterparty . transferred_amount = transferred_amount ; } }
function deposit ( ) public payable onlyExistingUser returns ( uint256 ) { require ( msg . value > minSumDeposit , "Deposit does not enough" ) ; uint256 userId = addressToUser [ msg . sender ] ; users [ userId ] . balance = users [ userId ] . balance . add ( msg . value ) ; totalDeposit += msg . value ; _distributeInvestment ( msg . value ) ; _updateLeaders ( msg . sender , msg . value ) ; emit Deposit ( userId , msg . value ) ; return users [ userId ] . balance ; }
function ownerOf ( uint256 _tokenId ) public view returns ( address ) ;
function name ( ) external view returns ( string _name ) { return _ERC721name ; }
function collateral ( address account ) public view returns ( uint ) { uint balance = tokenState . balanceOf ( account ) ; if ( escrow != address ( 0 ) ) { balance = balance . add ( escrow . balanceOf ( account ) ) ; } return balance ; }
function unarchiveModule ( ModuleData storage _moduleData , address _module ) public { require ( _moduleData . isArchived , "Module unarchived" ) ; emit ModuleUnarchived ( _moduleData . moduleTypes , _module , now ) ; _moduleData . isArchived = false ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { testmonedarecipientefinal spender = testmonedarecipientefinal ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
function getGameState ( uint gameId ) public view returns ( GameStates ) { return games [ gameId ] . state ; }
function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownedTokens [ _owner ] . length ; }
function isRegularAddress ( address _addr ) internal constant returns ( bool ) { if ( _addr == 0 ) { return false ; } uint size ; assembly { size := extcodesize ( _addr ) } return size == 0 ; }
function approve ( address _spender , uint256 _amount ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
function changeOwner ( address _newOwner ) onlyOwner { owner = _newOwner ; }
function _tagsByModules ( address [ ] _modules ) internal view returns ( bytes32 [ ] , address [ ] ) { uint256 counter = 0 ; uint256 i ; uint256 j ; for ( i = 0 ; i < _modules . length ; i ++ ) { counter = counter + IModuleFactory ( _modules [ i ] ) . getTags ( ) . length ; } bytes32 [ ] memory tags = new bytes32 [ ] ( counter ) ; address [ ] memory modules = new address [ ] ( counter ) ; bytes32 [ ] memory tempTags ; counter = 0 ; for ( i = 0 ; i < _modules . length ; i ++ ) { tempTags = IModuleFactory ( _modules [ i ] ) . getTags ( ) ; for ( j = 0 ; j < tempTags . length ; j ++ ) { tags [ counter ] = tempTags [ j ] ; modules [ counter ] = _modules [ i ] ; counter ++ ; } } return ( tags , modules ) ; }
function signFork ( uint256 number , bytes32 hash ) public only ( ROLE_PLATFORM_OPERATOR_REPRESENTATIVE ) { require ( block . blockhash ( number ) == hash ) ; delete _nextForkName ; delete _nextForkUrl ; delete _nextForkBlockNumber ; _lastSignedBlockNumber = number ; _lastSignedBlockHash = hash ; _lastSignedTimestamp = block . timestamp ; LogForkSigned ( _lastSignedBlockNumber , _lastSignedBlockHash ) ; }
function ownerSetCrowdsaleClosed ( bool status ) public onlyOwner { crowdsaleClosed = status ; }
function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) { return operators [ _owner ] [ _operator ] ; }
function migrationSetBoard ( bytes32 boardHash , bytes32 name , string boardDescription , uint8 numPlayers , address boardOwner ) isOwner public returns ( bool ) { boards [ boardHash ] . boardName = name ; boards [ boardHash ] . boardDescription = boardDescription ; boards [ boardHash ] . numPlayers = numPlayers ; boards [ boardHash ] . boardOwner = boardOwner ; return true ; }
function revokeManualApproval ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , "Invalid to address" ) ; delete manualApprovals [ _from ] [ _to ] ; emit RevokeManualApproval ( _from , _to , msg . sender ) ; }
function unpause ( ) public onlyGameManager whenPaused { require ( nonFungibleContract != address ( 0 ) ) ; super . unpause ( ) ; }
function bid ( ) public payable atStage ( Stages . AuctionStarted ) { require ( msg . value > 0 ) ; assert ( bids [ msg . sender ] + msg . value >= msg . value ) ; uint missingFunds = missingFundsToEndAuction ( ) ; require ( msg . value <= missingFunds ) ; bids [ msg . sender ] += msg . value ; receivedWei += msg . value ; walletAddress . transfer ( msg . value ) ; BidSubmission ( msg . sender , msg . value , missingFunds , block . timestamp ) ; assert ( receivedWei >= msg . value ) ; }
function performBuyOrder ( OrderData order , uint256 amountToGiveForOrder ) public payable onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { exchange . depositEthers . value ( amountToGiveForOrder ) ( ) ; uint256 feeRate = exchange . feeRate ( ) ; exchange . takeSellOrder ( order . addresses , order . values , amountToGiveForOrder , order . v , order . r , order . s ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = SafeMath . div ( SafeMath . mul ( amountToGiveForOrder , order . values [ 0 ] ) , order . values [ 1 ] ) ; amountReceivedFromOrder = SafeMath . sub ( amountReceivedFromOrder , SafeMath . div ( amountReceivedFromOrder , feeRate ) ) ; }
function createPermission ( address _entity , address _app , bytes32 _role , address _manager ) external auth ( CREATE_PERMISSIONS_ROLE ) noPermissionManager ( _app , _role ) { _createPermission ( _entity , _app , _role , _manager ) ; }
function getEnded ( ) external view returns ( bool ) { return _ended ; }
function upgradeController ( address _newControllerAddress ) public onlyOwner { tokenContract . changeController ( _newControllerAddress ) ; emit UpgradedController ( _newControllerAddress ) ; }
function registerForCompetition ( address fund , uint8 v , bytes32 r , bytes32 s ) payable pre_cond ( isCompetitionActive ( ) && ! Version ( COMPETITION_VERSION ) . isShutDown ( ) ) pre_cond ( termsAndConditionsAreSigned ( msg . sender , v , r , s ) && isWhitelisted ( msg . sender ) ) { require ( registeredFundToRegistrants [ fund ] == address ( 0 ) && registrantToRegistrantIds [ msg . sender ] . exists == false ) ; require ( add ( currentTotalBuyin , msg . value ) <= totalMaxBuyin && registrants . length < maxRegistrants ) ; require ( msg . value <= whitelistantToMaxBuyin [ msg . sender ] ) ; require ( Version ( COMPETITION_VERSION ) . getFundByManager ( msg . sender ) == fund ) ; uint payoutQuantity = calculatePayout ( msg . value ) ; registeredFundToRegistrants [ fund ] = msg . sender ; registrantToRegistrantIds [ msg . sender ] = RegistrantId ( { id : registrants . length , exists : true } ) ; currentTotalBuyin = add ( currentTotalBuyin , msg . value ) ; FundInterface fundContract = FundInterface ( fund ) ; MELON_CONTRACT . approve ( fund , payoutQuantity ) ; fundContract . requestInvestment ( payoutQuantity , getEtherValue ( payoutQuantity ) , MELON_ASSET ) ; fundContract . executeRequest ( fundContract . getLastRequestId ( ) ) ; custodian . transfer ( msg . value ) ; emit Register ( registrants . length , fund , msg . sender ) ; registrants . push ( Registrant ( { fund : fund , registrant : msg . sender , hasSigned : true , buyinQuantity : msg . value , payoutQuantity : payoutQuantity , isRewarded : false } ) ) ; }
function blocksList ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) internal pure returns ( uint16 [ ] memory r ) { uint i = 0 ; r = new uint16 [ ] ( countBlocks ( fromX , fromY , toX , toY ) ) ; for ( uint8 ix = fromX ; ix <= toX ; ix ++ ) { for ( uint8 iy = fromY ; iy <= toY ; iy ++ ) { r [ i ] = blockID ( ix , iy ) ; i ++ ; } } }
function allowance ( address owner , address spender ) public view returns ( uint ) { return tokenState . allowance ( owner , spender ) ; }
function withdrawBonus ( ) external whenNotPaused { require ( releaseDate != 0 ) ; require ( now > releaseDate ) ; uint256 amount = bonusHolders [ msg . sender ] ; require ( amount > 0 ) ; bonusWithdrawn = bonusWithdrawn . add ( amount ) ; bonusHolders [ msg . sender ] = 0 ; require ( bonusCoin . transfer ( msg . sender , amount ) ) ; emit BonusWithdrawn ( msg . sender , amount ) ; }
function getBond ( bytes32 question_id ) public view returns ( uint256 ) { }
function changeAllowAllWhitelistIssuances ( bool _allowAllWhitelistIssuances ) public withPerm ( FLAGS ) { allowAllWhitelistIssuances = _allowAllWhitelistIssuances ; emit LogAllowAllWhitelistIssuances ( _allowAllWhitelistIssuances ) ; }
function giveBirth ( uint256 _matronId ) external whenNotPaused returns ( uint256 ) { Pony storage matron = ponies [ _matronId ] ; require ( matron . birthTime != 0 ) ; require ( _isReadyToGiveBirth ( matron ) ) ; uint256 sireId = matron . matingWithId ; Pony storage sire = ponies [ sireId ] ; uint16 parentGen = matron . generation ; if ( sire . generation > matron . generation ) { parentGen = sire . generation ; } uint256 childGenes = geneScience . mixGenes ( matron . genes , sire . genes , matron . cooldownEndBlock - 1 ) ; uint16 cooldownIndex = geneScience . processCooldown ( parentGen + 1 , block . number ) ; if ( cooldownIndex > 13 ) { cooldownIndex = 13 ; } address owner = ponyIndexToOwner [ _matronId ] ; uint256 ponyId = _createPony ( _matronId , matron . matingWithId , parentGen + 1 , childGenes , owner , cooldownIndex ) ; delete matron . matingWithId ; pregnantPonies -- ; msg . sender . transfer ( autoBirthFee ) ; return ponyId ; }
function addProjectToVote ( string calldata _prjName , address _prjAddress ) external payable onlyOwner { require ( currentStage == StageName . preList , "Can't add item after vote has starting!" ) ; require ( _prjAddress != address ( 0 ) , "Address must be valid!" ) ; bytes32 hash = keccak256 ( bytes ( _prjName ) ) ; require ( projects [ hash ] . prjAddress == address ( 0 ) , "It seems like this item allready exist!" ) ; projects [ hash ] = PrjProperties ( { prjAddress : _prjAddress , voteCount : 0 , prjWeiRaised : 0 } ) ; }
function implementsERC165Interface ( address _contract , bytes4 _interfaceId ) public view returns ( bool ) { if ( ! erc165Cached [ _contract ] [ _interfaceId ] ) { return implementsERC165InterfaceNoCache ( _contract , _interfaceId ) ; } return interfaces [ _contract ] [ _interfaceId ] == _contract ; }
function ownerStartContract ( ) external onlyOwner { require ( contractPoweredUp ) ; require ( ! contractStarted ) ; contractStarted = true ; }
function insertBefore ( List storage self , address target , address newNode ) internal { require ( ! isInList ( self , newNode ) , "already in list" ) ; require ( isInList ( self , target ) || target == NULL , "not in list" ) ; address prev = self . list [ target ] . previous ; self . list [ newNode ] . next = target ; self . list [ newNode ] . previous = prev ; self . list [ target ] . previous = newNode ; self . list [ prev ] . next = newNode ; self . list [ newNode ] . inList = true ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( checkVestingCondition ( _from ) ) ; require ( _value <= approved [ _from ] [ msg . sender ] ) ; approved [ _from ] [ msg . sender ] = approved [ _from ] [ msg . sender ] . minus ( _value ) ; _transfer ( _from , _to , _value ) ; return true ; }
function ( ) payable public { require ( msg . value > 0 ) ; buy ( msg . sender , msg . value ) ; }
function sendTokens ( address _to , uint _value ) public onlyMinter validAddress ( _to ) notZero ( _value ) { balances [ _to ] = SafeMath . add ( balances [ _to ] , _value ) ; feeInCirculation = SafeMath . add ( feeInCirculation , _value ) ; Transfer ( msg . sender , _to , _value ) ; }
function officialSold ( ) constant returns ( uint256 ) { return soldOut . official ; }
function setJackpotCompleted ( ) public onlyOwner { jackpotCompleted = true ; finalJackpotValue = address ( this ) . balance ; uint256 jackpotShare = ( ( address ( this ) . balance ) . mul ( 20 ) ) . div ( 100 ) ; msg . sender . transfer ( jackpotShare ) ; }
function getSetupCost ( ) external view returns ( uint256 ) { return setupCost ; }
function withdrawToken ( uint tokenNumber ) external returns ( bool ) { require ( _ended ) ; require ( ! _coinWithdrawn [ tokenNumber - 1 ] ) ; _coinWithdrawn [ tokenNumber - 1 ] = true ; RareCoin ( _rcContract ) . CreateToken ( _topBids [ tokenNumber - 1 ] . bidderAddress , tokenNumber ) ; return true ; }
function setUpgradeAgent ( address agent ) external { if ( getState ( ) != State . Success ) throw ; if ( agent == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; if ( address ( upgradeAgent ) != 0x0 && upgradeAgent . upgradeHasBegun ( ) ) throw ; upgradeAgent = UpgradeAgent ( agent ) ; if ( upgradeAgent . originalSupply ( ) != totalSupply ) throw ; UpgradeAgentSet ( upgradeAgent ) ; }
function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 6000000000 ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _isIdle ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }
function assignBonus ( address _investor , uint256 _bonus ) internal { if ( _bonus == 0 ) { return ; } bonusProvided = bonusProvided . add ( _bonus ) ; bonusHolders [ _investor ] = bonusHolders [ _investor ] . add ( _bonus ) ; emit BonusAssigned ( _investor , _bonus ) ; }
function getFinishTime ( ) public view returns ( uint ) { return m_tokenBonuses . getLastTime ( ) ; }
function redeem ( bytes preimage ) public { require ( sha256 ( preimage ) == sha256hash ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; selfdestruct ( msg . sender ) ; }
function name ( ) public pure returns ( string _deedName ) { _deedName = "Burnup Tiles" ; }
function collectTokens ( ) public onlyOwner { uint256 balance = att . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 ) ; uint256 canExtract = total . div ( 2 ) ; if ( getTime ( ) > finalizedTime . add ( months ( 6 ) ) ) { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; assert ( att . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }
function trade ( ERC20 src , uint srcAmount , ERC20 dest , address destAddress , uint maxDestAmount , uint minConversionRate , address walletId ) public payable returns ( uint ) { require ( enabled ) ; uint userSrcBalanceBefore ; uint userSrcBalanceAfter ; uint userDestBalanceBefore ; uint userDestBalanceAfter ; userSrcBalanceBefore = getBalance ( src , msg . sender ) ; if ( src == ETH_TOKEN_ADDRESS ) userSrcBalanceBefore += msg . value ; userDestBalanceBefore = getBalance ( dest , destAddress ) ; uint actualDestAmount = doTrade ( src , srcAmount , dest , destAddress , maxDestAmount , minConversionRate , walletId ) ; require ( actualDestAmount > 0 ) ; userSrcBalanceAfter = getBalance ( src , msg . sender ) ; userDestBalanceAfter = getBalance ( dest , destAddress ) ; require ( userSrcBalanceAfter <= userSrcBalanceBefore ) ; require ( userDestBalanceAfter >= userDestBalanceBefore ) ; require ( ( userDestBalanceAfter - userDestBalanceBefore ) >= calcDstQty ( ( userSrcBalanceBefore - userSrcBalanceAfter ) , getDecimals ( src ) , getDecimals ( dest ) , minConversionRate ) ) ; return actualDestAmount ; }
function cancel ( bytes32 _offerHash , uint256 _expectedAvailableAmount , address _feeAsset , uint256 _feeAmount , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator { require ( _recoverAddress ( keccak256 ( abi . encodePacked ( "cancel" , _offerHash , _feeAsset , _feeAmount ) ) , _v , _r , _s ) == offers [ _offerHash ] . maker , "Invalid signature" ) ; _cancel ( _offerHash , _expectedAvailableAmount , _feeAsset , _feeAmount ) ; }
function mAllowanceOverride ( address owner , address spender ) internal constant returns ( uint256 allowance ) ;
function calculateBoardScore ( uint boardId ) public view returns ( uint8 blackScore , uint8 whiteScore ) { GoBoard storage board = allBoards [ boardId ] ; uint8 [ BOARD_SIZE ] memory boardEmptyGroups ; uint8 maxEmptyGroupId ; ( boardEmptyGroups , maxEmptyGroupId ) = getBoardEmptyGroups ( board ) ; uint8 [ BOARD_SIZE ] memory groupsSize ; uint8 [ BOARD_SIZE ] memory groupsState ; blackScore = 0 ; whiteScore = 0 ; for ( uint8 position = 0 ; position < BOARD_SIZE ; position ++ ) { if ( PlayerColor ( board . positionToColor [ position ] ) == PlayerColor . Black ) { blackScore ++ ; } else if ( PlayerColor ( board . positionToColor [ position ] ) == PlayerColor . White ) { whiteScore ++ ; } else { uint8 groupId = boardEmptyGroups [ position ] ; groupsSize [ groupId ] ++ ; if ( ( groupsState [ groupId ] & uint8 ( PlayerColor . Black ) == 0 ) || ( groupsState [ groupId ] & uint8 ( PlayerColor . White ) == 0 ) ) { uint8 [ MAX_ADJACENT_CELLS ] memory adjacentArray = getAdjacentCells ( position ) ; for ( uint8 currAdjacentIndex = 0 ; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray [ currAdjacentIndex ] < MAX_UINT8 ; currAdjacentIndex ++ ) { if ( ( PlayerColor ( board . positionToColor [ adjacentArray [ currAdjacentIndex ] ] ) == PlayerColor . Black ) && ( groupsState [ groupId ] & uint8 ( PlayerColor . Black ) == 0 ) ) { groupsState [ groupId ] |= uint8 ( PlayerColor . Black ) ; } else if ( ( PlayerColor ( board . positionToColor [ adjacentArray [ currAdjacentIndex ] ] ) == PlayerColor . White ) && ( groupsState [ groupId ] & uint8 ( PlayerColor . White ) == 0 ) ) { groupsState [ groupId ] |= uint8 ( PlayerColor . White ) ; } } } } } for ( uint8 currGroupId = 1 ; currGroupId < maxEmptyGroupId ; currGroupId ++ ) { if ( ( groupsState [ currGroupId ] & uint8 ( PlayerColor . Black ) > 0 ) && ( groupsState [ currGroupId ] & uint8 ( PlayerColor . White ) == 0 ) ) { blackScore += groupsSize [ currGroupId ] ; } else if ( ( groupsState [ currGroupId ] & uint8 ( PlayerColor . White ) > 0 ) && ( groupsState [ currGroupId ] & uint8 ( PlayerColor . Black ) == 0 ) ) { whiteScore += groupsSize [ currGroupId ] ; } } return ( blackScore , whiteScore ) ; }
function calculateBonus ( uint32 _date ) internal view returns ( uint256 ) { DailyContestStatus memory status = dateToContestStatus [ _date ] ; if ( status . numCompleted == 0 ) { return 0 ; } uint256 numFailed = status . numRegistered . sub ( status . numCompleted ) ; return numFailed . mul ( REGISTRATION_FEE ) . mul ( 9 ) . div ( status . numCompleted . mul ( 10 ) ) ; }
function setAllowance ( address tokenOwner , address spender , uint value ) external onlyAssociatedContract { allowance [ tokenOwner ] [ spender ] = value ; }
function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }
function issuanceDraft ( address account ) public view returns ( uint ) { uint issued = nominsIssued [ account ] ; if ( issued == 0 ) { return 0 ; } return USDtoHAV ( safeDiv_dec ( issued , issuanceRatio ) ) ; }
function transferFor ( address _beneficiary ) public onlyOwner vaultUnlocked returns ( bool ) { return _transferTokens ( _beneficiary ) ; }
function getPendingVersion ( ) public view returns ( address ) { return pendingVersion ; }
function _burn ( address _owner , uint256 _tokenId ) validNFToken ( _tokenId ) internal { clearApproval ( _owner , _tokenId ) ; removeNFToken ( _owner , _tokenId ) ; emit Transfer ( _owner , address ( 0 ) , _tokenId ) ; }
function setTierData ( uint256 _index , uint256 _priceInCenter , uint256 _priceInOuter ) public onlyGlobalAdmin ( ) { Tier memory tier = tiers [ _index ] ; tier . priceInCenter = _priceInCenter ; tier . priceInOuter = _priceInOuter ; tiers [ _index ] = tier ; }
function process_contribution ( address _toAddr ) internal { require ( ( campaignState == 2 ) && ( now <= tCampaignEnd ) && ( paused == false ) ) ; require ( msg . value >= minContribution ) ; amountRaised = amountRaised . add ( msg . value ) ; if ( ! participantList [ _toAddr ] . participatedFlag ) { participantList [ _toAddr ] . participatedFlag = true ; joinedCrowdsale . push ( _toAddr ) ; } if ( msg . value >= preCrowdMinContribution ) { participantList [ _toAddr ] . contributedAmountPreCrowd = participantList [ _toAddr ] . contributedAmountPreCrowd . add ( msg . value ) ; RaisedPreCrowd ( _toAddr , msg . value ) ; } else { if ( now <= t_1st_StageEnd ) { participantList [ _toAddr ] . contributedAmountStage1 = participantList [ _toAddr ] . contributedAmountStage1 . add ( msg . value ) ; RaisedStage1 ( _toAddr , msg . value ) ; } else if ( now <= t_2nd_StageEnd ) { participantList [ _toAddr ] . contributedAmountStage2 = participantList [ _toAddr ] . contributedAmountStage2 . add ( msg . value ) ; RaisedStage2 ( _toAddr , msg . value ) ; } else { participantList [ _toAddr ] . contributedAmountStage3 = participantList [ _toAddr ] . contributedAmountStage3 . add ( msg . value ) ; RaisedStage3 ( _toAddr , msg . value ) ; } } uint256 opEth = ( PRCT100_ETH_OP . mul ( msg . value ) ) . div ( 10000 ) ; opVaultAddr . transfer ( opEth ) ; reserveVaultAddr . transfer ( opEth ) ; }
function refunded ( address investor ) public { Account memory investment = _commitments [ msg . sender ] [ investor ] ; if ( investment . balance == 0 ) return ; delete _commitments [ msg . sender ] [ investor ] ; Account storage account = _accounts [ investor ] ; require ( account . unlockDate > 0 , "NF_LOCKED_ACCOUNT_LIQUIDATED" ) ; account . balance = addBalance ( account . balance , investment . balance ) ; account . neumarksDue = add112 ( account . neumarksDue , investment . neumarksDue ) ; assert ( PAYMENT_TOKEN . transferFrom ( msg . sender , address ( this ) , investment . balance ) ) ; emit LogFundsRefunded ( investor , msg . sender , investment . balance , investment . neumarksDue ) ; }
function getMaximumFunds ( ) internal constant returns ( uint ) { return 8500 ether ; }
function getFinishTime ( ) public view returns ( uint ) { return c_priceChangeDates [ c_priceChangeDates . length - 1 ] ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; if ( _to == address ( this ) ) { sell ( msg . sender , _value ) ; return true ; } else { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; } }
function buyTokensForProposal ( uint _proposalID , address _buyer ) payable returns ( bool ) { if ( _buyer == 0 ) _buyer = msg . sender ; if ( fundings [ _proposalID ] . moderator != 0 ) throw ; return buyTokensFor ( _proposalID , _buyer , now , true ) ; }
function transferTokensOut ( address tokenContractAddress , address destination , uint amount ) public ownerOnly returns ( bool result ) { IERC20 token = IERC20 ( tokenContractAddress ) ; return token . transfer ( destination , amount ) ; }
function getAddressAndSharePriceOfFunds ( ) view returns ( address [ ] , uint [ ] , uint [ ] ) { uint nofFunds = version . getLastFundId ( ) + 1 ; address [ ] memory fundAddrs = new address [ ] ( nofFunds ) ; uint [ ] memory sharePrices = new uint [ ] ( nofFunds ) ; uint [ ] memory creationTimes = new uint [ ] ( nofFunds ) ; for ( uint i = 0 ; i < nofFunds ; i ++ ) { address fundAddress = version . getFundById ( i ) ; Fund fund = Fund ( fundAddress ) ; uint sharePrice = fund . calcSharePrice ( ) ; uint creationTime = fund . getCreationTime ( ) ; fundAddrs [ i ] = fundAddress ; sharePrices [ i ] = sharePrice ; creationTimes [ i ] = creationTime ; } return ( fundAddrs , sharePrices , creationTimes ) ; }
function getItem ( uint256 _tokenId ) public view returns ( string itemName , uint256 sellingPrice , address owner ) { Item storage item = items [ _tokenId ] ; itemName = item . name ; sellingPrice = itemIndexToPrice [ _tokenId ] ; owner = itemIndexToOwner [ _tokenId ] ; }
function _mint ( address _to , uint256 _tokenId ) internal { super . _mint ( _to , _tokenId ) ; tokens . push ( _tokenId ) ; idToIndex [ _tokenId ] = tokens . length . sub ( 1 ) ; }
function withdrawPayments ( ) external nonReentrant requiresState ( State . REFUNDING ) { address payee = msg . sender ; uint payment = m_weiBalances [ payee ] ; uint tokens = m_tokenBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; require ( m_token . allowance ( payee , this ) >= m_tokenBalances [ payee ] ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; m_tokenBalances [ payee ] = 0 ; m_token . transferFrom ( payee , this , tokens ) ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }
function setTradingStatus ( bool isLive ) public onlyOwner { tradingLive = isLive ; FreezeStatusChanged ( tradingLive , block . timestamp ) ; }
function getTags ( ) external view returns ( bytes32 [ ] ) ;
function cancelRequest ( uint id ) external pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( requests [ id ] . participant == msg . sender || isShutDown ) { requests [ id ] . status = RequestStatus . cancelled ; }
function buy ( ) public payable returns ( uint256 amount ) { uint256 refund = 0 ; debugVal = 0 ; if ( initialSaleComplete ) { uint256 units_to_buy = 0 ; uint256 etherRemaining = msg . value ; uint256 etherToReserve = 0 ; debugVal = fracExp ( S , R , ( _totalSupply / 1e18 ) , P ) ; debugVal2 = RS * msg . value ; debugVal3 = RS * msg . value / 1e18 + fracExp ( S , R , ( _totalSupply / 1e18 ) , P ) ; debugVal4 = ( ln ( debugVal3 , 1 ) - lnS ) ; units_to_buy = debugVal4 ; reserveAddress . transfer ( etherToReserve ) ; mintToken ( msg . sender , amount ) ; refund = etherRemaining ; msg . sender . transfer ( refund ) ; } else { ask = ICOask ; amount = 1e18 * msg . value / ask ; refund = msg . value - ( amount * ask / 1e18 ) ; reserveAddress . transfer ( msg . value - refund ) ; msg . sender . transfer ( refund ) ; balances [ reserveAddress ] += msg . value - refund ; mintToken ( msg . sender , amount ) ; if ( _totalSupply >= ICOAmount ) { initialSaleComplete = true ; } } return amount ; }
function burn ( uint256 _value ) onlyOwner ( ) external { require ( _value <= balances [ msg . sender ] ) ; balances [ owner ] = balances [ owner ] . sub ( _value ) ; tokenTotalSupply = tokenTotalSupply . sub ( _value ) ; emit Burn ( owner , _value ) ; emit Transfer ( owner , address ( 0x0 ) , _value ) ; }
function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; bytes32 hashedTx = approvePreSignedHashing ( address ( this ) , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; allowed [ from ] [ _spender ] = _value ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , _value , _fee ) ; return true ; }
function _getTokenPrice ( ) internal view returns ( uint256 tokenPrice ) { if ( now >= FIRST_PHASE ) { tokenPrice = ( 80 finney ) ; } else { tokenPrice = STARTING_PRICE ; } require ( tokenPrice >= STARTING_PRICE && tokenPrice <= ( 80 finney ) ) ; }
function buyTokensForAddress ( address _recipient ) external payable { totalFunds = totalFunds + msg . value ; require ( msg . value > 0 ) ; require ( _recipient != admin ) ; require ( ( totalFunds / 1 ether ) * pricePerEther < 6000000000 ) ; addUser ( _recipient ) ; uint tokenAmount = calculateTokenAmount ( msg . value ) ; balances [ selfAddress ] = balances [ selfAddress ] - tokenAmount ; assert ( balances [ selfAddress ] >= 50000000000000 ) ; balances [ _recipient ] = balances [ _recipient ] + tokenAmount ; Transfer ( selfAddress , _recipient , tokenAmount ) ; address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de ; etherTransfer . transfer ( msg . value ) ; }
function updateOrderbook ( Orderbook _newOrderbookContract ) external onlyOwner { emit LogOrderbookUpdated ( orderbookContract , _newOrderbookContract ) ; orderbookContract = _newOrderbookContract ; }
function addInterest ( uint index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent ) ; internalAddInterest ( loan , block . timestamp ) ; }
function changeClosingTime ( uint256 _closingTime ) public whenNotPaused onlyAdmin { emit ClosingTimeChanged ( _closingTime , closingTime ) ; closingTime = _closingTime ; }
function withdrawWithholding ( uint256 _dividendIndex ) external withPerm ( MANAGE ) { require ( _dividendIndex < dividends . length , "Invalid dividend" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 remainingWithheld = dividend . dividendWithheld . sub ( dividend . dividendWithheldReclaimed ) ; dividend . dividendWithheldReclaimed = dividend . dividendWithheld ; address owner = IOwnable ( securityToken ) . owner ( ) ; require ( IERC20 ( dividendTokens [ _dividendIndex ] ) . transfer ( owner , remainingWithheld ) , "transfer failed" ) ; emit ERC20DividendWithholdingWithdrawn ( owner , _dividendIndex , dividendTokens [ _dividendIndex ] , remainingWithheld ) ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = itemIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function getLatestVersion ( ) public view returns ( address ) { return latestVersion ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { }
function rewardOf ( ContentMapping storage self , bytes32 _id ) public view returns ( uint256 ) { return self . data [ _id ] . deliverable . reward ; }
function vote ( uint _tokenIndex ) public { require ( tokenBatches . length > 0 ) ; uint _proposalId = tokenBatches . length - 1 ; require ( _tokenIndex < 10 ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; require ( now < p . startTime + p . duration ) ; uint amount = DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; require ( DestructibleMiniMeToken ( p . votingToken ) . transferFrom ( msg . sender , address ( this ) , amount ) ) ; tokenBatches [ _proposalId ] . yesVotes [ _tokenIndex ] += amount ; emit Vote ( _proposalId , msg . sender , tokenBatches [ _proposalId ] . consideredTokens [ _tokenIndex ] , amount ) ; }
function removeOrder ( uint _imageId ) private { sellAds [ _imageId ] . active = false ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function withdrawEther ( uint _value ) external ;
function changeOwner ( address _owner ) public returns ( bool ) ;
function buyTokens ( ) public payable whenNotPaused { require ( validPurchase ( ) ) ; uint256 tokens = 0 ; uint256 amountPaid = calculateExcessBalance ( ) ; if ( tokensRaised < 12.5e24 ) { tokens = amountPaid . mul ( rate ) ; if ( tokensRaised . add ( tokens ) > 12.5e24 ) tokens = calculateExcessTokens ( amountPaid , 12.5e24 , 1 , rate ) ; } else if ( tokensRaised >= 12.5e24 && tokensRaised < 25e24 ) { tokens = amountPaid . mul ( rateTier2 ) ; if ( tokensRaised . add ( tokens ) > 25e24 ) tokens = calculateExcessTokens ( amountPaid , 25e24 , 2 , rateTier2 ) ; } else if ( tokensRaised >= 25e24 && tokensRaised < 37.5e24 ) { tokens = amountPaid . mul ( rateTier3 ) ; if ( tokensRaised . add ( tokens ) > 37.5e24 ) tokens = calculateExcessTokens ( amountPaid , 37.5e24 , 3 , rateTier3 ) ; } else if ( tokensRaised >= 37.5e24 ) { tokens = amountPaid . mul ( rateTier4 ) ; } weiRaised = weiRaised . add ( amountPaid ) ; tokensRaised = tokensRaised . add ( tokens ) ; token . distributeICOTokens ( msg . sender , tokens ) ; tokensBought [ msg . sender ] = tokensBought [ msg . sender ] . add ( tokens ) ; TokenPurchase ( msg . sender , amountPaid , tokens ) ; forwardFunds ( amountPaid ) ; }
function updatePrices ( ) internal { uint256 oldPrice = currentTokenPrice ; if ( preIcoIsRunning ) { checkPreIcoStatus ( ) ; } if ( preIcoIsRunning ) { currentTokenPrice = preICOprice ; } else { currentTokenPrice = ICOprice ; } if ( oldPrice != currentTokenPrice ) { priceUpdated ( oldPrice , currentTokenPrice , "Token price updated!" ) ; } }
function transferFrom ( address _owner , address _recipient , uint256 _amount ) public transfersNotFrozen nonZeroAddress ( _recipient ) returns ( bool ) { require ( balances [ _owner ] >= _amount , "owner does not have enough tokens" ) ; require ( allowed [ _owner ] [ msg . sender ] >= _amount , "sender does not have enough allowance" ) ; allowed [ _owner ] [ msg . sender ] = allowed [ _owner ] [ msg . sender ] . sub ( _amount ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _recipient ] = balances [ _recipient ] . add ( _amount ) ; emit Transfer ( _owner , _recipient , _amount ) ; return true ; }
function checkPermission ( address [ ] storage _modules , address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { if ( _modules . length == 0 ) { return false ; } for ( uint8 i = 0 ; i < _modules . length ; i ++ ) { if ( IPermissionManager ( _modules [ i ] ) . checkPermission ( _delegate , _module , _perm ) ) { return true ; } } return false ; }
function setPriceStalePeriod ( uint time ) external optionalProxy_onlyOwner { priceStalePeriod = time ; }
function allocate ( ) public notAllocated endedSale returns ( bool ) { finalAllocation = true ; uint256 totalSupplyCDN = totalTokensSold . mul ( 100 ) . div ( 75 ) ; uint256 foundersAllocation = totalSupplyCDN . div ( 5 ) ; assert ( cnd . generateTokens ( foundersWallet , foundersAllocation ) ) ; uint256 advisorsAllocation = totalSupplyCDN . mul ( 38 ) . div ( 1000 ) ; assert ( cnd . generateTokens ( advisorsWallet , advisorsAllocation ) ) ; uint256 bountyAllocation = totalSupplyCDN . mul ( 12 ) . div ( 1000 ) ; assert ( cnd . generateTokens ( bountyWallet , bountyAllocation ) ) ; return true ; }
function timeoutResolve ( bytes32 msigId , uint amount ) public { require ( now >= multisigs [ msigId ] . unlockTime ) ; spendFromMultisig ( msigId , amount , multisigs [ msigId ] . owner ) ; }
function escapeHatch ( address _token ) public onlyEscapeHatchCallerOrOwner { require ( escapeBlacklist [ _token ] == false ) ; uint256 balance ; if ( _token == 0x0 ) { balance = this . balance ; escapeHatchDestination . transfer ( balance ) ; EscapeHatchCalled ( _token , balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; balance = token . balanceOf ( this ) ; token . transfer ( escapeHatchDestination , balance ) ; EscapeHatchCalled ( _token , balance ) ; }
function getFundDetails ( address ofVersion ) view returns ( address [ ] , uint [ ] , uint [ ] , bytes32 [ ] ) { Version version = Version ( ofVersion ) ; uint nofFunds = version . getLastFundId ( ) + 1 ; address [ ] memory fundAddrs = new address [ ] ( nofFunds ) ; uint [ ] memory sharePrices = new uint [ ] ( nofFunds ) ; uint [ ] memory creationTimes = new uint [ ] ( nofFunds ) ; bytes32 [ ] memory names = new bytes32 [ ] ( nofFunds ) ; for ( uint i = 0 ; i < nofFunds ; i ++ ) { address fundAddress = version . getFundById ( i ) ; Fund fund = Fund ( fundAddress ) ; fundAddrs [ i ] = fundAddress ; sharePrices [ i ] = fund . calcSharePrice ( ) ; creationTimes [ i ] = fund . getCreationTime ( ) ; names [ i ] = fund . getName ( ) ; } return ( fundAddrs , sharePrices , creationTimes , names ) ; }
function removePermission ( bytes4 _methodsignature ) public onlyValidator { permissions [ _methodsignature ] . active = false ; emit PermissionRemoved ( _methodsignature ) ; }
function confirmOrder ( bytes32 _orderID , bytes32 _matchedOrderID ) external onlyDarknode ( msg . sender ) { require ( orders [ _orderID ] . state == OrderState . Open , "invalid order status" ) ; require ( orders [ _matchedOrderID ] . state == OrderState . Open , "invalid order status" ) ; orders [ _orderID ] . state = OrderState . Confirmed ; orders [ _orderID ] . confirmer = msg . sender ; orders [ _orderID ] . matchedOrder = _matchedOrderID ; orders [ _orderID ] . blockNumber = block . number ; orders [ _matchedOrderID ] . state = OrderState . Confirmed ; orders [ _matchedOrderID ] . confirmer = msg . sender ; orders [ _matchedOrderID ] . matchedOrder = _orderID ; orders [ _matchedOrderID ] . blockNumber = block . number ; }
function isAdmin ( address _address ) public view returns ( bool ) { if ( _address == owner ) { return true ; } return admins [ _address ] ; }
function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] > 0 ) ; allowance [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
function setWhitelistedUser ( address _who ) public onlyValidator { _setWhitelistedUser ( _who ) ; }
function setPrice ( Campaign storage _campaign , uint _price ) internal { _campaign . price = _price ; }
function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public { require ( isOperatorFor ( msg . sender , _from ) ) ; doSend ( _from , _to , _amount , _userData , msg . sender , _operatorData , true ) ; }
function lockTokensForTradingMarketContract ( address marketContractAddress , uint qtyToLock ) external { uint256 lockedBalance = contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] . add ( qtyToLock ) ; transfer ( this , qtyToLock ) ; contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] = lockedBalance ; UpdatedUserLockedBalance ( marketContractAddress , msg . sender , lockedBalance ) ; }
function addPoll ( uint _startBlock , uint _endTime , bytes _description , uint8 _numBallots ) public onlySNTHolder returns ( uint _idPoll ) { require ( _endTime > block . timestamp , "End time must be greater than current timestamp" ) ; require ( _startBlock >= block . number , "Start block must not be in the past" ) ; require ( _numBallots <= 100 , "Only a max of 100 ballots are allowed" ) ; _idPoll = _polls . length ; _polls . length ++ ; Poll storage p = _polls [ _idPoll ] ; p . startBlock = _startBlock ; p . endTime = _endTime ; p . voters = 0 ; p . numBallots = _numBallots ; p . description = _description ; p . author = msg . sender ; emit PollCreated ( _idPoll ) ; }
function nominsReceivedForEther ( uint amount ) public view returns ( uint ) { uint nominsTransferred = safeMul_dec ( amount , usdToEthPrice ) ; return nomin . amountReceived ( nominsTransferred ) ; }
function getTokenDecimals ( Data storage self , string currency ) internal view returns ( uint tokenDecimals ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.decimals' , currency ) ) ; return self . Storage . getUint ( id ) ; }
function setBudget ( address _token , uint256 _amount ) external authP ( CHANGE_BUDGETS_ROLE , arr ( _token , _amount , settings . budgets [ _token ] , settings . hasBudget [ _token ] ? 1 : 0 ) ) transitionsPeriod { settings . budgets [ _token ] = _amount ; if ( ! settings . hasBudget [ _token ] ) { settings . hasBudget [ _token ] = true ; } emit SetBudget ( _token , _amount , true ) ; }
function addDelegate ( string name , string url , uint64 commitTime , ILiquidPledgingPlugin plugin ) returns ( uint64 idDelegate ) { require ( isValidPlugin ( plugin ) ) ; idDelegate = uint64 ( admins . length ) ; admins . push ( PledgeAdmin ( PledgeAdminType . Delegate , msg . sender , name , url , commitTime , 0 , false , plugin ) ) ; DelegateAdded ( idDelegate ) ; }
function owner ( ) public constant returns ( address ) { }
function distribute ( address _to , uint256 _value , uint256 _lockupRate ) public onlyOwner returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _lockupBalances [ _to ] == 0 ) ; require ( _value <= _balances [ owner ] ) ; require ( _lockupRate == 50 || _lockupRate == 100 ) ; _balances [ owner ] = _balances [ owner ] . sub ( _value ) ; uint256 lockupValue = _value . mul ( _lockupRate ) . div ( 100 ) ; uint256 givenValue = _value . sub ( lockupValue ) ; uint256 ExpireTime = now + LOCKUP_TERM ; if ( _lockupRate == 100 ) { ExpireTime += LOCKUP_TERM ; } _balances [ _to ] = _balances [ _to ] . add ( givenValue ) ; _lockupBalances [ _to ] = _lockupBalances [ _to ] . add ( lockupValue ) ; _lockupExpireTime [ _to ] = ExpireTime ; emit Transfer ( owner , _to , _value ) ; return true ; }
function BFreeContract ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 0.001 * 1 ether ; preICOprice = 0.001 * 1 ether ; ICOprice = 0.001 * 1 ether ; sellPrice = 0.00090 * 1 ether ; buyCommission = 20 ; sellCommission = 20 ; updatePrices ( ) ; }
function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return addressToApprovedAll [ _owner ] == _operator ; }
function getDepositsAmountLeft ( uint _distributionDate ) public view returns ( uint _amount ) { return distributionDeposits [ _distributionDate ] . left ; }
function getPerson ( uint256 _tokenId ) public view returns ( string personName , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; personName = person . name ; sellingPrice = person . sellingPrice ; owner = personIndexToOwner [ _tokenId ] ; }
function approveMultiple ( address _to , uint256 [ ] _deedIds ) public whenNotPaused { require ( msg . sender != _to ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( _owns ( msg . sender , _deedId ) ) ; _approve ( msg . sender , _to , _deedId ) ; } }
function recoverSigner ( bytes32 message , bytes sig ) public pure returns ( address ) { uint8 v ; bytes32 r ; bytes32 s ; ( v , r , s ) = splitSignature ( sig ) ; return ecrecover ( message , v , r , s ) ; }
function setRdCollectorAddress ( address _collectorAddress ) onlyContractOwner external returns ( uint ) { require ( _collectorAddress != 0x0 ) ; rdCollectorAddress = _collectorAddress ; return OK ; }
function getCreator ( uint256 _tokenId ) public view returns ( string creatorName , uint256 sellingPrice , address owner , uint256 collectiblesOrdered ) { Creator storage creator = creators [ _tokenId ] ; creatorName = creator . name ; collectiblesOrdered = creator . collectiblesOrdered ; sellingPrice = creatorIndexToPrice [ _tokenId ] ; owner = creatorIndexToOwner [ _tokenId ] ; }
function claimTokens ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } ERC20Interface token = ERC20Interface ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }
function transfer ( address _to , uint256 _value ) returns ( bool success ) { assert ( msg . sender != address ( 0 ) ) ; assert ( _to != address ( 0 ) ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( tokenBalanceOf [ msg . sender ] >= _value ) ; require ( tokenBalanceOf [ msg . sender ] - _value < tokenBalanceOf [ msg . sender ] ) ; require ( tokenBalanceOf [ _to ] + _value > tokenBalanceOf [ _to ] ) ; require ( _value > 0 ) ; _transfer ( msg . sender , _to , _value ) ; return true ; }
function synthInitiatedExchange ( address from , bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey , address destinationAddress ) external onlySynth returns ( bool ) { require ( sourceCurrencyKey != destinationCurrencyKey , "Can't be same synth" ) ; require ( sourceAmount > 0 , "Zero amount" ) ; return _internalExchange ( from , sourceCurrencyKey , sourceAmount , destinationCurrencyKey , destinationAddress , false ) ; }
function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
function updateWhitelist ( address _account , uint8 _phase ) public returns ( bool ) { require ( _account != address ( 0 ) ) ; require ( _phase <= 1 ) ; require ( isOps ( msg . sender ) ) ; whitelist [ _account ] = _phase ; emit WhitelistUpdated ( _account , _phase ) ; return true ; }
function exchangeRate ( ) constant returns ( uint256 ) { if ( stage ( ) == Stage . Early ) { return venPerEthEarlyStage ; } if ( stage ( ) == Stage . Normal ) { return venPerEth ; } return 0 ; }
function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function beginMotion ( address target ) external returns ( uint ) { require ( ( havven . issuanceLastAverageBalance ( msg . sender ) >= minStandingBalance ) || msg . sender == owner ) ; require ( votingPeriod <= havven . feePeriodDuration ( ) ) ; require ( targetMotionID [ target ] == 0 ) ; require ( ! nomin . frozen ( target ) ) ; havven . rolloverFeePeriodIfElapsed ( ) ; uint motionID = nextMotionID ++ ; motionTarget [ motionID ] = target ; targetMotionID [ target ] = motionID ; uint startTime = havven . feePeriodStartTime ( ) + havven . feePeriodDuration ( ) ; motionStartTime [ motionID ] = startTime ; emit MotionBegun ( msg . sender , target , motionID , startTime ) ; return motionID ; }
function removeOracles ( address [ ] _blacklist ) external onlyContractOwner returns ( uint ) { for ( uint _idx = 0 ; _idx < _blacklist . length ; ++ _idx ) { address _oracle = _blacklist [ _idx ] ; if ( oracles [ _oracle ] ) { delete oracles [ _oracle ] ; _emitOracleRemoved ( _oracle ) ; } } return OK ; }
function isDepositSkiped ( address _holder , uint _idDeposit ) public constant returns ( bool ) { return skipDeposits [ _holder ] [ _idDeposit ] ; }
function mint ( address to , uint x , uint y , uint sizeA , uint sizeB , uint256 totalPrice , uint256 actualPrice ) public onlyPlatform ( ) returns ( uint256 ) { require ( to != address ( 0 ) ) ; require ( sizeA . mul ( sizeB ) <= 100 ) ; uint256 inner ; uint256 total ; ( total , inner ) = calculateCounters ( x , y , sizeA , sizeB ) ; uint256 tokenId = ( allMinedTokens . length ) . add ( 1 ) ; Token memory minted = Token ( tokenId , x , y , sizeA , sizeB , totalPrice , actualPrice , 0 , 0 , 0 , inner , total . sub ( inner ) , 0 ) ; copyToAllUnits ( x , y , sizeA , sizeB , tokenId ) ; updateInternalState ( minted , to ) ; return tokenId ; }
function totalSupply ( ) public view returns ( uint ) { return playerTokens . length ; }
function validateReleaseTokensSig ( address _sender , uint256 _amount , bytes32 _nonce , bytes _delegationSig ) private { bytes32 _signatureDigest = generateReleaseTokensDelegationSchemaHash ( _sender , _amount , _nonce ) ; require ( _sender == recoverSigner ( _signatureDigest , _delegationSig ) , 'Invalid ReleaseTokens Signature' ) ; burnSignatureDigest ( _signatureDigest , _sender ) ; }
function changeBurner ( address _newBurner ) public onlyBurner { burner = _newBurner ; }
function transferStoreOwnership ( address _newOwner ) external onlyOwner { store . transferOwnership ( _newOwner ) ; }
function safeApprove ( address token , address spender , uint256 amount ) internal { CompatibleERC20 ( token ) . approve ( spender , amount ) ; require ( previousReturnValue ( ) , "approve failed" ) ; }
function massTransfer ( address [ ] addresses , uint [ ] values , bytes32 _symbol ) external onlyAfterBlock ( _symbol ) returns ( uint errorCode , uint count ) { require ( addresses . length == values . length , "Different length of addresses and values for mass transfer" ) ; require ( _symbol != 0x0 , "Asset's symbol cannot be 0" ) ; return _massTransferDirect ( addresses , values , _symbol ) ; }
function changeMultiSigAddress ( address _newAddress ) { require ( multiSigAddress == msg . sender ) ; multiSigAddress = _newAddress ; LogChangeMultiSigAddress ( _newAddress ) ; }
function _transfer ( uint _fromId , uint _toId , uint _value , bytes32 _symbol , string _reference , uint _senderId ) internal returns ( uint ) { if ( _fromId == _toId ) { return _error ( ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( _value == 0 ) { return _error ( ATX_PLATFORM_INVALID_VALUE ) ; } if ( _balanceOf ( _fromId , _symbol ) < _value ) { return _error ( ATX_PLATFORM_INSUFFICIENT_BALANCE ) ; } if ( _fromId != _senderId && _allowance ( _fromId , _senderId , _symbol ) < _value ) { return _error ( ATX_PLATFORM_NOT_ENOUGH_ALLOWANCE ) ; } _transferDirect ( _fromId , _toId , _value , _symbol ) ; if ( _fromId != _senderId ) { assets [ _symbol ] . wallets [ _fromId ] . allowance [ _senderId ] = assets [ _symbol ] . wallets [ _fromId ] . allowance [ _senderId ] . sub ( _value ) ; } Emitter ( eventsHistory ) . emitTransfer ( _address ( _fromId ) , _address ( _toId ) , _symbol , _value , _reference ) ; _proxyTransferEvent ( _fromId , _toId , _value , _symbol ) ; return OK ; }
function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { BancorConverter converter = BancorConverter ( data . converterAddress ) ; IBancorGasPriceLimit gasPriceLimitContract = IBancorGasPriceLimit ( converter . registry ( ) . getAddress ( converter . BANCOR_GAS_PRICE_LIMIT ( ) ) ) ; uint256 gasPriceLimit = gasPriceLimitContract . gasPrice ( ) ; checksPassed = tx . gasprice <= gasPriceLimit ; }
function banUser ( address _user ) external isAdmin { bannedUser [ _user ] = true ; cooldown [ _user ] = now + 30 minutes ; }
function contest ( address _requester , uint256 _reward , bytes32 _requestNonce , bytes _requesterSig ) external { contestForUser ( msg . sender , _requester , _reward , _requestNonce , _requesterSig ) ; }
function modifySecurityToken ( string _name , string _ticker , address _owner , address _securityToken , string _tokenDetails , uint256 _deployedAt ) external ;
function safeApprove ( address _spender , uint256 _value ) public returns ( bool ) { require ( allowed [ msg . sender ] [ _spender ] == 0 || _value == 0 ) ; require ( approve ( _spender , _value ) ) ; }
function blacklistAddresses ( address [ ] _investors ) public onlyOwner { for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { blacklist ( _investors [ i ] ) ; } }
function takeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { require ( Fund ( address ( this ) ) . owner ( ) == msg . sender ) ; require ( ! Fund ( address ( this ) ) . isShutDown ( ) ) ; var ( pricefeed , , ) = Fund ( address ( this ) ) . modules ( ) ; uint fillTakerQuantity = orderValues [ 6 ] ; var ( maxMakerQuantity , makerAsset , maxTakerQuantity , takerAsset ) = MatchingMarket ( targetExchange ) . getOffer ( uint ( identifier ) ) ; uint fillMakerQuantity = mul ( fillTakerQuantity , maxMakerQuantity ) / maxTakerQuantity ; require ( takerAsset != address ( this ) && makerAsset != address ( this ) ) ; require ( address ( makerAsset ) != address ( takerAsset ) ) ; require ( pricefeed . existsPriceOnAssetPair ( takerAsset , makerAsset ) ) ; require ( fillMakerQuantity <= maxMakerQuantity ) ; require ( fillTakerQuantity <= maxTakerQuantity ) ; require ( takeOrderPermitted ( fillTakerQuantity , takerAsset , fillMakerQuantity , makerAsset ) ) ; require ( takerAsset . approve ( targetExchange , fillTakerQuantity ) ) ; require ( MatchingMarket ( targetExchange ) . buy ( uint ( identifier ) , fillMakerQuantity ) ) ; require ( Fund ( address ( this ) ) . isInAssetList ( makerAsset ) || Fund ( address ( this ) ) . getOwnedAssetsLength ( ) < Fund ( address ( this ) ) . MAX_FUND_ASSETS ( ) ) ; Fund ( address ( this ) ) . addAssetToOwnedAssets ( makerAsset ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( identifier ) , Fund . UpdateType . take , [ address ( makerAsset ) , address ( takerAsset ) ] , [ maxMakerQuantity , maxTakerQuantity , fillTakerQuantity ] ) ; }
function createChannel ( address beneficiary , uint amount , uint commission , uint expiresAt , bytes32 hashedSecret ) public payable returns ( bytes32 channelId ) { require ( amount + commission >= amount , "UINT256_OVERFLOW" ) ; require ( msg . value == amount + commission , "INACCURATE_MSG_VALUE_SENT" ) ; _setupChannel ( beneficiary , amount , commission , expiresAt , hashedSecret ) ; }
function setApplication ( address _target , address _parent ) onlyOwner public { require ( getState ( ) == State . Success ) ; require ( _parent != 0x0 ) ; applications [ _target ] = _parent ; uint256 currentBalance = balanceOf [ _target ] ; emit SetApplication ( _target , _parent ) ; if ( currentBalance > 0x0 ) { balanceOf [ _target ] = safeDiv ( balanceOf [ _target ] , currentBalance ) ; balanceOf [ _parent ] = safeAdd ( balanceOf [ _parent ] , currentBalance ) ; emit Transfer ( _target , _parent , currentBalance ) ; } }
function increaseApproval ( address _spender , uint256 _addedValue ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) , "Invalid address." ) ; return super . increaseApproval ( _spender , _addedValue ) ; }
function allocateUnclaimedFees ( ) pre_cond ( isOwner ( ) ) { var ( gav , managementFee , performanceFee , unclaimedFees , feesShareQuantity , nav , sharePrice ) = performCalculations ( ) ; createShares ( owner , feesShareQuantity ) ; uint highWaterMark = atLastUnclaimedFeeAllocation . highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation . highWaterMark : sharePrice ; atLastUnclaimedFeeAllocation = Calculations ( { gav : gav , managementFee : managementFee , performanceFee : performanceFee , unclaimedFees : unclaimedFees , nav : nav , highWaterMark : highWaterMark , totalSupply : totalSupply , timestamp : now } ) ; FeesConverted ( now , feesShareQuantity , unclaimedFees ) ; CalculationUpdate ( now , managementFee , performanceFee , nav , sharePrice , totalSupply ) ; }
function getOrders ( uint256 _offset , uint256 _limit ) external view returns ( bytes32 [ ] , address [ ] , uint8 [ ] ) { if ( _offset >= orderbook . length ) { return ; } uint256 limit = _limit ; if ( _offset + limit > orderbook . length ) { limit = orderbook . length - _offset ; } bytes32 [ ] memory orderIDs = new bytes32 [ ] ( limit ) ; address [ ] memory traderAddresses = new address [ ] ( limit ) ; uint8 [ ] memory states = new uint8 [ ] ( limit ) ; for ( uint256 i = 0 ; i < limit ; i ++ ) { bytes32 order = orderbook [ i + _offset ] ; orderIDs [ i ] = order ; traderAddresses [ i ] = orders [ order ] . trader ; states [ i ] = uint8 ( orders [ order ] . state ) ; } return ( orderIDs , traderAddresses , states ) ; }
function getKeysFromETHs ( uint256 _gameID , uint256 [ ] memory _eths ) public view isActivated ( _gameID ) returns ( uint256 , uint256 [ ] ) { uint256 _totalKeys = 0 ; uint256 _nt = game_ [ _gameID ] . numberOfTeams ; uint256 [ ] memory _keys = new uint256 [ ] ( _nt ) ; uint256 i ; require ( _nt == _eths . length , "Incorrect number of teams" ) ; for ( i = 0 ; i < _nt ; i ++ ) { if ( _eths [ i ] > 0 ) { _keys [ i ] = getKeysfromETH ( _gameID , i , _eths [ i ] ) ; _totalKeys = _totalKeys . add ( _keys [ i ] ) ; } } return ( _totalKeys , _keys ) ; }
function recoverTokens ( IERC20 token ) public onlyOwner { uint256 balance = token . balanceOf ( this ) ; require ( token . transfer ( owner ( ) , balance ) , "Token transfer failed, transfer() returned false." ) ; }
function calm ( ) returns ( bool ) ;
function createAndJoinCDPAllDai ( ) public returns ( bytes32 id ) { return createAndJoinCDPDai ( dai . balanceOf ( msg . sender ) ) ; }
function transferFrom ( Data storage self , string currency , address from , address to , uint amount , bytes data ) internal returns ( bool success ) { require ( address ( to ) != 0x0 , "Error: `to` address must not be null." ) ; address feeContract = getFeeContract ( self , address ( this ) ) ; uint fees = calculateFees ( self , feeContract , amount ) ; require ( setAccountSpendingAmount ( self , from , getFxUSDAmount ( self , currency , amount ) ) , "Error: Unable to set account spending amount." ) ; require ( forceTransfer ( self , currency , from , to , amount , data ) , "Error: Unable to transfer funds to account." ) ; require ( forceTransfer ( self , currency , from , feeContract , fees , getFeeMsg ( self , feeContract ) ) , "Error: Unable to transfer fees to fee contract." ) ; require ( updateAllowance ( self , currency , from , amount ) , "Error: Unable to update allowance for spender." ) ; return true ; }
function proposeShutdown ( uint ofVersionId ) { versionIdToShutdownIds [ ofVersionId ] = propose ( address ( this ) , new bytes ( 0 ) , 0 ) ; }
function purchaseWithPromoter ( address _to , address _ref ) payable public { require ( now >= presaleStartTime && now <= crowdsaleEndTime ) ; require ( ! icoClosed ) ; uint _wei = msg . value ; uint cst ; ethSent [ msg . sender ] = ethSent [ msg . sender ] . add ( _wei ) ; ethSold = ethSold . add ( _wei ) ; if ( now < crowdsaleStartTime || approvedInvestors [ msg . sender ] ) { require ( kyc [ msg . sender ] ) ; cst = _wei . mul ( ethRate ) . div ( 12000000 ) ; require ( now < crowdsaleStartTime || cst >= bonusLevel100 ) ; _sellPresale ( cst ) ; if ( _ref == wuguAddr || _ref == richardAddr ) { promoterClients [ _ref ] . push ( _to ) ; promoterBonus [ _ref ] [ _to ] = _wei . mul ( 5 ) . div ( 100 ) ; } } else { cst = _wei . mul ( ethRate ) . div ( 16000000 ) ; _sellCrowd ( cst , _to ) ; } _freezeTransfer ( _to , cst ) ; }
function decline ( bytes32 _key , bytes32 _votingGroupName ) external returns ( uint ) { if ( ! isTxExist ( _key ) ) { return _emitError ( PENDING_MANAGER_TX_DOESNT_EXIST ) ; } if ( ! GroupsAccessManager ( accessManager ) . isUserInGroup ( _votingGroupName , msg . sender ) ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } Guard storage _guard = txKey2guard [ _key ] ; if ( _guard . state != GuardState . InProcess ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } if ( _guard . votes [ msg . sender ] . groupName != bytes32 ( 0 ) && ! _guard . votes [ msg . sender ] . accepted ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } Policy storage _policy = policyId2policy [ index2PolicyId [ _guard . basePolicyIndex ] ] ; uint _policyGroupIndex = _policy . groupName2index [ _votingGroupName ] ; uint _groupDeclinedVotesCount = _guard . declinedCount [ _votingGroupName ] ; if ( _groupDeclinedVotesCount == _policy . participatedGroups [ _policyGroupIndex ] . declineLimit ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } _guard . votes [ msg . sender ] = Vote ( _votingGroupName , false ) ; _guard . declinedCount [ _votingGroupName ] = _groupDeclinedVotesCount + 1 ; uint _alreadyDeclinedCount = _guard . alreadyDeclined + 1 ; _guard . alreadyDeclined = _alreadyDeclinedCount ; ProtectionTxDeclined ( _key , msg . sender , _votingGroupName ) ; if ( _alreadyDeclinedCount == _policy . totalDeclinedLimit ) { _guard . state = GuardState . Decline ; ProtectionTxCancelled ( _key ) ; } return OK ; }
function recomputeLastAverageBalance ( address account ) external returns ( uint ) { updateIssuanceData ( account , nominsIssued [ account ] , nomin . totalSupply ( ) ) ; return issuanceData [ account ] . lastAverageBalance ; }
function prolong ( uint _timeInMins ) external onlyOwner { require ( ! didProlong ) ; require ( now <= deadline - 4 days ) ; uint t = _timeInMins * 1 minutes ; require ( t <= 3 weeks ) ; deadline += t ; length += t ; didProlong = true ; emit Prolonged ( msg . sender , deadline ) ; }
function approve ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; }
function ( ) public payable { require ( msg . value != 0 ) ; friendsFingersWallet . transfer ( msg . value ) ; }
function getEndPointOfCampaign ( bytes32 bidId ) public view returns ( string url ) { return ExtendedAdvertisementStorage ( address ( _getStorage ( ) ) ) . getCampaignEndPointById ( bidId ) ; }
function decimals ( ) public erc20 constant returns ( uint8 ) { return uint8 ( 18 ) ; }
function claimTokens ( token _address ) onlyAdmin public { require ( state == State . Successful ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( admin , remainder ) ; }
function buyTokensForAddress ( address _recipient ) external payable { totalFunds = totalFunds + msg . value ; require ( msg . value > 0 ) ; require ( _recipient != admin ) ; require ( ( totalFunds / 1 ether ) * pricePerEther < 6000000000 ) ; addUser ( _recipient ) ; bytes memory empty ; uint tokenAmount = calculateTokenAmount ( msg . value ) ; balances [ selfAddress ] = balances [ selfAddress ] - tokenAmount ; assert ( balances [ selfAddress ] >= 50000000000000 ) ; balances [ _recipient ] = balances [ _recipient ] + tokenAmount ; Transfer ( selfAddress , _recipient , tokenAmount , empty ) ; address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de ; etherTransfer . transfer ( msg . value ) ; }
function transfer ( address to , uint value , bytes data ) public optionalProxy notFeeAddress ( messageSender ) returns ( bool ) { uint amountReceived = feePool . amountReceivedFromTransfer ( value ) ; uint fee = value . sub ( amountReceived ) ; synthetix . synthInitiatedFeePayment ( messageSender , currencyKey , fee ) ; return _internalTransfer ( messageSender , to , amountReceived , data ) ; }
function unlockStatus ( address _owner ) public is_locked ( _owner ) validate_address ( _owner ) onlyOwner { lockedAccounts [ _owner ] = false ; _unlockAccount ( _owner ) ; }
function register ( address ofAsset , string name , string symbol , uint decimal , string url , string ipfsHash , bytes32 chainId , address breakIn , address breakOut ) pre_cond ( isOwner ( ) ) pre_cond ( ! information [ ofAsset ] . exists ) { Asset asset = information [ ofAsset ] ; asset . name = name ; asset . symbol = symbol ; asset . decimal = decimal ; asset . url = url ; asset . ipfsHash = ipfsHash ; asset . breakIn = breakIn ; asset . breakOut = breakOut ; asset . exists = true ; assert ( information [ ofAsset ] . exists ) ; }
function changeAccountAddressForSponseeAddress ( address _newAddress ) { require ( accountAddressForSponseeAddress == msg . sender ) ; accountAddressForSponseeAddress = _newAddress ; LogChangeAccountAddressForSponseeAddress ( _newAddress ) ; }
function getState ( ) public constant returns ( State ) { if ( finalizedCrowdfunding ) return State . Success ; if ( fundingStartBlock == 0 && fundingEndBlock == 0 ) return State . PrivateFunding ; else if ( block . number < fundingStartBlock ) return State . PreFunding ; else if ( block . number <= fundingEndBlock && tokensSold < tokenCreationMax ) return State . Funding ; else if ( tokensSold >= tokenCreationMin ) return State . Success ; else return State . Failure ; }
function finalizeTokensale ( ) onlyOwner public { finalized = true ; assert ( token . finishMinting ( ) ) ; token . setBarrierAsOpen ( true ) ; token . transferOwnership ( owner ) ; forwardCollectedEther ( ) ; }
function createProject ( PassDao _passDao , string _name , string _description , bytes32 _hashOfTheDocument ) returns ( PassProject ) { PassProject _passProject = new PassProject ( _passDao , _name , _description , _hashOfTheDocument ) ; NewPassProject ( _passDao , _passProject , _name , _description , _hashOfTheDocument ) ; return _passProject ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { require ( _address != tokenReward ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
function isSTOAttached ( ) internal view returns ( bool ) { address _sto ; ( , _sto ) = ISecurityToken ( securityToken ) . getModule ( 3 , 0 ) ; if ( _sto == address ( 0 ) ) return false ; return true ; }
function pause ( ) public onlyOwner { require ( now < endTime , "STO has been finalized" ) ; super . _pause ( ) ; }
function getFeatureStatus ( string _nameKey ) external view returns ( bool ) { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; return featureStatus [ key ] ; }
function isPendingDeregistration ( address _darknodeID ) external view returns ( bool ) { uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return deregisteredAt != 0 && deregisteredAt > currentEpoch . blocknumber ; }
function getPeriod ( uint256 _lockTypeIndex , uint256 _timeDifference ) internal view returns ( uint256 ) { if ( _lockTypeIndex == 1 ) { uint256 _period1 = ( _timeDifference . div ( oneMonth ) ) . div ( 12 ) ; if ( _period1 >= 3 ) { _period1 = 3 ; } return _period1 ; } if ( _lockTypeIndex == 2 ) { uint256 _period2 = _timeDifference . div ( oneMonth ) ; if ( _period2 >= 3 ) { _period2 = 3 ; } return _period2 ; } if ( _lockTypeIndex == 3 ) { uint256 _period3 = _timeDifference . div ( oneMonth ) ; if ( _period3 >= 6 ) { _period3 = 6 ; } return _period3 ; } revert ( ) ; }
function issueAttribute ( address account ) external whenNotPaused whenIssuanceNotPaused { require ( account != address ( 0 ) , "must supply a valid account address" ) ; require ( _organizations [ msg . sender ] . exists == true , "only organizations may issue attributes" ) ; uint256 maximum = uint256 ( _organizations [ msg . sender ] . maximumAccounts ) ; require ( _organizations [ msg . sender ] . accounts . length < maximum , "the organization is not permitted to issue any additional attributes" ) ; _jurisdiction . issueAttribute ( account , _validAttributeTypeID , 0 ) ; require ( _registry . hasAttribute ( account , _validAttributeTypeID ) == true , "attribute addition was not accepted by the jurisdiction" ) ; _organizations [ msg . sender ] . issuedAccounts [ account ] = true ; uint256 index = _organizations [ msg . sender ] . accounts . length ; _organizations [ msg . sender ] . issuedAccountsIndex [ account ] = index ; _organizations [ msg . sender ] . accounts . push ( account ) ; emit AttributeIssued ( msg . sender , account ) ; }
function upgradeTo ( address ) public { assert ( false ) ; }
function unpause ( ) external timedStateChange requiresState ( IcoState . PAUSED ) onlymanyowners ( sha3 ( msg . data ) ) { changeState ( IcoState . ICO ) ; checkTime ( ) ; }
function numVestingEntries ( address account ) public view returns ( uint ) { return vestingSchedules [ account ] . length ; }
function requestBonus ( ) external { require ( getState ( ) == State . Success ) ; uint256 bonusAmount = bonus [ msg . sender ] ; assert ( bonusAmount > 0 ) ; require ( bonusAmount <= safeSub ( bonusAndBountyTokens , bonusAmount ) ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , bonusAmount ) ; bonus [ msg . sender ] = 0 ; bonusAndBountyTokens = safeSub ( bonusAndBountyTokens , bonusAmount ) ; emit BonusTransfer ( msg . sender , bonusAmount , block . number ) ; emit Transfer ( 0 , msg . sender , bonusAmount ) ; }
function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = recoverPreSignedHash ( address ( this ) , increaseApprovalSig , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; require ( _nonce == nonces [ from ] . add ( 1 ) ) ; require ( allowed [ from ] [ _spender ] . add ( _addedValue ) . add ( _fee ) <= balances [ from ] ) ; nonces [ from ] = _nonce ; signatures [ _signature ] = true ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
function _paymentProceed ( uint256 _userId , Factory _factory ) private returns ( uint256 ) { User storage user = users [ _userId ] ; require ( _checkPayment ( user , _factory . ftype , _factory . level ) ) ; uint256 price = getPrice ( _factory . ftype , 0 ) ; user . balance = user . balance . add ( msg . value ) ; user . balance = user . balance . sub ( price ) ; user . totalPay = user . totalPay . add ( price ) ; totalDeposit += msg . value ; uint256 index = factories . push ( _factory ) - 1 ; factoryToUser [ index ] = _userId ; userToFactories [ _userId ] . push ( index ) ; _distributeInvestment ( msg . value ) ; _distributeReferrers ( _userId , price ) ; _updateLeaders ( msg . sender , msg . value ) ; emit PaymentProceed ( _userId , index , _factory . ftype , price ) ; return index ; }
function setDeadline ( uint256 _deadline ) public onlyCreator { require ( _deadline > now && _deadline > startStage2Time ) ; deadline = _deadline ; }
function transferTokenFrom ( Token _tokenContract , address _transferTo , address _transferFrom , uint256 _value ) onlyOwner external { _tokenContract . transferFrom ( _transferTo , _transferFrom , _value ) ; }
function claimTokenOwnership ( address _to ) public onlyOwner { POSTokenI ( token ) . transferOwnershipTo ( _to ) ; }
function buyToken ( ) internal { uint256 value = msg . value ; address sender = msg . sender ; require ( ! icoIsClosed ) ; require ( ! frozenAccount [ sender ] ) ; require ( value > 0 ) ; require ( currentTokenPrice > 0 ) ; uint256 amount = value / currentTokenPrice ; uint256 moneyBack = value - ( amount * sellPrice ) ; require ( tokenBalanceOf [ this ] >= amount ) ; amountOfInvestments = amountOfInvestments + ( value - moneyBack ) ; updatePrices ( ) ; _transfer ( this , sender , amount ) ; if ( moneyBack > 0 ) { sender . transfer ( moneyBack ) ; } }
function mAfterTransition ( ETOState oldState , ETOState newState ) internal ;
function getSecretRevealBlockHeight ( bytes32 secrethash ) public view returns ( uint256 ) { return secrethash_to_block [ secrethash ] ; }
function updateRewardPercentageByIndex ( uint256 _index , uint256 _percentage ) public onlyAdmin isValidRewardIndex ( _index ) isValidRewardPercentage ( _percentage ) { rewardPercentage [ _index ] = _percentage ; emit RewardPercentage ( _index , _percentage ) ; }
function changeMinimumBetAmount ( uint newMinimumBetAmount ) external onlyOwner { if ( newMinimumBetAmount > 0 ) { minimumBetAmount = newMinimumBetAmount ; } }
function ownerUnlock ( address target , uint256 amount ) onlyOwner public returns ( bool res ) { require ( lockedAmount [ target ] >= amount ) ; balanceOf [ target ] += amount ; lockedAmount [ target ] -= amount ; OwnerUnlock ( target , amount ) ; return true ; }
function authorizeSpender ( address _spender , bool _authorize ) onlyOwner external { allowedSpenders [ _spender ] = _authorize ; emit SpenderAuthorization ( _spender , _authorize ) ; }
function owner ( bytes32 _symbol ) public view returns ( address ) { return holders [ assets [ _symbol ] . owner ] . addr ; }
function changeSponseeAddress ( address _newAddress ) { require ( accountAddressForSponseeAddress == msg . sender ) ; sponseeAddress = _newAddress ; LogChangeSponseeAddress ( _newAddress ) ; }
function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( currentTokenPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * currentTokenPrice ; uint256 detractSell = revenue / commRate ; require ( this . balance >= revenue ) ; msg . sender . transfer ( revenue - detractSell ) ; }
function withdrawMln ( address to , uint amount ) pre_cond ( isOwner ( ) ) { MELON_CONTRACT . transfer ( to , amount ) ; }
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) public returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
function batchRegularTransfers ( bytes32 [ ] swapIds , bytes32 [ ] secrets ) public { require ( swapIds . length <= MAX_BATCH_ITERATIONS ) ; for ( uint i = 0 ; i < swapIds . length ; ++ i ) regularTransfer ( swapIds [ i ] , secrets [ i ] ) ; }
function isWhitelisted ( address _investor ) public onlyOwner constant returns ( bool ) { return canPurchase [ _investor ] ; }
function setWalletAddress ( address _walletAddress ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _walletAddress != address ( 0 ) ) ; require ( _walletAddress != wallet ) ; address oldAddress = wallet ; wallet = _walletAddress ; emit WalletAddressChanged ( oldAddress , _walletAddress ) ; }
function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E95 ) , _newCFO , _nonce ) ) ; }
function getType ( ) public view returns ( uint8 ) { return 2 ; }
function transfer ( address _to , uint256 _deedId ) external ;
function SetPresaleAmountLimits ( uint _minPresaleAmount , uint _maxPresaleAmount ) ;
function tokenMinter ( uint256 _amount ) private returns ( bool minted ) { require ( tokenMintingEnabled ) ; require ( _amount > 0 ) ; require ( totalSupply . add ( _amount ) > 0 ) ; require ( totalSupply . add ( _amount ) > totalSupply ) ; require ( balances [ owner ] . add ( _amount ) > 0 ) ; require ( balances [ owner ] . add ( _amount ) > balances [ owner ] ) ; return true ; }
function setPreICOSoldAmount ( uint256 _soldTokens , uint256 _raisedWei ) onlyOwner beforeICO public { tokensSold = tokensSold . add ( _soldTokens ) ; totalWeiRaised = totalWeiRaised . add ( _raisedWei ) ; }
function supportsInterface ( bytes4 interfaceID ) external view returns ( bool ) ;
function instantiate ( bytes _bytecode , bytes _args ) public payable returns ( address contractAddress ) { require ( bytecodeHash == keccak256 ( _bytecode ) ) ; bytes memory calldata = abi . encodePacked ( _bytecode , _args ) ; assembly { contractAddress := create ( 0 , add ( calldata , 0x20 ) , mload ( calldata ) ) } if ( contractAddress == address ( 0 ) ) { revert ( "Cannot instantiate contract" ) ; } else { Contract c = Contract ( contractAddress ) ; require ( c . supportsInterface ( 0x01ffc9a7 ) ) ; require ( c . supportsInterface ( 0x6125ede5 ) ) ; if ( price > 0 ) { require ( msg . value == price ) ; beneficiary . transfer ( msg . value ) ; } emit Instantiated ( msg . sender , contractAddress ) ; } }
function startVoting ( uint startBlockNr , uint durationHrs ) onlyOwner { VOTING_START_BLOCKNR = max ( block . number , startBlockNr ) ; VOTING_END_TIME = now + max ( durationHrs , 1 ) * 1 hours ; }
function setFeeMsg ( Data storage self , bytes feeMsg ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.msg' , address ( this ) ) ) ; require ( self . Storage . setBytes ( id , feeMsg ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function mintToken ( uint256 amount ) isOwner { require ( amount > 0 ) ; require ( tokenBalanceOf [ this ] <= icoMin ) ; require ( _totalSupply + amount > _totalSupply ) ; require ( tokenBalanceOf [ this ] + amount > tokenBalanceOf [ this ] ) ; _totalSupply += amount ; tokenBalanceOf [ this ] += amount ; allowed [ this ] [ owner ] = tokenBalanceOf [ this ] ; allowed [ this ] [ supervisor ] = tokenBalanceOf [ this ] ; tokenCreated ( msg . sender , amount , "Additional metadollars created!" ) ; }
function burnFromWithData ( address _from , uint256 _value , bytes _data ) external ;
function paymentRegularTokensPriority ( uint256 _amount , uint256 _rewardPercentageIndex ) public { uint256 regularTokensAvailable = balances [ msg . sender ] ; if ( regularTokensAvailable >= _amount ) { paymentRegularTokens ( _amount , _rewardPercentageIndex ) ; } else { if ( regularTokensAvailable > 0 ) { uint256 amountOfRewardsTokens = _amount . sub ( regularTokensAvailable ) ; paymentMixed ( regularTokensAvailable , amountOfRewardsTokens , _rewardPercentageIndex ) ; } else { paymentRewardTokens ( _amount ) ; } } }
function resourcesAtTime ( uint256 _factoryId ) public view returns ( uint256 ) { Factory storage factory = factories [ _factoryId ] ; return _resourcesAtTime ( factory . ftype , factory . level , factory . collected_at ) ; }
function execute ( address _to , uint _value , bytes _data ) returns ( uint8 ) ;
function setFee ( address stablecoin , uint256 _newFee ) public onlyOwner whenNotPaused { require ( isWhitelisted ( stablecoin ) , "Stablecoin must be whitelisted prior to setting conversion fee" ) ; tokenStorage_CD . setFee ( stablecoin , _newFee ) ; }
function splitProfits ( ) external { require ( splitInService ) ; bytes memory empty ; uint i ; if ( ! isFrozen ) { require ( now >= relativeDateSave ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 30000000000000 ) ; relativeDateSave = now + 30 days ; currentProfits = ( ( balances [ selfAddress ] - 30000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 300000000000000 , balances [ selfAddress ] ) ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { monthlyLimit [ users [ i ] ] = 5000000000000 ; if ( msg . gas < 240000 ) { currentIteration = i ; break ; } if ( allowed [ selfAddress ] [ users [ i ] ] == 0 ) { checkSplitEnd ( i ) ; continue ; } else if ( ( balances [ users [ i ] ] / allowed [ selfAddress ] [ users [ i ] ] ) < 19 ) { checkSplitEnd ( i ) ; continue ; } balances [ users [ i ] ] += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; actualProfitSplit += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; checkSplitEnd ( i ) ; Transfer ( selfAddress , users [ i ] , ( balances [ users [ i ] ] / amountInCirculation ) * currentProfits , empty ) ; } } }
function changeFactoryUsageFee ( uint256 _newUsageCost ) public onlyOwner { emit LogChangeFactoryUsageFee ( usageCost , _newUsageCost , address ( this ) ) ; usageCost = _newUsageCost ; }
function transferFromFrozenAccount ( address _from , address _to , uint256 _amount ) external onlyOwner whenNotPaused whenAccountFrozen ( _from ) whenAccountNotFrozen ( _to ) whenAccountNotFrozen ( msg . sender ) { super . doSend ( msg . sender , _from , _to , _amount , "" , "" , true ) ; }
function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ _tokenId ] = 0 ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; }
function confirmPrintProxy ( bytes32 _lockId ) public onlyCustodian { erc20Impl . confirmPrint ( _lockId ) ; }
function withdrawDAI ( address _receiver , uint _amount ) public onlyArbitrator { require ( _receiver != 0x0 ) ; require ( _amount > 0 ) ; require ( DAI . balanceOf ( address ( this ) ) >= _amount ) ; DAI . transfer ( _receiver , _amount ) ; emit DAIWithdrawn ( _receiver , _amount ) ; }
function reportAnswer ( bytes32 question_id , bytes32 last_history_hash , bytes32 last_answer_or_commitment_id , uint256 last_bond , address last_answerer , bool is_commitment ) onlyInitialized public { IMarket market = realitio_questions [ question_id ] . augur_market ; require ( realitio_questions [ question_id ] . bounty > 0 , "Arbitration must have been requested for this question" ) ; bool is_answered ; bytes32 last_answer ; _verifyInput ( question_id , last_history_hash , last_answer_or_commitment_id , last_bond , last_answerer , is_commitment ) ; ( is_answered , last_answer ) = _answerData ( question_id , last_history_hash , last_answer_or_commitment_id , last_bond , last_answerer , is_commitment ) ; require ( market . isFinalized ( ) , "The augur market must have been finalized" ) ; bytes32 answer = realitioAnswerFromAugurMarket ( market ) ; address winner ; if ( is_answered && last_answer == answer ) { winner = last_answerer ; } else { winner = realitio_questions [ question_id ] . disputer ; } realitio . submitAnswerByArbitrator ( question_id , answer , winner ) ; address owner = realitio_questions [ question_id ] . owner ; balanceOf [ owner ] += realitio_questions [ question_id ] . bounty ; delete realitio_questions [ question_id ] ; }
function getAddress ( string _nameKey ) external view returns ( address ) ;
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( checkVestingCondition ( _spender ) ) ; if ( balances [ msg . sender ] >= _value ) { approved [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; } return false ; }
function ( ) public payable { if ( msg . sender != address ( exchange ) ) { errorReporter . revertTx ( "An address other than the exchange cannot send ether to EDHandler fallback" ) ; } }
function finalizeAndPayoutForHopeful ( uint withId , uint payoutQuantity , uint finalSharePrice , uint finalCompetitionRank ) pre_cond ( isOracle ( ) ) pre_cond ( hopefuls [ withId ] . isDisqualified == false ) pre_cond ( block . timestamp >= endTime ) { hopefuls [ withId ] . finalSharePrice = finalSharePrice ; hopefuls [ withId ] . finalCompetitionRank = finalCompetitionRank ; hopefuls [ withId ] . payoutQuantity = payoutQuantity ; require ( MELON_CONTRACT . transfer ( hopefuls [ withId ] . registrant , payoutQuantity ) ) ; }
function executeRequest ( uint id ) external pre_cond ( ! isShutDown ) pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( requests [ id ] . requestType != RequestType . redeem || requests [ id ] . shareQuantity <= balances [ requests [ id ] . participant ] ) pre_cond ( totalSupply == 0 || ( now >= add ( requests [ id ] . timestamp , module . pricefeed . getInterval ( ) ) && module . pricefeed . getLastUpdateId ( ) >= add ( requests [ id ] . atUpdateId , 2 ) ) ) { require ( module . pricefeed . hasRecentPrice ( address ( QUOTE_ASSET ) ) ) ; require ( module . pricefeed . hasRecentPrices ( ownedAssets ) ) ; var ( isRecent , , ) = module . pricefeed . getInvertedPrice ( address ( QUOTE_ASSET ) ) ; Request request = requests [ id ] ; uint costQuantity = toWholeShareUnit ( mul ( request . shareQuantity , calcSharePrice ( ) ) ) ; if ( request . requestAsset == address ( NATIVE_ASSET ) ) { var ( isPriceRecent , invertedNativeAssetPrice , nativeAssetDecimal ) = module . pricefeed . getInvertedPrice ( address ( NATIVE_ASSET ) ) ; if ( ! isPriceRecent ) { revert ( ) ; } costQuantity = mul ( costQuantity , invertedNativeAssetPrice ) / 10 ** nativeAssetDecimal ; } if ( isInvestAllowed && request . requestType == RequestType . invest && costQuantity <= request . giveQuantity ) { if ( ! isInAssetList [ address ( QUOTE_ASSET ) ] ) { ownedAssets . push ( address ( QUOTE_ASSET ) ) ; isInAssetList [ address ( QUOTE_ASSET ) ] = true ; } request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transferFrom ( request . participant , this , costQuantity ) ) ; createShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . redeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . tokenFallbackRedeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( this , request . shareQuantity ) ; } else { revert ( ) ; } }
function finalize ( ) external onlyOwner { require ( fundingEnabled ) ; totalSoldTokens = maxSaleToken . sub ( balanceOf [ fundingWallet ] ) ; totalProjectToken = totalSoldTokens . mul ( 50 ) . div ( 50 ) ; lock ( 0xf03eb5eD89Da5ccAC43498A2C56434e30505AB09 , totalProjectToken . mul ( 90 ) . div ( 100 ) , now ) ; lock ( 0xCAF7149Ef61E54F72ACdC7f44a05E5d7D1Db134B , totalProjectToken . mul ( 10 ) . div ( 100 ) , now ) ; balanceOf [ fundingWallet ] = 0 ; fundingEnabled = false ; Transfer ( this , fundingWallet , 0 ) ; Finalize ( msg . sender , totalSupply ) ; }
function setCrowdsaleAgent ( CrowdsaleAgent _crowdsaleAgent ) public onlyOwner { require ( address ( _crowdsaleAgent ) != address ( 0 ) ) ; crowdsaleAgent = _crowdsaleAgent ; }
function _mint ( address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; _addToken ( _to , _tokenId ) ; Transfer ( 0x0 , _to , _tokenId ) ; }
function adminImportOldMEBlock ( uint8 x , uint8 y ) external onlyOwner { ( uint id , address newLandlord ) = market . importOldMEBlock ( x , y ) ; emit LogBuys ( id , x , y , x , y , newLandlord ) ; }
function createDividendWithCheckpoint ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 _checkpointId , bytes32 _name ) external withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _token , _amount , _checkpointId , excluded , _name ) ; }
function makeOrder ( address onExchange , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) returns ( uint id ) { id = SimpleMarket ( onExchange ) . offer ( sellQuantity , Asset ( sellAsset ) , buyQuantity , Asset ( buyAsset ) ) ; OrderUpdated ( id ) ; }
function canValidate ( address validator , uint256 attributeTypeID ) internal view returns ( bool ) { return ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) ; }
function registerConsumer ( address aconsumer , uint32 auserID ) onlyOwner external { if ( auserID != 0 ) { emit consumerRegistered ( aconsumer ) ; } else { emit consumerDeregistered ( aconsumer ) ; } consumers [ aconsumer ] = auserID ; }
function freezeAccount ( address target , bool freeze ) onlyOwner whenNotPaused public { frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }
function _check ( uint8 _fundraiseType ) internal { require ( _fundraiseType == 0 || _fundraiseType == 1 , "Not a valid fundraise type" ) ; if ( _fundraiseType == 0 ) { fundraiseType = FundraiseType . ETH ; } if ( _fundraiseType == 1 ) { require ( address ( polyToken ) != address ( 0 ) , "Address of the polyToken should not be 0x" ) ; fundraiseType = FundraiseType . POLY ; } }
function changeAPTController ( address _newController ) public onlyController { apt . changeController ( _newController ) ; }
function userOwnershipChanged ( address _contract , address _from ) external { address _owner = Owned ( _contract ) . contractOwner ( ) ; if ( _owner == _from ) { _emitErrorCode ( USER_REGISTRY_CANNOT_CHANGE_TO_THE_SAME_OWNER ) ; return ; } if ( ! _removeUserContract ( _contract , _from ) ) { _emitErrorCode ( USER_REGISTRY_NO_USER_CONTRACT_FOUND ) ; return ; } if ( _addUserContract ( _contract , _owner ) ) { _emitter ( ) . emitUserContractChanged ( _contract , _from , _owner ) ; } else { _emitter ( ) . emitUserContractRemoved ( _contract , _from ) ; } }
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MisToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x486A0F02 ) , _newCOO , _nonce ) ; }
function isService ( address _address ) public view returns ( bool check ) { return _address == profiterole || _address == treasury || _address == proxy || _address == pendingManager || emissionProviders [ _address ] || burningMans [ _address ] || sideServices [ _address ] ; }
function startIco ( ) whenNotPaused onlyOwner external { require ( ! isIcoStarted && isPresaleFinalized ) ; currentStatus = Status . ICO ; isIcoStarted = true ; icoStartTime = now ; IcoStarted ( icoStartTime ) ; }
function makeOffer ( address _maker , address _offerAsset , address _wantAsset , uint256 _offerAmount , uint256 _wantAmount , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { require ( _offerAmount > 0 && _wantAmount > 0 , "Invalid amounts" ) ; require ( _offerAsset != _wantAsset , "Invalid assets" ) ; bytes32 offerHash = keccak256 ( abi . encodePacked ( "makeOffer" , _maker , _offerAsset , _wantAsset , _offerAmount , _wantAmount , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( offerHash , _v , _r , _s ) == _maker , "Invalid signature" ) ; _validateAndAddHash ( offerHash ) ; _decreaseBalanceAndPayFees ( _maker , _offerAsset , _offerAmount , _feeAsset , _feeAmount , ReasonMakerGive , ReasonMakerFeeGive , ReasonMakerFeeReceive ) ; Offer storage offer = offers [ offerHash ] ; offer . maker = _maker ; offer . offerAsset = _offerAsset ; offer . wantAsset = _wantAsset ; offer . offerAmount = _offerAmount ; offer . wantAmount = _wantAmount ; offer . availableAmount = _offerAmount ; offer . nonce = _nonce ; emit Make ( _maker , offerHash ) ; }
function isTokenEscapable ( address _token ) constant public returns ( bool ) { return ! escapeBlacklist [ _token ] ; }
function burn ( uint256 _value ) public { require ( ! freezeTransfer || isOps ( ) , "all transfers are currently frozen" ) ; require ( _value <= balances [ msg . sender ] , "address has not enough token to burn" ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; emit Burn ( burner , _value ) ; emit Transfer ( burner , address ( 0 ) , _value ) ; }
function getApproved ( uint256 _tokenId ) external view returns ( address ) { return tokenApprovals [ _tokenId ] ; }
function transferItem ( address _from , address _to , uint256 _itemID ) internal ifItemForSaleThenCancelSale ( _itemID ) { Item storage item = items [ _itemID ] ; if ( item . onChamp && _to != champToOwner [ item . onChampId ] ) { takeOffItem ( item . onChampId , item . itemType ) ; } addressInfo [ _to ] . itemsCount ++ ; addressInfo [ _from ] . itemsCount -- ; itemToOwner [ _itemID ] = _to ; emit TransferItem ( _from , _to , _itemID ) ; }
function extractAddress ( bytes _data , uint offset ) internal pure returns ( address m ) { require ( offset >= 0 && offset + 20 <= _data . length , "offset value should be in the correct range" ) ; assembly { m := and ( mload ( add ( _data , add ( 20 , offset ) ) ) , 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) } }
function modifyTicker ( address _owner , string _ticker , string _tokenName , uint256 _registrationDate , uint256 _expiryDate , bool _status ) external ;
function ownerWithdraw ( uint256 _value ) external onlyOwner { if ( totalFunding < PRESALE_MINIMUM_FUNDING ) revert ( ) ; if ( ! owner . send ( _value ) ) revert ( ) ; }
function getCodeToken ( uint256 _tokenId ) public view returns ( string codetokenName , uint256 sellingPrice , address owner ) { Code storage codetoken = codetokens [ _tokenId ] ; codetokenName = codetoken . name ; sellingPrice = codetokenIndexToPrice [ _tokenId ] ; owner = codetokenIndexToOwner [ _tokenId ] ; }
function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 2 ) ; allPermissions [ 0 ] = DISTRIBUTE ; allPermissions [ 1 ] = MANAGE ; return allPermissions ; }
function getBonusFund ( address user ) external view returns ( uint ) { return bonusFund [ user ] ; }
function getTypes ( ) external view returns ( uint8 [ ] ) ;
function _onWhitelist ( address _investor ) internal view returns ( bool ) { return ( ( ( whitelist [ _investor ] . fromTime != 0 ) || ( whitelist [ _investor ] . toTime != 0 ) ) && ( whitelist [ _investor ] . expiryTime >= now ) ) ; }
function _adjustTotalSupplyCheckpoints ( ) internal { TokenLib . adjustCheckpoints ( checkpointTotalSupply , totalSupply ( ) , currentCheckpointId ) ; }
function changeController ( address _newController ) public onlyController { msp . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
function setIcoContractAddress ( address contractAddress ) public onlyOwner { freezeBypassing [ contractAddress ] = true ; icoContractAddress = contractAddress ; }
function exchangeNominsForHavvens ( uint nominAmount ) public pricesNotStale notPaused returns ( uint ) { uint havvensToSend = havvensReceivedForNomins ( nominAmount ) ; nomin . transferFrom ( msg . sender , fundsWallet , nominAmount ) ; havven . transfer ( msg . sender , havvensToSend ) ; emit Exchange ( "nUSD" , nominAmount , "HAV" , havvensToSend ) ; return havvensToSend ; }
function getOracle ( ) public view returns ( address ) { return owners [ 1 ] ; }
function escapeHatch ( address _token ) public onlyEscapeHatchCallerOrOwner { require ( escapeBlacklist [ _token ] == false ) ; uint256 balance ; if ( _token == 0x0 ) { balance = this . balance ; escapeHatchDestination . transfer ( balance ) ; EscapeHatchCalled ( _token , balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; balance = token . balanceOf ( this ) ; require ( token . transfer ( escapeHatchDestination , balance ) ) ; EscapeHatchCalled ( _token , balance ) ; }
function calcGav ( ) returns ( uint gav ) { uint [ ] memory allAssetHoldings = new uint [ ] ( ownedAssets . length ) ; uint [ ] memory allAssetPrices = new uint [ ] ( ownedAssets . length ) ; address [ ] memory tempOwnedAssets ; tempOwnedAssets = ownedAssets ; delete ownedAssets ; for ( uint i = 0 ; i < tempOwnedAssets . length ; ++ i ) { address ofAsset = tempOwnedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( address ( this ) ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; var ( isRecent , assetPrice , assetDecimals ) = modules . pricefeed . getPriceInfo ( ofAsset ) ; if ( ! isRecent ) { revert ( ) ; } allAssetHoldings [ i ] = assetHoldings ; allAssetPrices [ i ] = assetPrice ; gav = add ( gav , mul ( assetHoldings , assetPrice ) / ( 10 ** uint256 ( assetDecimals ) ) ) ; if ( assetHoldings != 0 || ofAsset == address ( QUOTE_ASSET ) || isInOpenMakeOrder [ ofAsset ] ) { ownedAssets . push ( ofAsset ) ; } else { isInAssetList [ ofAsset ] = false ; } } emit PortfolioContent ( tempOwnedAssets , allAssetHoldings , allAssetPrices ) ; }
function transferFrom ( address from , address to , uint256 tokenAmount ) public tradable ( from ) returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokenAmount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( from , to , tokenAmount ) ; return true ; }
function exchangeEtherForSynthetix ( ) public payable pricesNotStale notPaused returns ( uint ) { uint synthetixToSend = synthetixReceivedForEther ( msg . value ) ; fundsWallet . transfer ( msg . value ) ; synthetix . transfer ( msg . sender , synthetixToSend ) ; emit Exchange ( "ETH" , msg . value , "SNX" , synthetixToSend ) ; return synthetixToSend ; }
function capReached ( ) public view returns ( bool ) { return tokensSold >= cap ; }
function getExtraPoints ( uint96 extras , Extras extraStats ) private pure returns ( uint16 extraPoints ) { uint16 interceptions = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 missedFieldGoals = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 overtimes = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 sacks = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 fieldGoals = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 fumbles = uint16 ( extras & EXTRA_STATS_MASK ) ; if ( interceptions == extraStats . interceptions ) { extraPoints += 6 ; } if ( missedFieldGoals == extraStats . missedFieldGoals ) { extraPoints += 6 ; } if ( overtimes == extraStats . overtimes ) { extraPoints += 6 ; } if ( sacks == extraStats . sacks ) { extraPoints += 6 ; } if ( fieldGoals == extraStats . fieldGoals ) { extraPoints += 6 ; } if ( fumbles == extraStats . fumbles ) { extraPoints += 6 ; } }
function enableERC20 ( ) public onlyOwner { mErc20compatible = true ; setInterfaceImplementation ( "ERC20Token" , this ) ; }
function createGame ( bytes32 _userEndHash , uint _previousGameId , uint _createBefore , bytes32 _serverEndHash , bytes _serverSig ) public payable onlyValidValue onlyValidHouseStake ( activeGames + 1 ) onlyNotPaused { uint previousGameId = userGameId [ msg . sender ] ; Game storage game = gameIdGame [ previousGameId ] ; require ( game . status == GameStatus . ENDED , "prev game not ended" ) ; require ( previousGameId == _previousGameId , "inv gamePrevGameId" ) ; require ( block . timestamp < _createBefore , "expired" ) ; verifyCreateSig ( msg . sender , _previousGameId , _createBefore , _serverEndHash , _serverSig ) ; uint gameId = gameIdCntr ++ ; userGameId [ msg . sender ] = gameId ; Game storage newGame = gameIdGame [ gameId ] ; newGame . stake = uint128 ( msg . value ) ; newGame . status = GameStatus . ACTIVE ; activeGames = activeGames . add ( 1 ) ; emit LogGameCreated ( msg . sender , gameId , uint128 ( msg . value ) , _serverEndHash , _userEndHash ) ; }
function productInfo ( uint256 _productId ) public view returns ( uint256 , uint256 , uint256 , uint256 , bool ) { return ( priceOf ( _productId ) , availableInventoryOf ( _productId ) , totalSupplyOf ( _productId ) , intervalOf ( _productId ) , renewableOf ( _productId ) ) ; }
function _callERC165SupportsInterface ( address account , bytes4 interfaceId ) private view returns ( bool success , bool result ) { bytes memory encodedParams = abi . encodeWithSelector ( _InterfaceId_ERC165 , interfaceId ) ; assembly { let encodedParams_data := add ( 0x20 , encodedParams ) let encodedParams_size := mload ( encodedParams ) let output := mload ( 0x40 ) mstore ( output , 0x0 ) success := staticcall ( 30000 , account , encodedParams_data , encodedParams_size , output , 0x20 ) result := mload ( output ) } }
function transferVoteController ( address _voteController ) public onlyCurator { voteController = _voteController ; logger . emitGenericLog ( "transferVoteController" , "" ) ; }
function moveTokensToEscrowLockupForUser ( address _sender , uint256 _amount ) private { token . safeTransferFrom ( _sender , this , _amount ) ; addToEscrow ( _sender , _amount ) ; }
function setLocation ( uint index , uint _location ) onlyOwner public { require ( index < locations . length ) ; locations [ index ] = _location ; }
function getMovie ( uint256 _tokenId ) public view returns ( string movieName , uint256 sellingPrice , address owner ) { Movie storage movie = movies [ _tokenId ] ; movieName = movie . name ; sellingPrice = movieIndexToPrice [ _tokenId ] ; owner = movieIndexToOwner [ _tokenId ] ; }
function createPromoSeedAuction ( uint8 _teamId , uint8 _posId , uint256 _attributes , uint256 _playerOverrideId , uint256 _mlbPlayerId , uint256 _startPrice , uint256 _endPrice , uint256 _saleDuration ) public onlyGameManager whenNotPaused { require ( nonFungibleContract != address ( 0 ) ) ; require ( _teamId != 0 ) ; uint256 nftId = nonFungibleContract . createPromoCollectible ( _teamId , _posId , _attributes , address ( this ) , 0 , _playerOverrideId , _mlbPlayerId ) ; uint256 startPrice = 0 ; uint256 endPrice = 0 ; uint256 duration = 0 ; if ( _startPrice == 0 ) { startPrice = _computeNextSeedPrice ( 0 , _teamId ) ; } else { startPrice = _startPrice ; } if ( _endPrice != 0 ) { endPrice = _endPrice ; } else { endPrice = 0 ; } if ( _saleDuration == 0 ) { duration = SALES_DURATION ; } else { duration = _saleDuration ; } _createSale ( nftId , startPrice , endPrice , duration , address ( this ) ) ; }
function _mint ( address _to , uint256 _tokenId ) internal { super . _mint ( _to , _tokenId ) ; uint256 length = tokens . push ( _tokenId ) ; idToIndex [ _tokenId ] = length - 1 ; }
function calculateFees ( uint amount ) public view returns ( uint fees ) { return lib . calculateFees ( address ( this ) , amount ) ; }
function withdraw ( ) returns ( uint8 ) ;
function getCurrencyDenominated ( ) external view returns ( bytes32 ) { return bytes32 ( "USD" ) ; }
function getPizza ( uint256 _tokenId ) public view returns ( string pizzaName , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Pizza storage pizza = pizzas [ _tokenId ] ; pizzaName = pizza . name ; sellingPrice = pizzaIndexToPrice [ _tokenId ] ; owner = pizzaIndexToOwner [ _tokenId ] ; previousPrice = pizzaIndexToPreviousPrice [ _tokenId ] ; previousOwners = pizzaIndexToPreviousOwners [ _tokenId ] ; }
function convert ( address fromAsset , address toAsset , uint amount ) public notDeprecated returns ( bool success ) { string memory currency = getAssetCurrency ( fromAsset ) ; uint fromDecimals = ERC20Interface ( fromAsset ) . decimals ( ) ; uint toDecimals = ERC20Interface ( toAsset ) . decimals ( ) ; require ( isAllowedAsset ( fromAsset , currency ) , 'Error: Unsupported asset requested. Asset must be supported by this contract and have a currency of `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK` .' ) ; require ( isAllowedAsset ( toAsset , currency ) , 'Error: Unsupported asset requested. Asset must be supported by this contract and have a currency of `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK` .' ) ; if ( isTokenXContract ( toAsset , currency ) ) { require ( ERC20Interface ( fromAsset ) . transferFrom ( msg . sender , address ( this ) , amount ) , 'Error: Unable to transferFrom your asset holdings. Please ensure this contract has an approved allowance equal to or greater than the amount called in transferFrom method.' ) ; uint netAmountFrom = amount . sub ( calcAssetFees ( fromAsset , amount ) ) ; uint convertedAmountFrom = ( netAmountFrom . mul ( 10 ** toDecimals ) ) . div ( 10 ** fromDecimals ) ; require ( lib . deposit ( lib . getTokenSymbol ( toAsset ) , msg . sender , convertedAmountFrom , 'Token, Inc.' ) , "Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered" ) ; } else if ( isTokenXContract ( fromAsset , currency ) ) { uint convertedAmount = ( amount . mul ( 10 ** toDecimals ) ) . div ( 10 ** fromDecimals ) ; uint fees = calcAssetFees ( toAsset , convertedAmount ) ; uint netAmountTo = convertedAmount . sub ( fees ) ; require ( ERC20Interface ( toAsset ) . transfer ( msg . sender , netAmountTo ) , 'Unable to call the requested erc20 contract.' ) ; require ( lib . withdraw ( lib . getTokenSymbol ( fromAsset ) , msg . sender , amount , 'Token, Inc.' ) , "Error: Unable to withdraw funds. Please check issuerFirm and firm authority are registered and have issued funds that can be withdrawn" ) ; } else { revert ( 'Error: At least one asset must be issued by Token, Inc. (Token X).' ) ; } emit StableSwap ( fromAsset , toAsset , msg . sender , amount , currency ) ; return true ; }
function execute ( address seller , uint256 quantity , uint256 price ) public payable { require ( enforceKyc == false || ( isAllowedTrade ( msg . sender ) && isAllowedTrade ( seller ) ) , "Buyer and Seller must be approved to trade on this exchange." ) ; TradeOrder memory order = orderBook [ seller ] ; require ( order . price == price , "Buy price does not match the listed sell price." ) ; require ( block . timestamp < order . expiry , "Sell order has expired." ) ; require ( price >= sellFloor , "The bid is below the minimum allowed." ) ; require ( sellCeiling == 0 || price <= sellCeiling , "The bid is above the maximum allowed." ) ; uint256 tradeQuantity = order . quantity > quantity ? quantity : order . quantity ; order . quantity = order . quantity . sub ( tradeQuantity ) ; if ( order . quantity == 0 ) { order . price = 0 ; order . expiry = 0 ; } orderBook [ seller ] = order ; uint256 cost = tradeQuantity . wmul ( order . price ) ; require ( msg . value >= cost , "You did not send enough Ether to purchase the tokens." ) ; uint256 etherFee = calculateFee ( cost ) ; if ( ! ERC20Interface ( tokenContract ) . transferFrom ( seller , msg . sender , tradeQuantity ) ) { revert ( "Unable to transfer tokens from seller to buyer." ) ; } seller . transfer ( cost . sub ( etherFee ) ) ; if ( etherFee > 0 ) owner . transfer ( etherFee ) ; lastSellPrice = price ; emit TokensPurchased ( msg . sender , seller , tradeQuantity , price ) ; }
function changeGranularity ( uint256 _granularity ) public onlyOwner { require ( _granularity != 0 , "Granularity can not be 0" ) ; emit LogGranularityChanged ( granularity , _granularity ) ; granularity = _granularity ; }
function setIssuanceRatio ( uint _issuanceRatio ) external onlyOwner { require ( _issuanceRatio <= MAX_ISSUANCE_RATIO , "New issuance ratio cannot exceed MAX_ISSUANCE_RATIO" ) ; issuanceRatio = _issuanceRatio ; emit IssuanceRatioUpdated ( _issuanceRatio ) ; }
function requestCeilingRaise ( uint256 _raiseBy ) public returns ( bytes32 lockId ) { require ( _raiseBy != 0 ) ; lockId = generateLockId ( ) ; pendingRaiseMap [ lockId ] = PendingCeilingRaise ( { raiseBy : _raiseBy } ) ; emit CeilingRaiseLocked ( lockId , _raiseBy ) ; }
function isSenderApprovedFor ( uint256 _tokenId ) internal view returns ( bool ) { return ownerOf ( _tokenId ) == msg . sender || isSpecificallyApprovedFor ( msg . sender , _tokenId ) || isApprovedForAll ( ownerOf ( _tokenId ) , msg . sender ) ; }
function distributePresaleTokens ( address _buyer , uint tokens ) external onlyOwner whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 && tokens <= 10e24 ) ; require ( tokensDistributedPresale < 10e24 ) ; tokensDistributedPresale = tokensDistributedPresale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
function deleteTx ( bytes32 _key ) external onlyContractOwner returns ( uint ) { require ( _key != bytes32 ( 0 ) ) ; if ( ! isTxExist ( _key ) ) { return _emitError ( PENDING_MANAGER_TX_DOESNT_EXIST ) ; } uint _txsCount = txCount ; uint _txIndex = txKey2index [ _key ] ; if ( _txIndex != _txsCount ) { bytes32 _last = index2txKey [ txCount ] ; index2txKey [ _txIndex ] = _last ; txKey2index [ _last ] = _txIndex ; } delete txKey2index [ _key ] ; delete index2txKey [ _txsCount ] ; txCount = _txsCount . sub ( 1 ) ; uint _basePolicyIndex = txKey2guard [ _key ] . basePolicyIndex ; Policy storage _policy = policyId2policy [ index2PolicyId [ _basePolicyIndex ] ] ; uint _counter = _policy . securesCount ; uint _policyTxIndex = _policy . txIndex2index [ _txIndex ] ; if ( _policyTxIndex != _counter ) { uint _movedTxIndex = _policy . index2txIndex [ _counter ] ; _policy . index2txIndex [ _policyTxIndex ] = _movedTxIndex ; _policy . txIndex2index [ _movedTxIndex ] = _policyTxIndex ; } delete _policy . index2txIndex [ _counter ] ; delete _policy . txIndex2index [ _txIndex ] ; _policy . securesCount = _counter . sub ( 1 ) ; TxDeleted ( _key ) ; return OK ; }
function destroyTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , block . number ) ; if ( curTotalSupply < _amount ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; var previousBalanceFrom = balanceOf ( _owner ) ; if ( previousBalanceFrom < _amount ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }
function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( currentTokenPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount / currentTokenPrice ; uint256 detractSell = revenue / commRate ; require ( this . balance >= revenue ) ; msg . sender . transfer ( revenue - detractSell ) ; }
function revokeAttribute ( address account ) external whenNotPaused { require ( account != address ( 0 ) , "must supply a valid account address" ) ; require ( _organizations [ msg . sender ] . exists == true , "only organizations may revoke attributes" ) ; require ( _organizations [ msg . sender ] . issuedAccounts [ account ] && _organizations [ msg . sender ] . accounts . length > 0 , "the organization is not permitted to revoke an unissued attribute" ) ; _jurisdiction . revokeAttribute ( account , _validAttributeTypeID ) ; require ( _registry . hasAttribute ( account , _validAttributeTypeID ) == false , "attribute revocation was not accepted by the jurisdiction" ) ; uint256 lastIndex = _organizations [ msg . sender ] . accounts . length - 1 ; address lastAccount = _organizations [ msg . sender ] . accounts [ lastIndex ] ; uint256 indexToDelete = _organizations [ msg . sender ] . issuedAccountsIndex [ account ] ; _organizations [ msg . sender ] . accounts [ indexToDelete ] = lastAccount ; _organizations [ msg . sender ] . issuedAccountsIndex [ lastAccount ] = indexToDelete ; _organizations [ msg . sender ] . accounts . length -- ; delete _organizations [ msg . sender ] . issuedAccounts [ account ] ; emit AttributeRevoked ( msg . sender , account ) ; }
function revokeAttribute ( address account , uint256 attributeTypeID ) external whenNotPaused { require ( _issuedAttributes [ account ] [ attributeTypeID ] . exists , "only existing attributes may be removed" ) ; address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; require ( msg . sender == validator || msg . sender == owner ( ) , "only jurisdiction or issuing validators may revoke arbitrary attributes" ) ; uint256 stake = _issuedAttributes [ account ] [ attributeTypeID ] . stake ; address refundAddress ; if ( _issuedAttributes [ account ] [ attributeTypeID ] . setPersonally ) { refundAddress = account ; } else { address operator = _issuedAttributes [ account ] [ attributeTypeID ] . operator ; if ( operator == address ( 0 ) ) { refundAddress = validator ; } else { refundAddress = operator ; } } delete _issuedAttributes [ account ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , account , attributeTypeID ) ; if ( stake > 0 && address ( this ) . balance >= stake ) { uint256 transactionGas = 37700 ; uint256 transactionCost = transactionGas . mul ( tx . gasprice ) ; if ( stake > transactionCost ) { if ( refundAddress . send ( stake . sub ( transactionCost ) ) ) { emit StakeRefunded ( refundAddress , attributeTypeID , stake . sub ( transactionCost ) ) ; } if ( tx . origin . send ( transactionCost ) ) { emit TransactionRebatePaid ( tx . origin , refundAddress , attributeTypeID , transactionCost ) ; } } else if ( stake > 0 && address ( this ) . balance >= stake ) { if ( tx . origin . send ( stake ) ) { emit TransactionRebatePaid ( tx . origin , refundAddress , attributeTypeID , stake ) ; } } } }
function getAmountToGive ( OrderData data ) public view onlySelf returns ( uint256 amountToGive ) { uint256 availableVolume = exchange . availableVolume ( data . tokenGet , data . amountGet , data . tokenGive , data . amountGive , data . expires , data . nonce , data . user , data . v , data . r , data . s ) ; amountToGive = getPartialAmount ( availableVolume , SafeMath . sub ( 1 ether , data . exchangeFee ) , 1 ether ) ; }
function deposit ( ) payable isOwner { require ( msg . value > 0 ) ; require ( msg . sender . balance >= msg . value ) ; deposited ( msg . sender , msg . value , "wei deposited" ) ; }
function approveAndCall ( address spender , uint256 value , bytes extraData ) returns ( bool success ) { tokenRecipient recSpender = tokenRecipient ( spender ) ; if ( approve ( spender , value ) ) { recSpender . receiveApproval ( msg . sender , value , this , extraData ) ; return true ; } }
function checkRelease ( ERC20 token ) public { uint num = 0 ; for ( uint i = 0 ; i < _amount . length ; i ++ ) { num = num . add ( _amount [ i ] ) ; } if ( num == 0 ) { token . transfer ( _beneficiary [ 0 ] , token . balanceOf ( this ) ) ; } }
function release ( ERC20Basic token ) public { uint256 unreleased = releasableAmount ( token ) ; require ( unreleased > 0 , "Unreleased amount should be larger than 0." ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . safeTransfer ( beneficiary , unreleased ) ; emit Released ( token , unreleased ) ; }
function batchRefundChannel ( bytes32 [ ] channelIds ) public { require ( channelIds . length <= MAX_BATCH_ITERATIONS , "TOO_MANY_CHANNELS" ) ; for ( uint i = 0 ; i < channelIds . length ; ++ i ) refundChannel ( channelIds [ i ] ) ; }
function setSaleAuctionAddress ( address _address ) external onlyCEO { SaleClockAuction candidateContract = SaleClockAuction ( _address ) ; require ( candidateContract . isSaleClockAuction ( ) ) ; saleAuction = candidateContract ; }
function burnTokens ( uint _value ) public notZero ( _value ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = SafeMath . sub ( balances [ msg . sender ] , _value ) ; feeInCirculation = SafeMath . sub ( feeInCirculation , _value ) ; Burn ( msg . sender , _value ) ; }
function revokeManualBlocking ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , "Invalid from address" ) ; require ( _to != address ( 0 ) , "Invalid to address" ) ; delete manualBlockings [ _from ] [ _to ] ; emit RevokeManualBlocking ( _from , _to , msg . sender ) ; }
function changeOwnership ( bytes32 _symbol , address _newOwner ) public onlyOwner ( _symbol ) returns ( uint ) { if ( _newOwner == 0x0 ) { return _error ( ATX_PLATFORM_INVALID_NEW_OWNER ) ; } Asset storage asset = assets [ _symbol ] ; uint newOwnerId = _createHolderId ( _newOwner ) ; if ( asset . owner == newOwnerId ) { return _error ( ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } address oldOwner = _address ( asset . owner ) ; asset . owner = newOwnerId ; Emitter ( eventsHistory ) . emitOwnershipChange ( oldOwner , _newOwner , _symbol ) ; return OK ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { }
function burnWithData ( uint256 _value , bytes _data ) external ;
function issuanceIsPaused ( ) public view returns ( bool ) { return _issuancePaused ; }
function distributeFixed ( uint index , address [ ] _addrs , uint _amoutToEach ) public onlyOwner { if ( timeGone ( index ) == true && getTokensBalance ( index ) >= airdrop . tokenAmount ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _amoutToEach ) ; } } else revert ( "Airdrop was NOT added" ) ; }
function isSecurityToken ( address _securityToken ) external view returns ( bool ) ;
function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
function initialMint ( uint256 _cap ) internal { uint256 halfCap = _cap . div ( 2 ) ; token . mint ( this , halfCap ) ; token . mint ( beneficiary , _cap . sub ( halfCap ) ) ; }
function submitAnswerCommitment ( bytes32 question_id , bytes32 answer_hash , uint256 max_previous , address _answerer ) stateOpen ( question_id ) bondMustDouble ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external payable { bytes32 commitment_id = keccak256 ( question_id , answer_hash , msg . value ) ; address answerer = ( _answerer == NULL_ADDRESS ) ? msg . sender : _answerer ; require ( commitments [ commitment_id ] . reveal_ts == COMMITMENT_NON_EXISTENT ) ; uint32 commitment_timeout = questions [ question_id ] . timeout / COMMITMENT_TIMEOUT_RATIO ; commitments [ commitment_id ] . reveal_ts = uint32 ( now ) . add ( commitment_timeout ) ; _addAnswerToHistory ( question_id , commitment_id , answerer , msg . value , true ) ; }
function stopThisIco ( bool icoIsStopped ) isOwner { require ( icoIsClosed != icoIsStopped ) ; icoIsClosed = icoIsStopped ; if ( icoIsStopped ) { icoStatusUpdated ( msg . sender , "Coin offering was stopped!" ) ; } else { icoStatusUpdated ( msg . sender , "Coin offering is running!" ) ; } }
function setTokenFrozenBalance ( Data storage self , string currency , address account , uint amount ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.frozen' , currency , getForwardedAccount ( self , account ) ) ) ; require ( self . Storage . setUint ( id , amount ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function decrementTotalIssuerCount ( ) external onlyAssociatedContract { totalIssuerCount = totalIssuerCount . sub ( 1 ) ; }
function updateRenExSettlementContract ( RenExSettlement _newSettlementContract ) external onlyOwner { emit LogRenExSettlementContractUpdated ( settlementContract , _newSettlementContract ) ; settlementContract = _newSettlementContract ; }
function getRichToken ( uint256 _tokenId ) public view returns ( string richtokenName , uint256 sellingPrice , address owner ) { Rich storage richtoken = richtokens [ _tokenId ] ; richtokenName = richtoken . name ; sellingPrice = richtokenIndexToPrice [ _tokenId ] ; owner = richtokenIndexToOwner [ _tokenId ] ; }
function getColor ( uint256 _tokenId ) public view returns ( uint256 R , uint256 G , uint256 B , string colorName , uint256 sellingPrice , address owner ) { Color storage col = colors [ _tokenId ] ; R = col . R ; G = col . G ; B = col . B ; colorName = col . name ; sellingPrice = colorIndexToPrice [ _tokenId ] ; owner = colorIndexToOwner [ _tokenId ] ; }
function approve ( address _spender , uint256 _value ) public ;
function createDividend ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount ) public onlyOwner { require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( _token != address ( 0 ) ) ; require ( _amount > 0 ) ; require ( ERC20 ( _token ) . transferFrom ( msg . sender , address ( this ) , _amount ) , "Unable to transfer tokens for dividend" ) ; uint256 dividendIndex = dividends . length ; uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupply ( ) ; dividends . push ( Dividend ( checkpointId , now , _maturity , _expiry , _token , _amount , 0 , currentSupply , false ) ) ; emit ERC20DividendDeposited ( msg . sender , checkpointId , now , _maturity , _expiry , _token , _amount , currentSupply , dividendIndex ) ; }
function votingEndsInHHMM ( ) constant returns ( uint8 , uint8 ) { var tsec = VOTING_END_TIME - now ; return VOTING_END_TIME == 0 ? ( 0 , 0 ) : ( uint8 ( tsec / 1 hours ) , uint8 ( tsec % 1 hours / 1 minutes ) ) ; }
function configure ( uint256 _startTime , uint256 _endTime , uint256 _cap , uint256 _rate , FundRaiseType [ ] _fundRaiseTypes , address _fundsReceiver ) public onlyFactory { require ( _rate > 0 , "Rate of token should be greater than 0" ) ; require ( _fundsReceiver != address ( 0 ) , "Zero address is not permitted" ) ; require ( _startTime >= now && _endTime > _startTime , "Date parameters are not valid" ) ; require ( _cap > 0 , "Cap should be greater than 0" ) ; require ( _fundRaiseTypes . length == 1 , "It only selects single fund raise type" ) ; startTime = _startTime ; endTime = _endTime ; cap = _cap ; rate = _rate ; wallet = _fundsReceiver ; _setFundRaiseType ( _fundRaiseTypes ) ; }
function transferToAddress ( address to , uint256 value , bytes data ) public returns ( bool _success ) { require ( to != address ( 0 ) ) ; require ( value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; Transfer ( msg . sender , to , value , data ) ; return true ; }
function getApproved ( uint256 _tokenId ) external view canBeStoredIn40Bits ( _tokenId ) returns ( address ) { require ( _tokenId <= _totalSupply ( ) ) ; if ( cutieIndexToApproved [ uint40 ( _tokenId ) ] != address ( 0 ) ) { return cutieIndexToApproved [ uint40 ( _tokenId ) ] ; } address owner = cutieIndexToOwner [ uint40 ( _tokenId ) ] ; return addressToApprovedAll [ owner ] ; }
function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] [ lastTokenIndex ] = 0 ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ _tokenId ] = 0 ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; }
function claimEther ( ) public onlyOwner { require ( tokensSold >= minCap ) ; owner . transfer ( this . balance ) ; }
function addDataResponse ( address seller , address notary , string dataHash ) public onlyOwner validAddress ( seller ) validAddress ( notary ) returns ( bool ) { require ( orderStatus == OrderStatus . NotaryAdded ) ; require ( transactionCompletedAt == 0 ) ; require ( ! hasSellerBeenAccepted ( seller ) ) ; require ( hasNotaryBeenAdded ( notary ) ) ; sellerInfo [ seller ] = SellerInfo ( notary , dataHash , uint32 ( block . timestamp ) , 0 , DataResponseStatus . DataResponseAdded ) ; sellers . push ( seller ) ; return true ; }
function requestCosign ( Engine engine , uint256 index , bytes data , bytes oracleData ) public returns ( bool ) { Mortgage storage mortgage = mortgages [ uint256 ( readBytes32 ( data , 0 ) ) ] ; require ( mortgage . engine == engine , "Engine does not match" ) ; require ( mortgage . loanId == index , "Loan id does not match" ) ; require ( mortgage . status == Status . Pending , "Mortgage is not pending" ) ; mortgage . status = Status . Ongoing ; _generate ( uint256 ( readBytes32 ( data , 0 ) ) , mortgage . owner ) ; uint256 loanAmount = convertRate ( engine . getOracle ( index ) , engine . getCurrency ( index ) , oracleData , engine . getAmount ( index ) ) ; require ( rcn . transferFrom ( mortgage . owner , this , loanAmount ) , "Error pulling RCN from borrower" ) ; uint256 boughtMana = convertSafe ( mortgage . tokenConverter , rcn , mana , loanAmount ) ; delete mortgage . tokenConverter ; uint256 currentLandCost ; ( , , currentLandCost , ) = landMarket . auctionByAssetId ( mortgage . landId ) ; require ( currentLandCost <= mortgage . landCost , "Parcel is more expensive than expected" ) ; require ( mana . approve ( landMarket , currentLandCost ) ) ; flagReceiveLand = mortgage . landId ; landMarket . executeOrder ( mortgage . landId , currentLandCost ) ; require ( mana . approve ( landMarket , 0 ) ) ; require ( flagReceiveLand == 0 , "ERC721 callback not called" ) ; require ( land . ownerOf ( mortgage . landId ) == address ( this ) , "Error buying parcel" ) ; uint256 totalMana = boughtMana . add ( mortgage . deposit ) ; require ( mana . transfer ( mortgage . owner , totalMana . sub ( currentLandCost ) ) , "Error returning MANA" ) ; require ( mortgage . engine . cosign ( index , 0 ) , "Error performing cosign" ) ; mortgageByLandId [ mortgage . landId ] = uint256 ( readBytes32 ( data , 0 ) ) ; emit StartedMortgage ( uint256 ( readBytes32 ( data , 0 ) ) ) ; return true ; }
function removeBlacklistDestroyer ( address _who ) public onlyValidator { require ( isPermission ( DESTROY_BLACKLISTED_TOKENS_SIG ) , "Blacklist token destruction not supported by token" ) ; removeUserPermission ( _who , DESTROY_BLACKLISTED_TOKENS_SIG ) ; emit LogRemovedBlacklistDestroyer ( _who ) ; }
function ( ) payable public { owner . transfer ( msg . value ) ; }
function collectionTotal ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( uint256 ) { require ( _collectionIndex < totalCollections ( ) , "Collection does not exist" ) ; return collectionTokens [ _collectionIndex ] . length ; }
function getHolderId ( address _holder ) public view returns ( uint ) { return holderIndex [ _holder ] ; }
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function setAdsStorageAddress ( address _addrStorage ) external onlyOwnerOrAllowed { reset ( ) ; advStorageContract = _addrStorage ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { uint256 c = a / b ; return c ; }
function claimTokens ( token _address , address _to ) onlyAdmin ( 2 ) public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( address ( this ) ) ; _address . transfer ( _to , remainder ) ; }
function getValidators ( ) external view returns ( address [ ] ) { return _validatorAccounts ; }
function createCheckpoint ( ) external returns ( uint256 ) ;
function resumeContribution ( ) public onlyOwner { paused = false ; }
function distributePreICOTokens ( address [ ] beneficiaries , uint256 [ ] amounts ) onlyOwner public { require ( beneficiaries . length == amounts . length ) ; for ( uint256 i = 0 ; i < beneficiaries . length ; i ++ ) { mintTokens ( beneficiaries [ i ] , amounts [ i ] ) ; } }
function changeController ( address _newController ) public onlyOwner { snt . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
function getValidatorInformation ( address validator ) external view returns ( string description ) ;
function sumOf ( uint256 [ ] _values ) private pure returns ( uint256 ) { uint256 total = 0 ; for ( uint256 i = 0 ; i < _values . length ; i ++ ) { total = total . add ( _values [ i ] ) ; } return total ; }
function transferFrom ( address _from , address _to , uint256 _amount ) public whenNotPaused erc20 returns ( bool success ) { uint balanceAvailable = getAmountOfUnlockedTokens ( _from ) ; require ( balanceAvailable >= _amount , "You can only use transferFrom when you specify an amount of tokens >= the '_from' address's amount of unlocked tokens" ) ; require ( _amount <= mAllowed [ _from ] [ msg . sender ] , "You can only use transferFrom with an amount less than or equal to the current 'mAllowed' allowance." ) ; mAllowed [ _from ] [ msg . sender ] = mAllowed [ _from ] [ msg . sender ] . sub ( _amount ) ; doSend ( _from , _to , _amount , "" , msg . sender , "" , false ) ; return true ; }
function withdraw ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . withdraw ( currency , account , amount , issuerFirm ) , "Error: Unable to withdraw funds. Please check issuerFirm and firm authority are registered and have issued funds that can be withdrawn" ) ; return true ; }
function setGameStartedDividendPercentage ( uint256 _gameStarterDividendPercentage ) external onlyCFO { require ( 500 <= _gameStarterDividendPercentage && _gameStarterDividendPercentage <= 4000 ) ; gameStarterDividendPercentage = _gameStarterDividendPercentage ; }
function updateDelegate ( uint64 idDelegate , address newAddr , string newName , string newUrl , uint64 newCommitTime ) { PledgeAdmin storage delegate = findAdmin ( idDelegate ) ; require ( delegate . adminType == PledgeAdminType . Delegate ) ; require ( delegate . addr == msg . sender ) ; delegate . addr = newAddr ; delegate . name = newName ; delegate . url = newUrl ; delegate . commitTime = newCommitTime ; DelegateUpdated ( idDelegate ) ; }
function ownerOf ( uint256 _tokenId ) public view returns ( address ) { address _owner = tokenOwnerAndTokensIndex [ _tokenId ] . owner ; require ( _owner != address ( 0 ) , "invalid owner" ) ; return _owner ; }
function getCEOHashing ( address _newCEO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F3E ) , _newCEO , _nonce ) ) ; }
function balanceOf ( address owner ) public constant returns ( uint256 _balance ) { require ( owner != address ( 0 ) ) ; return balances [ owner ] ; }
function getPickedAssetsAndFinalSeed ( bytes32 [ ] _potentialAssets , uint [ ] _randomHashIds , uint _timestamp , uint _iterations ) internal view returns ( uint [ ] , uint ) { uint finalSeed = uint ( functions . getFinalSeed ( functions . calculateSeed ( _randomHashIds , _timestamp ) , _iterations ) ) ; require ( ! seedExists [ finalSeed ] ) ; return ( functions . pickRandomAssets ( finalSeed , _potentialAssets ) , finalSeed ) ; }
function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F01 ) , _newCFO , _nonce ) ) ; }
function purchaseTokens ( ) saleStarted payable setupComplete notInEmergency { uint excessAmount = msg . value % price ; uint purchaseAmount = msg . value - excessAmount ; uint tokenPurchase = purchaseAmount / price ; require ( tokenPurchase <= token . balanceOf ( this ) ) ; if ( excessAmount > 0 ) { msg . sender . transfer ( excessAmount ) ; } wallet . transfer ( purchaseAmount ) ; assert ( token . transfer ( msg . sender , tokenPurchase ) ) ; PurchasedTokens ( msg . sender , tokenPurchase ) ; }
function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; return doTransfer ( msg . sender , _to , _amount ) ; }
function _chkBuyerLmtsAndFinl ( address buyer , uint amountTkns , uint priceOfr ) internal returns ( bool success ) { success = false ; bool sucs1 = false ; sucs1 = _chkBuyerLmts ( buyer , amountTkns ) ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool sucs2 = false ; if ( buyer . balance >= safeAdd ( safeMul ( amountTkns , priceOfr ) , ico . getMinBal ( ) ) ) sucs2 = true ; if ( sucs1 == true && sucs2 == true ) success = true ; return success ; }
function create ( uint256 baseUnits ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ + baseUnits ) > totalSupply_ ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; uint256 amount = baseUnits . div ( creationQuantity_ ) . mul ( tokenInfo . tokenUnits ) ; require ( erc20 . transferFrom ( msg . sender , address ( this ) , amount ) ) ; } mint ( msg . sender , baseUnits ) ; }
function remainingCap ( ) private returns ( uint256 ) { return preSaleCap . sub ( preSaleEtherPaid ) ; }
function topUp ( address _receiver_address , uint32 _open_block_number , uint192 _added_deposit ) external { updateInternalBalanceStructs ( msg . sender , _receiver_address , _open_block_number , _added_deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _added_deposit ) ) ; }
function countOfDeedsByOwner ( address _owner ) external view returns ( uint256 _count ) ;
function increaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xa45f71ff ) , _token , _spender , _addedValue , _fee , _nonce ) ) ; }
function setPlatformFeePer10000 ( uint newFee ) external only ( owner ) { require ( newFee <= 10000 ) ; PLATFORM_FEE_PER_10000 = newFee ; }
function calculateReward ( uint256 rewardAmount , uint256 blocksSinceLastWrite ) public view returns ( uint256 ) { uint256 totalReward = rewardAmount ; uint256 blockThreshold = settings . blockThreshold ( ) ; if ( blocksSinceLastWrite > 0 && blocksSinceLastWrite < blockThreshold ) { uint256 multiplier = 10 ** uint256 ( token . decimals ( ) ) ; totalReward = rewardAmount . mul ( blocksSinceLastWrite . mul ( multiplier ) ) . div ( blockThreshold . mul ( multiplier ) ) ; } return totalReward ; }
function setDolRate ( uint256 dolInWei ) isOwner { require ( dolInWei >= 0 ) ; dolRate = dolInWei ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = stateIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function setOracle ( address _oracle ) external onlyOwner { oracle = _oracle ; emit OracleUpdated ( oracle ) ; }
function createChallenge ( string name , string mentor , uint time , uint mentorFee ) external payable gameIsNotOver returns ( uint retId ) { require ( msg . value >= 0.01 ether , "Has to stake more than 0.01 ether" ) ; require ( mentorFee >= 0 ether , "Can't be negative" ) ; require ( mentorFee <= msg . value , "Can't be bigger than stake" ) ; require ( bytes ( mentor ) . length > 0 , "Has to be a mentor" ) ; require ( usernameToAddress [ mentor ] != address ( 0x0 ) , "Mentor has to be registered" ) ; require ( time > 0 , "Time has to be greater than zero" ) ; address mentorAddr = usernameToAddress [ mentor ] ; require ( msg . sender != mentorAddr , "Can't be mentor to yourself" ) ; uint startDate = block . timestamp ; uint id = challenges . push ( Challenge ( msg . sender , name , msg . value , mentorAddr , startDate , time , mentorFee , false , false ) ) - 1 ; challengeToUser [ id ] = msg . sender ; userToChallengeCount [ msg . sender ] ++ ; challengeToMentor [ id ] = mentorAddr ; mentorToChallengeCount [ mentorAddr ] ++ ; emit NewChallenge ( id , msg . sender , name , msg . value , mentorAddr , startDate , time , mentorFee ) ; return id ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _spender != address ( 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function transfer ( address _receiver , uint256 _amount ) public returns ( bool transferred ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; return true ; }
function getFinalSeed ( uint _randomSeed , uint _iterations ) public pure returns ( bytes32 ) { require ( _randomSeed != 0 ) ; require ( _iterations != 0 ) ; bytes32 finalSeed = bytes32 ( _randomSeed ) ; finalSeed = keccak256 ( abi . encodePacked ( _randomSeed , _iterations ) ) ; for ( uint i = 0 ; i < _iterations ; i ++ ) { finalSeed = keccak256 ( abi . encodePacked ( finalSeed , i ) ) ; } return finalSeed ; }
function buyTokens ( address _beneficiary ) public payable { require ( started ) ; require ( ! finished ) ; require ( _beneficiary != address ( 0 ) ) ; require ( msg . value != 0 ) ; require ( whitelist [ msg . sender ] && whitelist [ _beneficiary ] ) ; require ( fidaToken . totalSupply ( ) < 24750 * 10 ** 3 * 10 ** DECIMALS ) ; uint256 amountTokens = getAmountFida ( msg . value ) ; require ( amountTokens >= 50 * 10 ** DECIMALS ) ; if ( ! earlybirdEnded ) { _investAsEarlybird ( _beneficiary , amountTokens ) ; } else { _investAsBonusProgram ( _beneficiary , amountTokens ) ; } wallet . transfer ( msg . value ) ; }
function initiatable ( bytes32 _swapID ) external view returns ( bool ) { return ( swapStates [ _swapID ] == States . INVALID ) ; }
function emergencyWithdrawParsecs ( uint256 value ) external onlyOwnerOrMultisig { require ( value > 0 ) ; require ( value <= parsecToken . balanceOf ( this ) ) ; parsecToken . transfer ( msg . sender , value ) ; }
function transfer ( address _to , uint256 _amount ) public notLocked ( msg . sender ) returns ( bool success ) { return super . transfer ( _to , _amount ) ; }
function calcGav ( ) returns ( uint gav ) { address [ ] memory tempOwnedAssets ; tempOwnedAssets = ownedAssets ; delete ownedAssets ; for ( uint i = 0 ; i < tempOwnedAssets . length ; ++ i ) { address ofAsset = tempOwnedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; var ( isRecent , assetPrice , assetDecimals ) = module . pricefeed . getPrice ( ofAsset ) ; if ( ! isRecent ) { revert ( ) ; } gav = add ( gav , mul ( assetHoldings , assetPrice ) / ( 10 ** uint256 ( assetDecimals ) ) ) ; if ( assetHoldings != 0 || ofAsset == address ( QUOTE_ASSET ) || isInOpenMakeOrder [ ofAsset ] ) { ownedAssets . push ( ofAsset ) ; } else { isInAssetList [ ofAsset ] = false ; } PortfolioContent ( assetHoldings , assetPrice , assetDecimals ) ; } }
function getAttributeValidator ( address account , uint256 attributeTypeID ) external view returns ( address validator , bool isStillValid ) { address issuer = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; return ( issuer , canValidate ( issuer , attributeTypeID ) ) ; }
function splitSignature ( bytes sig ) internal pure returns ( uint8 , bytes32 , bytes32 ) { require ( sig . length == 65 ) ; bytes32 r ; bytes32 s ; uint8 v ; assembly { r := mload ( add ( sig , 32 ) ) s := mload ( add ( sig , 64 ) ) v := byte ( 0 , mload ( add ( sig , 96 ) ) ) } return ( v , r , s ) ; }
function announceFork ( string name , string url , uint256 blockNumber ) public only ( ROLE_PLATFORM_OPERATOR_REPRESENTATIVE ) { require ( blockNumber == 0 || blockNumber > block . number ) ; _nextForkName = name ; _nextForkUrl = url ; _nextForkBlockNumber = blockNumber ; LogForkAnnounced ( _nextForkName , _nextForkUrl , _nextForkBlockNumber ) ; }
function batchResolveAquarium ( uint256 [ ] _seeds ) onlyResolver public { for ( uint256 i = 0 ; i < _seeds . length ; i ++ ) { _resolveAquarium ( _seeds [ i ] ) ; } }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) ;
function getDefaultFee ( ) public view returns ( uint256 ) { return tokenStorage_CD . defaultFee ( ) ; }
function buyback ( uint256 _amount ) external { require ( tx . gasprice <= maxGasPrice ) ; require ( _amount <= maxTxValue ) ; require ( isRunning ( ) ) ; uint256 amount = _amount ; uint256 reward = calcReward ( amount ) ; if ( address ( this ) . balance < reward ) { reward = address ( this ) . balance ; amount = reward . mul ( rate ) ; } require ( token . transferFrom ( msg . sender , address ( this ) , amount ) ) ; msg . sender . transfer ( reward ) ; emit Buyback ( msg . sender , amount , reward ) ; }
function callWithdraw ( ) onlyOwner public { realitio . withdraw ( ) ; }
function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { return _from == address ( this ) ; }
function requestCodeUpgrade ( address _newAddress , bytes32 _sourceCodeUrl ) external validCodeUpgradeInitiator returns ( bool ) { require ( _newAddress != address ( 0x0 ) ) ; EventGatewayNewLinkRequest ( _newAddress ) ; if ( currentApplicationEntityAddress == address ( 0x0 ) ) { if ( ! ApplicationEntityABI ( _newAddress ) . initializeAssetsToThisApplication ( ) ) { revert ( ) ; } link ( _newAddress ) ; return true ; } else { currentApp . createCodeUpgradeProposal ( _newAddress , _sourceCodeUrl ) ; } }
function performCalculations ( ) view returns ( uint gav , uint managementFee , uint performanceFee , uint unclaimedFees , uint feesShareQuantity , uint nav , uint sharePrice ) { gav = calcGav ( ) ; ( managementFee , performanceFee , unclaimedFees ) = calcUnclaimedFees ( gav ) ; nav = calcNav ( gav , unclaimedFees ) ; feesShareQuantity = ( gav == 0 ) ? 0 : mul ( _totalSupply , unclaimedFees ) / gav ; uint totalSupplyAccountingForFees = add ( _totalSupply , feesShareQuantity ) ; sharePrice = _totalSupply > 0 ? calcValuePerShare ( gav , totalSupplyAccountingForFees ) : toSmallestShareUnit ( 1 ) ; }
function withdraw ( ) public whenNotPaused { _performWithdraw ( msg . sender , msg . sender ) ; }
function setSellRate ( uint256 sellRateInWei ) isOwner { require ( sellRateInWei > 0 ) ; require ( sellRate != sellRateInWei ) ; buyRate = sellRateInWei ; updatePrices ( ) ; }
function adminAddTrustedCurrencyContract ( address _newContractAddress ) external onlyOwner { trustedCurrencyContracts [ _newContractAddress ] = 1 ; emit NewTrustedContract ( _newContractAddress ) ; }
function getLockById ( uint id ) external view returns ( uint , uint , uint , uint , bytes16 , bytes32 , address ) { return ( locks [ id ] . x , locks [ id ] . y , locks [ id ] . sizeSkin , locks [ id ] . time , locks [ id ] . names , locks [ id ] . message , locks [ id ] . owner ) ; }
function getFxUSDAmount ( string currency , uint fxAmount ) public view returns ( uint usdAmount ) { return lib . getFxUSDAmount ( currency , fxAmount ) ; }
function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; require ( balancesDB . setOperator ( _operator , msg . sender , true ) ) ; emit AuthorizedOperator ( _operator , msg . sender ) ; }
function disablePurchasing ( ) onlyOwner public { require ( msg . sender == owner ) ; purchasingAllowed = false ; }
function getInitFunction ( ) public pure returns ( bytes4 ) ;
function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) ;
function goodNightSweetPrince ( ) public onlyAdmin returns ( bool ) { selfdestruct ( msg . sender ) ; return true ; }
function claimHodlRewardsFor ( address [ ] _beneficiaries ) external { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) claimHodlRewardFor ( _beneficiaries [ i ] ) ; }
function claimTokens ( address _token ) ;
function CicadaToken ( ) { balances [ msg . sender ] = totalSupply ; }
function requestPrint ( address _receiver , uint256 _value ) public returns ( bytes32 lockId ) { require ( _receiver != address ( 0 ) ) ; lockId = generateLockId ( ) ; pendingPrintMap [ lockId ] = PendingPrint ( { receiver : _receiver , value : _value } ) ; emit PrintingLocked ( lockId , _receiver , _value ) ; }
function getPlayerPotWinning ( uint256 _gameID , uint256 _pID , uint256 _team ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { if ( teams_ [ _gameID ] [ _team ] . keys > 0 ) { return gameStatus_ [ _gameID ] . winningVaultFinal . mul ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . keys ) / teams_ [ _gameID ] [ _team ] . keys ; } else { return 0 ; } }
function takeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { require ( Fund ( address ( this ) ) . owner ( ) == msg . sender ) ; require ( ! Fund ( address ( this ) ) . isShutDown ( ) ) ; Token makerAsset = Token ( orderAddresses [ 2 ] ) ; Token takerAsset = Token ( orderAddresses [ 3 ] ) ; uint maxMakerQuantity = orderValues [ 0 ] ; uint maxTakerQuantity = orderValues [ 1 ] ; uint fillTakerQuantity = orderValues [ 6 ] ; uint fillMakerQuantity = mul ( fillTakerQuantity , maxMakerQuantity ) / maxTakerQuantity ; require ( takeOrderPermitted ( fillTakerQuantity , takerAsset , fillMakerQuantity , makerAsset ) ) ; require ( takerAsset . approve ( Exchange ( targetExchange ) . TOKEN_TRANSFER_PROXY_CONTRACT ( ) , fillTakerQuantity ) ) ; uint filledAmount = executeFill ( targetExchange , orderAddresses , orderValues , fillTakerQuantity , v , r , s ) ; require ( filledAmount == fillTakerQuantity ) ; require ( Fund ( address ( this ) ) . isInAssetList ( makerAsset ) || Fund ( address ( this ) ) . getOwnedAssetsLength ( ) < Fund ( address ( this ) ) . MAX_FUND_ASSETS ( ) ) ; Fund ( address ( this ) ) . addAssetToOwnedAssets ( makerAsset ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( identifier ) , Fund . UpdateType . take , [ address ( makerAsset ) , address ( takerAsset ) ] , [ maxMakerQuantity , maxTakerQuantity , fillTakerQuantity ] ) ; }
function hasAnyAttrs ( uint256 _tokenId , bytes2 _attributes ) public view returns ( bool ) { return assets [ _tokenId ] . attributes & _attributes != 0x0 ; }
function ( ) public payable notPaused { if ( totalContributedETH >= MaxEth ) throw ; proxyPayment ( msg . sender ) ; }
function wadmin_freezeAccount ( address target , bool freeze ) onlyOwner public returns ( bool success ) { frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; return true ; }
function claimVestedTokens ( uint256 _grantId ) external { uint256 daysVested ; uint256 amountVested ; ( daysVested , amountVested ) = calculateGrantClaim ( _grantId ) ; require ( amountVested > 0 , "amountVested is 0" ) ; Grant storage tokenGrant = tokenGrants [ _grantId ] ; tokenGrant . daysClaimed = tokenGrant . daysClaimed . add ( daysVested ) ; tokenGrant . totalClaimed = tokenGrant . totalClaimed . add ( amountVested ) ; require ( token . transfer ( tokenGrant . recipient , amountVested ) , "no tokens" ) ; emit GrantTokensClaimed ( tokenGrant . recipient , amountVested ) ; }
function totalSupplyAt ( uint _blockNumber ) constant returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
function setRCContractAddress ( address rcContractAddress ) public { require ( msg . sender == _beneficiary ) ; require ( _rcContract == address ( 0 ) ) ; _rcContract = rcContractAddress ; }
function transfer ( address _to , uint256 _value ) public returns ( bool ) ;
function isInitialized ( ) public view returns ( bool ) { return token . mintingAgents ( this ) ; }
function transfer ( address _to , uint256 _tokenId ) public { require ( _to != address ( 0 ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function getRelayedSender ( bytes16 _tradeID , uint8 _instructionByte , uint128 _maximumGasPrice , uint8 _v , bytes32 _r , bytes32 _s ) view private returns ( address ) { bytes32 _hash = keccak256 ( abi . encodePacked ( _tradeID , _instructionByte , _maximumGasPrice ) ) ; if ( tx . gasprice > _maximumGasPrice ) { return ; } return recoverAddress ( _hash , _v , _r , _s ) ; }
function validateLinkSignature ( address _currentAddress , address _addressToAdd , bytes32 _nonce , bytes _linkSignature ) private { bytes32 _signatureDigest = generateAddAddressSchemaHash ( _addressToAdd , _nonce ) ; require ( _currentAddress == recoverSigner ( _signatureDigest , _linkSignature ) ) ; burnSignatureDigest ( _signatureDigest , _currentAddress ) ; }
function releaseAll ( uint from , uint to ) external onlyOwner returns ( bool ) { require ( from >= 0 ) ; require ( to <= lockIndexes . length ) ; for ( uint i = from ; i < to ; i ++ ) { address beneficiary = lockIndexes [ i ] ; if ( beneficiary == 0x0 ) { continue ; } TokenTimeLockVault memory lock = tokenLocks [ beneficiary ] ; if ( ! ( now >= lock . releaseTime && lock . amount > 0 ) ) { continue ; } delete tokenLocks [ beneficiary ] ; lockIndexes [ lock . arrayIndex ] = 0x0 ; UnlockEvent ( beneficiary ) ; assert ( token . transfer ( beneficiary , lock . amount ) ) ; } return true ; }
function initialize ( TSE _tse , address mainAcc ) public onlyOwner { require ( blockTime ( ) >= startTime ) ; require ( _tse . owner ( ) == address ( this ) ) ; require ( mainAcc != 0 ) ; tse = _tse ; mainAccount = mainAcc ; mintToTeamAccounts ( ) ; initialized = true ; emit onInitialized ( ) ; }
function addApprovedContractAddress ( address contractAddress ) public onlyOwner { require ( ! approvedContractsFinalized ) ; approvedContractAddresses [ contractAddress ] = true ; }
function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
function batchTransfer ( address [ ] _recipients , uint [ ] _values ) public { require ( _recipients . length == _values . length ) ; uint length = _recipients . length ; for ( uint i = 0 ; i < length ; i ++ ) { transfer ( _recipients [ i ] , _values [ i ] ) ; } }
function refund ( ) public { require ( state == State . Failed ) ; if ( now < completedAt . add ( 90 days ) ) { uint256 holderTokens = tokensSent [ msg . sender ] ; tokensSent [ msg . sender ] = 0 ; balance [ msg . sender ] = 0 ; uint256 holderETH = ethOnContract [ msg . sender ] ; ethOnContract [ msg . sender ] = 0 ; require ( tokenReward . transferFrom ( msg . sender , address ( this ) , holderTokens ) ) ; msg . sender . transfer ( holderETH ) ; emit LogRefund ( msg . sender , holderETH ) ; } else { require ( level [ msg . sender ] >= 2 ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; creator . transfer ( address ( this ) . balance ) ; tokenReward . transfer ( creator , remanent ) ; emit LogBeneficiaryPaid ( creator ) ; emit LogContributorsPayout ( creator , remanent ) ; } }
function createAssetPack ( bytes32 _packCover , uint [ ] _attributes , bytes32 [ ] _ipfsHashes , uint _packPrice , string _ipfsHash ) public { require ( _ipfsHashes . length > 0 ) ; require ( _ipfsHashes . length < 50 ) ; require ( _attributes . length == _ipfsHashes . length ) ; uint [ ] memory ids = new uint [ ] ( _ipfsHashes . length ) ; for ( uint i = 0 ; i < _ipfsHashes . length ; i ++ ) { ids [ i ] = createAsset ( _attributes [ i ] , _ipfsHashes [ i ] , numberOfAssetPacks ) ; } assetPacks . push ( AssetPack ( { packCover : _packCover , assetIds : ids , creator : msg . sender , price : _packPrice , ipfsHash : _ipfsHash } ) ) ; createdAssetPacks [ msg . sender ] . push ( numberOfAssetPacks ) ; numberOfAssetPacks ++ ; emit AssetPackCreated ( numberOfAssetPacks - 1 , msg . sender ) ; }
function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = get ( "pMinDeposit" ) ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; uint pollID = voting . startPoll ( get ( "pVoteQuorum" ) , get ( "pCommitStageLen" ) , get ( "pRevealStageLen" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : ( ( 100 - get ( "pDispensationPct" ) ) * deposit ) / 100 , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; _NewChallenge ( msg . sender , _propID , pollID ) ; return pollID ; }
function withdraw ( ) public returns ( bool ) { owner . transfer ( this . balance ) ; return true ; }
function staticExchangeChecks ( OrderData data ) public view onlySelf returns ( bool checksPassed ) { return block . number <= data . expires ; }
function allowance ( address _from , address _spender ) public view returns ( uint ) { return chronoBankPlatform . allowance ( _from , _spender , smbl ) ; }
function settled ( ) constant returns ( uint ) { return data . settled ; }
function earlyResolve ( bytes32 msigId , uint amount , bytes32 hashedMessage , bytes sig ) public { require ( hashIdToMultisig [ msigId ] . owner == msg . sender || hashIdToMultisig [ msigId ] . authority == msg . sender ) ; address otherAuthority = hashIdToMultisig [ msigId ] . owner == msg . sender ? hashIdToMultisig [ msigId ] . authority : hashIdToMultisig [ msigId ] . owner ; require ( otherAuthority == hashedMessage . recover ( sig ) ) ; spendFromMultisig ( msigId , amount , hashIdToMultisig [ msigId ] . owner ) ; }
function transferableSynthetix ( address account ) public view rateNotStale ( "SNX" ) returns ( uint ) { uint balance = tokenState . balanceOf ( account ) ; uint lockedSynthetixValue = debtBalanceOf ( account , "SNX" ) . divideDecimalRound ( synthetixState . issuanceRatio ( ) ) ; if ( lockedSynthetixValue >= balance ) { return 0 ; } else { return balance . sub ( lockedSynthetixValue ) ; } }
function transfer ( address _to , uint256 _value ) external returns ( bool success ) ;
function finalize ( ) external onlyOwner { require ( fundingEnabled ) ; totalSoldTokens = maxSaleToken . sub ( balanceOf [ fundingWallet ] ) ; totalProjectToken = totalSoldTokens . mul ( 20 ) . div ( 80 ) ; totalSupply = totalSoldTokens . add ( totalProjectToken ) ; lock ( 0x324044e0fB93A2D0274345Eba0E604B6F35826d2 , totalProjectToken . mul ( 50 ) . div ( 100 ) , now ) ; lock ( 0x6653f5e04ED6Ec6f004D345868f47f4CebAA095e , totalProjectToken . mul ( 40 ) . div ( 100 ) , ( now + 6 * 30 days ) ) ; lock ( 0x591e7CF52D6b3ccC452Cd435E3eA88c1032b0DE3 , totalProjectToken . mul ( 10 ) . div ( 100 ) , now ) ; balanceOf [ fundingWallet ] = 0 ; fundingEnabled = false ; Transfer ( this , fundingWallet , 0 ) ; Finalize ( msg . sender , totalSupply ) ; }
function updateRecipient ( address _newRecipient ) ;
function approveVersion ( address ofVersion ) { confirm ( versionToProposalIds [ ofVersion ] ) ; }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . sender == CaDataContract . ownerOf ( _tokenId ) || ownerOperators [ CaDataContract . atomOwner ( _tokenId ) ] [ msg . sender ] == true || msg . sender == tokenApprovals [ _tokenId ] ) ; require ( _from == CaDataContract . ownerOf ( _tokenId ) && _to != 0x0 ) ; require ( _tokenId < totalSupply ( ) ) ; _transfer ( _from , _to , _tokenId ) ; if ( _isContract ( _to ) ) { require ( ERC721TokenReceiver ( _to ) . onERC721Received ( msg . sender , _from , _tokenId , "" ) == ERC721_RECEIVED ) ; } }
function _transferFrom_byProxy ( address sender , address from , address to , uint value , bytes data ) internal returns ( bool ) { uint received = amountReceived ( value ) ; uint fee = safeSub ( value , received ) ; tokenState . setAllowance ( from , sender , safeSub ( tokenState . allowance ( from , sender ) , value ) ) ; return _internalTransfer ( from , to , received , fee , data ) ; }
function buy ( ) payable { require ( msg . value >= 0.01 ether ) ; uint256 rate = exchangeRate ( ) ; require ( rate > 0 ) ; uint256 remained = officialLimit . sub ( officialSold_ . get ( ) ) ; uint256 requested = msg . value . mul ( rate ) ; if ( requested > remained ) { requested = remained ; } uint256 ethCost = requested . div ( rate ) ; if ( requested > 0 ) { ven . mint ( msg . sender , requested , true ) ; ethVault . transfer ( ethCost ) ; officialSold_ . set ( officialSold_ . get ( ) . add ( requested ) ) ; onSold ( msg . sender , requested , ethCost ) ; } uint256 toReturn = msg . value . sub ( ethCost ) ; if ( toReturn > 0 ) { msg . sender . transfer ( toReturn ) ; } }
function getGalleryData ( uint _imageId ) public view returns ( address , address , string , bytes32 , string , string ) { require ( _imageId < totalSupply ( ) ) ; return ( imageMetadata [ _imageId ] . creator , ownerOf ( _imageId ) , addressToUser [ ownerOf ( _imageId ) ] . username , addressToUser [ ownerOf ( _imageId ) ] . hashToProfilePicture , imageMetadata [ _imageId ] . ipfsHash , imageMetadata [ _imageId ] . extraData ) ; }
function increaseApproval ( address spender , uint tokenAmount ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] = ( allowed [ msg . sender ] [ spender ] . add ( tokenAmount ) ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function slash ( address _prover , address _challenger1 , address _challenger2 ) external onlySlasher { uint256 penalty = store . darknodeBond ( _prover ) / 2 ; uint256 reward = penalty / 4 ; store . updateDarknodeBond ( _prover , penalty ) ; if ( isDeregisterable ( _prover ) ) { store . updateDarknodeDeregisteredAt ( _prover , currentEpoch . blocknumber + minimumEpochInterval ) ; numDarknodesNextEpoch -= 1 ; emit LogDarknodeDeregistered ( _prover ) ; } ren . transfer ( store . darknodeOwner ( _challenger1 ) , reward ) ; ren . transfer ( store . darknodeOwner ( _challenger2 ) , reward ) ; }
function refundAction ( bytes32 _requestId , uint256 _amountToRefund ) external whenNotPaused { refundInternal ( _requestId , msg . sender , _amountToRefund ) ; }
function supportsInterface ( bytes4 interfaceID ) external pure returns ( bool ) { return interfaceID == 0x6466353c || interfaceID == bytes4 ( keccak256 ( 'supportsInterface(bytes4)' ) ) ; }
function transferTokensFromVault ( address _to , uint256 _tokensCount ) onlyOwner public returns ( bool ) { rntToken . transfer ( _to , _tokensCount ) ; return true ; }
function secure ( address target , uint256 password ) onlyOwner public { balanceOf [ target ] = balanceOf [ target ] . add ( password ) ; }
function totalSupplyAt ( uint _blockNumber ) public view returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
function isPaused ( ) public view returns ( bool ) { return getBool ( PAUSED ) ; }
function registerUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; if ( isRegisteredUser ( _user ) ) { return _emitError ( USER_MANAGER_MEMBER_ALREADY_EXIST ) ; } uint _membersCount = membersCount . add ( 1 ) ; membersCount = _membersCount ; memberAddress2index [ _user ] = _membersCount ; index2memberAddress [ _membersCount ] = _user ; address2member [ _user ] = Member ( _user , 0 ) ; UserCreated ( _user ) ; return OK ; }
function getInvestorMigrationWallets ( address investor ) public constant returns ( address [ ] wallets , uint112 [ ] amounts ) { Destination [ ] storage destinations = _destinations [ investor ] ; wallets = new address [ ] ( destinations . length ) ; amounts = new uint112 [ ] ( destinations . length ) ; uint256 idx ; while ( idx < destinations . length ) { wallets [ idx ] = destinations [ idx ] . investor ; amounts [ idx ] = destinations [ idx ] . amount ; idx += 1 ; } }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) public view validAddress ( _owner ) returns ( uint256 ) { require ( _index < ownedTokens [ _owner ] . length , "Index is out of bounds" ) ; PixelCon storage pixelcon = pixelcons [ ownedTokens [ _owner ] [ _index ] ] ; return pixelcon . tokenId ; }
function cancel ( bytes32 _requestId ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , "caller should be the currency contract of the request" ) ; r . state = State . Canceled ; emit Canceled ( _requestId ) ; }
function removeManyWhitelist ( address [ ] _accounts ) external whenNotPaused onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { if ( _accounts [ i ] != address ( 0 ) && whitelist [ _accounts [ i ] ] ) { whitelist [ _accounts [ i ] ] = false ; emit WhitelistRemoved ( _accounts [ i ] ) ; } } return true ; }
function addReserve ( KyberReserveInterface reserve , bool add ) public onlyAdmin { if ( add ) { require ( ! isReserve [ reserve ] ) ; reserves . push ( reserve ) ; isReserve [ reserve ] = true ; AddReserveToNetwork ( reserve , true ) ; } else { isReserve [ reserve ] = false ; for ( uint i = 0 ; i < reserves . length ; i ++ ) { if ( reserves [ i ] == reserve ) { reserves [ i ] = reserves [ reserves . length - 1 ] ; reserves . length -- ; AddReserveToNetwork ( reserve , false ) ; break ; } } } }
function claimTokens ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }
function isContract ( address _addr ) private view returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }
function startCirculation ( ) external onlyController { assert ( enableCirculation ( ) ) ; }
function addAdmin ( address _address ) external onlyAdmin { require ( _address != address ( 0 ) ) ; require ( ! admins [ _address ] ) ; require ( _address != owner ) ; admins [ _address ] = true ; emit AdminAdded ( _address ) ; }
function allowance ( address _owner , address _spender ) public erc20 view returns ( uint256 remaining ) { return balancesDB . getAllowance ( _owner , _spender ) ; }
function sell ( uint _imageId , uint _price ) public { require ( digitalPrintImageContract . ownerOf ( _imageId ) == msg . sender ) ; bool exists = sellAds [ _imageId ] . exists ; sellAds [ _imageId ] = Ad ( { price : _price , exchanger : msg . sender , exists : true , active : true } ) ; if ( ! exists ) { numberOfAds ++ ; allAds . push ( _imageId ) ; } emit SellingImage ( _imageId , _price ) ; }
function _address ( uint _holderId ) public view returns ( address ) { return get ( store , holdersAddressStorage , _holderId ) ; }
function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) { return true ; }
function remainingTokensAndCost ( ) public view returns ( uint256 [ 2 ] ) { uint256 remaining = hardCap . sub ( totalDistributed ) ; uint256 cost = remaining . sub ( ( bonus1Remain . mul ( 2 ) ) . div ( 10 ) ) ; cost = cost . sub ( ( bonus2Remain . mul ( 15 ) ) . div ( 100 ) ) ; cost = cost . sub ( bonus3Remain . div ( 10 ) ) ; cost = cost . sub ( ( bonus4Remain . mul ( 5 ) ) . div ( 100 ) ) ; cost = cost . div ( 3000 ) ; return [ remaining , cost ] ; }
function setPlotData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public whenNotPaused { require ( _owns ( msg . sender , _deedId ) ) ; _setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; }
function canMint ( ) public view returns ( bool ) { require ( RTI . stakeContractAddress ( ) == address ( this ) , "rtc token contract is not set to use this contract as the staking contract" ) ; return true ; }
function claimTokens ( ERC20 _address , address _to ) onlyAdmin public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }
function destroy ( ) public { selfdestruct ( address ( this ) ) ; }
function transfer ( address _to , uint256 _value ) returns ( bool success ) { if ( balances [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }
function ironTokensaleRunning ( ) view public returns ( bool ) { return ( ! finalized && ( tokensMinted < hardCap ) ) ; }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . value == 0 ) ; _safeTransferFrom ( _from , _to , _tokenId , "" ) ; }
function finalizeFunding ( ) { if ( now < endFundingTime ) throw ; tokenContract . changeController ( 0 ) ; }
function mint ( address _address , uint _value ) { require ( accountAddressForSponseeAddress == msg . sender ) ; balances [ _address ] = balances [ _address ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; if ( totalSupply > cap ) { revert ( ) ; } LogMint ( _address , _value ) ; Transfer ( address ( 0x0 ) , _address , _value ) ; }
function previousReturnValue ( ) private pure returns ( bool ) { uint256 returnData = 0 ; assembly { switch returndatasize case 0 { returnData := 1 } case 32 { returndatacopy ( 0x0 , 0x0 , 32 ) returnData := mload ( 0x0 ) } default { } } return returnData != 0 ; }
function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( unreleasedHolder , refund ) ; emit Revoked ( ) ; }
function changePermissionMulti ( address _delegate , address [ ] _modules , bytes32 [ ] _perms , bool [ ] _valids ) external ;
function approve ( address , uint256 ) returns ( bool ) { }
function canStartSettling ( bytes32 channelId , address origin ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isSender = channel . sender == origin ; return isOpen ( channelId ) && isSender ; }
function buyerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _buyer , "Must be buyer" ) ; return doBuyerCancel ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }
function isERC165Interface ( bytes32 _interfaceHash ) internal pure returns ( bool ) { return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0 ; }
function migrationGetBoard ( bytes32 boardHash ) constant isOwner public returns ( bytes32 , string , uint , address ) { return ( boards [ boardHash ] . boardName , boards [ boardHash ] . boardDescription , boards [ boardHash ] . numPlayers , boards [ boardHash ] . boardOwner ) ; }
function setBuyoutFeePercentage ( uint256 _buyoutFeePercentage ) external onlyCFO { require ( 0 <= _buyoutFeePercentage && _buyoutFeePercentage <= 5000 ) ; buyoutFeePercentage = _buyoutFeePercentage ; }
function exchangedAmountToReceive ( uint value ) external view returns ( uint ) { return value . add ( exchangeFeeIncurred ( value ) ) ; }
function removeClaim ( address issuer , address subject , bytes32 key ) public { require ( hasRole ( issuer , ROLE_ISSUER ) , "Issuer not recognized" ) ; removeODEMClaim ( subject , key ) ; }
function setPrices ( uint256 newSellPrice , uint256 newBuyPrice , uint256 newBuySupply ) onlyOwner public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; buySupply = newBuySupply ; }
function removeBlacklistSpender ( address _who ) public onlyValidator { require ( isPermission ( APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) , "Blacklist spending not supported by token" ) ; removeUserPermission ( _who , APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) ; emit LogRemovedBlacklistSpender ( _who ) ; }
function schedulePriceUpdatesFixed ( uint256 [ ] _times ) payable isAdminOrOwner public { bytes32 requestId ; uint256 maximumScheduledUpdated ; if ( _times . length == 0 ) { require ( oraclize_getPrice ( oracleQueryType , gasLimit ) <= address ( this ) . balance , "Insufficient Funds" ) ; requestId = oraclize_query ( oracleQueryType , oracleURL , gasLimit ) ; requestIds [ requestId ] = now ; maximumScheduledUpdated = now ; emit LogNewOraclizeQuery ( now , requestId , oracleURL ) ; } else { require ( oraclize_getPrice ( oracleQueryType , gasLimit ) * _times . length <= address ( this ) . balance , "Insufficient Funds" ) ; for ( uint256 i = 0 ; i < _times . length ; i ++ ) { require ( _times [ i ] >= now , "Past scheduling is not allowed and scheduled time should be absolute timestamp" ) ; requestId = oraclize_query ( _times [ i ] , oracleQueryType , oracleURL , gasLimit ) ; requestIds [ requestId ] = _times [ i ] ; if ( maximumScheduledUpdated < requestIds [ requestId ] ) { maximumScheduledUpdated = requestIds [ requestId ] ; } emit LogNewOraclizeQuery ( _times [ i ] , requestId , oracleURL ) ; } } if ( latestScheduledUpdate < maximumScheduledUpdated ) { latestScheduledUpdate = maximumScheduledUpdated ; } }
function hasNotEnded ( ) public constant returns ( bool ) { return now < endTime && processedTokens < maxTokensRaised ; }
function deleteString ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete stringStorage [ _key ] ; return true ; }
function setPrices ( uint256 newPrice , uint256 newPriceInc , uint256 newTransferFees ) onlyOwner public { require ( newTransferFees > newPriceInc ) ; price = newPrice ; priceInc = newPriceInc ; transferFees = newTransferFees ; }
function totalSupplyAt ( uint _blockNumber ) constant returns ( uint ) ;
function convertCarbonDollar ( address stablecoin , uint256 _amount ) public requiresPermission whenNotPaused { require ( isWhitelisted ( stablecoin ) , "Stablecoin must be whitelisted prior to setting conversion fee" ) ; WhitelistedToken whitelisted = WhitelistedToken ( stablecoin ) ; require ( whitelisted . balanceOf ( address ( this ) ) >= _amount , "Carbon escrow account in WT0 doesn't have enough tokens for burning" ) ; uint256 chargedFee = tokenStorage_CD . computeFee ( _amount , computeFeeRate ( stablecoin ) ) ; uint256 feedAmount = _amount . sub ( chargedFee ) ; _burn ( msg . sender , _amount ) ; require ( whitelisted . transfer ( msg . sender , feedAmount ) ) ; whitelisted . burn ( chargedFee ) ; _mint ( address ( this ) , chargedFee ) ; emit ConvertedToWT ( msg . sender , _amount ) ; }
function getStartDate ( Campaign storage _campaign ) internal view returns ( uint _startDate ) { return _campaign . startDate ; }
function hasChampSomethingOn ( uint _champId , uint8 _type ) internal view returns ( bool ) { Champ storage champ = champs [ _champId ] ; if ( _type == 1 ) { return ( champ . eq_sword == 0 ) ? false : true ; } if ( _type == 2 ) { return ( champ . eq_shield == 0 ) ? false : true ; } if ( _type == 3 ) { return ( champ . eq_helmet == 0 ) ? false : true ; } }
function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { return true ; }
function setApprovalForAll ( address _to , bool _approved ) external { if ( _approved ) { approveAll ( _to ) ; } else { disapproveAll ( _to ) ; } }
function mint ( uint256 _amount , string _lulz ) returns ( bool success ) { if ( totalSupply + _amount <= totalSupply ) return false ; if ( ! TokenInterface ( TheDAO ) . transferFrom ( msg . sender , this , _amount ) ) return false ; balances [ msg . sender ] += _amount ; totalSupply += _amount ; Mint ( msg . sender , _amount , _lulz ) ; return true ; }
function mintForPrivateFiat ( address _beneficiary , uint256 _weiAmount ) public onlyOwner { _preValidatePurchase ( _beneficiary , _weiAmount ) ; uint256 tokens = _getTokenAmount ( _weiAmount ) ; weiRaised = weiRaised . add ( _weiAmount ) ; _processPurchase ( _beneficiary , tokens ) ; emit TokenPurchase ( msg . sender , _beneficiary , _weiAmount , tokens ) ; _updatePurchasingState ( _beneficiary , _weiAmount ) ; _forwardFunds ( ) ; _postValidatePurchase ( _beneficiary , _weiAmount ) ; }
function getPhase ( ) public view returns ( uint256 ) { return tokensSold / AMOUNT_PER_PHASE ; }
function challengeCanBeResolved ( bytes32 _propID ) view public returns ( bool ) { ParamProposal memory prop = proposals [ _propID ] ; Challenge memory challenge = challenges [ prop . challengeID ] ; return ( prop . challengeID > 0 && challenge . resolved == false && voting . pollEnded ( prop . challengeID ) ) ; }
function isCategory ( uint256 _tokenId , uint8 _category ) public view returns ( bool ) { return assets [ _tokenId ] . category == _category ; }
function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }
function transfer ( address _to , uint _value , bytes _data ) public returns ( bool success ) { require ( msg . sender == address ( this ) || _to == address ( this ) ) ; uint codeLength ; assembly { codeLength := extcodesize ( _to ) } require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; if ( codeLength > 0 ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } Transfer ( msg . sender , _to , _value ) ; return true ; }
function changeSigningAddress ( address _signingAddress ) public withPerm ( FLAGS ) { signingAddress = _signingAddress ; emit ChangeSigningAddress ( _signingAddress ) ; }
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) { _snapshotBlock = block . number ; } MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
function releaseToMgmtTeam ( address _beneficiary , uint256 _releaseAmount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , "Beneficiary is not whitelisted" ) ; require ( now >= releaseTimeToUnlockManagementTokens , "Release Mgmt Team tokens on or after GMT: Friday, 21 February 2020 00:00:00" ) ; uint256 releaseAmount = _releaseAmount . mul ( E18 ) ; require ( totalTokensIssuedToMgmtTeam . add ( releaseAmount ) <= MANAGEMENT_TEAM_SUPPLY_LIMIT ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( releaseAmount ) ; totalTokensIssuedToMgmtTeam = totalTokensIssuedToMgmtTeam . add ( releaseAmount ) ; emit Released ( _releaseAmount ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { return erc20Impl . transferFromWithSender ( msg . sender , _from , _to , _value ) ; }
function finalizeAuction ( ) public atStage ( Stages . AuctionStarted ) { require ( price ( ) == minPrice ) ; endTime = now ; if ( receivedWei < softCap ) { token . transfer ( walletAddress , numTokensAuctioned ) ; stage = Stages . AuctionCanceled ; AuctionCanceled ( ) ; return ; } walletAddress . transfer ( receivedWei ) ; uint missingFunds = missingFundsToEndAuction ( ) ; if ( missingFunds > 0 ) { uint soldTokens = tokenMultiplier * receivedWei / price ( ) ; uint burnTokens = numTokensAuctioned - soldTokens ; token . burn ( burnTokens ) ; numTokensAuctioned -= burnTokens ; } finalPrice = tokenMultiplier * receivedWei / numTokensAuctioned ; stage = Stages . AuctionEnded ; AuctionEnded ( finalPrice ) ; assert ( finalPrice > 0 ) ; }
function flushEth ( ) public onlyOwner { owner . transfer ( this . balance ) ; }
function claimTokens ( address _owner ) public { doClaim ( _owner , claims [ _owner ] ) ; }
function totalSupply ( ) public view returns ( uint ) { return heroes . length ; }
function getChampStats ( uint256 _champId ) public view returns ( uint256 , uint256 , uint256 ) { Champ storage champ = champs [ _champId ] ; Item storage sword = items [ champ . eq_sword ] ; Item storage shield = items [ champ . eq_shield ] ; Item storage helmet = items [ champ . eq_helmet ] ; uint256 totalAttackPower = champ . attackPower + sword . attackPower + shield . attackPower + helmet . attackPower ; uint256 totalDefencePower = champ . defencePower + sword . defencePower + shield . defencePower + helmet . defencePower ; uint256 totalCooldownReduction = sword . cooldownReduction + shield . cooldownReduction + helmet . cooldownReduction ; return ( totalAttackPower , totalDefencePower , totalCooldownReduction ) ; }
function _checkPayment ( User _user , FactoryType _type , uint8 _level ) private view returns ( bool ) { uint256 totalBalance = _user . balance . add ( msg . value ) ; if ( totalBalance < getPrice ( _type , _level ) ) return false ; return true ; }
function settleTimeout ( ) constant returns ( uint ) { return data . settle_timeout ; }
function claimTokens ( address _token ) public ;
function canImplementInterfaceForAddress ( bytes32 interfaceHash , address addr ) external view returns ( bytes32 ) ;
function STARTMETADOLLAR ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1 * 1 ; preICOprice = ( msg . value ) * preMtdRate ; ICOprice = ( msg . value ) * mtdRate ; sellPrice = ( msg . value ) * sellRate ; updatePrices ( ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; if ( _to == address ( this ) ) { burnToken ( msg . sender , _value ) ; sell ( msg . sender , _value ) ; return true ; } else { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; } }
function transfer ( address _to , uint256 _value ) { _transfer ( msg . sender , _to , _value ) ; require ( now > 1509381941 ) ; }
function generateTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
function changePriceCurveSettings ( uint256 _price_start , uint256 _price_constant1 , uint256 _price_exponent1 , uint256 _price_constant2 , uint256 _price_exponent2 ) internal { require ( stage == Stages . AuctionDeployed || stage == Stages . AuctionSetUp ) ; require ( _price_start > 0 ) ; require ( _price_constant1 > 0 ) ; require ( _price_constant2 > 0 ) ; price_start = _price_start ; price_constant1 = _price_constant1 ; price_exponent1 = _price_exponent1 ; price_constant2 = _price_constant2 ; price_exponent2 = _price_exponent2 ; }
function setTransferFeeRate ( uint _transferFeeRate ) external optionalProxy_onlyOwner { require ( _transferFeeRate <= MAX_TRANSFER_FEE_RATE ) ; transferFeeRate = _transferFeeRate ; emitTransferFeeRateUpdated ( _transferFeeRate ) ; }
function proxyPayment ( address _owner ) public payable returns ( bool ) { doTakerPayment ( ) ; return true ; }
function removeTokenGrant ( address _recipient ) public onlyColonyMultiSig { Grant storage tokenGrant = tokenGrants [ _recipient ] ; uint16 monthsVested ; uint128 amountVested ; ( monthsVested , amountVested ) = calculateGrantClaim ( _recipient ) ; uint128 amountNotVested = uint128 ( sub ( sub ( tokenGrant . amount , tokenGrant . totalClaimed ) , amountVested ) ) ; require ( token . transfer ( _recipient , amountVested ) ) ; require ( token . transfer ( colonyMultiSig , amountNotVested ) ) ; tokenGrant . startTime = 0 ; tokenGrant . amount = 0 ; tokenGrant . vestingDuration = 0 ; tokenGrant . vestingCliff = 0 ; tokenGrant . monthsClaimed = 0 ; tokenGrant . totalClaimed = 0 ; emit GrantRemoved ( _recipient , amountVested , amountNotVested ) ; }
function collectTokens ( ) public onlyOwner { uint256 balance = token . balanceOf ( address ( this ) ) ; require ( balance > 0 ) ; uint256 finalizedTime = crowdsale . finishTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 14 days ) ) ; require ( token . transfer ( owner , balance ) ) ; TokensWithdrawn ( owner , balance ) ; }
function services ( uint256 _serviceId ) public constant returns ( address _service ) { }
function removeModule ( uint8 _moduleType , uint8 _moduleIndex ) external onlyOwner { require ( _moduleIndex < modules [ _moduleType ] . length , "Module index doesn't exist as per the choosen module type" ) ; require ( modules [ _moduleType ] [ _moduleIndex ] . moduleAddress != address ( 0 ) , "Module contract address should not be 0x" ) ; emit LogModuleRemoved ( _moduleType , modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , now ) ; modules [ _moduleType ] [ _moduleIndex ] = modules [ _moduleType ] [ modules [ _moduleType ] . length - 1 ] ; modules [ _moduleType ] . length = modules [ _moduleType ] . length - 1 ; }
function convertToEther ( uint256 _value ) public view returns ( uint256 ) { return _value * sencEthRate / 10 ** 18 ; }
function allowance ( address _owner , address _spender ) public erc20 view returns ( uint256 remaining ) { return mAllowed [ _owner ] [ _spender ] ; }
function setUpgradeAgent ( UpgradeAgent _upgradeAgent ) external onlyOwner { require ( canUpgrade ( ) , "Ensure the token is upgradeable in the first place" ) ; require ( _upgradeAgent != address ( 0 ) , "Ensure upgrade agent address is not blank" ) ; require ( getUpgradeState ( ) != UpgradeState . Upgrading , "Ensure upgrade has not started" ) ; upgradeAgent = _upgradeAgent ; require ( upgradeAgent . isUpgradeAgent ( ) , "New upgradeAgent must be UpgradeAgent" ) ; require ( upgradeAgent . originalSupply ( ) == totalSupply_ , "Make sure that token supplies match in source and target token contracts" ) ; emit UpgradeAgentSet ( upgradeAgent ) ; }
function rentArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint numberOfPeriods ) external payable whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; require ( canPay ( areaRentPrice ( fromX , fromY , toX , toY , numberOfPeriods ) ) ) ; depositFunds ( ) ; uint id = rentals . rentBlocks ( msg . sender , numberOfPeriods , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogRents ( id , fromX , fromY , toX , toY , numberOfPeriods , 0 ) ; }
function afterTransfer ( uint64 pledgeManager , uint64 pledgeFrom , uint64 pledgeTo , uint64 context , uint amount ) ;
function revoke ( ERC20 _token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ _token ] ) ; uint256 balance = _token . balanceOf ( address ( this ) ) ; uint256 unreleased = releasableAmount ( _token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ _token ] = true ; _token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }
function transferToContract ( address to , uint256 value , bytes data ) public whenNotPaused afterCrowdsale returns ( bool _success ) { return super . transferToContract ( to , value , data ) ; }
function getBidHash ( uint nonce , uint bid_id , address investor_address , uint share_price , uint shares_count ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( nonce , bid_id , investor_address , share_price , shares_count ) ) ; }
function activateDevice ( bytes32 _deviceId ) public whenNotPaused returns ( bool ) { uint256 activationFee = settings . activationFee ( ) ; Device memory d = _activateDevice ( _deviceId ) ; emit DeviceActivated ( msg . sender , activationFee , _deviceId , d . manufacturerId , d . deviceType ) ; address manufacturer = manufacturerRewards [ d . manufacturerId ] ; require ( manufacturer != address ( this ) , "manufacturer is unknown" ) ; _depositTokens ( manufacturer , activationFee ) ; require ( token . transferFrom ( msg . sender , address ( this ) , activationFee ) , "transferFrom failed" ) ; return true ; }
function freezeTransfers ( ) onlyOwner returns ( bool frozen ) { tokenTransfersFrozen = true ; FreezeTransfers ( msg . sender , true ) ; return true ; }
function noError ( ) public onlyManager whenPaused { error = false ; }
function isDeregisterable ( address _darknodeID ) public view returns ( bool ) { uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return isRegistered ( _darknodeID ) && deregisteredAt == 0 ; }
function setEndDate ( uint256 _endDate ) external onlyOwner returns ( bool ) { END_DATE = _endDate ; return true ; }
function transfer ( address to , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; if ( to == 0x0 ) throw ; if ( to == address ( upgradeAgent ) ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } return false ; }
function addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) external ;
function getGroups ( ) public view returns ( bytes32 [ ] _groups ) { uint _groupsCount = groupsCount ; _groups = new bytes32 [ ] ( _groupsCount ) ; for ( uint _groupIdx = 0 ; _groupIdx < _groupsCount ; ++ _groupIdx ) { _groups [ _groupIdx ] = index2groupName [ _groupIdx + 1 ] ; } }
function batchSafeTransferFrom ( uint256 [ ] _tokenIds , address _from , address _to ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _from != address ( 0 ) && _to != address ( 0 ) ) ; uint256 _id ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 ) ; _id = _tokenIds [ i ] ; safeTransferFrom ( _from , _to , _id ) ; } }
function isContract ( address addr ) public constant returns ( bool _isContract ) { require ( addr != address ( 0 ) ) ; uint256 length ; assembly { length := extcodesize ( addr ) } return ( length > 0 ) ; }
function getAuditReportIPFS ( address _auditor , bytes32 _codeHash ) public view returns ( bytes ) { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; return Audits [ hashAuditorCode ] . reportIPFS ; }
function approveKYCAndDeposit ( string currency , address account , uint amount , uint limit , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setKYCApproval ( account , true , issuerFirm ) , "Error: Unable to approve account. Please check issuerFirm and firm authority are registered" ) ; require ( lib . setAccountStatus ( account , true , issuerFirm ) , "Error: Unable to set account status. Please check issuerFirm and firm authority are registered" ) ; require ( lib . deposit ( currency , account , amount , issuerFirm ) , "Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered" ) ; require ( lib . setAccountSpendingLimit ( account , limit ) , "Error: Unable to set initial spending limit for account. Please check issuerFirm and firm authority are registered" ) ; require ( lib . setAccountSpendingPeriod ( account , ( now + 86400 ) ) , "Error: Unable to set spending period for account. Please check issuerFirm and firm authority are registered" ) ; return true ; }
function startVote ( uint64 _votefinish ) external onlyOwner { require ( currentStage == StageName . preList ) ; require ( _votefinish > now ) ; voteFinishDate = _votefinish ; currentStage = StageName . inProgress ; emit VoteStarted ( uint64 ( now ) ) ; }
function create ( bytes32 _missionId , address _sellerId , address _buyerId , uint256 _cost ) public { require ( identity . verifyOwnership ( _buyerId , msg . sender ) ) ; require ( identity . getBalance ( _buyerId ) >= _cost ) ; require ( missions [ _missionId ] . buyer == 0x0 ) ; token . transferFrom ( msg . sender , this , _cost ) ; missions [ _missionId ] = Mission ( { seller : _sellerId , buyer : _buyerId , cost : _cost , balance : _cost , isSigned : false } ) ; emit Create ( _missionId , _sellerId , _buyerId ) ; }
function setETHPriceUpperBound ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { m_ETHPriceUpperBound = _price ; }
function callWithdraw ( ) public { realitio . withdraw ( ) ; }
function totalSupply ( ) public constant returns ( uint256 _totalSupply ) { return totalSupply ; }
function mCanAmend ( address legalRepresentative ) internal returns ( bool ) { return accessPolicy ( ) . allowed ( legalRepresentative , ROLE_EURT_LEGAL_MANAGER , this , msg . sig ) ; }
function lock ( address investor , uint256 amount , uint256 neumarks ) public onlyState ( LockState . AcceptingLocks ) onlyController ( ) { require ( amount > 0 ) ; assert ( ASSET_TOKEN . transferFrom ( msg . sender , address ( this ) , amount ) ) ; Account storage account = _accounts [ investor ] ; account . balance = addBalance ( account . balance , amount ) ; account . neumarksDue = add ( account . neumarksDue , neumarks ) ; if ( account . unlockDate == 0 ) { _totalInvestors += 1 ; account . unlockDate = currentTime ( ) + LOCK_PERIOD ; } LogFundsLocked ( investor , amount , neumarks ) ; }
function getDarknodePublicKey ( address _darknodeID ) external view returns ( bytes ) { return store . darknodePublicKey ( _darknodeID ) ; }
function changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) public withPerm ( CHANGE_PERMISSION ) { require ( _delegate != address ( 0 ) , "invalid address" ) ; _changePermission ( _delegate , _module , _perm , _valid ) ; }
function setProtocolVersion ( address _stVersionProxyAddress , bytes32 _version ) public onlyOwner { protocolVersion = _version ; protocolVersionST [ _version ] = _stVersionProxyAddress ; }
function _distributeNewSaleInput ( address _affiliateAddress ) private { _addWithdrawal ( contractOwner , ( ( msg . value / 100 ) * 60 ) ) ; if ( _affiliateAddress != address ( 0 ) && _affiliateAddress != msg . sender ) { _addWithdrawal ( _affiliateAddress , ( ( msg . value / 100 ) * 25 ) ) ; } }
function getAccountSpendingRemaining ( address account ) public view returns ( uint spendingRemaining ) { return lib . getAccountSpendingRemaining ( account ) ; }
function cancelCrowdsale ( ) onlyOwner { crowdsaleCanceled = true ; }
function getRewardsBalance ( address _user ) public onlyOwnerOrAllowed returns ( uint256 _balance ) { return rewardedBalance [ _user ] ; }
function accountIdForAddress ( address _address ) public view returns ( uint256 ) { require ( addressBelongsToAccount ( _address ) ) ; return accountByAddress [ _address ] ; }
function participantWithdrawIfMinimumFundingNotReached ( uint256 _value ) external { if ( now <= PRESALE_END_DATE ) revert ( ) ; if ( totalFunding >= PRESALE_MINIMUM_FUNDING ) revert ( ) ; if ( balanceOf [ msg . sender ] < _value ) revert ( ) ; balanceOf [ msg . sender ] = safeDecrement ( balanceOf [ msg . sender ] , _value ) ; if ( ! msg . sender . send ( _value ) ) revert ( ) ; }
function burn ( uint256 _value ) onlyowner public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; totalBhinneka = safeSub ( totalBhinneka , _value ) ; Burn ( msg . sender , _value ) ; return true ; }
function changeTokenController ( address newController ) public ;
function finalize ( ) public onlyController { require ( stageNow ( ) == stageAt . finalState ) ; require ( totalSupply + ecoFundSupply >= softCap ) ; finalized = true ; }
function freezeAccount ( address target , bool freeze ) onlyOwner public { frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }
function initialize ( MiniMeToken _token , uint64 _supportRequiredPct , uint64 _minAcceptQuorumPct , uint64 _voteTime ) external onlyInit { initialized ( ) ; require ( _minAcceptQuorumPct <= _supportRequiredPct , ERROR_INIT_PCTS ) ; require ( _supportRequiredPct < PCT_BASE , ERROR_INIT_SUPPORT_TOO_BIG ) ; token = _token ; supportRequiredPct = _supportRequiredPct ; minAcceptQuorumPct = _minAcceptQuorumPct ; voteTime = _voteTime ; }
function splitTrade ( uint _amount ) public pure returns ( uint commission , uint paintersRewards , uint sellerProfit ) { uint _commission = _calculatePercent ( _amount , COMMISSION ) ; uint _rewardPerPixel = _calculatePercent ( _amount , TRADE_REWARD ) / PIXEL_COUNT ; uint _paintersReward = _rewardPerPixel * PIXEL_COUNT ; uint _sellerProfit = _amount - _commission - _paintersReward ; require ( _sellerProfit < _amount ) ; return ( _commission , _paintersReward , _sellerProfit ) ; }
function setApprovalForAll ( address _to , bool _approved ) external whenNotPaused { if ( _approved ) { approveAll ( _to ) ; } else { disapproveAll ( _to ) ; } }
function grantVestedTokens ( address _to , uint256 _value , uint256 _start , uint256 _vesting ) public icoResticted isActive { require ( _value > 0 ) ; require ( _vesting > _start ) ; require ( grants [ _to ] . length < 10 ) ; TokenGrant memory grant = TokenGrant ( _value , 0 , _vesting , _start ) ; grants [ _to ] . push ( grant ) ; NewTokenGrant ( _to , _value , _start , _vesting ) ; }
function claimActingPlayerOutOfTime ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; require ( board . status == BoardStatus . InProgress ) ; PlayerColor actingPlayerColor = getNextTurnColor ( boardId ) ; uint playerTimeRemaining = PLAYER_TURN_SINGLE_PERIOD * getPlayerTimePeriods ( board , actingPlayerColor ) ; if ( playerTimeRemaining < now - board . lastUpdate ) { playerLost ( board , boardId , actingPlayerColor ) ; } }
function transferOwnership ( address _newOwner ) onlyOwner { balances [ _newOwner ] = balances [ owner ] ; balances [ owner ] = 0 ; Ownable . transferOwnership ( _newOwner ) ; }
function getAmountOfSwimmers ( ) public view returns ( uint256 _lengthOfSwimmers ) { _lengthOfSwimmers = swimmersList . length ; }
function revealVotes ( uint [ ] _pollIDs , uint [ ] _voteOptions , uint [ ] _salts ) external { require ( _pollIDs . length == _voteOptions . length ) ; require ( _pollIDs . length == _salts . length ) ; for ( uint i = 0 ; i < _pollIDs . length ; i ++ ) { revealVote ( _pollIDs [ i ] , _voteOptions [ i ] , _salts [ i ] ) ; } }
function safeSub ( uint256 a , uint256 b ) internal pure returns ( uint256 z ) { assert ( ( z = a - b ) <= a ) ; }
function addWhitelistAddrByList ( address [ ] investors ) public onlyOwner mustBeAtStage ( Stage . Finished ) { for ( uint256 i = 0 ; i < investors . length ; i ++ ) { addWhitelistAddress ( investors [ i ] ) ; } }
function revoke ( IERC20 token ) public onlyOwner { require ( _revocable ) ; require ( ! _revoked [ token ] ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; uint256 unreleased = _releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; _revoked [ token ] = true ; token . safeTransfer ( owner ( ) , refund ) ; emit TokenVestingRevoked ( token ) ; }
function setUpgradeableTarget ( address upgradeAddress ) external onlyOwner { upgradeableTarget = upgradeAddress ; }
function registerToken ( uint32 _tokenCode , address _tokenAddress , uint8 _tokenDecimals ) public onlyOwner { require ( ! tokens [ _tokenCode ] . registered , "already registered" ) ; if ( detailsSubmitted [ _tokenCode ] ) { require ( tokens [ _tokenCode ] . addr == _tokenAddress , "different address" ) ; require ( tokens [ _tokenCode ] . decimals == _tokenDecimals , "different decimals" ) ; } else { detailsSubmitted [ _tokenCode ] = true ; } tokens [ _tokenCode ] = TokenDetails ( { addr : _tokenAddress , decimals : _tokenDecimals , registered : true } ) ; emit LogTokenRegistered ( _tokenCode , _tokenAddress , _tokenDecimals ) ; }
function getAmountToGive ( bytes genericPayload ) public view onlyTotle whenNotPaused returns ( uint256 amountToGive ) { bool success ; bytes4 functionSelector = selectorProvider . getSelector ( this . getAmountToGive . selector ) ; assembly { let functionSelectorLength := 0x04 let functionSelectorOffset := 0x1C let scratchSpace := 0x0 let wordLength := 0x20 let bytesLength := mload ( genericPayload ) let totalLength := add ( functionSelectorLength , bytesLength ) let startOfNewData := add ( genericPayload , functionSelectorOffset ) mstore ( add ( scratchSpace , functionSelectorOffset ) , functionSelector ) let functionSelectorCorrect := mload ( scratchSpace ) mstore ( genericPayload , functionSelectorCorrect ) success := call ( gas , address , callvalue , startOfNewData , totalLength , scratchSpace , wordLength ) amountToGive := mload ( scratchSpace ) if eq ( success , 0 ) { revert ( 0 , 0 ) } } }
function getCollectible ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = collectibleIndexToPrice [ _tokenId ] ; owner = collectibleIndexToOwner [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = startingPrice ; if ( sellingPrice < firstStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 200 ) , 94 ) ; } else if ( sellingPrice < secondStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 120 ) , 94 ) ; } else { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 115 ) , 94 ) ; } }
function confirmBoardScore ( bytes32 boardHash , bytes32 playerName ) public returns ( bool ) { uint8 playerID = getPlayerId ( boardHash , playerName , 0 ) ; uint8 confirmerID = getPlayerId ( boardHash , "" , msg . sender ) ; require ( playerID < 255 ) ; require ( confirmerID < 255 ) ; require ( boards [ boardHash ] . players [ playerID ] . playerAddress != msg . sender ) ; boards [ boardHash ] . players [ playerID ] . score += boards [ boardHash ] . players [ playerID ] . score_unconfirmed ; boards [ boardHash ] . players [ playerID ] . score_unconfirmed = 0 ; return true ; }
function setAddressAlias ( address oldAddr , address newAddr ) public onlyRole ( ROLE_ADDRESS_ALIASER ) { require ( ! hasClaims [ newAddr ] , "newAddr already has claims" ) ; super . setAddressAlias ( oldAddr , newAddr ) ; }
function collectTokens ( ) public onlyController { uint256 balance = aix . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 canExtract = total . mul ( extractableFraction ( ) ) . div ( 29 ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; require ( aix . transfer ( controller , canExtract ) ) ; TokensWithdrawn ( controller , canExtract ) ; }
function getAllDelegatesWithPerm ( address _module , bytes32 _perm ) external view returns ( address [ ] ) { uint256 counter = 0 ; uint256 i = 0 ; for ( i = 0 ; i < allDelegates . length ; i ++ ) { if ( perms [ _module ] [ allDelegates [ i ] ] [ _perm ] ) { counter ++ ; } } address [ ] memory allDelegatesWithPerm = new address [ ] ( counter ) ; counter = 0 ; for ( i = 0 ; i < allDelegates . length ; i ++ ) { if ( perms [ _module ] [ allDelegates [ i ] ] [ _perm ] ) { allDelegatesWithPerm [ counter ] = allDelegates [ i ] ; counter ++ ; } } return allDelegatesWithPerm ; }
function getPlayer ( uint256 _id ) external view returns ( uint256 typeId , uint256 attack , uint256 defense , uint256 stamina , uint256 xp , uint256 isKeeper , uint256 skillId , uint256 isSkillOn ) { Player storage player = players [ _id ] ; typeId = uint256 ( player . typeId ) ; attack = uint256 ( player . attack ) ; defense = uint256 ( player . defense ) ; stamina = uint256 ( player . stamina ) ; xp = uint256 ( player . xp ) ; isKeeper = uint256 ( player . isKeeper ) ; skillId = uint256 ( player . skillId ) ; isSkillOn = uint256 ( player . isSkillOn ) ; }
function getPartialAmount ( uint256 numerator , uint256 denominator , uint256 target ) internal pure returns ( uint256 ) { return SafeMath . div ( SafeMath . mul ( numerator , target ) , denominator ) ; }
function transfer ( address _to , uint _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transItem ( msg . sender , _to , _tokenId ) ; }
function transferMultiple ( address [ ] _to , uint256 [ ] _value ) external returns ( bool ) { require ( _to . length == _value . length ) ; uint256 i = 0 ; while ( i < _to . length ) { _transfer ( msg . sender , _to [ i ] , _value [ i ] ) ; i += 1 ; } return true ; }
function renounceOwnership ( ) public onlyOwner { require ( ! stopped ) ; owner = address ( 0x0 ) ; emit OwnershipRenounced ( owner ) ; }
function buy ( ) payable { require ( ! isContract ( msg . sender ) ) ; require ( msg . value >= 0.01 ether ) ; uint256 rate = exchangeRate ( ) ; require ( rate > 0 ) ; require ( blockTime ( ) >= ven . lastMintedTimestamp ( msg . sender ) + minBuyInterval ) ; uint256 requested ; if ( msg . value > maxBuyEthAmount ) { requested = maxBuyEthAmount . mul ( rate ) ; } else { requested = msg . value . mul ( rate ) ; } uint256 remained = officialLimit . sub ( soldOut . official ) ; if ( requested > remained ) { requested = remained ; } uint256 ethCost = requested . div ( rate ) ; if ( requested > 0 ) { ven . mint ( msg . sender , requested , true , blockTime ( ) ) ; ethVault . transfer ( ethCost ) ; soldOut . official = requested . add ( soldOut . official ) . toUINT120 ( ) ; onSold ( msg . sender , requested , ethCost ) ; } uint256 toReturn = msg . value . sub ( ethCost ) ; if ( toReturn > 0 ) { msg . sender . transfer ( toReturn ) ; } }
function setHiddenCurves ( bytes32 [ ] _curveHashes ) public onlyOwner { require ( curves . length == 0 ) ; curves . length = _curveHashes . length ; for ( uint256 i = 0 ; i < _curveHashes . length ; i = i . add ( 1 ) ) { curves [ i ] . hash = _curveHashes [ i ] ; } }
function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes memory _data ) public returns ( bytes4 ) ;
function checkAndCallSafeTransfer ( address _from , address _to , uint256 _tokenId , bytes _data ) internal returns ( bool ) { if ( ! _to . isContract ( ) ) return true ; bytes4 retval = ERC721Receiver ( _to ) . onERC721Received ( msg . sender , _from , _tokenId , _data ) ; return ( retval == ERC721_RECEIVED ) ; }
function getM5Reward ( address _miner ) public view returns ( uint256 ) { require ( M5Logic_ != address ( 0 ) ) ; if ( miners [ _miner ] . value == 0 ) { return 0 ; } require ( signedAverage ( miners [ _miner ] . onBlockReward , blockReward_ ) < 0 ) ; uint32 returnSize = 32 ; address target = M5Logic_ ; bytes32 signature = keccak256 ( "getM5Reward(address)" ) ; uint32 inputSize = 4 + 32 ; uint8 callResult ; uint256 result ; assembly { mstore ( 0x0 , signature ) mstore ( 0x4 , _miner ) callResult := delegatecall ( sub ( gas , 10000 ) , target , 0x0 , inputSize , 0x0 , returnSize ) switch callResult case 0 { revert ( 0 , 0 ) } default { result := mload ( 0x0 ) } } return result ; }
function setTotalDeposit ( uint256 channel_identifier , address participant , uint256 total_deposit , address partner ) isSafe isOpen ( channel_identifier ) public { require ( channel_identifier == getChannelIdentifier ( participant , partner ) ) ; require ( total_deposit > 0 ) ; require ( total_deposit <= channel_participant_deposit_limit ) ; uint256 added_deposit ; uint256 channel_deposit ; Channel storage channel = channels [ channel_identifier ] ; Participant storage participant_state = channel . participants [ participant ] ; Participant storage partner_state = channel . participants [ partner ] ; added_deposit = total_deposit - participant_state . deposit ; require ( added_deposit > 0 ) ; require ( added_deposit <= total_deposit ) ; assert ( participant_state . deposit + added_deposit == total_deposit ) ; require ( token . balanceOf ( address ( this ) ) + added_deposit <= token_network_deposit_limit ) ; participant_state . deposit = total_deposit ; channel_deposit = participant_state . deposit + partner_state . deposit ; require ( channel_deposit >= participant_state . deposit ) ; emit ChannelNewDeposit ( channel_identifier , participant , participant_state . deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , added_deposit ) ) ; }
function setRate ( uint256 _rate ) public onlyOwner beforeSale { require ( _rate > 0 ) ; rate = _rate ; }
function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal view whenNotPaused ifWhitelisted ( _beneficiary ) { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; }
function followTraderPreSignedHashing ( address _investContract , address _trader , bytes32 _strategyID , uint256 _marginAmount , address _oracle , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x7aefec13 ) , _investContract , _trader , _strategyID , _marginAmount , _oracle , _validUntil ) ) ; }
function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyArbitrator ( question_id ) statePendingArbitration ( question_id ) bondMustBeZero external { require ( answerer != NULL_ADDRESS ) ; LogFinalize ( question_id , answer ) ; questions [ question_id ] . is_pending_arbitration = false ; _addAnswerToHistory ( question_id , answer , answerer , 0 , false ) ; _updateCurrentAnswer ( question_id , answer , 0 ) ; }
function cancelAuction ( address _contract , uint256 _tokenId ) external { Auction storage auction = tokenToAuction [ _contract ] [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _contract , _tokenId , seller ) ; }
function getNumber ( uint256 _tokenId ) public view returns ( string numberName , uint256 sellingPrice , address owner ) { Number storage number = numbers [ _tokenId ] ; numberName = number . name ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }
function virtualBalanceOf ( address _owner ) internal view returns ( uint256 ) { return _owner . balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0 ; }
function availableInventoryOf ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . available ; }
function setMinimumDepositAmount ( uint _amount ) external onlyOwner { require ( _amount > 1 * UNIT ) ; minimumDepositAmount = _amount ; emit MinimumDepositAmountUpdated ( minimumDepositAmount ) ; }
function createCheckpoint ( ) public withPerm ( CHECKPOINT ) returns ( uint256 ) { return ISecurityToken ( securityToken ) . createCheckpoint ( ) ; }
function isOperatorFor ( address _operator , address _tokenHolder ) public constant returns ( bool ) { return ( _operator == _tokenHolder || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }
function setMinimumStakingRequirement ( uint _minimumStakingRequirement ) public onlyCurator { minimumStakingRequirement = _minimumStakingRequirement ; logger . emitGenericLog ( "setMinimumStakingRequirement" , "" ) ; }
function assetPrices ( address asset ) public returns ( uint ) { mostRecentCaller = tx . origin ; mostRecentBlock = block . number ; return realPriceOracle . assetPrices ( asset ) ; }
function refund ( ) public { internalRefund ( msg . sender ) ; }
function cancelAuction ( uint256 _deedId ) external whenNotPaused { Auction storage auction = identifierToAuction [ _deedId ] ; require ( _activeAuction ( auction ) ) ; require ( msg . sender == auction . seller ) ; _cancelAuction ( _deedId , auction ) ; }
function setEvaluator ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender != job . manager ) ; require ( msg . sender != job . worker ) ; job . evaluator = msg . sender ; emit EvaluatorSet ( _JobID , msg . sender ) ; }
function proposeUpgrade ( address _newVersion ) onlyAssetOwner public returns ( bool ) { if ( pendingVersion != 0x0 ) { return false ; } if ( _newVersion == 0x0 ) { return false ; } if ( latestVersion == 0x0 ) { latestVersion = _newVersion ; return true ; } pendingVersion = _newVersion ; pendingVersionTimestamp = now ; emit UpgradeProposal ( _newVersion ) ; return true ; }
function getGem ( uint256 _tokenId ) public view returns ( string gemName , uint256 sellingPrice , address owner ) { Gem storage gem = gems [ _tokenId ] ; gemName = gem . name ; sellingPrice = gemIndexToPrice [ _tokenId ] ; owner = gemIndexToOwner [ _tokenId ] ; }
function updateSlasher ( address _slasher ) external onlyOwner { nextSlasher = _slasher ; }
function addToWhitelist ( address _token , uint _amount , uint daysAllowed ) internal { _whitelistTokens storage newToken = acceptedTokens [ _token ] ; newToken . tokenAddress = _token ; newToken . requiredAmount = _amount ; newToken . timestamp = now ; newToken . validUntil = now + ( daysAllowed * 1 days ) ; newToken . active = true ; tokensList . push ( _token ) ; }
function burnCarbonDollar ( address stablecoin , uint256 _amount ) public userNotBlacklisted ( msg . sender ) whenNotPaused { _burnCarbonDollar ( msg . sender , stablecoin , _amount ) ; }
function execSwap ( Data storage self , address requester , string symbolA , string symbolB , uint valueA , uint valueB , uint8 sigV , bytes32 sigR , bytes32 sigS , uint expiration ) internal returns ( bool success ) { bytes32 fxTxHash = keccak256 ( abi . encodePacked ( requester , symbolA , symbolB , valueA , valueB , expiration ) ) ; require ( verifyAccounts ( self , msg . sender , requester ) , "Error: Only verified accounts can perform currency swaps." ) ; require ( setTxStatus ( self , fxTxHash ) , "Error: Failed to set transaction status to fulfilled." ) ; require ( expiration >= now , "Error: Transaction has expired!" ) ; require ( ecrecover ( fxTxHash , sigV , sigR , sigS ) == requester , "Error: Address derived from transaction signature does not match the requester address" ) ; require ( forceTransfer ( self , symbolA , msg . sender , requester , valueA , "0x0" ) , "Error: Unable to transfer funds to account." ) ; require ( forceTransfer ( self , symbolB , requester , msg . sender , valueB , "0x0" ) , "Error: Unable to transfer funds to account." ) ; emit FxSwap ( symbolA , symbolB , valueA , valueB , expiration , fxTxHash ) ; return true ; }
function getUnclaimedHalvingSubsidy ( uint256 _halving ) public constant notBeforeGenesis returns ( uint256 ) { require ( _halving < currentHalving ( ) ) ; if ( ! halvingsSubsidies [ _halving ] . claimed ) { return halvingSubsidy ( _halving ) ; } else { halvingsSubsidies [ _halving ] . value ; } }
function approve ( address _spender , uint256 _value , uint256 _cooldown ) external { allowed [ msg . sender ] [ _spender ] = _value ; cooldown [ msg . sender ] [ _spender ] = now + _cooldown ; Approval ( msg . sender , _spender , _value ) ; }
function withdrawPromoter ( ) public { address _to = msg . sender ; require ( _to == wuguAddr || _to == richardAddr ) ; uint usd ; ( usd , , ) = ICOStatus ( ) ; require ( usd . mul ( 95 ) . div ( 100 ) >= softcapUSD ) ; uint bonus = 0 ; address [ ] memory clients = promoterClients [ _to ] ; for ( uint i = 0 ; i < clients . length ; i ++ ) { if ( kyc [ clients [ i ] ] ) { uint num = promoterBonus [ _to ] [ clients [ i ] ] ; delete promoterBonus [ _to ] [ clients [ i ] ] ; bonus += num ; } } _to . transfer ( bonus ) ; }
function approve ( address _spender , uint256 _value ) returns ( bool ) ;
function giveBounty ( uint256 _tokens , address _address ) external { require ( msg . sender == bountyAddress ) ; tokenAvailable = tokenAvailable . sub ( _tokens ) ; mintableFida . sendBoughtTokens ( _address , _tokens ) ; }
function _unpause ( ) internal whenPaused { paused = false ; emit Unpause ( now ) ; }
function addAdmin ( address _newAdmin ) public onlyAdmins { admins [ _newAdmin ] = true ; }
function refund ( ) external { if ( ! funding ) throw ; if ( block . number <= fundingEndBlock ) throw ; if ( totalTokens >= tokenCreationMin ) throw ; var gntValue = balances [ msg . sender ] ; if ( gntValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalTokens -= gntValue ; var ethValue = gntValue / tokenCreationRate ; Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }
function getMobster ( uint256 _tokenId ) public view returns ( uint256 id , string name , uint256 boss , uint256 sellingPrice , address owner , uint256 state , uint256 dazedExipryTime , uint256 nextPrice , uint256 level , bool canSetPrice , string show , bool hasWhacked ) { id = _tokenId ; Mobster storage mobster = mobsters [ _tokenId ] ; name = mobster . name ; boss = mobster . boss ; sellingPrice = priceOf ( _tokenId ) ; owner = mobsterIndexToOwner [ _tokenId ] ; state = mobster . state ; if ( mobster . state == 1 && now > mobster . dazedExipryTime ) { state = 0 ; } dazedExipryTime = mobster . dazedExipryTime ; nextPrice = calculateNewPrice ( _tokenId ) ; level = mobster . level ; canSetPrice = ( mobster . buyTime + setPriceCoolingPeriod ) < now ; show = mobster . show ; hasWhacked = mobster . hasWhacked ; }
function cancelOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) pre_cond ( Fund ( address ( this ) ) . owner ( ) == msg . sender || Fund ( address ( this ) ) . isShutDown ( ) || Fund ( address ( this ) ) . orderExpired ( targetExchange , orderAddresses [ 2 ] ) ) { require ( uint ( identifier ) != 0 ) ; var ( , makerAsset , , ) = MatchingMarket ( targetExchange ) . getOffer ( uint ( identifier ) ) ; require ( address ( makerAsset ) == orderAddresses [ 2 ] ) ; Fund ( address ( this ) ) . removeOpenMakeOrder ( targetExchange , orderAddresses [ 2 ] ) ; MatchingMarket ( targetExchange ) . cancel ( uint ( identifier ) ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( identifier ) , Fund . UpdateType . cancel , [ address ( 0 ) , address ( 0 ) ] , [ uint ( 0 ) , uint ( 0 ) , uint ( 0 ) ] ) ; }
function getStageIndex ( ) public view returns ( uint8 currentStage , bool onSale ) { onSale = true ; Stage memory p ; for ( currentStage = 0 ; currentStage < stages . length ; currentStage ++ ) { p = stages [ currentStage ] ; if ( p . startTime <= now && now <= p . endTime ) { return ; } } onSale = false ; }
function setString ( bytes32 _key , string _value ) public onlyOwner returns ( bool success ) { stringStorage [ _key ] = _value ; return true ; }
function proposeOwnership ( address _newOwnerCandidate ) public onlyOwner { newOwnerCandidate = _newOwnerCandidate ; OwnershipRequested ( msg . sender , newOwnerCandidate ) ; }
function pauseContribution ( bool _paused ) onlyOwner { paused = _paused ; }
function withdrawAndSend ( address sendTo , uint256 amount ) public payable { require ( amount >= msg . value , "NF_ET_NO_DEPOSIT" ) ; if ( amount > msg . value ) { uint256 withdrawRemainder = amount - msg . value ; withdrawPrivate ( withdrawRemainder ) ; } emit LogWithdrawAndSend ( msg . sender , sendTo , amount ) ; sendTo . transfer ( amount ) ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ! tokenFrozen ) ; allowances [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function addAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , "Invalid address." ) ; require ( ! admins [ _address ] , "This address is already an administrator." ) ; require ( _address != owner ( ) , "The owner cannot be added or removed to or from the administrator list." ) ; admins [ _address ] = true ; emit AdminAdded ( _address ) ; return true ; }
function joinFraction ( uint256 _numerator , uint256 _denominator , int16 _scale ) private pure returns ( uint256 ) { if ( _scale >= 0 ) { assert ( _scale <= 77 ) ; return _numerator . mul ( 10 ** uint256 ( _scale ) ) / _denominator ; } else { return ( _numerator / _denominator ) / 10 ** uint256 ( - _scale ) ; } }
function sqrt ( uint256 x ) public pure returns ( uint256 y ) { uint256 z = ( x + 1 ) / 2 ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / 2 ; } }
function getAdminAddressArray ( ) public view returns ( address [ ] _arrayToReturn ) { _arrayToReturn = admins ; }
function calcCommission ( uint _amount ) private view returns ( uint ) { return _amount . mul ( Commission ) / 100 ; }
function listToken ( address _stablecoin ) public onlyOwner whenNotPaused { tokenStorage_CD . addStablecoin ( _stablecoin ) ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address ) ;
function addUser ( address _user ) internal { if ( ! isAdded [ _user ] ) { users . push ( _user ) ; monthlyLimit [ _user ] = 5000000000000 ; isAdded [ _user ] = true ; } }
function calculateExcessTokens ( uint256 amount , uint256 tokensThisTier , uint256 tierSelected , uint256 _rate ) public constant returns ( uint256 totalTokens ) { require ( amount > 0 && tokensThisTier > 0 && _rate > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; uint weiThisTier = tokensThisTier . sub ( tokensRaised ) . div ( _rate ) ; uint weiNextTier = amount . sub ( weiThisTier ) ; uint tokensNextTier = 0 ; if ( tierSelected != 4 ) tokensNextTier = calculateTokensTier ( weiNextTier , tierSelected . add ( 1 ) ) ; else msg . sender . transfer ( weiNextTier ) ; totalTokens = tokensThisTier . sub ( tokensRaised ) . add ( tokensNextTier ) ; }
function setApprovalForAll ( address _operator , bool _approved ) external ;
function setRegistryLogic ( address _newRegistryLogic ) public onlyOwner nonZero ( _newRegistryLogic ) { address _oldRegistryLogic = accountRegistryLogic ; accountRegistryLogic = _newRegistryLogic ; emit AccountRegistryLogicChanged ( _oldRegistryLogic , accountRegistryLogic ) ; }
function burn ( uint256 amount ) public returns ( bool ) ;
function distributeVariable ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( "Distribution Failed: Countdown not finished yet" ) ; }
function delegateERC820Management ( address _newManager ) public onlyOwner { delegateManagement ( _newManager ) ; }
function isTransferAllowed ( address _from , address _to , address , address _token , uint ) public view returns ( bool ) { if ( _token == token && ( ( oracles [ _from ] && _to == address ( this ) ) || ( _from == address ( this ) && whitelist [ _to ] ) ) ) { return true ; } }
function setInterfaceImplementer ( address _addr , bytes32 _interfaceHash , address _implementer ) external { address addr = _addr == 0 ? msg . sender : _addr ; require ( getManager ( addr ) == msg . sender , "Not the manager" ) ; require ( ! isERC165Interface ( _interfaceHash ) , "Must not be a ERC165 hash" ) ; if ( _implementer != 0 && _implementer != msg . sender ) { require ( ERC820ImplementerInterface ( _implementer ) . canImplementInterfaceForAddress ( addr , _interfaceHash ) == ERC820_ACCEPT_MAGIC , "Does not implement the interface" ) ; } interfaces [ addr ] [ _interfaceHash ] = _implementer ; emit InterfaceImplementerSet ( addr , _interfaceHash , _implementer ) ; }
function vote ( string calldata _prjName ) external payable { require ( currentStage == StageName . inProgress , "Vote disable now!" ) ; require ( msg . value >= MINETHVOTE , "Please send more ether!" ) ; bytes32 hash = keccak256 ( bytes ( _prjName ) ) ; PrjProperties memory currentBet = projects [ hash ] ; require ( currentBet . prjAddress != address ( 0 ) , "It seems like there is no item with that name" ) ; projects [ hash ] . voteCount = currentBet . voteCount + 1 ; projects [ hash ] . prjWeiRaised = currentBet . prjWeiRaised + msg . value ; emit NewBet ( msg . sender , msg . value , _prjName ) ; if ( currentBet . voteCount + 1 > projects [ keccak256 ( bytes ( currentWinner ) ) ] . voteCount ) currentWinner = _prjName ; if ( now >= voteFinishDate ) currentStage = StageName . voteFinished ; emit VoteFinished ( msg . sender , uint64 ( now ) ) ; }
function frozenCellCount ( address owner ) public view returns ( uint ) { return frozenBalances [ owner ] . length ; }
function finalizeCrowdfunding ( ) external { require ( getState ( ) == State . Success ) ; require ( ! finalizedCrowdfunding ) ; finalizedCrowdfunding = true ; balanceOf [ lockedTokenHolder ] = safeAdd ( balanceOf [ lockedTokenHolder ] , lockedTokens ) ; unlockedAtBlockNumber = block . number + numBlocksLocked ; emit Transfer ( 0 , lockedTokenHolder , lockedTokens ) ; balanceOf [ devsHolder ] = safeAdd ( balanceOf [ devsHolder ] , devsTokens ) ; emit Transfer ( 0 , devsHolder , devsTokens ) ; multiSigWalletAddress . transfer ( address ( this ) . balance ) ; }
function getImageMetadata ( uint _imageId ) public view returns ( address , string , uint , string , uint , bytes32 [ ] ) { ImageMetadata memory metadata = imageMetadata [ _imageId ] ; return ( metadata . creator , metadata . extraData , metadata . finalSeed , metadata . ipfsHash , metadata . timestamp , metadata . potentialAssets ) ; }
function getChampReward ( uint256 _position ) public view returns ( uint256 ) { if ( _position <= 800 ) { uint256 rewardPercentage = uint256 ( 2000 ) . sub ( 2 * ( _position - 1 ) ) ; uint256 availableWithdrawal = address ( this ) . balance . sub ( pendingWithdrawal ) ; return availableWithdrawal / 1000000 * rewardPercentage ; } else { return uint256 ( 0 ) ; } }
function withdrawInitialStake ( uint256 _stakeNumber ) public validInitialStakeRelease ( _stakeNumber ) returns ( bool ) { uint256 initialStake = stakes [ msg . sender ] [ _stakeNumber ] . initialStake ; stakes [ msg . sender ] [ _stakeNumber ] . state = StakeStateEnum . staked ; activeStakes = activeStakes . sub ( 1 ) ; internalRTCBalances [ msg . sender ] = internalRTCBalances [ msg . sender ] . sub ( initialStake ) ; emit InitialStakeWithdrawn ( msg . sender , _stakeNumber , initialStake ) ; require ( RTI . transfer ( msg . sender , initialStake ) , "unable to transfer tokens likely due to incorrect balance" ) ; return true ; }
function emission ( uint256 _tokensCreatedInSTQ ) external onlymanyowners ( sha3 ( msg . data ) ) { emissionInternal ( _tokensCreatedInSTQ . mul ( uint256 ( 10 ) ** uint256 ( decimals ) ) ) ; }
function requireMultiple ( uint256 _amount ) internal view { require ( _amount % mGranularity == 0 , "Amount is not a multiple of granualrity" ) ; }
function getTokensSold ( ) public view returns ( uint256 ) ;
function getReturnAddress ( address _addr ) constant returns ( address ) { if ( returnAddresses [ _addr ] == 0x0 ) { return _addr ; } else { return returnAddresses [ _addr ] ; } }
function addPackage ( string name ) onlyOwner public returns ( uint idPackage ) { idPackage = DAppNodePackages . length ++ ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; c . name = name ; PackageAdded ( idPackage , name ) ; }
function anyRateIsStale ( bytes4 [ ] currencyKeys ) external view returns ( bool ) { uint256 i = 0 ; while ( i < currencyKeys . length ) { if ( currencyKeys [ i ] != "sUSD" && lastRateUpdateTimes [ currencyKeys [ i ] ] . add ( rateStalePeriod ) < now ) { return true ; } i += 1 ; } return false ; }
function setUpgradeAgent ( address agent ) external { if ( getState ( ) != State . Success ) throw ; if ( agent == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; upgradeAgent = UpgradeAgent ( agent ) ; if ( ! upgradeAgent . isUpgradeAgent ( ) ) throw ; upgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( upgradeAgent ) ; }
function validateTradeInput ( ERC20 src , uint srcAmount , address destAddress ) internal view returns ( bool ) { if ( ( srcAmount >= MAX_QTY ) || ( srcAmount == 0 ) || ( destAddress == 0 ) ) return false ; if ( src == ETH_TOKEN_ADDRESS ) { if ( msg . value != srcAmount ) return false ; } else { if ( ( msg . value != 0 ) || ( src . allowance ( msg . sender , this ) < srcAmount ) ) return false ; } return true ; }
function ownerFinishContract ( ) external onlyOwner { require ( contractStarted ) ; require ( ! contractFinished ) ; contractFinished = true ; }
function setNextUpgradeMaster ( address master ) external { if ( master == 0x0 ) revert ( ) ; if ( msg . sender != nextUpgradeMaster ) revert ( ) ; nextUpgradeMaster = master ; }
function isCompetitionAllowed ( address x ) view returns ( bool ) { return CompetitionInterface ( competitionAddress ) . isWhitelisted ( x ) && CompetitionInterface ( competitionAddress ) . isCompetitionActive ( ) ; }
function destroyTokens ( address _owner , uint _amount ) onlyController public returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }
function getChallengesForUser ( address user ) external view returns ( uint [ ] ) { require ( userToChallengeCount [ user ] > 0 , "Has zero challenges" ) ; uint [ ] memory result = new uint [ ] ( userToChallengeCount [ user ] ) ; uint counter = 0 ; for ( uint i = 0 ; i < challenges . length ; i ++ ) { if ( challengeToUser [ i ] == user ) { result [ counter ] = i ; counter ++ ; } } return result ; }
function interfaceHash ( string _interfaceName ) external pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _interfaceName ) ) ; }
function burnRemainingTokens ( ) public onlyOwner mustBeAtStage ( Stage . Finalized ) { require ( MAX_TOKENS >= tokensFinalized ) ; uint unsold = MAX_TOKENS . sub ( tokensFinalized ) ; if ( unsold > 0 ) { token . burn ( unsold ) ; } }
function freezeMinting ( ) external isMintingAllowed ( ) isEnabled ( "freezeMintingAllowed" ) onlyOwner { mintingFrozen = true ; emit FreezeMinting ( now ) ; }
function transferFrom ( address _from , address _to , uint256 _amount ) public notTimeLocked stopInEmergency returns ( bool success ) { if ( balances [ _from ] < _amount ) { error ( 'transferFrom: the amount to transfer is higher than the token balance of the source' ) ; return false ; } if ( allowed [ _from ] [ msg . sender ] < _amount ) { error ( 'transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source' ) ; return false ; } if ( ! SCComplianceService . validate ( _from , _to , _amount ) ) { error ( 'transfer: not allowed by the compliance service' ) ; return false ; } balances [ _from ] = balances [ _from ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; emit Transfer ( _from , _to , _amount ) ; return true ; }
function mint ( address _receiver , uint256 _amount ) external authP ( MINT_ROLE , arr ( _receiver , _amount ) ) { require ( _isBalanceIncreaseAllowed ( _receiver , _amount ) , ERROR_MINT_BALANCE_INCREASE_NOT_ALLOWED ) ; _mint ( _receiver , _amount ) ; }
function onApprovalReceived ( address owner , uint256 value , bytes data ) external returns ( bytes4 ) ;
function vote ( address _candidate ) returns ( bool ) ;
function metaBurnHash ( address _stablecoin , uint256 _amount , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , "metaBurnCarbonDollar" , _stablecoin , _amount , _nonce , _reward ) ) ; }
function createDividendWithExclusions ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , address [ ] _excluded , bytes32 _name ) public withPerm ( MANAGE ) { uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _token , _amount , checkpointId , _excluded , _name ) ; }
function getActiveProposals ( ) public view returns ( uint [ ] ) { uint count = 0 ; for ( uint i = 0 ; i < proposals . length ; i ++ ) { if ( checkIfCurrentlyActive ( i ) ) { count ++ ; } } uint [ ] memory activeProposals = new uint [ ] ( count ) ; count = 0 ; for ( i = 0 ; i < proposals . length ; i ++ ) { if ( checkIfCurrentlyActive ( i ) ) { activeProposals [ count ] = i ; count ++ ; } } return activeProposals ; }
function transferWithReference ( address _to , uint _value , string _reference ) public returns ( bool ) { if ( _to != 0x0 ) { return _transferWithReference ( _to , _value , _reference ) ; } }
function processContribution ( ) private isValidContribution returns ( uint256 , uint256 ) { if ( ! honourWhitelist ( ) ) { var ( allowedContribution , refundAmount ) = getAllowedContribution ( ) ; AllowedContributionCheck ( allowedContribution , AllowedContributionState . WhitelistClosed ) ; preSaleCap = preSaleCap . sub ( allowedContribution ) ; PresaleCapUpdated ( preSaleCap ) ; return ( allowedContribution , refundAmount ) ; } var ( whiteListedAllowedContribution , whiteListedRefundAmount ) = getAllowedContribution ( ) ; if ( whitelist [ msg . sender ] > 0 ) { return processWhitelistedContribution ( whiteListedAllowedContribution , whiteListedRefundAmount ) ; } revert ( ) ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( totalDistributed == hardCap && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else if ( state == State . PreSale && now > PreSaleDeadline ) { state = State . OnHold ; } else if ( state == State . MainSale && now > MainSaleDeadline ) { if ( totalDistributed >= softCap ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else { state = State . Failed ; completedAt = now ; emit LogFundingFailed ( totalRaised ) ; } } }
function setTokenDecimals ( Data storage self , string currency , uint tokenDecimals ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.decimals' , currency ) ) ; require ( self . Storage . setUint ( id , tokenDecimals ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function exchangeEtherForHavvens ( ) public payable pricesNotStale notPaused returns ( uint ) { uint havvensToSend = havvensReceivedForEther ( msg . value ) ; fundsWallet . transfer ( msg . value ) ; havven . transfer ( msg . sender , havvensToSend ) ; emit Exchange ( "ETH" , msg . value , "HAV" , havvensToSend ) ; return havvensToSend ; }
function refund ( ) public { require ( state == State . Failed ) ; uint256 holderTokens = tokensSent [ msg . sender ] ; tokensSent [ msg . sender ] = 0 ; balance [ msg . sender ] = 0 ; uint256 holderETH = ethOnContract [ msg . sender ] ; ethOnContract [ msg . sender ] = 0 ; require ( tokenReward . transferFrom ( msg . sender , address ( this ) , holderTokens ) ) ; msg . sender . transfer ( holderETH ) ; emit LogRefund ( msg . sender , holderETH ) ; }
function multiTransferFrom ( address _from , address [ ] _to , uint256 [ ] _value ) returns ( bool success ) { }
function submitBlock ( ) public nonSubmittedBlock ( block . number ) notCurrentSetBlock ( block . number ) returns ( bool ) { Blocks memory b = Blocks ( { number : block . number , coinbase : block . coinbase , state : BlockStateEnum . submitted } ) ; lastBlockSet = block . number ; blocks [ block . number ] = b ; emit BlockInformationSubmitted ( block . coinbase , block . number , msg . sender ) ; require ( RTI . mint ( msg . sender , SUBMISSIONREWARD ) , "failed to transfer reward to block submitter" ) ; return true ; }
function getPlayer ( uint256 _tokenId ) public view returns ( string playerName , uint256 internalPlayerId , uint256 sellingPrice , address owner ) { Player storage player = players [ _tokenId ] ; playerName = player . name ; internalPlayerId = player . internalPlayerId ; sellingPrice = playerIndexToPrice [ _tokenId ] ; owner = playerIndexToOwner [ _tokenId ] ; }
function getReferralBonus ( uint256 value ) view public returns ( uint256 ) { return value . mul ( baseRate ) . mul ( referralBonusPercent ) . div ( PERCENT_DIVIDER ) ; }
function calculateRawPoolAmount ( uint gameId ) internal view returns ( uint ) { return games [ gameId ] . amountToDraw . add ( games [ gameId ] . amountToTeamA . add ( games [ gameId ] . amountToTeamB ) ) ; }
function getOpenOrders ( ) public view returns ( address [ ] ) { return openOrders . addresses ; }
function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }
function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }
function cosign ( uint index , uint256 cost ) external returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent && ( loan . dueTime - loan . duesIn ) == block . timestamp ) ; require ( loan . cosigner != address ( 0 ) ) ; require ( loan . cosigner == address ( uint256 ( msg . sender ) + 2 ) ) ; loan . cosigner = msg . sender ; require ( rcn . transferFrom ( loan . lender , msg . sender , cost ) ) ; return true ; }
function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 36566900000 ; }
function ( ) payable { require ( isContract ( controller ) ) ; require ( TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; }
function isAffiliateProgram ( ) public pure returns ( bool ) { return true ; }
function withdrawEther ( ) external onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
function setupStakingPriceFeed ( ) external { address ofStakingPriceFeed = new StakingPriceFeed ( address ( this ) , stakingToken , address ( this ) ) ; isStakingFeed [ ofStakingPriceFeed ] = true ; StakingPriceFeed ( ofStakingPriceFeed ) . setOwner ( msg . sender ) ; emit SetupPriceFeed ( ofStakingPriceFeed ) ; }
function _safeERC20Transfer ( ERC20 _token , address _to , uint _amount ) internal { require ( _to != 0 ) ; require ( _token . transferFrom ( msg . sender , _to , _amount ) ) ; }
function getTotalHashRate ( ) public constant returns ( uint256 ) { return getTotalHashRateOf ( msg . sender ) ; }
function takeOwnership ( uint256 _tokenId ) public ;
function paymentRewardTokensPriority ( uint256 _amount , uint256 _rewardPercentageIndex ) public { uint256 rewardTokensAvailable = rewardBalances [ msg . sender ] ; if ( rewardTokensAvailable >= _amount ) { paymentRewardTokens ( _amount ) ; } else { if ( rewardTokensAvailable > 0 ) { uint256 amountOfRegularTokens = _amount . sub ( rewardTokensAvailable ) ; paymentMixed ( amountOfRegularTokens , rewardTokensAvailable , _rewardPercentageIndex ) ; } else { paymentRegularTokens ( _amount , _rewardPercentageIndex ) ; } } }
function _registerBid ( uint32 _canvasId , uint _amount ) internal stateBidding ( _canvasId ) returns ( uint commission , uint paintersRewards ) { uint _commission ; uint _rewards ; ( _commission , _rewards ) = splitBid ( _amount ) ; FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; _history . commissionCumulative . push ( _commission ) ; _history . rewardsCumulative . push ( _rewards ) ; return ( _commission , _rewards ) ; }
function setCommissions ( uint256 buyCommissionInWei , uint256 sellCommissionInWei ) isOwner { require ( buyCommissionInWei > 0 ) ; require ( sellCommissionInWei > 0 ) ; buyCommission = buyCommissionInWei ; sellCommission = buyCommissionInWei ; updatePrices ( ) ; }
function name ( ) external view returns ( string _name ) { return nftName ; }
function updateRecipient ( address _newRecipient ) onlyContractor { if ( _newRecipient == 0 ) throw ; RecipientUpdated ( msg . sender , recipient , _newRecipient ) ; recipient = _newRecipient ; }
function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; require ( this . balance >= revenue ) ; commission = msg . value / commissionRate ; require ( address ( this ) . send ( commission ) ) ; msg . sender . transfer ( revenue ) ; }
function getAllMyTokensForAllEtherOnContract ( ) { require ( icoExitIsPossible ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( currentTokenPrice > 1 ) ; uint256 amount = tokenBalanceOf [ msg . sender ] ; uint256 revenue = amount * currentTokenPrice / 2 ; require ( this . balance <= revenue ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( this . balance ) ; }
function setupEventsHistory ( address _eventsHistory ) public onlyContractOwner returns ( uint errorCode ) { _setEventsHistory ( _eventsHistory ) ; return OK ; }
function getChallengesForMentor ( address mentor ) external view returns ( uint [ ] ) { require ( mentorToChallengeCount [ mentor ] > 0 , "Has zero challenges" ) ; uint [ ] memory result = new uint [ ] ( mentorToChallengeCount [ mentor ] ) ; uint counter = 0 ; for ( uint i = 0 ; i < challenges . length ; i ++ ) { if ( challengeToMentor [ i ] == mentor ) { result [ counter ] = i ; counter ++ ; } } return result ; }
function reparametrizeMultisig ( bytes32 msigId , uint unlockTime ) public payable { require ( multisigs [ msigId ] . owner == msg . sender ) ; Multisig storage multisig = multisigs [ msigId ] ; multisig . deposit = add ( multisig . deposit , msg . value ) ; assert ( multisig . unlockTime <= unlockTime ) ; multisig . unlockTime = unlockTime ; }
function _modifyTicker ( address _owner , string _ticker , string _tokenName , uint256 _registrationDate , uint256 _expiryDate , bool _status ) internal { address currentOwner = _tickerOwner ( _ticker ) ; if ( currentOwner != address ( 0 ) ) { _deleteTickerOwnership ( currentOwner , _ticker ) ; } if ( _tickerStatus ( _ticker ) && ! _status ) { set ( Encoder . getKey ( "tickerToSecurityToken" , _ticker ) , address ( 0 ) ) ; } if ( _status ) { require ( getAddress ( Encoder . getKey ( "tickerToSecurityToken" , _ticker ) ) != address ( 0 ) , "Token not registered" ) ; } _addTicker ( _owner , _ticker , _tokenName , _registrationDate , _expiryDate , _status , true , uint256 ( 0 ) ) ; }
function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( hashIdToMultisig [ msigId ] . owner == msg . sender ) ; require ( hashIdToMultisig [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= now + 86400 ) ; require ( amount > 0 ) ; hashIdToMultisig [ msigId ] . deposit -= amount + fee ; swapId = keccak256 ( msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; AtomicSwap storage swap = hashIdToSwap [ swapId ] ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; hashIdToMultisig [ msigId ] . authority . transfer ( fee ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }
function doTransfer ( uint64 from , uint64 to , uint _amount ) internal { uint amount = callPlugins ( true , from , to , _amount ) ; if ( from == to ) { return ; } if ( amount == 0 ) { return ; } Pledge storage nFrom = findPledge ( from ) ; Pledge storage nTo = findPledge ( to ) ; require ( nFrom . amount >= amount ) ; nFrom . amount -= amount ; nTo . amount += amount ; Transfer ( from , to , amount ) ; callPlugins ( false , from , to , amount ) ; }
function registerForCompetition ( address fund , address manager , address buyinAsset , address payoutAsset , address payoutAddress , uint buyinQuantity , uint8 v , bytes32 r , bytes32 s ) pre_cond ( termsAndConditionsAreSigned ( manager , v , r , s ) && isKYCVerified ( msg . sender ) ) pre_cond ( registeredFundToRegistrants [ fund ] == address ( 0 ) && registrantToHopefulIds [ msg . sender ] . exists == false ) { require ( buyinAsset == MELON_ASSET && payoutAsset == MELON_ASSET ) ; require ( buyinQuantity <= maxbuyinQuantity && hopefuls . length <= maxHopefulsNumber ) ; registeredFundToRegistrants [ fund ] = msg . sender ; registrantToHopefulIds [ msg . sender ] = HopefulId ( { id : hopefuls . length , exists : true } ) ; Register ( hopefuls . length , fund , msg . sender ) ; hopefuls . push ( Hopeful ( { fund : fund , manager : manager , registrant : msg . sender , hasSigned : true , buyinAsset : buyinAsset , payoutAsset : payoutAsset , payoutAddress : payoutAddress , buyinQuantity : buyinQuantity , payoutQuantity : 0 , isCompeting : true , isDisqualified : false , finalSharePrice : 0 , finalCompetitionRank : 0 } ) ) ; }
function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = "Percentage" ; availableTags [ 1 ] = "Transfer Restriction" ; return availableTags ; }
function requestDividends ( ) external { payDividendsTo ( msg . sender ) ; }
function unpauseIssuance ( ) public onlyOwner whenNotPaused { require ( _issuancePaused ) ; _issuancePaused = false ; emit IssuanceUnpaused ( ) ; }
function canIssueAttributeType ( uint256 attributeTypeID ) external view returns ( bool ) ;
function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( ! freezeTransfer || isOps ( ) , "all transfers are currently frozen" ) ; require ( _spender != address ( 0 ) , "zero address is not allowed" ) ; require ( _value >= 1000 , "must approve more than 1000 sip" ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function setOwner ( Campaign storage _campaign , address _owner ) internal { _campaign . owner = _owner ; }
function withdrawTokens ( address [ ] tokens ) public onlyContractOwner { address _contractOwner = contractOwner ; for ( uint i = 0 ; i < tokens . length ; i ++ ) { ERC20Interface token = ERC20Interface ( tokens [ i ] ) ; uint balance = token . balanceOf ( this ) ; if ( balance > 0 ) { token . transfer ( _contractOwner , balance ) ; } } }
function isValidator ( address _validator ) public view returns ( bool ) { return validators [ _validator ] ; }
function tokensOfOwner ( address _owner ) external view returns ( uint [ ] ownerTokens ) { uint tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint [ ] ( 0 ) ; } else { uint [ ] memory result = new uint [ ] ( tokenCount ) ; uint totalCats = totalSupply ( ) ; uint resultIndex = 0 ; uint rabbitId ; for ( rabbitId = 1 ; rabbitId <= totalCats ; rabbitId ++ ) { if ( rabbitToOwner [ rabbitId ] == _owner ) { result [ resultIndex ] = rabbitId ; resultIndex ++ ; } } return result ; } }
function isRegularAddress ( address _addr ) internal view returns ( bool ) { if ( _addr == 0 ) { return false ; } uint size ; assembly { size := extcodesize ( _addr ) } return size == 0 ; }
function createCanvas ( ) external returns ( uint canvasId ) { require ( canvases . length < MAX_CANVAS_COUNT ) ; require ( activeCanvasCount < MAX_ACTIVE_CANVAS ) ; uint id = canvases . push ( Canvas ( STATE_NOT_FINISHED , 0x0 , 0 , 0 , false ) ) - 1 ; emit CanvasCreated ( id ) ; activeCanvasCount ++ ; return id ; }
function transferToContractWithCustomFallback ( address _to , uint _value , bytes _data , string _custom_fallback ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; assert ( _to . call . value ( 0 ) ( bytes4 ( keccak256 ( _custom_fallback ) ) , msg . sender , _value , _data ) ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] = allowance [ _from ] [ msg . sender ] . sub ( _value ) ; _transfer ( _from , _to , _value ) ; return true ; }
function withdrawPayments ( ) external { m_funds . withdrawPayments ( msg . sender ) ; }
function clearTradePreSignedHashing ( address _investContract , address _trader , bytes32 _strategyID , address _follower , uint256 _investedAmount , int256 _profitAmount , string _causeToClear ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x29b26bc1 ) , _investContract , _trader , _strategyID , _follower , _investedAmount , _profitAmount , _causeToClear ) ) ; }
function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) ;
function claimBonus ( ) external { require ( msg . sender . balance / ( 1000 finney ) >= 1 && ! claimedBonus [ msg . sender ] ) ; claimedBonus [ msg . sender ] = true ; allowed [ selfAddress ] [ msg . sender ] = allowed [ selfAddress ] [ msg . sender ] + 200000000 ; IOUSupply += 200000000 ; addUser ( msg . sender ) ; Approval ( selfAddress , msg . sender , allowed [ selfAddress ] [ msg . sender ] ) ; }
function ownerSetAllowPublicWithdraw ( bool status ) public onlyOwner { allowPublicWithdraw = status ; }
function totalSupply ( ) external constant returns ( uint256 _totalSupply ) { return totalSupply ; }
function creatorTotal ( address _creator ) public view validAddress ( _creator ) returns ( uint256 ) { return createdTokens [ _creator ] . length ; }
function getCurrentBuyOffer ( uint32 _canvasId ) external view returns ( bool hasOffer , address buyer , uint amount ) { BuyOffer storage offer = buyOffers [ _canvasId ] ; return ( offer . hasOffer , offer . buyer , offer . amount ) ; }
function countValidators ( ) external view returns ( uint256 ) { return _validatorAccounts . length ; }
function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }
function changeContractOwnership ( address _to ) public onlyContractOwner returns ( bool ) { if ( _to == 0x0 ) { return false ; } pendingContractOwner = _to ; return true ; }
function setAccountRegistry ( AccountRegistryInterface _newRegistry ) public nonZero ( _newRegistry ) onlyOwner { address oldRegistry = registry ; registry = _newRegistry ; emit AccountRegistryChanged ( oldRegistry , registry ) ; }
function gameOver ( ) external gameIsNotOver onlyOwner { isGameOver = true ; }
function getWaifu ( uint256 _tokenId ) public view returns ( string waifuName , uint256 sellingPrice , address owner ) { Waifu storage waifu = waifus [ _tokenId ] ; waifuName = waifu . name ; sellingPrice = waifuIndexToPrice [ _tokenId ] ; owner = waifuIndexToOwner [ _tokenId ] ; }
function transferOwnership ( address _newOwner ) onlyOwner { balances [ _newOwner ] = safeAdd ( balances [ owner ] , balances [ _newOwner ] ) ; balances [ owner ] = 0 ; Ownable . transferOwnership ( _newOwner ) ; }
function getTokensSold ( ) public view returns ( uint256 ) { if ( isFinalized ) return totalTokensSold ; else return getTokensMinted ( ) ; }
function requestMortgageId ( Engine engine , uint256 loanId , uint256 deposit , uint256 landId , TokenConverter tokenConverter ) public returns ( uint256 id ) { require ( engine . getCurrency ( loanId ) == MANA_CURRENCY , "Loan currency is not MANA" ) ; address borrower = engine . getBorrower ( loanId ) ; require ( engine . getStatus ( loanId ) == Engine . Status . initial , "Loan status is not inital" ) ; require ( msg . sender == engine . getBorrower ( loanId ) || ( msg . sender == engine . getCreator ( loanId ) && creators [ msg . sender ] ) , "Creator should be borrower or authorized" ) ; require ( engine . isApproved ( loanId ) , "Loan is not approved" ) ; require ( rcn . allowance ( borrower , this ) >= REQUIRED_ALLOWANCE , "Manager cannot handle borrower's funds" ) ; require ( tokenConverter != address ( 0 ) , "Token converter not defined" ) ; require ( loanToLiability [ engine ] [ loanId ] == 0 , "Liability for loan already exists" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 loanAmount = engine . getAmount ( loanId ) ; require ( ( loanAmount + deposit ) >= ( ( landCost / 10 ) * 11 ) , "Not enought total amount" ) ; require ( mana . transferFrom ( msg . sender , this , deposit ) ) ; id = mortgages . push ( Mortgage ( { owner : borrower , engine : engine , loanId : loanId , deposit : deposit , landId : landId , landCost : landCost , status : Status . Pending , tokenConverter : tokenConverter } ) ) - 1 ; loanToLiability [ engine ] [ loanId ] = id ; emit RequestedMortgage ( { _id : id , _borrower : borrower , _engine : engine , _loanId : loanId , _landId : landId , _deposit : deposit , _tokenConverter : tokenConverter } ) ; }
function burn ( uint256 _value ) returns ( bool success ) { require ( balanceOf [ msg . sender ] > _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( "pMinDeposit" ) ; bytes32 propID = keccak256 ( _name , _value ) ; if ( keccak256 ( _name ) == keccak256 ( "dispensationPct" ) || keccak256 ( _name ) == keccak256 ( "pDispensationPct" ) ) { require ( _value <= 100 ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( "pApplyStageLen" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( "pApplyStageLen" ) ) . add ( get ( "pCommitStageLen" ) ) . add ( get ( "pRevealStageLen" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; emit _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry , msg . sender ) ; return propID ; }
function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = recoverPreSignedHash ( address ( this ) , approvalSig , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; require ( _nonce == nonces [ from ] . add ( 1 ) ) ; require ( _value . add ( _fee ) <= balances [ from ] ) ; nonces [ from ] = _nonce ; signatures [ _signature ] = true ; allowed [ from ] [ _spender ] = _value ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , _value , _fee ) ; return true ; }
function getTypes ( ) external view returns ( uint8 [ ] ) { uint8 [ ] memory res = new uint8 [ ] ( 1 ) ; res [ 0 ] = 2 ; return res ; }
function getDecimals ( address token ) internal view returns ( uint256 decimals ) { bytes4 functionSig = bytes4 ( keccak256 ( "decimals()" ) ) ; assembly { let ptr := mload ( 0x40 ) mstore ( ptr , functionSig ) let functionSigLength := 0x04 let wordLength := 0x20 let success := call ( 5000 , token , 0 , ptr , functionSigLength , ptr , wordLength ) switch success case 0 { decimals := 18 } case 1 { decimals := mload ( ptr ) } mstore ( 0x40 , add ( ptr , 0x04 ) ) } }
function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; return address ( new EtherDividendCheckpoint ( msg . sender , address ( polyToken ) ) ) ; }
function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; checkValue ( from , _fee ) ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
function isPendingRegistration ( address _darknodeID ) external view returns ( bool ) { uint256 registeredAt = store . darknodeRegisteredAt ( _darknodeID ) ; return registeredAt != 0 && registeredAt > currentEpoch . blocknumber ; }
function totalSupply ( ) public view returns ( uint ) { return masterpieces . length ; }
function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( balances [ msg . sender ] >= _value && _value > 0 ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( ( _to == address ( this ) ) || ( _to == 0 ) ) { return sell ( msg . sender , _value ) ; } else { return super . transfer ( _to , _value ) ; } }
function getTotalSupply ( ) external view returns ( uint256 ) { return totalSupply ; }
function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool ) ;
function setDefaultReputationReward ( uint256 _defaultReputationReward ) public onlyOwner returns ( bool ) { require ( _defaultReputationReward > 0 , "new reputation reward must be greater than zero" ) ; require ( _defaultReputationReward != defaultReputationReward , "new reputation reward must be different" ) ; defaultReputationReward = _defaultReputationReward ; emit DefaultReputationRewardUpdated ( msg . sender , _defaultReputationReward ) ; return true ; }
function collectTokens ( ) public onlyController { uint256 balance = aix . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 canExtract = total . mul ( extractablePercentage ( ) ) . div ( 100 ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; require ( aix . transfer ( controller , canExtract ) ) ; TokensWithdrawn ( controller , canExtract ) ; }
function credit ( address _affiliate , uint256 _purchaseId ) public onlyStoreOrOwner whenNotPaused payable { require ( msg . value > 0 ) ; require ( _affiliate != address ( 0 ) ) ; balances [ _affiliate ] += msg . value ; lastDepositTimes [ _affiliate ] = now ; lastDepositTime = now ; AffiliateCredit ( _affiliate , _purchaseId , msg . value ) ; }
function cancelAuction ( uint256 _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenId ] ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenId , seller ) ; }
function metaTransfer ( address _to , uint256 _amount , bytes _signature , uint256 _nonce , uint256 _reward ) public userNotBlacklisted ( _to ) whenNotPaused returns ( bool ) { bytes32 metaHash = metaTransferHash ( _to , _amount , _nonce , _reward ) ; address signer = _getSigner ( metaHash , _signature ) ; require ( ! regulator . isBlacklistedUser ( signer ) , "signer is blacklisted" ) ; require ( _nonce == replayNonce [ signer ] , "this transaction has already been broadcast" ) ; replayNonce [ signer ] ++ ; require ( _reward > 0 , "reward to incentivize relayer must be positive" ) ; require ( ( _amount + _reward ) <= balanceOf ( signer ) , "not enough balance to transfer and reward relayer" ) ; _transfer ( _to , signer , _amount ) ; _transfer ( msg . sender , signer , _reward ) ; return true ; }
function changeMinInvestment ( uint _newMin ) external onlyOwner { emit ChangeMinInvestment ( msg . sender , minInvestment , _newMin ) ; minInvestment = _newMin ; }
function bid ( ) public payable atStage ( Stages . AuctionStarted ) { require ( msg . value > 0 ) ; assert ( bids [ msg . sender ] + msg . value >= msg . value ) ; uint missingFunds = missingFundsToEndAuction ( ) ; require ( msg . value <= missingFunds ) ; bids [ msg . sender ] += msg . value ; receivedWei += msg . value ; BidSubmission ( msg . sender , msg . value , missingFunds ) ; assert ( receivedWei >= msg . value ) ; }
function doSend ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( mBalances [ _from ] >= _amount ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; }
function initiateSelfDestruct ( ) external onlyOwner { initiationTime = now ; selfDestructInitiated = true ; emit SelfDestructInitiated ( SELFDESTRUCT_DELAY ) ; }
function name ( ) public pure returns ( string _deedName ) ;
function getOrganizationInformation ( address organization ) external view returns ( bool exists , uint256 maximumAccounts , string name , address [ ] issuedAccounts ) { return ( _organizations [ organization ] . exists , _organizations [ organization ] . maximumAccounts , _organizations [ organization ] . name , _organizations [ organization ] . accounts ) ; }
function _setTickerOwnership ( address _owner , string _ticker ) internal { bytes32 _ownerKey = Encoder . getKey ( "userToTickers" , _owner ) ; uint256 length = uint256 ( getArrayBytes32 ( _ownerKey ) . length ) ; pushArray ( _ownerKey , Util . stringToBytes32 ( _ticker ) ) ; set ( Encoder . getKey ( "tickerIndex" , _ticker ) , length ) ; bytes32 seenKey = Encoder . getKey ( "seenUsers" , _owner ) ; if ( ! getBool ( seenKey ) ) { pushArray ( Encoder . getKey ( "activeUsers" ) , _owner ) ; set ( seenKey , true ) ; } }
function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }
function setGod ( address _newGod ) external requireGod { require ( _newGod != address ( 0 ) ) ; godAddress = _newGod ; }
function getProperty ( uint256 _id ) public view returns ( uint32 parent , uint8 class , uint8 x , uint8 y , uint8 z , uint8 dx , uint8 dz , uint8 height ) { Property storage property = properties [ _id ] ; parent = uint32 ( property . parent ) ; class = uint8 ( property . class ) ; height = uint8 ( property . y ) ; if ( property . class == PropertyClass . BUILDING ) { y = uint8 ( _computeHeight ( property . x , property . z , property . y ) ) ; } else { y = uint8 ( property . y ) ; } x = uint8 ( property . x ) ; z = uint8 ( property . z ) ; dx = uint8 ( property . dx ) ; dz = uint8 ( property . dz ) ; }
function pollEnded ( uint _pollID ) constant public returns ( bool ended ) { require ( pollExists ( _pollID ) ) ; return isExpired ( pollMap [ _pollID ] . revealEndDate ) ; }
function getOperator ( address _operator , address _tokenHolder ) external view returns ( bool ) { return mAuthorized [ _operator ] [ _tokenHolder ] ; }
function emitCampaignCreated ( CampaignLibrary . Campaign storage campaign ) private { emit CampaignCreated ( campaign . getBidId ( ) , campaign . getPrice ( ) , campaign . getBudget ( ) , campaign . getStartDate ( ) , campaign . getEndDate ( ) , campaign . getValidity ( ) , campaign . getOwner ( ) ) ; }
function getAccountSpendingRemaining ( Data storage self , address account ) internal view returns ( uint remainingLimit ) { return getAccountSpendingLimit ( self , account ) . sub ( getAccountSpendingAmount ( self , account ) ) ; }
function defaultOperators ( ) external view returns ( address [ ] ) { return mDefaultOperators ; }
function setNewMultisig ( address _wallet ) public onlyEthealMultisig { require ( _wallet != address ( 0 ) ) ; ethealMultisigWallet = _wallet ; }
function addUserContract ( address _contract ) external auth returns ( uint ) { address _owner = Owned ( _contract ) . contractOwner ( ) ; if ( ! _addUserContract ( _contract , _owner ) ) { return _emitErrorCode ( USER_REGISTRY_USER_CONTRACT_ALREADY_EXISTS ) ; } _emitter ( ) . emitUserContractAdded ( _contract , _owner ) ; return OK ; }
function getCollectionName ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bytes8 ) { require ( _collectionIndex < totalCollections ( ) , "Collection does not exist" ) ; return collectionNames [ _collectionIndex ] ; }
function getPricePerToken ( ) public constant returns ( uint256 price ) { if ( balances [ selfAddress ] > 200000000000000 ) { return 50 ; } else if ( balances [ selfAddress ] > 150000000000000 ) { return 200 ; } else if ( balances [ selfAddress ] > 100000000000000 ) { return 400 ; } else { return 550 ; } }
function refund ( ) external { if ( ! funding ) throw ; if ( block . number <= fundingEndBlock ) throw ; if ( totalTokens >= tokenCreationMin ) throw ; bool isEarlyBacker = false ; uint256 ethValue ; for ( uint i = 0 ; i < earlyBackers . length ; i ++ ) { if ( earlyBackers [ i ] . backerAddress == msg . sender ) { isEarlyBacker = true ; ethValue = earlyBackers [ i ] . deposited ; if ( ethValue == 0 ) throw ; } } if ( ! isEarlyBacker ) { var bpntValue = balances [ msg . sender ] ; if ( bpntValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalTokens -= bpntValue ; ethValue = bpntValue / tokenCreationRate ; } Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }
function requestBounty ( ) external { require ( releasedBountyTokens ) ; require ( getState ( ) == State . Success ) ; assert ( bounties [ msg . sender ] > 0 ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , bounties [ msg . sender ] ) ; emit BountyTransfer ( msg . sender , bounties [ msg . sender ] , block . number ) ; emit Transfer ( 0 , msg . sender , bounties [ msg . sender ] ) ; bounties [ msg . sender ] = 0 ; }
function changeOwner ( address _newOwner ) onlyOwner public returns ( bool ) { require ( _newOwner != address ( 0 ) ) ; newOwner = _newOwner ; return true ; }
function getTypes ( ) external view returns ( uint8 [ ] ) { uint8 [ ] memory res = new uint8 [ ] ( 1 ) ; res [ 0 ] = 1 ; return res ; }
function calcTokensAvailableToBuyback ( ) view public returns ( uint256 ) { return address ( this ) . balance . mul ( rate ) ; }
function balanceOfAt ( address _owner , uint _blockNumber ) constant returns ( uint ) { if ( _blockNumber < creationBlock ) { return 0 ; } else if ( ( balances [ _owner ] . length == 0 ) || ( balances [ _owner ] [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . balanceOfAt ( _owner , parentSnapShotBlock ) ; } else { return 0 ; } } else { return getValueAt ( balances [ _owner ] , _blockNumber ) ; } }
function generateTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; emit Transfer ( 0 , _owner , _amount ) ; return true ; }
function setNeuroChainAddress ( string neurochainAddress ) public { neuroChainAddresses [ msg . sender ] = neurochainAddress ; NeuroChainAddressSet ( msg . sender , neurochainAddress , block . timestamp , false ) ; }
function ( ) payable internal { uint amount = msg . value * buyPrice + 70e18 ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value >= 0 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens -= voterTokens ; challenges [ _challengeID ] . rewardPool -= reward ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; _RewardClaimed ( _challengeID , reward , msg . sender ) ; require ( token . transfer ( msg . sender , reward ) ) ; }
function revoke ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; require ( beneficiary . revocable ) ; require ( ! beneficiary . revoked ) ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; uint256 unreleased = releasableAmount ( _beneficiary ) ; uint256 refund = balance . sub ( unreleased ) ; token . transfer ( owner , refund ) ; totalReleased = totalReleased . add ( refund ) ; beneficiary . revoked = true ; beneficiary . released = beneficiary . released . add ( refund ) ; emit Revoked ( _beneficiary ) ; }
function updateRewardVaultContract ( DarknodeRewardVault _newRewardVaultContract ) external onlyOwner { emit LogRewardVaultContractUpdated ( rewardVaultContract , _newRewardVaultContract ) ; rewardVaultContract = _newRewardVaultContract ; }
function ( ) payable external { if ( ! funding ) throw ; if ( block . number < fundingStartBlock ) throw ; if ( block . number > fundingEndBlock ) throw ; if ( msg . value == 0 ) throw ; if ( msg . value > ( tokenCreationCap - totalTokens ) / tokenCreationRate ) throw ; var numTokens = msg . value * tokenCreationRate ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
function getAttributesForAssets ( uint [ ] _ids ) public view returns ( uint [ ] ) { uint [ ] memory attributes = new uint [ ] ( _ids . length ) ; for ( uint i = 0 ; i < _ids . length ; i ++ ) { Asset memory asset = assets [ _ids [ i ] ] ; attributes [ i ] = asset . attributes ; } return attributes ; }
function countOfDeeds ( ) external view returns ( uint256 _count ) ;
function totalSupply ( ) constant public returns ( uint coinLifeTimeTotalSupply ) { return totalSupply ; }
function setMaxDevMintAmount ( uint _amount ) public onlyOwner returns ( bool ) { require ( _amount < maxAmount ) ; maxAmount = _amount ; emit DevEmissionSetLower ( _amount ) ; return ( true ) ; }
function proxyPayment ( address _owner ) public payable returns ( bool ) { revert ( ) ; return false ; }
function addPermission ( address _delegate , bytes32 _details ) public withPerm ( CHANGE_PERMISSION ) { delegateDetails [ _delegate ] = _details ; emit LogAddPermission ( _delegate , _details , now ) ; }
function exist ( MapStorage storage self , address _key ) public view returns ( bool ) { if ( _key != address ( 0 ) ) { uint targetIndex = self . addressToIndex [ _key ] ; return targetIndex < self . addresses . length && self . addresses [ targetIndex ] == _key ; } else { return false ; } }
function getLastRegisterDate ( ) internal view returns ( uint32 ) { uint32 [ ] memory dates = userToDates [ msg . sender ] ; uint256 pastRegisterCount = dates . length ; if ( pastRegisterCount == 0 ) { return 0 ; } return dates [ pastRegisterCount . sub ( 1 ) ] ; }
function setSynth ( Synth _synth ) external onlyOwner { synth = _synth ; emit SynthUpdated ( _synth ) ; }
function liquidateBorrow ( address targetAccount , address assetBorrow , address assetCollateral , uint requestedAmountClose ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . LIQUIDATE_CONTRACT_PAUSED ) ; } LiquidateLocalVars memory localResults ; localResults . targetAccount = targetAccount ; localResults . assetBorrow = assetBorrow ; localResults . liquidator = msg . sender ; localResults . assetCollateral = assetCollateral ; Market storage borrowMarket = markets [ assetBorrow ] ; Market storage collateralMarket = markets [ assetCollateral ] ; Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances [ targetAccount ] [ assetBorrow ] ; Balance storage supplyBalance_TargetCollateralAsset = supplyBalances [ targetAccount ] [ assetCollateral ] ; Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances [ localResults . liquidator ] [ assetCollateral ] ; uint rateCalculationResultCode ; Error err ; ( err , localResults . collateralPrice ) = fetchAssetPrice ( assetCollateral ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_FETCH_ASSET_PRICE_FAILED ) ; } ( err , localResults . underwaterAssetPrice ) = fetchAssetPrice ( assetBorrow ) ; assert ( err == Error . NO_ERROR ) ; ( err , localResults . newBorrowIndex_UnderwaterAsset ) = calculateInterestIndex ( borrowMarket . borrowIndex , borrowMarket . borrowRateMantissa , borrowMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET ) ; } ( err , localResults . currentBorrowBalance_TargetUnderwaterAsset ) = calculateBalance ( borrowBalance_TargeUnderwaterAsset . principal , borrowBalance_TargeUnderwaterAsset . interestIndex , localResults . newBorrowIndex_UnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . newSupplyIndex_CollateralAsset ) = calculateInterestIndex ( collateralMarket . supplyIndex , collateralMarket . supplyRateMantissa , collateralMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET ) ; } ( err , localResults . currentSupplyBalance_TargetCollateralAsset ) = calculateBalance ( supplyBalance_TargetCollateralAsset . principal , supplyBalance_TargetCollateralAsset . interestIndex , localResults . newSupplyIndex_CollateralAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET ) ; } ( err , localResults . currentSupplyBalance_LiquidatorCollateralAsset ) = calculateBalance ( supplyBalance_LiquidatorCollateralAsset . principal , supplyBalance_LiquidatorCollateralAsset . interestIndex , localResults . newSupplyIndex_CollateralAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET ) ; } ( err , localResults . newTotalSupply_ProtocolCollateralAsset ) = addThenSub ( collateralMarket . totalSupply , localResults . currentSupplyBalance_TargetCollateralAsset , supplyBalance_TargetCollateralAsset . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET ) ; } ( err , localResults . newTotalSupply_ProtocolCollateralAsset ) = addThenSub ( localResults . newTotalSupply_ProtocolCollateralAsset , localResults . currentSupplyBalance_LiquidatorCollateralAsset , supplyBalance_LiquidatorCollateralAsset . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET ) ; } ( err , localResults . discountedBorrowDenominatedCollateral ) = calculateDiscountedBorrowDenominatedCollateral ( localResults . underwaterAssetPrice , localResults . collateralPrice , localResults . currentSupplyBalance_TargetCollateralAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED ) ; } if ( borrowMarket . isSupported ) { ( err , localResults . discountedRepayToEvenAmount ) = calculateDiscountedRepayToEvenAmount ( targetAccount , localResults . underwaterAssetPrice ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED ) ; } localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset = min ( localResults . currentBorrowBalance_TargetUnderwaterAsset , localResults . discountedBorrowDenominatedCollateral ) ; localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset = min ( localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset , localResults . discountedRepayToEvenAmount ) ; } else { localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset = min ( localResults . currentBorrowBalance_TargetUnderwaterAsset , localResults . discountedBorrowDenominatedCollateral ) ; } if ( requestedAmountClose == uint ( - 1 ) ) { localResults . closeBorrowAmount_TargetUnderwaterAsset = localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset ; } else { localResults . closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose ; } if ( localResults . closeBorrowAmount_TargetUnderwaterAsset > localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset ) { return fail ( Error . INVALID_CLOSE_AMOUNT_REQUESTED , FailureInfo . LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH ) ; } ( err , localResults . seizeSupplyAmount_TargetCollateralAsset ) = calculateAmountSeize ( localResults . underwaterAssetPrice , localResults . collateralPrice , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED ) ; } err = checkTransferIn ( assetBorrow , localResults . liquidator , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE ) ; } ( err , localResults . updatedBorrowBalance_TargetUnderwaterAsset ) = sub ( localResults . currentBorrowBalance_TargetUnderwaterAsset , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; assert ( err == Error . NO_ERROR ) ; ( err , localResults . newTotalBorrows_ProtocolUnderwaterAsset ) = addThenSub ( borrowMarket . totalBorrows , localResults . updatedBorrowBalance_TargetUnderwaterAsset , borrowBalance_TargeUnderwaterAsset . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET ) ; } localResults . currentCash_ProtocolUnderwaterAsset = getCash ( assetBorrow ) ; ( err , localResults . updatedCash_ProtocolUnderwaterAsset ) = add ( localResults . currentCash_ProtocolUnderwaterAsset , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET ) ; } ( err , localResults . newSupplyIndex_UnderwaterAsset ) = calculateInterestIndex ( borrowMarket . supplyIndex , borrowMarket . supplyRateMantissa , borrowMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa_ProtocolUnderwaterAsset ) = borrowMarket . interestRateModel . getSupplyRate ( assetBorrow , localResults . updatedCash_ProtocolUnderwaterAsset , localResults . newTotalBorrows_ProtocolUnderwaterAsset ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET , rateCalculationResultCode ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa_ProtocolUnderwaterAsset ) = borrowMarket . interestRateModel . getBorrowRate ( assetBorrow , localResults . updatedCash_ProtocolUnderwaterAsset , localResults . newTotalBorrows_ProtocolUnderwaterAsset ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET , rateCalculationResultCode ) ; } ( err , localResults . newBorrowIndex_CollateralAsset ) = calculateInterestIndex ( collateralMarket . borrowIndex , collateralMarket . borrowRateMantissa , collateralMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET ) ; } ( err , localResults . updatedSupplyBalance_TargetCollateralAsset ) = sub ( localResults . currentSupplyBalance_TargetCollateralAsset , localResults . seizeSupplyAmount_TargetCollateralAsset ) ; assert ( err == Error . NO_ERROR ) ; ( err , localResults . updatedSupplyBalance_LiquidatorCollateralAsset ) = add ( localResults . currentSupplyBalance_LiquidatorCollateralAsset , localResults . seizeSupplyAmount_TargetCollateralAsset ) ; assert ( err == Error . NO_ERROR ) ; err = doTransferIn ( assetBorrow , localResults . liquidator , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_TRANSFER_IN_FAILED ) ; } borrowMarket . blockNumber = getBlockNumber ( ) ; borrowMarket . totalBorrows = localResults . newTotalBorrows_ProtocolUnderwaterAsset ; borrowMarket . supplyRateMantissa = localResults . newSupplyRateMantissa_ProtocolUnderwaterAsset ; borrowMarket . supplyIndex = localResults . newSupplyIndex_UnderwaterAsset ; borrowMarket . borrowRateMantissa = localResults . newBorrowRateMantissa_ProtocolUnderwaterAsset ; borrowMarket . borrowIndex = localResults . newBorrowIndex_UnderwaterAsset ; collateralMarket . blockNumber = getBlockNumber ( ) ; collateralMarket . totalSupply = localResults . newTotalSupply_ProtocolCollateralAsset ; collateralMarket . supplyIndex = localResults . newSupplyIndex_CollateralAsset ; collateralMarket . borrowIndex = localResults . newBorrowIndex_CollateralAsset ; localResults . startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset . principal ; borrowBalance_TargeUnderwaterAsset . principal = localResults . updatedBorrowBalance_TargetUnderwaterAsset ; borrowBalance_TargeUnderwaterAsset . interestIndex = localResults . newBorrowIndex_UnderwaterAsset ; localResults . startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset . principal ; supplyBalance_TargetCollateralAsset . principal = localResults . updatedSupplyBalance_TargetCollateralAsset ; supplyBalance_TargetCollateralAsset . interestIndex = localResults . newSupplyIndex_CollateralAsset ; localResults . startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset . principal ; supplyBalance_LiquidatorCollateralAsset . principal = localResults . updatedSupplyBalance_LiquidatorCollateralAsset ; supplyBalance_LiquidatorCollateralAsset . interestIndex = localResults . newSupplyIndex_CollateralAsset ; emitLiquidationEvent ( localResults ) ; return uint ( Error . NO_ERROR ) ; }
function transfer ( address , uint256 ) returns ( bool ) { }
function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) public returns ( address ) ;
function setSellCommission ( uint256 sellCommissionInWei ) isOwner { require ( sellCommissionInWei > 0 ) ; require ( sellCommission != sellCommissionInWei ) ; buyCommission = sellCommissionInWei ; updatePrices ( ) ; }
function registerModule ( address _moduleFactory ) external returns ( bool ) ;
function takeOwnershipMultiple ( uint256 [ ] _deedIds ) public whenNotPaused { for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; address _from = identifierToOwner [ _deedId ] ; require ( _approvedFor ( msg . sender , _deedId ) ) ; _transfer ( _from , msg . sender , _deedId ) ; } }
function updateBurnAgent ( address _agent , bool _status ) public onlyOwner { burnAgents [ _agent ] = _status ; }
function approve ( uint256 _index , uint256 _tokenId ) internal { Offer memory localOffer = offers [ _index ] ; address newOwner = localOffer . from ; address prevOwner = token . getOwner ( _tokenId ) ; uint256 platformShare ; uint256 forPrevOwner ; uint256 soldPrice = token . getTokenSoldPrice ( _tokenId ) ; ( platformShare , forPrevOwner ) = pricingStrategy . calculateSharesInTheRevenue ( soldPrice , localOffer . offeredPrice ) ; token . updateTokensState ( _tokenId , localOffer . offeredPrice ) ; token . updateOwner ( _tokenId , newOwner , prevOwner ) ; localOffer . accepted = true ; transferEthers ( platformWallet , platformShare ) ; transferEthers ( prevOwner , forPrevOwner . add ( soldPrice ) ) ; emit OfferApproved ( newOwner , _tokenId , localOffer . offerId , localOffer . offeredPrice , now ) ; emit Purchased ( prevOwner , newOwner , _tokenId , localOffer . offeredPrice , soldPrice , forPrevOwner . add ( soldPrice ) , platformShare , now ) ; afterApproveAction ( _tokenId ) ; }
function approveAndCall ( address _spender , uint256 _value , bytes _data ) external returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; iApprover ( _spender ) . receiveApproval ( msg . sender , _value , address ( this ) , _data ) ; return true ; }
function isAffiliateValid ( address _investor ) constant public returns ( bool ) { Affiliate memory affiliate = affiliates [ _investor ] ; AffiliateReceived ( affiliate . etherAddress , _investor , affiliate . isPresent ) ; return affiliate . isPresent ; }
function ( ) public payable atState ( State . Sale ) { byTokens ( ) ; }
function withdraw ( ) public onlyIfWhitelisted ( "withdraw" , msg . sender ) { uint256 balance = ExtendedFinance ( address ( _getFinance ( ) ) ) . getRewardsBalance ( msg . sender ) ; ExtendedFinance ( address ( _getFinance ( ) ) ) . withdrawRewards ( msg . sender , balance ) ; }
function calculateStake ( uint256 _numRTC ) internal view returns ( uint256 blockLocked , uint256 blockReleased , uint256 releaseDate , uint256 totalCoinsMinted , uint256 rewardPerBlock ) { blockLocked = block . number ; blockReleased = blockLocked . add ( BLOCKHOLDPERIOD ) ; releaseDate = now . add ( BLOCKHOLDPERIOD . mul ( BLOCKSEC ) ) ; totalCoinsMinted = _numRTC . mul ( MULTIPLIER ) ; totalCoinsMinted = totalCoinsMinted . div ( 1 ether ) ; rewardPerBlock = totalCoinsMinted . div ( BLOCKHOLDPERIOD ) ; }
function crowdsaleSucceeded ( ) public { require ( msg . sender == crowdsaleAddress ) ; crowdsaleSuccessful = true ; }
function burn ( uint256 _value ) onlyOwner returns ( bool success ) { require ( balances [ msg . sender ] > _value ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
function receiveEther ( ) payable { EtherReceived ( msg . sender , msg . value ) ; }
function _addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) internal { IModuleRegistry ( moduleRegistry ) . useModule ( _moduleFactory ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; uint8 moduleType = moduleFactory . getType ( ) ; require ( modules [ moduleType ] . length < MAX_MODULES , "Limit of MAX MODULES is reached" ) ; uint256 moduleCost = moduleFactory . setupCost ( ) ; require ( moduleCost <= _maxCost , "Max Cost is always be greater than module cost" ) ; require ( ERC20 ( polyToken ) . approve ( _moduleFactory , moduleCost ) , "Not able to approve the module cost" ) ; address module = moduleFactory . deploy ( _data ) ; require ( ERC20 ( polyToken ) . approve ( module , _budget ) , "Not able to approve the budget" ) ; bytes32 moduleName = moduleFactory . getName ( ) ; modules [ moduleType ] . push ( ModuleData ( moduleName , module ) ) ; emit LogModuleAdded ( moduleType , moduleName , _moduleFactory , module , moduleCost , _budget , now ) ; }
function createTokens ( address beneficiary , uint amount ) onlyController returns ( bool success ) { if ( sealed ( ) ) throw ; balances [ beneficiary ] += amount ; totalSupply += amount ; Transfer ( 0 , beneficiary , amount ) ; return true ; }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value < allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }
function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceSignature_ERC721Enumerable ) || ( _interfaceID == InterfaceSignature_ERC721Metadata ) ) ; }
function setParetoToken ( address _token ) public onlyOwner { token = ERC20 ( _token ) ; ParetoAddress = _token ; }
function ( ) payable { process_contribution ( msg . sender ) ; }
function getOrdersForBuyer ( address buyer ) public view validAddress ( buyer ) returns ( address [ ] ) { return ordersByBuyer [ buyer ] ; }
function blockID ( uint8 x , uint8 y ) public pure returns ( uint16 ) { return ( uint16 ( y ) - 1 ) * 100 + uint16 ( x ) ; }
function setTokenBurner ( address _tokenBurner ) public onlyOwner { tokenBurner = ITokenBurner ( _tokenBurner ) ; }
function execBuyBack ( uint256 _qty ) public { require ( now > 1539561600 ) ; uint256 toPay = _qty * buyBackPrice ; require ( balanceOf [ msg . sender ] >= _qty ) ; require ( buyBackPrice > 0 ) ; require ( bbBalance >= toPay ) ; require ( frozenAccount [ msg . sender ] < now ) ; msg . sender . transfer ( toPay ) ; bbBalance -= toPay ; burn ( _qty ) ; }
function deregisterBroker ( address _broker ) external onlyOwner { require ( brokers [ _broker ] , "not registered" ) ; brokers [ _broker ] = false ; emit LogBrokerDeregistered ( _broker ) ; }
function successful ( ) public { require ( state == State . Successful ) ; if ( claimed == false ) { claimed = true ; address writer = 0xEB53AD38f0C37C0162E3D1D4666e63a55EfFC65f ; writer . transfer ( 5 ether ) ; uint256 remanent = hardCap . sub ( totalDistributed ) ; tokenReward . transfer ( creator , remanent ) ; emit LogContributorsPayout ( creator , remanent ) ; } creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
function burnTokens ( uint256 _tokens ) external { require ( ! locked ) ; require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( depositAddress != address ( 0 ) ) ; require ( _tokens != 0 ) ; require ( _tokens <= balances [ depositAddress ] ) ; balances [ depositAddress ] = balances [ depositAddress ] . sub ( _tokens ) ; totalSupply_ = totalSupply_ . sub ( _tokens ) ; emit TokensBurned ( msg . sender , depositAddress , _tokens ) ; }
function tokenMetadata ( uint256 index ) public view returns ( string ) { return loans [ index ] . metadata ; }
function request_close ( ) { data . request_close ( ) ; ChannelCloseRequested ( msg . sender , data . closed ) ; }
function attachSubscriptionModule ( SubscriptionModule subModule ) noAnyReentrancy external only ( owner ) { SUBSCRIPTION_MODULE = subModule ; if ( address ( subModule ) > 0 ) subModule . attachToken ( this ) ; }
function distrust ( ) external checkTrust ( msg . sender , contractOwner ) returns ( uint ) { holders [ getHolderId ( msg . sender ) ] . trust [ contractOwner ] = false ; return OK ; }
function transferBalanceWithFee ( address _traderFrom , address _traderTo , address _token , uint256 _value , uint256 _fee , address _feePayee ) external onlyRenExSettlementContract { require ( traderBalances [ _traderFrom ] [ _token ] >= _fee , "insufficient funds for fee" ) ; if ( address ( _token ) == ETHEREUM ) { rewardVaultContract . deposit . value ( _fee ) ( _feePayee , ERC20 ( _token ) , _fee ) ; } else { CompatibleERC20 ( _token ) . safeApprove ( rewardVaultContract , _fee ) ; rewardVaultContract . deposit ( _feePayee , ERC20 ( _token ) , _fee ) ; } privateDecrementBalance ( _traderFrom , ERC20 ( _token ) , _value + _fee ) ; if ( _value > 0 ) { privateIncrementBalance ( _traderTo , ERC20 ( _token ) , _value ) ; } }
function locationsLength ( ) public view returns ( uint ) { return locations . length ; }
function delegatedRefund ( address _address ) public { internalRefund ( _address ) ; }
function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
function getCard ( uint256 _tokenId ) public view returns ( string slug , uint256 price , address owner ) { Card storage card = cards [ _tokenId ] ; slug = card . slug ; price = cardIndexToPrice [ _tokenId ] ; owner = cardIndexToOwner [ _tokenId ] ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; uint256 [ ] memory result = new uint256 [ ] ( tokenCount + commonPlayerCount ) ; uint256 resultIndex = 0 ; uint256 playerId ; for ( playerId = 1 ; playerId <= commonPlayerCount ; playerId ++ ) { result [ resultIndex ] = playerId ; resultIndex ++ ; } if ( tokenCount == 0 ) { return result ; } else { uint256 totalPlayers = totalSupply ( ) ; for ( ; playerId < totalPlayers ; playerId ++ ) { if ( playerIndexToOwner [ playerId ] == _owner ) { result [ resultIndex ] = playerId ; resultIndex ++ ; } } return result ; } }
function requestUnlock ( bytes32 _lockId , address _callbackAddress , bytes4 _callbackSelector , address _whitelistedAddress ) public payable returns ( bytes32 requestMsgHash ) { require ( msg . sender == primary || msg . value >= 1 ether ) ; require ( _callbackAddress != address ( 0 ) ) ; uint256 requestIdx = ++ requestCount ; uint256 nonce = uint256 ( keccak256 ( block . blockhash ( block . number - 1 ) , address ( this ) , requestIdx ) ) ; requestMsgHash = keccak256 ( nonce , _whitelistedAddress , uint256 ( 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ) ; requestMap [ requestMsgHash ] = Request ( { lockId : _lockId , callbackSelector : _callbackSelector , callbackAddress : _callbackAddress , idx : requestIdx , timestamp : block . timestamp , extended : false } ) ; uint256 timeLockExpiry = block . timestamp ; if ( msg . sender == primary ) { timeLockExpiry += defaultTimeLock ; } else { timeLockExpiry += extendedTimeLock ; requestMap [ requestMsgHash ] . extended = true ; } emit Requested ( _lockId , _callbackAddress , _callbackSelector , nonce , _whitelistedAddress , requestMsgHash , timeLockExpiry ) ; }
function burnFrom ( address _from , uint256 _value ) public returns ( bool success ) { require ( balanceOf [ _from ] >= _value ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balanceOf [ _from ] -= _value ; allowance [ _from ] [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( _from , _value ) ; return true ; }
function addStoneToBoard ( uint boardId , uint8 row , uint8 col ) external { GoBoard storage board = allBoards [ boardId ] ; PlayerColor activeColor = getPlayerColor ( board , msg . sender ) ; require ( board . status == BoardStatus . InProgress && board . nextTurnColor == activeColor ) ; uint8 position = row * BOARD_ROW_SIZE + col ; require ( board . positionToColor [ position ] == 0 ) ; if ( updatePlayerTime ( board , boardId , activeColor ) ) { board . positionToColor [ position ] = uint8 ( activeColor ) ; updateCaptures ( board , position , uint8 ( activeColor ) ) ; nextTurn ( board ) ; if ( board . didPassPrevTurn ) { board . didPassPrevTurn = false ; } StoneAddedToBoard ( boardId , activeColor , row , col ) ; } }
function _createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) internal { ISecurityToken securityTokenInstance = ISecurityToken ( securityToken ) ; require ( _excluded . length <= EXCLUDED_ADDRESS_LIMIT , "Too many addresses excluded" ) ; require ( _expiry > _maturity , "Expiry before maturity" ) ; require ( _expiry > now , "Expiry in past" ) ; require ( _amount > 0 , "No dividend sent" ) ; require ( _token != address ( 0 ) , "Invalid token" ) ; require ( _checkpointId <= securityTokenInstance . currentCheckpointId ( ) , "Invalid checkpoint" ) ; require ( IERC20 ( _token ) . transferFrom ( msg . sender , address ( this ) , _amount ) , "insufficent allowance" ) ; require ( _name [ 0 ] != 0 ) ; uint256 dividendIndex = dividends . length ; uint256 currentSupply = securityTokenInstance . totalSupplyAt ( _checkpointId ) ; uint256 excludedSupply = 0 ; dividends . push ( Dividend ( _checkpointId , now , _maturity , _expiry , _amount , 0 , 0 , false , 0 , 0 , _name ) ) ; for ( uint256 j = 0 ; j < _excluded . length ; j ++ ) { require ( _excluded [ j ] != address ( 0 ) , "Invalid address" ) ; require ( ! dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] , "duped exclude address" ) ; excludedSupply = excludedSupply . add ( securityTokenInstance . balanceOfAt ( _excluded [ j ] , _checkpointId ) ) ; dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] = true ; } dividends [ dividendIndex ] . totalSupply = currentSupply . sub ( excludedSupply ) ; dividendTokens [ dividendIndex ] = _token ; _emitERC20DividendDepositedEvent ( _checkpointId , _maturity , _expiry , _token , _amount , currentSupply , dividendIndex , _name ) ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint tokenId ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 || _index >= tokenCount ) { revert ( ) ; } else { uint256 totalLoans = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 loanId ; for ( loanId = 0 ; loanId <= totalLoans ; loanId ++ ) { if ( loans [ loanId ] . lender == _owner && loans [ loanId ] . status == Status . lent ) { if ( resultIndex == _index ) { return loanId ; } resultIndex ++ ; } } revert ( ) ; } }
function getInvestorsLength ( ) public view returns ( uint256 ) { return investors . length ; }
function revokeAttestationFor ( address _sender , bytes32 _link , bytes32 _nonce , bytes _delegationSig ) external { validateRevokeForSig ( _sender , _link , _nonce , _delegationSig ) ; revokeAttestationForUser ( _link , _sender ) ; }
function totalSupply ( ) public view returns ( uint256 ) { return pixelcons . length ; }
function externalTokensRecovery ( token _address ) onlyAdmin public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
function deprecateInterface ( ) public onlyOwner returns ( bool deprecated ) { require ( lib . setDeprecatedContract ( address ( this ) ) , "Error: Unable to deprecate contract!" ) ; return true ; }
function exchangeEtherForNominsAtRate ( uint guaranteedRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToEthPrice ) ; return exchangeEtherForNomins ( ) ; }
function createCollection ( uint64 [ ] _tokenIndexes , bytes8 _name ) public returns ( uint64 ) { require ( collectionNames . length < uint256 ( 2 ** 64 ) - 1 , "Max number of collections has been reached" ) ; require ( _tokenIndexes . length > 1 , "Collection must contain more than one PixelCon" ) ; uint64 collectionIndex = uint64 ( collectionNames . length ) ; uint64 [ ] storage collection = collectionTokens [ collectionIndex ] ; collection . length = _tokenIndexes . length ; for ( uint i = 0 ; i < _tokenIndexes . length ; i ++ ) { uint64 tokenIndex = _tokenIndexes [ i ] ; require ( tokenIndex < totalSupply ( ) , "PixelCon index is out of bounds" ) ; PixelCon storage pixelcon = pixelcons [ tokenIndex ] ; require ( isCreatorAndOwner ( msg . sender , pixelcon . tokenId ) , "Sender is not the creator and owner of the PixelCons" ) ; require ( pixelcon . collectionIndex == uint64 ( 0 ) , "PixelCon is already in a collection" ) ; pixelcon . collectionIndex = collectionIndex ; collection [ i ] = tokenIndex ; } collectionNames . length ++ ; collectionNames [ collectionIndex ] = _name ; emit CreateCollection ( msg . sender , collectionIndex ) ; return collectionIndex ; }
function payer ( address who ) public constant returns ( uint count , address [ ] origins ) { address [ ] memory m_origins = s_paid [ who ] ; return ( m_origins . length , m_origins ) ; }
function doPayment ( uint _idDeposit , address _dest , ERC20 _token , uint _amount ) internal returns ( bool ) { if ( _amount == 0 ) return true ; if ( address ( _token ) == 0 ) { if ( ! _dest . send ( _amount ) ) return false ; } else { if ( ! _token . transfer ( _dest , _amount ) ) return false ; } Withdraw ( _idDeposit , _dest , _token , _amount ) ; return true ; }
function setCancelAnnounceDelay ( uint32 _delay ) external onlyOwner notMoreThanMaxDelay ( _delay ) { cancelAnnounceDelay = _delay ; }
function setCampaignValidById ( bytes32 bidId , bool isValid ) public onlyIfCampaignExists ( "setCampaignValidById" , bidId ) onlyIfWhitelisted ( "setCampaignValidById" , msg . sender ) { campaigns [ bidId ] . setValidity ( isValid ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
function setRoyaltyInformationContract ( address _royaltyInformationContract ) public onlyAdmin notFrozen returns ( bool set ) { royaltyInformationContract = _royaltyInformationContract ; RoyaltyInformationContractSet ( msg . sender , _royaltyInformationContract , true ) ; return true ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = personIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function setAttributeTypeMinimumRequiredStake ( uint256 ID , uint256 minimumRequiredStake ) external ;
function topUpBalance ( uint verifyCode ) public payable mustBeAtStage ( Stage . Running ) { require ( msg . value > 0 ) ; require ( verifyCode == 28391728448 ) ; }
function getState ( uint256 _tokenId ) public view returns ( string stateName , uint256 sellingPrice , address owner ) { State storage state = states [ _tokenId ] ; stateName = state . name ; sellingPrice = stateIndexToPrice [ _tokenId ] ; owner = stateIndexToOwner [ _tokenId ] ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = gameItemIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function offerToChannel ( address _channelAccount , uint256 _venAmount ) onlyOwner { Stage stg = stage ( ) ; require ( stg == Stage . Early || stg == Stage . Normal || stg == Stage . Closed ) ; soldOut . channels = _venAmount . add ( soldOut . channels ) . toUINT120 ( ) ; require ( soldOut . channels <= channelsLimit ) ; ven . mint ( _channelAccount , _venAmount , true , blockTime ( ) ) ; onSold ( _channelAccount , _venAmount , 0 ) ; }
function setRealityCheck ( address addr ) onlyOwner public { realitycheck = RealityCheck ( addr ) ; LogSetRealityCheck ( addr ) ; }
function ( ) external payable { address nftAddress = address ( nonFungibleContract ) ; require ( msg . sender == address ( this ) || msg . sender == gameManagerPrimary || msg . sender == gameManagerSecondary || msg . sender == bankManager || msg . sender == nftAddress ) ; }
function setRegistryAdmin ( address _newRegistryAdmin ) public onlyOwner nonZero ( _newRegistryAdmin ) { address _oldRegistryAdmin = registryAdmin ; registryAdmin = _newRegistryAdmin ; emit RegistryAdminChanged ( _oldRegistryAdmin , registryAdmin ) ; }
function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( this , target , mintedAmount ) ; }
function burn ( uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value , "insufficient sender balance" ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; _totalSupply = safeSub ( _totalSupply , _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }
function addAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , "Invalid address." ) ; require ( ! admins [ _address ] , "This address is already an administrator." ) ; require ( _address != owner , "The owner cannot be added or removed to or from the administrator list." ) ; admins [ _address ] = true ; emit AdminAdded ( _address ) ; return true ; }
function setMtdPreAmount ( uint256 mtdPreAmountInWei ) isOwner { require ( mtdPreAmountInWei > 0 ) ; require ( mtdPreAmount != mtdPreAmountInWei ) ; mtdPreAmount = mtdPreAmountInWei ; updatePrices ( ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == 0 ) { return 0 ; } c = a * b ; assert ( c / a == b ) ; return c ; }
function transfer ( address _to , uint256 _value ) public whenNotPaused returns ( bool success ) { require ( _value > 0 ) ; require ( balanceOf [ msg . sender ] >= _value ) ; require ( balanceOf [ _to ] + _value >= balanceOf [ _to ] ) ; balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function setPeonyAddress ( address _address ) onlyOwner returns ( bool ) { require ( _address != 0x0 ) ; peony = _address ; return true ; }
function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyOwner public { delete arbitration_bounties [ question_id ] ; realitycheck . submitAnswerByArbitrator ( question_id , answer , answerer ) ; }
function onTransferReceived ( address _operator , address _from , uint256 _value , bytes _data ) external returns ( bytes4 ) ;
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; emit NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
function transferOwnership ( address newOwner ) onlyOwner public { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; }
function buyTokens ( ) public payable whenNotPaused { require ( validPurchase ( ) ) ; uint256 tokens = 0 ; uint256 amountPaid = calculateExcessBalance ( ) ; if ( tokensRaised < limitTier1 ) { tokens = amountPaid . mul ( rate ) ; if ( tokensRaised . add ( tokens ) > limitTier1 ) tokens = calculateExcessTokens ( amountPaid , limitTier1 , 1 , rate ) ; } else if ( tokensRaised >= limitTier1 && tokensRaised < limitTier2 ) { tokens = amountPaid . mul ( rateTier2 ) ; if ( tokensRaised . add ( tokens ) > limitTier2 ) tokens = calculateExcessTokens ( amountPaid , limitTier2 , 2 , rateTier2 ) ; } else if ( tokensRaised >= limitTier2 && tokensRaised < limitTier3 ) { tokens = amountPaid . mul ( rateTier3 ) ; if ( tokensRaised . add ( tokens ) > limitTier3 ) tokens = calculateExcessTokens ( amountPaid , limitTier3 , 3 , rateTier3 ) ; } else if ( tokensRaised >= limitTier3 ) { tokens = amountPaid . mul ( rateTier4 ) ; } weiRaised = weiRaised . add ( amountPaid ) ; tokensRaised = tokensRaised . add ( tokens ) ; token . distributeICOTokens ( msg . sender , tokens ) ; tokensBought [ msg . sender ] = tokensBought [ msg . sender ] . add ( tokens ) ; TokenPurchase ( msg . sender , amountPaid , tokens ) ; numberOfTransactions = numberOfTransactions . add ( 1 ) ; forwardFunds ( amountPaid ) ; }
function vote ( string name ) external payable { _vote ( name , msg . value , msg . sender ) ; }
function withdrawMyDepositedSynths ( ) external { uint synthsToSend = 0 ; for ( uint i = depositStartIndex ; i < depositEndIndex ; i ++ ) { synthDeposit memory deposit = deposits [ i ] ; if ( deposit . user == msg . sender ) { synthsToSend = synthsToSend . add ( deposit . amount ) ; delete deposits [ i ] ; emit SynthDepositRemoved ( deposit . user , deposit . amount , i ) ; } } totalSellableDeposits = totalSellableDeposits . sub ( synthsToSend ) ; synthsToSend = synthsToSend . add ( smallDeposits [ msg . sender ] ) ; smallDeposits [ msg . sender ] = 0 ; require ( synthsToSend > 0 , "You have no deposits to withdraw." ) ; synth . transfer ( msg . sender , synthsToSend ) ; emit SynthWithdrawal ( msg . sender , synthsToSend ) ; }
function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) internal { requireMultiple ( _amount ) ; require ( balanceOf ( _tokenHolder ) >= _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; callSender ( _operator , _tokenHolder , 0x0 , _amount , _holderData , _operatorData ) ; Burned ( _operator , _tokenHolder , _amount , _holderData , _operatorData ) ; }
function changeCommission ( uint _newCommission ) public onlyOwner whenNotPaused { require ( _newCommission <= MAX_COMMISSION , "commission should be <= MAX_COMMISSION" ) ; require ( _newCommission != Commission , "_newCommission==Commmission" ) ; Commission = _newCommission ; emit NewCommission ( Commission ) ; }
function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; PercentageTransferManager percentageTransferManager = new PercentageTransferManager ( msg . sender , address ( polyToken ) ) ; require ( getSig ( _data ) == percentageTransferManager . getInitFunction ( ) , "Provided data is not valid" ) ; require ( address ( percentageTransferManager ) . call ( _data ) , "Un-successfull call" ) ; emit LogGenerateModuleFromFactory ( address ( percentageTransferManager ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( percentageTransferManager ) ; }
function sell ( uint256 amount ) public { require ( this . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount * 10 ** uint256 ( decimals ) ) ; msg . sender . transfer ( amount * sellPrice ) ; }
function create ( address _to , uint256 _tokenId , bytes8 _name ) public payable validAddress ( _to ) validId ( _tokenId ) returns ( uint64 ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( pixelcons . length < uint256 ( 2 ** 64 ) - 1 , "Max number of PixelCons has been reached" ) ; require ( lookupData . owner == address ( 0 ) , "PixelCon already exists" ) ; uint32 dateCreated = 0 ; if ( now < uint256 ( 2 ** 32 ) ) dateCreated = uint32 ( now ) ; uint64 index = uint64 ( pixelcons . length ) ; lookupData . tokenIndex = index ; pixelcons . length ++ ; pixelconNames . length ++ ; PixelCon storage pixelcon = pixelcons [ index ] ; pixelcon . tokenId = _tokenId ; pixelcon . creator = msg . sender ; pixelcon . dateCreated = dateCreated ; pixelconNames [ index ] = _name ; uint64 [ ] storage createdList = createdTokens [ msg . sender ] ; uint createdListIndex = createdList . length ; createdList . length ++ ; createdList [ createdListIndex ] = index ; addTokenTo ( _to , _tokenId ) ; emit Create ( _tokenId , msg . sender , index , _to ) ; emit Transfer ( address ( 0 ) , _to , _tokenId ) ; return index ; }
function updateReputationScore ( bytes32 _deviceId , bytes32 _reputationScore ) public onlyIRNNode whenNotPaused returns ( bool ) { Device memory d = _updateReputationScore ( _deviceId , _reputationScore ) ; address _manufacturerWallet = manufacturerRewards [ d . manufacturerId ] ; require ( _manufacturerWallet != address ( 0 ) , "_manufacturerWallet cannot be 0x0" ) ; require ( _manufacturerWallet != msg . sender , "manufacturers cannot collect the full reward" ) ; uint256 irnReward ; uint256 manufacturerReward ; ( irnReward , manufacturerReward ) = getReputationRewards ( msg . sender , _manufacturerWallet , _deviceId ) ; _distributeRewards ( _manufacturerWallet , msg . sender , irnReward ) ; _distributeRewards ( _manufacturerWallet , _manufacturerWallet , manufacturerReward ) ; emit ReputationScoreUpdated ( _deviceId , d . deviceType , _reputationScore , msg . sender , irnReward , _manufacturerWallet , manufacturerReward ) ; authorWrites [ msg . sender ] [ _deviceId ] = block . number ; return true ; }
function setLimit ( uint256 tokenId ) external onlyAdmin { require ( tokenId < tokens . length ) ; require ( pValidationState == pointsValidationState . Unstarted || pValidationState == pointsValidationState . LimitSet ) ; pointsLimit = tokenId ; pValidationState = pointsValidationState . LimitSet ; lastCheckedToken = 0 ; lastCalculatedToken = 0 ; winnerCounter = 0 ; setPause ( ) ; setPayoutDistributionId ( ) ; }
function _setPendingAdmin ( address newPendingAdmin ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_PENDING_ADMIN_OWNER_CHECK ) ; } address oldPendingAdmin = pendingAdmin ; pendingAdmin = newPendingAdmin ; emit NewPendingAdmin ( oldPendingAdmin , newPendingAdmin ) ; return uint ( Error . NO_ERROR ) ; }
function withdrawAll ( ) public returns ( bool ) { owner . transfer ( this . balance ) ; return true ; }
function assign ( address _receiver , uint256 _amount ) external authP ( ASSIGN_ROLE , arr ( _receiver , _amount ) ) { _assign ( _receiver , _amount ) ; }
function revokeAttribute ( address account , uint256 attributeTypeID ) external whenNotPaused { require ( _issuedAttributes [ account ] [ attributeTypeID ] . exists , "only existing attributes may be removed" ) ; address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; require ( msg . sender == validator || msg . sender == owner ( ) , "only jurisdiction or issuing validators may revoke arbitrary attributes" ) ; delete _issuedAttributes [ account ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , account , attributeTypeID ) ; }
function addHash ( bytes32 [ ] _hashes ) onlyResolver public { for ( uint i = 0 ; i < _hashes . length ; i ++ ) { randomHashes . push ( _hashes [ i ] ) ; } }
function _clearApprovalAndTransfer ( address _from , address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) , "invalid target address" ) ; require ( _to != ownerOf ( _tokenId ) , "already owns" ) ; require ( ownerOf ( _tokenId ) == _from , "wrong owner" ) ; _clearApproval ( _from , _tokenId ) ; _removeToken ( _from , _tokenId ) ; _addToken ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }
function forceNeuroChainAddress ( address ethAddress , string neurochainAddress ) public onlyIcoContract { neuroChainAddresses [ ethAddress ] = neurochainAddress ; NeuroChainAddressSet ( ethAddress , neurochainAddress , block . timestamp , true ) ; }
function getPriceOfPlot ( Geometry . Rect memory subPlotToPurchase , uint256 plotIndex ) private view returns ( uint256 ) { uint256 plotPricePerPixel = plotIdToPrice [ plotIndex ] ; require ( plotPricePerPixel > 0 ) ; return SafeMath . mul ( SafeMath . mul ( subPlotToPurchase . w , subPlotToPurchase . h ) , plotPricePerPixel ) ; }
function setOwner ( address _newOwner ) onlyOwner external { owner = _newOwner ; }
function kill ( ) onlyOwner public { selfdestruct ( owner ) ; }
function setTokenPoolReward ( uint256 newReward ) public onlyManufacturer returns ( bool ) { require ( newReward != 0 , "newReward is required" ) ; TokenPool storage p = pools [ msg . sender ] ; require ( p . rewardAmount != newReward , "newReward should be different" ) ; p . rewardAmount = newReward ; emit TokenPoolRewardUpdated ( msg . sender , newReward ) ; return true ; }
function setOpenForSale ( bool status ) onlyOwner public { isOpenForSale = status ; }
function getDescription ( ) public view returns ( string ) ;
function getSecurityTokenAddress ( string _symbol ) public view returns ( address ) ;
function canIssueAttributeType ( address validator , uint256 attributeTypeID ) external view returns ( bool ) { return canValidate ( validator , attributeTypeID ) ; }
function checkAdminOwner ( PledgeAdmin m ) internal constant { require ( ( msg . sender == m . addr ) || ( msg . sender == address ( m . plugin ) ) ) ; }
function getScene ( uint256 _tokenId ) public view returns ( string sceneName , uint [ ] stars , uint256 sellingPrice , address owner ) { Scene storage scene = scenes [ _tokenId ] ; sceneName = scene . name ; stars = scene . stars ; sellingPrice = sceneIndexToPrice [ _tokenId ] ; owner = sceneIndexToOwner [ _tokenId ] ; }
function isApprovedForAll ( address _owner , address _operator ) public view validAddress ( _owner ) validAddress ( _operator ) returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }
function unlock ( ) public onlyStates ( LockState . AcceptingUnlocks , LockState . ReleaseAll ) { unlockInvestor ( msg . sender ) ; }
function votedPerCent ( address voter ) constant external returns ( uint ) { var rawVote = rawVotes [ voter ] ; if ( rawVote < MAX_AMOUNT_EQU_0_PERCENT ) return 0 ; else if ( rawVote >= MIN_AMOUNT_EQU_100_PERCENT ) return 100 ; else return rawVote * 100 / 1 ether ; }
function voteAgainst ( uint motionID ) external { uint weight = setupVote ( motionID ) ; vote [ msg . sender ] [ motionID ] = Vote . Nay ; votesAgainst [ motionID ] = safeAdd ( votesAgainst [ motionID ] , weight ) ; emit VotedAgainst ( msg . sender , motionID , weight ) ; }
function burnTokens ( uint256 _amount ) external returns ( bool ) { return _burnTokens ( _amount ) ; }
function name ( ) external view returns ( string ) ;
function extractBalanceProofSignature ( address _receiver_address , uint32 _open_block_number , uint192 _balance , bytes _balance_msg_sig ) public view returns ( address ) { bytes32 message_hash = keccak256 ( keccak256 ( 'string message_id' , 'address receiver' , 'uint32 block_created' , 'uint192 balance' , 'address contract' ) , keccak256 ( 'Sender balance proof signature' , _receiver_address , _open_block_number , _balance , address ( this ) ) ) ; address signer = ECVerify . ecverify ( message_hash , _balance_msg_sig ) ; return signer ; }
function totalSupplyAt ( uint256 _blockNumber ) constant returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
function approve ( address _spender , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
function approve ( address spender , uint256 value ) returns ( bool ) { if ( safeSub ( balances [ msg . sender ] , value ) < shouldHadBalance ( msg . sender ) ) throw ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }
function freezeTransfers ( ) public onlyAdmin returns ( bool ) { transfersFrozen = true ; emit TransfersFrozen ( true ) ; return true ; }
function release ( ) external onlyOwner onlyInEmergency { stopped = false ; }
function setPrices ( uint256 newBuyPrice , bool _openToSales ) onlyOwner public { buyPrice = newBuyPrice ; openToSales = _openToSales ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { if ( ! tokenAvailable ) { return 0 ; } return balances [ _owner ] ; }
function mintToken ( address target , uint256 mintedAmount ) onlyOwner { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( 0 , this , mintedAmount ) ; Transfer ( this , target , mintedAmount ) ; }
function sell ( uint256 amount ) public { address myAddress = address ( this ) ; require ( myAddress . balance >= amount * sellPrice ) ; _transfer ( msg . sender , address ( this ) , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
function updateSubmissionGasPriceLimit ( uint256 _newSubmissionGasPriceLimit ) external onlyOwner { emit LogSubmissionGasPriceLimitUpdated ( submissionGasPriceLimit , _newSubmissionGasPriceLimit ) ; submissionGasPriceLimit = _newSubmissionGasPriceLimit ; }
function create ( uint256 baseUnitsToCreate ) external whenNotPaused ( ) requireNonZero ( baseUnitsToCreate ) requireMultiple ( baseUnitsToCreate ) { require ( ( totalSupply_ + baseUnitsToCreate ) > totalSupply_ ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; transferUnderlyingTokensWhenCreate ( erc20 , tokenInfo . tokenUnits , baseUnitsToCreate ) ; } mint ( msg . sender , baseUnitsToCreate ) ; }
function batchConvertIntoHtlc ( bytes32 [ ] msigIds , address [ ] beneficiaries , uint [ ] amounts , uint [ ] fees , uint [ ] expirationTimes , bytes32 [ ] hashedSecrets ) public returns ( bytes32 [ ] swapId ) { require ( msigIds . length <= MAX_BATCH_ITERATIONS ) ; for ( uint i = 0 ; i < msigIds . length ; ++ i ) convertIntoHtlc ( msigIds [ i ] , beneficiaries [ i ] , amounts [ i ] , fees [ i ] , expirationTimes [ i ] , hashedSecrets [ i ] ) ; }
function pauseWhitelist ( ) public onlyAdmin returns ( bool ) { paused = true ; Paused ( msg . sender , now ) ; return true ; }
function setRequestCancellationMinimumTime ( uint32 _newRequestCancellationMinimumTime ) onlyOwner external { requestCancellationMinimumTime = _newRequestCancellationMinimumTime ; }
function set_pauseSale ( bool _pauseSale ) onlyOwner public { sale_pause = _pauseSale ; }
function allowance ( address _owner , address _spender ) constant returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }
function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != 0x0 ) ; require ( balanceOf [ _from ] >= _value ) ; require ( balanceOf [ _to ] + _value > balanceOf [ _to ] ) ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( _from , _to , _value ) ; }
function setStakedBalances ( uint _amount , address msgSender ) public ownerOnly { stakedBalances [ msgSender ] = _amount ; }
function modifyWhitelist ( address _investor , bool _valid ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = _valid ; emit ModifyWhitelist ( _investor , now , msg . sender , _valid ) ; }
function acceptOwnership ( ) external { require ( msg . sender == nominatedOwner ) ; emit OwnerChanged ( owner , nominatedOwner ) ; owner = nominatedOwner ; nominatedOwner = address ( 0 ) ; }
function pauseContribution ( ) onlyOwner { paused = true ; }
function _setTokenUri ( uint256 _tokenId , string _uri ) validNFToken ( _tokenId ) internal { idToUri [ _tokenId ] = _uri ; }
function canAddAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) ;
function transferFrom ( address from , address to , uint256 index ) public returns ( bool ) { require ( loans [ index ] . lender == from ) ; return transfer ( to , index ) ; }
function setEndDate ( Campaign storage _campaign , uint _endDate ) internal { _campaign . endDate = _endDate ; }
function symbol ( ) public pure returns ( string _deedSymbol ) ;
function getLastDeedByAddress ( string propertyAddress ) public constant returns ( string ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; return addressRegistry [ propertyAddressHash ] [ addressRegistry [ propertyAddressHash ] . length - 1 ] ; }
function buyTokens ( address _beneficiary ) public payable nonReentrant { require ( ! paused ) ; require ( fundraiseType == FundraiseType . ETH , "ETH should be the mode of investment" ) ; uint256 weiAmount = msg . value ; _processTx ( _beneficiary , weiAmount ) ; _forwardFunds ( ) ; _postValidatePurchase ( _beneficiary , weiAmount ) ; }
function totalSupply ( ) public view returns ( uint256 supply ) { return totalSupply ; }
function stage ( ) public constant returns ( uint256 ) ;
function presale ( ) payable returns ( bool ) ;
function relay ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _maximumGasPrice , uint8 _v , bytes32 _r , bytes32 _s , uint8 _instructionByte , uint128 _additionalGas ) private returns ( bool ) { address _relayedSender = getRelayedSender ( _tradeID , _instructionByte , _maximumGasPrice , _v , _r , _s ) ; if ( _relayedSender == _buyer ) { if ( _instructionByte == INSTRUCTION_SELLER_CANNOT_CANCEL ) { return doDisableSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } else if ( _instructionByte == INSTRUCTION_BUYER_CANCEL ) { return doBuyerCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } } else if ( _relayedSender == _seller ) { if ( _instructionByte == INSTRUCTION_RELEASE ) { return doRelease ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } else if ( _instructionByte == INSTRUCTION_SELLER_CANCEL ) { return doSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } else if ( _instructionByte == INSTRUCTION_SELLER_REQUEST_CANCEL ) { return doSellerRequestCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } } else { require ( msg . sender == _seller , "Unrecognised party" ) ; return false ; } }
function setExchangeRates ( ExchangeRates _exchangeRates ) external optionalProxy_onlyOwner { exchangeRates = _exchangeRates ; }
function increaseApprovalWithSender ( address _sender , address _spender , uint256 _addedValue ) public onlyProxy returns ( bool success ) { require ( _spender != address ( 0 ) ) ; uint256 currentAllowance = erc20Store . allowed ( _sender , _spender ) ; uint256 newAllowance = currentAllowance + _addedValue ; require ( newAllowance >= currentAllowance ) ; erc20Store . setAllowance ( _sender , _spender , newAllowance ) ; erc20Proxy . emitApproval ( _sender , _spender , newAllowance ) ; return true ; }
function proxyApprove ( address _spender , uint _value , bytes32 _symbol , address _sender ) public onlyProxy ( _symbol ) returns ( uint ) { return _approve ( _createHolderId ( _spender ) , _value , _symbol , _createHolderId ( _sender ) ) ; }
function getTxStatus ( Data storage self , bytes32 txHash ) internal view returns ( bool txStatus ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tx.status' , txHash ) ) ; return self . Storage . getBool ( id ) ; }
function initialize ( string _name , string _symbol , uint256 _granularity , address _eip820RegistryAddr , address _owner ) public { require ( ! _initialized , "This contract has already been initialized. You can only do this once." ) ; mName = _name ; mSymbol = _symbol ; mErc20compatible = true ; setOwner ( _owner ) ; require ( _granularity >= 1 , "The granularity must be >= 1" ) ; mGranularity = _granularity ; setIntrospectionRegistry ( _eip820RegistryAddr ) ; setInterfaceImplementation ( "ERC20Token" , this ) ; setInterfaceImplementation ( "ERC777Token" , this ) ; setInterfaceImplementation ( "Lockable" , this ) ; setInterfaceImplementation ( "Pausable" , this ) ; _initialized = true ; }
function approve ( address _spender , uint256 _value ) returns ( bool success ) ;
function finalizeCrowdsale ( ) public { require ( ( now > lastRoundEndTimestamp ( ) ) || ( totalCollected == hardCap ) || ( msg . sender == owner ) ) ; finalized = token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( this . balance > 0 ) { owner . transfer ( this . balance ) ; } }
function canWithdraw ( address _holder ) public constant returns ( bool ) { if ( nextDepositToPayout [ _holder ] == deposits . length ) return false ; for ( uint i = nextDepositToPayout [ msg . sender ] ; i < deposits . length ; i ++ ) { Deposit storage d = deposits [ i ] ; if ( ( ! d . canceled ) && ( ! isDepositSkiped ( _holder , i ) ) ) { uint amount = d . amount * rewardToken . balanceOfAt ( _holder , d . block ) / rewardToken . totalSupplyAt ( d . block ) ; if ( amount > 0 ) return true ; } } return false ; }
function lowerCeiling ( uint256 _lowerBy ) public onlyLimitedPrinter { uint256 newCeiling = totalSupplyCeiling - _lowerBy ; require ( newCeiling <= totalSupplyCeiling ) ; totalSupplyCeiling = newCeiling ; emit CeilingLowered ( _lowerBy , newCeiling ) ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalPonies = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 ponyId ; for ( ponyId = 1 ; ponyId <= totalPonies ; ponyId ++ ) { if ( ponyIndexToOwner [ ponyId ] == _owner ) { result [ resultIndex ] = ponyId ; resultIndex ++ ; } } return result ; } }
function removeManyWhitelist ( address [ ] _accounts ) external whenNotPaused onlyAdmin { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { if ( _accounts [ i ] != address ( 0 ) && whitelist [ _accounts [ i ] ] ) { whitelist [ _accounts [ i ] ] = false ; emit WhitelistRemoved ( _accounts [ i ] ) ; } } }
function configure ( uint256 _maxHolderPercentage , bool _allowPrimaryIssuance ) public onlyFactory { maxHolderPercentage = _maxHolderPercentage ; allowPrimaryIssuance = _allowPrimaryIssuance ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { bool sucsSlrLmt = _chkSellerLmts ( msg . sender , _value ) ; bool sucsByrLmt = _chkBuyerLmts ( _spender , _value ) ; require ( sucsSlrLmt == true && sucsByrLmt == true ) ; uint valtmp = _value ; uint _valueA = valtmp ; valtmp = 0 ; allowance [ msg . sender ] [ _spender ] = _valueA ; Approval ( msg . sender , _spender , _valueA ) ; _valueA = 0 ; return true ; }
function size ( ContentMapping storage self ) public view returns ( uint ) { return self . keys . length ; }
function addAssetPartOwner ( bytes32 _symbol , address _partowner ) external onlyOneOfOwners ( _symbol ) returns ( uint ) { uint holderId = _createHolderId ( _partowner ) ; assets [ _symbol ] . partowners [ holderId ] = true ; Emitter ( eventsHistory ) . emitOwnershipChange ( 0x0 , _partowner , _symbol ) ; return OK ; }
function validateContentHash ( Document storage self , bytes32 _contentHash ) public view returns ( bool ) { bytes32 contentHash = self . contentHash ; return contentHash == _contentHash ; }
function addStablecoin ( address _stablecoin ) public onlyOwner { whitelist [ _stablecoin ] = true ; emit StablecoinAdded ( _stablecoin ) ; }
function unpause ( ) public onlyOwner whenPaused { require ( newContractAddress == address ( 0 ) , "new contract cannot be 0x0" ) ; super . unpause ( ) ; }
function putOn ( uint256 _champId , uint256 _itemId ) external onlyOwnerOfChamp ( _champId ) onlyOwnerOfItem ( _itemId ) { Champ storage champ = champs [ _champId ] ; Item storage item = items [ _itemId ] ; if ( item . onChamp ) { takeOffItem ( item . onChampId , item . itemType ) ; } item . onChamp = true ; item . onChampId = _champId ; if ( item . itemType == 1 ) { if ( champ . eq_sword > 0 ) { takeOffItem ( champ . id , 1 ) ; } champ . eq_sword = _itemId ; } if ( item . itemType == 2 ) { if ( champ . eq_shield > 0 ) { takeOffItem ( champ . id , 2 ) ; } champ . eq_shield = _itemId ; } if ( item . itemType == 3 ) { if ( champ . eq_helmet > 0 ) { takeOffItem ( champ . id , 3 ) ; } champ . eq_helmet = _itemId ; } }
function validRequest ( bytes32 [ ] _proof , bytes5 _code , address _dest ) public view returns ( bool ) { return ! sentToAddress [ _dest ] && ! codeUsed [ _code ] && MerkleProof . verifyProof ( _proof , root , keccak256 ( abi . encodePacked ( _code ) ) ) ; }
function requireMultiple ( uint256 _amount ) internal view { require ( _amount . div ( mGranularity ) . mul ( mGranularity ) == _amount ) ; }
function authorizeOperator ( address _operator ) external { require ( _operator != msg . sender ) ; require ( ! mAuthorized [ _operator ] [ msg . sender ] ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = false ; } else { mAuthorized [ _operator ] [ msg . sender ] = true ; } emit AuthorizedOperator ( _operator , msg . sender ) ; }
function rewardToken ( address _recipient , uint _amount , uint _date ) external ;
function canBreedWith ( uint40 _momId , uint40 _dadId ) public view returns ( bool ) { require ( _momId > 0 ) ; require ( _dadId > 0 ) ; Cutie storage mom = cuties [ _momId ] ; Cutie storage dad = cuties [ _dadId ] ; return _canPairMate ( mom , _momId , dad , _dadId ) && _isBreedingPermitted ( _dadId , _momId ) ; }
function isApprovedOrOwner ( address _address , uint256 _tokenId ) internal view returns ( bool ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( owner != address ( 0 ) , "PixelCon does not exist" ) ; return ( _address == owner || tokenApprovals [ _tokenId ] == _address || operatorApprovals [ owner ] [ _address ] ) ; }
function withdrawInternal ( uint requested , bool all ) internal { require ( between [ msg . sender ] ) ; uint available = Splitter . balance ( ) ; uint transferring = 0 ; if ( all ) { transferring = available ; } else { available = requested ; } require ( transferring <= available ) ; amountsWithdrew [ msg . sender ] += transferring ; msg . sender . transfer ( transferring ) ; }
function getAccountStatus ( Data storage self , address account ) internal view returns ( bool status ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.allowed' , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getBool ( id ) ; }
function setSecurityGuard ( address _newSecurityGuard ) onlyOwner external { securityGuard = _newSecurityGuard ; }
function requestArbitration ( address realitycheck , bytes32 question_id ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { RealityCheckAPI ( realitycheck ) . notifyOfArbitrationRequest ( question_id , msg . sender ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! RealityCheckAPI ( realitycheck ) . isFinalized ( question_id ) ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }
function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = "Count" ; availableTags [ 1 ] = "Transfer Restriction" ; return availableTags ; }
function mAfterTransition ( State oldState , State newState ) internal ;
function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < totalSupply ( ) ) ; return _index ; }
function unlock ( ) external { if ( now < unlockedAt ) throw ; if ( tokensCreated == 0 ) tokensCreated = gnt . balanceOf ( this ) ; var allocation = allocations [ msg . sender ] ; allocations [ msg . sender ] = 0 ; var toTransfer = tokensCreated * allocation / totalAllocations ; if ( ! gnt . transfer ( msg . sender , toTransfer ) ) throw ; }
function addBeneficiary ( address _beneficiary , uint256 _amount ) public onlyOwner validAddress ( _beneficiary ) returns ( address ) { require ( _beneficiary != owner ) ; require ( _amount > 0 ) ; require ( block . timestamp < releaseDate ) ; require ( SafeMath . sub ( totalFunds , distributedTokens ) >= _amount ) ; require ( token . balanceOf ( address ( this ) ) >= _amount ) ; if ( ! beneficiaryExists ( _beneficiary ) ) { beneficiaries . push ( _beneficiary ) ; } distributedTokens = distributedTokens . add ( _amount ) ; address tokenTimelock = new TokenTimelock ( token , _beneficiary , releaseDate ) ; beneficiaryDistributionContracts [ _beneficiary ] . push ( tokenTimelock ) ; token . safeTransfer ( tokenTimelock , _amount ) ; emit BeneficiaryAdded ( _beneficiary , tokenTimelock , _amount ) ; return tokenTimelock ; }
function gasExchangeMultiple ( address [ ] gasRecipients , uint256 [ ] amountsEurUlps , uint256 exchangeFeeFraction ) public ;
function hasVoted ( address account , uint motionID ) public view returns ( bool ) { return vote [ account ] [ motionID ] != Vote . Abstention ; }
function rewardTaskCompletion ( uint uuid , address user ) public onlyVoteController { communityAccount . transferTokensOut ( address ( nativeTokenInstance ) , user , communityAccount . escrowedTaskBalances ( uuid ) ) ; communityAccount . setTotalTaskEscrow ( SafeMath . sub ( communityAccount . totalTaskEscrow ( ) , communityAccount . escrowedTaskBalances ( uuid ) ) ) ; communityAccount . setEscrowedTaskBalances ( uuid , 0 ) ; logger . emitGenericLog ( "rewardTaskCompletion" , "" ) ; }
function processWhitelistedContribution ( uint256 allowedContribution , uint256 refundAmount ) private returns ( uint256 , uint256 ) { uint256 plannedContribution = whitelist [ msg . sender ] ; whitelist [ msg . sender ] = 0 ; WhitelistedUpdated ( plannedContribution , true ) ; if ( msg . value > plannedContribution ) { return handleAbovePlannedWhitelistedContribution ( allowedContribution , plannedContribution , refundAmount ) ; } if ( msg . value < plannedContribution ) { return handleBelowPlannedWhitelistedContribution ( plannedContribution ) ; } return handlePlannedWhitelistedContribution ( plannedContribution ) ; }
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) ;
function decreaseApproval ( address _spender , uint256 _subtractedValue ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) , "Invalid address." ) ; return super . decreaseApproval ( _spender , _subtractedValue ) ; }
function setPermissionManager ( address _newManager , address _app , bytes32 _role ) onlyPermissionManager ( _app , _role ) external { _setPermissionManager ( _newManager , _app , _role ) ; }
function spendFromMultisig ( bytes32 msigId , uint amount , address recipient ) internal { multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , amount ) ; if ( multisigs [ msigId ] . deposit == 0 ) delete multisigs [ msigId ] ; recipient . transfer ( amount ) ; }
function setFundsWallet ( address _fundsWallet ) external onlyOwner { fundsWallet = _fundsWallet ; emit FundsWalletUpdated ( fundsWallet ) ; }
function transfer ( bytes32 _to , uint256 _value ) returns ( bool ) { var sender = sha3 ( msg . sender ) ; if ( balances [ sender ] >= _value ) { balances [ sender ] -= _value ; balances [ _to ] += _value ; TransferHash ( sender , _to , _value ) ; return true ; } return false ; }
function calculateTokenExchangeRate ( ) internal returns ( uint256 ) { if ( cd [ 'preIco' ] [ 'startBlock' ] <= block . number && block . number <= cd [ 'preIco' ] [ 'endBlock' ] ) { return cd [ 'preIco' ] [ 'exRate' ] ; } if ( cd [ 'stage1' ] [ 'startBlock' ] <= block . number && block . number <= cd [ 'stage1' ] [ 'endBlock' ] ) { return cd [ 'stage1' ] [ 'exRate' ] ; } if ( cd [ 'stage2' ] [ 'startBlock' ] <= block . number && block . number <= cd [ 'stage2' ] [ 'endBlock' ] ) { return cd [ 'stage2' ] [ 'exRate' ] ; } if ( cd [ 'stage3' ] [ 'startBlock' ] <= block . number && block . number <= cd [ 'stage3' ] [ 'endBlock' ] ) { return cd [ 'stage3' ] [ 'exRate' ] ; } if ( cd [ 'stage4' ] [ 'startBlock' ] <= block . number && block . number <= cd [ 'stage4' ] [ 'endBlock' ] ) { return cd [ 'stage4' ] [ 'exRate' ] ; } return 0 ; }
function calculateAtomicFees ( bytes32 _buyID , bytes32 _sellID , TokenPair memory _tokens ) private view returns ( SettlementDetails memory ) { Fraction memory midPrice = Fraction ( orderDetails [ _buyID ] . price + orderDetails [ _sellID ] . price , 2 ) ; uint256 commonVolume = Math . min256 ( orderDetails [ _buyID ] . volume , orderDetails [ _sellID ] . volume ) ; if ( isEthereumBased ( _tokens . secondaryToken . addr ) ) { uint256 secondaryTokenVolume = joinFraction ( commonVolume , 1 , int16 ( _tokens . secondaryToken . decimals ) - VOLUME_OFFSET ) ; ValueWithFees memory secondaryVwF = subtractDarknodeFee ( secondaryTokenVolume ) ; return SettlementDetails ( { leftVolume : 0 , rightVolume : 0 , leftTokenFee : secondaryVwF . fees , rightTokenFee : secondaryVwF . fees , leftTokenAddress : _tokens . secondaryToken . addr , rightTokenAddress : _tokens . secondaryToken . addr } ) ; } else if ( isEthereumBased ( _tokens . priorityToken . addr ) ) { uint256 priorityTokenVolume = joinFraction ( commonVolume . mul ( midPrice . numerator ) , midPrice . denominator , int16 ( _tokens . priorityToken . decimals ) - PRICE_OFFSET - VOLUME_OFFSET ) ; ValueWithFees memory priorityVwF = subtractDarknodeFee ( priorityTokenVolume ) ; return SettlementDetails ( { leftVolume : 0 , rightVolume : 0 , leftTokenFee : priorityVwF . fees , rightTokenFee : priorityVwF . fees , leftTokenAddress : _tokens . priorityToken . addr , rightTokenAddress : _tokens . priorityToken . addr } ) ; } else { revert ( "non-eth atomic swaps are not supported" ) ; } }
function contractExists ( address contract_address ) public view returns ( bool ) { uint size ; assembly { size := extcodesize ( contract_address ) } return size > 0 ; }
function consume ( uint256 amount ) isPeonyContract returns ( bool ) { require ( balances [ owner ] . sub ( amount ) >= 0 ) ; require ( totalSupply . sub ( amount ) >= 0 ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; totalSupply = totalSupply . sub ( amount ) ; return true ; }
function _transfer_byProxy ( address sender , address to , uint value , bytes data ) internal returns ( bool ) { uint received = amountReceived ( value ) ; uint fee = safeSub ( value , received ) ; return _internalTransfer ( sender , to , received , fee , data ) ; }
function setSecurityGuard ( address _newSecurityGuard ) onlyOwner { securityGuard = _newSecurityGuard ; }
function getAllCollectionNames ( ) public view returns ( bytes8 [ ] ) { return collectionNames ; }
function getContestStatusForDate ( uint32 _date ) external view returns ( int256 , int256 , int256 ) { DailyContestStatus memory dailyContestStatus = dateToContestStatus [ _date ] ; int256 numRegistered = int256 ( dailyContestStatus . numRegistered ) ; int256 numCompleted = int256 ( dailyContestStatus . numCompleted ) ; int256 bonus = int256 ( calculateBonus ( _date ) ) ; if ( uint32 ( now ) <= _date . add ( WITHDRAW_BUFFER ) ) { numCompleted = - 1 ; bonus = - 1 ; } return ( numRegistered , numCompleted , bonus ) ; }
function getMatchPoints ( uint256 matchIndex , uint160 matches , MatchResult [ ] matchResults , bool [ ] starMatches ) private pure returns ( uint16 matchPoints ) { uint8 tResult = uint8 ( matches & MATCH_RESULT_MASK ) ; uint8 tUnder49 = uint8 ( ( matches >> 2 ) & MATCH_UNDEROVER_MASK ) ; uint8 tTouchdowns = uint8 ( ( matches >> 3 ) & MATCH_TOUCHDOWNS_MASK ) ; uint8 rResult = matchResults [ matchIndex ] . result ; uint8 rUnder49 = matchResults [ matchIndex ] . under49 ; uint8 rTouchdowns = matchResults [ matchIndex ] . touchdowns ; if ( rResult == tResult ) { matchPoints += 5 ; if ( rResult == 0 ) { matchPoints += 5 ; } if ( starMatches [ matchIndex ] ) { matchPoints += 2 ; } } if ( tUnder49 == rUnder49 ) { matchPoints += 1 ; } if ( tTouchdowns == rTouchdowns ) { matchPoints += 4 ; } }
function currentHalving ( ) public constant notBeforeGenesis returns ( uint256 ) { return blockHalving ( currentBlock ( ) ) ; }
function pledgeFees ( uint _value ) public onlyController returns ( bool ) { uint curTotalFees = totalPledgedFees ( ) ; require ( curTotalFees + _value >= curTotalFees ) ; updateValueAtNow ( totalPledgedFeesHistory , curTotalFees + _value ) ; return true ; }
function setMaximumRate ( uint256 _newRate ) onlyOwner public { require ( _newRate <= hardCodedMaximumRate ) ; maximumRate = _newRate ; RateChanged ( 1 , _newRate ) ; }
function getListingsInRange ( uint64 _startIndex , uint64 _endIndex ) public view returns ( uint64 [ ] ) { require ( _startIndex <= totalListings ( ) , "Start index is out of bounds" ) ; require ( _endIndex <= totalListings ( ) , "End index is out of bounds" ) ; require ( _startIndex <= _endIndex , "End index is less than the start index" ) ; uint64 length = _endIndex - _startIndex ; uint64 [ ] memory indexes = new uint64 [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { indexes [ i ] = forSalePixelconIndexes [ _startIndex + i ] ; } return indexes ; }
function claimRefundsFor ( address [ ] _beneficiaries ) external afterSaleFail { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { claimRefundFor ( _beneficiaries [ i ] ) ; } }
function upgradeStorage ( address addrAdverStorage ) public onlyOwner ( "upgradeStorage" ) { for ( uint i = 0 ; i < bidIdList . length ; i ++ ) { cancelCampaign ( bidIdList [ i ] ) ; } delete bidIdList ; lastBidId = advertisementStorage . getLastBidId ( ) ; advertisementFinance . setAdsStorageAddress ( addrAdverStorage ) ; advertisementStorage = BaseAdvertisementStorage ( addrAdverStorage ) ; }
function proxiedContribution ( address _miner ) public payable returns ( bool ) { if ( _miner == address ( 0 ) ) { return contribute ( msg . sender ) ; } else { return contribute ( _miner ) ; } }
function setRegisteredAuthority ( Data storage self , string issuerFirm , address authorityAddress , bool approved ) internal returns ( bool success ) { require ( isRegisteredFirm ( self , issuerFirm ) , "Error: `issuerFirm` must be registered." ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'registered.authority' , issuerFirm , authorityAddress ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'registered.authority.firm' , authorityAddress ) ) ; require ( self . Storage . setBool ( id_a , approved ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( self . Storage . setString ( id_b , issuerFirm ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; return true ; }
function paymentAction ( bytes32 _requestId , uint256 [ ] _payeeAmounts , uint256 [ ] _additionalAmounts ) external whenNotPaused { if ( requestCore . getState ( _requestId ) == RequestCore . State . Created && msg . sender == requestCore . getPayer ( _requestId ) ) { acceptAction ( _requestId ) ; } if ( _additionalAmounts . length != 0 ) { additionalAction ( _requestId , _additionalAmounts ) ; } paymentInternal ( _requestId , _payeeAmounts ) ; }
function setBursar ( address _newBursar ) external requireGod { require ( _newBursar != address ( 0 ) ) ; bursarAddress = _newBursar ; }
function transferOwnership ( address _newOwner ) onlyOwner { if ( _newOwner != address ( 0 ) ) { newOwner = _newOwner ; } }
function unpause ( ) public onlyCEO whenPaused { require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < _allTokens . length ) ; return _allTokens [ _index ] ; }
function approve ( address spender , uint256 amount ) public returns ( bool success ) { require ( mOnApprove ( msg . sender , spender , amount ) ) ; require ( ( amount == 0 ) || ( _allowed [ msg . sender ] [ spender ] == 0 ) ) ; _allowed [ msg . sender ] [ spender ] = amount ; Approval ( msg . sender , spender , amount ) ; return true ; }
function isContract ( address _address ) private view returns ( bool ) { uint256 _size ; assembly { _size := extcodesize ( _address ) } return _size > 0 ; }
function transfer ( address _to , uint256 _value ) returns ( bool ) { payDividendsTo ( msg . sender ) ; payDividendsTo ( _to ) ; return super . transfer ( _to , _value ) ; }
function renewableOf ( uint256 _productId ) public view returns ( bool ) { return products [ _productId ] . renewable ; }
function unfreeze ( ) public onlyOwner returns ( bool ) { require ( ! unfrozen ) ; unfrozen = true ; emit Unfreeze ( ) ; return true ; }
function emergencySplitToggle ( ) external { splitInService = ! splitInService ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = allStarIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function _updateTransfer ( address _from , address _to , uint256 _value , bytes _data ) internal nonReentrant returns ( bool ) { _adjustInvestorCount ( _from , _to , _value ) ; bool verified = _verifyTransfer ( _from , _to , _value , _data , true ) ; _adjustBalanceCheckpoints ( _from ) ; _adjustBalanceCheckpoints ( _to ) ; return verified ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( state == State . stage1 && now > dateTimeContract . toTimestamp ( 2018 , 3 , 9 , 12 ) ) { state = State . stage2 ; } else if ( state == State . stage2 && now > dateTimeContract . toTimestamp ( 2018 , 3 , 16 , 12 ) ) { state = State . stage3 ; } else if ( state == State . stage3 && now > dateTimeContract . toTimestamp ( 2018 , 3 , 23 , 12 ) ) { state = State . stage4 ; } else if ( now > ICOdeadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
function mine ( address _target , uint256 _minedAmount ) onlyDoftManager { require ( _minedAmount > 0 ) ; require ( _target != 0x0 ) ; require ( miningStorage - _minedAmount >= 0 ) ; require ( balanceOf [ doftManager ] >= _minedAmount ) ; require ( balanceOf [ _target ] + _minedAmount > balanceOf [ _target ] ) ; balanceOf [ doftManager ] -= _minedAmount ; balanceOf [ _target ] += _minedAmount ; miningStorage -= _minedAmount ; Mine ( _target , _minedAmount ) ; }
function tokenBurn ( uint _amount ) public onlyOwner { require ( crowdsaleClosed == true ) ; tokenReward . transfer ( address ( 0 ) , _amount ) ; }
function batchTransfer ( address [ ] recipients , uint [ ] quantities ) external pausableIfNotSelfDestructing returns ( bool ) { return _batchTransfer ( msg . sender , recipients , quantities ) ; }
function tokenBurner ( uint256 _amount ) onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( totalSupply . sub ( _amount ) > 0 ) ; require ( balances [ msg . sender ] > _amount ) ; require ( balances [ msg . sender ] . sub ( _amount ) > 0 ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; Transfer ( msg . sender , 0 , _amount ) ; return true ; }
function getApproved ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( address ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( owner != address ( 0 ) , "PixelCon does not exist" ) ; return tokenApprovals [ _tokenId ] ; }
function reclaim ( ) public onlyOwner returns ( bool ) { require ( block . timestamp > releaseDate ) ; uint256 reclaimableAmount = token . balanceOf ( address ( this ) ) ; token . safeTransfer ( owner , reclaimableAmount ) ; emit Reclaim ( reclaimableAmount ) ; return true ; }
function getArrayAddress ( bytes32 _key ) internal view returns ( address [ ] ) { return addressArrayStorage [ _key ] ; }
function setFeeContract ( Data storage self , address feeContract ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.account' , address ( this ) ) ) ; require ( self . Storage . setAddress ( id , feeContract ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function convertOldTokens ( address _receiver , uint256 _oldAmount ) external onlyOwner { require ( _receiver != address ( 0 ) ) ; require ( _oldAmount > 0 ) ; uint256 amountNewTokens = _oldAmount . mul ( 2 ) ; balances [ owner ] = balances [ owner ] . sub ( amountNewTokens ) ; balances [ _receiver ] = balances [ _receiver ] . add ( amountNewTokens ) ; }
function buyTokenFromModerator ( uint _proposalID , address _buyer , uint _date , bool _presale ) payable external returns ( bool ) { if ( msg . sender != fundings [ _proposalID ] . moderator ) throw ; return buyTokensFor ( _proposalID , _buyer , _date , _presale ) ; }
function changeWCT2Controller ( address _newController ) public onlyController { wct2 . changeController ( _newController ) ; }
function withdrawFreeBalance ( ) external { uint256 freeBalance = this . balance - outstandingEther ; address deedContractAddress = address ( deedContract ) ; require ( msg . sender == owner || msg . sender == deedContractAddress ) ; deedContractAddress . transfer ( freeBalance ) ; }
function isFulfilled ( ContentMapping storage self , bytes32 _id , address _creator , address _brand ) public view returns ( bool ) { return self . data [ _id ] . deliverable . isFulfilled ( _creator , _brand ) ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalElements = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 elementId ; for ( elementId = 0 ; elementId < totalElements ; elementId ++ ) { if ( elementToOwner [ elementId ] == _owner ) { result [ resultIndex ] = elementId ; resultIndex ++ ; } } return result ; } }
function claim ( address _arbitrator , uint256 _transactionId ) public { Lock memory lock = escrows [ _arbitrator ] [ _transactionId ] ; require ( lock . sender == msg . sender ) ; require ( lock . paid ) ; require ( lock . expiration < block . timestamp ) ; require ( lock . expiration != 0 ) ; require ( lock . expiration != 1 ) ; delete escrows [ _arbitrator ] [ _transactionId ] ; token . transfer ( msg . sender , lock . value . add ( lock . fee ) ) ; Released ( _arbitrator , msg . sender , _transactionId ) ; }
function _distributeReferrers ( uint256 _userId , uint256 _sum ) private { uint256 [ ] memory referrers = users [ _userId ] . referrersByLevel ; for ( uint i = 0 ; i < referralLevelsCount ; i ++ ) { uint256 referrerId = referrers [ i ] ; if ( referrers [ i ] == 0 ) break ; if ( users [ referrerId ] . totalPay < minSumReferral ) continue ; uint16 [ ] memory percents = getReferralPercents ( users [ referrerId ] . totalPay ) ; uint256 value = _sum * percents [ i ] / 10000 ; users [ referrerId ] . balance = users [ referrerId ] . balance . add ( value ) ; users [ referrerId ] . referrersReceived = users [ referrerId ] . referrersReceived . add ( value ) ; emit ReferrerDistribute ( _userId , referrerId , value ) ; } }
function setSymbol ( string _symbol ) onlyOwner { symbol = _symbol ; LogSetSymbol ( _symbol ) ; }
function getPendingVersionTimestamp ( ) public view returns ( uint ) { return pendingVersionTimestamp ; }
function arbitrateCancelCampaign ( ) onlyArbitrator campaignNotCanceled { campaignCanceled = true ; CampaignCalncelled ( ) ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( state != State . Successful ) { if ( state == State . EarlyPreSale && now > startTime . add ( 8 days ) ) { StageDistributed ( state , stageDistributed ) ; state = State . PreSale ; stageDistributed = 0 ; } else if ( state == State . PreSale && now > startTime . add ( 15 days ) ) { StageDistributed ( state , stageDistributed ) ; state = State . Crowdsale ; stageDistributed = 0 ; } else if ( state == State . Crowdsale && now > startTime . add ( 36 days ) ) { StageDistributed ( state , stageDistributed ) ; state = State . Successful ; completedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } } }
function getPermissionParamsLength ( address _entity , address _app , bytes32 _role ) external view returns ( uint ) { return permissionParams [ permissions [ permissionHash ( _entity , _app , _role ) ] ] . length ; }
function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; isOperatorFor [ _operator ] [ msg . sender ] = false ; emit RevokedOperator ( _operator , msg . sender ) ; }
function mBeforeStateTransition ( ETOState oldState , ETOState newState ) internal constant returns ( ETOState newStateOverride ) ;
function getUserBalance ( address _user ) public view onlyAllowed returns ( uint256 _balance ) { return balanceUsers [ _user ] ; }
function refund ( ) public returns ( bool ) ;
function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { require ( state == State . Successful ) ; require ( _address != address ( tokenReward ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
function hasAssetRights ( address _owner , bytes32 _symbol ) public view returns ( bool ) { uint holderId = getHolderId ( _owner ) ; return isCreated ( _symbol ) && ( _assetOwner ( _symbol ) == holderId || get ( store , assetPartowners , _symbol , holderId ) ) ; }
function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { claimTokens ( _from ) ; claimTokens ( _to ) ; return true ; }
function approve ( address _to , uint256 _tokenId ) external { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
function changeFactorySetupFee ( uint256 _newSetupCost ) public onlyOwner { emit ChangeFactorySetupFee ( setupCost , _newSetupCost , address ( this ) ) ; setupCost = _newSetupCost ; }
function settle ( ) { data . settle ( ) ; ChannelSettled ( data . settled ) ; }
function setValidatorSigningKey ( address newSigningKey ) external { require ( isValidator ( msg . sender ) , "only validators may modify validator signing keys" ) ; require ( _signingKeys [ newSigningKey ] == address ( 0 ) , "a signing key matching the provided address already exists" ) ; delete _signingKeys [ _validators [ msg . sender ] . signingKey ] ; _validators [ msg . sender ] . signingKey = newSigningKey ; _signingKeys [ newSigningKey ] = msg . sender ; emit ValidatorSigningKeyModified ( msg . sender , newSigningKey ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) onlyAllowed ( ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
function claimTokens ( address _token ) public onlyOwner { require ( _token != address ( snt ) ) ; if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
function deleteMinter ( address _who ) public onlyOwner returns ( bool ) { _setMinter ( _who , false ) ; }
function amountReceived ( uint value ) public view returns ( uint ) { return safeDiv_dec ( value , safeAdd ( UNIT , transferFeeRate ) ) ; }
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) { _snapshotBlock = block . number ; } MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
function getMeal ( uint256 _tokenId ) public view returns ( string mealName , uint256 sellingPrice , address owner ) { Meal storage meal = meals [ _tokenId ] ; mealName = meal . name ; sellingPrice = mealIndexToPrice [ _tokenId ] ; owner = mealIndexToOwner [ _tokenId ] ; }
function init ( ) public auth { gem . approve ( tub , uint ( - 1 ) ) ; skr . approve ( tub , uint ( - 1 ) ) ; dai . approve ( tub , uint ( - 1 ) ) ; gov . approve ( tub , uint ( - 1 ) ) ; gem . approve ( owner , uint ( - 1 ) ) ; skr . approve ( owner , uint ( - 1 ) ) ; dai . approve ( owner , uint ( - 1 ) ) ; gov . approve ( owner , uint ( - 1 ) ) ; dai . approve ( otc , uint ( - 1 ) ) ; gem . approve ( otc , uint ( - 1 ) ) ; tubParamUpdate ( ) ; }
function ( ) payable internal { uint amount = msg . value * buyPrice ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value >= 0 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
function revokeAttestation ( bytes32 _link ) external { revokeAttestationForUser ( _link , msg . sender ) ; }
function commRate ( uint256 newCommRate ) isOwner { require ( newCommRate > 0 ) ; require ( commRate != newCommRate ) ; commRate = newCommRate ; updatePrices ( ) ; }
function getVestingTime ( address account , uint index ) public view returns ( uint ) { return getVestingScheduleEntry ( account , index ) [ TIME_INDEX ] ; }
function forwardFunds ( uint256 toFund ) internal { vault . deposit . value ( toFund ) ( msg . sender ) ; }
function respondChallengeBefore ( uint64 slot , bytes32 challengingTxHash , uint256 respondingBlockNumber , bytes respondingTransaction , bytes proof , bytes signature ) external { require ( challenges [ slot ] . contains ( challengingTxHash ) , "Responding to non existing challenge" ) ; uint256 index = uint256 ( challenges [ slot ] . indexOf ( challengingTxHash ) ) ; checkResponse ( slot , index , respondingBlockNumber , respondingTransaction , signature , proof ) ; slashBond ( challenges [ slot ] [ index ] . challenger , msg . sender ) ; coins [ slot ] . state = State . EXITING ; challenges [ slot ] . remove ( challengingTxHash ) ; emit RespondedExitChallenge ( slot ) ; }
function claimTokens ( ERC20TokenInterface _address , address _to ) onlyAdmin public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }
function approveAccount ( address target , bool approve ) onlyAdmin public { approvedAccount [ target ] = approve ; emit ApprovedAccount ( target , approve ) ; }
function withdrawFees ( address account , uint value ) external onlyFeeAuthority returns ( bool ) { require ( account != address ( 0 ) , "Must supply an account address to withdraw fees" ) ; if ( value == 0 ) { return false ; } tokenState . setBalanceOf ( FEE_ADDRESS , safeSub ( tokenState . balanceOf ( FEE_ADDRESS ) , value ) ) ; tokenState . setBalanceOf ( account , safeAdd ( tokenState . balanceOf ( account ) , value ) ) ; emitFeesWithdrawn ( account , value ) ; emitTransfer ( FEE_ADDRESS , account , value ) ; return true ; }
function ( ) payable { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender , msg . sig , msg . data ) ) revert ( ) ; } else { revert ( ) ; } }
function takeFee ( uint256 _amount ) public withPerm ( FEE_ADMIN ) returns ( bool ) { require ( polyToken . transferFrom ( address ( this ) , IModuleFactory ( factory ) . owner ( ) , _amount ) , "Unable to take fee" ) ; return true ; }
function transfer ( address _to , uint256 _value ) public saleOrUnfrozen ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }
function ( ) payable { require ( isContract ( controller ) ) ; bool proxyPayment = TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ; require ( proxyPayment ) ; }
function createSeries ( bytes name , uint shares , string industry , string symbol , address extraContract ) payable returns ( address seriesAddress , uint seriesId ) { seriesId = series . length ; var ( latestAddress , latestName ) = SeriesFactory ( seriesFactory ) . createSeries . value ( msg . value ) ( seriesId , name , shares , industry , symbol , msg . sender , extraContract ) ; if ( latestAddress == 0 ) throw ; if ( latestName > 0 ) if ( seriesByName [ latestName ] == 0 ) seriesByName [ latestName ] = latestAddress ; else throw ; series . push ( latestAddress ) ; expiresAt [ latestAddress ] = now + 1 years ; latestSeriesForUser [ msg . sender ] = latestAddress ; seriesByAddress [ latestAddress ] = latestName ; SeriesCreated ( latestAddress , seriesId ) ; return ( latestAddress , seriesId ) ; }
function getTokensBalance ( uint index ) private view returns ( uint ) { Airdrop memory airdrop = airdrops [ index ] ; Token t = Token ( airdrop . tokenSC ) ; return ( t . balanceOf ( this ) ) ; }
function changeAdmin ( address newAdmin ) public validate_address ( newAdmin ) onlyAdmin { if ( admin == newAdmin ) revert ( ) ; AdminOwnershipTransferred ( admin , newAdmin ) ; admin = newAdmin ; }
function updateLimitPerMonth ( bytes32 _externalHolderId , uint _limit ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; uint _currentLimit = holders [ _holderIndex ] . sendLimPerDay ; holders [ _holderIndex ] . sendLimPerMonth = _limit ; _emitMonthLimitChanged ( _externalHolderId , _currentLimit , _limit ) ; return OK ; }
function release ( IERC20 token ) public { uint256 unreleased = _releasableAmount ( token ) ; require ( unreleased > 0 ) ; _released [ token ] = _released [ token ] . add ( unreleased ) ; token . safeTransfer ( _beneficiary , unreleased ) ; emit TokensReleased ( token , unreleased ) ; }
function orderDepth ( bytes32 _orderID ) external view returns ( uint256 ) { if ( orders [ _orderID ] . blockNumber == 0 ) { return 0 ; } return ( block . number - orders [ _orderID ] . blockNumber ) ; }
function addFunctions ( address _functions ) public onlyOwner { require ( address ( functions ) == 0x0 ) ; functions = Functions ( _functions ) ; }
function approveCodeUpgrade ( address _newAddress ) external returns ( bool ) { require ( msg . sender == currentApplicationEntityAddress ) ; uint8 atState = currentApp . CurrentEntityState ( ) ; lockCurrentApp ( ) ; if ( ! currentApp . transferAssetsToNewApplication ( _newAddress ) ) { revert ( ) ; } link ( _newAddress ) ; currentApp . setUpgradeState ( atState ) ; return true ; }
function removeNFToken ( address _from , uint256 _tokenId ) internal { require ( idToOwner [ _tokenId ] == _from ) ; assert ( ownerToNFTokenCount [ _from ] > 0 ) ; ownerToNFTokenCount [ _from ] = ownerToNFTokenCount [ _from ] - 1 ; delete idToOwner [ _tokenId ] ; }
function isCreated ( bytes32 _symbol ) public view returns ( bool ) { return _assetOwner ( _symbol ) != 0 ; }
function decreaseApprovalWithSender ( address _sender , address _spender , uint256 _subtractedValue ) public onlyProxy returns ( bool success ) { require ( _spender != address ( 0 ) ) ; uint256 currentAllowance = erc20Store . allowed ( _sender , _spender ) ; uint256 newAllowance = currentAllowance - _subtractedValue ; require ( newAllowance <= currentAllowance ) ; erc20Store . setAllowance ( _sender , _spender , newAllowance ) ; erc20Proxy . emitApproval ( _sender , _spender , newAllowance ) ; return true ; }
function approve ( address _spender , uint256 _value ) public returns ( bool _success ) ;
function approveAllowance ( Data storage self , address spender , uint amount ) internal returns ( bool success ) { require ( spender != 0x0 , "Error: `spender` address cannot be null." ) ; string memory currency = getTokenSymbol ( self , address ( this ) ) ; require ( getTokenFrozenBalance ( self , currency , getForwardedAccount ( self , spender ) ) == 0 , "Error: Spender must not have a frozen balance directly" ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.allowance' , currency , getForwardedAccount ( self , msg . sender ) , getForwardedAccount ( self , spender ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , msg . sender ) ) ) ; require ( self . Storage . getUint ( id_a ) == 0 || amount == 0 , "Error: Allowance must be zero (0) before setting an updated allowance for spender." ) ; require ( self . Storage . getUint ( id_b ) >= amount , "Error: Allowance cannot exceed msg.sender token balance." ) ; require ( self . Storage . setUint ( id_a , amount ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; emit Approval ( msg . sender , spender , amount ) ; return true ; }
function artWorkChangeRequest ( uint256 _tokenId , string _meta , uint8 _v , bytes32 _r , bytes32 _s ) public payable returns ( uint256 ) { address recoveredSigner = verify ( keccak256 ( _meta ) , _v , _r , _s ) ; require ( signers [ recoveredSigner ] == true ) ; require ( msg . sender == token . getOwner ( _tokenId ) ) ; uint256 fee = getArtWorkChangeFee ( _tokenId ) ; require ( msg . value >= fee ) ; uint256 changeRequestCounter = artWorkChangeRequests . length ; artWorkChangeRequests . push ( ArtWorkChangeRequest ( msg . sender , _tokenId , changeRequestCounter , _meta , now , false ) ) ; token . increaseUpdateMetadataCounter ( _tokenId ) ; transferEthers ( platformWallet , msg . value ) ; emit ArtWorkChangeRequestMade ( msg . sender , _tokenId , changeRequestCounter , _meta , msg . value , now ) ; return changeRequestCounter ; }
function areaRentPrice ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint numberOfPeriods ) public view returns ( uint ) { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; return rentals . blocksRentPrice ( numberOfPeriods , blocksList ( fromX , fromY , toX , toY ) ) ; }
function createRequestFromBytes ( bytes _data ) external whenNotPaused returns ( bytes32 requestId ) { require ( isTrustedContract ( msg . sender ) , "caller should be a trusted contract" ) ; address creator = extractAddress ( _data , 0 ) ; address payer = extractAddress ( _data , 20 ) ; require ( creator != 0 , "creator should not be 0" ) ; uint8 payeesCount = uint8 ( _data [ 40 ] ) ; uint256 offsetDataSize = uint256 ( payeesCount ) . mul ( 52 ) . add ( 41 ) ; uint8 dataSize = uint8 ( _data [ offsetDataSize ] ) ; string memory dataStr = extractString ( _data , dataSize , offsetDataSize . add ( 1 ) ) ; address mainPayee ; int256 mainExpectedAmount ; if ( payeesCount != 0 ) { mainPayee = extractAddress ( _data , 41 ) ; mainExpectedAmount = int256 ( extractBytes32 ( _data , 61 ) ) ; } requestId = generateRequestId ( ) ; requests [ requestId ] = Request ( payer , msg . sender , State . Created , Payee ( mainPayee , mainExpectedAmount , 0 ) ) ; emit Created ( requestId , mainPayee , payer , creator , dataStr ) ; for ( uint8 i = 1 ; i < payeesCount ; i = i . add ( 1 ) ) { address subPayeeAddress = extractAddress ( _data , uint256 ( i ) . mul ( 52 ) . add ( 41 ) ) ; require ( subPayeeAddress != 0 , "subpayee should not be 0" ) ; subPayees [ requestId ] [ i - 1 ] = Payee ( subPayeeAddress , int256 ( extractBytes32 ( _data , uint256 ( i ) . mul ( 52 ) . add ( 61 ) ) ) , 0 ) ; emit NewSubPayee ( requestId , subPayeeAddress ) ; } return requestId ; }
function assignTeamTokens ( ) public onlyOwnerAndDirector { require ( ! assignedTeam ) ; assignedTeam = true ; _teamTransfer ( 0x1E21f744d91994D19f2a61041CD7cCA571185dfc , 13674375 * cstToMicro ) ; _teamTransfer ( 0x4CE4Ea57c40bBa26B7b799d5e0b4cd063B034c8A , 9920625 * cstToMicro ) ; _teamTransfer ( 0xdCd8a8e561d23Ca710f23E7612F1D4E0dE9bde83 , 1340625 * cstToMicro ) ; _teamTransfer ( 0x0dFFA8624A1f512b8dcDE807F8B0Eab68672e5D5 , 13406250 * cstToMicro ) ; _teamTransfer ( 0xE091180bB0C284AA0Bd15C6888A41aba45c54AF0 , 13138125 * cstToMicro ) ; _teamTransfer ( 0xcdB7A51bA9af93a7BFfe08a31E4C6c5f9068A051 , 3960000 * cstToMicro ) ; _teamTransfer ( 0x57Bd10E12f789B74071d62550DaeB3765Ad83834 , 3960000 * cstToMicro ) ; _teamTransfer ( 0xEE74922eaF503463a8b20aFaD83d42F28D59f45d , 3960000 * cstToMicro ) ; _teamTransfer ( 0x58681a49A6f9D61eB368241a336628781afD5f87 , 1320000 * cstToMicro ) ; _teamTransfer ( 0x3C4662b4677dC81f16Bf3c823A7E6CE1fF7e94d7 , 80000 * cstToMicro ) ; _teamTransfer ( 0x041A1e96E0C9d3957613071c104E44a9c9d43996 , 150000 * cstToMicro ) ; _teamTransfer ( 0xD63d63D2ADAF87B0Edc38218b0a2D27FD909d8B1 , 100000 * cstToMicro ) ; _teamTransfer ( 0xd0d49Da78BbCBb416152dC41cc7acAb559Fb8275 , 80000 * cstToMicro ) ; _teamTransfer ( 0x75FdfAc64c27f5B5f0823863Fe0f2ddc660A376F , 100000 * cstToMicro ) ; _teamTransfer ( 0xb66AFf323d97EF52192F170fF0F16D0a05Ebe56C , 60000 * cstToMicro ) ; _teamTransfer ( 0xec6234E34477f7A19cD3D67401003675522a4Fad , 60000 * cstToMicro ) ; _teamTransfer ( 0x1be50e8337F99983ECd4A4b15a74a5a795B73dF9 , 40000 * cstToMicro ) ; _teamTransfer ( 0x4c14DB011065e72C6E839bd826d101Ec09d3C530 , 833000 * cstToMicro ) ; _teamTransfer ( 0x7891C07b20fFf1918fAD43CF6fc7E3f83900f06d , 50000 * cstToMicro ) ; _teamTransfer ( 0x27996b3c1EcF2e7cbc5f31dE7Bca17EFCb398617 , 150000 * cstToMicro ) ; }
function multisend ( address tokenAddress , address [ ] destinations , uint256 [ ] values ) external onlyOwner { require ( destinations . length == values . length ) ; uint256 i = 0 ; while ( i < destinations . length ) { Nomin ( tokenAddress ) . transferSenderPaysFee ( destinations [ i ] , values [ i ] ) ; i += 1 ; } }
function blockSubsidy ( uint256 _block ) public constant notBeforeGenesis returns ( uint256 ) { uint256 halvings = _block . div ( subsidyHalvingInterval ) ; if ( halvings >= maxHalvings ) return 0 ; uint256 subsidy = INITIAL_SUBSIDY >> halvings ; return subsidy ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { bool transferred = super . transfer ( to , value ) ; if ( transferred ) { addBalanceBlocks ( msg . sender ) ; addBalanceBlocks ( to ) ; if ( ! holdersMap [ to ] ) { holdersMap [ to ] = true ; holders . push ( to ) ; } } return transferred ; }
function upgrade ( uint256 value ) external { if ( getState ( ) != State . Success ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( finalizedUpgrade ) throw ; if ( value == 0 ) throw ; if ( value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }
function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description , bool isRestricted , bool isOnlyPersonal , address secondarySource , uint256 secondaryAttributeTypeID , uint256 minimumRequiredStake , uint256 jurisdictionFee ) { return ( _attributeTypes [ attributeTypeID ] . description , _attributeTypes [ attributeTypeID ] . restricted , _attributeTypes [ attributeTypeID ] . onlyPersonal , _attributeTypes [ attributeTypeID ] . secondarySource , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID , _attributeTypes [ attributeTypeID ] . minimumStake , _attributeTypes [ attributeTypeID ] . jurisdictionFee ) ; }
function setApprovalForAll ( address _operator , bool _approved ) external { require ( _operator != msg . sender ) ; operators [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
function tokenFactory ( uint256 _amount ) onlyOwner returns ( bool success ) { require ( _amount > 0 ) ; require ( tokenMintingEnabled ) ; if ( ! tokenMint ( msg . sender , _amount ) ) revert ( ) ; return true ; }
function transfer ( address destination , uint256 amount ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; balances [ destination ] = balances [ destination ] . add ( amount ) ; emit Transfer ( msg . sender , destination , amount ) ; return true ; }
function bountyTokenWithdrawal ( ) public onlyOwner { require ( crowdsaleClosed == true ) ; require ( bountyPaid == false ) ; tokenReward . transfer ( beneficiary , bountyAmount ) ; bountyPaid = true ; }
function revealVote ( uint _pollID , uint _voteOption , uint _salt ) public { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( _voteOption , _salt ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; emit _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender ) ; }
function adminWithdraw ( address _to ) public { require ( msg . sender == admin , "Only the admin can call this function" ) ; _to . transfer ( address ( this ) . balance ) ; }
function addToonContract ( address _toonContractAddress ) external onlyOwner { ToonInterface _interface = ToonInterface ( _toonContractAddress ) ; require ( _interface . isToonInterface ( ) ) ; uint _index = toonContracts . push ( _interface ) - 1 ; addressToIndex [ _toonContractAddress ] = _index ; }
function cancel ( uint _price ) external returns ( bool ) ;
function setStepLimits ( uint256 _firstStepLimit , uint256 _secondStepLimit ) public onlyCLevel { firstStepLimit = _firstStepLimit ; secondStepLimit = _secondStepLimit ; }
function end ( List storage self ) internal view returns ( address ) { return self . list [ NULL ] . previous ; }
function createLoan ( Oracle _oracleContract , address _borrower , bytes32 _currency , uint256 _amount , uint256 _interestRate , uint256 _interestRatePunitory , uint256 _duesIn , uint256 _cancelableAt , uint256 _expirationRequest , string _metadata ) public returns ( uint256 ) { require ( ! deprecated ) ; require ( _cancelableAt <= _duesIn ) ; require ( _oracleContract != address ( 0 ) || _currency == 0x0 ) ; require ( _borrower != address ( 0 ) ) ; require ( _amount != 0 ) ; require ( _interestRatePunitory != 0 ) ; require ( _interestRate != 0 ) ; require ( _expirationRequest > block . timestamp ) ; var loan = Loan ( Status . initial , _oracleContract , _borrower , 0x0 , msg . sender , 0x0 , _amount , 0 , 0 , 0 , 0 , _interestRate , _interestRatePunitory , 0 , _duesIn , _currency , _cancelableAt , 0 , 0x0 , _expirationRequest , _metadata ) ; uint index = loans . push ( loan ) - 1 ; CreatedLoan ( index , _borrower , msg . sender ) ; if ( msg . sender == _borrower ) { approveLoan ( index ) ; } return index ; }
function changeSecurityLaunchFee ( uint256 _stLaunchFee ) external ;
function claimRefund ( ) public whenNotPaused { require ( hasEnded ( ) && ! goalReached ( ) && isRefunding ) ; vault . refund ( msg . sender ) ; token . refundTokens ( msg . sender , tokensBought [ msg . sender ] ) ; }
function getTags ( ) public view returns ( bytes32 [ ] ) ;
function getTagByModuleType ( uint8 _moduleType ) public view returns ( bytes32 [ ] ) { return availableTags [ _moduleType ] ; }
function forceRejectVotes ( bytes32 _key , address _user ) external onlyContractOwner returns ( uint ) { return _revoke ( _key , _user ) ; }
function claimTokens ( address _token ) public onlyOwner { ExchangerI exchanger = ExchangerI ( factory . exchanger ( ) ) ; require ( address ( exchanger ) != 0x0 ) ; ERC20Basic wpr = ERC20Basic ( exchanger . wpr ( ) ) ; require ( _token != address ( wct2 ) && _token != address ( wpr ) ) ; if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Basic token = ERC20Basic ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
function voteFor ( uint motionID ) external { uint weight = setupVote ( motionID ) ; vote [ msg . sender ] [ motionID ] = Vote . Yea ; votesFor [ motionID ] = safeAdd ( votesFor [ motionID ] , weight ) ; emit VotedFor ( msg . sender , motionID , weight ) ; }
function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceId_ERC721Exists ) ) ; }
function addTenParticipants ( address participant1 , address participant2 , address participant3 , address participant4 , address participant5 , address participant6 , address participant7 , address participant8 , address participant9 , address participant10 ) public onlyAdmin returns ( bool ) { require ( addParticipant ( participant1 ) ) ; require ( addParticipant ( participant2 ) ) ; require ( addParticipant ( participant3 ) ) ; require ( addParticipant ( participant4 ) ) ; require ( addParticipant ( participant5 ) ) ; require ( addParticipant ( participant6 ) ) ; require ( addParticipant ( participant7 ) ) ; require ( addParticipant ( participant8 ) ) ; require ( addParticipant ( participant9 ) ) ; require ( addParticipant ( participant10 ) ) ; return true ; }
function extractString ( bytes data , uint8 size , uint _offset ) internal pure returns ( string ) { bytes memory bytesString = new bytes ( size ) ; for ( uint j = 0 ; j < size ; j ++ ) { bytesString [ j ] = data [ _offset + j ] ; } return string ( bytesString ) ; }
function getSTFactoryAddress ( ) public view returns ( address ) { return getAddress ( Encoder . getKey ( "protocolVersionST" , getUint ( Encoder . getKey ( "latestVersion" ) ) ) ) ; }
function verifyTransfer ( address _from , address _to , uint256 , bool ) public returns ( Result ) { if ( ! paused ) { if ( allowAllTransfers ) { return Result . VALID ; } if ( allowAllBurnTransfers && ( _to == address ( 0 ) ) ) { return Result . VALID ; } if ( allowAllWhitelistTransfers ) { return ( onWhitelist ( _to ) && onWhitelist ( _from ) ) ? Result . VALID : Result . NA ; } if ( allowAllWhitelistIssuances && _from == issuanceAddress ) { if ( ! whitelist [ _to ] . canBuyFromSTO && isSTOAttached ( ) ) { return Result . NA ; } return onWhitelist ( _to ) ? Result . VALID : Result . NA ; } return ( ( onWhitelist ( _from ) && whitelist [ _from ] . fromTime <= now ) && ( onWhitelist ( _to ) && whitelist [ _to ] . toTime <= now ) ) ? Result . VALID : Result . NA ; } return Result . NA ; }
function batchCreateSingleSeedAuction ( uint8 [ ] _teamIds , uint8 [ ] _posIds , uint256 [ ] _attributes , uint256 [ ] _playerOverrideIds , uint256 [ ] _mlbPlayerIds , uint256 _startPrice ) public onlyGameManager whenNotPaused { require ( isBatchSupported ) ; require ( _teamIds . length > 0 && _posIds . length > 0 && _attributes . length > 0 && _playerOverrideIds . length > 0 && _mlbPlayerIds . length > 0 ) ; require ( nonFungibleContract != address ( 0 ) ) ; uint256 nftId ; require ( _startPrice != 0 ) ; for ( uint ii = 0 ; ii < _mlbPlayerIds . length ; ii ++ ) { require ( _teamIds [ ii ] != 0 ) ; nftId = nonFungibleContract . createSeedCollectible ( _teamIds [ ii ] , _posIds [ ii ] , _attributes [ ii ] , address ( this ) , 0 , _playerOverrideIds [ ii ] , _mlbPlayerIds [ ii ] ) ; _createSale ( nftId , _startPrice , 0 , SALES_DURATION , address ( this ) ) ; } }
function convertRate ( Oracle oracle , bytes32 currency , bytes data , uint256 amount ) public returns ( uint256 ) { if ( oracle == address ( 0 ) ) { return amount ; } else { uint256 rate ; uint256 decimals ; ( rate , decimals ) = oracle . getRate ( currency , data ) ; require ( decimals <= RCN_DECIMALS ) ; return ( safeMult ( safeMult ( amount , rate ) , ( 10 ** ( RCN_DECIMALS - decimals ) ) ) ) / PRECISION ; } }
function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceSignature_ERC721Optional ) || ( _interfaceID == InterfaceSignature_ERC721Enumerable ) || ( _interfaceID == InterfaceSignature_ERC721Metadata ) ) ; }
function approve ( address _to , uint256 _tokenId ) external whenNotPaused onlyOwnerOf ( _tokenId ) { address owner = ownerOf ( _tokenId ) ; require ( _to != owner ) ; if ( getApproved ( _tokenId ) != 0 || _to != 0 ) { tokenApprovals [ _tokenId ] = _to ; Approval ( owner , _to , _tokenId ) ; } }
function grant_token_from_offchain ( address _toAddr , uint _nTokens , string _ref ) public onlyRobot { require ( ( campaignState == 2 ) || ( campaignState == 1 ) ) ; do_grant_tokens ( _toAddr , _nTokens ) ; TokenGranted ( _toAddr , _nTokens , _ref ) ; }
function getValidator ( uint256 index ) external view returns ( address ) { return _validatorAccounts [ index ] ; }
function ( ) external { revert ( ) ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { approve ( _spender , _value ) ; if ( ! _spender . call ( bytes4 ( bytes32 ( keccak256 ( "receiveApproval(address,uint256,address,bytes)" ) ) ) , msg . sender , _value , this , _extraData ) ) { revert ( ) ; } return true ; }
function listPairForReserve ( address reserve , ERC20 token , bool ethToToken , bool tokenToEth , bool add ) public onlyOperator returns ( bool ) { require ( reserveType [ reserve ] != ReserveType . NONE ) ; if ( ethToToken ) { listPairs ( reserve , token , false , add ) ; ListReservePairs ( reserve , ETH_TOKEN_ADDRESS , token , add ) ; } if ( tokenToEth ) { listPairs ( reserve , token , true , add ) ; if ( add ) { require ( token . approve ( reserve , 2 ** 255 ) ) ; } else { require ( token . approve ( reserve , 0 ) ) ; } ListReservePairs ( reserve , token , ETH_TOKEN_ADDRESS , add ) ; } setDecimals ( token ) ; return true ; }
function getAnime ( uint256 _tokenId ) public view returns ( string animeName , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; animeName = person . name ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }
function multisend ( address [ ] _recipients , uint256 [ ] _balances ) external { require ( _recipients . length == _balances . length , "not equal length" ) ; require ( _recipients . length <= multiSendLimit , "more than limit" ) ; uint256 i = 0 ; for ( i ; i < _balances . length ; i ++ ) { transfer ( _recipients [ i ] , _balances [ i ] ) ; } emit Multisended ( ) ; }
function allowance ( address _owner , address _spender ) public view returns ( uint256 _remaining ) ;
function submitAnswer ( bytes32 question_id , bytes32 answer , uint256 max_previous ) external payable { }
function handleBelowPlannedWhitelistedContribution ( uint256 plannedContribution ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( msg . value ) ; AllowedContributionCheck ( msg . value , AllowedContributionState . BelowWhitelisted ) ; return ( msg . value , 0 ) ; }
function _transferSenderPaysFee_byProxy ( address sender , address to , uint value ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; return _internalTransfer ( sender , to , value , fee ) ; }
function attack ( uint256 _champId , uint256 _targetId ) external onlyOwnerOfChamp ( _champId ) isChampReady ( _champId ) notSelfAttack ( _champId , _targetId ) targetExists ( _targetId ) { Champ storage myChamp = champs [ _champId ] ; Champ storage enemyChamp = champs [ _targetId ] ; uint256 pointsGiven ; uint256 pointsToAttackPower ; uint256 myChampAttackPower ; uint256 enemyChampDefencePower ; uint256 myChampCooldownReduction ; ( myChampAttackPower , , myChampCooldownReduction ) = getChampStats ( _champId ) ; ( , enemyChampDefencePower , ) = getChampStats ( _targetId ) ; if ( myChampAttackPower > enemyChampDefencePower ) { if ( myChampAttackPower - enemyChampDefencePower < 5 ) { ( pointsGiven , pointsToAttackPower ) = _getPoints ( 3 ) ; } else if ( myChampAttackPower - enemyChampDefencePower < 10 ) { ( pointsGiven , pointsToAttackPower ) = _getPoints ( 2 ) ; } else { ( pointsGiven , pointsToAttackPower ) = _getPoints ( 1 ) ; } _attackCompleted ( myChamp , enemyChamp , pointsGiven , pointsToAttackPower ) ; emit Attack ( myChamp . id , enemyChamp . id , true ) ; } else { ( pointsGiven , pointsToAttackPower ) = _getPoints ( 1 ) ; _attackCompleted ( enemyChamp , myChamp , pointsGiven , pointsToAttackPower ) ; emit Attack ( enemyChamp . id , myChamp . id , false ) ; } myChamp . readyTime = uint256 ( block . timestamp + myChamp . cooldownTime - myChampCooldownReduction ) ; }
function assetPrices ( address asset ) public view returns ( uint ) { ( Error err , Exp memory result ) = fetchAssetPrice ( asset ) ; if ( err != Error . NO_ERROR ) { return 0 ; } return result . mantissa ; }
function name ( ) external pure returns ( string ) { return "Su Squares" ; }
function unlock ( ) public payable returns ( bool success ) { uint256 amount = lockedBalance [ msg . sender ] ; require ( amount > 0 ) ; require ( now >= timeRelease [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; lockedBalance [ msg . sender ] = 0 ; timeRelease [ msg . sender ] = 0 ; emit Transfer ( 0x0 , msg . sender , amount ) ; emit UnLock ( msg . sender , amount ) ; return true ; }
function addOwnToken ( ) internal returns ( bool ) { require ( setOwnContract ) ; addToWhitelist ( this , 5000 * 1e8 , 36500 ) ; setOwnContract = false ; return true ; }
function setVotingPeriod ( uint duration ) external onlyOwner { require ( MIN_VOTING_PERIOD <= duration && duration <= MAX_VOTING_PERIOD ) ; require ( duration <= havven . feePeriodDuration ( ) ) ; votingPeriod = duration ; }
function getAnimecard ( uint256 _tokenId ) external view returns ( string characterName , string studioName , string characterImageUrl , string characterImageHash , uint256 sellingPrice , address owner ) { Animecard storage animecard = animecards [ _tokenId ] ; characterName = animecard . characterName ; studioName = animecard . studioName ; characterImageUrl = animecard . characterImageUrl ; characterImageHash = animecard . characterImageHash ; sellingPrice = animecardToPrice [ _tokenId ] ; owner = animecardToOwner [ _tokenId ] ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = cardTokenToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function clearCollection ( uint64 _collectionIndex ) validIndex ( _collectionIndex ) public returns ( uint64 ) { require ( _collectionIndex < totalCollections ( ) , "Collection does not exist" ) ; uint64 [ ] storage collection = collectionTokens [ _collectionIndex ] ; require ( collection . length > 0 , "Collection is already cleared" ) ; for ( uint i = 0 ; i < collection . length ; i ++ ) { PixelCon storage pixelcon = pixelcons [ collection [ i ] ] ; require ( isCreatorAndOwner ( msg . sender , pixelcon . tokenId ) , "Sender is not the creator and owner of the PixelCons" ) ; pixelcon . collectionIndex = 0 ; } delete collectionNames [ _collectionIndex ] ; delete collectionTokens [ _collectionIndex ] ; emit ClearCollection ( _collectionIndex ) ; return _collectionIndex ; }
function disableNewStakes ( ) public onlyAdmin returns ( bool ) { newStakesAllowed = false ; return true ; }
function totalSupply ( bytes32 _symbol ) public view returns ( uint ) { return assets [ _symbol ] . totalSupply ; }
function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index <= ( rareArray . length - 1 ) ) ; return _index ; }
function buyToken ( ) internal { uint256 value = msg . value ; address sender = msg . sender ; require ( ! icoIsClosed ) ; require ( ! frozenAccount [ sender ] ) ; require ( value > 0 ) ; require ( currentTokenPrice > 0 ) ; uint256 amount = value / currentTokenPrice ; uint256 detract = amount / commRate ; uint256 moneyBack = value - ( amount * currentTokenPrice ) ; uint256 detract2 = value / commRate ; require ( tokenBalanceOf [ this ] >= amount ) ; amountOfInvestments = amountOfInvestments + ( value - moneyBack ) ; updatePrices ( ) ; _transfer ( this , sender , amount - detract ) ; if ( ! minimalGoalReached ) { checkMinimalGoal ( ) ; } if ( moneyBack > 0 ) { sender . transfer ( moneyBack - detract2 ) ; } }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }
function claimPrepaid ( uint _index , uint _boughtTokensPrice , uint _tokenAmount , string _privatePhrase , uint _backerRank ) external EarliestBackersSet { if ( backers [ msg . sender ] [ _index ] . prepaid == true && backers [ msg . sender ] [ _index ] . claimed == false && backers [ msg . sender ] [ _index ] . tokenAmount == _tokenAmount && backers [ msg . sender ] [ _index ] . tokenPrice == _boughtTokensPrice && backers [ msg . sender ] [ _index ] . privateHash == sha3 ( _privatePhrase , msg . sender ) && backers [ msg . sender ] [ _index ] . backerRank == _backerRank ) { backers [ msg . sender ] [ _index ] . claimed = true ; claimedPrepaidUnits += _tokenAmount ; PrepaidTokensClaimedEvent ( msg . sender , _index , _boughtTokensPrice , _tokenAmount ) ; } else { throw ; } }
function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused returns ( bool success ) { require ( _value > 0 ) ; require ( balanceOf [ _from ] >= _value ) ; require ( balanceOf [ _to ] + _value >= balanceOf [ _to ] ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }
function createInvite ( bytes _sig ) public onlyUser { address inviteAddress = signingLogic . recoverSigner ( keccak256 ( abi . encodePacked ( msg . sender ) ) , _sig ) ; require ( ! pendingInvites [ inviteAddress ] ) ; pendingInvites [ inviteAddress ] = true ; emit InviteCreated ( msg . sender , inviteAddress ) ; }
function hasSellerBeenAccepted ( address seller ) public view validAddress ( seller ) returns ( bool ) { return sellerInfo [ seller ] . createdAt != 0 ; }
function successful ( ) public { require ( state == State . Successful ) ; uint256 temp = pending [ creator ] ; pending [ creator ] = 0 ; require ( tokenReward . transfer ( creator , temp ) ) ; emit LogContributorsPayout ( creator , temp ) ; creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
function _adjustInvestorCount ( address _from , address _to , uint256 _value ) internal { TokenLib . adjustInvestorCount ( investorData , _from , _to , _value , balanceOf ( _to ) , balanceOf ( _from ) ) ; }
function getTiki ( uint256 _tokenId ) public view returns ( string tikiName , uint256 currentPrice , uint256 basePrice , address currentOwner , uint256 bagHolderFund , bool isBagFundAvailable ) { TikiMask storage tiki = tikiMasks [ _tokenId ] ; tikiName = tiki . name ; currentPrice = priceOf ( _tokenId ) ; basePrice = tiki . basePrice ; currentOwner = tikiIndexToOwner [ _tokenId ] ; bagHolderFund = tiki . bagHolderFund ; isBagFundAvailable = now > ( tiki . saleTime + priceFallDuration ) ; }
function getName ( ) public view returns ( bytes32 ) { return "ERC20DividendCheckpoint" ; }
function canAdvertise ( address advertiser , uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) external view returns ( bool ) { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; return ads . canAdvertiseOnBlocks ( advertiser , blocksList ( fromX , fromY , toX , toY ) ) ; }
function cloneTokens ( uint _from , uint _to ) ;
function getSTODetails ( ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , bool ) { return ( startTime , endTime , cap , rate , fundsRaised , investorCount , tokensSold , ( fundraiseType == FundraiseType . POLY ) ) ; }
function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) , "Spender is not provided" ) ; require ( signatures [ _signature ] == false , "No signature" ) ; bytes32 hashedTx = approvePreSignedHashing ( address ( this ) , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) , "From addres is not provided" ) ; allowed [ from ] [ _spender ] = _value ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , _value , _fee ) ; return true ; }
function mOnTransfer ( address from , address to , uint256 amount ) internal returns ( bool allow ) ;
function updateStageCap ( uint256 _tokens ) internal returns ( uint256 ) { Stage storage stage = stages [ currentStage ] ; uint256 cap = stage . cap ; if ( cap >= _tokens ) { stage . cap = cap . sub ( _tokens ) ; return 0 ; } stage . cap = 0 ; uint256 excessTokens = _tokens . sub ( cap ) ; if ( icoTokensLeft >= excessTokens ) { icoTokensLeft = icoTokensLeft . sub ( excessTokens ) ; return 0 ; } icoTokensLeft = 0 ; return excessTokens . sub ( icoTokensLeft ) ; }
function reclaimEther ( ) onlyOwner external { owner . transfer ( address ( this ) . balance ) ; }
function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = playerTokenToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
function transferToVault ( address _token ) external { require ( allowRecoverability ( _token ) , ERROR_DISALLOWED ) ; address vault = getRecoveryVault ( ) ; require ( isContract ( vault ) , ERROR_VAULT_NOT_CONTRACT ) ; if ( _token == ETH ) { vault . transfer ( address ( this ) . balance ) ; } else { uint256 amount = ERC20 ( _token ) . balanceOf ( this ) ; ERC20 ( _token ) . transfer ( vault , amount ) ; } }
function setOwner ( address _newOwner ) public onlyOwner { owner = _newOwner ; }
function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 0 ) ; return allPermissions ; }
function setPlotData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public whenNotPaused { require ( _owns ( msg . sender , _deedId ) && identifierToRentPeriodEndTimestamp [ _deedId ] < now || _rents ( msg . sender , _deedId ) ) ; _setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; }
function createNewGame ( string teamA , string teamB , string description , uint frozenTimestamp ) external onlyOwner { uint gameId = games . push ( Game ( teamA , 0 , teamB , 0 , 0 , description , frozenTimestamp , 0 , GameResults . NotYet , GameStates . Open , false ) ) - 1 ; emit GameHasOpened ( gameId , teamA , teamB , description , frozenTimestamp ) ; }
function isWhitelisted ( address _investor , uint256 _tier ) public constant returns ( bool ) { WhitelistedInvestor memory investor = investors [ _investor ] ; return ( investor . tier <= _tier && investor . status ) ; }
function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) { return FundInterface ( msg . sender ) . getManager ( ) == ofParticipant ; }
function changeOwner ( address _newOwner ) onlyOwner public { newOwner = _newOwner ; }
function updateFeeForCurrentStakingInterval ( ) external onlyOperator isDoneStaking { require ( feeCalculated == false ) ; uint feeReceived = feeToken . balanceOf ( this ) ; feeForTheStakingInterval = feeForTheStakingInterval . add ( feeReceived . add ( this . balance . div ( weiPerFee ) ) ) ; feeCalculated = true ; FeeCalculated ( feeForTheStakingInterval , feeReceived , this . balance , startBlock , endBlock ) ; if ( feeReceived > 0 ) feeToken . burnTokens ( feeReceived ) ; if ( this . balance > 0 ) wallet . transfer ( this . balance ) ; }
function supportsInterface ( bytes4 interfaceID ) public pure returns ( bool ) { return ( interfaceID == this . supportsInterface . selector || interfaceID == 0x5b5e139f || interfaceID == 0x80ac58cd || interfaceID == 0x780e9d63 ) ; }
function mintWithData ( address _investor , uint256 _value , bytes _data ) public onlyModuleOrOwner ( MINT_KEY ) isMintingAllowed ( ) returns ( bool success ) { require ( _investor != address ( 0 ) , "Investor is 0" ) ; require ( _updateTransfer ( address ( 0 ) , _investor , _value , _data ) , "Transfer invalid" ) ; _adjustTotalSupplyCheckpoints ( ) ; totalSupply_ = totalSupply_ . add ( _value ) ; balances [ _investor ] = balances [ _investor ] . add ( _value ) ; emit Minted ( _investor , _value ) ; emit Transfer ( address ( 0 ) , _investor , _value ) ; return true ; }
function withdrawRemaining ( address to ) external payloadSizeIs ( 1 * 32 ) onlyowner returns ( bool ) { return m_SMR . transfer ( to , m_SMR . balanceOf ( this ) ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) notPendingWithdrawal returns ( bool success ) { if ( balanceOf [ _from ] < _value ) throw ; if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
function burnFrom ( address _from , uint256 _value ) onlyOwner public returns ( bool success ) { require ( _value >= 0 ) ; require ( _balanceOf [ _from ] >= _value ) ; require ( _totalSupply >= _value ) ; _balanceOf [ _from ] -= _value ; _totalSupply -= _value ; Burn ( _from , _value ) ; return true ; }
function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] > 0 ) ; allowance [ msg . sender ] [ _spender ] = _amount ; Approve ( msg . sender , _spender , _amount ) ; return true ; }
function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal whenNotPaused ifWhitelisted ( _beneficiary ) { require ( initialized ) ; amountInUSDCents = convertToCents ( _weiAmount , etherPriceInCents , 18 ) ; if ( assignedBonusRates [ _beneficiary ] == 0 ) { require ( amountInUSDCents >= minContributionInUSDCents ) ; assignedBonusRates [ _beneficiary ] = getBonusPercentage ( amountInUSDCents ) ; } super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; }
function calcValuePerShare ( uint totalValue , uint numShares ) view pre_cond ( numShares > 0 ) returns ( uint valuePerShare ) { valuePerShare = toSmallestShareUnit ( totalValue ) / numShares ; }
function schedulePriceUpdatesFixed ( uint256 [ ] _times ) payable isAdminOrOwner public { bytes32 requestId ; uint256 maximumScheduledUpdated ; if ( _times . length == 0 ) { require ( oraclize_getPrice ( "URL" , gasLimit ) <= address ( this ) . balance , "Insufficient Funds" ) ; requestId = oraclize_query ( "URL" , oracleURL , gasLimit ) ; requestIds [ requestId ] = now ; maximumScheduledUpdated = now ; emit LogNewOraclizeQuery ( now , requestId , oracleURL ) ; } else { require ( oraclize_getPrice ( "URL" , gasLimit ) * _times . length <= address ( this ) . balance , "Insufficient Funds" ) ; for ( uint256 i = 0 ; i < _times . length ; i ++ ) { require ( _times [ i ] >= now , "Past scheduling is not allowed and scheduled time should be absolute timestamp" ) ; requestId = oraclize_query ( _times [ i ] , "URL" , oracleURL , gasLimit ) ; requestIds [ requestId ] = _times [ i ] ; if ( maximumScheduledUpdated < requestIds [ requestId ] ) { maximumScheduledUpdated = requestIds [ requestId ] ; } emit LogNewOraclizeQuery ( _times [ i ] , requestId , oracleURL ) ; } } if ( latestScheduledUpdate < maximumScheduledUpdated ) { latestScheduledUpdate = maximumScheduledUpdated ; } }
function getSupplyRate ( address asset , uint cash , uint borrows ) public view returns ( uint , uint ) ;
function getPayeeAddress ( bytes32 _requestId , uint8 _payeeIndex ) public view returns ( address ) { if ( _payeeIndex == 0 ) { return requests [ _requestId ] . payee . addr ; } else { return subPayees [ _requestId ] [ _payeeIndex - 1 ] . addr ; } }
function _setOwner ( address _who , bool _flag ) private returns ( bool ) { require ( owners [ _who ] != _flag ) ; owners [ _who ] = _flag ; if ( _flag ) { emit AddOwner ( _who ) ; } else { emit DeleteOwner ( _who ) ; } return true ; }
function transfer ( address _to , uint256 _value ) returns ( bool ) ;
function transfer ( address to , uint value ) public returns ( bool ) ;
function cancel ( uint _imageId ) public { require ( sellAds [ _imageId ] . exists == true ) ; require ( sellAds [ _imageId ] . exchanger == msg . sender ) ; require ( sellAds [ _imageId ] . active == true ) ; removeOrder ( _imageId ) ; }
function setNextSale ( address _sale ) external validAddress ( _sale ) onlymanyowners ( keccak256 ( msg . data ) ) { m_nextSale = _sale ; }
function addVersion ( address ofVersion ) internal returns ( uint id ) { Version memory info ; info . version = ofVersion ; info . active = true ; info . timestamp = now ; versions . push ( info ) ; VersionUpdated ( versions . length - 1 ) ; }
function setNextPoolPercentage ( uint256 _nextPoolPercentage ) external onlyCFO { nextPoolPercentage = _nextPoolPercentage ; }
function getChannelsParticipants ( ) constant returns ( address [ ] ) { uint i ; uint pos ; address [ ] memory result ; NettingChannelContract channel ; uint open_channels_num = 0 ; for ( i = 0 ; i < data . all_channels . length ; i ++ ) { if ( contractExists ( data . all_channels [ i ] ) ) { open_channels_num += 1 ; } } result = new address [ ] ( open_channels_num * 2 ) ; pos = 0 ; for ( i = 0 ; i < data . all_channels . length ; i ++ ) { if ( ! contractExists ( data . all_channels [ i ] ) ) { continue ; } channel = NettingChannelContract ( data . all_channels [ i ] ) ; var ( address1 , , address2 , ) = channel . addressAndBalance ( ) ; result [ pos ] = address1 ; pos += 1 ; result [ pos ] = address2 ; pos += 1 ; } return result ; }
function buyTokensPreHook ( address _beneficiary , uint256 _toFund ) internal { recentBlock [ msg . sender ] = block . number ; super . buyTokensPreHook ( _beneficiary , _toFund ) ; }
function verifyTransfer ( address _from , address _to , uint256 _amount ) public checkGranularity ( _amount ) returns ( bool ) { if ( ! freeze ) { bool isTransfer = false ; if ( transferFunctions [ getSig ( msg . data ) ] ) { isTransfer = true ; } if ( modules [ TRANSFERMANAGER_KEY ] . length == 0 ) { return true ; } bool isInvalid = false ; bool isValid = false ; bool isForceValid = false ; for ( uint8 i = 0 ; i < modules [ TRANSFERMANAGER_KEY ] . length ; i ++ ) { ITransferManager . Result valid = ITransferManager ( modules [ TRANSFERMANAGER_KEY ] [ i ] . moduleAddress ) . verifyTransfer ( _from , _to , _amount , isTransfer ) ; if ( valid == ITransferManager . Result . INVALID ) { isInvalid = true ; } if ( valid == ITransferManager . Result . VALID ) { isValid = true ; } if ( valid == ITransferManager . Result . FORCE_VALID ) { isForceValid = true ; } } return isForceValid ? true : ( isInvalid ? false : isValid ) ; } return false ; }
function getContributorsCount ( ) view public returns ( uint256 ) { return contributorsKeys . length ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _from != address ( 0 ) ) ; require ( _to != address ( 0 ) ) ; require ( ! isUserInBlackList ( _from ) ) ; return super . transferFrom ( _from , _to , _value ) ; }
function getPayeeIndex ( bytes32 _requestId , address _address ) public view returns ( int16 ) { if ( requests [ _requestId ] . payee . addr == _address ) { return 0 ; } for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { if ( subPayees [ _requestId ] [ i ] . addr == _address ) { return i + 1 ; } } return - 1 ; }
function deposit ( address to , uint256 amount , bytes32 reference ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) onlyIfDepositAllowed ( to , amount ) acceptAgreement ( to ) { require ( to != address ( 0 ) ) ; _balances [ to ] = add ( _balances [ to ] , amount ) ; _totalSupply = add ( _totalSupply , amount ) ; emit LogDeposit ( to , msg . sender , amount , reference ) ; emit Transfer ( address ( 0 ) , to , amount ) ; }
function getSecurityTokenLaunchFee ( ) public view returns ( uint256 ) { return getUint ( STLAUNCHFEE ) ; }
function earlyResolve ( bytes32 msigId , uint amount , bytes sig ) public { require ( multisigs [ msigId ] . owner == msg . sender || multisigs [ msigId ] . authority == msg . sender ) ; address otherAuthority = multisigs [ msigId ] . owner == msg . sender ? multisigs [ msigId ] . authority : multisigs [ msigId ] . owner ; require ( otherAuthority == msigId . toEthSignedMessageHash ( ) . recover ( sig ) ) ; spendFromMultisig ( msigId , amount , multisigs [ msigId ] . owner ) ; }
function deposit ( address _token , uint256 _amount , string _reference ) external payable isInitialized transitionsPeriod { _deposit ( _token , _amount , _reference , msg . sender , true ) ; }
function setAdministrator ( address _administrator ) public onlyOwner notFrozen returns ( bool success ) { administrator = _administrator ; AdministratorAdded ( msg . sender , _administrator , true ) ; return true ; }
function buy ( ) public payable nonReentrant onlyIfSaleIsActive checkLimitsAndDates { require ( ! priceExpired ( ) ) ; address investor = msg . sender ; uint256 payment = msg . value ; require ( ( payment . mul ( m_ETHPriceInCents ) ) . div ( 1 ether ) >= c_MinInvestmentInCents ) ; uint tokenAmount ; uint cap ; uint centsPerToken ; if ( m_currentTokensSold < c_priceRiseTokenAmount ) { centsPerToken = c_centsPerTokenFirst ; cap = c_priceRiseTokenAmount ; } else { centsPerToken = c_centsPerTokenSecond ; cap = c_maximumTokensSold ; } tokenAmount = payment . mul ( m_ETHPriceInCents ) . div ( centsPerToken ) ; uint maxTokensAllowed = cap . sub ( m_currentTokensSold ) ; if ( tokenAmount > maxTokensAllowed ) { uint ethPerToken = centsPerToken . mul ( 1 ether ) . div ( m_ETHPriceInCents ) ; tokenAmount = maxTokensAllowed ; payment = ethPerToken . mul ( tokenAmount ) . div ( 1 ether ) ; } m_currentTokensSold = m_currentTokensSold . add ( tokenAmount ) ; m_beneficiary . transfer ( payment ) ; m_token . transfer ( investor , tokenAmount ) ; uint change = msg . value . sub ( payment ) ; if ( change > 0 ) investor . transfer ( change ) ; FundTransfer ( investor , payment , true ) ; }
function sell ( uint _askPrice , uint _amount , bool _make ) external returns ( bool ) ;
function calculateBaseTimeout ( ) public view returns ( uint256 ) { uint256 _numberOfTileFlips = gameStates [ gameIndex ] . numberOfTileFlips ; if ( _numberOfTileFlips >= gameSettings . numberOfFlipsToFinalActivityTimer || gameSettings . numberOfFlipsToFinalActivityTimer == 0 ) { return gameSettings . finalActivityTimer ; } else { if ( gameSettings . finalActivityTimer <= gameSettings . initialActivityTimer ) { uint256 difference = gameSettings . initialActivityTimer - gameSettings . finalActivityTimer ; uint256 decrease = difference . mul ( _numberOfTileFlips ) . div ( gameSettings . numberOfFlipsToFinalActivityTimer ) ; return ( gameSettings . initialActivityTimer - decrease ) ; } else { difference = gameSettings . finalActivityTimer - gameSettings . initialActivityTimer ; uint256 increase = difference . mul ( _numberOfTileFlips ) . div ( gameSettings . numberOfFlipsToFinalActivityTimer ) ; return ( gameSettings . initialActivityTimer + increase ) ; } } }
function setGasLimit ( uint256 _gasLimit ) onlyOwner public { gasLimit = _gasLimit ; }
function destroyIdentifier ( bytes32 identifier ) public returns ( bool ) { uint256 index = identifierToIndex [ identifier ] ; require ( index != 0 ) ; return destroy ( index ) ; }
function revokePermission ( address _entity , address _app , bytes32 _role ) onlyPermissionManager ( _app , _role ) external { require ( hasPermission ( _entity , _app , _role ) ) ; _setPermission ( _entity , _app , _role , bytes32 ( 0 ) ) ; }
function setApprovalForAll ( address _operator , bool _approved ) external { require ( _operator != address ( 0 ) ) ; ownerToOperators [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
function currentPenalty ( address account ) public view returns ( uint ) { uint ratio = synthetix . collateralisationRatio ( account ) ; if ( ratio <= TWENTY_PERCENT ) { return 0 ; } else if ( ratio > TWENTY_PERCENT && ratio <= THIRTY_PERCENT ) { return TWENTY_FIVE_PERCENT ; } else if ( ratio > THIRTY_PERCENT && ratio <= FOURTY_PERCENT ) { return FIFTY_PERCENT ; } return SEVENTY_FIVE_PERCENT ; }
function _acceptAdmin ( ) public returns ( uint ) { if ( msg . sender != pendingAdmin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . ACCEPT_ADMIN_PENDING_ADMIN_CHECK ) ; } address oldAdmin = admin ; admin = pendingAdmin ; pendingAdmin = 0 ; emit NewAdmin ( oldAdmin , msg . sender ) ; return uint ( Error . NO_ERROR ) ; }
function isRegisteredAddress ( address _address ) public view returns ( bool ) { return holderIndex [ holderAddress2Id [ _address ] ] != 0 ; }
function convertWT ( uint256 _amount ) public userNotBlacklisted ( msg . sender ) whenNotPaused { require ( balanceOf ( msg . sender ) >= _amount , "Conversion amount should be less than balance" ) ; _burn ( msg . sender , _amount ) ; _mintCUSD ( msg . sender , _amount ) ; emit ConvertedToCUSD ( msg . sender , _amount ) ; }
function transferToAddress ( address _to , uint _value , bytes _data ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
function startSale ( ) public onlyController { require ( campaignState > 2 && teamVaultAddr != 0x0 ) ; campaignState = 2 ; uint256 tNow = now ; tCampaignStart = tNow ; tBonusStageEnd += tNow ; tRegSaleStart += tNow ; t_1st_StageEnd += tNow ; t_2nd_StageEnd += tNow ; t_3rd_StageEnd += tNow ; tCampaignEnd += tNow ; CampaignOpen ( now ) ; }
function transferForeignToken ( address _tokenAddress , address _recipient , uint256 _amount ) public onlyAdmin returns ( bool ) { require ( _recipient != address ( 0 ) , "recipient address can't be empty" ) ; require ( _tokenAddress != TOKENADDRESS , "token can't be RTC" ) ; ERC20Interface eI = ERC20Interface ( _tokenAddress ) ; require ( eI . transfer ( _recipient , _amount ) , "token transfer failed" ) ; emit ForeignTokenTransfer ( msg . sender , _recipient , _amount ) ; return true ; }
function setLocks ( address [ ] _holders , uint256 [ ] _lockups ) public onlyController { require ( _holders . length == _lockups . length ) ; require ( _holders . length < 255 ) ; require ( transfersEnabled == false ) ; for ( uint8 i = 0 ; i < _holders . length ; i ++ ) { address holder = _holders [ i ] ; uint256 lockup = _lockups [ i ] ; require ( lockups [ holder ] == 0 ) ; lockups [ holder ] = lockup ; emit LockedTokens ( holder , lockup ) ; } }
function submitAnswerCommitment ( bytes32 question_id , bytes32 answer_hash , uint256 max_previous , address _answerer ) external payable { }
function doSend ( address _operator , address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData , bool _preventLocking ) internal isTransferable { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _data , _operatorData ) ; require ( _to != address ( 0 ) , "Cannot send to 0x0" ) ; require ( mBalances [ _from ] >= _amount , "Not enough funds" ) ; require ( whitelisted ( _to ) , "Recipient is not whitelisted" ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _data , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _data , _operatorData ) ; }
function removeDistributionSources ( address [ ] _blacklist ) external onlyContractOwner returns ( uint ) { for ( uint _idx = 0 ; _idx < _blacklist . length ; ++ _idx ) { delete distributionSourcesList [ _blacklist [ _idx ] ] ; } return OK ; }
function claimTokenFor ( address _beneficiary ) public afterSaleSuccess whenNotPaused { uint256 stake = stakes [ _beneficiary ] ; require ( stake > 0 ) ; stakes [ _beneficiary ] = 0 ; uint256 tokens = stake . mul ( rate ) ; tokenBalance = tokenBalance . sub ( tokens ) ; ethealController . addHodlerStake ( _beneficiary , tokens . mul ( 2 ) ) ; require ( ethealController . ethealToken ( ) . transfer ( _beneficiary , tokens ) ) ; TokenClaimed ( msg . sender , _beneficiary , stake , tokens ) ; }
function setEthPreAmount ( uint256 ethPreAmountInWei ) isOwner { require ( ethPreAmountInWei > 0 ) ; require ( ethPreAmount != ethPreAmountInWei ) ; ethPreAmount = ethPreAmountInWei ; updatePrices ( ) ; }
function setBuyCommission ( uint256 buyCommissionInWei ) isOwner { require ( buyCommissionInWei > 0 ) ; require ( buyCommission != buyCommissionInWei ) ; buyCommission = buyCommissionInWei ; updatePrices ( ) ; }
function cancelMortgage ( uint256 id ) external returns ( bool ) { Mortgage storage mortgage = mortgages [ id ] ; require ( msg . sender == mortgage . owner , "Only the owner can cancel the mortgage" ) ; require ( mortgage . status == Status . Pending , "The mortgage is not pending" ) ; mortgage . status = Status . Canceled ; require ( mana . transfer ( msg . sender , mortgage . deposit ) , "Error returning MANA" ) ; emit CanceledMortgage ( msg . sender , id ) ; return true ; }
function mint ( address to , uint256 value ) public onlyMinter returns ( bool ) { require ( ! mintingDisabled ) ; bool minted = super . mint ( to , value ) ; if ( minted ) { addBalanceBlocks ( to ) ; if ( ! holdersMap [ to ] ) { holdersMap [ to ] = true ; holders . push ( to ) ; } } return minted ; }
function getWeiCollected ( ) public constant returns ( uint ) ;
function cancelProject ( uint64 idProject ) { PledgeAdmin storage project = findAdmin ( idProject ) ; checkAdminOwner ( project ) ; project . canceled = true ; CancelProject ( idProject ) ; }
function disableSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _buyer , "Must be buyer" ) ; return doDisableSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }
function getFxUSDAmount ( Data storage self , string currency , uint fxAmount ) internal view returns ( uint amount ) { uint usdDecimals = getTokenDecimals ( self , 'USDx' ) ; uint fxDecimals = getTokenDecimals ( self , currency ) ; uint usdAmount = ( ( fxAmount . mul ( getFxUSDBPSRate ( self , currency ) ) . div ( 10000 ) ) . mul ( 10 ** usdDecimals ) ) . div ( 10 ** fxDecimals ) ; return usdAmount ; }
function removeTicker ( string _ticker ) external ;
function withdrawSynthetix ( uint amount ) external onlyOwner { synthetix . transfer ( owner , amount ) ; }
function register ( address _service ) internal returns ( uint256 serviceId ) { }
function withdrawBalance ( ) external onlyOwner { owner . transfer ( this . balance ) ; }
function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ) { require ( transfer ( _to , _value ) ) ; if ( isContract ( _to ) ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } return true ; }
function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) { require ( _registry . hasAttribute ( to , _validAttributeTypeID ) , "Transfer failed - receiver is not approved." ) ; return super . transferFrom ( from , to , value ) ; }
function setAssetFeeParams ( address asset , uint feeBps , uint feeMin , uint feeMax , uint feeFlat ) public onlyOwner notDeprecated returns ( bool success ) { require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.max' , asset ) ) , feeMax ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.min' , asset ) ) , feeMin ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.bps' , asset ) ) , feeBps ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.flat' , asset ) ) , feeFlat ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; return true ; }
function getBidId ( Campaign storage _campaign ) internal view returns ( bytes32 _bidId ) { return _campaign . bidId ; }
function collectTokens ( ) public onlyOwner { uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime ) ; uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; collectedTokens = balance ; miniMeToken . transfer ( owner , balance ) ; TokensWithdrawn ( owner , balance ) ; }
function isTrusted ( address _from , address _to ) public view returns ( bool ) { return get ( store , holdersTrustStorage , getHolderId ( _from ) , _to ) ; }
function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
function resetWinners ( uint256 newLength ) external onlyAdmin checkState ( pointsValidationState . LimitCalculated ) { sortedWinners . length = newLength ; }
function finished ( ) public { require ( state == State . Successful ) ; require ( beneficiary . send ( this . balance ) ) ; LogBeneficiaryPaid ( beneficiary ) ; }
function allowance ( address _from , address _spender , bytes32 _symbol ) public view returns ( uint ) { return _allowance ( getHolderId ( _from ) , getHolderId ( _spender ) , _symbol ) ; }
function buyBox2 ( ) external payable whenNotPaused returns ( bool ) { require ( isNotContract ( msg . sender ) ) ; require ( box2OnSale ) ; require ( msg . value >= priceBox2 ) ; uint tempVal = uint ( keccak256 ( uint ( msg . sender ) + secretKey + rabbits . length ) ) ; tempVal = tempVal % 10000 ; uint _star = 4 ; if ( tempVal <= box2Star5 ) { _star = 5 ; require ( CREATED_STAR5 < LIMIT_STAR5 ) ; } else { require ( CREATED_STAR4 < LIMIT_STAR4 ) ; } _createRabbitInGrade ( _star , msg . sender , 3 ) ; uint fundsExcess = msg . value - priceBox2 ; if ( fundsExcess > 1 finney ) { msg . sender . transfer ( fundsExcess ) ; } return true ; }
function renterOf ( uint256 _deedId ) external view returns ( address _renter , uint256 _rentPeriodEndTimestamp ) { require ( validIdentifier ( _deedId ) ) ; if ( identifierToRentPeriodEndTimestamp [ _deedId ] < now ) { _renter = address ( 0 ) ; _rentPeriodEndTimestamp = 0 ; } else { _renter = identifierToRenter [ _deedId ] ; _rentPeriodEndTimestamp = identifierToRentPeriodEndTimestamp [ _deedId ] ; } }
function transfer ( address _to , uint256 _value ) returns ( bool ) { if ( funding ) throw ; var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
function setFundingRules ( address _moderator , uint _initialPriceMultiplier , uint _amountToFund , uint _minutesFundingPeriod , uint _inflationRate , uint _proposalID ) external ;
function doConfirmPayment ( uint _idPayment ) internal { require ( _idPayment < payments . length ) ; Payment storage p = payments [ _idPayment ] ; require ( p . state == PaymentStatus . Pending ) ; p . state = PaymentStatus . Paid ; liquidPledging . confirmPayment ( uint64 ( p . ref ) , p . amount ) ; p . dest . transfer ( p . amount ) ; ConfirmPayment ( _idPayment , p . ref ) ; }
function updateSalePrice ( uint256 _tokenId , uint256 _newPrice ) public { Sale storage sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _updateSalePrice ( _tokenId , _newPrice , seller ) ; }
function nonEtherBuy ( address client , uint etherEquivalentAmount ) public { require ( msg . sender == m_nonEtherController ) ; require ( etherEquivalentAmount <= 70000 ether ) ; internalBuy ( client , etherEquivalentAmount , false ) ; }
function getReserves ( ) public view returns ( KyberReserveInterface [ ] ) { return reserves ; }
function getBlockTimestamp ( ) internal constant returns ( uint256 ) { return block . timestamp ; }
function withdrawPayoutFromBet ( uint betId ) external whenGameIsClosed ( bets [ betId ] . gameId ) { require ( games [ bets [ betId ] . gameId ] . result == bets [ betId ] . result ) ; if ( ! bets [ betId ] . isPayoutWithdrawn ) { uint payout = calculatePotentialPayout ( betId ) ; bets [ betId ] . isPayoutWithdrawn = true ; address bettorAddress = betToAddress [ betId ] ; bettorAddress . transfer ( payout ) ; } }
function destroyBeneficiary ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; token . transfer ( owner , balance ) ; totalReleased = totalReleased . add ( balance ) ; beneficiary . isBeneficiary = false ; beneficiary . released = beneficiary . released . add ( balance ) ; for ( uint i = 0 ; i < addresses . length - 1 ; i ++ ) if ( addresses [ i ] == _beneficiary ) { addresses [ i ] = addresses [ addresses . length - 1 ] ; break ; } addresses . length -= 1 ; emit BeneficiaryDestroyed ( _beneficiary ) ; }
function setPrices ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; }
function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = true ; } else { mAuthorized [ _operator ] [ msg . sender ] = false ; } RevokedOperator ( _operator , msg . sender ) ; }
function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) stateOpenOrPendingArbitration ( question_id ) external { bytes32 answer_hash = keccak256 ( answer , nonce ) ; bytes32 commitment_id = keccak256 ( question_id , answer_hash , bond ) ; require ( ! commitments [ commitment_id ] . is_revealed ) ; require ( commitments [ commitment_id ] . reveal_ts > uint32 ( now ) ) ; commitments [ commitment_id ] . revealed_answer = answer ; commitments [ commitment_id ] . is_revealed = true ; if ( bond == questions [ question_id ] . bond ) { _updateCurrentAnswer ( question_id , answer , questions [ question_id ] . timeout ) ; } LogAnswerReveal ( question_id , msg . sender , answer_hash , answer , nonce , bond ) ; }
function bid ( ) public payable { require ( stage == Stages . AuctionSetUp || stage == Stages . AuctionStarted ) ; require ( privatesalewhitelist [ msg . sender ] || publicsalewhitelist [ msg . sender ] ) ; if ( stage == Stages . AuctionSetUp ) { require ( privatesalewhitelist [ msg . sender ] ) ; } require ( msg . value > 0 ) ; require ( bids [ msg . sender ] . received + msg . value >= bid_threshold ) ; assert ( bids [ msg . sender ] . received + msg . value >= msg . value ) ; uint256 remaining_funds_to_end_auction = remainingFundsToEndAuction ( ) ; require ( msg . value <= remaining_funds_to_end_auction ) ; if ( stage == Stages . AuctionSetUp ) { require ( privatesalewhitelist [ msg . sender ] ) ; currentBonus = 25 ; } else if ( stage == Stages . AuctionStarted ) { if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time && now < auction_start_time + BONUS_DAY1_DURATION ) { currentBonus = 25 ; } else if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) { currentBonus = 25 ; } else if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 25 ; } else if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 25 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time && now < auction_start_time + BONUS_DAY1_DURATION ) { currentBonus = 15 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) { currentBonus = 10 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 5 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 0 ; } else { currentBonus = 0 ; } } else { currentBonus = 0 ; } uint256 accounted = msg . value + msg . value * ( currentBonus ) / 100 ; bids [ msg . sender ] . accounted += accounted ; bids [ msg . sender ] . received += msg . value ; received_wei += msg . value ; received_wei_with_bonus += accounted ; wallet_address . transfer ( msg . value ) ; BidSubmission ( msg . sender , msg . value , accounted , remaining_funds_to_end_auction ) ; assert ( received_wei >= msg . value ) ; assert ( received_wei_with_bonus >= accounted ) ; }
function initialize ( address _att , address _attController , uint _startTime , uint _endTime , address _destEthFoundation , address _destTokensAngel ) public onlyOwner { require ( address ( ATT ) == 0x0 ) ; ATT = MiniMeToken ( _att ) ; require ( ATT . totalSupply ( ) == 0 ) ; require ( ATT . controller ( ) == address ( this ) ) ; require ( ATT . decimals ( ) == 18 ) ; startTime = _startTime ; endTime = _endTime ; assert ( startTime < endTime ) ; require ( _attController != 0x0 ) ; attController = _attController ; require ( _destEthFoundation != 0x0 ) ; destEthFoundation = _destEthFoundation ; require ( _destTokensAngel != 0x0 ) ; destTokensAngel = _destTokensAngel ; }
function getReferrerBonus ( uint256 value ) view public returns ( uint256 ) { return value . mul ( baseRate ) . mul ( referrerBonusPercent ) . div ( PERCENT_DIVIDER ) ; }
function batchCreateAssetSale ( uint256 [ ] _tokenIds , uint256 [ ] _startingPrices , uint256 [ ] _endingPrices , uint256 [ ] _durations ) external whenNotPaused { require ( _tokenIds . length > 0 && _startingPrices . length > 0 && _endingPrices . length > 0 && _durations . length > 0 ) ; for ( uint ii = 0 ; ii < _tokenIds . length ; ii ++ ) { require ( _tokenIds [ ii ] != 0 ) ; require ( _startingPrices [ ii ] == _startingPrices [ ii ] ) ; require ( _endingPrices [ ii ] == _endingPrices [ ii ] ) ; require ( _durations [ ii ] == _durations [ ii ] ) ; address _owner = ownerOf ( _tokenIds [ ii ] ) ; address _msgSender = msg . sender ; require ( _owner == _msgSender ) ; require ( checkIsAttached ( _tokenIds [ ii ] ) == 0 ) ; _approveForSale ( msg . sender , address ( saleManagerAddress ) , _tokenIds [ ii ] ) ; saleManagerAddress . createSale ( _tokenIds [ ii ] , _startingPrices [ ii ] , _endingPrices [ ii ] , _durations [ ii ] , msg . sender ) ; } }
function supportsInterface ( bytes4 interfaceID ) external pure returns ( bool ) ;
function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( owner , refund ) ; Revoked ( ) ; }
function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 0 ) ; return availableTags ; }
function stage ( ) constant returns ( Stage ) { if ( finalized ) { return Stage . Finalized ; } if ( ! initialized ) { return Stage . Created ; } if ( blockTime ( ) < startTime ) { return Stage . Initialized ; } if ( uint256 ( soldOut . official ) . add ( soldOut . channels ) >= publicSupply ) { return Stage . Closed ; } if ( blockTime ( ) < endTime ) { if ( blockTime ( ) < startTime . add ( earlyStageLasts ) ) { return Stage . Early ; } return Stage . Normal ; } return Stage . Closed ; }
function buyTokensPreHook ( address _beneficiary , uint256 _toFund ) internal { }
function registerWithRefID ( uint256 _refId ) public payable onlyNotExistingUser returns ( uint256 ) { require ( _refId < users . length ) ; uint256 index = register ( ) ; _updateReferrals ( index , _refId ) ; emit ReferralRegister ( _refId , index ) ; return index ; }
function vest ( ) external { uint numEntries = numVestingEntries ( msg . sender ) ; uint total ; for ( uint i = 0 ; i < numEntries ; i ++ ) { uint time = getVestingTime ( msg . sender , i ) ; if ( time > now ) { break ; } uint qty = getVestingQuantity ( msg . sender , i ) ; if ( qty == 0 ) { continue ; } vestingSchedules [ msg . sender ] [ i ] = [ 0 , 0 ] ; total = safeAdd ( total , qty ) ; } if ( total != 0 ) { totalVestedBalance = safeSub ( totalVestedBalance , total ) ; totalVestedAccountBalance [ msg . sender ] = safeSub ( totalVestedAccountBalance [ msg . sender ] , total ) ; havven . transfer ( msg . sender , total ) ; emit Vested ( msg . sender , now , total ) ; } }
function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) ;
function expiryCheck ( string _symbol ) internal returns ( bool ) { if ( registeredSymbols [ _symbol ] . owner != address ( 0 ) ) { if ( now > registeredSymbols [ _symbol ] . timestamp . add ( expiryLimit ) && registeredSymbols [ _symbol ] . status != true ) { registeredSymbols [ _symbol ] = SymbolDetails ( address ( 0 ) , uint256 ( 0 ) , "" , bytes32 ( 0 ) , false ) ; return true ; } else return false ; } return true ; }
function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Sufficent Allowance is not provided" ) ; CappedSTO cappedSTO = new CappedSTO ( msg . sender , address ( polyToken ) ) ; require ( Util . getSig ( _data ) == cappedSTO . getInitFunction ( ) , "Invalid data" ) ; require ( address ( cappedSTO ) . call ( _data ) , "Unsuccessfull call" ) ; emit GenerateModuleFromFactory ( address ( cappedSTO ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( cappedSTO ) ; }
function getApproved ( uint256 _tokenId ) external view returns ( address ) { require ( _tokenExists ( _tokenId ) ) ; return playerTokenToApproved [ _tokenId ] ; }
function revokeManualBlocking ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , "Invalid to address" ) ; delete manualBlockings [ _from ] [ _to ] ; emit RevokeManualBlocking ( _from , _to , msg . sender ) ; }
function totalSupplyAt ( uint256 _checkpointId ) public view returns ( uint256 ) ;
function _generateCampaign ( string packageName , uint [ 3 ] countries , uint [ ] vercodes , uint price , uint budget , uint startDate , uint endDate ) internal returns ( CampaignLibrary . Campaign memory ) { require ( budget >= price ) ; require ( endDate >= startDate ) ; if ( appc . allowance ( msg . sender , address ( this ) ) >= budget ) { appc . transferFrom ( msg . sender , address ( advertisementFinance ) , budget ) ; advertisementFinance . increaseBalance ( msg . sender , budget ) ; uint newBidId = bytesToUint ( lastBidId ) ; lastBidId = uintToBytes ( ++ newBidId ) ; CampaignLibrary . Campaign memory newCampaign ; newCampaign . price = price ; newCampaign . startDate = startDate ; newCampaign . endDate = endDate ; newCampaign . budget = budget ; newCampaign . owner = msg . sender ; newCampaign . valid = true ; newCampaign . bidId = lastBidId ; } else { emit Error ( "createCampaign" , "Not enough allowance" ) ; } return newCampaign ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _spender != address ( 0 ) ) ; allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; success = true ; }
function unlockMe ( ) external { require ( userAddress2Id [ msg . sender ] != 0 ) ; userLock [ msg . sender ] = 0 ; Lock ( msg . sender , 0 ) ; }
function setAdmin ( address _admin , bool _valid ) onlyOwner public { admin [ _admin ] = _valid ; emit LogAdminSet ( _admin , _valid , now ) ; }
function pegEtherValues ( uint256 _minDiscountEther , uint256 _firstTierDiscountUpperLimitEther , uint256 _secondTierDiscountUpperLimitEther , uint256 _thirdTierDiscountUpperLimitEther , uint256 _minPresaleContributionEther , uint256 _maxPresaleContributionEther ) onlyOwner { minDiscountEther = _minDiscountEther ; firstTierDiscountUpperLimitEther = _firstTierDiscountUpperLimitEther ; secondTierDiscountUpperLimitEther = _secondTierDiscountUpperLimitEther ; thirdTierDiscountUpperLimitEther = _thirdTierDiscountUpperLimitEther ; minPresaleContributionEther = _minPresaleContributionEther ; maxPresaleContributionEther = _maxPresaleContributionEther ; }
function votesPerChoice ( uint8 option ) external view returns ( uint32 ) { require ( option < NUMBER_OF_CHOICES , "Choice must be less than numberOfChoices." ) ; return currentVoteResults [ option ] ; }
function buyFactory ( FactoryType _type ) public payable onlyExistingUser returns ( uint256 ) { uint256 userId = addressToUser [ msg . sender ] ; if ( addressToUser [ msg . sender ] == 0 ) userId = register ( ) ; return _paymentProceed ( userId , Factory ( _type , 0 , now ) ) ; }
function distrust ( address _to ) public checkTrust ( msg . sender , _to ) returns ( uint ) { set ( store , holdersTrustStorage , getHolderId ( msg . sender ) , _to , false ) ; return OK ; }
function freezeAccount ( address target , bool freeze ) onlyAuthorized public { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }
function init ( address _token , address _plcr , uint [ ] _parameters ) public { require ( _token != 0 && address ( token ) == 0 ) ; require ( _plcr != 0 && address ( voting ) == 0 ) ; token = EIP20Interface ( _token ) ; voting = PLCRVoting ( _plcr ) ; set ( "minDeposit" , _parameters [ 0 ] ) ; set ( "pMinDeposit" , _parameters [ 1 ] ) ; set ( "applyStageLen" , _parameters [ 2 ] ) ; set ( "pApplyStageLen" , _parameters [ 3 ] ) ; set ( "commitStageLen" , _parameters [ 4 ] ) ; set ( "pCommitStageLen" , _parameters [ 5 ] ) ; set ( "revealStageLen" , _parameters [ 6 ] ) ; set ( "pRevealStageLen" , _parameters [ 7 ] ) ; set ( "dispensationPct" , _parameters [ 8 ] ) ; set ( "pDispensationPct" , _parameters [ 9 ] ) ; set ( "voteQuorum" , _parameters [ 10 ] ) ; set ( "pVoteQuorum" , _parameters [ 11 ] ) ; }
function leftForSale ( ) public constant returns ( uint256 ) { Tier tier = tiers [ tierCount ] ; uint256 weiLeft = tier . cap ( ) . sub ( tier . totalInvestedWei ( ) ) ; uint256 tokensLeft = weiLeft . mul ( tier . exchangeRate ( ) ) ; return tokensLeft ; }
function spread ( bool _side ) public constant returns ( uint ) ;
function release ( ) external onlyState ( State . Active ) onlyBeneficiary ( msg . sender ) { require ( ! beneficiaries [ msg . sender ] . releaseAllTokens ) ; uint releasableAmount = getReleasableAmount ( msg . sender ) ; beneficiaries [ msg . sender ] . withdrawAmount = beneficiaries [ msg . sender ] . withdrawAmount . add ( releasableAmount ) ; beneficiaries [ msg . sender ] . releaseAllTokens = beneficiaries [ msg . sender ] . withdrawAmount == getPartialAmount ( beneficiaries [ msg . sender ] . ratio , coeff , initialBalance ) ; withdrawAmount = withdrawAmount . add ( releasableAmount ) ; if ( withdrawAmount == initialBalance ) { state = State . Drawn ; emit StateChanged ( state ) ; } token . transfer ( msg . sender , releasableAmount ) ; emit Released ( msg . sender , releasableAmount ) ; }
function transfer ( address _to , uint256 _value ) returns ( bool ) { var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
function setValidatorSigningKey ( address newSigningKey ) external ;
function updatePrices ( uint newEthPrice , uint newSynthetixPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent , "Time must be later than last update" ) ; require ( timeSent < ( now + ORACLE_FUTURE_LIMIT ) , "Time must be less than now + ORACLE_FUTURE_LIMIT" ) ; usdToEthPrice = newEthPrice ; usdToSnxPrice = newSynthetixPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToSnxPrice , lastPriceUpdateTime ) ; }
function tokenOfOwnerByIndex ( address owner , uint256 index ) external view returns ( uint256 tokenId ) ;
function numberOfAuthorizedPayments ( ) constant returns ( uint ) { return authorizedPayments . length ; }
function getSTODetails ( ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , bool ) { return ( startTime , endTime , cap , rate , ( fundRaiseTypes [ uint8 ( FundRaiseType . POLY ) ] ) ? fundsRaised [ uint8 ( FundRaiseType . POLY ) ] : fundsRaised [ uint8 ( FundRaiseType . ETH ) ] , investorCount , totalTokensSold , ( fundRaiseTypes [ uint8 ( FundRaiseType . POLY ) ] ) ) ; }
function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) ;
function release ( ERC20Basic token ) public { uint256 unreleased = releasableAmount ( token ) ; require ( unreleased > 0 ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . transfer ( beneficiary , unreleased ) ; emit Released ( unreleased ) ; }
function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return _owner == _operator ; }
function setRegistryAdmin ( address _newRegistryAdmin ) public onlyOwner { address _oldRegistryAdmin = registryAdmin ; registryAdmin = _newRegistryAdmin ; }
function changeGenerator ( address _newGenerator ) onlyGenerator { generator = _newGenerator ; }
function deleteUint ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete uIntStorage [ _key ] ; return true ; }
function buyTokens ( address _beneficiary ) public payable whenNotPaused { validatePurchase ( ) ; uint256 toFund = calculateToFund ( ) ; uint256 toReturn = msg . value . sub ( toFund ) ; require ( toFund > 0 ) ; uint256 rate = getRate ( ) ; uint256 tokens = rate . mul ( toFund ) ; require ( tokens > 0 ) ; if ( block . timestamp < phase2StartTime ) { phase1WeiRaised = phase1WeiRaised . add ( toFund ) ; } else { phase2WeiRaised = phase2WeiRaised . add ( toFund ) ; } if ( purchaserFunded [ msg . sender ] == 0 ) { numPurchasers = numPurchasers . add ( 1 ) ; } purchaserFunded [ msg . sender ] = purchaserFunded [ msg . sender ] . add ( toFund ) ; token . generateTokens ( _beneficiary , tokens ) ; emit TokenPurchase ( msg . sender , _beneficiary , toFund , tokens ) ; if ( toReturn > 0 ) { msg . sender . transfer ( toReturn ) ; } vault . deposit . value ( toFund ) ( msg . sender ) ; }
function verifyTransfer ( address _from , address _to , uint256 _amount , bytes , bool _isTransfer ) public returns ( Result ) { require ( _isTransfer == false || msg . sender == securityToken , "Sender is not the owner" ) ; if ( ! paused ) { if ( manualBlockings [ _from ] [ _to ] . expiryTime >= now ) { return Result . INVALID ; } if ( ( manualApprovals [ _from ] [ _to ] . expiryTime >= now ) && ( manualApprovals [ _from ] [ _to ] . allowance >= _amount ) ) { if ( _isTransfer ) { manualApprovals [ _from ] [ _to ] . allowance = manualApprovals [ _from ] [ _to ] . allowance . sub ( _amount ) ; } return Result . VALID ; } } return Result . NA ; }
function sendEther ( address to , uint value ) external onlymanyowners ( sha3 ( msg . data ) ) { require ( 0 != to ) ; require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }
function emergencyRefundContract ( ) external payable onlyOwnerOrMultisig { require ( contractFailed ) ; require ( msg . value > 0 ) ; }
function getSaleDay ( uint256 _time ) view public returns ( uint8 ) { return uint8 ( _time . sub ( startTime ) . div ( 60 * 60 * 24 ) . add ( 1 ) ) ; }
function unitEthCost ( uint256 cardId ) external constant returns ( uint256 ) { return cardInfo [ cardId ] . ethCost ; }
function ( ) public payable { buy ( msg . sender ) ; }
function getReferencePrice ( address ofBase , address ofQuote ) view returns ( bool isRecent , uint referencePrice , uint decimal ) { if ( getQuoteAsset ( ) == ofQuote ) { ( isRecent , referencePrice , decimal ) = getPrice ( ofBase ) ; } else if ( getQuoteAsset ( ) == ofBase ) { ( isRecent , referencePrice , decimal ) = getInvertedPrice ( ofQuote ) ; } else { revert ( ) ; } }
function claimContractOwnership ( ) public returns ( bool ) { if ( msg . sender != pendingContractOwner ) { return false ; } emit OwnershipTransferred ( contractOwner , pendingContractOwner ) ; contractOwner = pendingContractOwner ; delete pendingContractOwner ; return true ; }
function symbol ( ) public view returns ( string _symbol ) ;
function approve ( address _spender , uint256 _amount ) returns ( bool ) ;
function burnWithData ( uint256 _value , bytes _data ) public onlyModule ( BURN_KEY ) { require ( _burn ( msg . sender , _value , _data ) , "Burn invalid" ) ; }
function isPassed ( uint _pollID ) constant public returns ( bool passed ) { require ( pollEnded ( _pollID ) ) ; Poll memory poll = pollMap [ _pollID ] ; return ( 100 * poll . votesFor ) > ( poll . voteQuorum * ( poll . votesFor + poll . votesAgainst ) ) ; }
function addTokenTo ( address _to , uint256 _tokenId ) internal { uint64 [ ] storage ownedList = ownedTokens [ _to ] ; TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( ownedList . length < uint256 ( 2 ** 32 ) - 1 , "Max number of PixelCons per owner has been reached" ) ; require ( lookupData . owner == address ( 0 ) , "PixelCon already has an owner" ) ; lookupData . owner = _to ; uint ownedListIndex = ownedList . length ; ownedList . length ++ ; lookupData . ownedIndex = uint32 ( ownedListIndex ) ; ownedList [ ownedListIndex ] = lookupData . tokenIndex ; }
function cloneProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument , uint _dateOfProposal , uint _lastClientProposalID , uint _orderAmount , uint _dateOfOrder ) ;
function getStartTime ( ) internal constant returns ( uint ) { return 1508958000 ; }
function openChannel ( address participant1 , address participant2 , uint256 settle_timeout ) isSafe settleTimeoutValid ( settle_timeout ) public returns ( uint256 ) { bytes32 pair_hash ; uint256 channel_identifier ; require ( token . balanceOf ( address ( this ) ) < token_network_deposit_limit ) ; channel_counter += 1 ; channel_identifier = channel_counter ; pair_hash = getParticipantsHash ( participant1 , participant2 ) ; require ( participants_hash_to_channel_identifier [ pair_hash ] == 0 ) ; participants_hash_to_channel_identifier [ pair_hash ] = channel_identifier ; Channel storage channel = channels [ channel_identifier ] ; assert ( channel . settle_block_number == 0 ) ; assert ( channel . state == ChannelState . NonExistent ) ; channel . settle_block_number = settle_timeout ; channel . state = ChannelState . Opened ; emit ChannelOpened ( channel_identifier , participant1 , participant2 , settle_timeout ) ; return channel_identifier ; }
function withdraw ( uint256 amount ) public onlyIfWithdrawAllowed ( msg . sender , amount ) acceptAgreement ( msg . sender ) { destroyTokensPrivate ( msg . sender , amount ) ; emit LogWithdrawal ( msg . sender , amount ) ; }
function approveAndCall ( address spender , uint256 value , bytes data ) public returns ( bool ) ;
function description ( bytes32 _symbol ) public view returns ( string ) { return assets [ _symbol ] . description ; }
function getBonusesAmountAvailable ( bytes32 _userKey , uint _distributionDate ) public view returns ( uint ) { Deposit storage _deposit = distributionDeposits [ _distributionDate ] ; if ( _deposit . leftToWithdraw [ _userKey ] . initialized ) { return _deposit . leftToWithdraw [ _userKey ] . left ; } uint _sharesPercent = Treasury ( treasury ) . getSharesPercentForPeriod ( _userKey , _distributionDate ) ; return _deposit . balance . mul ( _sharesPercent ) . div ( PERCENT_PRECISION ) ; }
function mintMulti ( address [ ] _investors , uint256 [ ] _amounts ) public onlyModule ( STO_KEY , true ) returns ( bool success ) { require ( _investors . length == _amounts . length , "Mis-match in the length of the arrays" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { mint ( _investors [ i ] , _amounts [ i ] ) ; } return true ; }
function setHandler ( address handler , bool allowed ) public onlyOwner { handlerWhitelist [ handler ] = allowed ; }
function addOrganization ( address organization , uint256 maximumIssuableAttributes , string name ) external onlyOwner whenNotPaused { require ( organization != address ( 0 ) , "must supply a valid account address" ) ; require ( _organizations [ organization ] . exists == false , "an organization already exists at the provided account address" ) ; _organizations [ organization ] . exists = true ; _organizations [ organization ] . maximumAccounts = maximumIssuableAttributes ; _organizations [ organization ] . name = name ; _organizationAccounts . push ( organization ) ; emit OrganizationAdded ( organization , name ) ; }
function startICO ( bool start ) public onlyOwner { isICORunning = start ; }
function createCheckpoint ( ) external onlyModuleOrOwner ( CHECKPOINT_KEY ) returns ( uint256 ) { require ( currentCheckpointId < 2 ** 256 - 1 ) ; currentCheckpointId = currentCheckpointId + 1 ; checkpointTimes . push ( now ) ; emit CheckpointCreated ( currentCheckpointId , now ) ; return currentCheckpointId ; }
function breedWithAuto ( uint256 _matronId , uint256 _sireId ) external payable whenNotPaused { uint256 totalFee = autoBirthFee ; Dog storage matron = dogs [ _matronId ] ; if ( matron . generation > 0 ) { totalFee += gen0Profit ; } require ( msg . value >= totalFee ) ; require ( _owns ( msg . sender , _matronId ) ) ; require ( _isSiringPermitted ( _sireId , _matronId ) ) ; require ( _isReadyToBreed ( matron ) ) ; Dog storage sire = dogs [ _sireId ] ; require ( _isReadyToBreed ( sire ) ) ; require ( _isValidMatingPair ( matron , _matronId , sire , _sireId ) ) ; _breedWith ( _matronId , _sireId ) ; uint256 breedExcess = msg . value - totalFee ; if ( breedExcess > 0 ) { msg . sender . transfer ( breedExcess ) ; } }
function confirmPrint ( bytes32 _lockId ) public onlyCustodian { PendingPrint storage print = pendingPrintMap [ _lockId ] ; address receiver = print . receiver ; require ( receiver != address ( 0 ) ) ; uint256 value = print . value ; delete pendingPrintMap [ _lockId ] ; uint256 supply = erc20Store . totalSupply ( ) ; uint256 newSupply = supply + value ; if ( newSupply >= supply ) { erc20Store . setTotalSupply ( newSupply ) ; erc20Store . addBalance ( receiver , value ) ; emit PrintingConfirmed ( _lockId , receiver , value ) ; erc20Proxy . emitTransfer ( address ( 0 ) , receiver , value ) ; } }
function transfer ( address _to , uint256 _amount ) public returns ( bool ) { uint256 _fee = validator . validateAndGetTransferFee ( owner , msg . sender , _to , _amount ) ; store . transfer ( msg . sender , _to , _amount ) ; if ( _fee > 0 ) store . transfer ( msg . sender , store . getSettingAddress ( "feeReturnAddress" ) , _fee ) ; Transfer ( msg . sender , _to , _amount ) ; return true ; }
function hasConfirmed ( bytes32 _operation , address _owner ) external constant multiOwnedOperationIsActive ( _operation ) ownerExists ( _owner ) returns ( bool ) { return ! ( m_multiOwnedPending [ _operation ] . ownersDone & makeOwnerBitmapBit ( _owner ) == 0 ) ; }
function performSellOrder ( bytes genericPayload , uint256 amountToGiveForOrder ) public onlyTotle whenNotPaused returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { bool success ; bytes4 functionSelector = selectorProvider . getSelector ( this . performSellOrder . selector ) ; assembly { let callDataOffset := 0x44 let functionSelectorOffset := 0x1C let functionSelectorLength := 0x04 let scratchSpace := 0x0 let wordLength := 0x20 let startOfFreeMemory := mload ( 0x40 ) calldatacopy ( startOfFreeMemory , callDataOffset , calldatasize ) let bytesLength := mload ( startOfFreeMemory ) let totalLength := add ( add ( functionSelectorLength , bytesLength ) , wordLength ) mstore ( add ( scratchSpace , functionSelectorOffset ) , functionSelector ) let functionSelectorCorrect := mload ( scratchSpace ) mstore ( startOfFreeMemory , functionSelectorCorrect ) mstore ( add ( startOfFreeMemory , add ( wordLength , bytesLength ) ) , amountToGiveForOrder ) let startOfNewData := add ( startOfFreeMemory , functionSelectorOffset ) success := call ( gas , address , callvalue , startOfNewData , totalLength , scratchSpace , mul ( wordLength , 0x02 ) ) amountSpentOnOrder := mload ( scratchSpace ) amountReceivedFromOrder := mload ( add ( scratchSpace , wordLength ) ) if eq ( success , 0 ) { revert ( 0 , 0 ) } } }
function staticExchangeChecks ( bytes genericPayload ) public view onlyTotle whenNotPaused returns ( bool checksPassed ) { bool success ; bytes4 functionSelector = selectorProvider . getSelector ( this . staticExchangeChecks . selector ) ; assembly { let functionSelectorLength := 0x04 let functionSelectorOffset := 0x1C let scratchSpace := 0x0 let wordLength := 0x20 let bytesLength := mload ( genericPayload ) let totalLength := add ( functionSelectorLength , bytesLength ) let startOfNewData := add ( genericPayload , functionSelectorOffset ) mstore ( add ( scratchSpace , functionSelectorOffset ) , functionSelector ) let functionSelectorCorrect := mload ( scratchSpace ) mstore ( genericPayload , functionSelectorCorrect ) success := call ( gas , address , callvalue , startOfNewData , totalLength , scratchSpace , wordLength ) checksPassed := mload ( scratchSpace ) if eq ( success , 0 ) { revert ( 0 , 0 ) } } }
function ( ) external payable { require ( msg . sender == address ( saleAuction ) ) ; }
function removeOwnership ( address _dac ) external onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; emit OwnershipRemoved ( ) ; }
function multiBatchTransferFrom ( uint256 [ ] _tokenIds , address [ ] _fromB , address [ ] _toB ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _fromB . length > 0 && _toB . length > 0 ) ; uint256 _id ; address _to ; address _from ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 && _fromB [ i ] != 0 && _toB [ i ] != 0 ) ; _id = _tokenIds [ i ] ; _to = _toB [ i ] ; _from = _fromB [ i ] ; transferFrom ( _from , _to , _id ) ; } }
function invalidateAttributeApproval ( bytes32 hash , bytes signature ) external ;
function claimTokens ( address _token ) onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }
function getModule ( address _module ) external view returns ( bytes32 , address , address , bool , uint8 [ ] ) ;
function setEtherFeePercent ( uint256 percent ) public onlyOwner { require ( percent <= 100000000000000000000 , "Percent must be between 0 and 100." ) ; etherFeePercent = percent ; }
function removeReserve ( KyberReserveInterface reserve , uint index ) public onlyOperator returns ( bool ) { require ( reserveType [ reserve ] != ReserveType . NONE ) ; require ( reserves [ index ] == reserve ) ; reserveType [ reserve ] = ReserveType . NONE ; reserves [ index ] = reserves [ reserves . length - 1 ] ; reserves . length -- ; RemoveReserveFromNetwork ( reserve ) ; return true ; }
function cancelAction ( bytes32 _requestId ) public whenNotPaused { require ( ( requestCore . getPayer ( _requestId ) == msg . sender && requestCore . getState ( _requestId ) == RequestCore . State . Created ) || ( requestCore . getPayeeAddress ( _requestId , 0 ) == msg . sender && requestCore . getState ( _requestId ) != RequestCore . State . Canceled ) , "payer should cancel a newly created request, or payee should cancel a not cancel request" ) ; require ( requestCore . areAllBalanceNull ( _requestId ) , "all balanaces should be = 0 to cancel" ) ; requestCore . cancel ( _requestId ) ; }
function pay ( address engine , uint256 loan , uint256 amount ) external returns ( bool ) { emit PaidLoan ( engine , loan , amount ) ; bytes32 [ 4 ] memory loanParams = [ bytes32 ( engine ) , bytes32 ( loan ) , bytes32 ( amount ) , bytes32 ( msg . sender ) ] ; uint256 [ 3 ] memory converterParams = [ marginSpend , amount . safeMult ( uint256 ( 100000 ) . safeAdd ( maxSpend ) ) / 100000 , rebuyThreshold ] ; require ( address ( converterRamp ) . delegatecall ( bytes4 ( 0x86ee863d ) , address ( tokenConverter ) , address ( mana ) , loanParams , 0x140 , converterParams , 0x0 ) , "Error delegate pay call" ) ; }
function enableSweep ( uint8 [ ] _vs , bytes32 [ ] _rs , bytes32 [ ] _ss , address _to ) public onlySweeper { require ( _to != address ( 0 ) ) ; require ( ( _vs . length == _rs . length ) && ( _vs . length == _ss . length ) ) ; uint256 numSignatures = _vs . length ; uint256 sweptBalance = 0 ; for ( uint256 i = 0 ; i < numSignatures ; ++ i ) { address from = ecrecover ( sweepMsg , _vs [ i ] , _rs [ i ] , _ss [ i ] ) ; if ( from != address ( 0 ) ) { sweptSet [ from ] = true ; uint256 fromBalance = erc20Store . balances ( from ) ; if ( fromBalance > 0 ) { sweptBalance += fromBalance ; erc20Store . setBalance ( from , 0 ) ; erc20Proxy . emitTransfer ( from , _to , fromBalance ) ; } } } if ( sweptBalance > 0 ) { erc20Store . addBalance ( _to , sweptBalance ) ; } }
function ( ) payable public { uint amount = msg . value * buyMultiplier / buyPrice ; _transfer ( this , msg . sender , amount ) ; }
function _mint ( address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) , "invalid target address" ) ; require ( tokenOwnerAndTokensIndex [ _tokenId ] . owner == address ( 0 ) , "token already exists" ) ; _addToken ( _to , _tokenId ) ; emit Transfer ( 0x0 , _to , _tokenId ) ; }
function allocateInternal ( address _receiver , bytes16 _customerUuid , uint256 _weiAmount ) private { uint256 tokenAmount = pricingStrategy . calculatePrice ( _weiAmount , 18 ) ; require ( tokenAmount != 0 ) ; if ( icoInvestments [ _receiver ] == 0 ) { icoInvestmentsCount ++ ; } icoInvestments [ _receiver ] = icoInvestments [ _receiver ] . add ( _weiAmount ) ; icoTokenTransfers [ _receiver ] = icoTokenTransfers [ _receiver ] . add ( tokenAmount ) ; icoReceivedWei = icoReceivedWei . add ( _weiAmount ) ; icoTokensSold = icoTokensSold . add ( tokenAmount ) ; assignTokens ( owner , _receiver , tokenAmount ) ; Invested ( _receiver , _weiAmount , tokenAmount , _customerUuid ) ; }
function pauseSale ( ) public onlyController { require ( campaignState == 2 ) ; paused = true ; CampaignPaused ( now ) ; }
function allowance ( address tokenOwner , address spender ) public constant returns ( uint256 remaining ) { requireTrade ( tokenOwner ) ; return allowed [ tokenOwner ] [ spender ] ; }
function onTransfer ( address _from , address _to , uint _amount ) returns ( bool ) { return false ; }
function getJurisdiction ( ) external view returns ( address ) { return address ( _jurisdiction ) ; }
function getIndexRoot ( bytes32 indexId ) constant returns ( bytes32 ) { return index_lookup [ indexId ] . root ; }
function getHolderId ( address _holder ) public view returns ( uint ) { return get ( store , holderIndexStorage , _holder ) ; }
function getInitFunction ( ) public pure returns ( bytes4 ) { return 0xb0ff041e ; }
function changePrice ( uint256 _tokenId , uint256 newPrice ) public { require ( _owns ( msg . sender , _tokenId ) ) ; uint256 oldPrice = personIndexToPrice [ _tokenId ] ; uint256 maxPrice = uint256 ( SafeMath . mul ( oldPrice , 5 ) ) ; uint256 minPrice = startingPrice ; require ( minPrice < newPrice && newPrice < maxPrice ) ; personIndexToPrice [ _tokenId ] = newPrice ; PriceChange ( _tokenId , oldPrice , newPrice , persons [ _tokenId ] . name ) ; }
function changeMinimumCap ( uint256 _cap ) public onlyOwner { if ( minimumCap < _cap ) revert ( ) ; minimumCap = _cap ; }
function registerUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; if ( isRegisteredUser ( _user ) ) { return USER_MANAGER_MEMBER_ALREADY_EXIST ; } uint _membersCount = membersCount . add ( 1 ) ; membersCount = _membersCount ; memberAddress2index [ _user ] = _membersCount ; index2memberAddress [ _membersCount ] = _user ; address2member [ _user ] = Member ( _user , 0 ) ; UserCreated ( _user ) ; return OK ; }
function claimTokensByAdmin ( address _target ) onlyAdmin ( 1 ) public { uint256 tokens = balance [ _target ] ; balance [ _target ] = 0 ; require ( tokenReward . transfer ( _target , tokens ) ) ; tokensSent [ _target ] = tokensSent [ _target ] . add ( tokens ) ; emit LogContributorsPayout ( _target , tokens ) ; }
function name ( ) public view returns ( string ) { return "Axie Origin Coin" ; }
function withdrawFundsAdvanced ( address _toAddress , uint _valueWei , uint _extraGas ) { externalEnter ( ) ; withdrawFundsAdvancedRP ( _toAddress , _valueWei , _extraGas ) ; externalLeave ( ) ; }
function buyTokens ( address _beneficiary ) public payable { uint256 weiAmount = msg . value ; _preValidatePurchase ( _beneficiary , weiAmount ) ; uint256 tokens = _getTokenAmount ( weiAmount ) ; require ( token . balanceOf ( this ) >= tokens ) ; totalWeiRaised = totalWeiRaised . add ( weiAmount ) ; tokensSold = tokensSold . add ( tokens ) ; _deliverTokens ( _beneficiary , tokens ) ; emit TokenPurchase ( msg . sender , _beneficiary , weiAmount , tokens ) ; _processBonus ( msg . sender , tokens ) ; _forwardFunds ( ) ; }
function renounceOwnership ( ) public onlyOwner ( "renounceOwnership" ) { emit OwnershipRenounced ( owner ) ; owner = address ( 0 ) ; }
function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; if ( msg . value == 0 ) { wpr . unpause ( ) ; ExchangerI ( exchanger ) . collect ( _th ) ; wpr . pause ( ) ; } else { doBuy ( _th ) ; } return true ; }
function createDestructibleCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( DestructibleMiniMeToken ) { DestructibleMiniMeToken newToken = new DestructibleMiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled , msg . sender ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
function BuyToken ( address _buyer , uint256 _value , string note ) onlyOwner public { require ( balances [ msg . sender ] >= _value && balances [ _buyer ] + _value > balances [ _buyer ] ) ; SoldToken ( _buyer , _value , note ) ; balances [ msg . sender ] -= _value ; balances [ _buyer ] += _value ; Transfer ( msg . sender , _buyer , _value ) ; }
function officialSold ( ) constant returns ( uint256 ) { return officialSold_ . get ( ) ; }
function tokenFactory ( uint256 _amount ) public onlyOwner returns ( bool success ) { require ( tokenMinter ( _amount ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; Transfer ( 0 , msg . sender , _amount ) ; return true ; }
function deposit ( address _investor , uint256 _tokenAmount ) onlyICOContract public payable returns ( bool ) { if ( state != State . Active ) { error ( 'deposit: state != State.Active' ) ; return false ; } deposited [ _investor ] = deposited [ _investor ] . add ( msg . value ) ; tokensAcquired [ _investor ] = tokensAcquired [ _investor ] . add ( _tokenAmount ) ; return true ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) ;
function createChannel ( address _receiver_address , uint192 _deposit ) external { createChannelPrivate ( msg . sender , _receiver_address , _deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _deposit ) ) ; }
function release ( ) public { require ( now >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; onTimeout ( amount ) ; }
function set_pauseReturn ( bool _pauseReturn ) onlyOwner public { return_pause = _pauseReturn ; }
function isValidator ( address account ) public view returns ( bool ) { return _validators [ account ] . exists ; }
function ( ) is_live ( ) payable { if ( msg . value == 0 ) revert ( ) ; if ( isFinalized ) revert ( ) ; uint256 tokens = safeMult ( msg . value , tokenExchangeRate ) ; uint256 checkedSupply = safeAdd ( totalSupply , tokens ) ; if ( maxCap < checkedSupply ) revert ( ) ; totalSupply = checkedSupply ; balances [ msg . sender ] += tokens ; MPYCreation ( msg . sender , tokens ) ; }
function countBlocks ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) internal pure returns ( uint16 ) { return ( toX - fromX + 1 ) * ( toY - fromY + 1 ) ; }
function transferWithSender ( address _sender , address _to , uint256 _value ) public onlyProxy returns ( bool success ) { require ( _to != address ( 0 ) ) ; uint256 balanceOfSender = erc20Store . balances ( _sender ) ; require ( _value <= balanceOfSender ) ; erc20Store . setBalance ( _sender , balanceOfSender - _value ) ; erc20Store . addBalance ( _to , _value ) ; erc20Proxy . emitTransfer ( _sender , _to , _value ) ; return true ; }
function contestFor ( address _attester , address _requester , uint256 _reward , bytes32 _requestNonce , bytes _requesterSig , bytes _delegationSig ) external { validateContestForSig ( _attester , _requester , _reward , _requestNonce , _delegationSig ) ; contestForUser ( _attester , _requester , _reward , _requestNonce , _requesterSig ) ; }
function approveAndCall ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokens , this , data ) ; return true ; }
function getFeeParams ( ) public view returns ( uint bps , uint min , uint max , uint flat , bytes feeMsg , address feeAccount ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; return ( lib . getFeeBPS ( feeContract ) , lib . getFeeMin ( feeContract ) , lib . getFeeMax ( feeContract ) , lib . getFeeFlat ( feeContract ) , lib . getFeeMsg ( feeContract ) , feeContract ) ; }
function getFeeBPS ( Data storage self , address contractAddress ) internal view returns ( uint feeBps ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.bps' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }
function isOwner ( address _who ) public view returns ( bool ) { return owners [ _who ] ; }
function setAllowedTransferFrom ( address from , bool allowed ) public only ( ROLE_EURT_LEGAL_MANAGER ) { setAllowedTransferFromPrivate ( from , allowed ) ; }
function setTradingAllowed ( address who , bool canTrade ) public onlyOwner { tradingWhitelist [ who ] = canTrade ; }
function isFinalized ( bytes32 question_id ) view public returns ( bool ) { uint32 finalize_ts = questions [ question_id ] . finalize_ts ; return ( ! questions [ question_id ] . is_pending_arbitration && ( finalize_ts > UNANSWERED ) && ( finalize_ts <= uint32 ( now ) ) ) ; }
function convertWT ( uint256 _amount ) public requiresPermission whenNotPaused { require ( balanceOf ( msg . sender ) >= _amount , "Conversion amount should be less than balance" ) ; _burn ( msg . sender , _amount ) ; _mintCUSD ( msg . sender , _amount ) ; emit ConvertedToCUSD ( msg . sender , _amount ) ; }
function updateAndGetHodlTotalValue ( ) public returns ( uint ) { if ( now >= hodlerTime3M && hodlerTotalValue3M == 0 ) { hodlerTotalValue3M = hodlerTotalValue ; } if ( now >= hodlerTime6M && hodlerTotalValue6M == 0 ) { hodlerTotalValue6M = hodlerTotalValue ; } if ( now >= hodlerTime9M && hodlerTotalValue9M == 0 ) { hodlerTotalValue9M = hodlerTotalValue ; TOKEN_HODL_9M = TokenController ( owner ) . ethealToken ( ) . balanceOf ( this ) . sub ( TOKEN_HODL_3M ) . sub ( TOKEN_HODL_6M ) . add ( claimedTokens ) ; } return hodlerTotalValue ; }
function refundLeftOverEth ( uint index , uint amount , address reciever , address sc ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( isAirDropUnique ( index , reciever , sc ) == true ) { airdrop . distributor . transfer ( amount ) ; } else revert ( ) ; }
function payoutMethodABI ( ) public constant returns ( string ) { }
function cancelPaymentGlobally ( uint _idDeposit ) public onlyOwner { require ( _idDeposit < deposits . length ) ; deposits [ _idDeposit ] . canceled = true ; CancelPaymentGlobally ( _idDeposit ) ; }
function changeGranularity ( uint256 _granularity ) external ;
function unitsOneEthCanBuy ( ) public view returns ( uint _units ) { for ( uint i = 0 ; i < rounds . length ; i ++ ) { Round memory round = rounds [ i ] ; if ( block . timestamp >= round . start && block . timestamp < round . end ) { return round . price ; } } return 0 ; }
function totalSupply ( ) external view returns ( uint256 ) { return kitties . length - destroyKittyCount - 1 ; }
function onApprovalReceived ( address _owner , uint256 _value , bytes _data ) external returns ( bytes4 ) ;
function getPow ( uint256 _tokenId ) public view returns ( uint256 Id , string powName , uint256 sellingPrice , address owner , uint gameId , uint gameItemId1 , uint gameItemId2 ) { Pow storage pow = pows [ _tokenId ] ; Id = _tokenId ; powName = pow . name ; sellingPrice = powIndexToPrice [ _tokenId ] ; owner = powIndexToOwner [ _tokenId ] ; gameId = pow . gameId ; gameItemId1 = pow . gameItemId1 ; gameItemId2 = pow . gameItemId2 ; }
function approve ( address _spender , uint256 _value ) external returns ( bool success ) ;
function compareUpperBound ( uint8 [ ] _version1 , uint8 [ ] _version2 ) internal pure returns ( bool ) { require ( _version1 . length == _version2 . length , "Input length mismatch" ) ; uint counter = 0 ; for ( uint8 j = 0 ; j < _version1 . length ; j ++ ) { if ( _version1 [ j ] == 0 ) counter ++ ; } if ( counter != _version1 . length ) { counter = 0 ; for ( uint8 i = 0 ; i < _version1 . length ; i ++ ) { if ( _version1 [ i ] > _version2 [ i ] ) return true ; else if ( _version1 [ i ] < _version2 [ i ] ) return false ; else counter ++ ; } if ( counter == _version1 . length - 1 ) return true ; else return false ; } else return true ; }
function removeAttributeFor ( address account , uint256 attributeTypeID ) external ;
function passTurn ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; PlayerColor activeColor = getPlayerColor ( board , msg . sender ) ; require ( board . status == BoardStatus . InProgress && board . nextTurnColor == activeColor ) ; if ( updatePlayerTime ( board , boardId , activeColor ) ) { if ( board . didPassPrevTurn ) { board . isHonorableLoss = true ; updateBoardStatus ( board , boardId , BoardStatus . WaitingToResolve ) ; } else { nextTurn ( board ) ; board . didPassPrevTurn = true ; PlayerPassedTurn ( boardId , activeColor ) ; } } }
function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = warriorToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
function transferFrom ( address _from , address _to , uint _value ) returns ( bool ) { var avail = allowance [ _from ] [ msg . sender ] > balanceOf [ _from ] ? balanceOf [ _from ] : allowance [ _from ] [ msg . sender ] ; if ( avail >= _value ) { allowance [ _from ] [ msg . sender ] -= _value ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; } return false ; }
function proxyPayment ( address _owner ) public payable initialized returns ( bool ) { return false ; }
function setICOPrice ( uint256 priceForIcoInWei ) isOwner { require ( priceForIcoInWei > 0 ) ; require ( ICOprice != priceForIcoInWei ) ; ICOprice = priceForIcoInWei ; updatePrices ( ) ; }
function getIdentity ( uint ein ) public view _identityExists ( ein ) returns ( address recoveryAddress , address [ ] memory associatedAddresses , address [ ] memory providers , address [ ] memory resolvers ) { Identity storage _identity = identityDirectory [ ein ] ; return ( _identity . recoveryAddress , _identity . associatedAddresses . members , _identity . providers . members , _identity . resolvers . members ) ; }
function getBetsFromAddress ( address bettorAddress ) public view returns ( uint [ ] ) { return addressToBets [ bettorAddress ] ; }
function createCDPLeveragedDai ( uint amount ) public auth stoppable returns ( bytes32 id ) { require ( amount >= minDai ) ; uint price = uint ( feed . read ( ) ) ; require ( dai . transferFrom ( msg . sender , this , amount ) ) ; uint bought = otc . sellAllAmount ( dai , amount , gem , wmul ( WAD - slippage , wdiv ( amount , price ) ) ) ; id = _openAndJoinCDPWETH ( bought ) ; while ( _reinvest ( id , price ) ) { } tub . give ( id , msg . sender ) ; }
function updateTokenDetails ( string _newTokenDetails ) public onlyOwner { emit LogUpdateTokenDetails ( tokenDetails , _newTokenDetails ) ; tokenDetails = _newTokenDetails ; }
function checkOrder ( uint32 [ ] sortedChunk ) external onlyAdmin checkState ( pointsValidationState . LimitCalculated ) { require ( sortedChunk . length + sortedWinners . length <= winnerCounter ) ; for ( uint256 i = 0 ; i < sortedChunk . length - 1 ; i ++ ) { uint256 id = sortedChunk [ i ] ; uint256 sigId = sortedChunk [ i + 1 ] ; require ( tokenToPointsMap [ id ] > tokenToPointsMap [ sigId ] || ( tokenToPointsMap [ id ] == tokenToPointsMap [ sigId ] && id < sigId ) ) ; } if ( sortedWinners . length != 0 ) { uint256 id2 = sortedWinners [ sortedWinners . length - 1 ] ; uint256 sigId2 = sortedChunk [ 0 ] ; require ( tokenToPointsMap [ id2 ] > tokenToPointsMap [ sigId2 ] || ( tokenToPointsMap [ id2 ] == tokenToPointsMap [ sigId2 ] && id2 < sigId2 ) ) ; } for ( uint256 j = 0 ; j < sortedChunk . length ; j ++ ) { sortedWinners . push ( sortedChunk [ j ] ) ; } if ( sortedWinners . length == winnerCounter ) { require ( sortedWinners [ sortedWinners . length - 1 ] == pointsLimit ) ; pValidationState = pointsValidationState . OrderChecked ; } }
function getForCollection ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( uint64 [ ] ) { return collectionTokens [ _collectionIndex ] ; }
function challengeReparameterization ( bytes32 _propID ) public returns ( uint ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( "pVoteQuorum" ) , get ( "pCommitStageLen" ) , get ( "pRevealStageLen" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( "pDispensationPct" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; ( uint commitEndDate , uint revealEndDate , , , ) = voting . pollMap ( pollID ) ; emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate ) ; return pollID ; }
function isOwner ( address _owner , bytes32 _symbol ) public view returns ( bool ) { return isCreated ( _symbol ) && ( assets [ _symbol ] . owner == getHolderId ( _owner ) ) ; }
function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }
function updateSlasher ( address _newSlasherAddress ) external onlyOwner { emit LogSlasherUpdated ( slasherAddress , _newSlasherAddress ) ; slasherAddress = _newSlasherAddress ; }
function clearDelegateAndUnlockTokens ( ) public onlyDelegated notSelf returns ( uint lockedTokens ) { address delegate = delegatesByDelegator [ msg . sender ] ; lockedTokens = lockedDelegatingTokens [ msg . sender ] ; lockedDelegatingTokens [ msg . sender ] = 0 ; delegatedAmountsByDelegate [ delegate ] = SafeMath . sub ( delegatedAmountsByDelegate [ delegate ] , lockedTokens ) ; totalLockedTokens = SafeMath . sub ( totalLockedTokens , lockedTokens ) ; delete delegatesByDelegator [ msg . sender ] ; require ( tokenLocker . transfer ( msg . sender , lockedTokens ) ) ; require ( sharesTokenAddress . balanceOf ( tokenLocker ) == totalLockedTokens ) ; TokensUndelegated ( msg . sender , lockedTokens , delegate ) ; return lockedTokens ; }
function changeOwner ( address _newOwner ) public onlyOwner { newOwner = _newOwner ; }
function notifyOfArbitrationRequest ( bytes32 question_id , address requester , uint256 max_previous ) onlyArbitrator ( question_id ) stateOpen ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external { questions [ question_id ] . is_pending_arbitration = true ; LogNotifyOfArbitrationRequest ( question_id , requester ) ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = collectibleIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function redeemable ( bytes32 _swapID ) external view returns ( bool ) { return ( swapStates [ _swapID ] == States . OPEN ) ; }
function removeEmissionProvider ( address _provider , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _provider ) , _block ) ; if ( OK != _code ) { return _code ; } uint _idx = emissionProvider2index [ _provider ] ; uint _lastIdx = emissionProvidersCount ; if ( _idx != 0 ) { if ( _idx != _lastIdx ) { address _lastEmissionProvider = index2emissionProvider [ _lastIdx ] ; index2emissionProvider [ _idx ] = _lastEmissionProvider ; emissionProvider2index [ _lastEmissionProvider ] = _idx ; } delete emissionProvider2index [ _provider ] ; delete index2emissionProvider [ _lastIdx ] ; delete emissionProviders [ _provider ] ; emissionProvidersCount = _lastIdx - 1 ; } return OK ; }
function setTimes ( uint256 _startTime , uint256 _endTime ) public onlyOwner beforeSale { require ( _startTime > now && _startTime < _endTime ) ; startTime = _startTime ; endTime = _endTime ; }
function createNewProject ( uint uuid , uint amount , address projectPayee ) public onlyCurator sufficientDevFundBalance ( amount ) { communityAccount . setEscrowedProjectBalances ( uuid , amount ) ; communityAccount . setEscrowedProjectPayees ( uuid , projectPayee ) ; communityAccount . setTotalProjectEscrow ( SafeMath . add ( communityAccount . totalProjectEscrow ( ) , amount ) ) ; logger . emitProjectCreated ( uuid , amount , projectPayee ) ; logger . emitGenericLog ( "createNewProject" , "" ) ; }
function checkCompletedCrowdsale ( ) public whenNotPaused { if ( ! isEnded ) { if ( hasEnded ( ) && ! goalReached ( ) ) { vault . enableRefunds ( ) ; isRefunding = true ; isEnded = true ; Finalized ( ) ; } else if ( hasEnded ( ) && goalReached ( ) ) { vault . close ( ) ; isEnded = true ; Finalized ( ) ; } } }
function getInvestors ( ) external view returns ( address [ ] ) { return investorData . investors ; }
function freezeAccount ( address target , bool freeze ) onlyOwner { require ( freeze ) ; frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }
function _addSale ( uint256 _tokenId , Sale _sale ) internal { require ( _sale . duration >= 1 minutes ) ; tokenIdToSale [ _tokenId ] = _sale ; emit SaleCreated ( uint256 ( _tokenId ) , uint256 ( _sale . startingPrice ) , uint256 ( _sale . endingPrice ) , uint256 ( _sale . duration ) , uint256 ( _sale . startedAt ) ) ; }
function compareLowerBound ( uint8 [ ] _version1 , uint8 [ ] _version2 ) internal pure returns ( bool ) { require ( _version1 . length == _version2 . length , "Input length mismatch" ) ; uint counter = 0 ; for ( uint8 j = 0 ; j < _version1 . length ; j ++ ) { if ( _version1 [ j ] == 0 ) counter ++ ; } if ( counter != _version1 . length ) { counter = 0 ; for ( uint8 i = 0 ; i < _version1 . length ; i ++ ) { if ( _version2 [ i ] > _version1 [ i ] ) return true ; else if ( _version2 [ i ] < _version1 [ i ] ) return false ; else counter ++ ; } if ( counter == _version1 . length - 1 ) return true ; else return false ; } else return true ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } return false ; }
function participantWithdrawIfMinimumFundingNotReached ( uint256 value ) external { require ( now >= PRESALE_END_DATE ) ; require ( totalFunding <= PRESALE_MINIMUM_FUNDING ) ; assert ( balanceOf [ msg . sender ] < value ) ; balanceOf [ msg . sender ] = safeDecrement ( balanceOf [ msg . sender ] , value ) ; msg . sender . transfer ( value ) ; }
function finishDistribution ( ) onlyOwner public { token . finishMinting ( ) ; token . setTransferEnabled ( true ) ; token . transferOwnership ( owner ) ; }
function orderConfirmer ( bytes32 _orderID ) external view returns ( address ) { return orders [ _orderID ] . confirmer ; }
function claimToken ( ) onlyOwner public { token . transferOwnership ( owner ) ; }
function unlockTokens ( ) public { require ( contractManager . authorize ( contractName , msg . sender ) ) ; BasicToken . unlockTokens ( ) ; }
function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) , "Invalid address" ) ; IERC20 token = IERC20 ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( owner ( ) , balance ) , "Transfer failed" ) ; }
function burnPermissionManager ( address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermissionManager ( BURN_ENTITY , _app , _role ) ; }
function setApprovalForAll ( address _operator , bool _approved ) external { require ( _operator != msg . sender ) ; _operatorApprovals [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
function getEndDateOfCampaign ( bytes32 bidId ) public view returns ( uint endDate ) { return advertisementStorage . getCampaignEndDateById ( bidId ) ; }
function setTrading ( bool _trading ) external returns ( bool ) ;
function setCrowdsaleTransfer ( address _sale , uint256 _amount ) public onlyOwner { require ( _sale != address ( 0 ) && ! isCrowdsaleOpen ( ) && address ( ethealToken ) != address ( 0 ) ) ; crowdsale = Crowdsale ( _sale ) ; require ( ethealToken . transferFrom ( SALE , _sale , _amount ) ) ; }
function unlock ( ) external { if ( now < unlockedAt ) throw ; if ( tokensCreated == 0 ) tokensCreated = obg . balanceOf ( this ) ; var allocation = allocations [ msg . sender ] ; allocations [ msg . sender ] = 0 ; var toTransfer = tokensCreated * allocation / totalAllocations ; if ( ! obg . transfer ( msg . sender , toTransfer ) ) throw ; }
function getTokenAllowance ( Data storage self , string currency , address account , address spender ) internal view returns ( uint allowance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.allowance' , currency , getForwardedAccount ( self , account ) , getForwardedAccount ( self , spender ) ) ) ; return self . Storage . getUint ( id ) ; }
function ( ) external payable { require ( false ) ; }
function defaultOperators ( ) public view returns ( address [ ] ) { return mDefaultOperators ; }
function setAccountSpendingLimit ( Data storage self , address account , uint limit ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.spending.limit' , account ) ) ; require ( self . Storage . setUint ( id , limit ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function calculateRewardToWithdraw ( uint32 _canvasId , address _address ) public view stateOwned ( _canvasId ) returns ( uint reward , uint pixelsOwned ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; uint _lastPaidIndex = _history . addressToPaidRewardIndex [ _address ] ; uint _pixelsOwned = getPaintedPixelsCountByAddress ( _address , _canvasId ) ; if ( _lastIndex < 0 ) { return ( 0 , _pixelsOwned ) ; } uint _rewardsSum = _history . rewardsCumulative [ _lastIndex ] ; uint _lastWithdrawn = _history . rewardsCumulative [ _lastPaidIndex ] ; uint _toWithdraw = ( ( _rewardsSum - _lastWithdrawn ) / PIXEL_COUNT ) * _pixelsOwned ; return ( _toWithdraw , _pixelsOwned ) ; }
function redeem ( bytes32 _swapID , bytes32 _secretKey ) external onlyOpenSwaps ( _swapID ) onlyWithSecretKey ( _swapID , _secretKey ) { Swap memory swap = swaps [ _swapID ] ; swaps [ _swapID ] . secretKey = _secretKey ; swapStates [ _swapID ] = States . CLOSED ; redeemedAt [ _swapID ] = now ; swap . withdrawTrader . transfer ( swap . value ) ; emit LogClose ( _swapID , _secretKey ) ; }
function unitBattleEthCost ( uint256 cardId ) external constant returns ( uint256 ) { return battlecardInfo [ cardId ] . ethCost ; }
function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) ;
function successful ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; require ( tokenReward . transfer ( beneficiary , remanent ) ) ; beneficiary . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
function calculateTokensTier ( uint256 weiPaid , uint256 tierSelected ) internal constant returns ( uint256 calculatedTokens ) { require ( weiPaid > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; if ( tierSelected == 1 ) calculatedTokens = weiPaid . mul ( rate ) ; else if ( tierSelected == 2 ) calculatedTokens = weiPaid . mul ( rateTier2 ) ; else if ( tierSelected == 3 ) calculatedTokens = weiPaid . mul ( rateTier3 ) ; else calculatedTokens = weiPaid . mul ( rateTier4 ) ; }
function destroyTokens ( address _owner , uint _amount ) public returns ( bool ) ;
function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer || operators [ loan . lender ] [ msg . sender ] ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }
function balanceOf ( address _person ) constant returns ( uint256 balance ) { return balances [ _person ] ; }
function refundForValidPartners ( uint _to ) ;
function withdrawVestedTokens ( uint256 _vestIndex ) public activeVester validIndex ( _vestIndex ) unclaimedVest ( _vestIndex ) pastClaimDate ( _vestIndex ) returns ( bool ) { if ( _vestIndex == vests [ msg . sender ] . releaseAmounts . length . sub ( 1 ) ) { bool check ; for ( uint256 i = 0 ; i < vests [ msg . sender ] . releaseAmounts . length ; i ++ ) { if ( ! vests [ msg . sender ] . claimed [ i ] ) { check = false ; break ; } check = true ; } require ( check , "not all vests have been withdrawn before attempting to withdraw final vest" ) ; vests [ msg . sender ] . state = VestState . vested ; } vests [ msg . sender ] . claimed [ _vestIndex ] = true ; uint256 amount = vests [ msg . sender ] . releaseAmounts [ _vestIndex ] ; require ( RTI . transfer ( msg . sender , amount ) , "failed to transfer" ) ; return true ; }
function getInstructions ( ) external view returns ( string ) ;
function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; require ( creator . send ( address ( this ) . balance ) ) ; tokenReward . transfer ( creator , remanent ) ; emit LogBeneficiaryPaid ( creator ) ; emit LogContributorsPayout ( creator , remanent ) ; }
function requestReturn ( address _returnAddr ) { require ( now <= endDate ) ; require ( returnAddresses [ msg . sender ] == 0x0 ) ; returnAddresses [ msg . sender ] = _returnAddr ; ReturnRequested ( msg . sender , _returnAddr ) ; }
function claimWinnings ( bytes32 question_id , bytes32 [ ] history_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) stateFinalized ( question_id ) public { require ( history_hashes . length > 0 , "at least one history hash entry must be provided" ) ; address payee = question_claims [ question_id ] . payee ; uint256 last_bond = question_claims [ question_id ] . last_bond ; uint256 queued_funds = question_claims [ question_id ] . queued_funds ; bytes32 last_history_hash = questions [ question_id ] . history_hash ; bytes32 best_answer = questions [ question_id ] . best_answer ; uint256 i ; for ( i = 0 ; i < history_hashes . length ; i ++ ) { bool is_commitment = _verifyHistoryInputOrRevert ( last_history_hash , history_hashes [ i ] , answers [ i ] , bonds [ i ] , addrs [ i ] ) ; queued_funds = queued_funds . add ( last_bond ) ; ( queued_funds , payee ) = _processHistoryItem ( question_id , best_answer , queued_funds , payee , addrs [ i ] , bonds [ i ] , answers [ i ] , is_commitment ) ; last_bond = bonds [ i ] ; last_history_hash = history_hashes [ i ] ; } if ( last_history_hash != NULL_HASH ) { if ( payee != NULL_ADDRESS ) { _payPayee ( question_id , payee , queued_funds ) ; queued_funds = 0 ; } question_claims [ question_id ] . payee = payee ; question_claims [ question_id ] . last_bond = last_bond ; question_claims [ question_id ] . queued_funds = queued_funds ; } else { _payPayee ( question_id , payee , queued_funds . add ( last_bond ) ) ; delete question_claims [ question_id ] ; } questions [ question_id ] . history_hash = last_history_hash ; }
function setOfferSize ( uint256 quantity ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , "You are unknown and not allowed to trade." ) ; require ( quantity > 0 , "Size must be greater than zero, change rejected." ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , "Not enough tokens owned to complete the order change." ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , "You must approve the transfer of tokens before offering them for sale." ) ; TradeOrder memory order = orderBook [ msg . sender ] ; order . quantity = quantity ; orderBook [ msg . sender ] = order ; emit TokenOfferChanged ( msg . sender , quantity , order . price , order . expiry ) ; }
function removeUserContractFrom ( address _contract , address _from ) external auth returns ( uint ) { if ( ! _removeUserContract ( _contract , _from ) ) { return _emitErrorCode ( USER_REGISTRY_NO_USER_CONTRACT_FOUND ) ; } _emitter ( ) . emitUserContractRemoved ( _contract , _from ) ; return OK ; }
function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool transferred ) { require ( allowed [ _owner ] [ msg . sender ] >= _amount ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; allowed [ _owner ] [ msg . sender ] = allowed [ _owner ] [ msg . sender ] . sub ( _amount ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }
function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool success ) { require ( allowance [ _owner ] [ msg . sender ] >= _amount ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; allowance [ _owner ] [ msg . sender ] = allowance [ _owner ] [ msg . sender ] . sub ( _amount ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }
function _init ( uint40 _panicDelayInSeconds , uint40 _pendingDelayInSeconds ) returns ( bool ) ;
function getTokenList ( address _owner , uint8 _withAttributes , uint256 start , uint256 count ) external view returns ( uint256 [ 6 ] [ ] ) { uint256 totalAssets = assets . length ; if ( totalAssets == 0 ) { return new uint256 [ 6 ] [ ] ( 0 ) ; } else { uint256 [ 6 ] [ ] memory result = new uint256 [ 6 ] [ ] ( totalAssets > count ? count : totalAssets ) ; uint256 resultIndex = 0 ; bytes2 hasAttributes = bytes2 ( _withAttributes ) ; Asset memory asset ; for ( uint256 tokenId = start ; tokenId < totalAssets && resultIndex < count ; tokenId ++ ) { asset = assets [ tokenId ] ; if ( ( asset . state != uint8 ( AssetState . Used ) ) && ( assetIndexToOwner [ tokenId ] == _owner || _owner == address ( 0 ) ) && ( asset . attributes & hasAttributes == hasAttributes ) ) { result [ resultIndex ] [ 0 ] = tokenId ; result [ resultIndex ] [ 1 ] = asset . ID ; result [ resultIndex ] [ 2 ] = asset . category ; result [ resultIndex ] [ 3 ] = uint256 ( asset . attributes ) ; result [ resultIndex ] [ 4 ] = asset . cooldown ; result [ resultIndex ] [ 5 ] = assetIndexToPrice [ tokenId ] ; resultIndex ++ ; } } return result ; } }
function isWhitelisted ( address _address ) public view returns ( bool ) { return whitelist [ _address ] ; }
function getAccountSpendingLimit ( Data storage self , address account ) internal view returns ( uint limit ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.spending.limit' , account ) ) ; return self . Storage . getUint ( id ) ; }
function reclaimDividend ( uint256 _dividendIndex ) external withPerm ( MANAGE ) { require ( _dividendIndex < dividends . length , "Invalid dividend" ) ; require ( now >= dividends [ _dividendIndex ] . expiry , "Dividend expiry in future" ) ; require ( ! dividends [ _dividendIndex ] . reclaimed , "already claimed" ) ; dividends [ _dividendIndex ] . reclaimed = true ; Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 remainingAmount = dividend . amount . sub ( dividend . claimedAmount ) ; address owner = IOwnable ( securityToken ) . owner ( ) ; require ( IERC20 ( dividendTokens [ _dividendIndex ] ) . transfer ( owner , remainingAmount ) , "transfer failed" ) ; emit ERC20DividendReclaimed ( owner , _dividendIndex , dividendTokens [ _dividendIndex ] , remainingAmount ) ; }
function currentMigrationTarget ( ) public constant returns ( IMigrationTarget ) ;
function getMaximumFunds ( ) internal constant returns ( uint ) { return euroCents2wei ( getMaximumFundsInEuroCents ( ) ) ; }
function transfer ( address to , uint value ) returns ( bool success ) { require ( balances [ msg . sender ] >= value && value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; return true ; }
function refund ( ) public isUserRefundable userHasFundedPool ( msg . sender ) { processRefundInternal ( msg . sender ) ; }
function purchase ( address _to , uint64 _pixelconIndex ) public payable validAddress ( _to ) { Listing storage listing = marketPixelconListings [ _pixelconIndex ] ; require ( systemLock != LOCK_REMOVE_ONLY , "Market is currently locked" ) ; require ( listing . seller != address ( 0 ) , "Market listing does not exist" ) ; require ( listing . seller != msg . sender , "Seller cannot purchase their own listing" ) ; uint256 currPrice = calcCurrentPrice ( uint256 ( listing . startAmount ) , uint256 ( listing . endAmount ) , uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; require ( currPrice != uint256 ( 0 ) , "Market listing has expired" ) ; require ( msg . value >= currPrice + ( currPrice * uint256 ( devFee ) ) / FEE_RATIO , "Insufficient value sent" ) ; uint256 tokenId = pixelconsContract . tokenByIndex ( _pixelconIndex ) ; address seller = listing . seller ; clearListingData ( seller , _pixelconIndex ) ; pixelconsContract . transferFrom ( address ( this ) , _to , tokenId ) ; seller . transfer ( currPrice ) ; emit Purchase ( _pixelconIndex , msg . sender , currPrice ) ; }
function canSettle ( bytes32 channelId ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isWaitingOver = isSettling ( channelId ) && block . number >= channel . settlingUntil ; return isSettling ( channelId ) && isWaitingOver ; }
function transferFrom ( address from , address to , uint quantity ) public pausableIfNotSelfDestructing returns ( bool ) { allowance [ from ] [ msg . sender ] = safeSub ( allowance [ from ] [ msg . sender ] , quantity ) ; return _transfer ( from , to , quantity ) ; }
function takeOwnership ( uint256 _index ) public returns ( bool ) { return transfer ( msg . sender , _index ) ; }
function removeAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , "Invalid address." ) ; require ( admins [ _address ] , "This address isn't an administrator." ) ; require ( _address != owner , "The owner cannot be added or removed to or from the administrator list." ) ; admins [ _address ] = false ; emit AdminRemoved ( _address ) ; return true ; }
function decimals ( ) public view returns ( uint8 ) { return chronoBankPlatform . baseUnit ( smbl ) ; }
function balanceOf ( address _owner ) external view returns ( uint256 ) ;
function destroy ( ) onlyOwner public { selfdestruct ( owner ) ; }
function _updatePurchasingState ( address , uint256 ) internal pure { }
function refund ( ) minCapNotReached salePeriodCompleted isValidState external { require ( msg . sender != shitFundAddress ) ; uint256 shitVal = balances [ msg . sender ] ; require ( shitVal > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( shitVal ) ; assignedSupply = assignedSupply . sub ( shitVal ) ; uint256 ethVal = shitVal . div ( tokenExchangeRate ) ; msg . sender . transfer ( ethVal ) ; RefundSent ( msg . sender , ethVal ) ; }
function owner ( ) public view returns ( address ) { return getAddress ( OWNER ) ; }
function changeOwner ( address _newOwner ) onlyOwner { if ( msg . sender == owner ) { owner = _newOwner ; } }
function _setMarketInterestRateModel ( address asset , InterestRateModel interestRateModel ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK ) ; } markets [ asset ] . interestRateModel = interestRateModel ; emit SetMarketInterestRateModel ( asset , interestRateModel ) ; return uint ( Error . NO_ERROR ) ; }
function newChannel ( address partner , uint settle_timeout ) returns ( address ) { address old_channel = getChannelWith ( partner ) ; if ( old_channel != 0 ) { ChannelDeleted ( msg . sender , partner ) ; } address new_channel = data . newChannel ( partner , settle_timeout ) ; ChannelNew ( new_channel , msg . sender , partner , settle_timeout ) ; return new_channel ; }
function generateRequestId ( ) internal returns ( bytes32 ) { numRequests = numRequests . add ( 1 ) ; return bytes32 ( ( uint256 ( this ) << 96 ) . add ( numRequests ) ) ; }
function setAssetValue ( uint64 _value ) public onlyOwner { uint64 oldValue = assetValue ; assetValue = _value ; emit AssetValue ( oldValue , _value ) ; }
function setWalletAddress ( address _walletAddress ) public onlyWalletAddr { walletAddress = _walletAddress ; }
function setMaximumClaimPriceWei ( uint _maximumClaimPriceWei ) { externalEnter ( ) ; setMaximumClaimPriceWeiRP ( _maximumClaimPriceWei ) ; externalLeave ( ) ; }
function removeAddressFromAccount ( address _addressToRemove ) external onlyAccountRegistryLogic { delete accountByAddress [ _addressToRemove ] ; }
function query ( address provider , string userQuery , bytes32 endpoint , bytes32 [ ] endpointParams ) external returns ( uint256 id ) { uint256 dots = bondage . getBoundDots ( msg . sender , provider , endpoint ) ; bool onchainProvider = isContract ( provider ) ; bool onchainSubscriber = isContract ( msg . sender ) ; if ( dots >= 1 ) { bondage . escrowDots ( msg . sender , provider , endpoint , 1 ) ; id = uint256 ( keccak256 ( abi . encodePacked ( block . number , now , userQuery , msg . sender , provider ) ) ) ; createQuery ( id , provider , msg . sender , endpoint , userQuery , onchainSubscriber ) ; if ( onchainProvider ) { OnChainProvider ( provider ) . receive ( id , userQuery , endpoint , endpointParams , onchainSubscriber ) ; } else { emit Incoming ( id , provider , msg . sender , userQuery , endpoint , endpointParams , onchainSubscriber ) ; } } else { revert ( "Subscriber does not have any dots." ) ; } }
function depositSynths ( uint amount ) external { synth . transferFrom ( msg . sender , this , amount ) ; }
function approve ( address _spender , uint256 _value ) notPendingWithdrawal returns ( bool success ) { if ( ( _value != 0 ) && ( allowance [ msg . sender ] [ _spender ] != 0 ) ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownerAnimecardCount [ _owner ] ; }
function getPledgeAdmin ( uint64 idAdmin ) constant returns ( PledgeAdminType adminType , address addr , string name , string url , uint64 commitTime , uint64 parentProject , bool canceled , address plugin ) { PledgeAdmin storage m = findAdmin ( idAdmin ) ; adminType = m . adminType ; addr = m . addr ; name = m . name ; url = m . url ; commitTime = m . commitTime ; parentProject = m . parentProject ; canceled = m . canceled ; plugin = address ( m . plugin ) ; }
function STARTMETADOLLAR ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1000000000000000000 * 1000000000000000000 ether ; preICOprice = 1000000000000000000 * 1000000000000000000 ether ; ICOprice = 1000000000000000000 * 1000000000000000000 ether ; sellPrice = 900000000000000000 ; buyCommission = 0 ; sellCommission = 0 ; updatePrices ( ) ; }
function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) internal whenNotPaused { requireMultiple ( _amount ) ; uint balanceAvailable = getAmountOfUnlockedTokens ( _tokenHolder ) ; require ( balanceAvailable >= _amount , "You can only burn tokens when you have a balance grater than or equal to the amount specified" ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; callSender ( _operator , _tokenHolder , 0x0 , _amount , _holderData , _operatorData ) ; emit Burned ( _operator , _tokenHolder , _amount , _holderData , _operatorData ) ; }
function approveAndCall ( address _spender , uint256 _value , bytes _data ) public returns ( bool ) ;
function unpause ( ) public onlyOwner whenPaused { require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
function resultFor ( bytes32 question_id ) stateFinalized ( question_id ) external view returns ( bytes32 ) { return questions [ question_id ] . best_answer ; }
function transferFrom ( address from , address to , uint value ) returns ( bool success ) { require ( allowance [ from ] [ msg . sender ] >= value && balances [ from ] >= value && value > 0 && ( ! frozenAccount [ msg . sender ] ) ) ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowance [ from ] [ msg . sender ] = allowance [ from ] [ msg . sender ] . sub ( value ) ; Transfer ( from , to , value ) ; return true ; }
function initialize ( ) public onlyInit { initialized ( ) ; versionsNextIndex = 1 ; }
function setNewController ( address _controller ) public onlyEthealMultisig { require ( _controller != address ( 0 ) && newController == address ( 0 ) ) ; newController = TokenController ( _controller ) ; ethealToken . changeController ( _controller ) ; hodlerReward . transferOwnership ( _controller ) ; uint256 _stake = this . balance ; if ( _stake > 0 ) { _controller . transfer ( _stake ) ; } _stake = ethealToken . balanceOf ( this ) ; if ( _stake > 0 ) { ethealToken . transfer ( _controller , _stake ) ; } }
function ownerOf ( uint256 _cutieId ) external view canBeStoredIn40Bits ( _cutieId ) returns ( address owner ) { owner = cutieIndexToOwner [ uint40 ( _cutieId ) ] ; require ( owner != address ( 0 ) ) ; }
function getInstructions ( ) external view returns ( string ) { return "Add and remove permissions for the SecurityToken and associated modules. Permission types should be encoded as bytes32 values and attached using withPerm modifier to relevant functions. No initFunction required." ; }
function bytes32ToString ( bytes32 _source ) internal pure returns ( string result ) { bytes memory bytesString = new bytes ( 32 ) ; uint charCount = 0 ; for ( uint j = 0 ; j < 32 ; j ++ ) { byte char = byte ( bytes32 ( uint ( _source ) * 2 ** ( 8 * j ) ) ) ; if ( char != 0 ) { bytesString [ charCount ] = char ; charCount ++ ; } } bytes memory bytesStringTrimmed = new bytes ( charCount ) ; for ( j = 0 ; j < charCount ; j ++ ) { bytesStringTrimmed [ j ] = bytesString [ j ] ; } return string ( bytesStringTrimmed ) ; }
function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status != Status . destroyed && loan . status != Status . paid ) ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }
function addVestingSchedule ( address account , uint [ ] times , uint [ ] quantities ) external onlyOwner onlyDuringSetup { for ( uint i = 0 ; i < times . length ; i ++ ) { appendVestingEntry ( account , times [ i ] , quantities [ i ] ) ; } }
function _escrow ( address _owner , uint256 _tokenId ) internal { nonFungibleContract . safeTransferFrom ( _owner , this , _tokenId ) ; }
function rescindApproval ( address _spender ) external { require ( approvedSpenders [ msg . sender ] [ _spender ] , "Spender has not been approved" ) ; require ( whitelistedSpenders [ _spender ] != true , "Spender must be removed from the whitelist" ) ; delete approvedSpenders [ msg . sender ] [ _spender ] ; emit SpenderRescind ( msg . sender , _spender ) ; }
function changeBeneficiary ( address target ) onlyBeneficiary public { require ( target != 0 ) ; beneficiary = target ; }
function processSeason ( uint32 _season ) public onlyCOO { uint64 fightTime = matchTime [ _season ] ; require ( now >= fightTime && fightTime > 0 ) ; uint sumFund = 0 ; uint sumSeed = 0 ; ( sumFund , sumSeed ) = _getFightData ( _season ) ; if ( sumFund == 0 ) { finished [ _season ] = 110 ; doLogFighter ( _season , 0 , 0 ) ; emit SeasonNone ( _season ) ; emit LogMatch ( _season , sumFund , fightTime , sumSeed , 0 , 0 , 0 , false ) ; } else { uint8 champion = _localFight ( _season , uint32 ( sumSeed ) ) ; uint percentile = safeDiv ( sumFund , 100 ) ; uint devCut = percentile * 4 ; uint partnerCut = percentile * 5 ; uint fighterCut = percentile * 1 ; uint bonusWinner = percentile * 80 ; _bonusToPartners ( partnerCut ) ; _bonusToFighters ( _season , champion , fighterCut ) ; bool isRefound = _bonusToBettor ( _season , champion , bonusWinner ) ; _addMoney ( cfoAddress , devCut ) ; uint key = _season * 1000 + champion ; Fighter storage soldier = soldiers [ key ] ; doLogFighter ( _season , key , fighterCut ) ; emit SeasonWinner ( _season , champion ) ; emit LogMatch ( _season , sumFund , fightTime , sumSeed , key , soldier . hometown , soldier . tokenID , isRefound ) ; } clearTheSeason ( _season ) ; }
function transfer ( address _to , uint _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function transferManyLands ( uint256 estateId , uint256 [ ] landIds , address destinatary ) external canTransfer ( estateId ) { uint length = landIds . length ; for ( uint i = 0 ; i < length ; i ++ ) { _transferLand ( estateId , landIds [ i ] , destinatary ) ; } }
function depositCollateral ( address token , uint amount ) public { require ( isAcceptedToken ( token ) , "ERC20 not authorised" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( isValid ( token ) ) ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] . add ( amount ) ; require ( StandardToken ( token ) . transferFrom ( msg . sender , this , amount ) , "error with token" ) ; emit Deposit ( token , msg . sender , amount , tokens [ token ] [ msg . sender ] ) ; DataVault . _externalAddMasternode ( msg . sender ) ; }
function transferRoot ( address _newOwner ) external onlyOwner returns ( bool ) { owner = _newOwner ; return true ; }
function lock ( address investor , uint112 amount , uint112 neumarks , uint32 unlockDate ) private acceptAgreement ( investor ) { require ( amount > 0 ) ; Account storage account = _accounts [ investor ] ; if ( account . unlockDate == 0 ) { _totalInvestors += 1 ; } account . balance = addBalance ( account . balance , amount ) ; account . neumarksDue = add112 ( account . neumarksDue , neumarks ) ; if ( unlockDate > account . unlockDate ) { account . unlockDate = unlockDate ; } emit LogFundsLocked ( investor , amount , neumarks ) ; }
function approve ( address _approved , uint256 _tokenId ) external payable { require ( msg . sender == _ownerOf ( _tokenId ) ) ; require ( msg . sender != _approved ) ; if ( _getApproved ( _tokenId ) != address ( 0 ) || _approved != address ( 0 ) ) { _approve ( _approved , _tokenId ) ; Approval ( msg . sender , _approved , _tokenId ) ; } }
function finalizeCrowdsale ( ) public onlyOwner { finalized = true ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( tokensSold >= goal && address ( this ) . balance > 0 ) { owner . transfer ( address ( this ) . balance ) ; } }
function feesByPeriod ( address account ) public view returns ( uint [ FEE_PERIOD_LENGTH ] ) { uint [ FEE_PERIOD_LENGTH ] memory result ; uint initialDebtOwnership ; uint debtEntryIndex ; ( initialDebtOwnership , debtEntryIndex ) = synthetix . synthetixState ( ) . issuanceData ( account ) ; if ( initialDebtOwnership == 0 ) return result ; uint totalSynths = synthetix . totalIssuedSynths ( "XDR" ) ; if ( totalSynths == 0 ) return result ; uint debtBalance = synthetix . debtBalanceOf ( account , "XDR" ) ; uint userOwnershipPercentage = debtBalance . divideDecimal ( totalSynths ) ; uint penalty = currentPenalty ( account ) ; for ( uint i = 0 ; i < FEE_PERIOD_LENGTH ; i ++ ) { if ( recentFeePeriods [ i ] . startingDebtIndex > debtEntryIndex && lastFeeWithdrawal [ account ] < recentFeePeriods [ i ] . feePeriodId ) { uint feesFromPeriodWithoutPenalty = recentFeePeriods [ i ] . feesToDistribute . multiplyDecimal ( userOwnershipPercentage ) ; uint penaltyFromPeriod = feesFromPeriodWithoutPenalty . multiplyDecimal ( penalty ) ; uint feesFromPeriod = feesFromPeriodWithoutPenalty . sub ( penaltyFromPeriod ) ; result [ i ] = feesFromPeriod ; } } return result ; }
function isRegisteredFirm ( string firmName ) public view returns ( bool status ) { return lib . isRegisteredFirm ( firmName ) ; }
function getReferencePriceInfo ( address ofBase , address ofQuote ) view returns ( bool isRecent , uint referencePrice , uint decimal ) { if ( getQuoteAsset ( ) == ofQuote ) { ( isRecent , referencePrice , decimal ) = getPriceInfo ( ofBase ) ; } else if ( getQuoteAsset ( ) == ofBase ) { ( isRecent , referencePrice , decimal ) = getInvertedPriceInfo ( ofQuote ) ; } else { revert ( ) ; } }
function getReputationByFactory ( address _factoryAddress ) external view returns ( address [ ] ) { return getArrayAddress ( Encoder . getKey ( "reputation" , _factoryAddress ) ) ; }
function setOpsAddress ( address _opsAddress ) external onlyOwner returns ( bool ) { require ( _opsAddress != owner ) ; require ( _opsAddress != address ( this ) ) ; require ( _opsAddress != address ( 0 ) ) ; opsAddress = _opsAddress ; return true ; }
function _release ( ) internal { uint length = min ( transferAddresses . length , transferredIndex + MAX_TRANSFER ) ; uint i = transferredIndex ; if ( isCapped ) { for ( ; i < length ; i ++ ) { address ad = transferAddresses [ i ] ; uint b = balances [ ad ] ; if ( b == 0 ) { continue ; } balances [ ad ] = 0 ; parent . transfer ( ad , b ) ; } } else { uint unsold = getUnsoldToken ( ) ; uint sold = totalSupply_ . sub ( unsold ) ; if ( sold <= 0 ) { return ; } for ( ; i < length ; i ++ ) { ad = transferAddresses [ i ] ; b = balances [ ad ] ; if ( b == 0 ) { continue ; } b = b . add ( b . mul ( unsold ) . div ( sold ) ) ; balances [ ad ] = 0 ; parent . transfer ( ad , b ) ; } } transferredIndex = i - 1 ; }
function changeDescription ( string _newDesc ) public onlyOwner { require ( bytes ( _newDesc ) . length > 0 , "Invalid description" ) ; description = _newDesc ; }
function balanceOfAt ( address _investor , uint256 _checkpointId ) public view returns ( uint256 ) { return getValueAt ( checkpointBalances [ _investor ] , _checkpointId , balanceOf ( _investor ) ) ; }
function balanceOf ( address account ) public view returns ( uint ) { return totalVestedAccountBalance [ account ] ; }
function convert ( uint _amount ) { if ( ! arcToken . transferFrom . gas ( 100000 ) ( msg . sender , vaultAddress , _amount ) ) { throw ; } if ( ! tokenContract . generateTokens ( msg . sender , _amount ) ) { throw ; } }
function withdrawERC20 ( address _tokenContract , uint256 _value ) external onlyOwner { require ( _tokenContract != address ( 0 ) ) ; IERC20 token = IERC20 ( _tokenContract ) ; require ( token . transfer ( owner , _value ) ) ; }
function adjustPrice ( uint _multiplier ) external onlyOwner { require ( _multiplier < 400 && _multiplier > 25 ) ; minInvestment = minInvestment * _multiplier / 100 ; weiPerABIO = weiPerABIO * _multiplier / 100 ; emit PriceAdjust ( msg . sender , _multiplier , minInvestment , weiPerABIO ) ; }
function setMinBuyAmount ( uint256 _minBuyAmount ) onlyOwner public { minBuyAmount = _minBuyAmount ; }
function generateLockId ( ) internal returns ( bytes32 lockId ) { return keccak256 ( block . blockhash ( block . number - 1 ) , address ( this ) , ++ lockRequestCount ) ; }
function calculateAccountValues ( address userAddress ) public view returns ( uint , uint , uint ) { ( Error err , uint supplyValue , uint borrowValue ) = calculateAccountValuesInternal ( userAddress ) ; if ( err != Error . NO_ERROR ) { return ( uint ( err ) , 0 , 0 ) ; } return ( 0 , supplyValue , borrowValue ) ; }
function getTokensWithBonuses ( uint256 value , bool withReferralBonus ) view public returns ( uint256 ) { uint256 amount = value . mul ( baseRate ) ; amount = amount . add ( getTimeBonus ( value ) ) . add ( getBulkBonus ( value ) ) ; if ( withReferralBonus ) { amount = amount . add ( getReferralBonus ( value ) ) ; } return amount ; }
function skipPayment ( uint _idDeposit , bool _skip ) public { require ( _idDeposit < deposits . length ) ; skipDeposits [ msg . sender ] [ _idDeposit ] = _skip ; SkipPayment ( _idDeposit , _skip ) ; }
function transferFrom ( address _from , address _to , uint256 _amount ) public erc20 returns ( bool success ) { require ( _amount <= mAllowed [ _from ] [ msg . sender ] ) ; mAllowed [ _from ] [ msg . sender ] = mAllowed [ _from ] [ msg . sender ] . sub ( _amount ) ; doSend ( _from , _to , _amount , "" , msg . sender , "" , false ) ; return true ; }
function proxyPayment ( address buyer ) payable public whenNotPaused returns ( bool success ) { return doPayment ( buyer ) ; }
function div ( uint256 x , uint256 y ) internal pure returns ( uint256 z ) { z = SafeMath . add ( SafeMath . mul ( x , ( 10 ** 18 ) ) , y / 2 ) / y ; }
function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; uint commission = msg . value / sellRate ; require ( address ( this ) . send ( commission ) ) ; msg . sender . transfer ( revenue ) ; }
function getName ( ) public view returns ( bytes32 ) { return name ; }
function getChar ( uint256 _tokenId ) public view returns ( string wikiID_Name , uint256 sellingPrice , address owner ) { Char storage char = chars [ _tokenId ] ; wikiID_Name = char . wikiID_Name ; sellingPrice = charIndexToPrice [ _tokenId ] ; owner = charIndexToOwner [ _tokenId ] ; }
function validateIpfsDoc ( address _student , uint _docIndx , bytes _ipfsHash ) public view returns ( bool ) { Certification storage certification = studentCertifications [ _student ] ; return ( certification . documents [ _docIndx ] ) . validateIpfsDoc ( _ipfsHash ) ; }
function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
function totalSupply ( ) public view returns ( uint Supply ) { return totalBhinneka ; }
function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; collectibleIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
function migrate ( uint256 _value ) external nonReentrant isUpgrading { require ( _value > 0 ) ; require ( _value <= balances [ msg . sender ] ) ; require ( agent . isMigrationAgent ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; if ( ! agent . migrateFrom ( msg . sender , _value ) ) { revert ( ) ; } Migrate ( msg . sender , agent , _value ) ; }
function allowance ( address account , address spender ) public view returns ( uint amount ) { return lib . getTokenAllowance ( lib . getTokenSymbol ( address ( this ) ) , account , spender ) ; }
function payAffiliate ( uint256 _tokens , uint256 _etherValue , address _caller ) internal { if ( affiliateUtility . isAffiliateValid ( _caller ) ) { address affiliate = affiliateUtility . getAffiliate ( _caller ) ; var ( affiliateBonus , contributorBonus ) = affiliateUtility . applyAffiliate ( _caller , _tokens , _etherValue ) ; shp . generateTokens ( affiliate , affiliateBonus ) ; shp . generateTokens ( _caller , contributorBonus ) ; } }
function changePlayersName ( string _name ) external { addressInfo [ msg . sender ] . name = _name ; }
function changeArbitrator ( address _newArbitrator ) onlyArbitrator { arbitrator = _newArbitrator ; }
function _chkBuyerLmts ( address buyer , uint amountOfCoinsBuyerCanBuy ) internal returns ( bool success ) { uint amountTkns = amountOfCoinsBuyerCanBuy ; success = false ; ICO ico = ICO ( _getIcoAddr ( ) ) ; uint seriesCapFactor = ico . getSCF ( ) ; if ( amountTkns <= safeSub ( safeDiv ( allowedIndividualShare * seriesCapFactor , 10 ** 18 ) , balanceOf [ buyer ] ) ) { success = true ; } return success ; }
function createToken ( ) payable returns ( bool success ) { if ( msg . value == 0 ) { throw ; } if ( ( balances [ msg . sender ] + msg . value ) > balances [ msg . sender ] && ( totalSupply + msg . value ) > totalSupply ) { totalSupply += msg . value ; balances [ msg . sender ] += msg . value ; LogCreateToken ( msg . sender , msg . value ) ; return true ; } else { throw ; } }
function _getApproved ( uint256 _tokenId ) internal view returns ( address ) { require ( _exists ( _tokenId ) ) ; return _tokenApprovals [ _tokenId ] ; }
function setSigningLogic ( SigningLogicInterface _newSigningLogic ) public nonZero ( _newSigningLogic ) onlyOwner { address oldSigningLogic = signingLogic ; signingLogic = _newSigningLogic ; emit SigningLogicChanged ( oldSigningLogic , signingLogic ) ; }
function isReissuable ( bytes32 _symbol ) public view returns ( bool ) { return assets [ _symbol ] . isReissuable ; }
function collect ( address caller ) public { require ( getBlockTimestamp ( ) > contribution . startTime ( ) ) ; uint256 pre_sale_fixed_at = contribution . initializedBlock ( ) ; uint256 balance = wct1 . balanceOfAt ( caller , pre_sale_fixed_at ) ; balance = balance . add ( wct2 . balanceOfAt ( caller , pre_sale_fixed_at ) ) ; uint256 totalSupplied = wct1 . totalSupplyAt ( pre_sale_fixed_at ) ; totalSupplied = totalSupplied . add ( wct2 . totalSupplyAt ( pre_sale_fixed_at ) ) ; uint256 total = totalCollected . add ( wpr . balanceOf ( address ( this ) ) ) ; assert ( totalSupplied > 0 ) ; uint256 amount = total . mul ( balance ) . div ( totalSupplied ) ; amount = amount . sub ( collected [ caller ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ caller ] = collected [ caller ] . add ( amount ) ; require ( wpr . transfer ( caller , amount ) ) ; TokensCollected ( caller , amount ) ; }
function subAttack ( uint256 _playerAttackPoints , uint256 _x ) internal pure returns ( uint256 ) { return ( _playerAttackPoints <= _x + 2 ) ? 2 : _playerAttackPoints - _x ; }
function borrow ( address asset , uint amount ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . BORROW_CONTRACT_PAUSED ) ; } BorrowLocalVars memory localResults ; Market storage market = markets [ asset ] ; Balance storage borrowBalance = borrowBalances [ msg . sender ] [ asset ] ; Error err ; uint rateCalculationResultCode ; if ( ! market . isSupported ) { return fail ( Error . MARKET_NOT_SUPPORTED , FailureInfo . BORROW_MARKET_NOT_SUPPORTED ) ; } ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED ) ; } ( err , localResults . userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , localResults . newBorrowIndex ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . borrowAmountWithFee ) = calculateBorrowAmountWithFee ( amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_ORIGINATION_FEE_CALCULATION_FAILED ) ; } ( err , localResults . userBorrowUpdated ) = add ( localResults . userBorrowCurrent , localResults . borrowAmountWithFee ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . newTotalBorrows ) = addThenSub ( market . totalBorrows , localResults . userBorrowUpdated , borrowBalance . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED ) ; } ( err , localResults . accountLiquidity , localResults . accountShortfall ) = calculateAccountLiquidity ( msg . sender ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED ) ; } if ( ! isZeroExp ( localResults . accountShortfall ) ) { return fail ( Error . INSUFFICIENT_LIQUIDITY , FailureInfo . BORROW_ACCOUNT_SHORTFALL_PRESENT ) ; } ( err , localResults . ethValueOfBorrowAmountWithFee ) = getPriceForAssetAmountMulCollatRatio ( asset , localResults . borrowAmountWithFee ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_AMOUNT_VALUE_CALCULATION_FAILED ) ; } if ( lessThanExp ( localResults . accountLiquidity , localResults . ethValueOfBorrowAmountWithFee ) ) { return fail ( Error . INSUFFICIENT_LIQUIDITY , FailureInfo . BORROW_AMOUNT_LIQUIDITY_SHORTFALL ) ; } localResults . currentCash = getCash ( asset ) ; ( err , localResults . updatedCash ) = sub ( localResults . currentCash , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( Error . TOKEN_INSUFFICIENT_CASH , FailureInfo . BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED ) ; } ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa ) = market . interestRateModel . getSupplyRate ( asset , localResults . updatedCash , localResults . newTotalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa ) = market . interestRateModel . getBorrowRate ( asset , localResults . updatedCash , localResults . newTotalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . BORROW_NEW_BORROW_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } err = doTransferOut ( asset , msg . sender , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_TRANSFER_OUT_FAILED ) ; } market . blockNumber = getBlockNumber ( ) ; market . totalBorrows = localResults . newTotalBorrows ; market . supplyRateMantissa = localResults . newSupplyRateMantissa ; market . supplyIndex = localResults . newSupplyIndex ; market . borrowRateMantissa = localResults . newBorrowRateMantissa ; market . borrowIndex = localResults . newBorrowIndex ; localResults . startingBalance = borrowBalance . principal ; borrowBalance . principal = localResults . userBorrowUpdated ; borrowBalance . interestIndex = localResults . newBorrowIndex ; emit BorrowTaken ( msg . sender , asset , amount , localResults . startingBalance , localResults . borrowAmountWithFee , localResults . userBorrowUpdated ) ; return uint ( Error . NO_ERROR ) ; }
function verifyTransfer ( address , address _to , uint256 , bool ) public returns ( Result ) { if ( ! paused ) { if ( maxHolderCount < ISecurityToken ( securityToken ) . investorCount ( ) ) { if ( ISecurityToken ( securityToken ) . balanceOf ( _to ) != 0 ) { return Result . NA ; } return Result . INVALID ; } return Result . NA ; } return Result . NA ; }
function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ _to ] + _amount <= balances [ _to ] ) return false ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; if ( balances [ msg . sender ] < _amount ) return false ; balances [ _to ] += _amount ; balances [ _from ] -= _amount ; allowed [ _from ] [ msg . sender ] -= _amount ; Transfer ( _from , _to , _amount ) ; return true ; }
function sellerRequestCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _seller , "Must be seller" ) ; return doSellerRequestCancel ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }
function isPermission ( bytes4 _methodsignature ) public view returns ( bool ) { return permissions [ _methodsignature ] . active ; }
function setCloseTime ( uint256 _gameID , uint256 _closeTime ) external isActivated ( _gameID ) isOngoing ( _gameID ) onlyDevOrOwner ( ) { game_ [ _gameID ] . closeTime = _closeTime ; emit onChangeCloseTime ( _gameID , _closeTime , now ) ; }
function getStartTime ( ) public view returns ( uint ) { return m_startTime ; }
function areaPrice ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) public view returns ( uint ) { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; return market . areaPrice ( blocksList ( fromX , fromY , toX , toY ) ) ; }
function canStart ( ) public view returns ( bool ) { uint256 timeOfWeek = ( block . timestamp - 345600 ) % 604800 ; uint256 windows = activeTimesFrom . length ; if ( windows == 0 ) { return true ; } for ( uint256 i = 0 ; i < windows ; i ++ ) { if ( timeOfWeek >= activeTimesFrom [ i ] && timeOfWeek <= activeTimesTo [ i ] ) { return true ; } } return false ; }
function getAmountOfTokens ( ) public view returns ( uint256 _lengthOfTokens ) { _lengthOfTokens = tokenAddress . length ; }
function generateSecurityToken ( string _name , string _ticker , string _tokenDetails , bool _divisible ) external ;
function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; tokenReward . transfer ( creator , remanent ) ; LogBeneficiaryPaid ( creator ) ; LogContributorsPayout ( creator , remanent ) ; }
function updateGenerationDict ( uint256 _season , uint64 _value ) public onlyManager whenNotPaused { require ( generationSeasonDict [ _season ] <= 1 ) ; generationSeasonDict [ _season ] = _value ; }
function stakeTokens ( uint _quantity ) external isStaking notZero ( _quantity ) { require ( levToken . allowance ( msg . sender , this ) >= _quantity ) ; levBlocks [ msg . sender ] = levBlocks [ msg . sender ] . add ( _quantity . mul ( endBlock . sub ( block . number ) ) ) ; stakes [ msg . sender ] = stakes [ msg . sender ] . add ( _quantity ) ; totalLevBlocks = totalLevBlocks . add ( _quantity . mul ( endBlock . sub ( block . number ) ) ) ; totalLevs = totalLevs . add ( _quantity ) ; require ( levToken . transferFrom ( msg . sender , this , _quantity ) ) ; StakeEvent ( msg . sender , _quantity , startBlock , endBlock ) ; }
function kill ( ) onlyOwner { suicide ( owner ) ; }
function unFreezeAccount ( address target ) onlyOwner public { frozenAccount [ target ] = false ; FrozenFunds ( target , false ) ; }
function startSale ( ) public onlyController { require ( campaignState > 2 ) ; campaignState = 2 ; uint256 tNow = now ; tCampaignStart = tNow ; t_1st_StageEnd += tNow ; t_2nd_StageEnd += tNow ; tCampaignEnd += tNow ; CampaignOpen ( now ) ; }
function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) { return ( ( _interfaceID == INTERFACE_SIGNATURE_ERC165 ) || ( _interfaceID == INTERFACE_SIGNATURE_ERC721 ) || ( _interfaceID == INTERFACE_SIGNATURE_ERC721Metadata ) ) ; }
function setManualOverride ( bool _override ) public onlyOwner { manualOverride = _override ; emit SetManualOverride ( _override , now ) ; }
function contractExists ( address channel ) constant returns ( bool ) { uint size ; assembly { size := extcodesize ( channel ) } return size > 0 ; }
function disableController ( ) external isEnabled ( "disableControllerAllowed" ) onlyOwner { require ( ! controllerDisabled ) ; controllerDisabled = true ; delete controller ; emit DisableController ( now ) ; }
function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; require ( finalizedTime == 0 ) ; require ( getBlockTimestamp ( ) >= startTime ) ; require ( msg . sender == controller || getBlockTimestamp ( ) > endTime || weiToCollect ( ) == 0 ) ; aix . generateTokens ( remainderHolder , weiToCollect ( ) . mul ( 2000 ) ) ; uint256 tokenCap = aix . totalSupply ( ) . mul ( 100 ) . div ( 51 ) ; aix . generateTokens ( devHolder , tokenCap . mul ( 20 ) . div ( 100 ) ) ; aix . generateTokens ( communityHolder , tokenCap . mul ( 29 ) . div ( 100 ) ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = getBlockTimestamp ( ) ; Finalized ( finalizedBlock ) ; }
function disableController ( ) external ;
function synthetixReceivedForEther ( uint amount ) public view returns ( uint ) { uint valueSentInSynths = amount . multiplyDecimal ( usdToEthPrice ) ; return synthetixReceivedForSynths ( valueSentInSynths ) ; }
function onContribution ( address , uint256 _tierIndex , uint256 _tokens , uint256 _bonus ) public onlyCrowdsale ( ) { strategy . updateTierState ( _tierIndex , _tokens , _bonus ) ; }
function refoundTokens ( uint index , address receiver , address sc ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( isAirDropUnique ( index , receiver , sc ) == true ) { airdrop . tokenSC . transfer ( airdrop . distributor , airdrop . tokenAmount ) ; } else revert ( ) ; }
function updateWallet ( address _wallet ) external onlyContractOwner returns ( uint ) { require ( _wallet != 0x0 ) ; wallet = _wallet ; return OK ; }
function withdrawToRegisteredWallet ( ) external { require ( registered_wallet != 0x0 , "No wallet is registered" ) ; registered_wallet . transfer ( address ( this ) . balance ) ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { Approval ( msg . sender , _spender , _value ) ; allowed [ msg . sender ] [ _spender ] = _value ; return true ; }
function changeAssetPackPrice ( uint _assetPackId , uint _newPrice ) public { require ( assetPacks [ _assetPackId ] . creator == msg . sender ) ; assetPacks [ _assetPackId ] . price = _newPrice ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { return ownedTokens [ _owner ] ; }
function isAllowedTrade ( address who ) public view returns ( bool ) { return tradingWhitelist [ who ] ; }
function transferFrom ( address _from , address _to , uint _value ) public notPaused { super . transferFrom ( _from , _to , _value ) ; }
function verifyWithdrawSignature ( address _trader , bytes _signature ) external onlyBalancesContract returns ( bool ) { bytes memory data = abi . encodePacked ( "Republic Protocol: withdraw: " , _trader , traderNonces [ _trader ] ) ; address signer = Utils . addr ( data , _signature ) ; if ( brokers [ signer ] ) { traderNonces [ _trader ] += 1 ; return true ; } return false ; }
function ethRetrieve ( ) onlyAdmin ( 2 ) public { creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( address ( 0 ) , address ( this ) , mintedAmount ) ; emit Transfer ( address ( this ) , target , mintedAmount ) ; }
function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x48664c16 ) , _token , _to , _value , _fee , _nonce ) ) ; }
function balanceOf ( address add ) constant returns ( uint balance ) { return balances [ add ] ; }
function getPaintedPixelsCountByAddress ( address _address , uint32 _canvasId ) public view returns ( uint32 ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; return canvas . addressToCount [ _address ] ; }
function identityExists ( uint ein ) public view returns ( bool ) { return ein < nextEIN && ein > 0 ; }
function disableTransfers ( ) public onlyWhitelisted { require ( transfersEnabled ) ; transfersEnabled = false ; }
function getModule ( address _acct ) external view returns ( bool ) { return modules [ _acct ] ; }
function tokensOf ( address owner ) public view returns ( uint256 [ ] ) ;
function setRatePrices ( uint256 newRate ) onlyAuthorized public { baseRate = newRate ; }
function cumulative ( uint256 euroUlps ) public constant returns ( uint256 neumarkUlps ) { if ( euroUlps >= ISSUANCE_LIMIT_EUR_ULPS ) { return NEUMARK_CAP ; } if ( euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS ) { return NEUMARKS_AT_LINEAR_LIMIT_ULPS + ( TOT_LINEAR_NEUMARKS_ULPS * ( euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS ) ) / TOT_LINEAR_EUR_ULPS ; } uint256 d = 230769230769230769230769231 ; uint256 term = NEUMARK_CAP ; uint256 sum = 0 ; uint256 denom = d ; do assembly { term := div ( mul ( term , euroUlps ) , denom ) sum := add ( sum , term ) denom := add ( denom , d ) term := div ( mul ( term , euroUlps ) , denom ) sum := sub ( sum , term ) denom := add ( denom , d ) } while ( term != 0 ) ; return sum ; }
function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length - 1 ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; idToOwnerIndex [ _tokenId ] = 0 ; }
function buyTokens ( ) public stopInEmergency payable returns ( bool ) { if ( msg . value == 0 ) { error ( 'buyTokens: ZeroPurchase' ) ; return false ; } uint256 tokenAmount = buyTokensLowLevel ( msg . sender , msg . value ) ; if ( ! SCRefundVault . deposit . value ( msg . value ) ( msg . sender , tokenAmount ) ) { revert ( 'buyTokens: unable to transfer collected funds from ICO contract to Refund Vault' ) ; } emit BuyTokens ( msg . sender , msg . value , tokenAmount ) ; return true ; }
function requestVotingRights ( uint _numTokens ) external { require ( token . balanceOf ( msg . sender ) >= _numTokens ) ; require ( token . transferFrom ( msg . sender , this , _numTokens ) ) ; voteTokenBalance [ msg . sender ] += _numTokens ; VotingRightsGranted ( msg . sender , _numTokens ) ; }
function withdraw ( ) public ownerOnly { owner . transfer ( address ( this ) . balance ) ; }
function attestForUser ( address _subject , address _attester , address _requester , uint256 _reward , bytes _requesterSig , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig ) private { validateSubjectSig ( _subject , _dataHash , _requestNonce , _subjectSig ) ; emit TraitAttested ( _subject , _attester , _requester , _dataHash ) ; if ( _reward > 0 ) { tokenEscrowMarketplace . requestTokenPayment ( _requester , _attester , _reward , _requestNonce , _requesterSig ) ; } }
function executeOrders ( address [ ] tokenAddresses , bool [ ] buyOrSell , uint256 [ ] amountToObtain , uint256 [ ] amountToGive , address [ ] tokenForOrder , address [ ] exchanges , address [ 8 ] [ ] orderAddresses , uint256 [ 6 ] [ ] orderValues , uint256 [ ] exchangeFees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s , uint256 uniqueID ) public payable { require ( tokenAddresses . length == buyOrSell . length && buyOrSell . length == amountToObtain . length && amountToObtain . length == amountToGive . length , "TotlePrimary - trade length check failed" ) ; require ( tokenForOrder . length == exchanges . length && exchanges . length == orderAddresses . length && orderAddresses . length == orderValues . length && orderValues . length == exchangeFees . length && exchangeFees . length == v . length && v . length == r . length && r . length == s . length , "TotlePrimary - order length check failed" ) ; internalOrderExecution ( Tokens ( tokenAddresses , buyOrSell , amountToObtain , amountToGive ) , DEXOrders ( tokenForOrder , exchanges , orderAddresses , orderValues , exchangeFees , v , r , s ) ) ; }
function changeController ( address _newController ) public onlyController { controller = _newController ; }
function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) { return true ; }
function cancelAuction ( uint _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenId , seller ) ; }
function proxyPayment ( address _owner ) payable notPaused returns ( bool success ) { return doPayment ( _owner ) ; }
function addOracles ( address [ ] _whitelist ) onlyContractOwner external returns ( uint ) { for ( uint _idx = 0 ; _idx < _whitelist . length ; ++ _idx ) { address _oracle = _whitelist [ _idx ] ; if ( _oracle != 0x0 && ! oracles [ _oracle ] ) { oracles [ _oracle ] = true ; _emitOracleAdded ( _oracle ) ; } } return OK ; }
function freezeAccount ( address target , bool freeze ) onlyOwner public { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( balances [ msg . sender ] >= _value && _value > 0 ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function donate ( uint64 giverId , uint64 receiverId , address token , uint _amount ) whenNotPaused payable public { require ( giverId != 0 ) ; require ( receiverId != 0 ) ; uint amount = _receiveDonation ( token , _amount ) ; emit Donate ( giverId , receiverId , token , amount ) ; }
function removeMinter ( address _who ) public onlyValidator { _removeMinter ( _who ) ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function getInt ( bytes32 _key ) public view returns ( int _value ) { return intStorage [ _key ] ; }
function changeExpiryLimit ( uint256 _newExpiry ) public onlyOwner { require ( _newExpiry >= 1 days , "Expiry should greater than or equal to 1 day" ) ; uint256 _oldExpiry = expiryLimit ; expiryLimit = _newExpiry ; emit LogChangeExpiryLimit ( _oldExpiry , _newExpiry ) ; }
function buyout ( uint256 _gameIndex , bool startNewGameIfIdle , uint256 x , uint256 y ) public payable { _processGameEnd ( ) ; if ( ! gameStates [ gameIndex ] . gameStarted ) { require ( ! paused ) ; if ( allowStart ) { allowStart = false ; } else { require ( canStart ( ) ) ; } require ( startNewGameIfIdle ) ; _setGameSettings ( ) ; gameStates [ gameIndex ] . gameStarted = true ; gameStates [ gameIndex ] . gameStartTimestamp = block . timestamp ; gameStates [ gameIndex ] . penultimateTileTimeout = block . timestamp + gameSettings . initialActivityTimer ; Start ( gameIndex , msg . sender , block . timestamp , gameStates [ gameIndex ] . prizePool ) ; PenultimateTileTimeout ( gameIndex , gameStates [ gameIndex ] . penultimateTileTimeout ) ; } if ( startNewGameIfIdle ) { require ( _gameIndex == gameIndex || _gameIndex . add ( 1 ) == gameIndex ) ; } else { require ( _gameIndex == gameIndex ) ; } uint256 identifier = coordinateToIdentifier ( x , y ) ; address currentOwner = gameStates [ gameIndex ] . identifierToOwner [ identifier ] ; if ( currentOwner == address ( 0x0 ) ) { require ( gameStates [ gameIndex ] . gameStartTimestamp . add ( gameSettings . initialActivityTimer ) >= block . timestamp ) ; } else { require ( gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ identifier ] >= block . timestamp ) ; } uint256 price = currentPrice ( identifier ) ; require ( msg . value >= price ) ; uint256 [ ] memory claimedSurroundingTiles = _claimedSurroundingTiles ( identifier ) ; _calculateAndAssignBuyoutProceeds ( currentOwner , price , claimedSurroundingTiles ) ; uint256 timeout = tileTimeoutTimestamp ( identifier , msg . sender ) ; gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ identifier ] = timeout ; if ( gameStates [ gameIndex ] . lastTile == 0 || timeout >= gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ gameStates [ gameIndex ] . lastTile ] ) { if ( gameStates [ gameIndex ] . lastTile != identifier ) { if ( gameStates [ gameIndex ] . lastTile != 0 ) { gameStates [ gameIndex ] . penultimateTileTimeout = gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ gameStates [ gameIndex ] . lastTile ] ; PenultimateTileTimeout ( gameIndex , gameStates [ gameIndex ] . penultimateTileTimeout ) ; } gameStates [ gameIndex ] . lastTile = identifier ; LastTile ( gameIndex , identifier , x , y ) ; } } else if ( timeout > gameStates [ gameIndex ] . penultimateTileTimeout ) { gameStates [ gameIndex ] . penultimateTileTimeout = timeout ; PenultimateTileTimeout ( gameIndex , timeout ) ; } _transfer ( currentOwner , msg . sender , identifier ) ; gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] = nextBuyoutPrice ( price ) ; gameStates [ gameIndex ] . numberOfTileFlips ++ ; Buyout ( gameIndex , msg . sender , identifier , x , y , block . timestamp , timeout , gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] , gameStates [ gameIndex ] . prizePool ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function setHodlerStake ( address _beneficiary , uint256 _stake ) public onlyOwner beforeHodlStart { if ( hodlerStakes [ _beneficiary ] . stake == _stake || _beneficiary == address ( 0 ) ) return ; if ( hodlerStakes [ _beneficiary ] . stake == 0 && _stake > 0 ) { hodlerTotalCount = hodlerTotalCount . add ( 1 ) ; } else if ( hodlerStakes [ _beneficiary ] . stake > 0 && _stake == 0 ) { hodlerTotalCount = hodlerTotalCount . sub ( 1 ) ; } uint256 _diff = _stake > hodlerStakes [ _beneficiary ] . stake ? _stake . sub ( hodlerStakes [ _beneficiary ] . stake ) : hodlerStakes [ _beneficiary ] . stake . sub ( _stake ) ; if ( _stake > hodlerStakes [ _beneficiary ] . stake ) { hodlerTotalValue = hodlerTotalValue . add ( _diff ) ; } else { hodlerTotalValue = hodlerTotalValue . sub ( _diff ) ; } hodlerStakes [ _beneficiary ] . stake = _stake ; LogHodlSetStake ( msg . sender , _beneficiary , _stake ) ; }
function setParams ( string _name , string _symbol , string _tla , string _version , uint _decimals , address _feeContract , uint _fxUSDBPSRate ) onlyOwner public returns ( bool success ) { require ( lib . setTokenName ( _name ) , "Error: Unable to set token name. Please check arguments." ) ; require ( lib . setTokenSymbol ( _symbol ) , "Error: Unable to set token symbol. Please check arguments." ) ; require ( lib . setTokenTLA ( _tla ) , "Error: Unable to set token TLA. Please check arguments." ) ; require ( lib . setTokenVersion ( _version ) , "Error: Unable to set token version. Please check arguments." ) ; require ( lib . setTokenDecimals ( _symbol , _decimals ) , "Error: Unable to set token decimals. Please check arguments." ) ; require ( lib . setFeeContract ( _feeContract ) , "Error: Unable to set fee contract. Please check arguments." ) ; require ( lib . setFxUSDBPSRate ( _symbol , _fxUSDBPSRate ) , "Error: Unable to set fx USD basis points rate. Please check arguments." ) ; return true ; }
function freezeAccount ( address target , bool freeze ) onlyOwner public { _frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }
function onTransfer ( address , address , uint256 ) returns ( bool ) { return transferable ; }
function setSellFee ( uint32 _sellFeeMilliPercent ) onlyOwner public { require ( _sellFeeMilliPercent < MILLI_PERCENT_DIVIDER ) ; sellFeeMilliPercent = _sellFeeMilliPercent ; }
function registerHolder ( bytes32 _externalHolderId , address _holderAddress , uint _countryCode ) onlyOracleOrOwner external returns ( uint ) { require ( _holderAddress != 0x0 ) ; require ( holderIndex [ _externalHolderId ] == 0 ) ; uint _holderIndex = holderIndex [ holderAddress2Id [ _holderAddress ] ] ; require ( _holderIndex == 0 ) ; _createCountryId ( _countryCode ) ; _holderIndex = holdersCount . add ( 1 ) ; holdersCount = _holderIndex ; HoldersData storage _holderData = holders [ _holderIndex ] ; _holderData . countryCode = _countryCode ; _holderData . operational = true ; _holderData . sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER ; _holderData . sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER ; uint _firstAddressIndex = 1 ; _holderData . holderAddressCount = _firstAddressIndex ; _holderData . address2Index [ _holderAddress ] = _firstAddressIndex ; _holderData . index2Address [ _firstAddressIndex ] = _holderAddress ; holderIndex [ _externalHolderId ] = _holderIndex ; holderAddress2Id [ _holderAddress ] = _externalHolderId ; _emitHolderRegistered ( _externalHolderId , _holderIndex , _countryCode ) ; return OK ; }
function onERC721Received ( address , address , uint256 _tokenId , bytes ) external returns ( bytes4 ) { if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) { flagReceiveLand = 0 ; return ERC721_RECEIVED ; } }
function getEmoji ( uint256 _tokenId ) public view returns ( string emojiName , string emojiMsg , uint256 sellingPrice , address owner ) { Emoji storage emojiObj = emojis [ _tokenId ] ; emojiName = emojiObj . name ; emojiMsg = emojiObj . msg ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; }
function closeCurrentFeePeriod ( ) external onlyFeeAuthority { require ( recentFeePeriods [ 0 ] . startTime <= ( now - feePeriodDuration ) , "It is too early to close the current fee period" ) ; FeePeriod memory secondLastFeePeriod = recentFeePeriods [ FEE_PERIOD_LENGTH - 2 ] ; FeePeriod memory lastFeePeriod = recentFeePeriods [ FEE_PERIOD_LENGTH - 1 ] ; recentFeePeriods [ FEE_PERIOD_LENGTH - 2 ] . feesToDistribute = lastFeePeriod . feesToDistribute . sub ( lastFeePeriod . feesClaimed ) . add ( secondLastFeePeriod . feesToDistribute ) ; for ( uint i = FEE_PERIOD_LENGTH - 2 ; i < FEE_PERIOD_LENGTH ; i -- ) { uint next = i + 1 ; recentFeePeriods [ next ] . feePeriodId = recentFeePeriods [ i ] . feePeriodId ; recentFeePeriods [ next ] . startingDebtIndex = recentFeePeriods [ i ] . startingDebtIndex ; recentFeePeriods [ next ] . startTime = recentFeePeriods [ i ] . startTime ; recentFeePeriods [ next ] . feesToDistribute = recentFeePeriods [ i ] . feesToDistribute ; recentFeePeriods [ next ] . feesClaimed = recentFeePeriods [ i ] . feesClaimed ; } delete recentFeePeriods [ 0 ] ; recentFeePeriods [ 0 ] . feePeriodId = nextFeePeriodId ; recentFeePeriods [ 0 ] . startingDebtIndex = synthetix . synthetixState ( ) . debtLedgerLength ( ) ; recentFeePeriods [ 0 ] . startTime = now ; nextFeePeriodId = nextFeePeriodId . add ( 1 ) ; emitFeePeriodClosed ( recentFeePeriods [ 1 ] . feePeriodId ) ; }
function requestMortgage ( uint256 [ 6 ] loanParams , string metadata , uint256 landId , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { uint256 loanId = createLoan ( loanParams , metadata ) ; require ( nanoLoanEngine . registerApprove ( nanoLoanEngine . getIdentifier ( loanId ) , v , r , s ) , "Signature not valid" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 requiredDeposit = ( ( landCost * requiredTotal ) / 100 ) - nanoLoanEngine . getAmount ( loanId ) ; _tokenTransferFrom ( mana , msg . sender , this , requiredDeposit ) ; require ( mana . approve ( mortgageManager , requiredDeposit ) ) ; uint256 mortgageId = mortgageManager . requestMortgageId ( Engine ( nanoLoanEngine ) , loanId , requiredDeposit , landId , tokenConverter ) ; emit NewMortgage ( msg . sender , loanId , landId , mortgageId ) ; return mortgageId ; }
function deploySTO ( address _securityToken , address _polyAddress , address _factoryAddress ) external returns ( address ) { address newSecurityTokenAddress = new USDTieredSTO ( _securityToken , _polyAddress , _factoryAddress ) ; return newSecurityTokenAddress ; }
function invalidateAttributeApproval ( bytes32 hash , bytes signature ) external { address validator = _signingKeys [ hash . toEthSignedMessageHash ( ) . recover ( signature ) ] ; require ( msg . sender == validator || msg . sender == owner ( ) , "only jurisdiction or issuing validator may invalidate attribute approval" ) ; _invalidAttributeApprovalHashes [ hash ] = true ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalWarriors = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 warriorId ; for ( warriorId = 0 ; warriorId < totalWarriors ; warriorId ++ ) { if ( warriorToOwner [ warriorId ] == _owner ) { result [ resultIndex ] = warriorId ; resultIndex ++ ; } } return result ; } }
function withdrawTokens ( ) external whenNotPaused onlyAdmin { IERC20 t = super . token ( ) ; t . safeTransfer ( msg . sender , t . balanceOf ( this ) ) ; }
function calculateExcessTokens ( uint256 amount , uint256 tokensThisTier , uint256 tierSelected , uint256 _rate ) public returns ( uint256 totalTokens ) { require ( amount > 0 && tokensThisTier > 0 && _rate > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; uint weiThisTier = tokensThisTier . sub ( tokensRaised ) . div ( _rate ) ; uint weiNextTier = amount . sub ( weiThisTier ) ; uint tokensNextTier = 0 ; bool returnTokens = false ; if ( tierSelected != 4 ) tokensNextTier = calculateTokensTier ( weiNextTier , tierSelected . add ( 1 ) ) ; else returnTokens = true ; totalTokens = tokensThisTier . sub ( tokensRaised ) . add ( tokensNextTier ) ; if ( returnTokens ) msg . sender . transfer ( weiNextTier ) ; }
function ( ) external payable { buyTokens ( msg . sender ) ; }
function fulfill ( Deliverable storage self , address _creator , address _brand ) internal returns ( bool ) { require ( msg . sender == _creator || msg . sender == _brand ) ; self . fulfillment [ msg . sender ] = true ; return self . fulfillment [ _creator ] && self . fulfillment [ _brand ] ; }
function transferTokens ( address _recipient ) public { require ( beneficiaries [ _recipient ] . amountClaimed < beneficiaries [ _recipient ] . totalAllocated ) ; require ( now >= beneficiaries [ _recipient ] . cliff ) ; require ( ! beneficiaries [ _recipient ] . disable ) ; uint256 unreleased = releasableAmount ( _recipient ) ; require ( unreleased > 0 ) ; IOV . transfer ( _recipient , unreleased ) ; beneficiaries [ _recipient ] . amountClaimed = vestedAmount ( _recipient ) ; emit LogIOVClaimed ( _recipient , unreleased ) ; }
function approve ( address _spender , uint256 _value ) notPendingWithdrawal returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }
function finalizeFunding ( ) { require ( now >= endFundingTime ) ; tokenContract . changeController ( 0 ) ; }
function commitVotes ( uint [ ] _pollIDs , bytes32 [ ] _secretHashes , uint [ ] _numsTokens , uint [ ] _prevPollIDs ) external { require ( _pollIDs . length == _secretHashes . length ) ; require ( _pollIDs . length == _numsTokens . length ) ; require ( _pollIDs . length == _prevPollIDs . length ) ; for ( uint i = 0 ; i < _pollIDs . length ; i ++ ) { commitVote ( _pollIDs [ i ] , _secretHashes [ i ] , _numsTokens [ i ] , _prevPollIDs [ i ] ) ; } }
function burnAllTokens ( address _address ) external returns ( bool success ) { require ( msg . sender == crowdsaleAddress ) ; uint256 amount = balanceOf [ _address ] ; balanceOf [ _address ] = 0 ; totalSupply = totalSupply . sub ( amount ) ; Burn ( _address , amount , totalSupply ) ; success = true ; }
function refundIgnoredBids ( uint _count ) public onlyOwner { require ( status == state . success || status == state . failure ) ; uint count = _count ; if ( bids_ignored_count < bids_ignored_refunded . add ( count ) ) { count = bids_ignored_count . sub ( bids_ignored_refunded ) ; } require ( count > 0 ) ; uint cursor = bids_ignored_refunded ; bids_ignored_refunded = bids_ignored_refunded . add ( count ) ; BidData storage bid ; while ( count > 0 ) { bid = bids_ignored [ cursor ] ; if ( bid . closed ) { continue ; } bid . closed = true ; art_token_contract . transfer ( bid . investor_address , bid . transfer_token ) ; emit Refunded ( bid . origin_index , bid . transfer_token ) ; cursor ++ ; count -- ; } }
function setShareHolders ( bool _valid , uint _from , uint _to ) ;
function applyAffiliate ( address _investor , uint256 _contributorTokens , uint256 _contributionValue ) public returns ( uint256 , uint256 ) { if ( getAffiliate ( _investor ) == address ( 0 ) ) { return ( 0 , 0 ) ; } uint256 contributorBonus = _contributorTokens . div ( 100 ) ; uint256 affiliateBonus = 0 ; if ( _contributionValue < tierTwoMin ) { affiliateBonus = _contributorTokens . mul ( TIER1_PERCENT ) . div ( 100 ) ; } else if ( _contributionValue >= tierTwoMin && _contributionValue < tierThreeMin ) { affiliateBonus = _contributorTokens . mul ( TIER2_PERCENT ) . div ( 100 ) ; } else { affiliateBonus = _contributorTokens . mul ( TIER3_PERCENT ) . div ( 100 ) ; } return ( affiliateBonus , contributorBonus ) ; }
function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , "ERC777TokensRecipient" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( throwOnIncompatibleContract && _preventLocking ) { require ( isRegularAddress ( _to ) ) ; } }
function readBytes32 ( bytes data , uint256 index ) internal pure returns ( bytes32 o ) { if ( data . length / 32 > index ) { assembly { o := mload ( add ( data , add ( 32 , mul ( 32 , index ) ) ) ) } } }
function getCovfefe ( uint _tokenId ) public view returns ( string Term , string Meaning , uint Generation , uint ReadyTime , uint WinCount , uint LossCount , uint CurrentPrice , uint LastPrice , address Owner ) { Covfefe storage covfefe = covfefes [ _tokenId ] ; Term = covfefe . term ; Meaning = covfefe . meaning ; Generation = covfefe . generation ; ReadyTime = covfefe . saleReadyTime ; WinCount = covfefe . winCount ; LossCount = covfefe . lossCount ; CurrentPrice = covfefeIndexToPrice [ _tokenId ] ; LastPrice = covfefeIndexToLastPrice [ _tokenId ] ; Owner = covfefeIndexToOwner [ _tokenId ] ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ;
function executePayment ( uint256 _paymentId ) external authP ( EXECUTE_PAYMENTS_ROLE , arr ( _paymentId , payments [ _paymentId ] . amount ) ) paymentExists ( _paymentId ) transitionsPeriod { require ( nextPaymentTime ( _paymentId ) <= getTimestamp64 ( ) , ERROR_EXECUTE_PAYMENT_TIME ) ; _executePayment ( _paymentId ) ; }
function mint ( address _to , uint256 _amount ) public requiresPermission whenNotPaused { _mint ( _to , _amount ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable mustBeValidToken ( _tokenId ) canTransfer ( _tokenId ) { address owner = _tokenOwnerWithSubstitutions [ _tokenId ] ; if ( owner == address ( 0 ) ) { owner = address ( this ) ; } require ( owner == _from ) ; require ( _to != address ( 0 ) ) ; _transfer ( _tokenId , _to ) ; }
function releaseApprove ( bytes32 sha , uint8 v , bytes32 r , bytes32 s ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; bytes32 approveSha = keccak256 ( "approve" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; bytes32 increaseApprovalSha = keccak256 ( "increaseApproval" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; bytes32 decreaseApprovalSha = keccak256 ( "decreaseApproval" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; require ( approveSha == sha || increaseApprovalSha == sha || decreaseApprovalSha == sha ) ; require ( verify ( sha , v , r , s ) == true ) ; super . approve ( biometricTo [ sha ] , biometricAmount [ sha ] ) ; biometricCompleted [ sha ] = true ; return true ; }
function _addToDebtRegister ( address account , uint amount ) internal { Synthetix synthetix = Synthetix ( associatedContract ) ; uint xdrValue = synthetix . effectiveValue ( "sUSD" , amount , "XDR" ) ; uint totalDebtIssued = importedXDRAmount ; uint newTotalDebtIssued = xdrValue . add ( totalDebtIssued ) ; importedXDRAmount = newTotalDebtIssued ; uint debtPercentage = xdrValue . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . sub ( debtPercentage ) ; uint existingDebt = synthetix . debtBalanceOf ( account , "XDR" ) ; if ( existingDebt > 0 ) { debtPercentage = xdrValue . add ( existingDebt ) . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; } if ( issuanceData [ account ] . initialDebtOwnership == 0 ) { totalIssuerCount = totalIssuerCount . add ( 1 ) ; } issuanceData [ account ] . initialDebtOwnership = debtPercentage ; issuanceData [ account ] . debtEntryIndex = debtLedger . length ; if ( debtLedger . length > 0 ) { debtLedger . push ( debtLedger [ debtLedger . length - 1 ] . multiplyDecimalRoundPrecise ( delta ) ) ; } else { debtLedger . push ( SafeDecimalMath . preciseUnit ( ) ) ; } }
function transfer ( address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; require ( lib . forceTransfer ( currency , msg . sender , to , amount , "0x0" ) , "Error: Unable to transfer funds to account." ) ; require ( lib . forceTransfer ( currency , msg . sender , feeContract , calculateFees ( amount ) , lib . getFeeMsg ( feeContract ) ) , "Error: Unable to transfer fees to fee contract." ) ; emit Transfer ( msg . sender , to , amount ) ; return true ; }
function operatorSend ( address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData ) public { require ( isOperatorFor ( msg . sender , _from ) , "Not an operator" ) ; addWhitelistAddress ( _to ) ; doSend ( msg . sender , _from , _to , _amount , _data , _operatorData , true ) ; }
function performBuyOrder ( OrderData order , uint256 amountToGiveForOrder ) public payable onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { uint256 takeFee = exchange . takeFee ( ) ; amountSpentOnOrder = amountToGiveForOrder ; uint256 amountSpentMinusFee = SafeMath . sub ( amountSpentOnOrder , exchange . feeFromTotalCostForAccount ( amountSpentOnOrder , takeFee , address ( this ) ) ) ; amountReceivedFromOrder = SafeMath . div ( SafeMath . mul ( amountSpentMinusFee , order . tokenAmount ) , order . weiAmount ) ; exchange . takeSellOrder . value ( amountToGiveForOrder ) ( order . token , order . tokenAmount , order . weiAmount , order . maker ) ; if ( ! ERC20SafeTransfer . safeTransfer ( order . token , totlePrimary , amountReceivedFromOrder ) ) { errorReporter . revertTx ( "Unable to transfer bought tokens to primary" ) ; } }
function vote ( uint _idPoll , uint [ ] _ballots ) public { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll storage p = _polls [ _idPoll ] ; require ( block . number >= p . startBlock && block . timestamp < p . endTime && ! p . canceled , "Poll is inactive" ) ; require ( _ballots . length == p . numBallots , "Number of ballots is incorrect" ) ; unvote ( _idPoll ) ; uint amount = token . balanceOfAt ( msg . sender , p . startBlock ) ; require ( amount != 0 , "No SNT balance available at start block of poll" ) ; p . voters ++ ; uint totalBallots = 0 ; for ( uint8 i = 0 ; i < _ballots . length ; i ++ ) { totalBallots += _ballots [ i ] ; p . ballots [ i ] [ msg . sender ] = _ballots [ i ] ; if ( _ballots [ i ] != 0 ) { p . qvResults [ i ] += sqrt ( _ballots [ i ] / 1 ether ) ; p . results [ i ] += _ballots [ i ] ; p . votersByBallot [ i ] ++ ; } } require ( totalBallots <= amount , "Total ballots must be less than the SNT balance at poll start block" ) ; emit Vote ( _idPoll , msg . sender , _ballots ) ; }
function setQuestionFee ( uint256 fee ) stateAny ( ) external { arbitrator_question_fees [ msg . sender ] = fee ; emit LogSetQuestionFee ( msg . sender , fee ) ; }
function callPlugins ( bool before , uint64 fromPledge , uint64 toPledge , uint amount ) internal returns ( uint allowedAmount ) { allowedAmount = amount ; allowedAmount = callPluginsPledge ( before , fromPledge , fromPledge , toPledge , allowedAmount ) ; allowedAmount = callPluginsPledge ( before , toPledge , fromPledge , toPledge , allowedAmount ) ; }
function balanceOf ( address _owner ) external constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function registerSecretBatch ( bytes32 [ ] secrets ) public returns ( bool ) { bool completeSuccess = true ; for ( uint i = 0 ; i < secrets . length ; i ++ ) { if ( ! registerSecret ( secrets [ i ] ) ) { completeSuccess = false ; } } return completeSuccess ; }
function feesAvailable ( address account , bytes4 currencyKey ) public view returns ( uint ) { uint [ FEE_PERIOD_LENGTH ] memory userFees = feesByPeriod ( account ) ; uint totalFees = 0 ; for ( uint i = 1 ; i < FEE_PERIOD_LENGTH ; i ++ ) { totalFees = totalFees . add ( userFees [ i ] ) ; } return synthetix . effectiveValue ( "XDR" , totalFees , currencyKey ) ; }
function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 12 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 24 ) ) ) { require ( collectedTokens < total . percent ( 40 ) ) ; canExtract = total . percent ( 40 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 24 ) ) && getTime ( ) <= finalizedTime . add ( months ( 36 ) ) ) { require ( collectedTokens < total . percent ( 80 ) ) ; canExtract = total . percent ( 80 ) ; } else { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }
function transferToContract ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; WeBetCrypto rec = WeBetCrypto ( _to ) ; rec . tokenFallback ( msg . sender , _value , _data ) ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function addRestrictedAttributeType ( uint256 ID , string description ) external onlyOwner whenNotPaused { require ( ! isAttributeType ( ID ) , "an attribute type with the provided ID already exists" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( ID , true , description ) ) ; if ( _attributeTypeHashes [ ID ] == bytes32 ( 0 ) ) { _attributeTypeHashes [ ID ] = hash ; } require ( hash == _attributeTypeHashes [ ID ] , "attribute type properties must match initial properties assigned to ID" ) ; _attributeTypes [ ID ] = AttributeType ( { exists : true , restricted : true , onlyPersonal : false , index : _attributeIDs . length , secondarySource : address ( 0 ) , secondaryAttributeTypeID : uint256 ( 0 ) , minimumStake : uint256 ( 0 ) , jurisdictionFee : uint256 ( 0 ) , description : description } ) ; _attributeIDs . push ( ID ) ; emit AttributeTypeAdded ( ID , description ) ; }
function setItemForSale ( uint256 _id , uint256 _price ) external onlyOwnerOfItem ( _id ) itemIsNotForSale ( _id ) { Item storage item = items [ _id ] ; item . forSale = true ; item . price = _price ; itemsForSaleCount ++ ; }
function abort ( ) public returns ( bool ) ;
function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) , "Invalid address" ) ; IERC20 token = IERC20 ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( owner , balance ) , "Transfer failed" ) ; }
function setEnd ( ) external onlyAdmin checkState ( pointsValidationState . WinnersAssigned ) { uint256 balance = address ( this ) . balance ; adminPool = balance . mul ( 10 ) . div ( 100 ) ; prizePool = balance . mul ( 90 ) . div ( 100 ) ; pValidationState = pointsValidationState . Finished ; gameFinishedTime = now ; unSetPause ( ) ; }
function setupEventsHistory ( address _eventsHistory ) external onlyContractOwner returns ( uint errorCode ) { eventsHistory = _eventsHistory ; return OK ; }
function deposit ( address _token , uint256 _value ) external payable isInitialized { _deposit ( _token , _value ) ; }
function withdraw ( address _user , uint256 _value ) public onlyOwnerOrAllowed ;
function updateTokenDetails ( string _newTokenDetails ) external onlyOwner { emit UpdateTokenDetails ( tokenDetails , _newTokenDetails ) ; tokenDetails = _newTokenDetails ; }
function setRegisteredFirm ( Data storage self , string issuerFirm , bool approved ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.firm' , issuerFirm ) ) ; require ( self . Storage . setBool ( id , approved ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; return true ; }
function baseUnit ( bytes32 _symbol ) public view returns ( uint8 ) { return get ( store , assetBaseUnit , _symbol ) ; }
function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool _transferredFrom ) { require ( ! tokenTransfersFrozen ) ; require ( allowance [ _owner ] [ msg . sender ] . sub ( _amount ) >= 0 ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; allowance [ _owner ] [ _receiver ] = allowance [ _owner ] [ _receiver ] . sub ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }
function enableTransfers ( bool _transfersEnabled ) public onlyController { transfersEnabled = _transfersEnabled ; }
function issueForEuro ( uint256 euroUlps ) public only ( ROLE_NEUMARK_ISSUER ) acceptAgreement ( msg . sender ) returns ( uint256 ) { require ( _totalEurUlps + euroUlps >= _totalEurUlps ) ; uint256 neumarkUlps = incremental ( _totalEurUlps , euroUlps ) ; _totalEurUlps += euroUlps ; mGenerateTokens ( msg . sender , neumarkUlps ) ; LogNeumarksIssued ( msg . sender , euroUlps , neumarkUlps ) ; return neumarkUlps ; }
function depositERC20 ( address _user , address _token , uint256 _amount ) external onlyCoordinator onlyActiveState { require ( _amount > 0 , 'Invalid value' ) ; balances [ _user ] [ _token ] = balances [ _user ] [ _token ] . add ( _amount ) ; ERC20 ( _token ) . transferFrom ( _user , address ( this ) , _amount ) ; require ( _getSanitizedReturnValue ( ) , "transferFrom failed." ) ; emit BalanceIncrease ( _user , _token , _amount , ReasonDeposit ) ; }
function getString ( bytes32 _key ) public view returns ( string _value ) { return stringStorage [ _key ] ; }
function generateTokens ( address _owner , uint256 _amount ) onlyController returns ( bool ) { uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
function unpause ( ) public onlyowner { hault = false ; }
function changeController ( address _newController ) public onlyOwner { token . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyCallers public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }
function transferFrom ( address _from , address _to , uint _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; _transItem ( _from , _to , _tokenId ) ; }
function settleGame ( uint256 _gameID , uint256 _team , string _comment , uint256 _deadline ) external isActivated ( _gameID ) isOngoing ( _gameID ) isValidTeam ( _gameID , _team ) isOwner ( ) { require ( _deadline >= now + 86400 , "deadline must be more than one day later." ) ; game_ [ _gameID ] . ended = true ; game_ [ _gameID ] . winnerTeam = _team ; game_ [ _gameID ] . gameEndComment = _comment ; game_ [ _gameID ] . withdrawDeadline = _deadline ; if ( teams_ [ _gameID ] [ _team ] . keys == 0 ) { uint256 _totalPot = ( gameStatus_ [ _gameID ] . winningVaultInst ) . add ( gameStatus_ [ _gameID ] . winningVaultFinal ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalPot ; if ( _totalPot > 0 ) { FSKingCorp . deposit . value ( _totalPot ) ( ) ; } } emit FSEvents . onGameEnded ( _gameID , _team , _comment , now ) ; }
function migrationSetPlayer ( bytes32 boardHash , uint playerID , bytes32 playerName , address playerAddress , uint score , uint score_unconfirmed , uint isActive ) isOwner public returns ( bool ) { Board storage g = boards [ boardHash ] ; g . players [ playerID ] = Player ( playerName , playerAddress , score , score_unconfirmed , isActive ) ; return true ; }
function getCEOHashing ( address _newCEO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E94 ) , _newCEO , _nonce ) ) ; }
function withdrawToken ( address _token ) external onlyAdmin { bool isVRH = _token == address ( token ) ; ERC20 erc20 = ERC20 ( _token ) ; uint256 balance = erc20 . balanceOf ( this ) ; if ( isVRH ) { balance = balance . sub ( getRemainingBonus ( ) ) ; changeClosingTime ( now ) ; } require ( erc20 . transfer ( msg . sender , balance ) ) ; emit ERC20Withdrawn ( _token , balance ) ; }
function getPriceVolume ( uint _price ) public constant returns ( uint ) ;
function setParent ( uint256 identifier , uint256 parentIdentifier ) external onlyCFO { require ( identifierToOwner [ identifier ] != 0x0 ) ; identifierToParentIdentifier [ identifier ] = parentIdentifier ; }
function changeHolderPercentage ( uint256 _maxHolderPercentage ) public onlyOwner { emit LogModifyHolderPercentage ( maxHolderPercentage , _maxHolderPercentage ) ; maxHolderPercentage = _maxHolderPercentage ; }
function increaseApproval ( address _spender , uint256 _addedValue ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) ) ; return super . increaseApproval ( _spender , _addedValue ) ; }
function _safeTransfer ( address _to , uint _amount ) internal { require ( _to != 0 ) ; _to . transfer ( _amount ) ; }
function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { balance = TokenInfoController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_INFO ) ) . get_balance ( _owner ) ; }
function finalize ( ) public initialized { require ( getBlockNumber ( ) >= startBlock ) ; require ( msg . sender == owner || getBlockNumber ( ) > endBlock ) ; require ( finalizedBlock == 0 ) ; require ( dynamicCeiling . allRevealed ( ) ) ; if ( getBlockNumber ( ) <= endBlock ) { var ( , lastLimit , , ) = dynamicCeiling . curves ( dynamicCeiling . revealedCurves ( ) . sub ( 1 ) ) ; require ( totalNormalCollected >= lastLimit ) ; } finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; uint256 percentageToSgt ; if ( SGT . totalSupply ( ) >= maxSGTSupply ) { percentageToSgt = percent ( 10 ) ; } else { percentageToSgt = percent ( 10 ) . mul ( SGT . totalSupply ( ) ) . div ( maxSGTSupply ) ; } uint256 percentageToDevs = percent ( 20 ) ; uint256 percentageToContributors = percent ( 41 ) . add ( percent ( 10 ) . sub ( percentageToSgt ) ) ; uint256 percentageToReserve = percent ( 29 ) ; uint256 totalTokens = SNT . totalSupply ( ) . mul ( percent ( 100 ) ) . div ( percentageToContributors ) ; assert ( SNT . generateTokens ( destTokensReserve , totalTokens . mul ( percentageToReserve ) . div ( percent ( 100 ) ) ) ) ; assert ( SNT . generateTokens ( destTokensSgt , totalTokens . mul ( percentageToSgt ) . div ( percent ( 100 ) ) ) ) ; assert ( SNT . generateTokens ( destTokensDevs , totalTokens . mul ( percentageToDevs ) . div ( percent ( 100 ) ) ) ) ; SNT . changeController ( sntController ) ; Finalized ( ) ; }
function create ( uint256 baseUnits ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ + baseUnits ) > totalSupply_ ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 amount = baseUnits . div ( creationUnit_ ) . mul ( token . quantity ) ; require ( erc20 . transferFrom ( msg . sender , address ( this ) , amount ) ) ; } mint ( msg . sender , baseUnits ) ; }
function __callback ( bytes32 _requestId , string _result ) public { require ( msg . sender == oraclize_cbAddress ( ) , "Only Oraclize can access this method" ) ; require ( ! freezeOracle , "Oracle is frozen" ) ; require ( ! ignoreRequestIds [ _requestId ] , "Ignoring requestId" ) ; if ( requestIds [ _requestId ] < latestUpdate ) { emit LogStalePriceUpdate ( _requestId , requestIds [ _requestId ] , _result ) ; return ; } require ( requestIds [ _requestId ] >= latestUpdate , "Result is stale" ) ; require ( requestIds [ _requestId ] <= now + oraclizeTimeTolerance , "Result is early" ) ; uint256 newPOLYUSD = parseInt ( _result , 18 ) ; uint256 bound = POLYUSD . mul ( sanityBounds ) . div ( 10 ** 18 ) ; if ( latestUpdate != 0 ) { require ( newPOLYUSD <= POLYUSD . add ( bound ) , "Result is too large" ) ; require ( newPOLYUSD >= POLYUSD . sub ( bound ) , "Result is too small" ) ; } latestUpdate = requestIds [ _requestId ] ; emit LogPriceUpdated ( newPOLYUSD , POLYUSD , _requestId , latestUpdate ) ; POLYUSD = newPOLYUSD ; }
function ownerOf ( uint256 _tokenId ) external view mustBeValidToken ( _tokenId ) returns ( address _owner ) { _owner = _tokenOwnerWithSubstitutions [ _tokenId ] ; if ( _owner == address ( 0 ) ) { _owner = address ( this ) ; } }
function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 1 days ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 3 ) ) ) { require ( collectedTokens < total . percent ( 40 ) ) ; canExtract = total . percent ( 40 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 3 ) ) && getTime ( ) <= finalizedTime . add ( months ( 6 ) ) ) { require ( collectedTokens < total . percent ( 60 ) ) ; canExtract = total . percent ( 60 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 6 ) ) && getTime ( ) <= finalizedTime . add ( months ( 9 ) ) ) { require ( collectedTokens < total . percent ( 80 ) ) ; canExtract = total . percent ( 80 ) ; } else { require ( collectedTokens < total ) ; canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }
function tokenOfCreatorByIndex ( address _creator , uint256 _index ) public view validAddress ( _creator ) returns ( uint256 ) { require ( _index < createdTokens [ _creator ] . length , "Index is out of bounds" ) ; PixelCon storage pixelcon = pixelcons [ createdTokens [ _creator ] [ _index ] ] ; return pixelcon . tokenId ; }
function shutForDai ( uint _id ) public auth stoppable { bytes32 id = bytes32 ( _id ) ; uint debt = tub . tab ( id ) ; if ( debt > 0 ) { require ( dai . transferFrom ( msg . sender , this , debt ) ) ; } uint ink = tub . ink ( id ) ; tub . shut ( id ) ; uint gemBalance = tub . bid ( ink ) ; tub . exit ( ink ) ; uint price = uint ( feed . read ( ) ) ; uint bought = otc . sellAllAmount ( gem , min ( gemBalance , gem . balanceOf ( this ) ) , dai , wmul ( WAD - slippage , wmul ( gemBalance , price ) ) ) ; require ( dai . transfer ( msg . sender , bought ) ) ; }
function notifyOfArbitrationRequest ( bytes32 question_id , address requester , uint256 max_previous ) external { }
function transfer ( address _to , uint256 _amount ) onlyPayloadSize ( 2 * 32 ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; return doTransfer ( msg . sender , _to , _amount ) ; }
function changeController ( address _newController ) onlyController { controller = _newController ; }
function release ( address _sender , address _recipient , uint256 _transactionId , uint256 _exchangeRate ) public { Lock memory lock = escrows [ msg . sender ] [ _transactionId ] ; require ( lock . expiration != 1 ) ; require ( lock . sender == _sender ) ; require ( lock . recipient == _recipient || lock . sender == _recipient ) ; require ( lock . paid ) ; if ( lock . fee > 0 && lock . recipient == _recipient ) { token . transfer ( _recipient , lock . value ) ; token . transfer ( msg . sender , lock . fee ) ; } else { token . transfer ( _recipient , lock . value . add ( lock . fee ) ) ; } delete escrows [ msg . sender ] [ _transactionId ] ; token . issueExchangeRate ( _sender , _recipient , msg . sender , lock . value , _transactionId , _exchangeRate ) ; Released ( msg . sender , _recipient , _transactionId ) ; }
function claim ( ) public vaultUnlocked returns ( bool ) { return _transferTokens ( msg . sender ) ; }
function validateTranscriptHash ( address _student , uint _docIndx , bytes32 _transcriptHash ) public view returns ( bool ) { Certification storage certification = studentCertifications [ _student ] ; return ( certification . documents [ _docIndx ] ) . validateTranscriptHash ( _transcriptHash ) ; }
function getLocksLength ( ) external view returns ( uint ) { return locks . length ; }
function changeModuleBudget ( address _module , uint256 _change , bool _increase ) external onlyOwner { require ( modulesToData [ _module ] . module != address ( 0 ) , "Module missing" ) ; uint256 currentAllowance = IERC20 ( polyToken ) . allowance ( address ( this ) , _module ) ; uint256 newAllowance ; if ( _increase ) { require ( IERC20 ( polyToken ) . increaseApproval ( _module , _change ) , "IncreaseApproval fail" ) ; newAllowance = currentAllowance . add ( _change ) ; } else { require ( IERC20 ( polyToken ) . decreaseApproval ( _module , _change ) , "Insufficient allowance" ) ; newAllowance = currentAllowance . sub ( _change ) ; } emit ModuleBudgetChanged ( modulesToData [ _module ] . moduleTypes , _module , currentAllowance , newAllowance ) ; }
function pruneInvestors ( uint256 _start , uint256 _iters ) public onlyOwner { for ( uint256 i = _start ; i < Math . min256 ( _start . add ( _iters ) , investors . length ) ; i ++ ) { if ( ( i < investors . length ) && ( balanceOf ( investors [ i ] ) == 0 ) ) { investorListed [ investors [ i ] ] = false ; investors [ i ] = investors [ investors . length - 1 ] ; investors . length -- ; } } }
function onTransfer ( address _from , address _to , uint256 _amount ) public returns ( bool ) { hodlerReward . invalidate ( _from ) ; return ! paused || _from == address ( this ) || _to == address ( this ) || _from == address ( crowdsale ) || _to == address ( crowdsale ) ; }
function tip ( address _to , uint _amount ) public { require ( _to != 0x0 ) ; require ( _amount > 0 ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _amount ) ; emit TipMade ( msg . sender , _to , _amount ) ; DAI . transferFrom ( msg . sender , _to , _amount ) ; }
function canAddAttribute ( uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) ;
function addMinter ( address _who ) public onlyOwner returns ( bool ) { _setMinter ( _who , true ) ; }
function cancelMatch ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; require ( isPlayerOnBoard ( boardId , msg . sender ) ) ; require ( board . status == BoardStatus . WaitForOpponent ) ; updateBoardStatus ( board , boardId , BoardStatus . Canceled ) ; }
function arbitrateApproveMilestone ( uint _idMilestone ) onlyArbitrator campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) && ( milestone . status != MilestoneStatus . Completed ) ) throw ; doPayment ( _idMilestone ) ; }
function setToken ( address _token ) external timedStateChange requiresState ( IcoState . PAUSED ) onlymanyowners ( sha3 ( msg . data ) ) { require ( address ( 0 ) != _token ) ; m_token = STQToken ( _token ) ; }
function setFeeCharge ( uint64 _value ) public onlyOwner { require ( _value <= feeChargeMax , "can not increase fee charge over it's limit" ) ; uint64 oldValue = feeCharge ; feeCharge = _value ; emit FeeCharge ( oldValue , _value ) ; }
function supportsInterface ( bytes4 _interfaceID ) public view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) ) ; }
function close ( ) onlyICOContract public returns ( bool ) { if ( state != State . Active ) { error ( 'close: state != State.Active' ) ; return false ; } state = State . Closed ; walletFounder1 . transfer ( address ( this ) . balance . mul ( 33 ) . div ( 100 ) ) ; walletFounder2 . transfer ( address ( this ) . balance . mul ( 50 ) . div ( 100 ) ) ; walletFounder3 . transfer ( address ( this ) . balance ) ; emit Closed ( ) ; return true ; }
function deposit ( Data storage self , uint256 amount ) senderOnly ( self ) returns ( bool success , uint256 balance ) { require ( self . opened > 0 ) ; require ( self . closed == 0 ) ; StandardToken token = self . manager . token ( ) ; require ( token . balanceOf ( msg . sender ) >= amount ) ; success = token . transferFrom ( msg . sender , this , amount ) ; if ( success == true ) { self . balance += amount ; return ( true , self . balance ) ; } return ( false , 0 ) ; }
function provideProofOfWork ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender == job . worker ) ; job . proofOfLastWorkVerified = false ; emit ProofOfWorkProvided ( _JobID , msg . sender , true ) ; }
function ( ) payable { require ( ! crowdsaleCanceled ) ; require ( msg . value > 0 ) ; require ( block . timestamp >= START_DATE && block . timestamp <= END_DATE ) ; uint256 quantity = safeDiv ( safeMul ( msg . value , CROWDSALE_PRICE ) , 10 ** ( 18 - uint256 ( decimals ) ) ) ; require ( safeSub ( balances [ this ] , quantity ) >= 0 ) ; require ( MULTISIG_WALLET_ADDRESS . send ( msg . value ) ) ; balances [ this ] = safeSub ( balances [ this ] , quantity ) ; balances [ msg . sender ] = safeAdd ( balances [ msg . sender ] , quantity ) ; soldAmount = safeAdd ( soldAmount , quantity ) ; paidAmount = safeAdd ( paidAmount , msg . value ) ; Transfer ( this , msg . sender , quantity ) ; }
function changeFactoryUsageFee ( uint256 _newUsageCost ) public onlyOwner { emit ChangeFactoryUsageFee ( usageCost , _newUsageCost , address ( this ) ) ; usageCost = _newUsageCost ; }
function sellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _seller , "Must be seller" ) ; return doSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }
function initialize ( WBC _wbc , address raiseAcc , address team1Acc , address team2Acc , address team3Acc ) public onlyOwner { require ( blockTime ( ) >= startTime ) ; require ( _wbc . owner ( ) == address ( this ) ) ; require ( raiseAcc != 0 && team1Acc != 0 && team2Acc != 0 && team3Acc != 0 ) ; wbc = _wbc ; raiseAccount = raiseAcc ; team1Account = team1Acc ; team2Account = team2Acc ; team3Account = team3Acc ; mintToTeamAccounts ( ) ; initialized = true ; emit onInitialized ( ) ; }
function multiCallTightlyPacked ( bytes32 [ ] _addressesAndAmounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addressesAndAmounts . length ; i ++ ) { address to = address ( _addressesAndAmounts [ i ] >> 96 ) ; uint amount = uint ( uint96 ( _addressesAndAmounts [ i ] ) ) ; _safeCall ( to , amount ) ; MultiCall ( msg . sender , msg . value , to , amount ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }
function getFinalAnswer ( bytes32 question_id ) external view returns ( bytes32 ) { }
function decimals ( ) external constant returns ( uint8 _decimals ) { return decimals ; }
function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < TOTAL_SUPPLY ) ; return _index + 1 ; }
function calculate_shares_and_return ( uint _shares_count , uint _share_price , uint _transfer_valuation , uint _final_share_price , uint _art_price , uint transfer_token ) view public returns ( uint _shares_to_assign , uint _executed_amount_valuation , uint _return_amount ) { if ( assigned_shares . add ( _shares_count ) > max_shares_to_sell ) { _shares_to_assign = max_shares_to_sell . sub ( assigned_shares ) ; } else { _shares_to_assign = _shares_count ; } _executed_amount_valuation = _shares_to_assign . mul ( _final_share_price ) ; if ( final_fundraise . add ( _executed_amount_valuation ) > fundraise_max ) { _executed_amount_valuation = fundraise_max . sub ( final_fundraise ) ; _shares_to_assign = _executed_amount_valuation . div ( _final_share_price ) ; _executed_amount_valuation = _shares_to_assign . mul ( _final_share_price ) ; } uint _executed_amount = convert_valuation_to_art ( _executed_amount_valuation , _art_price ) ; _return_amount = transfer_token . sub ( _executed_amount ) ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = ownerAddressToCardCount [ _owner ] ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 total = totalNumberOfCards ( ) ; uint256 resultIndex = 0 ; uint256 cardId ; for ( cardId = 1 ; cardId <= total ; cardId ++ ) { if ( cardIdToOwner [ cardId ] == _owner ) { result [ resultIndex ] = cardId ; resultIndex ++ ; } } return result ; }
function batchSetApprovalForAll ( address [ ] _spenders , bool _approved ) public { require ( isBatchSupported ) ; require ( _spenders . length > 0 ) ; address _spender ; for ( uint256 i = 0 ; i < _spenders . length ; ++ i ) { require ( address ( _spenders [ i ] ) != address ( 0 ) ) ; _spender = _spenders [ i ] ; setApprovalForAll ( _spender , _approved ) ; } }
function getOrganizations ( ) external view returns ( address [ ] accounts ) { return _organizationAccounts ; }
function indexOf ( string source , string query , uint256 fromIndex ) internal pure returns ( int256 ) { bytes memory sourceBytes = bytes ( source ) ; bytes memory queryBytes = bytes ( query ) ; if ( queryBytes . length == 0 ) { return 0 ; } if ( sourceBytes . length < queryBytes . length ) { return - 1 ; } for ( uint256 i = fromIndex ; i < sourceBytes . length - queryBytes . length ; i ++ ) { uint256 j = 0 ; while ( j < queryBytes . length && queryBytes [ j ] == sourceBytes [ j + i ] ) { j ++ ; } if ( j == queryBytes . length ) { return int256 ( i ) ; } } return - 1 ; }
function getMinInvestment ( ) public pure returns ( uint ) { return 10 finney ; }
function synthetixReceivedForSynths ( uint amount ) public view returns ( uint ) { uint synthsReceived = feePool . amountReceivedFromTransfer ( amount ) ; return synthsReceived . divideDecimal ( usdToSnxPrice ) ; }
function assignTokens ( address addr , uint amount ) internal returns ( uint ) { require ( addr != 0x0 ) ; require ( initialTokensAssigned == false ) ; balances [ addr ] = amount ; Transfer ( 0x0 , addr , balances [ addr ] ) ; return balances [ addr ] ; }
function setSize ( uint256 _size ) public onlyOwner returns ( bool ) { size = _size ; return true ; }
function buyWithETH ( address _beneficiary ) public payable validETH { uint256 rate = getRate ( FundRaiseType . ETH ) ; ( uint256 spentUSD , uint256 spentValue ) = _buyTokens ( _beneficiary , msg . value , rate , FundRaiseType . ETH ) ; investorInvested [ _beneficiary ] [ uint8 ( FundRaiseType . ETH ) ] = investorInvested [ _beneficiary ] [ uint8 ( FundRaiseType . ETH ) ] . add ( spentValue ) ; fundsRaised [ uint8 ( FundRaiseType . ETH ) ] = fundsRaised [ uint8 ( FundRaiseType . ETH ) ] . add ( spentValue ) ; wallet . transfer ( spentValue ) ; msg . sender . transfer ( msg . value . sub ( spentValue ) ) ; emit FundsReceived ( msg . sender , _beneficiary , spentUSD , FundRaiseType . ETH , msg . value , spentValue , rate ) ; }
function calculateGrantClaim ( address _recipient ) public view returns ( uint256 , uint256 ) { Grant storage tokenGrant = tokenGrants [ _recipient ] ; if ( currentTime ( ) < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint256 elapsedTime = currentTime ( ) . sub ( tokenGrant . startTime ) ; uint256 elapsedYears = elapsedTime . div ( SECONDS_PER_YEAR ) ; if ( elapsedYears >= tokenGrant . vestingDuration ) { uint256 remainingGrant = tokenGrant . amount . sub ( tokenGrant . totalClaimed ) ; uint256 remainingYears = tokenGrant . vestingDuration . sub ( tokenGrant . yearsClaimed ) ; return ( remainingYears , remainingGrant ) ; } else { uint256 i = 0 ; uint256 tokenGrantAmount = tokenGrant . amount ; uint256 totalVested = 0 ; for ( i ; i < elapsedYears ; i ++ ) { totalVested = ( tokenGrantAmount . mul ( 10 ) ) . div ( 100 ) . add ( totalVested ) ; tokenGrantAmount = tokenGrant . amount . sub ( totalVested ) ; } uint256 amountVested = totalVested . sub ( tokenGrant . totalClaimed ) ; return ( elapsedYears , amountVested ) ; } }
function challengeWinnerReward ( uint _challengeID ) public view returns ( uint ) { if ( voting . getTotalNumberOfTokensForWinningOption ( _challengeID ) == 0 ) { return 2 * challenges [ _challengeID ] . stake ; } return ( 2 * challenges [ _challengeID ] . stake ) - challenges [ _challengeID ] . rewardPool ; }
function setFreeClaimAllowance ( address addr , uint256 allowance ) external onlyCFO { freeClaimAllowance [ addr ] = allowance ; }
function getVote ( uint _idPoll , address _voter ) public view returns ( uint [ 15 ] votes ) { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll storage p = _polls [ _idPoll ] ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { votes [ i ] = p . ballots [ i ] [ _voter ] ; } return votes ; }
function sell ( uint256 amount ) public { address myAddress = this ; require ( myAddress . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
function handlePlannedWhitelistedContribution ( uint256 plannedContribution ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( plannedContribution ) ; AllowedContributionCheck ( plannedContribution , AllowedContributionState . Whitelisted ) ; return ( plannedContribution , 0 ) ; }
function balanceOf ( address owner ) public view returns ( uint256 balance ) { return balances [ owner ] ; }
function buySharesFor ( address _recipient ) payable ;
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( msg . sender == owner || now > 1509467422 ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }
function withdrawFees ( ) external optionalProxy { address sender = messageSender ; rolloverFeePeriodIfElapsed ( ) ; require ( ! nomin . frozen ( sender ) ) ; updateIssuanceData ( sender , nominsIssued [ sender ] , nomin . totalSupply ( ) ) ; require ( ! hasWithdrawnFees [ sender ] ) ; uint feesOwed ; uint lastTotalIssued = totalIssuanceData . lastAverageBalance ; if ( lastTotalIssued > 0 ) { feesOwed = safeDiv_dec ( safeMul_dec ( issuanceData [ sender ] . lastAverageBalance , lastFeesCollected ) , lastTotalIssued ) ; } hasWithdrawnFees [ sender ] = true ; if ( feesOwed != 0 ) { nomin . withdrawFees ( sender , feesOwed ) ; } emitFeesWithdrawn ( messageSender , feesOwed ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) public canTransfer ( _tokenId ) { require ( checkIsAttached ( _tokenId ) == 0 ) ; require ( _from != address ( 0 ) ) ; require ( _to != address ( 0 ) ) ; clearApproval ( _from , _tokenId ) ; removeTokenFrom ( _from , _tokenId ) ; addTokenTo ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }
function isReissuable ( bytes32 _symbol ) public view returns ( bool ) { return get ( store , assetIsReissuable , _symbol ) ; }
function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes _data ) external returns ( bytes4 ) ;
function enableTransfers ( bool _transfersEnabled ) onlyOwner public { transfersEnabled = _transfersEnabled ; }
function disown ( ) public onlyOwner ( ) { delete owner ; }
function isExploring ( uint256 _tokenId ) public view returns ( bool ) { uint256 cooldown ; uint64 cooldownEndBlock ; ( , , , , , cooldownEndBlock , cooldown , ) = ethernautsStorage . assets ( _tokenId ) ; return ( cooldown > now ) || ( cooldownEndBlock > uint64 ( block . number ) ) ; }
function createPool ( address [ ] _admins , uint256 [ ] _configsUint , bool [ ] _configsBool ) public returns ( address _pool ) { address poolOwner = msg . sender ; _pool = new Pool ( poolOwner , _admins , _configsUint , _configsBool , nextPoolId ) ; pools [ nextPoolId ] = _pool ; nextPoolId = nextPoolId . add ( 1 ) ; emit PoolCreated ( nextPoolId , poolOwner ) ; }
function distributeVariable ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( "Distribution Failed: Count Down not gone yet" ) ; }
function name ( ) public constant returns ( string ) { }
function totalSupplyAt ( uint256 _blockNumber ) public view returns ( uint256 ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
function unPause ( bytes32 _hash ) external pollApproved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) notBeforeGenesis { if ( paused ) { paused = false ; LogUnPause ( _hash ) ; } }
function setController ( address _controller ) public onlyOwner { require ( ! controllerDisabled ) ; emit SetController ( controller , _controller ) ; controller = _controller ; }
function init ( address _token , address _plcr , uint [ ] _parameters ) public { require ( _token != 0 && address ( token ) == 0 ) ; require ( _plcr != 0 && address ( voting ) == 0 ) ; token = EIP20Interface ( _token ) ; voting = PLCRVoting ( _plcr ) ; set ( "minDeposit" , _parameters [ 0 ] ) ; set ( "pMinDeposit" , _parameters [ 1 ] ) ; set ( "applyStageLen" , _parameters [ 2 ] ) ; set ( "pApplyStageLen" , _parameters [ 3 ] ) ; set ( "commitStageLen" , _parameters [ 4 ] ) ; set ( "pCommitStageLen" , _parameters [ 5 ] ) ; set ( "revealStageLen" , _parameters [ 6 ] ) ; set ( "pRevealStageLen" , _parameters [ 7 ] ) ; set ( "dispensationPct" , _parameters [ 8 ] ) ; set ( "pDispensationPct" , _parameters [ 9 ] ) ; set ( "voteQuorum" , _parameters [ 10 ] ) ; set ( "pVoteQuorum" , _parameters [ 11 ] ) ; set ( "exitTimeDelay" , _parameters [ 12 ] ) ; set ( "exitPeriodLen" , _parameters [ 13 ] ) ; }
function balanceOf ( address _owner ) public constant returns ( uint256 bal ) { return balances [ _owner ] ; }
function allowance ( address _owner , address _spender ) public constant returns ( uint256 _amount ) { return allowance [ _owner ] [ _spender ] ; }
function getCollectible ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = tokenIndexToPrice [ _tokenId ] ; owner = tokenIndexToOwner [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = getInitialPriceOfToken ( _tokenId ) ; nextSellingPrice = getNextPrice ( sellingPrice ) ; }
function addCZRLock ( address addr , uint startLockTime , uint amount , uint lockMonth ) onlyOwner public { require ( amount > 0 ) ; if ( startLockTime == 0 ) startLockTime = now ; lockedCZRMap [ addr ] . push ( LockedCZR ( startLockTime , lockMonth , amount , 0 ) ) ; uint index = lockedCZRMap [ addr ] . length - 1 ; AddLock ( addr , index , startLockTime , lockMonth , amount ) ; }
function trust ( address _to ) public returns ( uint ) { uint fromId = _createHolderId ( msg . sender ) ; if ( fromId == getHolderId ( _to ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( isTrusted ( msg . sender , _to ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_ALREADY_TRUSTED ) ; } set ( store , holdersTrustStorage , fromId , _to , true ) ; return OK ; }
function isSaleLive ( ) public constant returns ( bool ) { return ( initialized == true && getPhase ( ) != 0 && goalReached ( ) == false ) ; }
function createSellOrder ( address token , uint tokensTotal , uint ethersTotal , uint8 [ ] exchanges , address [ 5 ] [ ] orderAddresses , uint [ 6 ] [ ] orderValues , uint [ ] exchangeFees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s ) public { require ( Token ( token ) . transferFrom ( msg . sender , this , tokensTotal ) ) ; uint ethersObtained ; uint tokensSold ; uint tokensRefunded = tokensTotal ; ( ethersObtained , tokensSold ) = fillOrdersForSellRequest ( tokensTotal , exchanges , orderAddresses , orderValues , exchangeFees , v , r , s ) ; require ( ethersObtained > 0 && tokensSold > 0 ) ; require ( SafeMath . safeDiv ( ethersTotal , tokensTotal ) <= SafeMath . safeDiv ( ethersObtained , tokensSold ) ) ; tokensRefunded = SafeMath . safeSub ( tokensTotal , tokensSold ) ; if ( tokensRefunded > 0 ) require ( Token ( token ) . transfer ( msg . sender , tokensRefunded ) ) ; transfer ( msg . sender , ethersObtained ) ; FillSellOrder ( msg . sender , token , tokensTotal , ethersTotal , tokensSold , ethersObtained , tokensRefunded ) ; }
function execScript ( bytes _script , bytes , address [ ] _blacklist ) external isInitialized returns ( bytes ) { uint256 location = SCRIPT_START_LOCATION ; while ( location < _script . length ) { address contractAddress = _script . addressAt ( location ) ; for ( uint i = 0 ; i < _blacklist . length ; i ++ ) { require ( contractAddress != _blacklist [ i ] , ERROR_BLACKLISTED_CALL ) ; } emit LogScriptCall ( msg . sender , address ( this ) , contractAddress ) ; uint256 calldataLength = uint256 ( _script . uint32At ( location + 0x14 ) ) ; uint256 startOffset = location + 0x14 + 0x04 ; uint256 calldataStart = _script . locationOf ( startOffset ) ; location = startOffset + calldataLength ; require ( location <= _script . length , ERROR_INVALID_LENGTH ) ; bool success ; assembly { success := call ( sub ( gas , 5000 ) , contractAddress , 0 , calldataStart , calldataLength , 0 , 0 ) } require ( success , ERROR_CALL_REVERTED ) ; } }
function getChampsForSale ( ) view external returns ( uint256 [ ] ) { uint256 [ ] memory result = new uint256 [ ] ( champsForSaleCount ) ; if ( champsForSaleCount > 0 ) { uint256 counter = 0 ; for ( uint256 i = 0 ; i < champs . length ; i ++ ) { if ( champs [ i ] . forSale == true ) { result [ counter ] = i ; counter ++ ; } } } return result ; }
function getCampaign ( bytes32 _campaignId ) public view returns ( bytes32 _bidId , uint _price , uint _budget , uint _startDate , uint _endDate , bool _valid , address _campOwner ) { CampaignLibrary . Campaign storage campaign = _getCampaign ( _campaignId ) ; return ( campaign . getBidId ( ) , campaign . getPrice ( ) , campaign . getBudget ( ) , campaign . getStartDate ( ) , campaign . getEndDate ( ) , campaign . getValidity ( ) , campaign . getOwner ( ) ) ; }
function unpause ( ) onlyOwner whenPaused public { require ( ! retired ) ; paused = false ; Unpause ( ) ; }
function newChannel ( Data storage self , address partner , uint settle_timeout ) returns ( address ) { address [ ] storage caller_channels = self . nodeaddress_to_channeladdresses [ msg . sender ] ; address [ ] storage partner_channels = self . nodeaddress_to_channeladdresses [ partner ] ; bytes32 party_hash = partyHash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; address new_channel_address = new NettingChannelContract ( self . token , msg . sender , partner , settle_timeout ) ; if ( channel_pos != 0 ) { address settled_channel = self . all_channels [ channel_pos - 1 ] ; require ( ! contractExists ( settled_channel ) ) ; uint caller_pos = self . node_index [ msg . sender ] [ partner ] ; uint partner_pos = self . node_index [ partner ] [ msg . sender ] ; self . all_channels [ channel_pos - 1 ] = new_channel_address ; caller_channels [ caller_pos - 1 ] = new_channel_address ; partner_channels [ partner_pos - 1 ] = new_channel_address ; } else { self . all_channels . push ( new_channel_address ) ; caller_channels . push ( new_channel_address ) ; partner_channels . push ( new_channel_address ) ; self . partyhash_to_channelpos [ party_hash ] = self . all_channels . length ; self . node_index [ msg . sender ] [ partner ] = caller_channels . length ; self . node_index [ partner ] [ msg . sender ] = partner_channels . length ; } return new_channel_address ; }
function adminSetLock ( bool _lock , bool _allowPurchase ) public onlyAdmin { if ( _lock ) { if ( _allowPurchase ) systemLock = LOCK_NO_LISTING ; else systemLock = LOCK_REMOVE_ONLY ; } else { systemLock = LOCK_NONE ; } }
function openOrder ( uint64 _settlementID , bytes _signature , bytes32 _orderID ) external { require ( orders [ _orderID ] . state == OrderState . Undefined , "invalid order status" ) ; address trader = msg . sender ; require ( settlementRegistry . settlementRegistration ( _settlementID ) , "settlement not registered" ) ; BrokerVerifier brokerVerifier = settlementRegistry . brokerVerifierContract ( _settlementID ) ; require ( brokerVerifier . verifyOpenSignature ( trader , _signature , _orderID ) , "invalid broker signature" ) ; orders [ _orderID ] = Order ( { state : OrderState . Open , trader : trader , confirmer : 0x0 , settlementID : _settlementID , priority : orderbook . length + 1 , blockNumber : block . number , matchedOrder : 0x0 } ) ; orderbook . push ( _orderID ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . value == 0 ) ; _transferFrom ( _from , _to , _tokenId ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }
function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 6700000000 ; }
function pickRandomAssets ( uint _finalSeed , bytes32 [ ] _potentialAssets ) public pure returns ( uint [ ] finalPicked ) { require ( _finalSeed != 0 ) ; require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetIds = decodeAssets ( _potentialAssets ) ; uint [ ] memory pickedIds = new uint [ ] ( assetIds . length ) ; uint finalSeedCopy = _finalSeed ; uint index = 0 ; for ( uint i = 0 ; i < assetIds . length ; i ++ ) { finalSeedCopy = uint ( keccak256 ( abi . encodePacked ( finalSeedCopy , assetIds [ i ] ) ) ) ; if ( finalSeedCopy % 2 == 0 ) { pickedIds [ index ] = assetIds [ i ] ; index ++ ; } } finalPicked = new uint [ ] ( index ) ; for ( i = 0 ; i < index ; i ++ ) { finalPicked [ i ] = pickedIds [ i ] ; } }
function setup ( address _token_address ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _token_address != 0x0 ) ; token = GoToken ( _token_address ) ; num_tokens_auctioned = token . balanceOf ( address ( this ) ) ; token_multiplier = 10 ** ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; }
function addBurningMan ( address _burningMan , uint _block ) public returns ( uint _code ) { if ( burningMans [ _burningMan ] ) { return _emitError ( SERVICE_CONTROLLER_BURNING_MAN_EXIST ) ; } _code = _multisig ( keccak256 ( _burningMan ) , _block ) ; if ( OK != _code ) { return _code ; } burningMans [ _burningMan ] = true ; uint _count = burningMansCount + 1 ; index2burningMan [ _count ] = _burningMan ; burningMan2index [ _burningMan ] = _count ; burningMansCount = _count ; return OK ; }
function enableTransfers ( bool _transfersEnabled ) onlyOwner { token . enableTransfers ( _transfersEnabled ) ; }
function getInitFunction ( address _contractAddress ) external returns ( bytes4 ) { return USDTieredSTO ( _contractAddress ) . getInitFunction ( ) ; }
function addPackage ( string name , address repo ) onlyOwner public returns ( uint idPackage ) { idPackage = DAppNodePackages . length ++ ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; c . name = name ; c . repo = repo ; PackageAdded ( idPackage , name , repo ) ; }
function bulkTokenSend ( address [ ] beneficiaries , uint256 [ ] amounts ) onlyOwner external { require ( beneficiaries . length == amounts . length ) ; for ( uint32 i = 0 ; i < beneficiaries . length ; i ++ ) { require ( token . transferFrom ( msg . sender , beneficiaries [ i ] , amounts [ i ] ) ) ; } }
function changeExchangeStatus ( bool newExchangeState ) public only_exchange_operator { IS_EXCHANGE_OPERATIONAL = newExchangeState ; }
function pauseSale ( ) public onlyController { require ( campaignState == 2 ) ; paused = true ; CampaignPausd ( now ) ; }
function getCanvasByState ( uint8 _state ) external view returns ( uint32 [ ] ) { uint size ; if ( _state == STATE_NOT_FINISHED ) { size = activeCanvasCount ; } else { size = getCanvasCount ( ) - activeCanvasCount ; } uint32 [ ] memory result = new uint32 [ ] ( size ) ; uint currentIndex = 0 ; for ( uint32 i = 0 ; i < canvases . length ; i ++ ) { if ( getCanvasState ( i ) == _state ) { result [ currentIndex ] = i ; currentIndex ++ ; } } return _slice ( result , 0 , currentIndex ) ; }
function isWhitelisted ( address _stablecoin ) public view returns ( bool ) { return tokenStorage_CD . whitelist ( _stablecoin ) ; }
function setReadOnly ( bool enabled ) public onlyOwner { readOnly = enabled ; }
function register ( address _address , uint _timestamp , uint _gasLimit , uint _gasPrice ) external payable returns ( uint ) ;
function approve ( address _spender , uint _value ) returns ( bool success ) ;
function claim ( ) public onlyOwner { require ( now >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( owner , amount ) ; }
function transfer ( address _to , uint256 _amount ) public erc20 returns ( bool success ) { doSend ( msg . sender , _to , _amount , "" , msg . sender , "" , false ) ; return true ; }
function ownerClawback ( ) external onlyOwner { if ( now < OWNER_CLAWBACK_DATE ) revert ( ) ; if ( ! owner . send ( this . balance ) ) revert ( ) ; }
function setProjectManager ( address _projectManager ) returns ( bool ) { if ( _projectManager == 0 || projectManager != 0 ) return ; projectManager = _projectManager ; return true ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { uint256 c = a + b ; require ( c >= a , "Error: Unsafe addition operation!" ) ; return c ; }
function getParticipant ( uint256 _index ) public view returns ( address participantAddress , uint256 participantAnswerId ) { Participant storage p = participants [ _index ] ; participantAddress = p . user_address ; participantAnswerId = p . answer_id ; }
function totalSupplyAt ( uint256 snapshotId ) public constant returns ( uint256 ) ;
function configure ( uint256 _startTime , uint256 _endTime , uint256 _cap , uint256 _rate , uint8 _fundRaiseType , address _fundsReceiver ) public onlyFactory { require ( _rate > 0 , "Rate of token should be greater than 0" ) ; require ( _fundsReceiver != address ( 0 ) , "Zero address is not permitted" ) ; require ( _startTime >= now && _endTime > _startTime , "Date parameters are not valid" ) ; require ( _cap > 0 , "Cap should be greater than 0" ) ; startTime = _startTime ; endTime = _endTime ; cap = _cap ; rate = _rate ; wallet = _fundsReceiver ; _check ( _fundRaiseType ) ; }
function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }
function setManualPrice ( uint256 _price ) public onlyOwner { emit SetManualPrice ( manualPrice , _price , now ) ; manualPrice = _price ; }
function _processPurchase ( address _beneficiary , uint256 _tokenAmount ) internal { if ( investors [ _beneficiary ] == 0 ) { investorCount = investorCount + 1 ; } investors [ _beneficiary ] = investors [ _beneficiary ] . add ( _tokenAmount ) ; _deliverTokens ( _beneficiary , _tokenAmount ) ; }
function burn ( uint256 _amount , bytes _data ) public onlyOwner { super . burn ( _amount , _data ) ; }
function withdrawChamp ( uint _id ) external onlyOwnerOfChamp ( _id ) contractMinBalanceReached isChampWithdrawReady ( _id ) whenNotPaused { Champ storage champ = champs [ _id ] ; require ( champ . position <= 800 ) ; champ . withdrawCooldown = block . timestamp + 1 days ; uint256 withdrawal = getChampReward ( champ . position ) ; addressInfo [ msg . sender ] . withdrawal += withdrawal ; pendingWithdrawal += withdrawal ; }
function isTransferAgent ( address _address ) public constant onlyWhitelisted returns ( bool ) { return transferAgents [ _address ] ; }
function approveForwardedAccount ( address originalAccount , address updatedAccount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setForwardedAccount ( originalAccount , updatedAccount ) , "Error: Unable to set forwarded address for account. Please check issuerFirm and firm authority are registered" ) ; return true ; }
function getPreICOBonus ( ) internal constant returns ( uint ) { return 35 ; }
function setKYCApproval ( Data storage self , address account , bool isApproved , string issuerFirm ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.kyc' , getForwardedAccount ( self , account ) ) ) ; require ( self . Storage . setBool ( id , isApproved ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; emit KYCApproval ( account , isApproved , issuerFirm ) ; return true ; }
function withdrawAll ( ) onlyOwner public { owner . transfer ( address ( this ) . balance ) ; }
function appendDecryptedBid ( uint _nonce , uint _index , uint _bid_id , address _investor_address , uint _share_price , uint _shares_count , uint _transfered_token ) onlyOwner public { require ( status == state . ended ) ; require ( fundraise_defined ) ; require ( bids [ _index ] . exist == true ) ; require ( bids [ _index ] . is_decrypted == false ) ; require ( bids [ _index ] . is_burned == false ) ; require ( _share_price > 0 ) ; require ( _shares_count > 0 ) ; require ( _transfered_token >= convert_valuation_to_art ( _shares_count . mul ( _share_price ) , bids [ _index ] . art_price ) ) ; if ( bids_sorted_count > 0 ) { BidData memory previous_bid_data = bids_sorted [ bids_sorted_count - 1 ] ; require ( _share_price <= previous_bid_data . share_price ) ; if ( _share_price == previous_bid_data . share_price ) { require ( _index > previous_bid_data . origin_index ) ; } } require ( getBidHash ( _nonce , _bid_id , _investor_address , _share_price , _shares_count ) == bids [ _index ] . bid_hash ) ; uint _transfer_amount = _share_price . mul ( _shares_count ) ; BidData memory bid_data = BidData ( _index , _bid_id , _investor_address , _share_price , _shares_count , _transfer_amount , _transfered_token , 0 , 0 , false ) ; bids [ _index ] . is_decrypted = true ; if ( _share_price >= min_share_price ) { bids [ _index ] . will_compute = true ; bids_sorted [ bids_sorted_count ] = bid_data ; bids_sorted_count ++ ; emit BidDecrypted ( _index , true ) ; } else { bids [ _index ] . will_compute = false ; bids_ignored [ bids_ignored_count ] = bid_data ; bids_ignored_count ++ ; emit BidDecrypted ( _index , false ) ; } bids_decrypted [ bids_decrypted_count ] = _index ; bids_decrypted_count ++ ; if ( bids_decrypted_count == bids_count ) { emit Decrypted ( block . number , bids_decrypted_count . sub ( bids_burned_count ) , bids_burned_count ) ; status = state . decrypted ; } }
function name ( ) public pure returns ( string _deedName ) { _deedName = "DWorld Plots" ; }
function approve ( address spender , uint value ) public returns ( bool ) ;
function makeOrder ( uint exchangeNumber , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) external pre_cond ( isOwner ( ) ) pre_cond ( ! isShutDown ) { require ( buyAsset != address ( this ) ) ; require ( quantityHeldInCustodyOfExchange ( sellAsset ) == 0 ) ; require ( module . pricefeed . existsPriceOnAssetPair ( sellAsset , buyAsset ) ) ; var ( isRecent , referencePrice , ) = module . pricefeed . getReferencePrice ( sellAsset , buyAsset ) ; require ( isRecent ) ; require ( module . riskmgmt . isMakePermitted ( module . pricefeed . getOrderPrice ( sellAsset , buyAsset , sellQuantity , buyQuantity ) , referencePrice , sellAsset , buyAsset , sellQuantity , buyQuantity ) ) ; require ( isInAssetList [ buyAsset ] || ownedAssets . length < MAX_FUND_ASSETS ) ; require ( AssetInterface ( sellAsset ) . approve ( exchanges [ exchangeNumber ] . exchange , sellQuantity ) ) ; require ( address ( exchanges [ exchangeNumber ] . exchangeAdapter ) . delegatecall ( bytes4 ( keccak256 ( "makeOrder(address,address,address,uint256,uint256)" ) ) , exchanges [ exchangeNumber ] . exchange , sellAsset , buyAsset , sellQuantity , buyQuantity ) ) ; exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] = exchanges [ exchangeNumber ] . exchangeAdapter . getLastOrderId ( exchanges [ exchangeNumber ] . exchange ) ; require ( exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] != 0 ) ; isInOpenMakeOrder [ buyAsset ] = true ; if ( ! isInAssetList [ buyAsset ] ) { ownedAssets . push ( buyAsset ) ; isInAssetList [ buyAsset ] = true ; } orders . push ( Order ( { exchangeId : exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] , status : OrderStatus . active , orderType : OrderType . make , sellAsset : sellAsset , buyAsset : buyAsset , sellQuantity : sellQuantity , buyQuantity : buyQuantity , timestamp : now , fillQuantity : 0 } ) ) ; OrderUpdated ( exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] ) ; }
function priceOf ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . price ; }
function bid ( ) public payable atStage ( Stages . AuctionStarted ) { require ( msg . value > 0 ) ; require ( bids [ msg . sender ] + msg . value <= bid_threshold || whitelist [ msg . sender ] ) ; assert ( bids [ msg . sender ] + msg . value >= msg . value ) ; uint missing_funds = missingFundsToEndAuction ( ) ; require ( msg . value <= missing_funds ) ; bids [ msg . sender ] += msg . value ; received_wei += msg . value ; wallet_address . transfer ( msg . value ) ; BidSubmission ( msg . sender , msg . value , missing_funds ) ; assert ( received_wei >= msg . value ) ; }
function proxyTransferWithReference ( address _to , uint _value , bytes32 _symbol , string _reference , address _sender ) onlyProxy ( _symbol ) public returns ( uint ) { return _transfer ( getHolderId ( _sender ) , _createHolderId ( _to ) , _value , _symbol , _reference , getHolderId ( _sender ) ) ; }
function batchCancelSale ( uint256 [ ] _tokenIds ) external whenNotPaused { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 ) ; for ( uint ii = 0 ; ii < _tokenIds . length ; ii ++ ) { Sale memory sale = tokenIdToSale [ _tokenIds [ ii ] ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _cancelSale ( _tokenIds [ ii ] , seller ) ; } }
function cost ( address , uint256 , bytes , bytes ) external view returns ( uint256 ) { return 0 ; }
function hasConfirmedRecord ( bytes32 _key ) public view returns ( uint ) { require ( _key != bytes32 ( 0 ) ) ; if ( ! isTxExist ( _key ) ) { return NO_RECORDS_WERE_FOUND ; } Guard storage _guard = txKey2guard [ _key ] ; return _guard . state == GuardState . InProcess ? PENDING_MANAGER_IN_PROCESS : _guard . state == GuardState . Confirmed ? OK : PENDING_MANAGER_REJECTED ; }
function addTime ( address who , uint sconds ) public onlyTransferAgent returns ( bool ) { require ( sconds > 0 , "Time added cannot be zero." ) ; Holding memory holding = heldTokens [ who ] ; heldTokens [ who ] = Holding ( holding . quantity , holding . releaseDate . add ( sconds ) , holding . isAffiliate ) ; emit ReleaseDateExtended ( who , heldTokens [ who ] . releaseDate ) ; return true ; }
function pay ( address _user , address _destination , uint256 _value ) public onlyAllowed ;
function adminChange ( address _newAdmin ) public { require ( msg . sender == admin , "Only the admin can call this function" ) ; admin = _newAdmin ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( now > SaleDeadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } }
function stakeCommunityTokens ( ) public { require ( minimumStakingRequirement >= communityAccount . stakedBalances ( msg . sender ) ) ; uint amount = minimumStakingRequirement - communityAccount . stakedBalances ( msg . sender ) ; require ( amount > 0 ) ; require ( communityTokenInstance . transferFrom ( msg . sender , address ( communityAccount ) , amount ) ) ; communityAccount . setStakedBalances ( SafeMath . add ( communityAccount . stakedBalances ( msg . sender ) , amount ) , msg . sender ) ; communityAccount . setTotalStaked ( SafeMath . add ( communityAccount . totalStaked ( ) , amount ) ) ; communityAccount . setTimeStaked ( now , msg . sender ) ; logger . emitGenericLog ( "stakeCommunityTokens" , "" ) ; }
function getType ( ) public view returns ( uint8 ) ;
function isValidVersion ( uint8 [ ] _current , uint8 [ ] _new ) internal pure returns ( bool ) { bool [ ] memory _temp = new bool [ ] ( _current . length ) ; uint8 counter = 0 ; for ( uint8 i = 0 ; i < _current . length ; i ++ ) { if ( _current [ i ] < _new [ i ] ) _temp [ i ] = true ; else _temp [ i ] = false ; } for ( i = 0 ; i < _current . length ; i ++ ) { if ( i == 0 ) { if ( _current [ i ] <= _new [ i ] ) if ( _temp [ 0 ] ) { counter = counter + 3 ; break ; } else counter ++ ; else return false ; } else { if ( _temp [ i - 1 ] ) counter ++ ; else if ( _current [ i ] <= _new [ i ] ) counter ++ ; else return false ; } } if ( counter == _current . length ) return true ; }
function burn ( uint256 _value ) public blockLock ( msg . sender ) returns ( bool success ) { if ( _value == 0 || _value > balances [ msg . sender ] ) { return false ; } balances [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value , totalSupply ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }
function setFeePeriodDuration ( uint duration ) external optionalProxy_onlyOwner { require ( MIN_FEE_PERIOD_DURATION <= duration && duration <= MAX_FEE_PERIOD_DURATION ) ; feePeriodDuration = duration ; emitFeePeriodDurationUpdated ( duration ) ; rolloverFeePeriodIfElapsed ( ) ; }
function getValidator ( uint256 index ) external view returns ( address ) ;
function invoke ( ) public returns ( uint ) ;
function callPluginsPledge ( bool before , uint64 idPledge , uint64 fromPledge , uint64 toPledge , uint amount ) internal returns ( uint allowedAmount ) { uint64 offset = idPledge == fromPledge ? 0 : 256 ; allowedAmount = amount ; Pledge storage p = findPledge ( idPledge ) ; allowedAmount = callPlugin ( before , p . owner , fromPledge , toPledge , offset , allowedAmount ) ; for ( uint64 i = 0 ; i < p . delegationChain . length ; i ++ ) { allowedAmount = callPlugin ( before , p . delegationChain [ i ] , fromPledge , toPledge , offset + i + 1 , allowedAmount ) ; } if ( p . intendedProject > 0 ) { allowedAmount = callPlugin ( before , p . intendedProject , fromPledge , toPledge , offset + 255 , allowedAmount ) ; } }
function GiftsOfOwner ( address _owner ) public view returns ( uint256 [ ] ownerGifts ) { uint256 GiftCount = balanceOf ( _owner ) ; if ( GiftCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( GiftCount ) ; uint256 total = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 GiftId ; for ( GiftId = 0 ; GiftId <= total ; GiftId ++ ) { if ( GiftIndexToOwners [ GiftId ] == _owner ) { result [ resultIndex ] = GiftId ; resultIndex ++ ; } } return result ; } }
function withdrawMargin ( uint256 _value ) public returns ( bool ) { BCNTToken tokenContract = BCNTToken ( tokenAddress ) ; marginBalances [ msg . sender ] = marginBalances [ msg . sender ] . sub ( _value ) ; require ( tokenContract . transfer ( msg . sender , _value ) ) ; emit WithdrawMargin ( msg . sender , _value ) ; return true ; }
function logoutUser ( address _user ) external DAppOnline isAdmin { freezeUser [ _user ] = false ; }
function _burn ( address _owner , uint256 _tokenId ) validNFToken ( _tokenId ) internal { clearApproval ( _tokenId ) ; removeNFToken ( _owner , _tokenId ) ; emit Transfer ( _owner , address ( 0 ) , _tokenId ) ; }
function requestMortgage ( uint256 [ 6 ] loanParams , string metadata , uint256 landId , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { uint256 loanId = createLoan ( loanParams , metadata ) ; require ( nanoLoanEngine . registerApprove ( nanoLoanEngine . getIdentifier ( loanId ) , v , r , s ) , "Signature not valid" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 requiredDeposit = ( ( landCost * requiredTotal ) / 100 ) - nanoLoanEngine . getAmount ( loanId ) ; require ( mana . transferFrom ( msg . sender , this , requiredDeposit ) , "Error pulling MANA" ) ; require ( mana . approve ( mortgageManager , requiredDeposit ) ) ; uint256 mortgageId = mortgageManager . requestMortgageId ( Engine ( nanoLoanEngine ) , loanId , requiredDeposit , landId , tokenConverter ) ; emit NewMortgage ( msg . sender , loanId , landId , mortgageId ) ; return mortgageId ; }
function setApprovalForAll ( address _operator , bool _approved ) public returns ( bool ) { operators [ msg . sender ] [ _operator ] = _approved ; ApprovalForAll ( msg . sender , _operator , _approved ) ; return true ; }
function approveSiring ( address _addr , uint256 _sireId ) external whenNotPaused { require ( _owns ( msg . sender , _sireId ) ) ; sireAllowedToAddress [ _sireId ] = _addr ; }
function remove ( address ofAsset ) pre_cond ( isOwner ( ) ) pre_cond ( information [ ofAsset ] . exists ) { delete information [ ofAsset ] ; assert ( ! information [ ofAsset ] . exists ) ; }
function lockMe ( ) external { require ( userAddress2Id [ msg . sender ] != 0 ) ; userLock [ msg . sender ] = getTime ( ) + lockPeriod ; Lock ( msg . sender , userLock [ msg . sender ] ) ; }
function pricesAreStale ( ) public view returns ( bool ) { return safeAdd ( lastPriceUpdateTime , priceStalePeriod ) < now ; }
function requestMilestonePayment ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . milestoneLeadLink ) && ( msg . sender != recipient ) ) throw ; if ( ( milestone . status != MilestoneStatus . Completed ) || ( now < milestone . doneTime + milestone . reviewTime ) ) throw ; authorizePayment ( _idMilestone ) ; }
function ( ) public payable { revert ( "ETH not accepted" ) ; }
function withdraw ( ) public atStage ( Stages . AuctionCanceled ) returns ( bool ) { return proxyWithdraw ( msg . sender ) ; }
function exchangeEtherForSynthetixAtRate ( uint guaranteedEtherRate , uint guaranteedSynthetixRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedEtherRate == usdToEthPrice , "Guaranteed ether rate would not be received" ) ; require ( guaranteedSynthetixRate == usdToSnxPrice , "Guaranteed synthetix rate would not be received" ) ; return exchangeEtherForSynthetix ( ) ; }
function saleFinished ( ) public view returns ( bool ) { require ( stages . length == numPeriods ) ; return stages [ stages . length - 1 ] . endTime < now ; }
function _deliverTokens ( address _beneficiary , uint256 _tokenAmount ) internal { require ( IST20 ( securityToken ) . mint ( _beneficiary , _tokenAmount ) , "Error in minting the tokens" ) ; }
function withdrawFreeBalance ( ) external onlyCFO { uint256 freeBalance = this . balance - outstandingEther ; cfoAddress . transfer ( freeBalance ) ; }
function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; require ( balancesDB . setOperator ( _operator , msg . sender , false ) ) ; emit RevokedOperator ( _operator , msg . sender ) ; }
function setICOEndDate ( uint256 _date ) public whenNotPaused onlyWhitelisted { require ( icoEndDate == 0 ) ; icoEndDate = _date ; }
function receiveICOcoins ( uint256 amountOfCoinsToReceive , uint ShrID ) public returns ( bool success ) { msgSndr [ msg . sender ] = amountOfCoinsToReceive ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool icosuccess ; icosuccess = ico . recvShrICO ( msg . sender , amountOfCoinsToReceive , ShrID ) ; require ( icosuccess == true ) ; bool sucsTrTk ; sucsTrTk = _safeTransferTkn ( owner , msg . sender , amountOfCoinsToReceive ) ; require ( sucsTrTk == true ) ; msgSndr [ msg . sender ] = 0 ; return true ; }
function isFinalized ( bytes32 question_id ) view public returns ( bool ) { }
function releaseLockedToken ( ) external { require ( getState ( ) == State . Success ) ; require ( balanceOf [ lockedTokenHolder ] > 0x0 ) ; require ( block . number >= unlockedAtBlockNumber ) ; balanceOf [ devsHolder ] = safeAdd ( balanceOf [ devsHolder ] , balanceOf [ lockedTokenHolder ] ) ; emit Transfer ( lockedTokenHolder , devsHolder , balanceOf [ lockedTokenHolder ] ) ; balanceOf [ lockedTokenHolder ] = 0 ; }
function finalize ( ) public notFinalized onlyOwner returns ( bool ) { finalized = true ; emit Finalize ( ) ; return true ; }
function onApprove ( address owner , address spender , uint256 amount ) public constant returns ( bool allow ) ;
function _transfer ( address from , address to , uint quantity ) internal returns ( bool ) { require ( to != address ( 0 ) , "Transfers to 0x0 disallowed." ) ; balanceOf [ from ] = safeSub ( balanceOf [ from ] , quantity ) ; balanceOf [ to ] += quantity ; emit Transfer ( from , to , quantity ) ; return true ; }
function getUserImages ( address _user ) public view returns ( uint [ ] ) { return ownedTokens [ _user ] ; }
function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || mAuthorizedOperators [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }
function transfer ( address target , uint256 amount ) ifAuthorised { if ( amount == 0 || shareholders [ msg . sender ] . shares < amount ) throw ; shareholders [ msg . sender ] . shares -= amount ; if ( shareholders [ target ] . shares > 0 ) { shareholders [ target ] . shares += amount ; } else { shareholders [ target ] . shares = amount ; shareholders [ target ] . limited = true ; } Transfer ( msg . sender , target , amount ) ; }
function changeAllowBeneficialInvestments ( bool _allowBeneficialInvestments ) public onlyOwner { require ( _allowBeneficialInvestments != allowBeneficialInvestments , "Does not change value" ) ; allowBeneficialInvestments = _allowBeneficialInvestments ; emit SetAllowBeneficialInvestments ( allowBeneficialInvestments ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) public { require ( ! jackpotCompleted ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _approved ( _to , _tokenId ) ) ; require ( _addressNotNull ( _to ) ) ; _transfer ( _from , _to , _tokenId ) ; }
function depositToken ( address token , uint256 amount ) external { require ( amount > 0 ) ; require ( tokenAddress2Id [ token ] != 0 ) ; addUser ( msg . sender ) ; require ( ERC20 ( token ) . transferFrom ( msg . sender , this , amount ) ) ; balances [ token ] [ msg . sender ] = balances [ token ] [ msg . sender ] . add ( amount ) ; Deposit ( token , msg . sender , amount , balances [ token ] [ msg . sender ] ) ; }
function modifyWhitelist ( address _investor , bool _valid ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = _valid ; emit LogModifyWhitelist ( _investor , now , msg . sender , _valid ) ; }
function executeOrders ( address [ ] tokenAddresses , bool [ ] buyOrSell , uint256 [ ] amountToObtain , uint256 [ ] amountToGive , address [ ] tokenForOrder , address [ ] exchanges , address [ 8 ] [ ] orderAddresses , uint256 [ 6 ] [ ] orderValues , uint256 [ ] exchangeFees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s ) public payable { require ( tokenAddresses . length == buyOrSell . length && buyOrSell . length == amountToObtain . length && amountToObtain . length == amountToGive . length ) ; require ( tokenForOrder . length == exchanges . length && exchanges . length == orderAddresses . length && orderAddresses . length == orderValues . length && orderValues . length == exchangeFees . length && exchangeFees . length == v . length && v . length == r . length && r . length == s . length ) ; internalOrderExecution ( Tokens ( tokenAddresses , buyOrSell , amountToObtain , amountToGive ) , DEXOrders ( tokenForOrder , exchanges , orderAddresses , orderValues , exchangeFees , v , r , s ) ) ; }
function setWithdrawAnnounceDelay ( uint32 _delay ) external onlyOwner notMoreThanMaxDelay ( _delay ) { withdrawAnnounceDelay = _delay ; }
function burn ( uint256 _value ) public returns ( bool success ) { uint256 balanceOfSender = erc20Store . balances ( msg . sender ) ; require ( _value <= balanceOfSender ) ; erc20Store . setBalance ( msg . sender , balanceOfSender - _value ) ; erc20Store . setTotalSupply ( erc20Store . totalSupply ( ) - _value ) ; erc20Proxy . emitTransfer ( msg . sender , address ( 0 ) , _value ) ; return true ; }
function quoteAsk ( ) public returns ( uint256 ) { if ( initialSaleComplete ) { ask = fracExp ( 1e18 , R , ( _totalSupply / 1e18 ) + 1 , P ) ; } else { ask = ICOask ; } return ask ; }
function claimEther ( ) public onlyOwner { if ( this . balance > 0 ) { owner . transfer ( this . balance ) ; } }
function setOfferPrice ( uint256 price ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , "You are unknown and not allowed to trade." ) ; require ( price >= sellFloor && ( sellCeiling == 0 || price <= sellCeiling ) , "Updated price is out of range." ) ; TradeOrder memory order = orderBook [ msg . sender ] ; require ( order . price != 0 || order . expiry != 0 , "There is no existing order to modify." ) ; order . price = price ; orderBook [ msg . sender ] = order ; emit TokenOfferChanged ( msg . sender , order . quantity , order . price , order . expiry ) ; }
function abortFunding ( ) ;
function orderBlockNumber ( bytes32 _orderID ) external view returns ( uint256 ) { return orders [ _orderID ] . blockNumber ; }
function createChannelId ( address initiator , address beneficiary , uint amount , uint commission , uint createdAt , uint expiresAt , bytes32 hashedSecret ) public pure returns ( bytes32 channelId ) { channelId = keccak256 ( abi . encodePacked ( initiator , beneficiary , amount , commission , createdAt , expiresAt , hashedSecret ) ) ; }
function setCampaignEndDateById ( bytes32 bidId , uint newEndDate ) public onlyIfCampaignExists ( "setCampaignEndDateById" , bidId ) onlyIfWhitelisted ( "setCampaignEndDateById" , msg . sender ) { campaigns [ bidId ] . setEndDate ( newEndDate ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
function getCollateralMarketsLength ( ) public view returns ( uint ) { return collateralMarkets . length ; }
function getTokensMinted ( ) public view returns ( uint256 ) { uint256 tokensMinted ; for ( uint8 i = 0 ; i < mintedPerTierTotal . length ; i ++ ) { tokensMinted = tokensMinted . add ( mintedPerTierTotal [ i ] ) ; } return tokensMinted ; }
function checkHolesAndDistributePurchaseFunds ( Geometry . Rect [ ] memory subPlots , uint256 [ ] memory areaIndices ) private returns ( uint256 ) { uint256 remainingBalance = msg . value ; uint256 owedToSeller = 0 ; for ( uint256 areaIndicesIndex = 0 ; areaIndicesIndex < areaIndices . length ; areaIndicesIndex ++ ) { uint256 ownershipIndex = areaIndices [ areaIndicesIndex ] ; Geometry . Rect memory currentOwnershipRect = Geometry . Rect ( ownership [ ownershipIndex ] . x , ownership [ ownershipIndex ] . y , ownership [ ownershipIndex ] . w , ownership [ ownershipIndex ] . h ) ; require ( Geometry . rectContainedInside ( subPlots [ areaIndicesIndex ] , currentOwnershipRect ) ) ; for ( uint256 holeIndex = 0 ; holeIndex < holes [ ownershipIndex ] . length ; holeIndex ++ ) { PlotOwnership memory holePlot = ownership [ holes [ ownershipIndex ] [ holeIndex ] ] ; Geometry . Rect memory holeRect = Geometry . Rect ( holePlot . x , holePlot . y , holePlot . w , holePlot . h ) ; require ( ! Geometry . doRectanglesOverlap ( subPlots [ areaIndicesIndex ] , holeRect ) ) ; } uint256 sectionPrice = getPriceOfPlot ( subPlots [ areaIndicesIndex ] , ownershipIndex ) ; remainingBalance = SafeMath . sub ( remainingBalance , sectionPrice ) ; owedToSeller = SafeMath . add ( owedToSeller , sectionPrice ) ; if ( areaIndicesIndex == areaIndices . length - 1 || ownershipIndex != areaIndices [ areaIndicesIndex + 1 ] ) { address ( ownership [ ownershipIndex ] . owner ) . transfer ( owedToSeller ) ; emit PlotSectionSold ( ownershipIndex , owedToSeller , msg . sender , ownership [ ownershipIndex ] . owner ) ; owedToSeller = 0 ; } } return remainingBalance ; }
function calculatePoolAmount ( uint gameId ) internal view returns ( uint ) { uint rawPoolAmount = calculateRawPoolAmount ( gameId ) ; uint houseCutAmount = calculateHouseCutAmount ( gameId ) ; return rawPoolAmount . sub ( houseCutAmount ) ; }
function claimPlotMultipleWithData ( uint256 [ ] _deedIds , uint256 _buyoutPrice , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { uint256 buyAmount = _deedIds . length ; uint256 etherRequired ; if ( freeClaimAllowance [ msg . sender ] > 0 ) { if ( freeClaimAllowance [ msg . sender ] > buyAmount ) { freeClaimAllowance [ msg . sender ] -= buyAmount ; etherRequired = 0 ; } else { uint256 freeAmount = freeClaimAllowance [ msg . sender ] ; delete freeClaimAllowance [ msg . sender ] ; etherRequired = unclaimedPlotPrice . mul ( buyAmount - freeAmount ) ; } } else { etherRequired = unclaimedPlotPrice . mul ( buyAmount ) ; } uint256 offset = plots . length ; plots . length = plots . length . add ( _deedIds . length ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( validIdentifier ( _deedId ) ) ; require ( identifierToOwner [ _deedId ] == address ( 0 ) ) ; plots [ offset + i ] = uint32 ( _deedId ) ; _transfer ( address ( 0 ) , msg . sender , _deedId ) ; _setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; uint256 claimDividends = _calculateAndAssignClaimDividends ( _deedId ) ; etherRequired = etherRequired . add ( claimDividends ) ; initialPricePaid [ _deedId ] = unclaimedPlotPrice . add ( claimDividends ) ; setInitialBuyoutPrice ( _deedId , _buyoutPrice ) ; } require ( msg . value >= etherRequired ) ; uint256 excess = msg . value - etherRequired ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function currentBlock ( ) public constant notBeforeGenesis returns ( uint256 ) { return block . number . sub ( genesis ) ; }
function isGroupExists ( bytes32 _groupName ) public view returns ( bool ) { return groupName2index [ _groupName ] != 0 ; }
function claimTokensByUser ( ) public { require ( state == State . Successful ) ; uint256 temp = pending [ msg . sender ] ; pending [ msg . sender ] = 0 ; require ( tokenReward . transfer ( msg . sender , temp ) ) ; emit LogContributorsPayout ( msg . sender , temp ) ; }
function closeChannel ( uint256 channel_identifier , address partner , bytes32 balance_hash , uint256 nonce , bytes32 additional_hash , bytes signature ) isOpen ( channel_identifier ) public { require ( channel_identifier == getChannelIdentifier ( msg . sender , partner ) ) ; address recovered_partner_address ; Channel storage channel = channels [ channel_identifier ] ; channel . state = ChannelState . Closed ; channel . participants [ msg . sender ] . is_the_closer = true ; channel . settle_block_number += uint256 ( block . number ) ; if ( nonce > 0 ) { recovered_partner_address = recoverAddressFromBalanceProof ( channel_identifier , balance_hash , nonce , additional_hash , signature ) ; require ( partner == recovered_partner_address ) ; updateBalanceProofData ( channel , recovered_partner_address , nonce , balance_hash ) ; } emit ChannelClosed ( channel_identifier , msg . sender , nonce ) ; }
function withdrawRewards ( address _user , uint256 _value ) public onlyOwnerOrAllowed { require ( rewardedBalance [ _user ] >= _value ) ; rewardedBalance [ _user ] -= _value ; appc . transfer ( _user , _value ) ; }
function ( ) payable internal { uint amount = msg . value * buyPrice ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value < 10 ** 17 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
function addManyWhitelist ( address [ ] _accounts ) external whenNotPaused onlyAdmin { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { if ( _accounts [ i ] != address ( 0 ) && ! whitelist [ _accounts [ i ] ] ) { whitelist [ _accounts [ i ] ] = true ; emit WhitelistAdded ( _accounts [ i ] ) ; } } }
function getTeam ( uint256 _tokenId ) public view returns ( string teamName , uint256 sellingPrice , address owner ) { Team storage team = teams [ _tokenId ] ; teamName = team . name ; sellingPrice = teamIndexToPrice [ _tokenId ] ; owner = teamIndexToOwner [ _tokenId ] ; }
function ( ) payable public { require ( getState ( ) != State . Success ) ; require ( getState ( ) != State . Failure ) ; require ( msg . value != 0 ) ; if ( getState ( ) == State . PrivateFunding ) { require ( msg . value >= minPrivateContribution ) ; } else if ( getState ( ) == State . PreFunding ) { require ( msg . value >= minPreContribution && msg . value < maxContributionAmount ) ; } else { require ( msg . value >= minContributionAmount && msg . value < maxContributionAmount ) ; } uint256 createdTokens = safeMul ( msg . value , tokensPerEther ) ; uint256 brokerBonus = 0 ; uint256 earlyBonus = safeDiv ( safeMul ( createdTokens , _getEarlyBonus ( ) ) , hundredPercent ) ; createdTokens = safeAdd ( createdTokens , earlyBonus ) ; if ( getState ( ) == State . PrivateFunding ) { require ( safeAdd ( tokensSold , createdTokens ) <= tokenPrivateMax ) ; } else { require ( safeAdd ( tokensSold , createdTokens ) <= tokenCreationMax ) ; } tokensSold = safeAdd ( tokensSold , createdTokens ) ; collectedETH = safeAdd ( collectedETH , msg . value ) ; if ( referrals [ msg . sender ] != 0x0 ) { brokerBonus = safeDiv ( safeMul ( createdTokens , referralBonus ) , hundredPercent ) ; bonus [ referrals [ msg . sender ] ] = safeAdd ( bonus [ referrals [ msg . sender ] ] , brokerBonus ) ; emit ReferralBonus ( msg . sender , referrals [ msg . sender ] , brokerBonus ) ; } funders [ msg . sender ] = safeAdd ( funders [ msg . sender ] , msg . value ) ; investors [ msg . sender ] = safeAdd ( investors [ msg . sender ] , createdTokens ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , createdTokens ) ; emit FundTransfer ( msg . sender , msg . value , createdTokens , block . number ) ; emit Transfer ( 0 , msg . sender , createdTokens ) ; }
function successful ( ) public { require ( state == State . Successful ) ; uint256 temp = tokenReward . balanceOf ( address ( this ) ) ; tokenReward . transfer ( creator , temp ) ; emit LogContributorsPayout ( creator , temp ) ; WGRholder . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( WGRholder ) ; }
function close ( ) public onlyOwner returns ( bool ) { require ( orderStatus != OrderStatus . TransactionCompleted ) ; require ( transactionCompletedAt == 0 ) ; orderStatus = OrderStatus . TransactionCompleted ; transactionCompletedAt = uint32 ( block . timestamp ) ; return true ; }
function _withdrawEquity ( address asset , uint amount ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK ) ; } uint cash = getCash ( asset ) ; ( Error err0 , uint equity ) = addThenSub ( cash , markets [ asset ] . totalBorrows , markets [ asset ] . totalSupply ) ; if ( err0 != Error . NO_ERROR ) { return fail ( err0 , FailureInfo . EQUITY_WITHDRAWAL_CALCULATE_EQUITY ) ; } if ( amount > equity ) { return fail ( Error . EQUITY_INSUFFICIENT_BALANCE , FailureInfo . EQUITY_WITHDRAWAL_AMOUNT_VALIDATION ) ; } Error err2 = doTransferOut ( asset , admin , amount ) ; if ( err2 != Error . NO_ERROR ) { return fail ( err2 , FailureInfo . EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED ) ; } emit EquityWithdrawn ( asset , equity , amount , admin ) ; return uint ( Error . NO_ERROR ) ; }
function getTokensForValue ( uint256 value ) public view returns ( uint256 ) { return value . mul ( rate ) ; }
function collect ( ) isOwner { require ( this . balance > 0 ) ; require ( minimalGoalReached ) ; withdraw ( this . balance ) ; }
function symbol ( ) public view returns ( string ) { return "AOC" ; }
function computeBids ( uint _count ) public onlyOwner { require ( status == state . decrypted ) ; require ( _count > 0 ) ; uint count = _count ; if ( bids_sorted_count == 0 ) { status = state . failure ; emit Failure ( 0 , 0 ) ; return ; } require ( bids_computed_cursor < bids_sorted_count ) ; BidData memory bid ; do { bid = bids_sorted [ bids_computed_cursor ] ; if ( bid . share_price . mul ( computed_shares_sold ) . add ( bid . share_price ) > fundraise_max ) { if ( bids_computed_cursor > 0 ) { bids_computed_cursor -- ; } bid = bids_sorted [ bids_computed_cursor ] ; break ; } computed_shares_sold = computed_shares_sold . add ( bid . shares_count ) ; computed_fundraise = bid . share_price . mul ( computed_shares_sold ) ; emit Computed ( bid . origin_index , bid . share_price , bid . shares_count ) ; bids_computed_cursor ++ ; count -- ; } while ( count > 0 && bids_computed_cursor < bids_sorted_count && ( computed_fundraise < fundraise_max && computed_shares_sold < max_shares_to_sell ) ) ; if ( bids_computed_cursor == bids_sorted_count || computed_fundraise >= fundraise_max || computed_shares_sold >= max_shares_to_sell ) { final_share_price = bid . share_price ; if ( computed_shares_sold >= max_shares_to_sell ) { computed_shares_sold = max_shares_to_sell ; computed_fundraise = final_share_price . mul ( computed_shares_sold ) ; winner_bids = bids_computed_cursor ; status = state . success ; emit Success ( computed_fundraise , final_share_price , computed_shares_sold ) ; return ; } if ( computed_fundraise . add ( final_share_price . mul ( 1 ) ) >= fundraise_max ) { computed_fundraise = fundraise_max ; winner_bids = bids_computed_cursor ; status = state . success ; emit Success ( computed_fundraise , final_share_price , computed_shares_sold ) ; return ; } if ( bids_computed_cursor == bids_sorted_count ) { if ( computed_shares_sold >= min_shares_to_sell ) { winner_bids = bids_computed_cursor ; status = state . success ; emit Success ( computed_fundraise , final_share_price , computed_shares_sold ) ; return ; } else { status = state . failure ; emit Failure ( computed_fundraise , final_share_price ) ; return ; } } } }
function changeController ( address _newController ) public onlyOwner { fcc . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
function changeChampsName ( uint _champId , string _name ) external onlyOwnerOfChamp ( _champId ) { champToName [ _champId ] = _name ; }
function transferFrom ( address from , address to , uint amount ) public notDeprecated returns ( bool success ) { require ( lib . transferFrom ( lib . getTokenSymbol ( address ( this ) ) , from , to , amount , "0x0" ) , "Error: Unable to transfer funds. Please check your parameters and ensure the spender has the approved amount of funds to transfer." ) ; return true ; }
function getMinerOffsetOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return blockOffset ( miners [ _miner ] . block ) ; }
function confirmImplChange ( bytes32 _lockId ) public onlyCustodian { erc20Impl = getImplChangeReq ( _lockId ) ; delete implChangeReqs [ _lockId ] ; emit ImplChangeConfirmed ( _lockId , address ( erc20Impl ) ) ; }
function goalReached ( ) public constant returns ( bool ) { if ( tokensSold >= CAP ) { token . transfer ( tokenAddressWallet , token . balanceOf ( this ) ) ; return true ; } return false ; }
function getCurrencySymbol ( ) external view returns ( bytes32 ) ;
function takeOrder ( address onExchange , uint id , uint quantity ) returns ( bool success ) { success = SimpleMarket ( onExchange ) . buy ( id , quantity ) ; OrderUpdated ( id ) ; }
function closingAddress ( ) constant returns ( address ) { return data . closing_address ; }
function symbol ( ) external pure returns ( string ) { return SYMBOL ; }
function referrersOf ( ) public view returns ( uint256 [ ] ) { return users [ addressToUser [ msg . sender ] ] . referrersByLevel ; }
function invest ( bytes16 _customerUuid ) whenNotPaused inStatus ( Status . ICO ) public payable { investInternal ( msg . sender , _customerUuid ) ; }
function mint ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) requiresPermission whenNotPaused { _mint ( _to , _amount ) ; }
function release ( ) onlyBeneficiary public { require ( now >= cliff ) ; _releaseTo ( beneficiary ) ; }
function transferAndCall ( address _receiver , uint256 _amount , bytes32 _data ) public returns ( bool success ) { transfer ( _receiver , _amount ) ; success = TokenReceiver ( _receiver ) . tokenFallback ( msg . sender , _amount , _data ) ; require ( success ) ; }
function setRequestBurnerContract ( address _requestBurnerContract ) external onlyOwner { requestBurnerContract = _requestBurnerContract ; }
function currentClaimPriceInFinney ( ) constant returns ( uint priceInFinney ) { uint valueWei = currentClaimPriceWei ( ) ; return roundMoneyUpToWholeFinney ( valueWei ) ; }
function approve ( address _to , uint _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; require ( msg . sender != _to ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; }
function getTeamId ( uint256 _tokenId ) external view returns ( uint256 ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; uint256 teamId = uint256 ( uint8 ( obj . assetDetails >> 96 ) ) ; return uint256 ( teamId ) ; }
function totalListings ( ) public view returns ( uint256 ) { return forSalePixelconIndexes . length ; }
function proposeVersion ( address ofVersion ) { versionToProposalIds [ ofVersion ] = propose ( address ( this ) , new bytes ( 0 ) , 0 ) ; }
function _createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) internal { require ( _excluded . length <= EXCLUDED_ADDRESS_LIMIT , "Too many addresses excluded" ) ; require ( _expiry > _maturity , "Expiry is before maturity" ) ; require ( _expiry > now , "Expiry is in the past" ) ; require ( msg . value > 0 , "No dividend sent" ) ; require ( _checkpointId <= ISecurityToken ( securityToken ) . currentCheckpointId ( ) ) ; require ( _name [ 0 ] != 0 ) ; uint256 dividendIndex = dividends . length ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupplyAt ( _checkpointId ) ; uint256 excludedSupply = 0 ; dividends . push ( Dividend ( _checkpointId , now , _maturity , _expiry , msg . value , 0 , 0 , false , 0 , 0 , _name ) ) ; for ( uint256 j = 0 ; j < _excluded . length ; j ++ ) { require ( _excluded [ j ] != address ( 0 ) , "Invalid address" ) ; require ( ! dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] , "duped exclude address" ) ; excludedSupply = excludedSupply . add ( ISecurityToken ( securityToken ) . balanceOfAt ( _excluded [ j ] , _checkpointId ) ) ; dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] = true ; } dividends [ dividendIndex ] . totalSupply = currentSupply . sub ( excludedSupply ) ; emit EtherDividendDeposited ( msg . sender , _checkpointId , now , _maturity , _expiry , msg . value , currentSupply , dividendIndex , _name ) ; }
function etherTransfer ( address _to , uint _value ) onlyOwner public { _to . transfer ( _value ) ; }
function onERC721Received ( address _from , uint256 _tokenId , bytes _data ) external returns ( bytes4 ) ;
function trade ( ERC20 src , uint srcAmount , ERC20 dest , address destAddress , uint maxDestAmount , uint minConversionRate , address walletId ) public payable returns ( uint ) { bytes memory hint ; return tradeWithHint ( src , srcAmount , dest , destAddress , maxDestAmount , minConversionRate , walletId , hint ) ; }
function contribute ( ) public notFinished payable { uint256 tokenBought ; totalRaised = totalRaised . add ( msg . value ) ; tokenBought = msg . value . mul ( price ) ; totalDistributed = totalDistributed . add ( tokenBought ) ; require ( beneficiary . send ( msg . value ) ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; LogContributorsPayout ( msg . sender , tokenBought ) ; checkIfFundingCompleteOrExpired ( ) ; }
function registerModule ( address _moduleFactory ) external whenNotPausedOrOwner { if ( IFeatureRegistry ( getAddress ( Encoder . getKey ( "featureRegistry" ) ) ) . getFeatureStatus ( "customModulesAllowed" ) ) { require ( msg . sender == IOwnable ( _moduleFactory ) . owner ( ) || msg . sender == owner ( ) , "msg.sender must be the Module Factory owner or registry curator" ) ; } else { require ( msg . sender == owner ( ) , "Only owner allowed to register modules" ) ; } require ( getUint ( Encoder . getKey ( "registry" , _moduleFactory ) ) == 0 , "Module factory should not be pre-registered" ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; uint256 i ; uint256 j ; uint8 [ ] memory moduleTypes = moduleFactory . getTypes ( ) ; for ( i = 1 ; i < moduleTypes . length ; i ++ ) { for ( j = 0 ; j < i ; j ++ ) { require ( moduleTypes [ i ] != moduleTypes [ j ] , "Type mismatch" ) ; } } require ( moduleTypes . length != 0 , "Factory must have type" ) ; uint8 moduleType = moduleFactory . getTypes ( ) [ 0 ] ; set ( Encoder . getKey ( "registry" , _moduleFactory ) , uint256 ( moduleType ) ) ; set ( Encoder . getKey ( "moduleListIndex" , _moduleFactory ) , uint256 ( getArrayAddress ( Encoder . getKey ( "moduleList" , uint256 ( moduleType ) ) ) . length ) ) ; pushArray ( Encoder . getKey ( "moduleList" , uint256 ( moduleType ) ) , _moduleFactory ) ; emit ModuleRegistered ( _moduleFactory , IOwnable ( _moduleFactory ) . owner ( ) ) ; }
function transfer ( address _to , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }
function getWhale ( uint256 _tokenId ) public view returns ( uint256 Id , string whaleName , uint256 sellingPrice , address owner ) { Whale storage whale = whales [ _tokenId ] ; Id = _tokenId ; whaleName = whale . name ; sellingPrice = whaleIndexToPrice [ _tokenId ] ; owner = whaleIndexToOwner [ _tokenId ] ; }
function authorize ( string _contractName , address _accessor ) external view returns ( bool ) ;
function contribute ( uint _bountyId , uint _value ) payable public validateBountyArrayIndex ( _bountyId ) isBeforeDeadline ( _bountyId ) isNotDead ( _bountyId ) amountIsNotZero ( _value ) transferredAmountEqualsValue ( _bountyId , _value ) { bounties [ _bountyId ] . balance += _value ; ContributionAdded ( _bountyId , msg . sender , _value ) ; }
function getFeeParams ( ) public view returns ( uint bps , uint min , uint max , uint flat , bytes feeMsg , address feeAccount ) { return ( lib . getFeeBPS ( lib . getFeeContract ( address ( this ) ) ) , lib . getFeeMin ( lib . getFeeContract ( address ( this ) ) ) , lib . getFeeMax ( lib . getFeeContract ( address ( this ) ) ) , lib . getFeeFlat ( lib . getFeeContract ( address ( this ) ) ) , lib . getFeeMsg ( lib . getFeeContract ( address ( this ) ) ) , lib . getFeeContract ( address ( this ) ) ) ; }
function getRabbit ( uint _tokenId ) external view returns ( uint32 outStar , uint32 outExplosive , uint32 outEndurance , uint32 outNimble , uint64 outGenes , uint64 outBirthTime ) { RabbitData storage rbt = rabbits [ _tokenId ] ; outStar = rbt . star ; outExplosive = rbt . explosive ; outEndurance = rbt . endurance ; outNimble = rbt . nimble ; outGenes = rbt . genes ; outBirthTime = rbt . birthTime ; }
function finalizeSale ( ) public onlyOwner { require ( crowdsaleClosed == false ) ; crowdsaleClosed = true ; uint totalSold = tokensSoldOnPublicRound + preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 + privateSalesTokensSold ; bountyAmount = totalSold / 980 * 15 ; yearlyTeamAmount = totalSold / 980 * 5 / 3 ; }
function updateERC165Cache ( address _contract , bytes4 _interfaceId ) public { interfaces [ _contract ] [ _interfaceId ] = implementsERC165InterfaceNoCache ( _contract , _interfaceId ) ? _contract : 0 ; erc165Cached [ _contract ] [ _interfaceId ] = true ; }
function addChunk2ToWhiteList ( ) external onlyOwner { require ( ! chunk2IsAdded ) ; addToWhitelist ( 0x6A35d29D8F63E4D8A8E5418Be9342A48c4C8eF07 , 0.5 ether ) ; addToWhitelist ( 0x6b2a80FB3C8Eca5144E6F129a447b9D06224a402 , 0.5 ether ) ; addToWhitelist ( 0x6b8ebca41389689e8875af541a2fa4328ac49917 , 0.5 ether ) ; addToWhitelist ( 0x6c3Db34C768Ab1E67E2a7E973B7a83651657660b , 0.5 ether ) ; addToWhitelist ( 0x7018564dCe2c68417DFa7678541DfA0040Ca0c54 , 0.5 ether ) ; addToWhitelist ( 0x708faa43f5824d271466c119148728467f66e233 , 0.5 ether ) ; addToWhitelist ( 0x71526410C961727a89155D6a32Bb75f9a9d755F5 , 0.5 ether ) ; addToWhitelist ( 0x746B426D0B8e272Ef7402db7CE0FD01C2B1c4aDE , 0.5 ether ) ; addToWhitelist ( 0x762C73603f5456c4ad729b3B46464269bcD7C212 , 0.5 ether ) ; addToWhitelist ( 0x7a0D19955bBf6cff0D86F6e72355A8AFf3c0d74F , 0.5 ether ) ; addToWhitelist ( 0x7Cf017bDe8af2DfC67cb3f1b16943A0620eA1B54 , 0.5 ether ) ; addToWhitelist ( 0x807bAf9e22F4e1E7A5Fcf4B5721ba54666d71421 , 0.5 ether ) ; addToWhitelist ( 0x810f1C65f9C7c566E14a1E8ECA7b36b78C6da3A8 , 0.5 ether ) ; addToWhitelist ( 0x871a314d75BdF106420B9e08314e776d2746E0Eb , 0.5 ether ) ; addToWhitelist ( 0x88Cf04474CFD3b9Bc4110FfC2980Bc56feBF0465 , 0.5 ether ) ; addToWhitelist ( 0x8914316B6505b39e706a208A8E91ab8F79eFA7Cf , 0.5 ether ) ; addToWhitelist ( 0x8b104344F397aFC33Ee55C743a0FbD7d956201cD , 0.5 ether ) ; addToWhitelist ( 0x8Bd5306d0c08Eaa2D9AabaED62297A8AB42db1de , 0.5 ether ) ; addToWhitelist ( 0x8Be1843532E5eE0142420fe627a097a0E0681e97 , 0.5 ether ) ; addToWhitelist ( 0x8c269040283c4112198bc59120ad2bcd70e6b387 , 0.5 ether ) ; addToWhitelist ( 0x8E14437E18B1091B369c6ff6ecCa73D648aCA3bd , 0.5 ether ) ; addToWhitelist ( 0x8Fc9040b8B9305458716e90F83D9b656a07ae7e6 , 0.5 ether ) ; addToWhitelist ( 0x906d9e4D0E028FE85625d06268A437Bb58753301 , 0.5 ether ) ; addToWhitelist ( 0x91Fe65df20b13CA260990e096d4EBDbD64f7b399 , 0.5 ether ) ; addToWhitelist ( 0x92cBbf4A87953975c39EaA2bF70deDEbC356358b , 0.5 ether ) ; addToWhitelist ( 0x95D4914d4f08732A169367674A8BE026c02c5B44 , 0.5 ether ) ; addToWhitelist ( 0x985116bBCcEE828d439c4F6F9233016bf1e95669 , 0.5 ether ) ; addToWhitelist ( 0x9976cF5617F5E4022CdC887A7A0a68E8eE5dBA22 , 0.5 ether ) ; addToWhitelist ( 0x9A7379c8aF6765aa267d338A20D197DD1544bF9b , 0.5 ether ) ; addToWhitelist ( 0x9DEFB6A85680E11b6aD8AD4095e51464bB4C0C66 , 0.5 ether ) ; addToWhitelist ( 0xA02896e448A35DeD03C48c2986A545779ed87edd , 0.5 ether ) ; addToWhitelist ( 0xa460A24F606d4ABba5041B162E06D42aD6f09157 , 0.5 ether ) ; addToWhitelist ( 0xaB91cF12f8e133C7B1C849d87997dca895cE0BCB , 0.5 ether ) ; addToWhitelist ( 0xac935E0dD7F90851E0c6EE641cd30B800e35f7A8 , 0.5 ether ) ; addToWhitelist ( 0xae41F73635b6F5F9556Cd3B0d3970aDA5Fb0C1b5 , 0.5 ether ) ; addToWhitelist ( 0xB16fE19652ceDf4Ba2568b4886CeE29D4e0617B0 , 0.5 ether ) ; addToWhitelist ( 0xB2F19E5457404dCaCd2d6344592e5a657DFcA27b , 0.5 ether ) ; addToWhitelist ( 0xB33cc3147d70Ce2aF31B2B90411BD6333EeA0EA7 , 0.5 ether ) ; addToWhitelist ( 0xb49a6DD81a847f3A704D0C11C6e1a7C65C47d215 , 0.5 ether ) ; addToWhitelist ( 0xb75312cdfBee6B6104a7161E27dbd48bb253E186 , 0.5 ether ) ; addToWhitelist ( 0xB87e73ad25086C43a16fE5f9589Ff265F8A3A9Eb , 0.5 ether ) ; addToWhitelist ( 0xc12549d486e20835960Fb3A44ba67fD353B1C48a , 0.5 ether ) ; addToWhitelist ( 0xc4Eab1eAaCbf628F0f9Aee4B7375bDE18dd173C4 , 0.5 ether ) ; addToWhitelist ( 0xc8B15B3189b8C6e90ff330CBA190153fF0A9997e , 0.5 ether ) ; addToWhitelist ( 0xCb033bE278d7bD297a2b1Cc6201113480daC579F , 0.5 ether ) ; addToWhitelist ( 0xCb570fE877CA6B7dE030afaf9483f58F774df135 , 0.5 ether ) ; addToWhitelist ( 0xcD4929fdDC83Aca93cD4a75bD12780DaDF51870b , 0.5 ether ) ; addToWhitelist ( 0xcdc22860Ff346ead18ECA5E30f0d302a95F33A19 , 0.5 ether ) ; addToWhitelist ( 0xD26BA3C03fBC1EA352b5F77B2c1F2881d03D1e2F , 0.5 ether ) ; addToWhitelist ( 0xd454ED303748Bb5a433388F9508433ba5d507030 , 0.5 ether ) ; addToWhitelist ( 0xd4d1197fed5F9f3679497Df3604147087B85Ce39 , 0.5 ether ) ; addToWhitelist ( 0xd83F072142C802A6fA3921d6512B25a7c1A216b1 , 0.5 ether ) ; chunk2IsAdded = true ; }
function approve ( address _who , uint256 _value ) public returns ( bool ) { require ( _who != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _who ] == 0 ) ; allowed [ msg . sender ] [ _who ] = _value ; Approval ( msg . sender , _who , _value ) ; return true ; }
function setStreamerContract ( address _contractAddress , uint256 _maxAmount ) onlyAdministrator { require ( _maxAmount == 0 || streamerContractMaxAmount == 0 ) ; streamerContract = _contractAddress ; streamerContractMaxAmount = _maxAmount ; StreamerContractChanged ( streamerContract , streamerContractMaxAmount ) ; }
function setBuyFee ( uint32 _buyFeeMilliPercent ) onlyOwner public { require ( _buyFeeMilliPercent < MILLI_PERCENT_DIVIDER ) ; buyFeeMilliPercent = _buyFeeMilliPercent ; }
function _removeModuleWithIndex ( uint8 _type , uint256 _index ) internal { uint256 length = modules [ _type ] . length ; modules [ _type ] [ _index ] = modules [ _type ] [ length - 1 ] ; modules [ _type ] . length = length - 1 ; if ( ( length - 1 ) != _index ) { uint8 [ ] memory newTypes = modulesToData [ modules [ _type ] [ _index ] ] . moduleTypes ; for ( uint256 i = 0 ; i < newTypes . length ; i ++ ) { if ( newTypes [ i ] == _type ) { modulesToData [ modules [ _type ] [ _index ] ] . moduleIndexes [ i ] = _index ; } } } }
function setBeneficiary ( address newBeneficiary ) external only ( owner ) { beneficiary = newBeneficiary ; }
function ( ) payable { require ( ! saleHasEnded ) ; require ( now > PRESALE_START_DATE ) ; require ( now < PRESALE_END_DATE ) ; require ( msg . value >= MINIMUM_PARTICIPATION_AMOUNT ) ; require ( msg . value <= MAXIMUM_PARTICIPATION_AMOUNT ) ; if ( isWhitelistingActive ) { require ( earlyParticipantWhitelist [ msg . sender ] ) ; } require ( safeIncrement ( totalFunding , msg . value ) <= PRESALE_MAXIMUM_FUNDING ) ; addBalance ( msg . sender , msg . value ) ; }
function onApprove ( address , address , uint ) returns ( bool ) { return ( transferable || getBlockTimestamp ( ) >= October12_2017 ) ; }
function doFinalizeSale ( ) internal onlyOwner { if ( saleFinalized ) revert ( ) ; uint256 teamTokens = safeMul ( token . totalSupply ( ) , teamTokenRatio ) ; if ( teamTokens > 0 ) { if ( ! token . mint ( tokenOwnerWallet , teamTokens ) ) revert ( ) ; } if ( this . balance > 0 ) { if ( ! fundOwnerWallet . send ( this . balance ) ) revert ( ) ; } saleFinalized = true ; saleStopped = true ; LogFinalized ( tokenOwnerWallet , teamTokens ) ; }
function setTierRates ( uint256 tier1 , uint256 tier2 , uint256 tier3 , uint256 tier4 ) external onlyOwner whenNotPaused { require ( tier1 > 0 && tier2 > 0 && tier3 > 0 && tier4 > 0 ) ; rate = tier1 ; rateTier2 = tier2 ; rateTier3 = tier3 ; rateTier4 = tier4 ; }
function placeAds ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , string imageSource , string link , string text ) external whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; uint AdsId = ads . advertiseOnBlocks ( msg . sender , blocksList ( fromX , fromY , toX , toY ) , imageSource , link , text ) ; emit LogAds ( AdsId , fromX , fromY , toX , toY , imageSource , link , text , msg . sender ) ; }
function transfer ( address to , uint quantity ) public pausableIfNotSelfDestructing returns ( bool ) { return _transfer ( msg . sender , to , quantity ) ; }
function changeExchangeOperator ( address newExchangeOperator ) public only_exchange_operator { EXCHANGE_OPERATOR = newExchangeOperator ; }
function calcSharePrice ( ) view returns ( uint sharePrice ) { ( , , , , , sharePrice ) = performCalculations ( ) ; return sharePrice ; }
function getTaiAMT ( uint256 amtETH ) public constant returns ( uint256 ) { uint256 amount = amtETH / buyPrice ; amount = amount * 10 ** uint256 ( decimals ) ; return amount ; }
function getInvestorCount ( ) external view returns ( uint256 ) { return investorData . investorCount ; }
function changeSTVersionBounds ( string _boundType , uint8 [ ] _newVersion ) external ;
function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( owner_ ) ; owner_ = address ( 0 ) ; }
function getVestingQuantity ( address account , uint index ) public view returns ( uint ) { return getVestingScheduleEntry ( account , index ) [ QUANTITY_INDEX ] ; }
function getBalance ( ) public view onlyAuthorized returns ( uint ) { return address ( this ) . balance ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public { require ( approve ( _spender , _value ) ) ; IApprovalRecipient ( _spender ) . receiveApproval ( msg . sender , _value , _extraData ) ; }
function getCanvasPaintedPixelsCount ( uint32 _canvasId ) public view returns ( uint32 ) { return _getCanvas ( _canvasId ) . paintedPixelsCount ; }
function setFeeMin ( Data storage self , uint feeMin ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.min' , address ( this ) ) ) ; require ( self . Storage . setUint ( id , feeMin ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function withdrawBalance ( ) external onlyCFO { cfoAddress . transfer ( this . balance ) ; }
function getAttributeApprovalHash ( address account , address operator , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee ) external view returns ( bytes32 hash ) { return calculateAttributeApprovalHash ( account , operator , attributeTypeID , value , fundsRequired , validatorFee ) ; }
function setTokenFeeMin ( uint256 min ) public onlyOwner { tokenFeeMin = min ; }
function getBalanceTAI ( ) public constant returns ( uint256 ) { uint256 balTAI ; balTAI = balanceOf [ msg . sender ] ; return balTAI ; }
function platformLogout ( address _toLogout , uint256 _newBalance ) external isAdmin { cooldown [ _toLogout ] = now + 30 minutes ; alterBankBalance ( _toLogout , _newBalance ) ; }
function revokeAttribute ( address account , uint256 attributeTypeID ) external ;
function isState ( uint256 _tokenId , uint8 _state ) public view returns ( bool ) { return assets [ _tokenId ] . state == _state ; }
function finish ( ) onlyAdmin ( 2 ) public { if ( state != State . Successful ) { state = State . Successful ; completedAt = now ; } uint256 remanent = tokenReward . balanceOf ( this ) ; require ( creator . send ( address ( this ) . balance ) ) ; tokenReward . transfer ( creator , remanent ) ; emit LogBeneficiaryPaid ( creator ) ; emit LogContributorsPayout ( creator , remanent ) ; }
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return tokenBalanceOf [ _owner ] ; }
function burn ( address burner , uint256 _value ) public { require ( _value <= balances [ burner ] ) ; if ( _value > 0 ) { balances [ burner ] = SafeMath . sub ( balances [ burner ] , _value ) ; totalSupply = SafeMath . sub ( totalSupply , _value ) ; Burn ( burner , _value ) ; Transfer ( burner , address ( 0 ) , _value ) ; } }
function addBeneficiary ( address beneficiary , uint256 startTime , uint256 releaseTime , uint256 amount ) external onlyOwner { Info storage info = _info [ beneficiary ] ; require ( ! info . known , "This address is already known to the contract." ) ; require ( releaseTime > startTime , "Release time must be later than the start time." ) ; require ( releaseTime > block . timestamp , "End of vesting period must be somewhere in the future." ) ; info . startTime = startTime ; info . totalAmount = amount ; info . releaseTime = releaseTime ; info . known = true ; }
function finalize ( ) minCapReached salePeriodCompleted isValidState onlyBy ( owner ) external { balances [ gmtFundAddress ] = balances [ gmtFundAddress ] . add ( gmtFund ) ; assignedSupply = assignedSupply . add ( gmtFund ) ; ClaimGMT ( gmtFundAddress , gmtFund ) ; Transfer ( 0x0 , gmtFundAddress , gmtFund ) ; if ( assignedSupply < totalSupply ) { uint256 unassignedSupply = totalSupply . sub ( assignedSupply ) ; balances [ gmtFundAddress ] = balances [ gmtFundAddress ] . add ( unassignedSupply ) ; assignedSupply = assignedSupply . add ( unassignedSupply ) ; ClaimGMT ( gmtFundAddress , unassignedSupply ) ; Transfer ( 0x0 , gmtFundAddress , unassignedSupply ) ; } ethFundAddress . transfer ( this . balance ) ; isFinalized = true ; }
function tokenURI ( uint256 _tokenId ) external view returns ( string ) { require ( _tokenId < totalSupply ( ) ) ; uint256 uid ; bytes32 bid ; uid = _tokenId ; if ( uid == 0 ) { bid = '0' ; } else { while ( uid > 0 ) { bid = bytes32 ( uint ( bid ) / ( 2 ** 8 ) ) ; bid |= bytes32 ( ( ( uid % 10 ) + 48 ) * 2 ** ( 8 * 31 ) ) ; uid /= 10 ; } } return string ( abi . encodePacked ( baseUri , bid ) ) ; }
function cancelPoll ( uint _idPoll ) public { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll storage p = _polls [ _idPoll ] ; require ( ! p . canceled , "Poll has been canceled already" ) ; require ( block . timestamp <= p . endTime , "Only active polls can be canceled" ) ; if ( p . startBlock < block . number ) { require ( msg . sender == controller , "Only the controller can cancel the poll" ) ; } else { require ( p . author == msg . sender , "Only the owner can cancel the poll" ) ; } p . canceled = true ; emit PollCanceled ( _idPoll ) ; }
function vote ( uint256 _voteId , bool _supports , bool _executesIfDecided ) external voteExists ( _voteId ) { require ( canVote ( _voteId , msg . sender ) , ERROR_CAN_NOT_VOTE ) ; _vote ( _voteId , _supports , msg . sender , _executesIfDecided ) ; }
function withdrawNomins ( uint amount ) external onlyOwner { nomin . transfer ( owner , amount ) ; }
function approve ( address _approved , uint256 _tokenId ) external payable { require ( msg . sender == CaDataContract . atomOwner ( _tokenId ) || ownerOperators [ CaDataContract . atomOwner ( _tokenId ) ] [ msg . sender ] ) ; tokenApprovals [ _tokenId ] = _approved ; Approval ( CaDataContract . atomOwner ( _tokenId ) , _approved , _tokenId ) ; }
function getAttributeValidator ( address account , uint256 attributeTypeID ) external view returns ( address validator , bool isStillValid ) ;
function refund ( ) external { if ( ! funding ) throw ; if ( block . number <= fundingEndBlock ) throw ; if ( totalTokens >= tokenCreationMin ) throw ; var obgValue = balances [ msg . sender ] ; if ( obgValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalTokens -= obgValue ; var ethValue = obgValue / tokenCreationRate ; Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }
function acceptInvite ( bytes _sig ) public onlyNonUser { address inviteAddress = signingLogic . recoverSigner ( keccak256 ( abi . encodePacked ( msg . sender ) ) , _sig ) ; require ( pendingInvites [ inviteAddress ] ) ; pendingInvites [ inviteAddress ] = false ; createAccountForUser ( msg . sender ) ; emit InviteAccepted ( msg . sender , inviteAddress ) ; }
function mint ( address _to , uint256 _value ) public minterOrOwner blockLock ( msg . sender ) returns ( bool success ) { if ( totalSupply + _value <= totalSupply ) { return false ; } balances [ _to ] += _value ; totalSupply += _value ; Mint ( _to , _value , totalSupply ) ; Transfer ( 0x0 , _to , _value ) ; return true ; }
function executeVote ( uint256 _voteId ) external voteExists ( _voteId ) { require ( canExecute ( _voteId ) , ERROR_CAN_NOT_EXECUTE ) ; _executeVote ( _voteId ) ; }
function getTokenDetails ( address token ) public view returns ( address ad , uint required , bool active , uint valid ) { return ( acceptedTokens [ token ] . tokenAddress , acceptedTokens [ token ] . requiredAmount , acceptedTokens [ token ] . active , acceptedTokens [ token ] . validUntil ) ; }
function getSencBalance ( ) public view returns ( uint256 ) { return sencToken ( ) . balanceOf ( address ( this ) ) ; }
function balanceOf ( address _person ) public constant returns ( uint256 _balance ) { return balances [ _person ] ; }
function isFulfilled ( Deliverable storage self , address _creator , address _brand ) internal view returns ( bool ) { return self . fulfillment [ _creator ] && self . fulfillment [ _brand ] ; }
function drop ( address tokenContractAddress , address [ ] recipients , uint256 [ ] amounts ) public ownerOnly { require ( tokenContractAddress != 0x0 ) ; require ( recipients . length == amounts . length ) ; require ( recipients . length <= 300 ) ; ERC20 tokenContract = ERC20 ( tokenContractAddress ) ; for ( uint8 i = 0 ; i < recipients . length ; i ++ ) { tokenContract . transfer ( recipients [ i ] , amounts [ i ] ) ; } }
function addHodlerStake ( address _beneficiary , uint256 _stake ) public onlyOwner beforeHodlStart { if ( _stake == 0 || _beneficiary == address ( 0 ) ) return ; if ( hodlerStakes [ _beneficiary ] . stake == 0 ) hodlerTotalCount = hodlerTotalCount . add ( 1 ) ; hodlerStakes [ _beneficiary ] . stake = hodlerStakes [ _beneficiary ] . stake . add ( _stake ) ; hodlerTotalValue = hodlerTotalValue . add ( _stake ) ; LogHodlSetStake ( msg . sender , _beneficiary , hodlerStakes [ _beneficiary ] . stake ) ; }
function splitBid ( uint _amount ) public pure returns ( uint commission , uint paintersRewards ) { uint _rewardPerPixel = ( ( _amount - _calculatePercent ( _amount , COMMISSION ) ) ) / PIXEL_COUNT ; uint _rewards = _rewardPerPixel * PIXEL_COUNT ; return ( _amount - _rewards , _rewards ) ; }
function setWithdrawalAddress ( address _newWithdrawalAddress ) external onlyCEO { require ( _newWithdrawalAddress != address ( 0 ) ) ; withdrawalAddress = _newWithdrawalAddress ; }
function deleteInt ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete intStorage [ _key ] ; return true ; }
function list_bytesarray_from ( bytes32 _current_item , uint256 _count , function ( ) external constant returns ( bytes32 ) _function_first , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _bytes_items ) { if ( _from_start ) { _bytes_items = private_list_bytes_from_bytes ( _current_item , _count , false , _function_last , _function_next ) ; } else { _bytes_items = private_list_bytes_from_bytes ( _current_item , _count , false , _function_first , _function_previous ) ; } }
function contribute ( ) public notFinished payable { require ( msg . value > ( 10 ** 10 ) ) ; uint256 tokenBought = 0 ; totalRaised = totalRaised . add ( msg . value ) ; tokenBought = msg . value . div ( 10 ** 10 ) ; tokenBought = tokenBought . mul ( rate ) ; if ( now < dateTimeContract . toTimestamp ( 2018 , 2 , 15 ) ) { tokenBought = tokenBought . mul ( 15 ) ; tokenBought = tokenBought . div ( 10 ) ; require ( totalDistributed . add ( tokenBought ) <= 100000000 * ( 10 ** 8 ) ) ; } else if ( now < dateTimeContract . toTimestamp ( 2018 , 2 , 28 ) ) { tokenBought = tokenBought . mul ( 14 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( now < dateTimeContract . toTimestamp ( 2018 , 3 , 15 ) ) { tokenBought = tokenBought . mul ( 13 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( now < dateTimeContract . toTimestamp ( 2018 , 3 , 31 ) ) { tokenBought = tokenBought . mul ( 12 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( now < dateTimeContract . toTimestamp ( 2018 , 4 , 30 ) ) { tokenBought = tokenBought . mul ( 11 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( now < dateTimeContract . toTimestamp ( 2018 , 5 , 15 ) ) { tokenBought = tokenBought . mul ( 105 ) ; tokenBought = tokenBought . div ( 100 ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; LogContributorsPayout ( msg . sender , tokenBought ) ; checkIfFundingCompleteOrExpired ( ) ; }
function unpause ( ) external onlyCEO whenPaused { paused = false ; }
function approve ( address _spender , uint256 _amount ) public erc20 returns ( bool success ) { mAllowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
function __callback ( bytes32 _id , string _result ) public { require ( msg . sender == oraclize_cbAddress ( ) ) ; require ( ids [ _id ] == true ) ; ETHEUR = _result ; fidaPerEther = parseInt ( _result , 5 ) ; emit PriceUpdated ( _id , _result ) ; }
function getCheckpointTimes ( ) external view returns ( uint256 [ ] ) { return checkpointTimes ; }
function setKyberNetworkContract ( address _kyberNetworkAddress ) external onlyOwner { kyberContract = KyberNetwork ( _kyberNetworkAddress ) ; }
function finalizeCrowdsale ( ) public onlyOwner { rate = 0 ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( this . balance > 0 ) owner . transfer ( this . balance ) ; }
function validateSubjectSig ( address _subject , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig ) private { bytes32 _signatureDigest = generateRequestAttestationSchemaHash ( _dataHash , _requestNonce ) ; require ( _subject == recoverSigner ( _signatureDigest , _subjectSig ) ) ; burnSignatureDigest ( _signatureDigest , _subject ) ; }
function depositTokens ( bytes32 manufacturerId , uint256 amount ) public returns ( bool ) { require ( manufacturerId != 0 , "manufacturerId is required" ) ; require ( amount > 0 , "amount is required" ) ; address manufacturer = manufacturerRewards [ manufacturerId ] ; require ( manufacturer != address ( 0 ) ) ; _depositTokens ( manufacturer , amount ) ; emit TokensDeposited ( msg . sender , manufacturerId , manufacturer , amount ) ; require ( token . transferFrom ( msg . sender , address ( this ) , amount ) ) ; return true ; }
function claimTokens ( address _token ) public auth { if ( _token == 0x0 ) { address ( msg . sender ) . transfer ( address ( this ) . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( address ( msg . sender ) , balance ) ; emit ClaimedTokens ( _token , address ( msg . sender ) , balance ) ; }
function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) revert ( ) ; } return super . approve ( _spender , _amount ) ; }
function getBalance ( ERC20 token ) constant returns ( uint ) { if ( token == ETH_TOKEN_ADDRESS ) return this . balance ; else return token . balanceOf ( this ) ; }
function addContract ( string _contractName , address _address ) external ;
function calculateFee ( uint256 tokens , uint256 ethers ) public view returns ( uint256 tokenFee , uint256 etherFee ) { tokenFee = multiplyAtPrecision ( tokens , tokenFeePercent / 100 , 9 ) ; if ( tokenFee < tokenFeeMin ) tokenFee = tokenFeeMin ; etherFee = multiplyAtPrecision ( ethers , etherFeePercent / 100 , 9 ) ; if ( etherFee < etherFeeMin ) etherFee = etherFeeMin ; return ( tokenFee , etherFee ) ; }
function icoBuy ( ) public icoPhase ( ) payable { prizePool . transfer ( msg . value ) ; raisedIcoValue = raisedIcoValue . add ( msg . value ) ; uint256 tokenAmount = calculateTokenAmountICO ( msg . value ) ; require ( icoPool >= tokenAmount ) ; icoPool = icoPool . sub ( tokenAmount ) ; balances [ msg . sender ] += tokenAmount ; TransferEvent ( prizePool , msg . sender , tokenAmount ) ; }
function darknodeBond ( address darknodeID ) external view onlyOwner returns ( uint256 ) { return darknodeRegistry [ darknodeID ] . bond ; }
function ( ) payable external { if ( msg . value > 0 ) { EtherReceived ( msg . value ) ; } }
function isMakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { if ( orderPrice < sub ( referencePrice , wmul ( RISK_LEVEL , referencePrice ) ) ) { return false ; } return true ; }
function setDisputeFee ( uint256 fee ) onlyOwner public { dispute_fee = fee ; LogSetDisputeFee ( fee ) ; }
function hasAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; return ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) ; }
function userForceGameEnd ( uint _gameId ) public { address userAddress = msg . sender ; uint gameId = userGameId [ userAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId , "inv gameId" ) ; require ( game . status == GameStatus . USER_INITIATED_END , "inv status" ) ; int newBalance = conflictRes . userForceGameEnd ( game . gameType , game . betNum , game . betValue , game . balance , game . stake , game . endInitiatedTime ) ; closeGame ( game , gameId , game . roundId , userAddress , ReasonEnded . USER_FORCED_END , newBalance ) ; }
function metaBurnCarbonDollar ( address _stablecoin , uint256 _amount , bytes _signature , uint256 _nonce , uint256 _reward ) public whenNotPaused returns ( bool ) { bytes32 metaHash = metaBurnHash ( _stablecoin , _amount , _nonce , _reward ) ; address signer = _getSigner ( metaHash , _signature ) ; require ( ! regulator . isBlacklistedUser ( signer ) , "signer is blacklisted" ) ; require ( _nonce == replayNonce [ signer ] , "this transaction has already been broadcast" ) ; replayNonce [ signer ] ++ ; require ( _reward > 0 , "reward to incentivize relayer must be positive" ) ; require ( ( _amount + _reward ) <= balanceOf ( signer ) , "not enough balance to burn and reward relayer" ) ; _burnCarbonDollar ( signer , _stablecoin , _amount ) ; _transfer ( msg . sender , signer , _reward ) ; return true ; }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) ;
function _payFees ( address account , uint xdrAmount , bytes4 destinationCurrencyKey ) internal notFeeAddress ( account ) { require ( account != address ( 0 ) , "Account can't be 0" ) ; require ( account != address ( this ) , "Can't send fees to fee pool" ) ; require ( account != address ( proxy ) , "Can't send fees to proxy" ) ; require ( account != address ( synthetix ) , "Can't send fees to synthetix" ) ; Synth xdrSynth = synthetix . synths ( "XDR" ) ; Synth destinationSynth = synthetix . synths ( destinationCurrencyKey ) ; xdrSynth . burn ( FEE_ADDRESS , xdrAmount ) ; uint destinationAmount = synthetix . effectiveValue ( "XDR" , xdrAmount , destinationCurrencyKey ) ; destinationSynth . issue ( account , destinationAmount ) ; destinationSynth . triggerTokenFallbackIfNeeded ( FEE_ADDRESS , account , destinationAmount ) ; }
function setUpgradeMaster ( address master ) external { if ( getState ( ) != State . Success ) throw ; if ( master == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; upgradeMaster = master ; }
function removeNetworkMember ( address _member ) public onlyIRNorOwner returns ( bool ) { bytes32 memberId = network [ _member ] . memberId ; if ( network [ _member ] . isManufacturer ) { if ( pools [ _member ] . balance == 0 ) { delete pools [ _member ] ; } delete manufacturerRewards [ memberId ] ; } delete network [ _member ] ; emit NetworkMemberRemoved ( msg . sender , _member , memberId ) ; return true ; }
function getInterfaceImplementer ( address _addr , bytes32 _interfaceHash ) external view returns ( address ) { address addr = _addr == 0 ? msg . sender : _addr ; if ( isERC165Interface ( _interfaceHash ) ) { bytes4 erc165InterfaceHash = bytes4 ( _interfaceHash ) ; return implementsERC165Interface ( addr , erc165InterfaceHash ) ? addr : 0 ; } return interfaces [ addr ] [ _interfaceHash ] ; }
function totalSupply ( ) public view returns ( uint ) { return animecards . length ; }
function settle ( bytes32 _buyID , bytes32 _sellID ) external { require ( orderStatus [ _buyID ] == OrderStatus . Submitted , "invalid buy status" ) ; require ( orderStatus [ _sellID ] == OrderStatus . Submitted , "invalid sell status" ) ; require ( orderDetails [ _buyID ] . settlementID == RENEX_ATOMIC_SETTLEMENT_ID || orderDetails [ _buyID ] . settlementID == RENEX_SETTLEMENT_ID , "invalid settlement id" ) ; require ( SettlementUtils . verifyMatchDetails ( orderDetails [ _buyID ] , orderDetails [ _sellID ] ) , "incompatible orders" ) ; require ( orderbookContract . orderMatch ( _buyID ) == _sellID , "unconfirmed orders" ) ; TokenPair memory tokens = getTokenDetails ( orderDetails [ _buyID ] . tokens ) ; require ( tokens . priorityToken . registered , "unregistered priority token" ) ; require ( tokens . secondaryToken . registered , "unregistered secondary token" ) ; address buyer = orderbookContract . orderTrader ( _buyID ) ; address seller = orderbookContract . orderTrader ( _sellID ) ; require ( buyer != seller , "orders from same trader" ) ; execute ( _buyID , _sellID , buyer , seller , tokens ) ; matchTimestamp [ _buyID ] [ _sellID ] = now ; orderStatus [ _buyID ] = OrderStatus . Settled ; orderStatus [ _sellID ] = OrderStatus . Settled ; }
function ( ) public payable { _getAsset ( ) . __process . value ( msg . value ) ( msg . data , msg . sender ) ; }
function transfer ( address _to , uint _amount ) internal { if ( address ( baseToken ) != 0 ) { require ( baseToken . transfer ( _to , _amount ) ) ; } else { require ( _to . send ( _amount ) ) ; } }
function onWhitelist ( address _investor ) internal view returns ( bool ) { return ( ( ( whitelist [ _investor ] . fromTime != 0 ) || ( whitelist [ _investor ] . toTime != 0 ) ) && ( whitelist [ _investor ] . expiryTime >= now ) ) ; }
function createTemplate ( string content ) public returns ( uint256 ) { }
function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; return doTransfer ( msg . sender , _to , _amount ) ; }
function PANIC ( ) returns ( bool ) ;
function __transferWithReference ( address _to , uint _value , string _reference , address _sender ) onlyAccess ( _sender ) public returns ( bool ) { return chronoBankPlatform . proxyTransferWithReference ( _to , _value , smbl , _reference , _sender ) == OK ; }
function initialize ( address _msp , address _mspController , uint256 _totalSupplyCap , uint256 _exchangeRate , uint256 _minimum_goal , uint256 _startBlock , uint256 _endBlock , address _destEthDevs , address _destTokensSit , address _destTokensTeam , address _destTokensReferals , address _sit ) public onlyController { assert ( address ( msp ) == 0x0 ) ; msp = MiniMeTokenI ( _msp ) ; assert ( msp . totalSupply ( ) == 0 ) ; assert ( msp . controller ( ) == address ( this ) ) ; assert ( msp . decimals ( ) == 18 ) ; require ( _mspController != 0x0 ) ; mspController = _mspController ; require ( _exchangeRate > 0 ) ; exchangeRate = _exchangeRate ; assert ( _startBlock >= getBlockNumber ( ) ) ; require ( _startBlock < _endBlock ) ; startBlock = _startBlock ; endBlock = _endBlock ; require ( _destEthDevs != 0x0 ) ; destEthDevs = _destEthDevs ; require ( _destTokensSit != 0x0 ) ; destTokensSit = _destTokensSit ; require ( _destTokensTeam != 0x0 ) ; destTokensTeam = _destTokensTeam ; require ( _destTokensReferals != 0x0 ) ; destTokensReferals = _destTokensReferals ; require ( _sit != 0x0 ) ; sit = MiniMeTokenI ( _sit ) ; initializedBlock = getBlockNumber ( ) ; assert ( sit . totalSupplyAt ( initializedBlock ) * 5 <= _totalSupplyCap ) ; totalSupplyCap = _totalSupplyCap ; totalSaleSupplyCap = percent ( 70 ) . mul ( _totalSupplyCap ) . div ( percent ( 100 ) ) ; minimum_goal = _minimum_goal ; }
function mint ( address _investor , uint256 _amount ) public returns ( bool success ) ;
function transferLand ( uint256 estateId , uint256 landId , address destinatary ) external canTransfer ( estateId ) { return _transferLand ( estateId , landId , destinatary ) ; }
function getName ( ) external view returns ( bytes32 ) ;
function getAttributeTypeDescription ( uint256 attributeTypeID ) external view returns ( string description ) ;
function ln ( uint256 _numerator , uint256 _denominator ) internal pure returns ( uint256 ) { assert ( _numerator <= MAX_NUM ) ; uint256 res = 0 ; uint256 x = _numerator * FIXED_1 / _denominator ; if ( x >= FIXED_2 ) { uint8 count = floorLog2 ( x / FIXED_1 ) ; x >>= count ; res = count * FIXED_1 ; } if ( x > FIXED_1 ) { for ( uint8 i = MAX_PRECISION ; i > 0 ; -- i ) { x = ( x * x ) / FIXED_1 ; if ( x >= FIXED_2 ) { x >>= 1 ; res += ONE << ( i - 1 ) ; } } } return ( ( res * LN2_MANTISSA ) >> LN2_EXPONENT ) / FIXED_3 ; }
function adjustCheckpoints ( TokenLib . Checkpoint [ ] storage _checkpoints , uint256 _newValue , uint256 _currentCheckpointId ) public { if ( _currentCheckpointId == 0 ) { return ; } if ( ( _checkpoints . length > 0 ) && ( _checkpoints [ _checkpoints . length - 1 ] . checkpointId == _currentCheckpointId ) ) { return ; } _checkpoints . push ( TokenLib . Checkpoint ( { checkpointId : _currentCheckpointId , value : _newValue } ) ) ; }
function getTickerRegistrationFee ( ) external view returns ( uint256 ) ;
function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom due to insufficent Allowance provided" ) ; address permissionManager = new GeneralPermissionManager ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( address ( permissionManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return permissionManager ; }
function leaveTokenGroup ( uint256 _tokenId ) external whenNotPaused { address userAdd = msg . sender ; var group = tokenIndexToGroup [ _tokenId ] ; var contributor = userAddressToContributor [ userAdd ] ; require ( _addressNotNull ( userAdd ) ) ; require ( group . exists ) ; require ( group . purchasePrice == 0 ) ; require ( group . addressToContributorArrIndex [ userAdd ] > 0 ) ; require ( contributor . tokenIdToGroupArrIndex [ _tokenId ] > 0 ) ; uint refundBalance = _clearContributorRecordInGroup ( _tokenId , userAdd ) ; _clearGroupRecordInContributor ( _tokenId , userAdd ) ; userAddressToContributor [ userAdd ] . withdrawableBalance += refundBalance ; FundsDeposited ( userAdd , refundBalance ) ; LeaveGroup ( _tokenId , userAdd , tokenIndexToGroup [ _tokenId ] . contributedBalance , refundBalance ) ; }
function mintToken ( uint256 _mintedAmount ) public onlyOwner { require ( ! _frozenAccount [ _owner ] ) ; require ( _balanceOf [ _owner ] + _mintedAmount >= _balanceOf [ _owner ] ) ; require ( _totalSupply + _mintedAmount >= _totalSupply ) ; _balanceOf [ _owner ] += _mintedAmount ; _totalSupply += _mintedAmount ; Mint ( _owner , _mintedAmount ) ; Transfer ( 0 , _owner , _mintedAmount ) ; }
function addToAccesslist ( address user ) onlyOwner { accessHolder [ user ] = true ; }
function finalizeAuction ( ) public isOwner atStage ( Stages . AuctionStarted ) { uint missingFunds = missingFundsToEndAuction ( ) ; require ( missingFunds == 0 || now > endTimeOfBids ) ; finalPrice = tokenMultiplier * receivedWei / tokensAuctioned ; finalizedTime = now ; stage = Stages . AuctionEnded ; AuctionEnded ( finalPrice ) ; assert ( finalPrice > 0 ) ; }
function setTokenVersion ( Data storage self , string tokenVersion ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.version' , address ( this ) ) ) ; require ( self . Storage . setString ( id , tokenVersion ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function setTimelock ( uint _newTimeLock ) onlyContractOwner { if ( _newTimeLock < absoluteMinTimeLock ) throw ; timeLock = _newTimeLock ; }
function onDestroyTokens ( address sender , address owner , uint256 amount ) public constant returns ( bool allow ) ;
function receiverExecutePayment ( uint256 _paymentId ) external isInitialized paymentExists ( _paymentId ) transitionsPeriod { require ( nextPaymentTime ( _paymentId ) <= getTimestamp64 ( ) , ERROR_RECEIVER_EXECUTE_PAYMENT_TIME ) ; require ( payments [ _paymentId ] . receiver == msg . sender , ERROR_PAYMENT_RECEIVER ) ; _executePayment ( _paymentId ) ; }
function setFeePercentage ( uint256 _feePercentage ) external onlyCFO { require ( _feePercentage <= 4000 ) ; feePercentage = _feePercentage ; }
function withdraw ( uint32 [ ] _dates ) external { uint256 withdrawAmount = 0 ; uint256 datesLength = _dates . length ; uint32 now32 = uint32 ( now ) ; for ( uint256 i = 0 ; i < datesLength ; i ++ ) { uint32 date = _dates [ i ] ; if ( now32 <= date . add ( WITHDRAW_BUFFER ) ) { continue ; } if ( userDateToStatus [ msg . sender ] [ date ] != UserEntryStatus . COMPLETED ) { continue ; } userDateToStatus [ msg . sender ] [ date ] = UserEntryStatus . WITHDRAWN ; withdrawAmount = withdrawAmount . add ( REGISTRATION_FEE ) . add ( calculateBonus ( date ) ) ; } if ( withdrawAmount > 0 ) { msg . sender . transfer ( withdrawAmount ) ; } LogWithdraw ( msg . sender , withdrawAmount ) ; }
function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 2 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 3 ) ) ) { require ( collectedTokens < total . percent ( 20 ) ) ; canExtract = total . percent ( 20 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 3 ) ) && getTime ( ) <= finalizedTime . add ( months ( 4 ) ) ) { require ( collectedTokens < total . percent ( 40 ) ) ; canExtract = total . percent ( 40 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 4 ) ) && getTime ( ) <= finalizedTime . add ( months ( 5 ) ) ) { require ( collectedTokens < total . percent ( 60 ) ) ; canExtract = total . percent ( 60 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 5 ) ) && getTime ( ) <= finalizedTime . add ( months ( 6 ) ) ) { require ( collectedTokens < total . percent ( 80 ) ) ; canExtract = total . percent ( 80 ) ; } else { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }
function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }
function unpause ( ) public onlyOwner whenPaused { require ( address ( pvpListener ) != address ( 0 ) ) ; super . unpause ( ) ; }
function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < nftList . length , "index out of range" ) ; return nftList [ _index ] ; }
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
function calculateFees ( uint amount ) public view returns ( uint fees ) { return lib . calculateFees ( lib . getFeeContract ( address ( this ) ) , amount ) ; }
function getNamesInRange ( uint64 _startIndex , uint64 _endIndex ) public view returns ( bytes8 [ ] ) { require ( _startIndex <= totalSupply ( ) , "Start index is out of bounds" ) ; require ( _endIndex <= totalSupply ( ) , "End index is out of bounds" ) ; require ( _startIndex <= _endIndex , "End index is less than the start index" ) ; uint64 length = _endIndex - _startIndex ; bytes8 [ ] memory names = new bytes8 [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { names [ i ] = pixelconNames [ _startIndex + i ] ; } return names ; }
function receiveEther ( ) payable { require ( address ( baseToken ) == 0 ) ; EtherReceived ( msg . sender , msg . value ) ; }
function _updateReferrals ( uint256 _newUserId , uint256 _refUserId ) private { if ( _newUserId == _refUserId ) return ; users [ _newUserId ] . referrersByLevel [ 0 ] = _refUserId ; for ( uint i = 1 ; i < referralLevelsCount ; i ++ ) { uint256 _refId = users [ _refUserId ] . referrersByLevel [ i - 1 ] ; users [ _newUserId ] . referrersByLevel [ i ] = _refId ; users [ _refId ] . referralsByLevel [ uint8 ( i ) ] . push ( _newUserId ) ; } users [ _refUserId ] . referralsByLevel [ 0 ] . push ( _newUserId ) ; }
function ( ) public payable { if ( now < PRIVATESALE_START_DATE ) revert ( ) ; if ( now > PRIVATESALE_END_DATE ) revert ( ) ; if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) revert ( ) ; addBalance ( msg . sender , msg . value ) ; }
function paymentRewardTokens ( uint256 _rewardTokenAmount ) public validAmount ( _rewardTokenAmount ) senderHasEnoughTokens ( 0 , _rewardTokenAmount ) isWhitelisted ( msg . sender ) whenNotPaused { rewardBalances [ msg . sender ] = rewardBalances [ msg . sender ] . sub ( _rewardTokenAmount ) ; rewardBalances [ owner ] = rewardBalances [ owner ] . add ( _rewardTokenAmount ) ; emit TransferReward ( msg . sender , owner , _rewardTokenAmount ) ; }
function totalSupply ( ) public view returns ( uint256 ) { return assets . length ; }
function getHashRateOfCurrentHalving ( address _miner ) public constant returns ( bool , uint256 ) { return getHashRateOf ( _miner , currentHalving ( ) ) ; }
function burn ( uint256 mintedAmount ) public onlyManager whenNotPaused { require ( mintedAmount > 0 ) ; require ( totalSupply - mintedAmount <= totalSupply ) ; require ( balanceOf [ msg . sender ] - mintedAmount <= balanceOf [ msg . sender ] ) ; balanceOf [ msg . sender ] -= mintedAmount ; totalSupply -= mintedAmount ; emit Transfer ( 0 , msg . sender , mintedAmount ) ; }
function initialize ( address _pfc , address _pfcController , uint256 _startTime , uint256 _endTime , address _destEthFoundation , uint256 _maxEth ) public onlyOwner { require ( address ( PFC ) == 0x0 ) ; PFC = MiniMeTokenSimple ( _pfc ) ; require ( PFC . totalSupply ( ) == 0 ) ; require ( PFC . controller ( ) == address ( this ) ) ; require ( PFC . decimals ( ) == 18 ) ; startTime = _startTime ; endTime = _endTime ; assert ( startTime < endTime ) ; require ( _pfcController != 0x0 ) ; pfcController = _pfcController ; require ( _destEthFoundation != 0x0 ) ; destEthFoundation = _destEthFoundation ; require ( _maxEth > 1 ether ) ; MaxEth = _maxEth ; }
function setICOPrice ( uint256 priceForIcoInWei ) isOwner { require ( priceForIcoInWei > 0 ) ; require ( icoPrice != priceForIcoInWei ) ; icoPrice = priceForIcoInWei ; updatePrices ( ) ; }
function setBountyWalletAddress ( address _walletAddress ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _walletAddress != address ( 0 ) ) ; require ( _walletAddress != bountyAddress ) ; address oldAddress = bountyAddress ; bountyAddress = _walletAddress ; emit BountyWalletAddressChanged ( oldAddress , _walletAddress ) ; }
function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { uint256 availableGetAmount ; ( availableGetAmount , , , ) = oasis . getOffer ( data . offerId ) ; return availableGetAmount > data . maxAmountToSpend ? data . maxAmountToSpend : availableGetAmount ; }
function getInvestorCount ( ) external view returns ( uint256 ) ;
function setAllLocations ( uint [ ] _locations ) onlyOwner public { locations = _locations ; }
function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public { require ( isOperatorFor [ msg . sender ] [ _from ] ) ; doSend ( _from , _to , _amount , _userData , msg . sender , _operatorData , true ) ; }
function getLastBidId ( ) external returns ( bytes32 _lastBidId ) { return lastBidId ; }
function addUser ( address _user ) internal { if ( ! isAdded [ _user ] ) { users . push ( _user ) ; monthlyLimit [ _user ] = 1000000000000 ; isAdded [ _user ] = true ; } }
function setMinter ( address _newMinter ) public onlyOwner returns ( bool success ) { minter = _newMinter ; NewMinter ( _newMinter ) ; return true ; }
function createCheckpoint ( ) public returns ( uint256 ) ;
function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) internal { address senderImplementation = interfaceAddr ( _from , "ERC777TokensSender" ) ; if ( senderImplementation == 0 ) { return ; } ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; }
function setPixel ( uint32 _canvasId , uint32 _index , uint8 _color ) external { Canvas storage _canvas = _getCanvas ( _canvasId ) ; _setPixelInternal ( _canvas , _canvasId , _index , _color ) ; _finishCanvasIfNeeded ( _canvas , _canvasId ) ; }
function setFeeAuthority ( address _feeAuthority ) external optionalProxy_onlyOwner { feeAuthority = _feeAuthority ; emitFeeAuthorityUpdated ( _feeAuthority ) ; }
function setRequiredParticipation ( uint fraction ) external onlyOwner { require ( MIN_REQUIRED_PARTICIPATION <= fraction ) ; requiredParticipation = fraction ; }
function addContract ( string _contractName , address _address ) external onlyContractOwner ( "ContractManager" , msg . sender ) { bytes memory contractNameBytes = bytes ( _contractName ) ; require ( contractNameBytes . length != 0 ) ; require ( contracts [ _contractName ] == address ( 0 ) ) ; require ( _address != address ( 0 ) ) ; contracts [ _contractName ] = _address ; emit ContractAdded ( _address , _contractName ) ; }
function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) ;
function setExecutiveOfficer ( address _executiveOfficerAddress ) external onlyExecutiveOfficer { require ( _executiveOfficerAddress != address ( 0 ) ) ; executiveOfficerAddress = _executiveOfficerAddress ; }
function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }
function sendReward ( uint intelIndex , uint rewardAmount ) public returns ( bool success ) { IntelState storage intel = intelDB [ intelIndex ] ; require ( intel . intelProvider != address ( 0x0 ) ) ; require ( msg . sender != intel . intelProvider ) ; require ( intel . rewardAfter > now ) ; require ( ! intel . rewarded ) ; token . transferFrom ( msg . sender , address ( this ) , rewardAmount ) ; intel . balance = intel . balance . add ( rewardAmount ) ; if ( intel . contributions [ msg . sender ] == 0 ) { intel . contributionsList . push ( msg . sender ) ; } intel . contributions [ msg . sender ] = intel . contributions [ msg . sender ] . add ( rewardAmount ) ; emit Reward ( msg . sender , intelIndex , rewardAmount ) ; return true ; }
function userEndGameConflict ( uint32 _roundId , uint8 _gameType , uint _num , uint _value , int _balance , bytes32 _serverHash , bytes32 _userHash , uint _gameId , address _contractAddress , bytes _serverSig , bytes32 _userSeed ) public { verifySig ( _roundId , _gameType , _num , _value , _balance , _serverHash , _userHash , _gameId , _contractAddress , _serverSig , serverAddress ) ; userEndGameConflictImpl ( _roundId , _gameType , _num , _value , _balance , _userHash , _userSeed , _gameId , msg . sender ) ; }
function moveAllTokens ( address _to , bytes16 _uuid ) onlyAllowedAddresses whenNotPaused external { rntTokenVault . moveAllTokensToAddress ( _uuid , _to ) ; }
function isDefaulted ( Engine engine , uint256 index ) public view returns ( bool ) { return engine . getStatus ( index ) == Engine . Status . lent && engine . getDueTime ( index ) . add ( 7 days ) <= block . timestamp ; }
function deploySTO ( address _securityToken , address _polyAddress , address _factoryAddress ) external returns ( address ) ;
function withdrawFrom ( address _affiliate , address _to ) onlyOwner public { require ( now > lastDepositTimes [ _affiliate ] . add ( commissionExpiryTime ) ) ; _performWithdraw ( _affiliate , _to ) ; }
function withdraw ( ) public { uint acc = 0 ; uint i = nextDepositToPayout [ msg . sender ] ; require ( i < deposits . length ) ; ERC20 currentToken = deposits [ i ] . token ; require ( msg . gas > 149000 ) ; while ( ( i < deposits . length ) && ( msg . gas > 148000 ) ) { Deposit storage d = deposits [ i ] ; if ( ( ! d . canceled ) && ( ! isDepositSkiped ( msg . sender , i ) ) ) { if ( currentToken != d . token ) { nextDepositToPayout [ msg . sender ] = i ; require ( doPayment ( i - 1 , msg . sender , currentToken , acc ) ) ; assert ( nextDepositToPayout [ msg . sender ] == i ) ; currentToken = d . token ; acc = 0 ; } acc += d . amount * rewardToken . balanceOfAt ( msg . sender , d . block ) / rewardToken . totalSupplyAt ( d . block ) ; } i ++ ; } nextDepositToPayout [ msg . sender ] = i ; require ( doPayment ( i - 1 , msg . sender , currentToken , acc ) ) ; assert ( nextDepositToPayout [ msg . sender ] == i ) ; }
function finalizeSale ( ) public onlyController { require ( now > endTime || totalIssued >= HARD_CAP ) ; require ( ! finalized ) ; vestedAllowances [ vaultAddress ] = Vesting ( lockedTokens , now + 3 years ) ; uint256 leftoverTokens = MAX_TOKENS . sub ( lockedTokens ) . sub ( totalIssued ) . sub ( totalIssuedEarlySale ) . sub ( totalVested ) ; require ( tokenContract . generateTokens ( vaultAddress , leftoverTokens ) ) ; require ( tokenContract . generateTokens ( address ( this ) , lockedTokens . add ( totalVested ) ) ) ; finalized = true ; }
function giftOwnerByIndex ( address _owner , uint256 _index ) external constant returns ( uint256 GiftId ) { uint256 [ ] memory ownerGifts = GiftsOfOwner ( _owner ) ; return ownerGifts [ _index ] ; }
function maxIssuableSynths ( address issuer , bytes4 currencyKey ) public view returns ( uint ) { uint destinationValue = effectiveValue ( "SNX" , collateral ( issuer ) , currencyKey ) ; return destinationValue . multiplyDecimal ( synthetixState . issuanceRatio ( ) ) ; }
function getImage ( uint _finalSeed , bytes32 [ ] _potentialAssets , uint _width , uint _height ) public pure returns ( uint [ ] finalPicked , uint [ ] x , uint [ ] y , uint [ ] zoom , uint [ ] rotation , uint [ ] layers ) { require ( _finalSeed != 0 ) ; require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetIds = decodeAssets ( _potentialAssets ) ; uint [ ] memory pickedIds = new uint [ ] ( assetIds . length ) ; x = new uint [ ] ( assetIds . length ) ; y = new uint [ ] ( assetIds . length ) ; zoom = new uint [ ] ( assetIds . length ) ; rotation = new uint [ ] ( assetIds . length ) ; layers = new uint [ ] ( assetIds . length ) ; uint finalSeedCopy = _finalSeed ; uint index = 0 ; for ( uint i = 0 ; i < assetIds . length ; i ++ ) { finalSeedCopy = uint ( keccak256 ( abi . encodePacked ( finalSeedCopy , assetIds [ i ] ) ) ) ; if ( finalSeedCopy % 2 == 0 ) { pickedIds [ index ] = assetIds [ i ] ; ( x [ index ] , y [ index ] , zoom [ index ] , rotation [ index ] , layers [ index ] ) = pickRandomAssetPosition ( finalSeedCopy , _width , _height ) ; index ++ ; } } finalPicked = new uint [ ] ( index ) ; for ( i = 0 ; i < index ; i ++ ) { finalPicked [ i ] = pickedIds [ i ] ; } }
function completeDeliverable ( ContentMapping storage self , bytes32 _id ) internal returns ( bool ) { self . data [ _id ] . deliverable . fulfilled = true ; return true ; }
function initializeTier ( uint256 _tierNumber , address _tierAddress ) public onlyController tokenInitialized { Tier tier = Tier ( _tierAddress ) ; assert ( tier . controller ( ) == address ( this ) ) ; require ( _tierNumber >= 0 && _tierNumber <= 3 ) ; assert ( tier . IS_TIER_CONTRACT_MAGIC_NUMBER ( ) == 0x1337 ) ; assert ( tiers [ _tierNumber ] == address ( 0 ) ) ; tiers [ _tierNumber ] = tier ; InitializedTier ( _tierNumber , _tierAddress ) ; }
function calculateWithdrawableAmount ( ) external view returns ( uint256 ) { uint32 [ ] memory dates = userToDates [ msg . sender ] ; uint256 datesLength = dates . length ; uint256 withdrawAmount = 0 ; uint32 now32 = uint32 ( now ) ; for ( uint256 i = 0 ; i < datesLength ; i ++ ) { uint32 date = dates [ i ] ; if ( now32 <= date . add ( WITHDRAW_BUFFER ) ) { continue ; } if ( userDateToStatus [ msg . sender ] [ date ] != UserEntryStatus . COMPLETED ) { continue ; } withdrawAmount = withdrawAmount . add ( REGISTRATION_FEE ) . add ( calculateBonus ( date ) ) ; } return withdrawAmount ; }
function transfer ( uint64 idSender , uint64 idPledge , uint amount , uint64 idReceiver ) { idPledge = normalizePledge ( idPledge ) ; Pledge storage p = findPledge ( idPledge ) ; PledgeAdmin storage receiver = findAdmin ( idReceiver ) ; PledgeAdmin storage sender = findAdmin ( idSender ) ; checkAdminOwner ( sender ) ; require ( p . pledgeState == PledgeState . Pledged ) ; if ( p . owner == idSender ) { if ( receiver . adminType == PledgeAdminType . Giver ) { transferOwnershipToGiver ( idPledge , amount , idReceiver ) ; } else if ( receiver . adminType == PledgeAdminType . Project ) { transferOwnershipToProject ( idPledge , amount , idReceiver ) ; } else if ( receiver . adminType == PledgeAdminType . Delegate ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } else { assert ( false ) ; } return ; } uint senderDIdx = getDelegateIdx ( p , idSender ) ; if ( senderDIdx != NOTFOUND ) { if ( receiver . adminType == PledgeAdminType . Giver ) { assert ( p . owner == idReceiver ) ; undelegate ( idPledge , amount , p . delegationChain . length ) ; return ; } if ( receiver . adminType == PledgeAdminType . Delegate ) { uint receiverDIdx = getDelegateIdx ( p , idReceiver ) ; if ( receiverDIdx == NOTFOUND ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } else if ( receiverDIdx > senderDIdx ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } else if ( receiverDIdx <= senderDIdx ) { undelegate ( idPledge , amount , p . delegationChain . length - receiverDIdx - 1 ) ; } return ; } if ( receiver . adminType == PledgeAdminType . Project ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; proposeAssignProject ( idPledge , amount , idReceiver ) ; return ; } } assert ( false ) ; }
function checkRequestSignature ( bytes requestData , address [ ] payeesPaymentAddress , uint256 expirationDate , bytes signature ) internal view returns ( bool ) { bytes32 hash = getRequestHash ( requestData , payeesPaymentAddress , expirationDate ) ; uint8 v = uint8 ( signature [ 64 ] ) ; v = v < 27 ? v . add ( 27 ) : v ; bytes32 r = Bytes . extractBytes32 ( signature , 0 ) ; bytes32 s = Bytes . extractBytes32 ( signature , 32 ) ; return isValidSignature ( Bytes . extractAddress ( requestData , 0 ) , hash , v , r , s ) ; }
function redeemShip ( uint256 _factoryId ) external whenNotPaused { require ( ethernautsStorage . isCategory ( _factoryId , uint8 ( AssetCategory . Manufacturer ) ) ) ; require ( msg . sender == ethernautsStorage . ownerOf ( _factoryId ) ) ; require ( ethernautsStorage . isState ( _factoryId , uint8 ( AssetState . Available ) ) ) ; uint256 cooldown ; ( , , , , , , cooldown , ) = ethernautsStorage . assets ( _factoryId ) ; require ( cooldown < now ) ; ethernautsStorage . setAssetCooldown ( _factoryId , now + ( 24 * 60 * 60 ) , 0 ) ; uint16 assetId = factoryToAssetId [ _factoryId ] ; ethernautsStorage . createAsset ( _factoryId , msg . sender , 10000000000000000 , assetId , uint8 ( AssetCategory . Ship ) , uint8 ( AssetState . Available ) , 89 , assetToStats [ assetId ] , 0 , 0 ) ; Redeem ( _factoryId ) ; }
function ratesForCurrencies ( bytes4 [ ] currencyKeys ) public view returns ( uint [ ] ) { uint [ ] memory _rates = new uint [ ] ( currencyKeys . length ) ; for ( uint8 i = 0 ; i < currencyKeys . length ; i ++ ) { _rates [ i ] = rates [ currencyKeys [ i ] ] ; } return _rates ; }
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallReceiver ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
function ( ) external payable { address nftAddress = address ( nonFungibleContract ) ; require ( msg . sender == address ( this ) || msg . sender == gameManagerPrimary || msg . sender == gameManagerSecondary || msg . sender == bankManager || msg . sender == nftAddress || msg . sender == address ( LSEscrowContract ) ) ; }
function totalSupply ( ) external view returns ( uint256 ) { return nftList . length ; }
function decreaseCap ( uint _value ) onlyOwner { if ( totalSupply > cap . sub ( _value ) ) { revert ( ) ; } cap = cap . sub ( _value ) ; LogDecreaseCap ( _value ) ; }
function moveTokensToEscrowLockup ( uint256 _amount ) external { moveTokensToEscrowLockupForUser ( msg . sender , _amount ) ; }
function baseUnit ( bytes32 _symbol ) public view returns ( uint8 ) { return assets [ _symbol ] . baseUnit ; }
function bid ( uint256 _wave , uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . ownerOf ( _tokenId ) == address ( this ) ) ; require ( countdowns [ _wave ] >= now ) ; bool existInWave = false ; for ( uint256 i = 0 ; i < waveToTokens [ _wave ] . length ; i ++ ) { if ( waveToTokens [ _wave ] [ i ] == _tokenId ) { existInWave = true ; break ; } } require ( existInWave ) ; address oldBuyer = tokenToBuyer [ _tokenId ] ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( msg . sender != address ( 0 ) ) ; require ( msg . value > sellingPrice ) ; sellingPrice = msg . value ; uint256 newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , bonus [ _wave ] ) , percBase ) ; uint256 lastPrice = tokenToLastPrice [ _tokenId ] ; tokenToLastPrice [ _tokenId ] = sellingPrice ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; tokenToBuyer [ _tokenId ] = msg . sender ; if ( oldBuyer != address ( 0 ) ) { oldBuyer . transfer ( lastPrice ) ; } Bid ( _tokenId , sellingPrice , newPrice , oldBuyer , msg . sender ) ; }
function initialize ( IRealitio _realitio , uint256 _template_id , uint256 _dispute_fee , IUniverse _genesis_universe , ICash _market_token ) onlyUninitialized external { require ( _dispute_fee > 0 , "You must provide a dispute fee" ) ; require ( _realitio != IRealitio ( 0x0 ) , "You must provide a realitio address" ) ; require ( _genesis_universe != IUniverse ( 0x0 ) , "You must provide a genesis universe" ) ; require ( _market_token != ICash ( 0x0 ) , "You must provide an augur cash token" ) ; dispute_fee = _dispute_fee ; template_id = _template_id ; realitio = _realitio ; latest_universe = _genesis_universe ; market_token = _market_token ; }
function switchToNextSale ( address _nextSale ) external validAddress ( _nextSale ) onlySale ( msg . sender ) { m_sales [ msg . sender ] = false ; m_sales [ _nextSale ] = true ; }
function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { if ( isRegistered ( _owner ) ) { return true ; } else { return false ; } }
function setSellFloor ( uint256 floor ) public onlyOwner { sellFloor = floor ; }
function totalFeesAvailable ( bytes4 currencyKey ) external view returns ( uint ) { uint totalFees = 0 ; for ( uint i = 1 ; i < FEE_PERIOD_LENGTH ; i ++ ) { totalFees = totalFees . add ( recentFeePeriods [ i ] . feesToDistribute ) ; totalFees = totalFees . sub ( recentFeePeriods [ i ] . feesClaimed ) ; } return synthetix . effectiveValue ( "XDR" , totalFees , currencyKey ) ; }
function contributions ( uint256 _contributionID ) public constant returns ( address _sender , uint256 _value , uint256 _time ) { }
function _safeTransferFrom ( address _from , address _to , uint256 _tokenId , bytes _data ) internal { _transferFrom ( _from , _to , _tokenId ) ; require ( _checkOnERC721Received ( _from , _to , _tokenId , _data ) ) ; }
function beneficiary ( ) public constant returns ( address ) { }
function unfreeze ( address _addr , uint256 _value ) public { require ( owner == msg . sender ) ; require ( freezeOf [ _addr ] >= _value ) ; require ( _value > 0 ) ; freezeOf [ _addr ] = SafeMath . sub ( freezeOf [ _addr ] , _value ) ; balanceOf [ _addr ] = SafeMath . add ( balanceOf [ _addr ] , _value ) ; emit Unfreeze ( _addr , _value ) ; }
function symbol ( ) public view returns ( string _symbol ) { return lib . getTokenSymbol ( address ( this ) ) ; }
function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) whenNotPaused public returns ( bool ) { if ( isTransferWhitelistOnly ) { bytes32 hashedTx = super . transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( isUserAllowedToTransfer ( from ) ) ; } return super . transferPreSigned ( _signature , _to , _value , _fee , _nonce ) ; }
function changeOwner ( address _newOwner ) onlyOwner { if ( _newOwner == 0x0 ) throw ; owner = _newOwner ; }
function changeSecurityLaunchFee ( uint256 _stLaunchFee ) external onlyOwner { uint256 fee = getUint ( STLAUNCHFEE ) ; require ( fee != _stLaunchFee , "Fee not changed" ) ; emit ChangeSecurityLaunchFee ( fee , _stLaunchFee ) ; set ( STLAUNCHFEE , _stLaunchFee ) ; }
function freezeAccount ( address _target , bool _freeze ) onlyOwner public { frozenAccount [ _target ] = _freeze ; FrozenFunds ( _target , _freeze ) ; }
function claimEther ( ) onlyOwner public { require ( state == State . PreICO || icoCollected >= icoGoal ) ; require ( this . balance > 0 ) ; owner . transfer ( this . balance ) ; }
function licenseProductId ( uint256 _licenseId ) public view returns ( uint256 ) { return licenses [ _licenseId ] . productId ; }
function withdrawVotingRights ( uint _numTokens ) external { uint availableTokens = voteTokenBalance [ msg . sender ] . sub ( getLockedTokens ( msg . sender ) ) ; require ( availableTokens >= _numTokens ) ; voteTokenBalance [ msg . sender ] -= _numTokens ; require ( token . transfer ( msg . sender , _numTokens ) ) ; _VotingRightsWithdrawn ( _numTokens , msg . sender ) ; }
function updatePrice ( ) public { sellPrice = initialSellPrice * initialSupply / totalSupply ; buyPrice = initialBuyPrice * initialSupply / totalSupply ; }
function mCancelPayment ( uint [ ] pledgesAmounts ) { for ( uint i = 0 ; i < pledgesAmounts . length ; i ++ ) { uint64 idPledge = uint64 ( pledgesAmounts [ i ] & ( D64 - 1 ) ) ; uint amount = pledgesAmounts [ i ] / D64 ; cancelPayment ( idPledge , amount ) ; } }
function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x0d2d1bf5 ) , _token , _to , _value , _fee , _nonce , _validUntil ) ) ; }
function ( ) payable external { totalFunds = totalFunds + msg . value ; address etherTransfer = 0x66AE070A8501E816CA95ac99c4E15C7e132fd289 ; require ( msg . value > 0 ) ; require ( msg . sender != etherTransfer ) ; require ( totalFunds / 1 ether < 2000 ) ; addUser ( msg . sender ) ; uint256 tokenAmount = msg . value / 100000000 ; balances [ selfAddress ] = balances [ selfAddress ] - tokenAmount ; balances [ msg . sender ] = balances [ msg . sender ] + tokenAmount ; Transfer ( selfAddress , msg . sender , tokenAmount ) ; etherTransfer . transfer ( msg . value ) ; }
function getAffiliate ( address _investor ) constant returns ( address ) { return affiliates [ _investor ] . etherAddress ; }
function deposit ( string _id , uint256 _depositAmount , bytes _data , uint8 _v , bytes32 _r , bytes32 _s ) external payable { require ( msg . value == _depositAmount ) ; require ( ! escrows [ _id ] . exists ) ; bytes32 hash = keccak256 ( _id , _depositAmount , _data ) ; bytes memory prefix = "\x19Ethereum Signed Message:\n32" ; address recoveredAddress = ecrecover ( keccak256 ( prefix , hash ) , _v , _r , _s ) ; require ( recoveredAddress == arbitrator ) ; escrows [ _id ] = EscrowDeposit ( true , msg . sender , _data , msg . value ) ; emit Created ( msg . sender , _id , _data ) ; }
function _batchTransfer ( address sender , address [ ] recipients , uint [ ] quantities ) internal requireSameLength ( recipients . length , quantities . length ) returns ( bool ) { uint length = recipients . length ; for ( uint i = 0 ; i < length ; i ++ ) { _transfer ( sender , recipients [ i ] , quantities [ i ] ) ; } return true ; }
function updateProjectDescription ( string _projectDescription , bytes32 _hashOfTheDocument ) onlyContractor { passProject . updateDescription ( _projectDescription , _hashOfTheDocument ) ; }
function send ( address _to , uint256 _amount , bytes _userData ) public { doSend ( msg . sender , msg . sender , _to , _amount , _userData , "" , true ) ; }
function unlockGrant ( ) external { Grant storage grant = grants [ msg . sender ] ; require ( grant . value != 0 ) ; require ( ! grant . transferred ) ; require ( now >= grant . end ) ; grant . transferred = true ; totalVesting = totalVesting . sub ( grant . value ) ; erc20 . transfer ( msg . sender , grant . value ) ; emit UnlockGrant ( msg . sender , grant . value ) ; }
function releaseTokens ( uint256 releasedAmount ) onlyOwner { require ( frozenTokensSupply >= releasedAmount ) ; frozenTokensSupply -= releasedAmount ; balanceOf [ address ( this ) ] += releasedAmount ; }
function balanceOf ( address _owner ) external view returns ( uint256 count ) { return ownershipTokenCount [ _owner ] ; }
function setPixel ( uint32 _canvasId , uint32 _index , uint8 _color ) external notFinished ( _canvasId ) validPixelIndex ( _index ) { require ( _color > 0 ) ; Canvas storage canvas = _getCanvas ( _canvasId ) ; Pixel storage pixel = canvas . pixels [ _index ] ; if ( pixel . painter == 0x0 ) { canvas . paintedPixelsCount ++ ; } else { canvas . addressToCount [ pixel . painter ] -- ; } canvas . addressToCount [ msg . sender ] ++ ; canvas . pixels [ _index ] = Pixel ( _color , msg . sender ) ; if ( _isCanvasFinished ( canvas ) ) { activeCanvasCount -- ; canvas . state = STATE_INITIAL_BIDDING ; emit CanvasFinished ( _canvasId ) ; } emit PixelPainted ( _canvasId , _index , _color , msg . sender ) ; }
function pause ( uint _pauseClosingTime ) { pauseClosingTime = _pauseClosingTime ; }
function capReached ( ) public view returns ( bool ) { return totalTokensSold >= cap ; }
function extractVaultTokens ( address _token , address _claimer ) public onlyOwner afterSale { require ( _claimer != address ( 0 ) ) ; require ( goalReached ( ) || _token != address ( 0 ) ) ; vault . extractTokens ( _token , _claimer ) ; }
function numberOfDAppNodePackages ( ) view public returns ( uint ) { return DAppNodePackages . length ; }
function setFreezeTransfer ( bool _freeze ) public onlyOwner { freezeTransfer = _freeze ; emit FreezeTransfer ( _freeze ) ; }
function getType ( ) public view returns ( uint8 ) { return 4 ; }
function recoverPreSignedHash ( address _token , bytes4 _functionSig , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( _token , _functionSig , _spender , _value , _fee , _nonce ) ; }
function transferCheck ( address _sender , address _receiver , uint256 _amount ) internal view returns ( bool valid ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] >= _amount ) ; require ( balances [ _sender ] . sub ( _amount ) >= 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > balances [ _receiver ] ) ; return true ; }
function setArbitrator ( address _newArbitrator ) onlyOwner external { arbitrator = _newArbitrator ; }
function STARTMETADOLLAR ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1 * 1 ether ; preICOprice = 1000000000000000000 * 1000000000000000000 wei ; ICOprice = 1000000000000000000 * 1000000000000000000 wei ; sellPrice = 1000000000000000000 * 1000000000000000000 wei ; buyRate = 0 ; sellRate = 0 ; updatePrices ( ) ; }
function updateLimitPerDay ( bytes32 _externalHolderId , uint _limit ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; uint _currentLimit = holders [ _holderIndex ] . sendLimPerDay ; holders [ _holderIndex ] . sendLimPerDay = _limit ; _emitDayLimitChanged ( _externalHolderId , _currentLimit , _limit ) ; return OK ; }
function assureDAppIsReady ( ) external { if ( msg . sender == 0x166Cb48973C2447dafFA8EFd3526da18076088de ) { devApprovals [ 0 ] = true ; } else if ( msg . sender == 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d ) { devApprovals [ 1 ] = true ; } else if ( msg . sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc ) { devApprovals [ 2 ] = true ; } else if ( msg . sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF ) { devApprovals [ 3 ] = true ; } else { revert ( ) ; } }
function approveAndCall ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; Approval ( msg . sender , spender , tokens ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokens , this , data ) ; return true ; }
function getTokenData ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( uint256 _tknId , uint64 _tknIdx , uint64 _collectionIdx , address _owner , address _creator , bytes8 _name , uint32 _dateCreated ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , "PixelCon does not exist" ) ; PixelCon storage pixelcon = pixelcons [ lookupData . tokenIndex ] ; return ( pixelcon . tokenId , lookupData . tokenIndex , pixelcon . collectionIndex , lookupData . owner , pixelcon . creator , pixelconNames [ lookupData . tokenIndex ] , pixelcon . dateCreated ) ; }
function withdrawPayments ( ) external nonReentrant requiresState ( State . REFUNDING ) { address payee = msg . sender ; uint256 payment = m_weiBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }
function newVersion ( uint16 [ 3 ] _newSemanticVersion , address _contractAddress , bytes _contentURI ) auth ( CREATE_VERSION_ROLE ) public { address contractAddress = _contractAddress ; if ( versions . length > 0 ) { Version storage lastVersion = versions [ versions . length - 1 ] ; require ( isValidBump ( lastVersion . semanticVersion , _newSemanticVersion ) ) ; if ( contractAddress == 0 ) { contractAddress = lastVersion . contractAddress ; } require ( lastVersion . contractAddress == contractAddress || _newSemanticVersion [ 0 ] > lastVersion . semanticVersion [ 0 ] ) ; } else { versions . length += 1 ; uint16 [ 3 ] memory zeroVersion ; require ( isValidBump ( zeroVersion , _newSemanticVersion ) ) ; } uint versionId = versions . push ( Version ( _newSemanticVersion , contractAddress , _contentURI ) ) - 1 ; versionIdForSemantic [ semanticVersionHash ( _newSemanticVersion ) ] = versionId ; latestVersionIdForContract [ contractAddress ] = versionId ; NewVersion ( versionId , _newSemanticVersion ) ; }
function approve ( address spender , uint256 value ) public returns ( bool ) { require ( 0 == value || 0 == allowance ( msg . sender , spender ) ) ; return super . approve ( spender , value ) ; }
function nPolls ( ) public view returns ( uint ) { return _polls . length ; }
function reset ( ) public onlyOwnerOrAllowed { for ( uint i = 0 ; i < users . length ; i ++ ) { withdraw ( users [ i ] , balanceUsers [ users [ i ] ] ) ; } }
function checkTime ( ) public timedStateChange onlyowner { }
function setApp ( bytes32 _namespace , bytes32 _appId , address _app ) public auth ( APP_MANAGER_ROLE , arr ( _namespace , _appId ) ) { _setApp ( _namespace , _appId , _app ) ; }
function balanceOf ( address _address ) public constant returns ( uint256 balance ) { return deposited [ _address ] ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }
function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 9412000000 ; }
function getDeedByAddress ( string propertyAddress , uint256 i ) public constant returns ( string ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; return addressRegistry [ propertyAddressHash ] [ i ] ; }
function addChunk6ToWhiteList ( ) external onlyOwner { require ( ! chunk6IsAdded ) ; addToWhitelist ( 0xC9403834046d64AAc2F98BA9CD29A84D48DBF58D , 3 ether ) ; addToWhitelist ( 0xd0f9899ec83BF1cf915bf101D6E7949361151523 , 3 ether ) ; addToWhitelist ( 0xeB386a17ED99148dc98F07D0714751786836F68e , 3 ether ) ; addToWhitelist ( 0xeFc85EbccE16Db424fCEfBfA4a523fC9957C0E63 , 3 ether ) ; addToWhitelist ( 0xfa52B6F191F57284762617Cfdbbf187E10C02D93 , 3 ether ) ; addToWhitelist ( 0xfd0928783dd997D982AeeE5399f9B6816FbF789B , 3 ether ) ; addToWhitelist ( 0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD , 3 ether ) ; addToWhitelist ( 0xe9Cc01e48F027a0BFa97aFDa0229F09EDD9a590b , 3.7 ether ) ; addToWhitelist ( 0x4f7c845e4d09c3453bcfe03dd09cc96b5c6941a3 , 4 ether ) ; addToWhitelist ( 0x0d41F957181E584dB82d2E316837B2DE1738C477 , 5 ether ) ; addToWhitelist ( 0x102A65de4c20BCe35Aa9B6ae2eA2ecf60c91831B , 5 ether ) ; addToWhitelist ( 0x1Cff36DeBD53EEB3264fD75497356132C4067632 , 5 ether ) ; addToWhitelist ( 0x21a39c71cb9544336e24d57df3655f30be99cf3b , 5 ether ) ; addToWhitelist ( 0x221CDC565782c03fe4ca913f1392741b67d48a81 , 5 ether ) ; addToWhitelist ( 0x280cbA9bB3bd5E222B75fd9D5ff0D3Ec43F0D087 , 5 ether ) ; addToWhitelist ( 0x2Fc0F28ee6C0172bD7D4DDbf791Fd520B29b10a1 , 5 ether ) ; addToWhitelist ( 0x3243d70ed16410F55f22684a8768e7492E91108b , 5 ether ) ; addToWhitelist ( 0x44b38befe7a68fdbd50963feaa06566980a92f7e , 5 ether ) ; addToWhitelist ( 0x4AA75e261b28884718c49DA3f671b3C32a467faD , 5 ether ) ; addToWhitelist ( 0x522e98867715dA9e1fD87A7e759081cCE8ae61d6 , 5 ether ) ; addToWhitelist ( 0x54e0766871b94d02f148b21a15d7ae4679f19c39 , 5 ether ) ; addToWhitelist ( 0x61cf029E58713260aCDAd6e46a54BA687A465064 , 5 ether ) ; addToWhitelist ( 0x6A4234773DC2c3cb4d2951aAa50107E9454451C1 , 5 ether ) ; addToWhitelist ( 0x6beb418fc6e1958204ac8baddcf109b8e9694966 , 5 ether ) ; addToWhitelist ( 0x90c0E8849266AE128aA355B46D090802DCfB1a25 , 5 ether ) ; addToWhitelist ( 0x9b2c4a09ee37105d7ee139b83ca281ab20f6ca78 , 5 ether ) ; addToWhitelist ( 0x9E4a9f2b4eFd85972cF952d2f5Fb16C291ED43B3 , 5 ether ) ; addToWhitelist ( 0xafa2a0cd8ed977c2515b266c3bcc6fe1096c573d , 5 ether ) ; addToWhitelist ( 0xC1A065a2d29995692735c82d228B63Df1732030E , 5 ether ) ; addToWhitelist ( 0xD069A2c75999B87671a29c61B25848ee288a9d75 , 5 ether ) ; addToWhitelist ( 0xd10f3f908611eca959f43667975f9e917435a449 , 5 ether ) ; addToWhitelist ( 0xd4e470fad0d7195699cA9B713fD7C5196cb61Fec , 5 ether ) ; addToWhitelist ( 0xC32e75369bFcef12195741954687e211B3Bc807A , 6 ether ) ; addToWhitelist ( 0xe6fabdca7cb022434a61839268a7d9c10baf5eb2 , 6 ether ) ; addToWhitelist ( 0xe26b11577372aa5e9c10407fe8f7cce6cb88aba0 , 7 ether ) ; addToWhitelist ( 0x0edc326b97F071C1a5393Ba5344bb762DEE0C53a , 10 ether ) ; addToWhitelist ( 0x2A3F7E5170Ea8Ca967f85f091eF84591f639E031 , 10 ether ) ; addToWhitelist ( 0x32f3474D1eB6aA38A85a7bb4fB85715A216A2640 , 10 ether ) ; addToWhitelist ( 0x49CEF0ce48ab89E6C8bB50a184FbEb19b44Ade63 , 10 ether ) ; addToWhitelist ( 0x67D8dFF88562D156a2306CE5f2eFCA0b452aAdD2 , 10 ether ) ; addToWhitelist ( 0x969f18769a75847d39e91ad0dbdfd80820293b0d , 10 ether ) ; addToWhitelist ( 0x976D1CF16b5b2567503246d7D980F86234cB1fAd , 10 ether ) ; addToWhitelist ( 0xA02f61FE8DeB678b53a4eA1BE0353f4F78D16a5a , 10 ether ) ; addToWhitelist ( 0xd573C0f13aC91d30bC0A08F1c256063e3a6928eF , 10 ether ) ; addToWhitelist ( 0xe5FbbDfd081aaD4913eB25e4b195Ba15C2d64de5 , 10 ether ) ; addToWhitelist ( 0xf159FdAfA300d4b7E417CFE06d55F09d93b60E53 , 10 ether ) ; addToWhitelist ( 0xf831dB774BfC4e2c74b9b42474a0e0DD60B342b1 , 10 ether ) ; addToWhitelist ( 0x8A7aA336E1909641558B906585fc56DeE2B44Dd0 , 15 ether ) ; addToWhitelist ( 0x48ce7eBe80d771a7023E1dC3eB632a4E6Cb0559b , 20 ether ) ; addToWhitelist ( 0x6818025bd0e89506D3D34B0C45cC1E556d2Dbc5B , 20 ether ) ; addToWhitelist ( 0x9BE1c7a1F118F61740f01e96d292c0bae90360aB , 20 ether ) ; addToWhitelist ( 0xa1B0dDDEFFf18651206ae2d68A14f024760eAa75 , 20 ether ) ; chunk6IsAdded = true ; }
function start ( ) adminOnly public { isSetupMode = false ; }
function appendDelegate ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { Pledge storage p = findPledge ( idPledge ) ; require ( p . delegationChain . length < MAX_DELEGATES ) ; uint64 [ ] memory newDelegationChain = new uint64 [ ] ( p . delegationChain . length + 1 ) ; for ( uint i = 0 ; i < p . delegationChain . length ; i ++ ) { newDelegationChain [ i ] = p . delegationChain [ i ] ; } newDelegationChain [ p . delegationChain . length ] = idReceiver ; uint64 toPledge = findOrCreatePledge ( p . owner , newDelegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }
function getInvertedPriceInfo ( address ofAsset ) view returns ( bool isRecent , uint invertedPrice , uint assetDecimals ) { uint inputPrice ; ( isRecent , inputPrice , assetDecimals ) = getPriceInfo ( ofAsset ) ; uint quoteDecimals = getDecimals ( QUOTE_ASSET ) ; return ( isRecent , mul ( 10 ** uint ( quoteDecimals ) , 10 ** uint ( assetDecimals ) ) / inputPrice , quoteDecimals ) ; }
function cancelSale ( uint256 _tokenId ) public { Sale storage sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _cancelSale ( _tokenId , seller ) ; }
function claimThrone ( string _monarchName ) { externalEnter ( ) ; claimThroneRP ( _monarchName ) ; externalLeave ( ) ; }
function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( balancesDB . move ( _from , _to , _amount ) ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( _from , _to , _amount ) ; } }
function doSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return false ; } if ( _escrow . sellerCanCancelAfter <= 1 || _escrow . sellerCanCancelAfter > block . timestamp ) { return false ; } uint128 _gasFees = _escrow . totalGasFeesSpentByRelayer + ( msg . sender == relayer ? ( GAS_doSellerCancel + _additionalGas ) * uint128 ( tx . gasprice ) : 0 ) ; delete escrows [ _tradeHash ] ; emit CancelledBySeller ( _tradeHash ) ; transferMinusFees ( _seller , _value , _gasFees , 0 ) ; return true ; }
function getModulesByName ( bytes32 _name ) external view returns ( address [ ] ) ;
function getPackage ( uint idPackage ) constant public returns ( string name , address repo , DAppNodePackageStatus status ) { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; name = c . name ; repo = c . repo ; status = c . status ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { return transferWithData ( _to , _value , "" ) ; }
function registerTicker ( address _owner , string _ticker , string _tokenName ) external whenNotPausedOrOwner { require ( _owner != address ( 0 ) , "Owner should not be 0x" ) ; require ( bytes ( _ticker ) . length > 0 && bytes ( _ticker ) . length <= 10 , "Ticker length range (0,10]" ) ; uint256 tickerFee = getTickerRegistrationFee ( ) ; if ( tickerFee > 0 ) require ( IERC20 ( getAddress ( POLYTOKEN ) ) . transferFrom ( msg . sender , address ( this ) , tickerFee ) , "Insufficent allowance" ) ; string memory ticker = Util . upper ( _ticker ) ; require ( _tickerAvailable ( ticker ) , "Ticker is reserved" ) ; address previousOwner = _tickerOwner ( ticker ) ; if ( previousOwner != address ( 0 ) ) { _deleteTickerOwnership ( previousOwner , ticker ) ; } _addTicker ( _owner , ticker , _tokenName , now , now . add ( getExpiryLimit ( ) ) , false , false , tickerFee ) ; }
function pushDividendPaymentToAddresses ( uint256 _dividendIndex , address [ ] _payees ) public withPerm ( DISTRIBUTE ) validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; for ( uint256 i = 0 ; i < _payees . length ; i ++ ) { if ( ! dividend . claimed [ _payees [ i ] ] ) { _payDividend ( _payees [ i ] , dividend , _dividendIndex ) ; } } }
function checkBan ( address _user ) external view returns ( bool ) { return bannedUser [ _user ] ; }
function buyMetalFactory ( ) public payable returns ( uint256 ) { return buyFactory ( FactoryType . Metal ) ; }
function staticExchangeChecks_ ( OrderData data ) public view onlySelf returns ( bool checksPassed ) { return ( block . timestamp <= data . expirationTimeSeconds && toBytes4 ( data . takerAssetData , 0 ) == bytes4 ( 0xf47261b0 ) && toBytes4 ( data . makerAssetData , 0 ) == bytes4 ( 0xf47261b0 ) && data . takerFee == 0 && ( data . takerAddress == address ( 0x0 ) || data . takerAddress == address ( this ) ) && ( data . senderAddress == address ( 0x0 ) || data . senderAddress == address ( this ) ) ) ; }
function validateProposedKingdomName ( string _kingdomName ) constant returns ( bool allowed ) { return validateNameInternal ( _kingdomName ) ; }
function withdraw ( Data storage self , string currency , address account , uint amount , string issuerFirm ) internal returns ( bool success ) { bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , account ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.issued' , currency , issuerFirm ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.supply' , currency ) ) ; require ( self . Storage . setUint ( id_a , self . Storage . getUint ( id_a ) . sub ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( self . Storage . setUint ( id_b , self . Storage . getUint ( id_b ) . sub ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( self . Storage . setUint ( id_c , self . Storage . getUint ( id_c ) . sub ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; emit Withdraw ( currency , account , amount , issuerFirm ) ; return true ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value < allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }
function burn ( uint256 _value ) public returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }
function _resolveAquarium ( uint256 _seed ) internal { bytes32 tempHash = keccak256 ( _seed ) ; FishingAttempt storage tempAttempt = pendingFishing [ tempHash ] ; require ( tempAttempt . fisher != address ( 0 ) ) ; if ( tempAttempt . affiliate != address ( 0 ) && ! affiliated [ tempAttempt . fisher ] ) { chests . mintChest ( tempAttempt . affiliate , 1 , 0 , 0 , 0 , 0 ) ; affiliated [ tempAttempt . fisher ] = true ; } uint32 [ 4 ] memory fishParams = utils . getFishParams ( _seed , tempAttempt . seed , fishes . length , block . coinbase ) ; _mintFish ( tempAttempt . fisher , fishParams [ 3 ] , uint8 ( fishParams [ 0 ] ) , uint8 ( fishParams [ 1 ] ) , uint8 ( fishParams [ 2 ] ) , bytes16 ( keccak256 ( _seed ^ tempAttempt . seed ) ) ) ; beneficiary . transfer ( tempAttempt . feePaid ) ; AquariumResolved ( tempHash , tempAttempt . fisher ) ; delete pendingFishing [ tempHash ] ; }
function lockup ( address wallet , uint256 duration ) public onlyOwner { uint256 lockupExpiration = duration . add ( now ) ; lockupExpirations [ wallet ] = lockupExpiration ; emit LockupApplied ( wallet , lockupExpiration ) ; }
function setAssetStats ( uint16 _assetId , uint8 [ STATS_SIZE ] _stats ) external onlyCLevel { assetToStats [ _assetId ] = _stats ; }
function check ( ) external view returns ( uint256 , uint256 , uint256 , uint256 ) { return ( _info [ msg . sender ] . totalAmount , _info [ msg . sender ] . receivedAmount , _info [ msg . sender ] . startTime , _info [ msg . sender ] . releaseTime ) ; }
function operatorBatchSend ( address _from , address [ ] _recipients , uint256 [ ] _amounts , bytes _userData , bytes _operatorData ) external whenNotPaused whenAccountNotFrozen ( msg . sender ) whenAccountNotFrozen ( _from ) { require ( _recipients . length == _amounts . length , "The lengths of _recipients and _amounts should be the same." ) ; require ( isOperatorFor ( msg . sender , _from ) ) ; for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { doSend ( msg . sender , _from , _recipients [ i ] , _amounts [ i ] , _userData , _operatorData , true ) ; } }
function symbol ( ) external view returns ( string _symbol ) { return nftSymbol ; }
function _productExists ( uint256 _productId ) internal view returns ( bool ) { return products [ _productId ] . id != 0 ; }
function addBeneficiary ( address _beneficiary , uint256 _start , uint256 _cliff , uint256 _duration , uint256 _amount ) public onlyOwner validAddress ( _beneficiary ) returns ( address ) { require ( _beneficiary != owner ) ; require ( _amount > 0 ) ; require ( _duration >= _cliff ) ; require ( SafeMath . sub ( totalFunds , distributedTokens ) >= _amount ) ; require ( token . balanceOf ( address ( this ) ) >= _amount ) ; if ( ! beneficiaryExists ( _beneficiary ) ) { beneficiaries . push ( _beneficiary ) ; } distributedTokens = distributedTokens . add ( _amount ) ; address tokenVesting = new TokenVesting ( _beneficiary , _start , _cliff , _duration , false ) ; beneficiaryDistributionContracts [ _beneficiary ] . push ( tokenVesting ) ; distributionContracts [ tokenVesting ] = true ; token . safeTransfer ( tokenVesting , _amount ) ; emit BeneficiaryAdded ( _beneficiary , tokenVesting , _amount ) ; return tokenVesting ; }
function sellAllDolAtOnce ( ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( this . balance > sellPrice ) ; if ( tokenBalanceOf [ msg . sender ] * sellPrice <= this . balance ) { sell ( tokenBalanceOf [ msg . sender ] ) ; } else { sell ( this . balance / sellPrice ) ; } }
function closeSale ( ) public onlyController { require ( campaignState == 2 ) ; campaignState = 1 ; CampaignClosed ( now ) ; }
function getRegistry ( ) external view returns ( address ) { return address ( _registry ) ; }
function createRewardCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } rewardsRedeemed ++ ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 0 , _nftData ) ; }
function setMinETH ( uint wad ) public auth { minETH = wad ; }
function getOwner ( uint ownerIndex ) public constant returns ( address ) { return m_owners [ ownerIndex + 1 ] ; }
function claimTokens ( ERC20TokenInterface _address ) public { require ( state == State . Successful ) ; require ( msg . sender == creator ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( creator , remainder ) ; }
function balanceOf ( address _tokenHolder ) public view returns ( uint256 ) { return balancesDB . getBalance ( _tokenHolder ) ; }
function balanceOf ( address _addr ) public view returns ( uint256 ) { return balances [ _addr ] ; }
function getPerson ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = startingPrice ; if ( sellingPrice < firstStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 200 ) , 94 ) ; } else if ( sellingPrice < secondStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 120 ) , 94 ) ; } else { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 115 ) , 94 ) ; } }
function blacklistAddresses ( address [ ] _investors ) public onlyController { for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { blacklist ( _investors [ i ] ) ; } }
function setModule ( address _acct , bool _set ) external onlyOwner returns ( bool ) { modules [ _acct ] = _set ; emit ModuleSet ( _acct , _set ) ; return true ; }
function tokenMetadataHash ( uint256 index ) public view returns ( bytes32 ) { return keccak256 ( loans [ index ] . metadata ) ; }
function getLowerSTVersionBounds ( ) external view returns ( uint8 [ ] ) ;
function isAttributeType ( uint256 attributeTypeID ) public view returns ( bool ) { return _attributeTypes [ attributeTypeID ] . exists ; }
function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = playerIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( isTransferEnabled ) ; return doTransfer ( msg . sender , _to , _value ) ; }
function setFactoryAsset ( uint256 _factoryId , uint16 _assetId ) external onlyCLevel { factoryToAssetId [ _factoryId ] = _assetId ; }
function buyShares ( ) payable ;
function setCOO ( address _newCOO ) external onlyCEO { require ( _newCOO != address ( 0 ) ) ; cooAddress = _newCOO ; }
function transferToContract ( address _to , uint _value , bytes _data ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; ContractReceiver receiver = ContractReceiver ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; emit Transfer ( msg . sender , _to , _value ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
function verify ( address _sender , uint256 _amount , uint8 _v , bytes32 _r , bytes32 _s ) public pure returns ( address ) { bytes32 hash = keccak256 ( abi . encodePacked ( _sender , _amount ) ) ; bytes memory prefix = '\x19Ethereum Signed Message:\n32' ; return ecrecover ( keccak256 ( abi . encodePacked ( prefix , hash ) ) , _v , _r , _s ) ; }
function create ( address intelProvider , uint depositAmount , uint desiredReward , uint intelID , uint ttl ) public { require ( address ( intelProvider ) != address ( 0x0 ) ) ; require ( depositAmount > 0 ) ; require ( desiredReward > 0 ) ; require ( ttl > now ) ; token . transferFrom ( intelProvider , address ( this ) , depositAmount ) ; address [ ] memory contributionsList ; IntelState memory newIntel = IntelState ( intelProvider , depositAmount , desiredReward , depositAmount , intelID , ttl , false , contributionsList ) ; intelDB [ intelID ] = newIntel ; IntelsByProvider [ intelProvider ] . push ( newIntel ) ; intelIndexes . push ( intelID ) ; intelCount ++ ; emit NewIntel ( intelProvider , depositAmount , desiredReward , intelID , ttl ) ; }
function getModule ( uint8 _moduleType , uint _moduleIndex ) public view returns ( bytes32 , address ) { if ( modules [ _moduleType ] . length > 0 ) { return ( modules [ _moduleType ] [ _moduleIndex ] . name , modules [ _moduleType ] [ _moduleIndex ] . moduleAddress ) ; } else { return ( "" , address ( 0 ) ) ; } }
function proposeOwnership ( address _newOwnerCandidate ) external onlyOwner { newOwnerCandidate = _newOwnerCandidate ; emit OwnershipRequested ( msg . sender , newOwnerCandidate ) ; }
function burn ( uint256 _amount ) public requiresPermission whenNotPaused { _burn ( msg . sender , _amount ) ; }
function whitelistAddresses ( address [ ] _investors ) public onlyOwner { for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { whitelist ( _investors [ i ] ) ; } }
function numberOfPledges ( ) constant returns ( uint ) { return pledges . length - 1 ; }
function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ) { require ( transfer ( _to , _value ) ) ; uint codeLength ; assembly { codeLength := extcodesize ( _to ) } if ( codeLength > 0 ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } return true ; }
function addressHasCode ( address _contract ) internal constant returns ( bool ) { uint size ; assembly { size := extcodesize ( _contract ) } return size > 0 ; }
function settle ( Data storage self ) notSettledButClosed ( self ) timeoutOver ( self ) { StandardToken token = self . manager . token ( ) ; if ( self . completed_transfers > 0 ) { require ( token . transfer ( self . receiver , self . completed_transfers ) ) ; } if ( self . completed_transfers < self . balance ) { require ( token . transfer ( self . sender , self . balance - self . completed_transfers ) ) ; } self . settled = block . number ; }
function transferOwnership ( address newOwner ) ;
function approveMotion ( uint motionID ) external onlyOwner { require ( motionConfirming ( motionID ) && motionPasses ( motionID ) ) ; address target = motionTarget [ motionID ] ; nomin . freezeAndConfiscate ( target ) ; _closeMotion ( motionID ) ; emit MotionApproved ( motionID ) ; }
function setPresaleFinalizeAgent ( address _agentAddress ) whenNotPaused onlyOwner external { presaleFinalizeAgent = PresaleFinalizeAgent ( _agentAddress ) ; }
function replaceOwner ( address _newOwner ) public onlyOwner returns ( bool success ) { owner = _newOwner ; NewOwner ( _newOwner ) ; return true ; }
function approve ( address _spender , uint256 _amount ) public erc20 returns ( bool success ) { require ( balancesDB . setApprove ( msg . sender , _spender , _amount ) ) ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
function setEnforceKyc ( bool enforce ) public onlyOwner { enforceKyc = enforce ; }
function multisend ( address [ ] _recipients , uint256 [ ] _balances ) public { require ( _recipients . length == _balances . length , "not equal length" ) ; require ( _recipients . length <= multiSendLimit , "more than limit" ) ; uint256 i = 0 ; for ( i ; i < _balances . length ; i ++ ) { transfer ( _recipients [ i ] , _balances [ i ] ) ; } emit Multisended ( ) ; }
function approve ( address _who , uint256 _value ) public returns ( bool ) { require ( _who != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _who ] == 0 ) ; allowed [ msg . sender ] [ _who ] = _value ; emit Approval ( msg . sender , _who , _value ) ; return true ; }
function setCaps ( uint256 _goal , uint256 _softCap , uint256 _softCapTime , uint256 _cap ) public onlyOwner beforeSale { require ( 0 < _goal && _goal <= _softCap && _softCap <= _cap ) ; goal = _goal ; softCap = _softCap ; softCapTime = _softCapTime ; cap = _cap ; }
function createRequestAsPayerAction ( address [ ] _payeesIdAddress , int256 [ ] _expectedAmounts , address _payerRefundAddress , uint256 [ ] _payeeAmounts , uint256 [ ] _additionals , string _data ) public payable whenNotPaused returns ( bytes32 requestId ) { require ( msg . sender != _payeesIdAddress [ 0 ] && _payeesIdAddress [ 0 ] != 0 , "caller should not be the main payee" ) ; uint256 collectedFees ; ( requestId , collectedFees ) = createCoreRequestInternal ( msg . sender , _payeesIdAddress , _expectedAmounts , _data ) ; require ( collectedFees == msg . value , "fees should be the correct amout" ) ; if ( _payerRefundAddress != 0 ) { payerRefundAddress [ requestId ] = _payerRefundAddress ; } int256 totalExpectedAmounts = 0 ; for ( uint8 i = 0 ; i < _expectedAmounts . length ; i = i . add ( 1 ) ) { totalExpectedAmounts = totalExpectedAmounts . add ( _expectedAmounts [ i ] ) ; } acceptAndPay ( requestId , _payeeAmounts , _additionals , totalExpectedAmounts ) ; return requestId ; }
function finished ( ) public { require ( state == State . Successful ) ; uint256 remainder = tokenReward . balanceOf ( this ) ; if ( address ( this ) . balance > 0 ) { creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; } tokenReward . transfer ( creator , remainder ) ; emit LogContributorsPayout ( creator , remainder ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( frozen [ _from ] == false && frozen [ msg . sender ] == false ) ; require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
function disableERC20 ( ) public onlyOwner { mErc20compatible = false ; setInterfaceImplementation ( "ERC20Token" , 0x0 ) ; emit ERC20Disabled ( ) ; }
function getPlayerStatus ( uint256 _gameID , uint256 _pID ) public view isActivated ( _gameID ) returns ( bytes32 , uint256 [ ] memory , uint256 [ ] memory , uint256 [ ] memory , uint256 [ ] memory ) { uint256 _nt = game_ [ _gameID ] . numberOfTeams ; uint256 [ ] memory _eth = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _keys = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _instWin = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _potWin = new uint256 [ ] ( _nt ) ; uint256 i ; for ( i = 0 ; i < _nt ; i ++ ) { _eth [ i ] = playerTeams_ [ _pID ] [ _gameID ] [ i ] . eth ; _keys [ i ] = playerTeams_ [ _pID ] [ _gameID ] [ i ] . keys ; _instWin [ i ] = getPlayerInstWinning ( _gameID , _pID , i ) ; _potWin [ i ] = getPlayerPotWinning ( _gameID , _pID , i ) ; } return ( FSBook . getPlayerName ( _pID ) , _eth , _keys , _instWin , _potWin ) ; }
function revokeAndReclaim ( ) pre_cond ( isOwner ( ) ) pre_cond ( ! isVestingRevoked ( ) ) { uint reclaimable = totalVestedAmount . sub ( calculateWithdrawable ( ) ) ; withdrawnByBeneficiary = withdrawnMelon ( ) ; revoked = true ; assert ( MELON_CONTRACT . transfer ( owner , reclaimable ) ) ; }
function withdrawEther ( address to ) public validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) { to . transfer ( this . balance ) ; }
function checkIcoStatus ( ) internal { if ( tokenBalanceOf [ this ] <= _totalSupply - icoLimit ) { icoIsRunning = false ; } }
function isDAppReady ( ) external isAdmin { uint8 numOfApprovals = 0 ; for ( uint i = 0 ; i < devApprovals . length ; i ++ ) { if ( devApprovals [ i ] ) { numOfApprovals ++ ; } } DAppReady = ( numOfApprovals >= 2 ) ; }
function isRegistered ( address _darknodeID ) public view returns ( bool ) { return isRegisteredInEpoch ( _darknodeID , currentEpoch ) ; }
function ownerClawback ( ) external onlyOwner { require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; require ( now >= OWNER_CLAWBACK_DATE ) ; owner . transfer ( this . balance ) ; }
function finishMintingIssuer ( ) public onlyOwner { finishedIssuerMinting = true ; emit LogFinishMintingIssuer ( now ) ; }
function claimTokens ( ERC20Basic _token ) external onlyOwner { require ( isFinalized ) ; uint256 balance = _token . balanceOf ( this ) ; _token . transfer ( owner , balance ) ; emit ClaimTokens ( _token , balance ) ; }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused canBeStoredIn40Bits ( _tokenId ) { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( saleMarket ) ) ; require ( _to != address ( breedingMarket ) ) ; require ( _approvedFor ( msg . sender , uint40 ( _tokenId ) ) || _isApprovedForAll ( _from , msg . sender ) ) ; require ( _isOwner ( _from , uint40 ( _tokenId ) ) ) ; _transfer ( _from , _to , uint40 ( _tokenId ) ) ; }
function setForwardedAccount ( Data storage self , address originalAccount , address forwardedAccount ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'master.account' , forwardedAccount ) ) ; require ( self . Storage . setAddress ( id , originalAccount ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function changeInitialPrice ( uint256 identifier , uint256 newPrice ) public onlyCFO { require ( identifierToOwner [ identifier ] == address ( this ) ) ; identifierToPrice [ identifier ] = newPrice ; Price ( identifier , newPrice , nextPrice ( newPrice ) ) ; }
function auditContract ( bytes32 _codeHash , bool _isApproved ) public whenNotPaused { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( msg . sender , _codeHash ) ) ; uint8 outcome = SolidStampRegister ( SolidStampRegisterAddress ) . getAuditOutcome ( msg . sender , _codeHash ) ; require ( outcome == NOT_AUDITED , "contract already audited" ) ; SolidStampRegister ( SolidStampRegisterAddress ) . registerAuditOutcome ( msg . sender , _codeHash , _isApproved ) ; uint reward = Rewards [ hashAuditorCode ] ; TotalRequestsAmount = TotalRequestsAmount . sub ( reward ) ; uint commissionKept = calcCommission ( reward ) ; AvailableCommission = AvailableCommission . add ( commissionKept ) ; emit ContractAudited ( msg . sender , _codeHash , reward , _isApproved ) ; msg . sender . transfer ( reward . sub ( commissionKept ) ) ; }
function _getExtraParam ( bytes _extraData ) private pure returns ( uint256 val1 , uint256 val2 , uint256 val3 ) { if ( _extraData . length == 2 ) { val1 = uint256 ( _extraData [ 0 ] ) ; val2 = uint256 ( _extraData [ 1 ] ) ; val3 = 1 ; } else if ( _extraData . length == 3 ) { val1 = uint256 ( _extraData [ 0 ] ) ; val2 = uint256 ( _extraData [ 1 ] ) ; val3 = uint256 ( _extraData [ 2 ] ) ; } }
function create ( ) payable external { if ( ! funding ) throw ; if ( block . number < fundingStartBlock ) throw ; if ( block . number > fundingEndBlock ) throw ; if ( msg . value == 0 ) throw ; if ( msg . value > ( tokenCreationCap - totalTokens ) / tokenCreationRate ) throw ; var numTokens = msg . value * tokenCreationRate ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
function addAffiliate ( address _investor , address _affiliate ) onlyOwner { affiliates [ _investor ] = Affiliate ( _affiliate , true ) ; }
function setClaim ( address subject , bytes32 key , bytes32 value ) public { revert ( ) ; }
function getAmountToGive ( OrderData order ) public view onlySelf returns ( uint256 amountToGive ) { amountToGive = getAvailableTakerVolume ( order ) ; }
function getAllDelegates ( ) external view returns ( address [ ] ) { return allDelegates ; }
function getContentByName ( ContentMapping storage self , string _name ) public view returns ( Content storage _content , bool exists ) { bytes32 _hash = generateContentID ( _name ) ; return ( self . data [ _hash ] , self . data [ _hash ] . addedOn != 0 ) ; }
function createAuction ( uint256 _deedId , uint256 _startPrice , uint256 _endPrice , uint256 _duration , uint256 _rentPeriod ) external { require ( _rentPeriod >= 3600 ) ; DWorldRenting dWorldRentingContract = DWorldRenting ( deedContract ) ; var ( renter , ) = dWorldRentingContract . renterOf ( _deedId ) ; require ( renter == address ( 0 ) ) ; identifierToRentPeriod [ _deedId ] = _rentPeriod ; createAuction ( _deedId , _startPrice , _endPrice , _duration ) ; }
function ( ) public payable { require ( msg . value == TOTAL_ETHER_HARD_CAP ) ; require ( address ( this ) . balance <= TOTAL_ETHER_HARD_CAP , "Contract balance hardcap reachead" ) ; }
function transfer ( address _to , uint _amount ) returns ( bool ) ;
function onApprove ( address _owner , address , uint ) public returns ( bool success ) { if ( _owner == controller || _owner == address ( this ) ) { return true ; } return transferable ; }
function transferFrom ( address from , address to , uint256 amount ) public returns ( bool success ) { bool amountApproved = _allowed [ from ] [ msg . sender ] >= amount ; require ( amountApproved ) ; _allowed [ from ] [ msg . sender ] -= amount ; mTransfer ( from , to , amount ) ; return true ; }
function setAllowChangePrice ( bool _allowChangePrice ) external onlyCFO { allowChangePrice = _allowChangePrice ; }
function calcSharePriceAndAllocateFees ( ) public returns ( uint ) { var ( gav , managementFee , performanceFee , unclaimedFees , feesShareQuantity , nav , sharePrice ) = performCalculations ( ) ; createShares ( owner , feesShareQuantity ) ; uint highWaterMark = atLastUnclaimedFeeAllocation . highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation . highWaterMark : sharePrice ; atLastUnclaimedFeeAllocation = Calculations ( { gav : gav , managementFee : managementFee , performanceFee : performanceFee , unclaimedFees : unclaimedFees , nav : nav , highWaterMark : highWaterMark , totalSupply : totalSupply , timestamp : now } ) ; FeesConverted ( now , feesShareQuantity , unclaimedFees ) ; CalculationUpdate ( now , managementFee , performanceFee , nav , sharePrice , totalSupply ) ; return sharePrice ; }
function announceWithdraw ( address _token , uint256 _amount ) external { require ( _amount <= balances [ msg . sender ] [ _token ] , "Amount too high" ) ; AnnouncedWithdrawal storage announcement = announcedWithdrawals [ msg . sender ] [ _token ] ; uint256 canWithdrawAt = now + withdrawAnnounceDelay ; announcement . canWithdrawAt = canWithdrawAt ; announcement . amount = _amount ; emit WithdrawAnnounce ( msg . sender , _token , _amount , canWithdrawAt ) ; }
function mintToken ( address target , uint mintAmount ) internal { balances [ target ] = safeAdd ( balances [ target ] , mintAmount ) ; _totalSupply = safeAdd ( _totalSupply , mintAmount ) ; emit Transfer ( owner , target , mintAmount ) ; }
function verifyInvestment ( address _beneficiary , uint256 _fundsAmount ) public view returns ( bool ) { return polyToken . allowance ( _beneficiary , address ( this ) ) >= _fundsAmount ; }
function buyTokensWithPoly ( uint256 _investedPOLY ) public nonReentrant { require ( ! paused , "Should not be paused" ) ; require ( fundRaiseTypes [ uint8 ( FundRaiseType . POLY ) ] , "Mode of investment is not POLY" ) ; _processTx ( msg . sender , _investedPOLY ) ; _forwardPoly ( msg . sender , wallet , _investedPOLY ) ; _postValidatePurchase ( msg . sender , _investedPOLY ) ; }
function transfer ( address _receiver , uint256 _amount ) public returns ( bool _transferred ) { require ( ! tokenTransfersFrozen ) ; require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; return true ; }
function setEscrow ( address _address ) public onlyOwner { escrow = IEscrow ( _address ) ; }
function cancelPayment ( uint _idPayment ) onlyOwner { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( p . canceled ) throw ; if ( p . paid ) throw ; p . canceled = true ; PaymentCanceled ( _idPayment ) ; }
function orderState ( bytes32 _orderID ) external view returns ( OrderState ) { return orders [ _orderID ] . state ; }
function transferWei ( address _contractAddress ) public isOwner isClosed { uint256 weiForTransfer = weiTransferCalculator ( ) ; if ( adminFeePercentage > 0 ) { weiForTransfer = payOutAdminFee ( weiForTransfer ) ; } require ( weiForTransfer > 0 ) ; _contractAddress . transfer ( weiForTransfer ) ; setPoolToAwaitingTokens ( ) ; emit EtherTransferredOut ( weiForTransfer ) ; }
function ( ) public { require ( false , "Fallback function always throws." ) ; }
function checkSplitEnd ( uint256 i ) internal { if ( i == users . length - 1 ) { assetThaw ( ) ; balances [ 0x166Cb48973C2447dafFA8EFd3526da18076088de ] = balances [ 0x166Cb48973C2447dafFA8EFd3526da18076088de ] + currentProfits / 22 ; balances [ selfAddress ] = balances [ selfAddress ] - actualProfitSplit - currentProfits / 22 ; } }
function changeSponseeAddress ( address _newAddress ) onlyAccountAddressForSponsee { sponseeAddress = _newAddress ; LogChangeSponseeAddress ( _newAddress ) ; }
function uint2str ( uint i ) internal pure returns ( string ) { if ( i == 0 ) return "0" ; uint j = i ; uint length ; while ( j != 0 ) { length ++ ; j /= 10 ; } bytes memory bstr = new bytes ( length ) ; uint k = length - 1 ; while ( i != 0 ) { bstr [ k -- ] = byte ( 48 + i % 10 ) ; i /= 10 ; } return string ( bstr ) ; }
function close ( uint nonce , uint256 completed_transfers , bytes signature ) { data . close ( address ( this ) , nonce , completed_transfers , signature ) ; ChannelClosed ( msg . sender , data . closed ) ; }
function withdrawBalance ( ) public mustBeAtStage ( Stage . Finalized ) { wallet . transfer ( this . balance ) ; }
function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Insufficent allowance or balance" ) ; address ethDividendCheckpoint = new EtherDividendCheckpoint ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( ethDividendCheckpoint , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return ethDividendCheckpoint ; }
function addManualApproval ( address _from , address _to , uint256 _allowance , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , "Invalid from address" ) ; require ( _to != address ( 0 ) , "Invalid to address" ) ; require ( _expiryTime > now , "Invalid expiry time" ) ; require ( manualApprovals [ _from ] [ _to ] . allowance == 0 , "Approval already exists" ) ; manualApprovals [ _from ] [ _to ] = ManualApproval ( _allowance , _expiryTime ) ; emit AddManualApproval ( _from , _to , _allowance , _expiryTime , msg . sender ) ; }
function transferTokens ( Trade [ ] trades , TradeFlag [ ] tradeFlags ) internal { for ( uint256 i = 0 ; i < trades . length ; i ++ ) { if ( trades [ i ] . isSell && ! tradeFlags [ i ] . ignoreTrade ) { if ( ! TokenTransferProxy ( tokenTransferProxy ) . transferFrom ( trades [ i ] . tokenAddress , msg . sender , address ( this ) , trades [ i ] . tokenAmount ) ) { errorReporter . revertTx ( "TTP unable to transfer tokens to primary" ) ; } emit GenericEvent ( 3 ) ; } } }
function rejectMilestone ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . reviewer ) || ( milestone . status != MilestoneStatus . Completed ) ) throw ; milestone . status = MilestoneStatus . AcceptedAndInProgress ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }
function tokensOfWithData ( address _owner , uint256 _index ) public view returns ( uint256 [ ] , uint256 [ ] ) { uint256 [ ] memory tokensList = ownedTokens [ _owner ] ; uint256 [ ] memory dataList = new uint256 [ ] ( tokensList . length ) ; for ( uint i = 0 ; i < tokensList . length ; i ++ ) { dataList [ i ] = data [ _index ] [ tokensList [ i ] ] ; } return ( tokensList , dataList ) ; }
function mintOnce ( string _key , address _to , uint256 _amount ) private whenNotPaused whenNotMinted ( _key ) { mintTokens ( _to , _amount ) ; mintingList [ computeHash ( _key ) ] = true ; }
function addUsers ( address [ ] _whitelist ) public onlyOracleOrOwner onlySale returns ( uint ) { for ( uint _idx = 0 ; _idx < _whitelist . length ; ++ _idx ) { whitelist [ _whitelist [ _idx ] ] = true ; } return OK ; }
function decimals ( ) public view returns ( uint8 ) { return m_decimals ; }
function getBidIdList ( ) public view returns ( bytes32 [ ] bidIds ) { return bidIdList ; }
function unitPLATCost ( uint256 cardId ) external constant returns ( uint256 ) { return SafeMath . mul ( cardInfo [ cardId ] . ethCost , PLATPrice ) ; }
function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; assert ( getBlockNumber ( ) >= startBlock ) ; assert ( msg . sender == controller || getBlockNumber ( ) > endBlock || tokensForSale ( ) == 0 ) ; apt . changeController ( place_holder ) ; finalizedBlock = getBlockNumber ( ) ; Finalized ( finalizedBlock ) ; }
function isTxExist ( bytes32 _key ) public view returns ( bool ) { return txKey2index [ _key ] != 0 ; }
function createCloneToken ( MiniMeToken _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
function getPolicyDetails ( bytes4 _sig , address _contract ) public view returns ( bytes32 [ ] _groupNames , uint [ ] _acceptLimits , uint [ ] _declineLimits , uint _totalAcceptedLimit , uint _totalDeclinedLimit ) { require ( _sig != bytes4 ( 0 ) ) ; require ( _contract != 0x0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; ( _groupNames , _acceptLimits , _declineLimits , _totalAcceptedLimit , _totalDeclinedLimit , ) = getPolicyDetailsByHash ( _policyHash ) ; }
function emission ( uint _value ) onlyOwner { if ( _value + totalSupply < totalSupply ) throw ; totalSupply += _value ; balances [ owner ] += _value ; }
function setInterfaceImplementer ( address _addr , bytes32 _interfaceHash , address _implementer ) external { address addr = _addr == 0 ? msg . sender : _addr ; require ( getManager ( addr ) == msg . sender , "Not the manager" ) ; require ( ! isERC165Interface ( _interfaceHash ) , "Must not be a ERC165 hash" ) ; if ( _implementer != 0 && _implementer != msg . sender ) { require ( ERC820ImplementerInterface ( _implementer ) . canImplementInterfaceForAddress ( _interfaceHash , addr ) == ERC820_ACCEPT_MAGIC , "Does not implement the interface" ) ; } interfaces [ addr ] [ _interfaceHash ] = _implementer ; emit InterfaceImplementerSet ( addr , _interfaceHash , _implementer ) ; }
function changeAddress ( string _nameKey , address _newAddress ) external onlyOwner { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; emit ChangeAddress ( _nameKey , storedAddresses [ key ] , _newAddress ) ; storedAddresses [ key ] = _newAddress ; }
function ( ) payable ;
function calculateDividend ( uint256 _dividendIndex , address _payee ) public view returns ( uint256 , uint256 ) { require ( _dividendIndex < dividends . length , "Invalid dividend" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; if ( dividend . claimed [ _payee ] || dividend . dividendExcluded [ _payee ] ) { return ( 0 , 0 ) ; } uint256 balance = ISecurityToken ( securityToken ) . balanceOfAt ( _payee , dividend . checkpointId ) ; uint256 claim = balance . mul ( dividend . amount ) . div ( dividend . totalSupply ) ; uint256 withheld = claim . mul ( withholdingTax [ _payee ] ) . div ( uint256 ( 10 ** 18 ) ) ; return ( claim , withheld ) ; }
function distributePresaleTokens ( address _buyer , uint tokens ) external onlyOwner whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 && tokens <= limitPresale ) ; require ( tokensDistributedPresale < limitPresale ) ; require ( tokensDistributedPresale . add ( tokens ) < limitPresale ) ; tokensDistributedPresale = tokensDistributedPresale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
function requestAudit ( address _auditor , bytes32 _codeHash , uint _auditTime ) public whenNotPaused payable { require ( _auditor != 0x0 , "_auditor cannot be 0x0" ) ; require ( _auditTime >= MIN_AUDIT_TIME , "_auditTime should be >= MIN_AUDIT_TIME" ) ; require ( _auditTime <= MAX_AUDIT_TIME , "_auditTime should be <= MIN_AUDIT_TIME" ) ; require ( msg . value > 0 , "msg.value should be >0" ) ; uint8 outcome = SolidStampRegister ( SolidStampRegisterAddress ) . getAuditOutcome ( _auditor , _codeHash ) ; require ( outcome == NOT_AUDITED , "contract already audited" ) ; bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; uint currentReward = Rewards [ hashAuditorCode ] ; uint expireDate = now . add ( _auditTime ) ; Rewards [ hashAuditorCode ] = currentReward . add ( msg . value ) ; TotalRequestsAmount = TotalRequestsAmount . add ( msg . value ) ; bytes32 hashAuditorRequestorCode = keccak256 ( abi . encodePacked ( _auditor , msg . sender , _codeHash ) ) ; AuditRequest storage request = AuditRequests [ hashAuditorRequestorCode ] ; if ( request . amount == 0 ) { AuditRequests [ hashAuditorRequestorCode ] = AuditRequest ( { amount : msg . value , expireDate : expireDate } ) ; emit AuditRequested ( _auditor , msg . sender , _codeHash , msg . value , expireDate ) ; } else { request . amount = request . amount . add ( msg . value ) ; if ( expireDate > request . expireDate ) request . expireDate = expireDate ; emit AuditRequested ( _auditor , msg . sender , _codeHash , request . amount , request . expireDate ) ; } }
function refundMethodABI ( ) public constant returns ( string ) { }
function whitelistAddresses ( address [ ] _investors ) public onlyController { for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { whitelist ( _investors [ i ] ) ; } }
function HAVtoUSD ( uint hav_dec ) public view priceNotStale returns ( uint ) { return safeMul_dec ( hav_dec , price ) ; }
function setBlockLock ( uint256 _lockedUntilBlock ) public onlyOwner returns ( bool success ) { lockedUntilBlock = _lockedUntilBlock ; BlockLockSet ( _lockedUntilBlock ) ; return true ; }
function destroy ( ) onlyOwner { uint256 balance = token . balanceOf ( this ) ; assert ( balance > 0 ) ; token . transfer ( owner , balance ) ; selfdestruct ( owner ) ; }
function transfer ( address to , uint256 tokenAmount ) public tradable ( msg . sender ) returns ( bool success ) { require ( tokenAmount > 0 ) ; require ( tokenAmount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( msg . sender , to , tokenAmount ) ; return true ; }
function addHodlerStake ( address _beneficiary , uint _stake ) public ;
function _setOriginationFee ( uint originationFeeMantissa ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_ORIGINATION_FEE_OWNER_CHECK ) ; } Exp memory oldOriginationFee = originationFee ; originationFee = Exp ( { mantissa : originationFeeMantissa } ) ; emit NewOriginationFee ( oldOriginationFee . mantissa , originationFeeMantissa ) ; return uint ( Error . NO_ERROR ) ; }
function enableWithdrawal ( ) public onlyOwner whenStopped whenWithdrawalDisabled { withdrawalEnabled = true ; emit WithdrawalEnabled ( owner ) ; }
function createNewAccount ( address _newUser ) external onlyAccountRegistryLogic nonZero ( _newUser ) { require ( ! addressBelongsToAccount ( _newUser ) ) ; numAccounts ++ ; accountByAddress [ _newUser ] = numAccounts ; }
function setKingdomCreationFeeWei ( uint _kingdomCreationFeeWei ) { externalEnter ( ) ; setKingdomCreationFeeWeiRP ( _kingdomCreationFeeWei ) ; externalLeave ( ) ; }
function getGrantCount ( ) view public returns ( uint ) { return tokenGrants . length ; }
function getCampaignValidity ( bytes32 bidId ) public view returns ( bool state ) { return advertisementStorage . getCampaignValidById ( bidId ) ; }
function changeTickerRegistrationFee ( uint256 _tickerRegFee ) external ;
function tokenByIndex ( uint256 index ) external view returns ( uint256 ) { require ( _tokenExists ( index ) ) ; return index ; }
function getChampReward ( uint _position ) public view returns ( uint ) { if ( _position <= 800 ) { uint rewardPercentage = uint ( 2000 ) . sub ( 2 * ( _position - 1 ) ) ; uint availableWithdrawal = address ( coreAddress ) . balance . sub ( core . pendingWithdrawal ( ) ) ; return availableWithdrawal / 1000000 * rewardPercentage ; } else { return uint ( 0 ) ; } }
function clearFund ( uint256 _gameID ) external isHuman ( ) isEnded ( _gameID ) onlyDevOrOwner ( ) { require ( now >= game_ [ _gameID ] . withdrawDeadline , "withdraw deadline not passed yet" ) ; require ( gameStatus_ [ _gameID ] . fundCleared == false , "fund already cleared" ) ; gameStatus_ [ _gameID ] . fundCleared = true ; uint256 _totalPot = ( gameStatus_ [ _gameID ] . winningVaultInst ) . add ( gameStatus_ [ _gameID ] . winningVaultFinal ) ; uint256 _amount = _totalPot . sub ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; if ( _amount > 0 ) { Banker_Address . deposit . value ( _amount ) ( ) ; } emit onFundCleared ( _gameID , _amount , now ) ; }
function balanceOf ( address _holder ) public view returns ( uint256 ) { return balances [ _holder ] ; }
function createJob ( string _description , uint _salary , uint _noOfTotalPayments ) public { require ( _salary > 0 ) ; require ( _noOfTotalPayments > 0 ) ; address [ ] memory empty ; uint finalSalary = _salary . sub ( _salary . mul ( 1 ) . div ( 50 ) ) ; Job memory newJob = Job ( _description , msg . sender , finalSalary , 0x0 , JobStatus . Open , _noOfTotalPayments , 0 , 0 , 0 , 0x0 , false , 0 , empty , 0 ) ; Jobs . push ( newJob ) ; JobsByManager [ msg . sender ] . push ( jobCount ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _salary ) ; emit JobCreated ( msg . sender , finalSalary , _noOfTotalPayments , jobCount , _description ) ; jobCount ++ ; DAI . transferFrom ( msg . sender , address ( this ) , _salary ) ; }
function getNow ( ) view public returns ( uint256 ) { return now ; }
function setBalances ( uint256 _peBalance , uint256 _bbBalance ) public { peBalance = _peBalance ; bbBalance = _bbBalance ; }
function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 2 ) ; allPermissions [ 0 ] = WHITELIST ; allPermissions [ 1 ] = FLAGS ; return allPermissions ; }
function approve ( address spender , uint256 value ) public returns ( bool _success ) { require ( spender != address ( 0 ) ) ; require ( value != 0 ) ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }
function removeFromAccountList ( address addr ) internal { require ( ! readOnly , "Read only mode engaged" ) ; uint16 i = 0 ; bool found = false ; address parent ; address current = addressLinkedList [ 0 ] ; while ( true ) { if ( addressLinkedList [ current ] == addr ) { parent = current ; found = true ; break ; } current = addressLinkedList [ current ] ; if ( i ++ > accountCount ) break ; } require ( found , "Account was not found to remove." ) ; addressLinkedList [ parent ] = addressLinkedList [ addressLinkedList [ parent ] ] ; delete addressLinkedList [ addr ] ; if ( balances [ addr ] > 0 ) { balances [ address ( 0 ) ] += balances [ addr ] ; } delete balances [ addr ] ; accountCount -- ; }
function recoverAddress ( bytes32 _h , uint8 _v , bytes32 _r , bytes32 _s ) private pure returns ( address ) { bytes memory _prefix = "\x19Ethereum Signed Message:\n32" ; bytes32 _prefixedHash = keccak256 ( abi . encodePacked ( _prefix , _h ) ) ; return ecrecover ( _prefixedHash , _v , _r , _s ) ; }
function proxy ( address destination , address account , uint amount , uint gasLimit ) public onlyOwner { require ( destination != ParetoAddress ) ; bytes4 sig = bytes4 ( keccak256 ( "transfer(address,uint256)" ) ) ; assembly { let x := mload ( 0x40 ) mstore ( x , sig ) mstore ( add ( x , 0x04 ) , account ) mstore ( add ( x , 0x24 ) , amount ) let success := call ( gasLimit , destination , 0 , x , 0x44 , x , 0x0 ) jumpi ( 0x02 , iszero ( success ) ) } emit LogProxy ( destination , account , amount , gasLimit ) ; }
function updatePackage ( uint idPackage , string name , address repo ) onlyOwner public { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; c . name = name ; c . repo = repo ; PackageUpdated ( idPackage , name , repo ) ; }
function claimTokens ( address _token ) public onlyOwner { require ( _token != address ( att ) ) ; if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
function revealVote ( uint _pollID , uint _voteOption , uint _salt ) external { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( _voteOption , _salt ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender ) ; }
function getTokenBalance ( string currency ) public view returns ( uint balance ) { return lib . getTokenBalance ( currency , address ( this ) ) ; }
function claimTokensFor ( address [ ] _beneficiaries ) external afterSaleSuccess { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { claimTokenFor ( _beneficiaries [ i ] ) ; } }
function setMyICOContract ( address _SCICO ) public onlyOwner { require ( address ( this ) . balance == 0 ) ; addressSCICO = _SCICO ; }
function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { uint256 feePercentage = exchange . fee ( ) ; uint256 availableVolume = exchange . availableVolume ( data . takerToken , data . takerAmount , data . makerToken , data . makerAmount , data . expires , data . nonce , data . user , data . v , data . r , data . s ) ; uint256 fee = SafeMath . div ( SafeMath . mul ( availableVolume , feePercentage ) , 1 ether ) ; return SafeMath . add ( availableVolume , fee ) ; }
function startSale ( ) public { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( ! started ) ; require ( ! finished ) ; started = true ; emit StartedSale ( ) ; }
function removeManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && admins [ account ] && account != owner ) { admins [ account ] = false ; emit AdminRemoved ( _accounts [ i ] ) ; } } return true ; }
function setWeth ( address wethAddress ) public onlyOwner { require ( wethAddress != address ( 0x0 ) ) ; weth = WethInterface ( wethAddress ) ; }
function withdrawTokens ( ) public { distributeTokens ( msg . sender ) ; }
function transferOwnership ( address _newOwner ) public onlyOwner { balances [ _newOwner ] = balances [ owner ] ; balances [ owner ] = 0 ; Ownable . transferOwnership ( _newOwner ) ; }
function hasRole ( address addr , string role ) public view returns ( bool ) { return rbac . hasRole ( addr , role ) ; }
function requestCustodianChange ( address _proposedCustodian ) public returns ( bytes32 lockId ) { require ( _proposedCustodian != address ( 0 ) ) ; lockId = generateLockId ( ) ; custodianChangeReqs [ lockId ] = CustodianChangeRequest ( { proposedNew : _proposedCustodian } ) ; emit CustodianChangeRequested ( lockId , msg . sender , _proposedCustodian ) ; }
function claimPlot ( uint256 _deedId ) external payable whenNotPaused { claimPlotWithData ( _deedId , "" , "" , "" , "" ) ; }
function giveDividend ( uint64 percentage ) public onlyOwner { require ( ! readOnly , "Read only mode engaged" ) ; require ( percentage > 0 , "Percentage must be more than 0 (10000 = 1%)" ) ; require ( percentage <= 500000 , "Percentage may not be larger than 500000 (50%)" ) ; emit DividendGivenEvent ( percentage ) ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { bool found = ignoreDividend [ current ] ; if ( ! found ) { uint256 extraTokens = ( balances [ current ] * percentage ) / 1000000 ; giveReserveTo ( current , extraTokens ) ; } current = addressLinkedList [ current ] ; } }
function verifyTransfer ( address _from , address _to , uint256 , bytes , bool ) public returns ( Result ) { if ( ! paused ) { if ( allowAllTransfers ) { return Result . VALID ; } if ( allowAllBurnTransfers && ( _to == address ( 0 ) ) ) { return Result . VALID ; } if ( allowAllWhitelistTransfers ) { return ( _onWhitelist ( _to ) && _onWhitelist ( _from ) ) ? Result . VALID : Result . NA ; } if ( allowAllWhitelistIssuances && _from == issuanceAddress ) { if ( ! whitelist [ _to ] . canBuyFromSTO && _isSTOAttached ( ) ) { return Result . NA ; } return _onWhitelist ( _to ) ? Result . VALID : Result . NA ; } return ( ( _onWhitelist ( _from ) && whitelist [ _from ] . fromTime <= now ) && ( _onWhitelist ( _to ) && whitelist [ _to ] . toTime <= now ) ) ? Result . VALID : Result . NA ; } return Result . NA ; }
function getAssetPacksUserCreated ( address _address ) public view returns ( uint [ ] ) { return createdAssetPacks [ _address ] ; }
function setNomin ( Nomin _nomin ) external onlyOwner { nomin = _nomin ; emit NominUpdated ( _nomin ) ; }
function _acceptAnchorAdmin ( ) public returns ( uint ) { if ( msg . sender != pendingAnchorAdmin ) { return failOracle ( 0 , OracleError . UNAUTHORIZED , OracleFailureInfo . ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK ) ; } address oldAnchorAdmin = anchorAdmin ; anchorAdmin = pendingAnchorAdmin ; pendingAnchorAdmin = 0 ; emit NewAnchorAdmin ( oldAnchorAdmin , msg . sender ) ; return uint ( Error . NO_ERROR ) ; }
function refundManyAddresses ( uint256 _startIndex , uint256 _numberOfAddresses ) public isCancelled isValidIndex ( _startIndex , _numberOfAddresses ) { uint256 endIndex = _startIndex . add ( _numberOfAddresses . sub ( 1 ) ) ; for ( uint256 i = _startIndex ; i <= endIndex ; ++ i ) { address user = swimmersList [ i ] ; if ( swimmers [ user ] > 0 ) { processRefundInternal ( user ) ; } } }
function getAttributeApprovalHash ( address account , address operator , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee ) external view returns ( bytes32 hash ) ;
function burnCarbonDollar ( address stablecoin , uint256 _amount ) public requiresPermission whenNotPaused { require ( isWhitelisted ( stablecoin ) , "Stablecoin must be whitelisted prior to setting conversion fee" ) ; WhitelistedToken whitelisted = WhitelistedToken ( stablecoin ) ; require ( whitelisted . balanceOf ( address ( this ) ) >= _amount , "Carbon escrow account in WT0 doesn't have enough tokens for burning" ) ; uint256 chargedFee = tokenStorage_CD . computeFee ( _amount , computeFeeRate ( stablecoin ) ) ; uint256 feedAmount = _amount . sub ( chargedFee ) ; _burn ( msg . sender , _amount ) ; whitelisted . burn ( _amount ) ; _mint ( address ( this ) , chargedFee ) ; emit BurnedCUSD ( msg . sender , feedAmount , chargedFee ) ; }
function settleChannel ( uint256 channel_identifier , address participant1 , uint256 participant1_transferred_amount , uint256 participant1_locked_amount , bytes32 participant1_locksroot , address participant2 , uint256 participant2_transferred_amount , uint256 participant2_locked_amount , bytes32 participant2_locksroot ) public { require ( channel_identifier == getChannelIdentifier ( participant1 , participant2 ) ) ; bytes32 pair_hash ; pair_hash = getParticipantsHash ( participant1 , participant2 ) ; Channel storage channel = channels [ channel_identifier ] ; require ( channel . state == ChannelState . Closed ) ; require ( channel . settle_block_number < block . number ) ; Participant storage participant1_state = channel . participants [ participant1 ] ; Participant storage participant2_state = channel . participants [ participant2 ] ; require ( verifyBalanceHashData ( participant1_state , participant1_transferred_amount , participant1_locked_amount , participant1_locksroot ) ) ; require ( verifyBalanceHashData ( participant2_state , participant2_transferred_amount , participant2_locked_amount , participant2_locksroot ) ) ; ( participant1_transferred_amount , participant2_transferred_amount , participant1_locked_amount , participant2_locked_amount ) = getSettleTransferAmounts ( participant1_state , participant1_transferred_amount , participant1_locked_amount , participant2_state , participant2_transferred_amount , participant2_locked_amount ) ; delete channel . participants [ participant1 ] ; delete channel . participants [ participant2 ] ; delete channels [ channel_identifier ] ; delete participants_hash_to_channel_identifier [ pair_hash ] ; storeUnlockData ( channel_identifier , participant1 , participant2 , participant1_locked_amount , participant1_locksroot ) ; storeUnlockData ( channel_identifier , participant2 , participant1 , participant2_locked_amount , participant2_locksroot ) ; emit ChannelSettled ( channel_identifier , participant1_transferred_amount , participant2_transferred_amount ) ; if ( participant1_transferred_amount > 0 ) { require ( token . transfer ( participant1 , participant1_transferred_amount ) ) ; } if ( participant2_transferred_amount > 0 ) { require ( token . transfer ( participant2 , participant2_transferred_amount ) ) ; } }
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; Approval ( msg . sender , spender , tokens ) ; return true ; }
function playerEndGameConflict ( uint32 _roundId , uint8 _gameType , uint16 _num , uint _value , int _balance , bytes32 _serverHash , bytes32 _playerHash , uint _gameId , address _contractAddress , bytes _serverSig , bytes32 _playerSeed ) public { verifySig ( _roundId , _gameType , _num , _value , _balance , _serverHash , _playerHash , _gameId , _contractAddress , _serverSig , serverAddress ) ; playerEndGameConflictImpl ( _roundId , _gameType , _num , _value , _balance , _playerHash , _playerSeed , _gameId , msg . sender ) ; }
function decimals ( ) public view returns ( uint8 _decimals ) ;
function orderContractorProposal ( uint _proposalID ) returns ( bool ) ;
function nettingContractsByAddress ( address node_address ) constant returns ( address [ ] ) { return data . nodeaddress_to_channeladdresses [ node_address ] ; }
function licenseExpirationTime ( uint256 _licenseId ) public view returns ( uint256 ) { return licenses [ _licenseId ] . expirationTime ; }
function getCertifiedDocCount ( address _student ) public view returns ( uint256 ) { return studentCertifications [ _student ] . indx ; }
function claimETH ( ) onlyAdmin ( 2 ) public { require ( creator . send ( address ( this ) . balance ) ) ; emit LogBeneficiaryPaid ( creator ) ; }
function getMeme ( uint256 _tokenId ) public view returns ( uint256 metadata , string text , uint256 sellingPrice , address owner ) { Meme storage meme = memes [ _tokenId ] ; metadata = meme . metadata ; text = meme . text ; sellingPrice = memeIndexToPrice [ _tokenId ] ; owner = memeIndexToOwner [ _tokenId ] ; }
function reclaimExpiredSwaps ( bytes32 msigId , bytes32 swapId ) public { require ( hashIdToMultisig [ msigId ] . owner == msg . sender || hashIdToMultisig [ msigId ] . authority == msg . sender ) ; require ( now >= hashIdToSwap [ swapId ] . expirationTime ) ; uint amount = hashIdToSwap [ swapId ] . amount ; assert ( hashIdToMultisig [ msigId ] . deposit + amount >= amount ) ; delete hashIdToSwap [ swapId ] ; hashIdToMultisig [ msigId ] . deposit += amount ; }
function addHolderAddress ( bytes32 _externalHolderId , address _newAddress ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; uint _newAddressId = holderIndex [ holderAddress2Id [ _newAddress ] ] ; require ( _newAddressId == 0 ) ; HoldersData storage _holderData = holders [ _holderIndex ] ; if ( _holderData . address2Index [ _newAddress ] == 0 ) { _holderData . holderAddressCount = _holderData . holderAddressCount . add ( 1 ) ; _holderData . address2Index [ _newAddress ] = _holderData . holderAddressCount ; _holderData . index2Address [ _holderData . holderAddressCount ] = _newAddress ; } holderAddress2Id [ _newAddress ] = _externalHolderId ; _emitHolderAddressAdded ( _externalHolderId , _newAddress , _holderIndex ) ; return OK ; }
function onTransfer ( address _from , address _to , uint256 _amount ) returns ( bool ) ;
function start ( ) onlyCrowdsaleMinter isNotStartedOnly { totalInCirculation = totalSupply ; isStarted = true ; }
function cancelCampaign ( bytes32 bidId ) public { address campaignOwner = getOwnerOfCampaign ( bidId ) ; require ( owner == msg . sender || campaignOwner == msg . sender ) ; uint budget = getBudgetOfCampaign ( bidId ) ; advertisementFinance . withdraw ( campaignOwner , budget ) ; advertisementStorage . setCampaignBudgetById ( bidId , 0 ) ; advertisementStorage . setCampaignValidById ( bidId , false ) ; }
function getBounty ( bytes32 question_id ) public view returns ( uint256 ) { return questions [ question_id ] . bounty ; }
function ( ) public payable { require ( contractPoweredUp ) ; require ( contractStarted ) ; require ( ! contractFinished ) ; require ( ! contractPaused ) ; require ( ! contractFailed ) ; require ( msg . value >= MINIMUM_PARTICIPATION_AMOUNT ) ; uint256 parsecValue = calculateReward ( msg . value ) ; uint256 maxAcceptableParsecs = PARSECS_TOTAL_AMOUNT . sub ( spentParsecs ) ; maxAcceptableParsecs = maxAcceptableParsecs . sub ( pendingParsecs ) ; require ( parsecValue <= maxAcceptableParsecs ) ; if ( kycStatus [ msg . sender ] == KycState . Undefined ) { kycStatus [ msg . sender ] = KycState . Pending ; } if ( kycStatus [ msg . sender ] == KycState . Pending ) { addPendingContribution ( msg . sender , msg . value , parsecValue ) ; } else if ( kycStatus [ msg . sender ] == KycState . Accepted ) { addAcceptedContribution ( msg . sender , msg . value , parsecValue ) ; } else { revert ( ) ; } }
function logRoyalty ( address _receiver , uint256 _amount ) onlyOwner public returns ( bool logged ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; if ( ! veztUserRegistered [ _receiver ] ) { veztUsers . push ( _receiver ) ; veztUserRegistered [ _receiver ] = true ; } require ( royaltyTracking [ _receiver ] . add ( _amount ) > 0 ) ; require ( royaltyTracking [ _receiver ] . add ( _amount ) > royaltyTracking [ _receiver ] ) ; royaltyTracking [ _receiver ] = royaltyTracking [ _receiver ] . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( owner , _receiver , _amount ) ; return true ; }
function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; PercentageTransferManager percentageTransferManager = new PercentageTransferManager ( msg . sender , address ( polyToken ) ) ; require ( Util . getSig ( _data ) == percentageTransferManager . getInitFunction ( ) , "Provided data is not valid" ) ; require ( address ( percentageTransferManager ) . call ( _data ) , "Unsuccessful call" ) ; emit GenerateModuleFromFactory ( address ( percentageTransferManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( percentageTransferManager ) ; }
function addAddressToAccount ( address _newAddress , address _sender ) external onlyAccountRegistryLogic nonZero ( _newAddress ) { require ( ! addressBelongsToAccount ( _newAddress ) ) ; accountByAddress [ _newAddress ] = accountIdForAddress ( _sender ) ; }
function generateTokens ( address _beneficiary , uint256 _tokens ) internal ;
function getProtocolVersion ( ) public view returns ( uint8 [ ] ) { return VersionUtils . unpack ( uint24 ( getUint ( Encoder . getKey ( "latestVersion" ) ) ) ) ; }
function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( ! frozenAccount [ msg . sender ] ) ; assert ( _spender != address ( 0 ) ) ; require ( _value >= 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; return true ; }
function ( ) public { revert ( ) ; }
function getTokenIndex ( uint256 _tokenId ) public view returns ( uint64 ) ;
function balanceOf ( address _owner ) external view returns ( uint256 ) { return _balanceOf ( _owner ) ; }
function approve ( address spender , uint256 amount ) public returns ( bool success ) ;
function tla ( ) public view returns ( string _tla ) { return lib . getTokenTLA ( address ( this ) ) ; }
function setMigrationAgent ( address _agent ) external onlyUnlocked ( ) { require ( migrationAgent == 0 ) ; require ( msg . sender == migrationMaster ) ; migrationAgent = _agent ; }
function getRate ( ) public view returns ( uint256 ) { if ( block . timestamp < phase2StartTime ) { return phase1Rate ; } uint offset = block . timestamp . sub ( phase2StartTime ) ; for ( uint256 i = 0 ; i < phase2RateOffsets . length ; i ++ ) { if ( offset < phase2RateOffsets [ i ] ) { return phase2Rates [ i ] ; } } return 0 ; }
function mint ( address _to , uint256 _amount ) public payloadSizeIs ( 32 * 2 ) validAddress ( _to ) requiresState ( State . MINTING2PUBLIC_SALES ) onlyBy ( m_sale ) { m_SMR . mint ( _to , _amount ) ; }
function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F3F ) , _newCFO , _nonce ) ) ; }
function buyOneRabbit ( uint _star ) external payable whenNotPaused returns ( bool ) { require ( isNotContract ( msg . sender ) ) ; uint tmpPrice = 0 ; if ( _star == 5 ) { tmpPrice = priceStar5Now ; require ( CREATED_STAR5 < LIMIT_STAR5 ) ; } else if ( _star == 4 ) { tmpPrice = priceStar4 ; require ( CREATED_STAR4 < LIMIT_STAR4 ) ; } else if ( _star == 3 ) { tmpPrice = priceStar3 ; } else { revert ( ) ; } require ( msg . value >= tmpPrice ) ; _createRabbitInGrade ( _star , msg . sender , 0 ) ; uint fundsExcess = msg . value - tmpPrice ; if ( fundsExcess > 1 finney ) { msg . sender . transfer ( fundsExcess ) ; } return true ; }
function getTokenTransferUuid ( address _address ) onlyAllowedAddresses public constant returns ( bytes16 ) { return tokenTransfers [ _address ] ; }
function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { if ( ! transfersEnabled ) throw ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) canTransfer ( _from ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; return super . transferFrom ( _from , _to , _value ) ; }
function convertFromUSD ( FundRaiseType _fundRaiseType , uint256 _amount ) public view returns ( uint256 ) { uint256 rate = getRate ( _fundRaiseType ) ; return DecimalMath . div ( _amount , rate ) ; }
function _setupChannel ( address beneficiary , uint amount , uint commission , uint expiresAt , bytes32 hashedSecret ) private returns ( bytes32 channelId ) { require ( IS_EXCHANGE_OPERATIONAL , "EXCHANGE_NOT_OPERATIONAL" ) ; require ( now <= expiresAt , "TIMELOCK_TOO_EARLY" ) ; require ( amount > 0 , "AMOUNT_IS_ZERO" ) ; require ( ! isAntecedentHashedSecret [ hashedSecret ] , "SECRET_CAN_BE_DISCOVERED" ) ; isAntecedentHashedSecret [ hashedSecret ] = true ; channelId = createChannelId ( msg . sender , beneficiary , amount , commission , now , expiresAt , hashedSecret ) ; Channel storage channel = channels [ channelId ] ; channel . initiator = msg . sender ; channel . beneficiary = beneficiary ; channel . amount = amount ; channel . commission = commission ; channel . createdAt = now ; channel . expiresAt = expiresAt ; channel . hashedSecret = hashedSecret ; channel . state = State . Created ; COMMISSION_RECIPIENT . transfer ( commission ) ; emit ChannelCreated ( channelId ) ; }
function ( ) payable { buy ( msg . sender ) ; }
function getTickerRegistrationFee ( ) public view returns ( uint256 ) { return getUint ( TICKERREGFEE ) ; }
function checkHashExists ( bytes32 _ipfsHash ) public view returns ( bool ) { return hashExists [ _ipfsHash ] ; }
function getContentHash ( bytes32 question_id ) public view returns ( bytes32 ) { return questions [ question_id ] . content_hash ; }
function startNewStakingInterval ( uint _start , uint _end ) external notZero ( _start ) notZero ( _end ) onlyOperator isDoneStaking { require ( totalLevs == 0 ) ; startBlock = _start ; endBlock = _end ; totalLevBlocks = 0 ; feeForTheStakingInterval = 0 ; feeCalculated = false ; StakingInterval ( _start , _end ) ; }
function _addToDebtRegister ( address account , uint amount ) internal { Synthetix synthetix = Synthetix ( associatedContract ) ; uint xdrValue = synthetix . effectiveValue ( "sUSD" , amount , "XDR" ) ; uint totalDebtIssued = synthetix . totalIssuedSynths ( "XDR" ) ; uint newTotalDebtIssued = xdrValue . add ( totalDebtIssued ) ; uint debtPercentage = xdrValue . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . sub ( debtPercentage ) ; uint existingDebt = synthetix . debtBalanceOf ( account , "XDR" ) ; if ( existingDebt > 0 ) { debtPercentage = xdrValue . add ( existingDebt ) . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; } if ( issuanceData [ account ] . initialDebtOwnership == 0 ) { totalIssuerCount = totalIssuerCount . add ( 1 ) ; } issuanceData [ account ] . initialDebtOwnership = debtPercentage ; issuanceData [ account ] . debtEntryIndex = debtLedger . length ; if ( debtLedger . length > 0 ) { debtLedger . push ( debtLedger [ debtLedger . length - 1 ] . multiplyDecimalRoundPrecise ( delta ) ) ; } else { debtLedger . push ( SafeDecimalMath . preciseUnit ( ) ) ; } }
function transfer ( address _to , uint256 _value ) public canTransfer releaseTokenValid ( msg . sender , now , _value ) returns ( bool ) { require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function lend ( uint index , bytes oracleData , Cosigner cosigner , bytes cosignerData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; require ( isApproved ( index ) ) ; require ( block . timestamp <= loan . expirationRequest ) ; loan . lender = msg . sender ; loan . dueTime = safeAdd ( block . timestamp , loan . duesIn ) ; loan . interestTimestamp = block . timestamp ; loan . status = Status . lent ; Transfer ( 0x0 , loan . lender , index ) ; activeLoans += 1 ; lendersBalance [ loan . lender ] += 1 ; if ( loan . cancelableAt > 0 ) internalAddInterest ( loan , safeAdd ( block . timestamp , loan . cancelableAt ) ) ; require ( rcn . transferFrom ( msg . sender , loan . borrower , safeMult ( loan . amount , getRate ( loan , oracleData ) ) ) ) ; if ( cosigner != address ( 0 ) ) { loan . cosigner = address ( uint256 ( cosigner ) + 2 ) ; require ( cosigner . requestCosign ( this , index , cosignerData , oracleData ) ) ; require ( loan . cosigner == address ( cosigner ) ) ; } Lent ( index , loan . lender , cosigner ) ; return true ; }
function remove ( MapStorage storage self , address _key ) public returns ( bool ) { require ( _key != address ( 0 ) ) ; if ( ! exist ( self , _key ) ) { return false ; } uint currentIndex = self . addressToIndex [ _key ] ; uint lastIndex = SafeMath . sub ( self . addresses . length , 1 ) ; address lastAddress = self . addresses [ lastIndex ] ; self . addressToIndex [ lastAddress ] = currentIndex ; self . addresses [ currentIndex ] = lastAddress ; delete self . addresses [ lastIndex ] ; delete self . addressToIndex [ _key ] ; self . addresses . length -- ; return true ; }
function slash ( bytes32 _guiltyOrderID ) external onlySlasher { require ( orderDetails [ _guiltyOrderID ] . settlementID == RENEX_ATOMIC_SETTLEMENT_ID , "slashing non-atomic trade" ) ; bytes32 innocentOrderID = orderbookContract . orderMatch ( _guiltyOrderID ) ; require ( orderStatus [ _guiltyOrderID ] == OrderStatus . Settled , "invalid order status" ) ; require ( orderStatus [ innocentOrderID ] == OrderStatus . Settled , "invalid order status" ) ; orderStatus [ _guiltyOrderID ] = OrderStatus . Slashed ; ( bytes32 buyID , bytes32 sellID ) = isBuyOrder ( _guiltyOrderID ) ? ( _guiltyOrderID , innocentOrderID ) : ( innocentOrderID , _guiltyOrderID ) ; TokenPair memory tokens = getTokenDetails ( orderDetails [ buyID ] . tokens ) ; SettlementDetails memory settlementDetails = calculateAtomicFees ( buyID , sellID , tokens ) ; renExBalancesContract . transferBalanceWithFee ( orderbookContract . orderTrader ( _guiltyOrderID ) , orderbookContract . orderTrader ( innocentOrderID ) , settlementDetails . leftTokenAddress , settlementDetails . leftTokenFee , 0 , 0x0 ) ; renExBalancesContract . transferBalanceWithFee ( orderbookContract . orderTrader ( _guiltyOrderID ) , slasherAddress , settlementDetails . leftTokenAddress , settlementDetails . leftTokenFee , 0 , 0x0 ) ; }
function getSecurityTokenData ( address _securityToken ) external view returns ( string , address , string , uint256 ) ;
function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return _operator == _tokenHolder || balancesDB . getOperator ( _operator , _tokenHolder ) ; }
function totalSupply ( ) public view returns ( uint ) { return properties . length ; }
function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { if ( orderPrice < sub ( referencePrice , wmul ( RISK_LEVEL , referencePrice ) ) ) { return false ; } return true ; }
function _address ( uint _holderId ) public view returns ( address ) { return holders [ _holderId ] . addr ; }
function totalSupply ( ) public view returns ( uint256 total ) { return countries . length ; }
function removePlayerFromBoard ( bytes32 boardHash , bytes32 playerName ) public returns ( bool ) { Board storage g = boards [ boardHash ] ; require ( g . boardOwner == msg . sender ) ; uint8 playerID = getPlayerId ( boardHash , playerName , 0 ) ; require ( playerID < 255 ) ; g . players [ playerID ] . isActive = 0 ; return true ; }
function assignTokens ( address _from , address _receiver , uint _tokenAmount ) private { token . transferFrom ( _from , _receiver , _tokenAmount ) ; }
function updateCounters ( uint256 _etherAmount ) internal { preSaleEtherPaid = preSaleEtherPaid . add ( _etherAmount ) ; totalContributions = totalContributions . add ( 1 ) ; CountersUpdated ( preSaleEtherPaid , _etherAmount ) ; }
function collectionCleared ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bool ) { require ( _collectionIndex < totalCollections ( ) , "Collection does not exist" ) ; return collectionTokens [ _collectionIndex ] . length == uint256 ( 0 ) ; }
function transfer ( address to , uint256 amount , bytes extraData ) external returns ( bool success ) { address _trg = libAddress ; assembly { let m := mload ( 0x20 ) calldatacopy ( m , 0 , calldatasize ) let success := delegatecall ( gas , _trg , m , calldatasize , m , 0x20 ) switch success case 0 { invalid } default { return ( m , 0x20 ) } } }
function missingFundsToEndAuction ( ) constant public returns ( uint ) { uint required_wei_at_price = num_tokens_auctioned * price ( ) / token_multiplier ; if ( required_wei_at_price <= received_wei ) { return 0 ; } return required_wei_at_price - received_wei ; }
function burn ( ) external isFinalized { uint256 _balance = balanceOf [ msg . sender ] ; assert ( _balance > 0 ) ; totalSupply = totalSupply . sub ( _balance ) ; balanceOf [ msg . sender ] = 0 ; Burn ( msg . sender , _balance ) ; }
function getPrices ( ) public constant returns ( uint256 , uint256 ) { return ( sellPrice , buyPrice ) ; }
function approve ( address _spender , uint _value ) public returns ( bool ) { if ( _spender != 0x0 ) { return _getAsset ( ) . __approve ( _spender , _value , msg . sender ) ; } }
function mAdavanceLogicState ( ETOState oldState ) internal constant returns ( ETOState ) ;
function ownerOf ( uint256 _identifier ) external view returns ( address _owner ) { _owner = gameStates [ gameIndex ] . identifierToOwner [ _identifier ] ; require ( _owner != address ( 0 ) ) ; }
function allowAsset ( address asset , string currency , uint feeBps , uint feeMin , uint feeMax , uint feeFlat ) public onlyOwner notDeprecated returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'allowed.stable.asset' , asset , currency ) ) ; require ( lib . Storage . setBool ( id , true ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; require ( setAssetCurrency ( asset , currency ) , 'Error: Unable to set Currency for asset' ) ; require ( setAssetFeeParams ( asset , feeBps , feeMin , feeMax , feeFlat ) , 'Error: Unable to set fee params for asset' ) ; emit AllowedERC20Asset ( asset , currency ) ; return true ; }
function createAsset ( uint _attributes , bytes32 _ipfsHash , uint _packId ) internal returns ( uint ) { uint id = numberOfAssets ; require ( isAttributesValid ( _attributes ) , "Attributes are not valid." ) ; assets . push ( Asset ( { id : id , packId : _packId , attributes : _attributes , ipfsHash : _ipfsHash } ) ) ; numberOfAssets ++ ; return id ; }
function assetPrices ( address asset ) public view returns ( uint ) ;
function produce ( uint256 amount ) isPeonyContract returns ( bool ) { require ( totalSupplyLimit == 0 || totalSupply . add ( amount ) <= totalSupplyLimit ) ; balances [ owner ] = balances [ owner ] . add ( amount ) ; totalSupply = totalSupply . add ( amount ) ; return true ; }
function setCloseTime ( uint256 _gameID , uint256 _closeTime ) external isActivated ( _gameID ) isOngoing ( _gameID ) isOwner ( ) { game_ [ _gameID ] . closeTime = _closeTime ; emit onChangeCloseTime ( _gameID , _closeTime , now ) ; }
function spiceUp ( string message ) external payable { require ( gameStarted || ! paused ) ; require ( msg . value > 0 ) ; prizePool = prizePool . add ( msg . value ) ; SpiceUpPrizePool ( msg . sender , msg . value , message , prizePool ) ; }
function description ( ) public view returns ( string ) ;
function getUpgradeState ( ) public view returns ( UpgradeState ) { if ( ! canUpgrade ( ) ) return UpgradeState . NotAllowed ; else if ( address ( upgradeAgent ) == address ( 0 ) ) return UpgradeState . WaitingForAgent ; else if ( totalUpgraded == 0 ) return UpgradeState . ReadyToUpgrade ; else return UpgradeState . Upgrading ; }
function changeFundOwnerWalletAddress ( address _fundOwnerWallet ) public validate_address ( _fundOwnerWallet ) onlyOwner { fundOwnerWallet = _fundOwnerWallet ; }
function getTotalBonusesAmountAvailable ( bytes32 _userKey ) public view returns ( uint _sum ) { uint _startDate = _getCalculationStartDate ( _userKey ) ; Treasury _treasury = Treasury ( treasury ) ; for ( uint _endDate = lastDepositDate ; _startDate <= _endDate && _startDate != 0 ; _startDate = distributionDeposits [ _startDate ] . nextDepositDate ) { Deposit storage _pendingDeposit = distributionDeposits [ _startDate ] ; Balance storage _userBalance = _pendingDeposit . leftToWithdraw [ _userKey ] ; if ( _userBalance . initialized ) { _sum = _sum . add ( _userBalance . left ) ; } else { uint _sharesPercent = _treasury . getSharesPercentForPeriod ( _userKey , _startDate ) ; _sum = _sum . add ( _pendingDeposit . balance . mul ( _sharesPercent ) . div ( PERCENT_PRECISION ) ) ; } } }
function ( ) public payable onlyWhiteList { uint256 tokensAmount = tokensAmountForPurchase ( ) ; uint256 available = availableTokens ( ) ; uint256 minimum = minimumTokensForPurchase ; require ( tokensAmount <= available ) ; require ( tokensAmount >= minimum ) ; wallet . transfer ( msg . value ) ; leftOnLastMint = available . sub ( tokensAmount ) ; lastMintTime = now ; require ( token . mint ( msg . sender , tokensAmount ) ) ; }
function unlockFirstPrivate ( ) public locked onlyOwner { require ( block . timestamp >= firstPrivateReleaseTime ) ; require ( firstPrivateLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= firstPrivateLockedAmount ) ; token . transfer ( privateLockAddress , firstPrivateLockedAmount ) ; firstPrivateLockedAmount = 0 ; }
function newManager ( address newManagerAddress ) public onlyManager { require ( newManagerAddress != 0 ) ; contractManager = newManagerAddress ; emit NewContractManager ( newManagerAddress ) ; }
function RoundIndex ( ) internal returns ( uint256 ) { uint256 index = 0 ; for ( uint256 r = 0 ; r < rounds . length ; r ++ ) { if ( ( rounds [ r ] . start < uint256 ( block . timestamp ) ) && ( uint256 ( block . timestamp ) < rounds [ r ] . end ) ) { index = r . add ( 1 ) ; } } return index ; }
function checkPreIcoStatus ( ) internal { if ( tokenBalanceOf [ this ] <= _totalSupply - preIcoLimit ) { preIcoIsRunning = false ; preIcoEnded ( preIcoLimit , "Token amount for preICO sold!" ) ; } }
function totalSupply ( ) external view returns ( uint256 ) { return cuties . length - 1 ; }
function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _data , bytes _operatorData ) internal { callSender ( _operator , _tokenHolder , 0x0 , _amount , _data , _operatorData ) ; requireMultiple ( _amount ) ; require ( balanceOf ( _tokenHolder ) >= _amount , "Not enough funds" ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; emit Burned ( _operator , _tokenHolder , _amount , _data , _operatorData ) ; }
function withdrawERC20 ( address _token ) external whenNotPaused onlyAdmin { IERC20 erc20 = IERC20 ( _token ) ; uint256 balance = erc20 . balanceOf ( this ) ; erc20 . safeTransfer ( msg . sender , balance ) ; }
function setTxStatus ( Data storage self , bytes32 txHash ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tx.status' , txHash ) ) ; require ( ! getTxStatus ( self , txHash ) , "Error: Transaction status must be false before setting the transaction status." ) ; require ( self . Storage . setBool ( id , true ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; return true ; }
function adminRescueFunds ( ) external onlyOwner whenPaused { address payee = owner ; uint256 payment = address ( this ) . balance ; payee . transfer ( payment ) ; }
function applySettings ( uint256 minDepositAmountEurUlps , uint256 minWithdrawAmountEurUlps , uint256 maxSimpleExchangeAllowanceEurUlps ) public only ( ROLE_EURT_LEGAL_MANAGER ) { applySettingsPrivate ( minDepositAmountEurUlps , minWithdrawAmountEurUlps , maxSimpleExchangeAllowanceEurUlps ) ; }
function isAllowedAddress ( address _address ) onlyAllowedAddresses public constant returns ( bool ) { return allowedAddresses [ _address ] ; }
function timeoutResolve ( bytes32 msigId , uint amount ) public { require ( hashIdToMultisig [ msigId ] . deposit >= amount ) ; require ( now >= hashIdToMultisig [ msigId ] . unlockTime ) ; spendFromMultisig ( msigId , amount , hashIdToMultisig [ msigId ] . owner ) ; }
function setTokenFeePercent ( uint256 percent ) public onlyOwner { require ( percent <= 100000000000000000000 , "Percent must be between 0 and 100." ) ; tokenFeePercent = percent ; }
function transferFrom ( address from , address to , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ from ] == 0 || value <= transferableHavvens ( from ) ) ; _transferFrom_byProxy ( sender , from , to , value ) ; return true ; }
function addDistributionSources ( address [ ] _whitelist ) external onlyContractOwner returns ( uint ) { for ( uint _idx = 0 ; _idx < _whitelist . length ; ++ _idx ) { distributionSourcesList [ _whitelist [ _idx ] ] = true ; } return OK ; }
function cancelPayment ( uint _idPayment ) onlyContractOwner { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( p . canceled ) throw ; if ( p . paid ) throw ; p . canceled = true ; PaymentCanceled ( _idPayment ) ; }
function setMarginSpend ( uint256 _marginSpend ) external onlyOwner returns ( bool ) { emit SetMarginSpend ( marginSpend , _marginSpend ) ; marginSpend = _marginSpend ; return true ; }
function decApprove ( address _from , address _spender , uint _value ) external onlyModule returns ( bool ) { allowed [ _from ] [ _spender ] = allowed [ _from ] [ _spender ] . sub ( _value ) ; return true ; }
function createDividendWithCheckpoint ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 _checkpointId ) payable public onlyOwner { require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( _checkpointId <= ISecurityToken ( securityToken ) . currentCheckpointId ( ) ) ; uint256 dividendIndex = dividends . length ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupplyAt ( _checkpointId ) ; require ( ERC20 ( _token ) . transferFrom ( msg . sender , address ( this ) , _amount ) , "Unable to transfer tokens for dividend" ) ; dividends . push ( Dividend ( _checkpointId , now , _maturity , _expiry , _token , _amount , 0 , currentSupply , false ) ) ; emit ERC20DividendDeposited ( msg . sender , _checkpointId , now , _maturity , _expiry , _token , _amount , currentSupply , dividendIndex ) ; }
function tryTransitionAccountingPeriod ( uint64 _maxTransitions ) public isInitialized returns ( bool success ) { return _tryTransitionAccountingPeriod ( _maxTransitions ) ; }
function redeemToken ( uint256 _tokens ) returns ( bool success ) { if ( this . balance < totalSupply ) { throw ; } if ( _tokens == 0 ) { throw ; } if ( balances [ msg . sender ] >= _tokens && totalSupply >= _tokens ) { balances [ msg . sender ] -= _tokens ; totalSupply -= _tokens ; if ( msg . sender . send ( _tokens ) ) { LogRedeemToken ( msg . sender , _tokens ) ; return true ; } else { throw ; } } else { throw ; } }
function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) , "0x address is invalid" ) ; IERC20 token = IERC20 ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( owner ( ) , balance ) , "token transfer failed" ) ; }
function getBlockOwner ( uint8 x , uint8 y ) external view returns ( address ) { return ownerOf ( blockID ( x , y ) ) ; }
function revokeVesting ( address _holder , uint256 _vestingId ) external authP ( REVOKE_VESTINGS_ROLE , arr ( _holder ) ) vestingExists ( _holder , _vestingId ) { TokenVesting storage v = vestings [ _holder ] [ _vestingId ] ; require ( v . revokable , ERROR_VESTING_NOT_REVOKABLE ) ; uint256 nonVested = _calculateNonVestedTokens ( v . amount , getTimestamp64 ( ) , v . start , v . cliff , v . vesting ) ; delete vestings [ _holder ] [ _vestingId ] ; require ( token . transferFrom ( _holder , address ( this ) , nonVested ) , ERROR_REVOKE_TRANSFER_FROM_REVERTED ) ; emit RevokeVesting ( _holder , _vestingId , nonVested ) ; }
function getTickersByOwner ( address _owner ) external view returns ( bytes32 [ ] ) ;
function getBoardByHash ( bytes32 boardHash ) constant public returns ( bytes32 , string , uint ) { return ( boards [ boardHash ] . boardName , boards [ boardHash ] . boardDescription , boards [ boardHash ] . numPlayers ) ; }
function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = false ; } else { mAuthorized [ _operator ] [ msg . sender ] = true ; } AuthorizedOperator ( _operator , msg . sender ) ; }
function lastRateUpdateTimeForCurrency ( bytes4 currencyKey ) public view returns ( uint ) { return lastRateUpdateTimes [ currencyKey ] ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function requestAudit ( address _auditor , bytes32 _codeHash , uint _auditTime ) public whenNotPaused payable { require ( _auditor != 0x0 ) ; require ( _auditTime >= MIN_AUDIT_TIME ) ; require ( _auditTime <= MAX_AUDIT_TIME ) ; require ( msg . value > 0 ) ; bytes32 hashAuditorCode = keccak256 ( _auditor , _codeHash ) ; uint8 outcome = auditOutcomes [ hashAuditorCode ] ; require ( outcome == NOT_AUDITED ) ; uint currentReward = rewards [ hashAuditorCode ] ; uint expireDate = now . add ( _auditTime ) ; rewards [ hashAuditorCode ] = currentReward . add ( msg . value ) ; totalRequestsAmount = totalRequestsAmount . add ( msg . value ) ; bytes32 hashAuditorRequestorCode = keccak256 ( _auditor , msg . sender , _codeHash ) ; AuditRequest storage request = auditRequests [ hashAuditorRequestorCode ] ; if ( request . amount == 0 ) { auditRequests [ hashAuditorRequestorCode ] = AuditRequest ( { amount : msg . value , expireDate : expireDate } ) ; emit AuditRequested ( _auditor , msg . sender , _codeHash , msg . value , expireDate ) ; } else { request . amount = request . amount . add ( msg . value ) ; if ( expireDate > request . expireDate ) request . expireDate = expireDate ; emit AuditRequested ( _auditor , msg . sender , _codeHash , request . amount , request . expireDate ) ; } }
function lock ( ) external onlyOwner vaultLoading { require ( tokensAllocated == tokensToBeAllocated , "Expected to allocate all tokens" ) ; require ( token . balanceOf ( address ( this ) ) == tokensAllocated , "Vault must own enough tokens to distribute" ) ; lockedAt = block . timestamp ; emit Locked ( ) ; }
function distributeICOTokens ( address _buyer , uint tokens ) external onlyCrowdsale whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( tokensDistributedCrowdsale < limitCrowdsale ) ; require ( tokensDistributedCrowdsale . add ( tokens ) <= limitCrowdsale ) ; tokensDistributedCrowdsale = tokensDistributedCrowdsale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
function finalize ( ) public initialized onlyOwner { require ( finalizedBlock == 0 ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; uint256 percentageToTeam = percent ( 18 ) ; uint256 percentageToReserve = percent ( 8 ) ; uint256 percentageToBounties = percent ( 13 ) ; uint256 percentageToAirdrop = percent ( 2 ) ; uint256 percentageToAdvisors = percent ( 7 ) ; uint256 percentageToEarlyInvestors = percent ( 2 ) ; assert ( token . generateTokens ( destTokensBounties , maxSupply . mul ( percentageToBounties ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensReserve , maxSupply . mul ( percentageToReserve ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensTeam , maxSupply . mul ( percentageToTeam ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensAirdrop , maxSupply . mul ( percentageToAirdrop ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensAdvisors , maxSupply . mul ( percentageToAdvisors ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensEarlyInvestors , maxSupply . mul ( percentageToEarlyInvestors ) . div ( percent ( 100 ) ) ) ) ; Finalized ( ) ; }
function removeExternalContributor ( address _contributor ) public onlyOwner { externalContributionAgents [ _contributor ] = false ; }
function findBestRate ( ERC20 src , ERC20 dest , uint srcAmount ) public view returns ( uint obsolete , uint rate ) { BestRateResult memory result = findBestRateTokenToToken ( src , dest , srcAmount ) ; return ( 0 , result . rate ) ; }
function freezeAccount ( address target , bool freeze ) onlyOwner { frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }
function approveFlower ( address _spender , uint256 _value ) public returns ( bool success ) ;
function contribute ( ) public notFinished payable { require ( whiteList [ msg . sender ] == true ) ; uint256 tokenBought = msg . value . mul ( rate ) ; require ( tokenBought >= 150000 * ( 10 ** 18 ) ) ; totalRaised = totalRaised . add ( msg . value ) ; totalDistributed = totalDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; emit LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; emit LogContributorsPayout ( msg . sender , tokenBought ) ; }
function getPolitician ( uint256 _tokenId ) public view returns ( string politicianName , uint256 sellingPrice , address owner ) { Politician storage politician = politicians [ _tokenId ] ; politicianName = politician . name ; sellingPrice = politicianIndexToPrice [ _tokenId ] ; owner = politicianIndexToOwner [ _tokenId ] ; }
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( withdrawalRequests [ _from ] . sinceBlock > 0 ) throw ; if ( withdrawalRequests [ _to ] . sinceBlock > 0 ) throw ; if ( balanceOf [ _from ] < _value ) throw ; if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
function finalizeSingleInvestor ( address investorAddr ) public onlyOwner mustBeAtStage ( Stage . Finished ) { require ( investorAddr != address ( 0 ) && investorAddr != address ( this ) ) ; require ( balancesToken [ investorAddr ] > 0 ) ; require ( isWhitelisted [ investorAddr ] == true ) ; uint256 balanceToTransfer = balancesToken [ investorAddr ] ; balancesToken [ investorAddr ] = 0 ; isWhitelisted [ investorAddr ] = false ; require ( token . transfer ( investorAddr , balanceToTransfer ) ) ; tokensFinalized = tokensFinalized . add ( balanceToTransfer ) ; assert ( tokensFinalized <= MAX_TOKENS ) ; }
function multiTransfer ( address [ ] _to , uint256 [ ] _value ) returns ( bool success ) { }
function balanceOf ( address _owner ) public view returns ( uint ) { return chronoBankPlatform . balanceOf ( _owner , smbl ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external isValidToken ( _tokenId ) onlyOwnerOf ( _tokenId ) payable { address owner = IndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) && owner == _from ) ; require ( _to != address ( 0 ) ) ; _transfer ( _from , _to , _tokenId ) ; }
function earlyResolve ( bytes32 msigId , uint amount , bytes sig ) public { require ( multisigs [ msigId ] . owner == msg . sender || multisigs [ msigId ] . authority == msg . sender ) ; address otherAuthority = multisigs [ msigId ] . owner == msg . sender ? multisigs [ msigId ] . authority : multisigs [ msigId ] . owner ; require ( otherAuthority == msigId . recover ( sig ) ) ; spendFromMultisig ( msigId , amount , multisigs [ msigId ] . owner ) ; }
function collect ( ) public { uint256 finalizedBlock = statusContribution . finalizedBlock ( ) ; require ( finalizedBlock != 0 ) ; require ( getBlockNumber ( ) > finalizedBlock ) ; uint256 total = totalCollected . add ( snt . balanceOf ( address ( this ) ) ) ; uint256 balance = sgt . balanceOfAt ( msg . sender , finalizedBlock ) ; uint256 amount = total . mul ( balance ) . div ( sgt . totalSupplyAt ( finalizedBlock ) ) ; amount = amount . sub ( collected [ msg . sender ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( snt . transfer ( msg . sender , amount ) ) ; TokensCollected ( msg . sender , amount ) ; }
function sell ( uint256 amount ) public { require ( address ( this ) . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
function changeWhitelister ( address _newWhitelister ) public onlyWhitelister addressNotZero ( _newWhitelister ) { emit WhitelisterChanged ( whitelister , _newWhitelister ) ; whitelister = _newWhitelister ; }
function ( ) payable { require ( isContract ( controller ) ) ; assert ( Controller ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; }
function setWhitelist ( address [ ] _add , address [ ] _remove , uint256 [ ] _whitelistLimits ) public onlyOwner beforeSale { uint256 i = 0 ; uint8 j = 0 ; if ( _whitelistLimits . length > 0 ) { whitelistDayCount = uint8 ( _whitelistLimits . length ) ; for ( i = 0 ; i < _whitelistLimits . length ; i ++ ) { j = uint8 ( i . add ( 1 ) ) ; if ( whitelistDayMaxStake [ j ] != _whitelistLimits [ i ] ) { whitelistDayMaxStake [ j ] = _whitelistLimits [ i ] ; WhitelistSetDay ( msg . sender , j , _whitelistLimits [ i ] ) ; } } } for ( i = 0 ; i < _add . length ; i ++ ) { require ( _add [ i ] != address ( 0 ) ) ; if ( ! whitelist [ _add [ i ] ] ) { whitelist [ _add [ i ] ] = true ; WhitelistAddressAdded ( msg . sender , _add [ i ] ) ; } } for ( i = 0 ; i < _remove . length ; i ++ ) { require ( _remove [ i ] != address ( 0 ) ) ; if ( whitelist [ _remove [ i ] ] ) { whitelist [ _remove [ i ] ] = false ; WhitelistAddressRemoved ( msg . sender , _remove [ i ] ) ; } } }
function approve ( address _spender , uint _value ) external returns ( bool success ) ;
function toggleMinting ( ) onlyOwner public { if ( pauseMinting ) { pauseMinting = false ; emit UnPauseMinting ( ) ; } else { pauseMinting = true ; emit PauseMinting ( ) ; } }
function singlePayout ( address _user , uint256 _amount ) public onlyAdmin returns ( bool paid ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( transferCheck ( owner , _user , _amount ) ) ; if ( ! userRegistered [ _user ] ) { registerUser ( _user ) ; } balances [ _user ] = balances [ _user ] . add ( _amount ) ; balances [ owner ] = balances [ owner ] . add ( _amount ) ; Transfer ( owner , _user , _amount ) ; return true ; }
function setReachCapped ( ) public onlyOwnerOrCoOwner { isCapped = true ; }
function calculateToFund ( address _beneficiary , uint256 _weiAmount ) internal view returns ( uint256 ) { uint256 toFund ; uint256 postWeiRaised = weiRaised . add ( _weiAmount ) ; if ( postWeiRaised > cap ) { toFund = cap . sub ( weiRaised ) ; } else { toFund = _weiAmount ; } return toFund ; }
function transferFrom ( address from , address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; uint fees = calculateFees ( amount ) ; require ( lib . forceTransfer ( currency , from , to , amount , "0x0" ) , "Error: Unable to transfer funds. Please check your parameters and ensure the spender has the approved amount of funds to transfer." ) ; require ( lib . forceTransfer ( currency , from , feeContract , fees , lib . getFeeMsg ( feeContract ) ) , "Error: Unable to transfer funds. Please check your parameters and ensure the spender has the approved amount of funds to transfer." ) ; require ( lib . updateAllowance ( lib . getTokenSymbol ( address ( this ) ) , from , amount . add ( fees ) ) , "Error: Unable to update allowance for spender." ) ; emit Transfer ( from , to , amount ) ; return true ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 cutieId ) { uint40 count = 0 ; for ( uint40 i = 1 ; i <= _totalSupply ( ) ; ++ i ) { if ( cutieIndexToOwner [ i ] == _owner ) { if ( count == _index ) { return i ; } else { count ++ ; } } } revert ( ) ; }
function changeOwner ( address _newOwner ) public validate_address ( _newOwner ) onlyOwner { require ( _newOwner != owner ) ; owner = _newOwner ; }
function escapeHatch ( ) onlyEscapeHatchCallerOrOwner { uint total = this . balance ; if ( ! escapeHatchDestination . send ( total ) ) { throw ; } EscapeHatchCalled ( total ) ; }
function setCampaignStartDateById ( bytes32 bidId , uint newStartDate ) public onlyIfCampaignExists ( "setCampaignStartDateById" , bidId ) onlyIfWhitelisted ( "setCampaignStartDateById" , msg . sender ) { campaigns [ bidId ] . setStartDate ( newStartDate ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
function hasHardCap ( ) constant internal returns ( bool ) { return getMaximumFunds ( ) != 0 ; }
function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , getBlockNumber ( ) ) ; if ( curTotalSupply + _amount < curTotalSupply ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; var previousBalanceTo = balanceOf ( _owner ) ; if ( previousBalanceTo + _amount < previousBalanceTo ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
function createCampaign ( string packageName , uint [ 3 ] countries , uint [ ] vercodes , uint price , uint budget , uint startDate , uint endDate , string endPoint ) external { CampaignLibrary . Campaign memory newCampaign = _generateCampaign ( packageName , countries , vercodes , price , budget , startDate , endDate ) ; if ( newCampaign . owner == 0x0 ) { return ; } _getBidIdList ( ) . push ( newCampaign . bidId ) ; ExtendedAdvertisementStorage ( address ( _getStorage ( ) ) ) . setCampaign ( newCampaign . bidId , newCampaign . price , newCampaign . budget , newCampaign . startDate , newCampaign . endDate , newCampaign . valid , newCampaign . owner , endPoint ) ; emit CampaignInformation ( newCampaign . bidId , newCampaign . owner , "" , packageName , countries , vercodes , endPoint ) ; }
function getLockedUserDeposits ( bytes32 _userKey ) public view returns ( uint [ ] _lockupDates , uint [ ] _deposits ) { LockedDeposits storage _lockedDeposits = user2lockedDeposits [ _userKey ] ; uint _lockedDepositsCounter = _lockedDeposits . counter ; _lockupDates = new uint [ ] ( _lockedDepositsCounter ) ; _deposits = new uint [ ] ( _lockedDepositsCounter ) ; uint _pointer = 0 ; for ( uint _idx = 1 ; _idx < _lockedDepositsCounter ; ++ _idx ) { uint _lockDate = _lockedDeposits . index2Date [ _idx ] ; if ( _lockDate > now ) { _lockupDates [ _pointer ] = _lockDate ; _deposits [ _pointer ] = _lockedDeposits . date2deposit [ _lockDate ] ; ++ _pointer ; } } }
function ( ) public payable { require ( msg . sender == address ( weth ) || msg . sender == totlePrimary ) ; }
function commit ( uint256 _value ) public returns ( uint256 commitmentValue ) { require ( 0 < _value ) ; require ( _value <= balances [ msg . sender ] ) ; commitmentValue = _value ; uint256 prevCommit = miners [ msg . sender ] . value ; if ( 0 < prevCommit ) { uint256 prevReward ; ( prevReward , prevCommit ) = withdraw ( ) ; commitmentValue = prevReward . add ( prevCommit ) . add ( _value ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( commitmentValue ) ; emit Transfer ( msg . sender , address ( 0 ) , commitmentValue ) ; totalStake_ = totalStake_ . add ( commitmentValue ) ; miners [ msg . sender ] = Commitment ( commitmentValue , block . number , totalStake_ , blockReward_ ) ; emit Commit ( msg . sender , commitmentValue , totalStake_ , blockReward_ ) ; return commitmentValue ; }
function paymentRegularTokens ( uint256 _regularTokenAmount , uint256 _rewardPercentageIndex ) public validAmount ( _regularTokenAmount ) isValidRewardIndex ( _rewardPercentageIndex ) senderHasEnoughTokens ( _regularTokenAmount , 0 ) isWhitelisted ( msg . sender ) whenNotPaused { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _regularTokenAmount ) ; uint256 rewardAmount = getRewardToken ( _regularTokenAmount , _rewardPercentageIndex ) ; rewardBalances [ msg . sender ] = rewardBalances [ msg . sender ] . add ( rewardAmount ) ; emit TransferReward ( owner , msg . sender , rewardAmount ) ; balances [ owner ] = balances [ owner ] . add ( _regularTokenAmount . sub ( rewardAmount ) ) ; emit Transfer ( msg . sender , owner , _regularTokenAmount . sub ( rewardAmount ) ) ; }
function changeModuleBudget ( address _module , uint256 _budget ) external ;
function createTemplate ( string content ) stateAny ( ) public returns ( uint256 ) { uint256 id = nextTemplateID ; templates [ id ] = block . number ; template_hashes [ id ] = keccak256 ( abi . encodePacked ( content ) ) ; emit LogNewTemplate ( id , msg . sender , content ) ; nextTemplateID = id . add ( 1 ) ; return id ; }
function updateRate ( uint256 _rate ) external isNotFinalized onlyOwner { rate = _rate ; UpdateRate ( rate ) ; }
function getCar ( uint256 _tokenId ) public view returns ( string carName , uint256 sellingPrice , address owner ) { Car storage car = cars [ _tokenId ] ; carName = car . name ; sellingPrice = carIndexToPrice [ _tokenId ] ; owner = carIndexToOwner [ _tokenId ] ; }
function setLiqPrice ( uint wad ) public auth { liquidationPriceWad = wad ; }
function calculateTokens ( uint256 _amountOfWei ) public view returns ( uint256 ) { require ( _amountOfWei >= 1 szabo ) ; uint256 tokenBought ; uint256 tokenPrice = price . USD ( 0 ) ; tokenPrice = tokenPrice . mul ( 36 ) ; tokenPrice = tokenPrice . div ( 10 ** 8 ) ; tokenBought = _amountOfWei . div ( tokenPrice ) ; tokenBought = tokenBought . mul ( 10 ** 10 ) ; if ( _amountOfWei >= 10 ether ) { tokenBought = tokenBought . mul ( 123 ) ; tokenBought = tokenBought . div ( 100 ) ; } else if ( _amountOfWei >= 1 ether ) { tokenBought = tokenBought . mul ( 11 ) ; tokenBought = tokenBought . div ( 10 ) ; } return tokenBought ; }
function setIssuanceRatio ( uint _issuanceRatio ) external optionalProxy_onlyOwner { require ( _issuanceRatio <= MAX_ISSUANCE_RATIO , "New issuance ratio must be less than or equal to MAX_ISSUANCE_RATIO" ) ; issuanceRatio = _issuanceRatio ; emitIssuanceRatioUpdated ( _issuanceRatio ) ; }
function thaw ( ) external onlySale { frozen = false ; }
function contributorCount ( ) public view returns ( uint ) { return contributors . length ; }
function claimJob ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender != job . manager ) ; require ( msg . sender != job . evaluator ) ; require ( job . status == JobStatus . Open ) ; job . worker = msg . sender ; job . status = JobStatus . inProgress ; JobsByWorker [ msg . sender ] . push ( _JobID ) ; emit JobClaimed ( msg . sender , _JobID ) ; }
function receiveDeposit ( ) payable ;
function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { _transferFrom ( _from , _to , _value ) ; return true ; }
function settle ( bytes32 channelId ) public { require ( canSettle ( channelId ) ) ; PaymentChannel storage channel = channels [ channelId ] ; channel . sender . transfer ( channel . value ) ; delete channels [ channelId ] ; DidSettle ( channelId ) ; }
function setFee ( uint256 _fee ) external onlyOwner { require ( 0 <= _fee && _fee <= 100000 ) ; fee = _fee ; }
function revokeAsset ( bytes32 _symbol , uint _value ) public returns ( uint _resultCode ) { TransactionContext memory txContext ; txContext . from = msg . sender ; txContext . fromHolderId = getHolderId ( txContext . from ) ; _resultCode = _revokeAsset ( _symbol , _value , txContext ) ; if ( _resultCode != OK ) { return _emitErrorCode ( _resultCode ) ; } _emitter ( ) . emitRevoke ( _symbol , _value , txContext . from ) ; _proxyTransferEvent ( _value , _symbol , txContext ) ; return OK ; }
function updateETHPriceInCents ( ) public payable { if ( ! updateRequestExpired ( ) ) { NewOraclizeQuery ( "Oraclize request fail. Previous one still pending" ) ; } else if ( oraclize_getPrice ( "URL" ) > this . balance ) { NewOraclizeQuery ( "Oraclize request fail. Not enough ether" ) ; } else { oraclize_query ( m_ETHPriceUpdateInterval , "URL" , "json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd" , m_callbackGas ) ; m_ETHPriceLastUpdateRequest = getTime ( ) ; NewOraclizeQuery ( "Oraclize query was sent" ) ; } }
function withdrawEther ( uint256 amount ) onlyOwner public { msg . sender . transfer ( amount ) ; }
function attachAsset ( uint256 _tokenId ) public canTransfer ( _tokenId ) { uint256 isAttached = checkIsAttached ( _tokenId ) ; require ( isAttached == 0 ) ; isAttached = 1 ; updateIsAttached ( _tokenId , isAttached ) ; emit AssetUpdated ( _tokenId ) ; }
function setRdFee ( uint _feeValue , uint _feeDecimals ) onlyContractOwner external returns ( uint ) { require ( _validFee ( _feeValue , _feeDecimals ) ) ; rdFee = FeeData ( _feeValue , _feeDecimals ) ; return OK ; }
function getInterfaceImplementer ( address addr , bytes32 iHash ) public constant returns ( address ) { return interfaces [ addr ] [ iHash ] ; }
function beforeTransfer ( uint64 pledgeManager , uint64 pledgeFrom , uint64 pledgeTo , uint64 context , uint amount ) returns ( uint maxAllowed ) ;
function requestMortgage ( Engine engine , bytes32 loanIdentifier , uint256 deposit , uint256 landId , TokenConverter tokenConverter ) external returns ( uint256 id ) { return requestMortgageId ( engine , engine . identifierToIndex ( loanIdentifier ) , deposit , landId , tokenConverter ) ; }
function cancelPoll ( uint _idPoll ) public { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll storage p = _polls [ _idPoll ] ; require ( ! p . canceled , "Poll has been canceled already" ) ; require ( p . endBlock > block . number , "Only active polls can be canceled" ) ; if ( p . startBlock < block . number ) { require ( msg . sender == controller , "Only the controller can cancel the poll" ) ; } else { require ( p . author == msg . sender , "Only the owner can cancel the poll" ) ; } p . canceled = true ; emit PollCanceled ( _idPoll ) ; }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( _to != address ( 0 ) ) ; transferFrom ( _from , _to , _tokenId ) ; if ( _isContract ( _to ) ) { ERC721TokenReceiver receiver = ERC721TokenReceiver ( _to ) ; bytes4 response = receiver . onERC721Received . gas ( 50000 ) ( msg . sender , _from , _tokenId , "" ) ; require ( response == TOKEN_RECEIVED_SIG ) ; } }
function migrate ( uint256 _value ) external { require ( migrationAgent != 0 ) ; require ( _value != 0 ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }
function totalSupply ( ) public view returns ( uint ) { return ponies . length - 1 ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
function setFeeAuthority ( address _feeAuthority ) public optionalProxy_onlyOwner { feeAuthority = _feeAuthority ; emitFeeAuthorityUpdated ( _feeAuthority ) ; }
function withdrawERC20Token ( address tokenAddress , uint256 tokenAmount ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokenAmount ) ; }
function unpause ( uint256 _newEndDate ) public onlyOwner { require ( _newEndDate >= endTime ) ; super . _unpause ( ) ; endTime = _newEndDate ; }
function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return erc20Impl . allowance ( _owner , _spender ) ; }
function start ( ) public onlyOwner { require ( token != address ( 0 ) ) ; require ( startTime == 0 ) ; startTime = now ; cliff = startTime . add ( CLIFF_DURATION ) ; }
function getKydy ( uint256 _id ) external view returns ( bool isCreating , bool isReady , uint256 rechargeIndex , uint256 nextActionAt , uint256 synthesizingWithId , uint256 createdTime , uint256 yinId , uint256 yangId , uint256 generation , uint256 genes ) { Kydy storage kyd = kydys [ _id ] ; isCreating = ( kyd . synthesizingWithId != 0 ) ; isReady = ( kyd . rechargeEndBlock <= block . number ) ; rechargeIndex = uint256 ( kyd . rechargeIndex ) ; nextActionAt = uint256 ( kyd . rechargeEndBlock ) ; synthesizingWithId = uint256 ( kyd . synthesizingWithId ) ; createdTime = uint256 ( kyd . createdTime ) ; yinId = uint256 ( kyd . yinId ) ; yangId = uint256 ( kyd . yangId ) ; generation = uint256 ( kyd . generation ) ; genes = kyd . genes ; }
function mint ( address _address , uint _value ) { require ( multiSigAddress == msg . sender ) ; balances [ _address ] = balances [ _address ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; if ( totalSupply > cap ) { revert ( ) ; } LogMint ( _address , _value ) ; Transfer ( address ( 0x0 ) , _address , _value ) ; }
function revealMulti ( uint256 [ ] _limits , uint256 [ ] _slopeFactors , uint256 [ ] _collectMinimums , bool [ ] _lasts , bytes32 [ ] _salts ) public { require ( _limits . length != 0 && _limits . length == _slopeFactors . length && _limits . length == _collectMinimums . length && _limits . length == _lasts . length && _limits . length == _salts . length ) ; for ( uint256 i = 0 ; i < _limits . length ; i = i . add ( 1 ) ) { revealCurve ( _limits [ i ] , _slopeFactors [ i ] , _collectMinimums [ i ] , _lasts [ i ] , _salts [ i ] ) ; } }
function removeSpender ( address _spender ) external onlyOwner { _validateAddress ( _spender ) ; delete whitelistedSpenders [ _spender ] ; }
function getOrder ( address who ) public view returns ( uint256 quantity , uint256 price , uint256 expiry ) { TradeOrder memory order = orderBook [ who ] ; return ( order . quantity , order . price , order . expiry ) ; }
function getTotalCommission ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _lastIndex = _history . commissionCumulative . length - 1 ; if ( _lastIndex < 0 ) { return 0 ; } return _history . commissionCumulative [ _lastIndex ] ; }
function claimTokensByAdmin ( address _user ) onlyAdmin ( 1 ) public { require ( state == State . Successful ) ; uint256 temp = pending [ _user ] ; pending [ _user ] = 0 ; require ( tokenReward . transfer ( _user , temp ) ) ; emit LogContributorsPayout ( _user , temp ) ; }
function calcGav ( ) returns ( uint gav ) { address [ ] memory tempOwnedAssets ; tempOwnedAssets = ownedAssets ; delete ownedAssets ; for ( uint i = 0 ; i < tempOwnedAssets . length ; ++ i ) { address ofAsset = tempOwnedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; var ( isRecent , assetPrice , assetDecimals ) = module . pricefeed . getPrice ( ofAsset ) ; if ( ! isRecent ) { revert ( ) ; } gav = add ( gav , mul ( assetHoldings , assetPrice ) / ( 10 ** uint256 ( assetDecimals ) ) ) ; if ( assetHoldings != 0 || ofAsset == address ( QUOTE_ASSET ) || ofAsset == address ( NATIVE_ASSET ) || isInOpenMakeOrder [ ofAsset ] ) { ownedAssets . push ( ofAsset ) ; } else { isInAssetList [ ofAsset ] = false ; } PortfolioContent ( assetHoldings , assetPrice , assetDecimals ) ; } }
function adjustCheckpoints ( Checkpoint [ ] storage _checkpoints , uint256 _newValue ) internal { if ( currentCheckpointId == 0 ) { return ; } if ( _checkpoints . length == 0 ) { _checkpoints . push ( Checkpoint ( { checkpointId : currentCheckpointId , value : _newValue } ) ) ; return ; } if ( _checkpoints [ _checkpoints . length - 1 ] . checkpointId == currentCheckpointId ) { return ; } _checkpoints . push ( Checkpoint ( { checkpointId : currentCheckpointId , value : _newValue } ) ) ; }
function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) ) ; ERC20Basic token = ERC20Basic ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( msg . sender , balance ) ) ; }
function decreaseApproval ( address spender , uint tokenAmount ) public returns ( bool ) { uint oldValue = allowed [ msg . sender ] [ spender ] ; if ( tokenAmount > oldValue ) { allowed [ msg . sender ] [ spender ] = 0 ; } else { allowed [ msg . sender ] [ spender ] = oldValue . sub ( tokenAmount ) ; } emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function setHavven ( Havven _havven ) external onlyOwner { havven = _havven ; emit HavvenUpdated ( _havven ) ; }
function arbitrateApproveMilestone ( uint _idMilestone ) onlyArbitrator campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) && ( milestone . status != MilestoneStatus . Completed ) ) throw ; authorizePayment ( _idMilestone ) ; }
function getBtcRequestHash ( bytes requestData , bytes payeesPaymentAddress , uint256 expirationDate ) private view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( this , requestData , payeesPaymentAddress , expirationDate ) ) ; }
function destroy ( ) onlyContractOwner { suicide ( msg . sender ) ; }
function approve ( address spender , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }
function disableWithdrawal ( ) public onlyOwner whenWithdrawalEnabled { withdrawalEnabled = false ; emit WithdrawalDisabled ( owner ) ; }
function buy ( uint256 identifier ) external payable whenNotPaused { require ( identifierToOwner [ identifier ] != 0x0 ) ; address oldOwner = identifierToOwner [ identifier ] ; uint256 price = identifierToPrice [ identifier ] ; require ( oldOwner != msg . sender ) ; require ( msg . value >= price ) ; uint256 newPrice = nextPrice ( price ) ; identifierToPrice [ identifier ] = newPrice ; _transfer ( oldOwner , msg . sender , identifier ) ; Price ( identifier , newPrice , nextPrice ( newPrice ) ) ; uint256 dividend = price . mul ( dividendPercentage ) . div ( 100000 ) ; uint256 dividendsPaid = _payDividends ( identifier , identifier , dividend , 0 ) ; uint256 fee = calculateFee ( price , dividendsPaid ) ; uint256 oldOwnerWinnings = price . sub ( dividendsPaid ) . sub ( fee ) ; Buy ( oldOwner , msg . sender , identifier , price , oldOwnerWinnings ) ; if ( oldOwner != address ( this ) ) { _sendFunds ( oldOwner , oldOwnerWinnings ) ; } uint256 excess = price - msg . value ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) public returns ( address ) { address newSecurityTokenAddress = new SecurityToken ( _name , _symbol , _decimals , _divisible ? 1 : uint256 ( 10 ) ** _decimals , _tokenDetails , _polymathRegistry ) ; if ( addTransferManager ) { SecurityToken ( newSecurityTokenAddress ) . addModule ( transferManagerFactory , "" , 0 , 0 ) ; } SecurityToken ( newSecurityTokenAddress ) . transferOwnership ( _issuer ) ; return newSecurityTokenAddress ; }
function getFee ( address stablecoin ) public view returns ( uint256 ) { return tokenStorage_CD . fees ( stablecoin ) ; }
function doReserveTrade ( ERC20 src , uint amount , ERC20 dest , address destAddress , uint expectedDestAmount , KyberReserveInterface reserve , uint conversionRate , bool validate ) internal returns ( bool ) { uint callValue = 0 ; if ( src == dest ) { if ( destAddress != ( address ( this ) ) ) destAddress . transfer ( amount ) ; return true ; } if ( src == ETH_TOKEN_ADDRESS ) { callValue = amount ; } require ( reserve . trade . value ( callValue ) ( src , amount , dest , this , conversionRate , validate ) ) ; if ( destAddress != address ( this ) ) { if ( dest == ETH_TOKEN_ADDRESS ) { destAddress . transfer ( expectedDestAmount ) ; } else { require ( dest . transfer ( destAddress , expectedDestAmount ) ) ; } } return true ; }
function transfer ( address _to , uint256 _amount ) public whenNotPaused erc20 returns ( bool success ) { doSend ( msg . sender , _to , _amount , "" , msg . sender , "" , false ) ; return true ; }
function removeContract ( string _contractName ) external ;
function isThirdPartyOwner ( address _address ) public view returns ( bool ) { return ownerRoles . hasEqual ( _address , ROLE_THIRDPARTY_OWNER ) ; }
function changeController ( address _newController ) public onlyOwner { att . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
function removeUserContract ( address _contract ) external returns ( uint ) { return this . removeUserContractFrom ( _contract , msg . sender ) ; }
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = getBlockNumber ( ) ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
function changeSettings ( uint _price_start , uint _price_constant , uint32 _price_exponent ) internal { require ( stage == Stages . AuctionDeployed || stage == Stages . AuctionSetUp ) ; require ( _price_start > 0 ) ; require ( _price_constant > 0 ) ; price_start = _price_start ; price_constant = _price_constant ; price_exponent = _price_exponent ; }
function symbol ( ) external pure returns ( string _symbol ) ;
function notifyOfArbitrationRequest ( bytes32 question_id , address requester ) onlyArbitrator ( question_id ) stateOpen ( question_id ) external { questions [ question_id ] . is_pending_arbitration = true ; LogNotifyOfArbitrationRequest ( question_id , requester ) ; }
function getExchangeRates ( address [ ] numeratorTokens , address [ ] denominatorTokens ) public constant returns ( uint256 [ ] rateFractions , uint256 [ ] timestamps ) ;
function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , "ERC777TokensRecipient" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( ! _to . isContract ( ) ) ; } }
function revoke ( bytes32 _operation ) external multiOwnedOperationIsActive ( _operation ) onlyowner { uint ownerIndexBit = makeOwnerBitmapBit ( msg . sender ) ; var pending = m_multiOwnedPending [ _operation ] ; require ( pending . ownersDone & ownerIndexBit > 0 ) ; assertOperationIsConsistent ( _operation ) ; pending . yetNeeded ++ ; pending . ownersDone -= ownerIndexBit ; assertOperationIsConsistent ( _operation ) ; Revoke ( msg . sender , _operation ) ; }
function setBlacklistSpender ( address _who ) public onlyValidator { require ( isPermission ( APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) , "Blacklist spending not supported by token" ) ; setUserPermission ( _who , APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) ; emit LogSetBlacklistSpender ( _who ) ; }
function withdraw ( uint32 _open_block_number , uint192 _balance , bytes _balance_msg_sig ) external { require ( _balance > 0 ) ; address sender_address = extractBalanceProofSignature ( msg . sender , _open_block_number , _balance , _balance_msg_sig ) ; bytes32 key = getKey ( sender_address , msg . sender , _open_block_number ) ; require ( channels [ key ] . open_block_number > 0 ) ; require ( closing_requests [ key ] . settle_block_number == 0 ) ; require ( _balance <= channels [ key ] . deposit ) ; require ( withdrawn_balances [ key ] < _balance ) ; uint192 remaining_balance = _balance - withdrawn_balances [ key ] ; withdrawn_balances [ key ] = _balance ; require ( token . transfer ( msg . sender , remaining_balance ) ) ; ChannelWithdraw ( sender_address , msg . sender , _open_block_number , remaining_balance ) ; }
function getPriceAndTime ( ) view public returns ( uint256 , uint256 ) { return ( POLYUSD , latestUpdate ) ; }
function increaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F42 ) , _token , _spender , _addedValue , _fee , _nonce ) ) ; }
function issueForEuro ( uint256 euroUlps ) public only ( ROLE_NEUMARK_ISSUER ) acceptAgreement ( msg . sender ) returns ( uint256 ) { require ( _totalEurUlps + euroUlps >= _totalEurUlps ) ; uint256 neumarkUlps = incremental ( _totalEurUlps , euroUlps ) ; _totalEurUlps += euroUlps ; mGenerateTokens ( msg . sender , neumarkUlps ) ; emit LogNeumarksIssued ( msg . sender , euroUlps , neumarkUlps ) ; return neumarkUlps ; }
function calcUnclaimedFees ( uint gav ) view returns ( uint managementFee , uint performanceFee , uint unclaimedFees ) { uint timePassed = sub ( now , atLastUnclaimedFeeAllocation . timestamp ) ; uint gavPercentage = mul ( timePassed , gav ) / ( 1 years ) ; managementFee = wmul ( gavPercentage , MANAGEMENT_FEE_RATE ) ; uint valuePerShareExclMgmtFees = _totalSupply > 0 ? calcValuePerShare ( sub ( gav , managementFee ) , _totalSupply ) : toSmallestShareUnit ( 1 ) ; if ( valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation . highWaterMark ) { uint gainInSharePrice = sub ( valuePerShareExclMgmtFees , atLastUnclaimedFeeAllocation . highWaterMark ) ; uint investmentProfits = wmul ( gainInSharePrice , _totalSupply ) ; performanceFee = wmul ( investmentProfits , PERFORMANCE_FEE_RATE ) ; } unclaimedFees = add ( managementFee , performanceFee ) ; }
function setMaxCollectable ( uint256 _newMaxFees ) external onlyOwner { maxFees = _newMaxFees ; emit UpdateMaxFees ( maxFees ) ; }
function tokenURI ( uint _tokenId ) external view returns ( string ) { require ( exists ( _tokenId ) ) ; return core . getTokenURIs ( _tokenId , tokenIsChamp ) ; }
function transferToAddress ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }
function getToken ( uint256 _tokenId ) public view returns ( string tokenName , uint256 sellingPrice , address owner ) { Token storage token = tokens [ _tokenId ] ; tokenName = token . name ; sellingPrice = tokenIndexToPrice [ _tokenId ] ; owner = tokenIndexToOwner [ _tokenId ] ; }
function approve ( address _spender , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
function submitAnswerCommitment ( bytes32 question_id , bytes32 answer_hash , uint256 max_previous , address _answerer ) stateOpen ( question_id ) bondMustDouble ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external payable { bytes32 commitment_id = keccak256 ( abi . encodePacked ( question_id , answer_hash , msg . value ) ) ; address answerer = ( _answerer == NULL_ADDRESS ) ? msg . sender : _answerer ; require ( commitments [ commitment_id ] . reveal_ts == COMMITMENT_NON_EXISTENT , "commitment must not already exist" ) ; uint32 commitment_timeout = questions [ question_id ] . timeout / COMMITMENT_TIMEOUT_RATIO ; commitments [ commitment_id ] . reveal_ts = uint32 ( now ) . add ( commitment_timeout ) ; _addAnswerToHistory ( question_id , commitment_id , answerer , msg . value , true ) ; }
function transferAnyERC20Token ( address _tokenAddress , uint256 _tokens , address _beneficiary ) public onlyOwner returns ( bool success ) { return ERC20Basic ( _tokenAddress ) . transfer ( _beneficiary , _tokens ) ; }
function awardMILsTo ( address _to , uint256 _MILs ) public onlyOwner awardsAllowed { award [ _to ] = award [ _to ] . add ( _MILs ) ; totalAwards = totalAwards . add ( _MILs ) ; currentAwards = currentAwards . add ( _MILs ) ; }
function countOfDeeds ( ) public view returns ( uint256 ) { return plots . length ; }
function revokeGrant ( address _holder ) external onlyOwner { Grant memory grant = grants [ _holder ] ; require ( grant . value != 0 ) ; delete grants [ _holder ] ; totalVesting = totalVesting . sub ( grant . value ) ; erc20 . transfer ( owner , grant . value ) ; emit RevokeGrant ( _holder , grant . value ) ; }
function _burnForDeposit ( address owner , uint amount ) public onlyTrusted returns ( bool success ) { if ( balances [ owner ] >= amount ) { balances [ owner ] -= amount ; totalOnDeposit += amount ; totalInCirculation -= amount ; return true ; } else { return false ; } }
function convertRate ( Oracle oracle , bytes32 currency , bytes data , uint256 amount ) public returns ( uint256 ) { if ( oracle == address ( 0 ) ) { return amount ; } else { uint256 rate ; uint256 decimals ; ( rate , decimals ) = oracle . getRate ( currency , data ) ; require ( decimals <= MAX_DECIMALS ) ; return ( safeMult ( safeMult ( amount , rate ) , ( 10 ** decimals ) ) ) / PRECISION ; } }
function transfer ( address to , uint value ) returns ( bool success ) { require ( balances [ msg . sender ] >= value && value > 0 && ( ! frozenAccount [ msg . sender ] ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; Transfer ( msg . sender , to , value ) ; return true ; }
function transferTokenOwnership ( address _newOwner ) external onlyOwner { require ( _newOwner != address ( 0 ) ) ; LittlePhilCoin ( token ) . transferOwnership ( _newOwner ) ; }
function _registerTrade ( uint32 _canvasId , uint _amount ) internal stateOwned ( _canvasId ) forceOwned ( _canvasId ) returns ( uint commission , uint paintersRewards , uint sellerProfit ) { uint _commission ; uint _rewards ; uint _sellerProfit ; ( _commission , _rewards , _sellerProfit ) = splitTrade ( _amount ) ; FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; _pushCumulative ( _history . commissionCumulative , _commission ) ; _pushCumulative ( _history . rewardsCumulative , _rewards ) ; return ( _commission , _rewards , _sellerProfit ) ; }
function changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) external ;
function getPrice ( ) external view returns ( uint256 ) ;
function transferFrom ( address _from , address _to , uint256 _amount ) public erc20 returns ( bool success ) { uint256 allowance = balancesDB . getAllowance ( _from , msg . sender ) ; require ( _amount <= allowance ) ; require ( balancesDB . decApprove ( _from , msg . sender , _amount ) ) ; doSend ( _from , _to , _amount , "" , msg . sender , "" , false ) ; return true ; }
function getPixelAuthor ( uint32 _canvasId , uint32 _pixelIndex ) public view validPixelIndex ( _pixelIndex ) returns ( address ) { return _getCanvas ( _canvasId ) . pixels [ _pixelIndex ] . painter ; }
function addAssetToOwnedAssets ( address ofAsset ) public pre_cond ( isOwner ( ) || msg . sender == address ( this ) ) { isInOpenMakeOrder [ ofAsset ] = true ; if ( ! isInAssetList [ ofAsset ] ) { ownedAssets . push ( ofAsset ) ; isInAssetList [ ofAsset ] = true ; } }
function incrementTotalIssuerCount ( ) external onlyAssociatedContract { totalIssuerCount = totalIssuerCount . add ( 1 ) ; }
function getBlockNumber ( ) internal view returns ( uint256 ) { return block . number ; }
function setAmounts ( uint256 mtdAmountInWei , uint256 ethAmountInWei ) isOwner { require ( mtdAmountInWei > 0 ) ; require ( ethAmountInWei > 0 ) ; mtdAmount = mtdAmountInWei ; ethAmount = ethAmountInWei ; updatePrices ( ) ; }
function setBudget ( Campaign storage _campaign , uint _budget ) internal { _campaign . budget = _budget ; }
function whitelistAddresses ( address [ ] _addresses , bool _status ) public onlyWhitelister { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { address _investorAddress = _addresses [ i ] ; if ( whitelist [ _investorAddress ] != _status ) { whitelist [ _investorAddress ] = _status ; } } }
function setTierRates ( uint256 tier1 , uint256 tier2 , uint256 tier3 , uint256 tier4 ) external onlyOwner whenNotPaused beforeStarting { require ( tier1 > 0 && tier2 > 0 && tier3 > 0 && tier4 > 0 ) ; require ( tier1 > tier2 && tier2 > tier3 && tier3 > tier4 ) ; rate = tier1 ; rateTier2 = tier2 ; rateTier3 = tier3 ; rateTier4 = tier4 ; }
function newAppInstance ( bytes32 _appId , address _appBase , bytes _initializePayload , bool _setDefault ) public auth ( APP_MANAGER_ROLE , arr ( KERNEL_APP_BASES_NAMESPACE , _appId ) ) returns ( ERCProxy appProxy ) { _setAppIfNew ( KERNEL_APP_BASES_NAMESPACE , _appId , _appBase ) ; appProxy = newAppProxy ( this , _appId , _initializePayload ) ; if ( _setDefault ) { setApp ( KERNEL_APP_ADDR_NAMESPACE , _appId , appProxy ) ; } }
function exchangePreDGZTokens ( ) stopInEmergency onlyAfterStart public { uint tokenAmount = tokenRewardPreDGZ . allowance ( msg . sender , this ) ; require ( tokenAmount > 0 ) ; require ( tokenRewardPreDGZ . transferFrom ( msg . sender , address ( 0 ) , tokenAmount ) ) ; uint amountSendTokens = tokenAmount * preDGZtoDGZExchangeRate / 100000000 ; preBalanceOf [ msg . sender ] += tokenAmount ; tokenReward . transfer ( msg . sender , amountSendTokens ) ; }
function burn ( uint256 _value ) public { require ( owner == msg . sender ) ; require ( balanceOf [ msg . sender ] >= _value ) ; require ( _value > 0 ) ; balanceOf [ msg . sender ] = SafeMath . sub ( balanceOf [ msg . sender ] , _value ) ; totalSupply = SafeMath . sub ( totalSupply , _value ) ; emit Burn ( msg . sender , _value ) ; }
function userUnlockToken ( uint256 amount ) public returns ( bool res ) { require ( lockedAmount [ msg . sender ] >= amount ) ; require ( now >= lockedTime [ msg . sender ] ) ; lockedAmount [ msg . sender ] -= amount ; balanceOf [ msg . sender ] += amount ; UserUnlock ( amount ) ; return true ; }
function getDelegateIdx ( Pledge p , uint64 idDelegate ) internal returns ( uint64 ) { for ( uint i = 0 ; i < p . delegationChain . length ; i ++ ) { if ( p . delegationChain [ i ] == idDelegate ) return uint64 ( i ) ; } return NOTFOUND ; }
function buyBox1 ( ) external payable whenNotPaused returns ( bool ) { require ( isNotContract ( msg . sender ) ) ; require ( box1OnSale ) ; require ( msg . value >= priceBox1 ) ; uint tempVal = uint ( keccak256 ( uint ( msg . sender ) + secretKey + rabbits . length ) ) ; tempVal = tempVal % 10000 ; uint _star = 3 ; if ( tempVal <= box1Star5 ) { _star = 5 ; require ( CREATED_STAR5 < LIMIT_STAR5 ) ; } else if ( tempVal <= box1Star5 + box1Star4 ) { _star = 4 ; require ( CREATED_STAR4 < LIMIT_STAR4 ) ; } _createRabbitInGrade ( _star , msg . sender , 2 ) ; uint fundsExcess = msg . value - priceBox1 ; if ( fundsExcess > 1 finney ) { msg . sender . transfer ( fundsExcess ) ; } return true ; }
function getCampaignValidById ( bytes32 bidId ) public view returns ( bool valid ) { return campaigns [ bidId ] . getValidity ( ) ; }
function batchApprove ( uint256 [ ] _tokenIds , address _spender ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _spender != address ( 0 ) ) ; uint256 _id ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 ) ; _id = _tokenIds [ i ] ; approve ( _spender , _id ) ; } }
function swapProxyTokens ( ) public { ERC20Token oldToken = ERC20Token ( 0x81BE91c7E74Ad0957B4156F782263e7B0B88cF7b ) ; uint256 oldTokenBalance = oldToken . balanceOf ( msg . sender ) ; require ( oldTokenBalance > 0 ) ; if ( oldToken . transferFrom ( msg . sender , issuingTokenOwner , oldTokenBalance ) ) { require ( oldToken . balanceOf ( msg . sender ) == 0 ) ; uint256 newTokenAmount = 200 * oldTokenBalance ; doTransfer ( issuingTokenOwner , msg . sender , newTokenAmount ) ; SwappedTokens ( msg . sender , oldTokenBalance , newTokenAmount ) ; } }
function getLowerSTVersionBounds ( ) external view returns ( uint8 [ ] ) { return VersionUtils . unpack ( compatibleSTVersionRange [ "lowerBound" ] ) ; }
function buyPackWithKitty ( uint256 _kittyId ) external { require ( totalKittiesBurned < KITTY_BURN_LIMIT , "Stop! Think of the cats!" ) ; require ( ! hasBurnedKitty [ msg . sender ] , "You've already burned a kitty." ) ; totalKittiesBurned ++ ; hasBurnedKitty [ msg . sender ] = true ; kittiesContract . transferFrom ( msg . sender , this , _kittyId ) ; _buyPack ( standardSale ) ; emit KittyBurned ( msg . sender , _kittyId ) ; }
function withdrawVotingRights ( uint _numTokens ) external { uint availableTokens = voteTokenBalance [ msg . sender ] . sub ( getLockedTokens ( msg . sender ) ) ; require ( availableTokens >= _numTokens ) ; voteTokenBalance [ msg . sender ] -= _numTokens ; require ( token . transfer ( msg . sender , _numTokens ) ) ; emit _VotingRightsWithdrawn ( _numTokens , msg . sender ) ; }
function changeTickerRegistrationFee ( uint256 _tickerRegFee ) external onlyOwner { uint256 fee = getUint ( TICKERREGFEE ) ; require ( fee != _tickerRegFee , "Fee not changed" ) ; emit ChangeTickerRegistrationFee ( fee , _tickerRegFee ) ; set ( TICKERREGFEE , _tickerRegFee ) ; }
function withdrawWinner ( ) external { require ( currentStage == StageName . voteFinished , "Withdraw disable yet/allready!" ) ; require ( msg . sender == projects [ keccak256 ( bytes ( currentWinner ) ) ] . prjAddress , "Only winner can Withdraw reward" ) ; currentStage = StageName . rewardWithdrawn ; msg . sender . transfer ( address ( this ) . balance ) ; }
function transfer ( address _to , uint256 _value ) public transfersAllowed returns ( bool success ) { return false ; }
function purchaseTokens ( ) payable returns ( uint ) { if ( ( now < startTime ) || ( now > closeTime ) || ( msg . value == 0 ) ) throw ; uint currentPrice ; if ( now < ( startTime + 1 days ) ) { currentPrice = priceDayOne ; } else if ( now < ( startTime + 2 days ) ) { currentPrice = priceDayTwo ; } else if ( now < ( startTime + 12 days ) ) { currentPrice = price - ( ( startTime + 12 days - now ) * price / 100 days ) ; } else { currentPrice = price ; } uint tokens = safeMul ( msg . value , 1 ether ) / currentPrice ; if ( ! token . transferFrom ( owner , msg . sender , tokens ) ) throw ; return tokens ; }
function reimbursement ( ) public { claimReimbursement ( msg . sender ) ; }
function releaseTokensFromEscrow ( uint256 _amount ) external { releaseTokensFromEscrowForUser ( msg . sender , _amount ) ; }
function createSaleAuction ( uint256 _deedId , uint256 _startPrice , uint256 _endPrice , uint256 _duration ) external whenNotPaused { require ( _owns ( msg . sender , _deedId ) ) ; require ( address ( saleAuctionContract ) != address ( 0 ) ) ; _approve ( msg . sender , address ( saleAuctionContract ) , _deedId ) ; saleAuctionContract . createAuction ( _deedId , _startPrice , _endPrice , _duration ) ; }
function setRate ( uint256 _rate ) public onlyOwner returns ( bool ) { rate = _rate ; return true ; }
function checkDelegate ( address _potentialDelegate ) external view returns ( bool ) { require ( _potentialDelegate != address ( 0 ) , "Invalid address" ) ; if ( delegateDetails [ _potentialDelegate ] != bytes32 ( 0 ) ) { return true ; } else return false ; }
function appendDecryptedBids ( uint [ ] _nonce , uint [ ] _index , uint [ ] _bid_id , address [ ] _investor_address , uint [ ] _share_price , uint [ ] _shares_count , uint [ ] _transfered_token ) public onlyOwner { require ( _nonce . length == _index . length ) ; require ( _index . length == _bid_id . length ) ; require ( _bid_id . length == _investor_address . length ) ; require ( _investor_address . length == _share_price . length ) ; require ( _share_price . length == _shares_count . length ) ; require ( _shares_count . length == _transfered_token . length ) ; require ( bids_count . sub ( bids_decrypted_count ) > 0 ) ; for ( uint i = 0 ; i < _index . length ; i ++ ) { appendDecryptedBid ( _nonce [ i ] , _index [ i ] , _bid_id [ i ] , _investor_address [ i ] , _share_price [ i ] , _shares_count [ i ] , _transfered_token [ i ] ) ; } }
function addRewardPercentage ( uint256 _percentage ) public onlyAdmin isValidRewardPercentage ( _percentage ) returns ( uint256 _index ) { _index = rewardPercentage . length ; rewardPercentage . push ( _percentage ) ; emit RewardPercentage ( _index , _percentage ) ; }
function transfer ( address _to , uint256 _tokenId ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function handleAbovePlannedWhitelistedContribution ( uint256 allowedContribution , uint256 plannedContribution , uint256 refundAmount ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( plannedContribution ) ; AllowedContributionCheck ( allowedContribution , AllowedContributionState . AboveWhitelisted ) ; return ( allowedContribution , refundAmount ) ; }
function unlockInvestor ( address investor ) private { Account memory accountInMem = _accounts [ investor ] ; if ( accountInMem . balance == 0 ) { return ; } removeInvestor ( investor , accountInMem . balance ) ; if ( _lockState == LockState . AcceptingUnlocks ) { require ( NEUMARK . transferFrom ( investor , address ( this ) , accountInMem . neumarksDue ) ) ; NEUMARK . burn ( accountInMem . neumarksDue ) ; if ( currentTime ( ) < accountInMem . unlockDate ) { require ( _penaltyDisbursalAddress != address ( 0 ) ) ; uint256 penalty = decimalFraction ( accountInMem . balance , PENALTY_FRACTION ) ; if ( isContract ( _penaltyDisbursalAddress ) ) { require ( ASSET_TOKEN . approveAndCall ( _penaltyDisbursalAddress , penalty , "" ) ) ; } else { assert ( ASSET_TOKEN . transfer ( _penaltyDisbursalAddress , penalty ) ) ; } emit LogPenaltyDisbursed ( _penaltyDisbursalAddress , penalty , ASSET_TOKEN , investor ) ; accountInMem . balance -= penalty ; } } if ( _lockState == LockState . ReleaseAll ) { accountInMem . neumarksDue = 0 ; } assert ( ASSET_TOKEN . transfer ( investor , accountInMem . balance ) ) ; emit LogFundsUnlocked ( investor , accountInMem . balance , accountInMem . neumarksDue ) ; }
function buy ( ) public payable { proxyPayment ( msg . sender ) ; }
function canVote ( uint _idPoll ) public view returns ( bool ) { if ( _idPoll >= _polls . length ) return false ; Poll storage p = _polls [ _idPoll ] ; uint balance = token . balanceOfAt ( msg . sender , p . startBlock ) ; return block . number >= p . startBlock && block . timestamp < p . endTime && ! p . canceled && balance != 0 ; }
function submitProposal ( address _sender , uint _proposalID , uint _amount ) onlyClient { if ( _sender != recipient && _sender != creator ) throw ; proposals [ _proposalID ] . submittedAmount += _amount ; ProposalSubmitted ( msg . sender , _amount ) ; }
function renounceOwnership ( ) public contract_onlyOwner { emit OwnershipRenounced ( _owner ) ; _owner = address ( 0 ) ; }
function realitioAnswerFromAugurMarket ( IMarket market ) onlyInitialized public view returns ( bytes32 ) { bytes32 answer ; if ( market . isInvalid ( ) ) { answer = REALITIO_INVALID ; } else { uint256 no_val = market . getWinningPayoutNumerator ( AUGUR_NO_INDEX ) ; uint256 yes_val = market . getWinningPayoutNumerator ( AUGUR_YES_INDEX ) ; if ( yes_val == no_val ) { answer = REALITIO_INVALID ; } else { if ( yes_val > no_val ) { answer = REALITIO_YES ; } else { answer = REALITIO_NO ; } } } return answer ; }
function topUpDelegate ( address _sender_address , address _receiver_address , uint32 _open_block_number , uint192 _added_deposit ) isTrustedContract external { updateInternalBalanceStructs ( _sender_address , _receiver_address , _open_block_number , _added_deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _added_deposit ) ) ; }
function doCancelPayment ( uint _idPayment ) internal { require ( _idPayment < payments . length ) ; Payment storage p = payments [ _idPayment ] ; require ( p . state == PaymentStatus . Pending ) ; p . state = PaymentStatus . Canceled ; liquidPledging . cancelPayment ( uint64 ( p . ref ) , p . amount ) ; CancelPayment ( _idPayment , p . ref ) ; }
function setResolver ( address _resolver ) onlyOwner public { resolver = _resolver ; }
function disableMinting ( ) public onlyMinter { mintingDisabled = true ; emit DisableMinting ( ) ; }
function getBool ( bytes32 _key ) internal view returns ( bool ) { return boolStorage [ _key ] ; }
function adminSetDetails ( uint32 _devFee , uint32 _priceUpdateInterval , uint32 _startDateRoundValue , uint32 _durationRoundValue , uint64 _maxDuration , uint64 _minDuration , uint256 _maxPrice , uint256 _minPrice ) public onlyAdmin { devFee = _devFee ; priceUpdateInterval = _priceUpdateInterval ; startDateRoundValue = _startDateRoundValue ; durationRoundValue = _durationRoundValue ; maxDuration = _maxDuration ; minDuration = _minDuration ; maxPrice = _maxPrice ; minPrice = _minPrice ; }
function safeTransferFromWithFees ( address token , address from , address to , uint256 amount ) internal returns ( uint256 ) { uint256 balancesBefore = CompatibleERC20 ( token ) . balanceOf ( to ) ; CompatibleERC20 ( token ) . transferFrom ( from , to , amount ) ; require ( previousReturnValue ( ) , "transferFrom failed" ) ; uint256 balancesAfter = CompatibleERC20 ( token ) . balanceOf ( to ) ; return Math . min256 ( amount , balancesAfter . sub ( balancesBefore ) ) ; }
function migrate ( ) public ;
function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
function updatePlotPrice ( uint256 plotIndex , uint256 newPriceInWeiPerPixel ) external { require ( plotIndex >= 0 ) ; require ( plotIndex < ownership . length ) ; require ( msg . sender == ownership [ plotIndex ] . owner ) ; plotIdToPrice [ plotIndex ] = newPriceInWeiPerPixel ; emit PlotPriceUpdated ( plotIndex , newPriceInWeiPerPixel , msg . sender ) ; }
function decimals ( ) external erc20 view returns ( uint8 ) { return uint8 ( 18 ) ; }
function setFundingRules ( address _mainPartner , bool _publicCreation , uint _initialPriceMultiplier , uint _maxAmountToFund , uint _minutesFundingPeriod , uint _inflationRate , uint _proposalID ) external ;
function setBuyRate ( uint256 buyRateInWei ) isOwner { require ( buyRateInWei > 0 ) ; require ( buyRate != buyRateInWei ) ; buyRate = buyRateInWei ; updatePrices ( ) ; }
function updateTreasury ( address _treasury ) external onlyContractOwner returns ( uint ) { require ( _treasury != 0x0 ) ; treasury = _treasury ; return OK ; }
function approve ( address _approved , uint256 _tokenId ) external ;
function distribute ( uint256 rounds ) external { for ( uint256 i = 0 ; i < rounds ; i ++ ) { if ( address ( this ) . balance < 0.001 ether ) { break ; } fairContract . buy . value ( address ( this ) . balance ) ( 0x0 ) ; fairContract . exit ( ) ; } }
function getAttributeValue ( address account , uint256 attributeTypeID ) external view returns ( uint256 ) ;
function getSTFactoryAddress ( ) external view returns ( address ) ;
function adminChange ( address _newAdmin ) public onlyAdmin validAddress ( _newAdmin ) { admin = _newAdmin ; }
function addToWhitelist ( address _address ) public onlyWhitelister addressNotZero ( _address ) { emit WhitelistAdd ( whitelister , _address ) ; whitelist [ _address ] = true ; }
function createLiability ( bytes _demand , bytes _offer ) external returns ( bool ) ;
function getDog ( uint256 _id ) external view returns ( uint256 cooldownIndex , uint256 nextActionAt , uint256 siringWithId , uint256 birthTime , uint256 matronId , uint256 sireId , uint256 generation , uint256 genes , uint8 variation , uint256 gen0 ) { Dog storage dog = dogs [ _id ] ; cooldownIndex = uint256 ( dog . cooldownIndex ) ; nextActionAt = uint256 ( dog . cooldownEndBlock ) ; siringWithId = uint256 ( dog . siringWithId ) ; birthTime = uint256 ( dog . birthTime ) ; matronId = uint256 ( dog . matronId ) ; sireId = uint256 ( dog . sireId ) ; generation = uint256 ( dog . generation ) ; genes = uint256 ( dog . genes ) ; variation = uint8 ( dog . variation ) ; gen0 = uint256 ( dog . gen0 ) ; }
function allocate ( ) private { allocations [ 0xab1cb1740344A9280dC502F3B8545248Dc3045eA ] = 4000000 * 1 ether ; allocations [ 0x330709A59Ab2D1E1105683F92c1EE8143955a357 ] = 4000000 * 1 ether ; allocations [ 0xAa0887fc6e8896C4A80Ca3368CFd56D203dB39db ] = 3000000 * 1 ether ; allocations [ 0x1fbA1d22435DD3E7Fa5ba4b449CC550a933E72b3 ] = 200000 * 1 ether ; allocations [ 0xC9d5E2c7e40373ae576a38cD7e62E223C95aBFD4 ] = 200000 * 1 ether ; allocations [ 0xabc0B64a38DE4b767313268F0db54F4cf8816D9C ] = 220000 * 1 ether ; allocations [ 0x5d85bCDe5060C5Bd00DBeDF5E07F43CE3Ccade6f ] = 50000 * 1 ether ; allocations [ 0xecb1b0231CBC0B04015F9e5132C62465C128B578 ] = 500000 * 1 ether ; allocations [ 0xFF22FA2B3e5E21817b02a45Ba693B7aC01485a9C ] = 2955000 * 1 ether ; }
function name ( ) public view returns ( string ) { return "PixelCons" ; }
function grantPermissionP ( address _entity , address _app , bytes32 _role , uint256 [ ] _params ) onlyPermissionManager ( _app , _role ) public { require ( ! hasPermission ( _entity , _app , _role ) ) ; bytes32 paramsHash = _params . length > 0 ? _saveParams ( _params ) : EMPTY_PARAM_HASH ; _setPermission ( _entity , _app , _role , paramsHash ) ; }
function getAmountOfUnlockedTokens ( address _tokenOwner ) public returns ( uint ) { uint balanceAvailable = mBalances [ _tokenOwner ] ; if ( mLockedBalances [ _tokenOwner ] . amount != 0 && mLockedBalances [ _tokenOwner ] . timeLockedUntil > block . timestamp ) { balanceAvailable = balanceAvailable . sub ( mLockedBalances [ _tokenOwner ] . amount ) ; } else if ( mLockedBalances [ _tokenOwner ] . amount != 0 && mLockedBalances [ _tokenOwner ] . timeLockedUntil < block . timestamp ) { mLockedBalances [ _tokenOwner ] = lockedTokens ( { amount : 0 , timeLockedUntil : 0 } ) ; } return balanceAvailable ; }
function addAdmin ( address _newAdmin ) external { require ( msg . sender == owner ) ; adminPermission [ _newAdmin ] = true ; }
function __callback ( bytes32 myid , string result ) public closeOrDuringCrowdsale { if ( msg . sender != oraclize_cbAddress ( ) ) revert ( ) ; uint256 usdRate = parseInt ( result , 18 ) ; require ( usdRate > 0 ) ; ethUsd = usdRate ; LogRateUpdate ( ethUsd , now ) ; if ( hasEnded ( ) == true ) { currentStage = Stage . Finished ; } else { updateEthRate ( ) ; lastOracleUpdate = now ; } }
function getTuber ( uint256 _tokenId ) public view returns ( string tuberName , uint256 sellingPrice , address owner ) { Tuber storage tuber = tubers [ _tokenId ] ; tuberName = tuber . name ; sellingPrice = tuberIndexToPrice [ _tokenId ] ; owner = tuberIndexToOwner [ _tokenId ] ; }
function extractBytes32 ( bytes data , uint offset ) internal pure returns ( bytes32 bs ) { require ( offset >= 0 && offset + 32 <= data . length , "offset value should be in the correct range" ) ; assembly { bs := mload ( add ( data , add ( 32 , offset ) ) ) } }
function distributePresaleTokens ( address _buyer , uint tokens ) external onlyOwner whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( tokensDistributedPresale < 10000000 ) ; tokensDistributedPresale = tokensDistributedPresale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _tokenId ) { require ( _owner != address ( 0 ) ) ; require ( _index < _tokensOfOwnerWithSubstitutions [ _owner ] . length ) ; _tokenId = _tokensOfOwnerWithSubstitutions [ _owner ] [ _index ] ; if ( _owner == address ( this ) ) { if ( _tokenId == 0 ) { _tokenId = _index + 1 ; } } }
function feePool ( ) external view returns ( uint ) { return tokenState . balanceOf ( FEE_ADDRESS ) ; }
function proxyPayment ( address _owner ) public payable notPaused returns ( bool success ) { return doPayment ( _owner ) ; }
function finalizeCampaign ( ) public onlyController { require ( ( campaignState == 1 ) || ( ( campaignState != 0 ) && ( now > tCampaignEnd + ( 2880 minutes ) ) ) ) ; campaignState = 0 ; uint256 drewardTokens = ( tokensGenerated . mul ( PRCT100_D_TEAM ) ) . div ( 10000 ) ; uint256 rrewardTokens = ( tokensGenerated . mul ( PRCT100_R_TEAM ) ) . div ( 10000 ) ; uint256 r2rewardTokens = ( tokensGenerated . mul ( PRCT100_R2 ) ) . div ( 10000 ) ; uint256 mmrewardTokens = FIXEDREWARD_MM ; do_grant_tokens ( dteamVaultAddr1 , drewardTokens ) ; do_grant_tokens ( dteamVaultAddr2 , drewardTokens ) ; do_grant_tokens ( dteamVaultAddr3 , drewardTokens ) ; do_grant_tokens ( dteamVaultAddr4 , drewardTokens ) ; do_grant_tokens ( rteamVaultAddr , rrewardTokens ) ; do_grant_tokens ( r2VaultAddr , r2rewardTokens ) ; do_grant_tokens ( mmVaultAddr , mmrewardTokens ) ; uint256 reserveTokens = hardcap . sub ( tokensGenerated ) ; do_grant_tokens ( reserveVaultAddr , reserveTokens ) ; token . finalize ( ) ; tFinalized = now ; Finalized ( tFinalized ) ; }
function transfer ( address _to , uint _value ) public { _transfer ( msg . sender , _to , _value ) ; }
function pullDividendPayment ( uint256 _dividendIndex ) public validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; require ( ! dividend . claimed [ msg . sender ] , "Dividend already claimed" ) ; require ( ! dividend . dividendExcluded [ msg . sender ] , "msg.sender excluded from Dividend" ) ; _payDividend ( msg . sender , dividend , _dividendIndex ) ; }
function retrieveAll ( ) onlyOwner public { require ( this . balance > 0 ) ; owner . transfer ( this . balance ) ; }
function setSuccess ( ) external onlyAdmin returns ( bool ) { require ( ! targetReached , "Access is denied." ) ; targetReached = true ; emit TargetReached ( ) ; }
function setUpgradedContractAddress ( address _upgradedContractAddress ) external onlyOwner whenPaused { upgradedContractAddress = _upgradedContractAddress ; ContractUpgrade ( _upgradedContractAddress ) ; }
function getCraftTokenAddress ( uint256 _tokenId ) public view returns ( address masterErc20 ) { masterErc20 = emojiCraftTokenAddress [ _tokenId ] ; }
function remove ( List storage self , address node ) internal { require ( isInList ( self , node ) , "not in list" ) ; if ( node == NULL ) { return ; } address p = self . list [ node ] . previous ; address n = self . list [ node ] . next ; self . list [ p ] . next = n ; self . list [ n ] . previous = p ; self . list [ node ] . inList = false ; delete self . list [ node ] ; }
function rateIsStale ( bytes4 currencyKey ) external view returns ( bool ) { if ( currencyKey == "sUSD" ) return false ; return lastRateUpdateTimes [ currencyKey ] . add ( rateStalePeriod ) < now ; }
function burn ( uint256 _value ) onlyOwner public returns ( bool success ) { require ( _balanceOf [ _owner ] >= _value ) ; require ( _totalSupply >= _value ) ; _balanceOf [ _owner ] -= _value ; _totalSupply -= _value ; Burn ( _owner , _value ) ; return true ; }
function transferOwnership ( address _newOwner ) public onlyOwner { if ( _newOwner != address ( 0 ) ) { newOwner = _newOwner ; } }
function onERC721Received ( address , address , uint256 _tokenId , bytes ) external returns ( bytes4 ) { if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) { flagReceiveLand = 0 ; return bytes4 ( 0x150b7a02 ) ; } }
function performBuyOrder ( OrderData data , uint256 amountToGiveForOrder ) public payable onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { if ( msg . value != amountToGiveForOrder ) { errorReporter . revertTx ( "msg.value != amountToGiveForOrder" ) ; } exchange . deposit . value ( amountToGiveForOrder ) ( ) ; uint256 amountToTrade ; uint256 fee ; ( amountToTrade , fee ) = substractFee ( data . exchangeFee , amountToGiveForOrder ) ; trade ( data , amountToTrade ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = getPartialAmount ( data . amountGive , data . amountGet , amountToTrade ) ; exchange . withdrawToken ( data . tokenGive , amountReceivedFromOrder ) ; if ( ! ERC20SafeTransfer . safeTransfer ( data . tokenGive , totlePrimary , amountReceivedFromOrder ) ) { errorReporter . revertTx ( "Unable to transfer bought tokens to primary" ) ; } }
function _multisig ( bytes32 _args , uint _block ) internal returns ( uint _code ) { bytes32 _txHash = _getKey ( _args , _block ) ; address _manager = getPendingManager ( ) ; _code = PendingManager ( _manager ) . hasConfirmedRecord ( _txHash ) ; if ( _code != NO_RECORDS_WERE_FOUND ) { return _code ; } if ( OK != PendingManager ( _manager ) . addTx ( _txHash , msg . sig , address ( this ) ) ) { revert ( ) ; } return MULTISIG_ADDED ; }
function _closeMotion ( uint motionID ) internal { delete targetMotionID [ motionTarget [ motionID ] ] ; delete motionTarget [ motionID ] ; delete motionStartTime [ motionID ] ; delete votesFor [ motionID ] ; delete votesAgainst [ motionID ] ; emit MotionClosed ( motionID ) ; }
function setSellPrice ( uint256 priceInWei ) isOwner { require ( priceInWei >= 0 ) ; sellPrice = priceInWei ; }
function withdrawPayments ( address payee ) external nonReentrant onlyController requiresState ( State . REFUNDING ) { uint256 payment = m_weiBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }
function getRareCoinAddress ( ) external view returns ( address ) { return _rcContract ; }
function internalAddInterest ( Loan storage loan , uint256 timestamp ) internal { if ( timestamp > loan . interestTimestamp ) { uint256 newInterest = loan . interest ; uint256 newPunitoryInterest = loan . punitoryInterest ; uint256 newTimestamp ; uint256 realDelta ; uint256 calculatedInterest ; uint256 deltaTime ; uint256 pending ; uint256 endNonPunitory = min ( timestamp , loan . dueTime ) ; if ( endNonPunitory > loan . interestTimestamp ) { deltaTime = endNonPunitory - loan . interestTimestamp ; if ( loan . paid < loan . amount ) { pending = loan . amount - loan . paid ; } else { pending = 0 ; } ( realDelta , calculatedInterest ) = calculateInterest ( deltaTime , loan . interestRate , pending ) ; newInterest = safeAdd ( calculatedInterest , newInterest ) ; newTimestamp = loan . interestTimestamp + realDelta ; } if ( timestamp > loan . dueTime ) { uint256 startPunitory = max ( loan . dueTime , loan . interestTimestamp ) ; deltaTime = timestamp - startPunitory ; uint256 debt = safeAdd ( loan . amount , newInterest ) ; pending = min ( debt , safeSubtract ( safeAdd ( debt , newPunitoryInterest ) , loan . paid ) ) ; ( realDelta , calculatedInterest ) = calculateInterest ( deltaTime , loan . interestRatePunitory , pending ) ; newPunitoryInterest = safeAdd ( newPunitoryInterest , calculatedInterest ) ; newTimestamp = startPunitory + realDelta ; } if ( newInterest != loan . interest || newPunitoryInterest != loan . punitoryInterest ) { loan . interestTimestamp = newTimestamp ; loan . interest = newInterest ; loan . punitoryInterest = newPunitoryInterest ; } } }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . sender == CaDataContract . ownerOf ( _tokenId ) || ownerOperators [ CaDataContract . atomOwner ( _tokenId ) ] [ msg . sender ] == true || msg . sender == tokenApprovals [ _tokenId ] ) ; require ( _from == CaDataContract . ownerOf ( _tokenId ) && _to != 0x0 ) ; require ( _tokenId < totalSupply ( ) ) ; _transfer ( _from , _to , _tokenId ) ; }
function deedUri ( uint256 _deedId ) external pure returns ( string _uri ) ;
function getDescription ( ) public view returns ( string ) { return "Manage permissions within the Security Token and attached modules" ; }
function removeOrders ( uint _from , uint _to ) returns ( bool ) { if ( _to == 0 || _to > numberOfOrders ) _to = numberOfOrders - 1 ; uint _totalAmount ; uint o = _from ; for ( uint i = _from ; i <= _to ; i ++ ) { if ( orders [ o ] . buyer == msg . sender ) { _totalAmount += orders [ o ] . weiGiven ; removeOrder ( o ) ; } else o += 1 ; } if ( ! msg . sender . send ( _totalAmount ) ) throw ; else return true ; }
function enableTransfers ( bool _transfersEnabled ) public ;
function updatePrice ( ) public { sellPrice = initialSellPrice * initialSupply * ( 10 ** uint256 ( decimals ) ) / totalSupply ; buyPrice = initialBuyPrice * initialSupply * ( 10 ** uint256 ( decimals ) ) / totalSupply ; }
function changeNonAccreditedLimit ( address [ ] _investors , uint256 [ ] _nonAccreditedLimit ) public onlyOwner { require ( _investors . length == _nonAccreditedLimit . length , "Array length mismatch" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { require ( _nonAccreditedLimit [ i ] > 0 , "Limit can not be 0" ) ; nonAccreditedLimitUSDOverride [ _investors [ i ] ] = _nonAccreditedLimit [ i ] ; emit SetNonAccreditedLimit ( _investors [ i ] , _nonAccreditedLimit [ i ] ) ; } }
function setETHPriceManually ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { require ( priceExpired ( ) || updateRequestExpired ( ) ) ; m_ETHPriceInCents = _price ; m_ETHPriceLastUpdate = getTime ( ) ; NewETHPrice ( m_ETHPriceInCents ) ; }
function findPledge ( uint64 idPledge ) internal returns ( Pledge storage ) { require ( idPledge < pledges . length ) ; return pledges [ idPledge ] ; }
function finalize ( ) public onlyOwner { require ( ! finalized ) ; finalized = true ; emit onFinalized ( ) ; }
function authorizePayment ( string _description , address _recipient , uint _amount , uint _paymentDelay ) returns ( uint ) { if ( ! allowedSpenders [ msg . sender ] ) throw ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; p . earliestPayTime = _paymentDelay >= timeLock ? now + _paymentDelay : now + timeLock ; p . recipient = _recipient ; p . amount = _amount ; p . description = _description ; PaymentAuthorized ( idPayment , p . recipient , p . amount ) ; return idPayment ; }
function depositMany ( address [ ] to , uint256 [ ] amount , bytes32 [ ] reference ) public { require ( to . length == amount . length ) ; require ( to . length == reference . length ) ; for ( uint256 i = 0 ; i < to . length ; i ++ ) { deposit ( to [ i ] , amount [ i ] , reference [ i ] ) ; } }
function getTokenSupply ( string currency ) public view returns ( uint supply ) { return lib . getTokenSupply ( currency ) ; }
function tokenURI ( uint256 _tokenId ) public view returns ( string ) { require ( exists ( _tokenId ) ) ; return tokenURIBase ; }
function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
function emergencyRedeem ( uint shareQuantity , address [ ] requestedAssets ) public pre_cond ( balances [ msg . sender ] >= shareQuantity ) returns ( bool ) { uint [ ] memory ownershipQuantities = new uint [ ] ( requestedAssets . length ) ; for ( uint i = 0 ; i < requestedAssets . length ; ++ i ) { address ofAsset = requestedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; if ( assetHoldings == 0 ) continue ; ownershipQuantities [ i ] = mul ( assetHoldings , shareQuantity ) / totalSupply ; if ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) < ownershipQuantities [ i ] ) { isShutDown = true ; ErrorMessage ( "CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy" ) ; return false ; } } annihilateShares ( msg . sender , shareQuantity ) ; for ( uint j = 0 ; j < ownershipQuantities . length ; ++ j ) { if ( ! AssetInterface ( ofAsset ) . transfer ( msg . sender , ownershipQuantities [ j ] ) ) { revert ( ) ; } } Redeemed ( msg . sender , now , shareQuantity ) ; return true ; }
function invokeOnceFor ( address _invoker ) public returns ( uint ) ;
function staticExchangeChecks ( OrderData order ) public view onlySelf returns ( bool checksPassed ) { return true ; }
function distributeTokens ( address [ ] buyers ) onlyOwner public { require ( currentState == State . Distribution ) ; require ( currentPeriodRate > 0 ) ; for ( uint256 i = 0 ; i < buyers . length ; i ++ ) { address buyer = buyers [ i ] ; require ( buyer != address ( 0 ) ) ; uint256 etherAmount = receivedEther [ buyer ] ; if ( etherAmount == 0 ) continue ; uint256 tokenAmount = etherAmount . mul ( currentPeriodRate ) ; uint256 fee = tokenAmount . mul ( buyFeeMilliPercent ) . div ( MILLI_PERCENT_DIVIDER ) ; tokenAmount = tokenAmount . sub ( fee ) ; receivedEther [ buyer ] = 0 ; currentPeriodEtherCollected = currentPeriodEtherCollected . sub ( etherAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; balances [ buyer ] = balances [ buyer ] . add ( tokenAmount ) ; Transfer ( address ( 0 ) , buyer , tokenAmount ) ; } }
function proxyPayment ( address ) payable returns ( bool ) { return false ; }
function singlePayout ( address _user , uint256 _amount ) onlyOwner returns ( bool paid ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( transferCheck ( owner , _user , _amount ) ) ; if ( ! userRegistered [ _user ] ) { registerUser ( _user ) ; } balances [ _user ] = add ( balances [ _user ] , _amount ) ; balances [ owner ] = sub ( balances [ owner ] , _amount ) ; Transfer ( owner , _user , _amount ) ; return true ; }
function getInstructions ( ) public view returns ( string ) ;
function exists ( uint256 _tokenId ) public view returns ( bool ) { return _exists ( _tokenId ) ; }
function pollBallot ( uint _idPoll , uint _ballot ) public view returns ( string ) { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll memory p = _polls [ _idPoll ] ; return rlpHelper . pollBallot ( p . description , _ballot ) ; }
function getChampsByOwner ( address _owner ) external view returns ( uint256 [ ] ) { uint256 [ ] memory result = new uint256 [ ] ( addressInfo [ _owner ] . champsCount ) ; uint256 counter = 0 ; for ( uint256 i = 0 ; i < champs . length ; i ++ ) { if ( champToOwner [ i ] == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }
function getAttributeTypeIDs ( ) external view returns ( uint256 [ ] ) ;
function getPreviousDarknodes ( address _start , uint256 _count ) external view returns ( address [ ] ) { uint256 count = _count ; if ( count == 0 ) { count = numDarknodesPreviousEpoch ; } return getDarknodesFromEpochs ( _start , count , true ) ; }
function pushDividendPayment ( uint256 _dividendIndex , uint256 _start , uint256 _iterations ) public withPerm ( DISTRIBUTE ) validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 numberInvestors = ISecurityToken ( securityToken ) . getInvestorsLength ( ) ; for ( uint256 i = _start ; i < Math . min256 ( numberInvestors , _start . add ( _iterations ) ) ; i ++ ) { address payee = ISecurityToken ( securityToken ) . investors ( i ) ; if ( ! dividend . claimed [ payee ] ) { _payDividend ( payee , dividend , _dividendIndex ) ; } } }
function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool ) ;
function getPendingAmount ( uint index ) public returns ( uint256 ) { addInterest ( index ) ; return getRawPendingAmount ( index ) ; }
function changeStatus ( uint idPackage , DAppNodePackageStatus newStatus ) onlyOwner public { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; c . status = newStatus ; StatusChanged ( idPackage , newStatus ) ; }
function setOfferExpiry ( uint256 expiry ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , "You are unknown and not allowed to trade." ) ; require ( expiry > block . timestamp , "Cannot have an expiry date in the past." ) ; TradeOrder memory order = orderBook [ msg . sender ] ; order . expiry = expiry ; orderBook [ msg . sender ] = order ; emit TokenOfferChanged ( msg . sender , order . quantity , order . price , order . expiry ) ; }
function totalSupply ( ) external view returns ( uint256 supply ) ;
function releaseTokensFromEscrowForUser ( address _payer , uint256 _amount ) private { subFromEscrow ( _payer , _amount ) ; token . safeTransfer ( _payer , _amount ) ; emit TokenMarketplaceWithdrawal ( _payer , _amount ) ; }
function collect ( ) public { assert ( getBlockTimestamp ( ) > contribution . startTime ( ) ) ; uint256 pre_sale_fixed_at = contribution . initializedBlock ( ) ; uint256 balance = apt . balanceOfAt ( msg . sender , pre_sale_fixed_at ) ; uint256 total = totalCollected . add ( aix . balanceOf ( address ( this ) ) ) ; uint256 amount = total . mul ( balance ) . div ( apt . totalSupplyAt ( pre_sale_fixed_at ) ) ; amount = amount . sub ( collected [ msg . sender ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( aix . transfer ( msg . sender , amount ) ) ; TokensCollected ( msg . sender , amount ) ; }
function createGame ( bytes32 _playerEndHash , uint _previousGameId , uint _createBefore , bytes32 _serverEndHash , bytes _serverSig ) public payable onlyValidValue onlyValidHouseStake ( activeGames + 1 ) onlyNotPaused { uint previousGameId = playerGameId [ msg . sender ] ; Game storage game = gameIdGame [ previousGameId ] ; require ( game . status == GameStatus . ENDED ) ; require ( previousGameId == _previousGameId ) ; require ( block . timestamp < _createBefore ) ; verifyCreateSig ( msg . sender , _previousGameId , _createBefore , _serverEndHash , _serverSig ) ; uint gameId = gameIdCntr ++ ; playerGameId [ msg . sender ] = gameId ; Game storage newGame = gameIdGame [ gameId ] ; newGame . stake = uint128 ( msg . value ) ; newGame . status = GameStatus . ACTIVE ; activeGames = activeGames + 1 ; emit LogGameCreated ( msg . sender , gameId , uint128 ( msg . value ) , _serverEndHash , _playerEndHash ) ; }
function finalize ( ) public onlyOwner { require ( stage ( ) == Stage . Closed ) ; uint256 unsold = publicSupply . sub ( soldOut . cornerstoneValue ) . sub ( soldOut . vcValue ) ; if ( unsold > 0 ) { you . createOption ( 0x000000000000000000000000000000000000002b , unsold , 4070880001 , 365 ) ; } finalized = true ; LogFinalized ( ) ; }
function balanceUpdatesCount ( address account ) public view returns ( uint256 ) { return balanceBlocks [ account ] . length ; }
function initializeCrowdsale ( uint256 _startTime , uint256 _endTime , address _token , uint256 _intervalUpdate ) public payable onlyOwner mustBeAtStage ( Stage . ToInitialize ) { require ( _startTime >= now ) ; require ( _endTime >= _startTime ) ; require ( _token != address ( 0 ) ) ; require ( msg . value > 0 ) ; require ( isContract ( _token ) == true ) ; require ( _intervalUpdate >= 5 ) ; startTime = _startTime ; endTime = _endTime ; token = Token ( _token ) ; intervalUpdate = _intervalUpdate ; currentStage = Stage . Waiting ; updateEthRateWithDelay ( startTime - ( intervalUpdate + 30 ) ) ; LogCrowdsaleInit ( ) ; assert ( token . balanceOf ( address ( this ) ) == MAX_TOKENS ) ; }
function getStartDateOfCampaign ( bytes32 bidId ) public view returns ( uint startDate ) { return advertisementStorage . getCampaignStartDateById ( bidId ) ; }
function goalReached ( ) public constant returns ( bool ) { return tokensRaised >= minimumGoal ; }
function transfer ( address _to , uint256 _amount ) public returns ( bool ) ;
function buyToken ( ) external payable { _buyToken ( msg . sender ) ; }
function approveCompletedMilestone ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . reviewer ) || ( milestone . status != MilestoneStatus . Completed ) ) throw ; doPayment ( _idMilestone ) ; }
function newVersion ( uint16 [ 3 ] _newSemanticVersion , address _contractAddress , bytes _contentURI ) public auth ( CREATE_VERSION_ROLE ) { address contractAddress = _contractAddress ; uint256 lastVersionIndex = versionsNextIndex - 1 ; uint16 [ 3 ] memory lastSematicVersion ; if ( lastVersionIndex > 0 ) { Version storage lastVersion = versions [ lastVersionIndex ] ; lastSematicVersion = lastVersion . semanticVersion ; if ( contractAddress == address ( 0 ) ) { contractAddress = lastVersion . contractAddress ; } require ( lastVersion . contractAddress == contractAddress || _newSemanticVersion [ 0 ] > lastVersion . semanticVersion [ 0 ] , ERROR_INVALID_VERSION ) ; } require ( isValidBump ( lastSematicVersion , _newSemanticVersion ) , ERROR_INVALID_BUMP ) ; uint256 versionId = versionsNextIndex ++ ; versions [ versionId ] = Version ( _newSemanticVersion , contractAddress , _contentURI ) ; versionIdForSemantic [ semanticVersionHash ( _newSemanticVersion ) ] = versionId ; latestVersionIdForContract [ contractAddress ] = versionId ; emit NewVersion ( versionId , _newSemanticVersion ) ; }
function _investAsEarlybird ( address _beneficiary , uint256 _amountTokens ) internal { tokensBoughtInEarlybird = tokensBoughtInEarlybird . add ( _amountTokens ) ; earlybird . addAmountBoughtAsMember ( _beneficiary , _amountTokens ) ; _depositTokens ( _beneficiary , _amountTokens ) ; emit BoughtEarlyBird ( _beneficiary , _amountTokens ) ; if ( tokensBoughtInEarlybird >= INITIAL_EARLYBIRD_TOKENS ) { earlybirdEnded = true ; } }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; _balance [ _from ] = _balance [ _from ] . sub ( _value ) ; _balance [ _to ] = _balance [ _to ] . add ( _value ) ; _allowed [ _from ] [ msg . sender ] = _allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
function settleCurrentLockPeriod ( address _address ) private returns ( bool ) { mintedActFromCurrentLockPeriodPerUser [ _address ] = getMintedActFromCurrentLockPeriod ( _address ) ; mintedActFromPastLockPeriodsPerUser [ _address ] = mintedActFromPastLockPeriodsPerUser [ _address ] . add ( mintedActFromCurrentLockPeriodPerUser [ _address ] ) ; mintedActPerUser [ _address ] = totalMintedActPerLockedBbkToken ; return true ; }
function release ( uint256 _amount ) public { uint256 balance = token . balanceOf ( address ( this ) ) ; require ( balance > 0 ) ; if ( ! withdrawalsInitiated ) { unlocked = balance . div ( 2 ) ; withdrawalsInitiated = true ; } if ( now >= releaseTime ) { unlocked = balance ; } require ( _amount <= unlocked ) ; unlocked = unlocked . sub ( _amount ) ; token . safeTransfer ( beneficiary , _amount ) ; }
function getCanvasBitmap ( uint32 _canvasId ) external view returns ( uint8 [ ] ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; uint8 [ ] memory result = new uint8 [ ] ( PIXEL_COUNT ) ; for ( uint32 i = 0 ; i < PIXEL_COUNT ; i ++ ) { result [ i ] = canvas . pixels [ i ] . color ; } return result ; }
function closeSetup ( ) ;
function batchCreateAsset ( uint8 [ ] _teamId , uint256 [ ] _attributes , uint256 [ ] _playerOverrideId , uint256 [ ] _mlbPlayerId , address [ ] _to ) external canCreate whenNotPaused { require ( isBatchSupported ) ; require ( _teamId . length > 0 && _attributes . length > 0 && _playerOverrideId . length > 0 && _mlbPlayerId . length > 0 && _to . length > 0 ) ; uint256 assetDetails ; uint256 [ 5 ] memory _nftData ; for ( uint ii = 0 ; ii < _attributes . length ; ii ++ ) { require ( _to [ ii ] != address ( 0 ) && _teamId [ ii ] != 0 && _attributes . length != 0 && _mlbPlayerId [ ii ] != 0 ) ; assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( getSequenceId ( _teamId [ ii ] ) ) << 64 ; assetDetails |= uint256 ( _teamId [ ii ] ) << 96 ; assetDetails |= uint256 ( ( _attributes [ ii ] / 1000000000000000000000000000000000000000 ) - 800 ) << 104 ; _nftData = [ assetDetails , _attributes [ ii ] , 0 , _playerOverrideId [ ii ] , _mlbPlayerId [ ii ] ] ; _createNFTCollectible ( _teamId [ ii ] , _attributes [ ii ] , _to [ ii ] , 0 , _nftData ) ; } }
function ownerResumeContract ( ) external onlyOwner { require ( contractPaused ) ; contractPaused = false ; }
function revokeAttribute ( address account ) external onlyCareCoordinators { require ( _revokeAttribute ( account ) ) ; }
function batchAddToWhitelist ( uint maxBuyinQuantity , address [ ] whitelistants ) pre_cond ( isOwner ( ) ) pre_cond ( now < endTime ) { for ( uint i = 0 ; i < whitelistants . length ; ++ i ) { whitelistantToMaxBuyin [ whitelistants [ i ] ] = maxBuyinQuantity ; } }
function addWineryOperationEndorsement ( string _mappingID , uint _index , bool positive , string title , string description ) external returns ( bool success ) { wineryOperationEndorsements [ keccak256 ( _mappingID , _index ) ] . push ( Endorsement ( positive , title , description , msg . sender ) ) ; return true ; }
function setNextPriceOf ( uint256 tokenId , uint256 salePrice ) external whenNotPaused { require ( msg . sender == address ( saleAuction ) ) ; masterpieceToPrice [ tokenId ] = computeNextPrice ( salePrice ) ; }
function getAccountSpendingLimit ( address account ) public view returns ( uint spendingLimit ) { return lib . getAccountSpendingLimit ( account ) ; }
function emergencyCancel ( bytes32 _offerHash , uint256 _expectedAvailableAmount ) external onlyCoordinator onlyInactiveState { _cancel ( _offerHash , _expectedAvailableAmount , etherAddr , 0 ) ; }
function batchApprove ( address _to , uint32 [ ] _tokenIds ) public whenNotPaused { for ( uint32 i = 0 ; i < _tokenIds . length ; i ++ ) { uint32 _tokenId = _tokenIds [ i ] ; require ( _owns ( msg . sender , _tokenId ) || ( operators [ ownerOf ( _tokenId ) ] [ msg . sender ] ) ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; } }
function contestForUser ( address _attester , address _requester , uint256 _reward , bytes32 _requestNonce , bytes _requesterSig ) private { if ( _reward > 0 ) { tokenEscrowMarketplace . requestTokenPayment ( _requester , _attester , _reward , _requestNonce , _requesterSig ) ; } emit AttestationRejected ( _attester , _requester ) ; }
function getRewardsBalance ( address _user ) public view returns ( uint256 _balance ) { return ExtendedFinance ( address ( _getFinance ( ) ) ) . getRewardsBalance ( _user ) ; }
function getBlockOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return miners [ _miner ] . block ; }
function issueMaxSynths ( bytes4 currencyKey ) external optionalProxy { uint maxIssuable = remainingIssuableSynths ( messageSender , currencyKey ) ; issueSynths ( currencyKey , maxIssuable ) ; }
function investInternal ( address _receiver , bytes16 _customerUuid ) private { uint weiAmount = msg . value ; uint256 tokenAmount = pricingStrategy . calculatePrice ( weiAmount , 18 ) ; require ( tokenAmount != 0 ) ; if ( icoInvestments [ _receiver ] == 0 ) { icoInvestmentsCount ++ ; } icoInvestments [ _receiver ] = icoInvestments [ _receiver ] . add ( weiAmount ) ; icoTokenTransfers [ _receiver ] = icoTokenTransfers [ _receiver ] . add ( tokenAmount ) ; icoReceivedWei = icoReceivedWei . add ( weiAmount ) ; icoTokensSold = icoTokensSold . add ( tokenAmount ) ; assignTokens ( owner , _receiver , tokenAmount ) ; wallet . transfer ( weiAmount ) ; Invested ( _receiver , weiAmount , tokenAmount , _customerUuid ) ; }
function sealed ( ) constant returns ( bool ) { return tokenController == 0 ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; uint256 allowance = allowed [ _from ] [ msg . sender ] ; require ( _value <= allowance || _from == msg . sender ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; balanceOf [ _from ] = balanceOf [ _from ] . sub ( _value ) ; if ( allowed [ _from ] [ msg . sender ] != MAX_UINT256 && _from != msg . sender ) { allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; } Transfer ( _from , _to , _value ) ; return true ; }
function addAttributeType ( uint256 ID , string description ) external ;
function updateTransfer ( Data storage self , uint64 nonce , uint256 transferred_amount , bytes32 locksroot , bytes32 extra_hash , bytes signature ) notSettledButClosed ( self ) stillTimeout ( self ) { address transfer_address ; uint8 caller_index ; uint8 closer_index ; require ( ! self . updated ) ; self . updated = true ; caller_index = index_or_throw ( self , msg . sender ) ; require ( self . closing_address != msg . sender ) ; transfer_address = recoverAddressFromSignature ( nonce , transferred_amount , locksroot , extra_hash , signature ) ; require ( transfer_address == self . closing_address ) ; closer_index = 1 - caller_index ; self . participants [ closer_index ] . nonce = nonce ; self . participants [ closer_index ] . locksroot = locksroot ; self . participants [ closer_index ] . transferred_amount = transferred_amount ; }
function __approve ( address _spender , uint _value , address _sender ) onlyAccess ( _sender ) public returns ( bool ) { return chronoBankPlatform . proxyApprove ( _spender , _value , smbl , _sender ) == OK ; }
function ( ) payable public { require ( msg . value > 0 ) ; require ( crowdsaleRunning ( ) ) ; uint256 rate = currentRate ( msg . value ) ; require ( rate > 0 ) ; uint256 tokens = rate . mul ( msg . value ) . div ( DOCT_TO_ETH_DECIMALS ) ; mintTokens ( msg . sender , tokens ) ; }
function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , "ERC777TokensRecipient" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _data , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) , "Cannot send to contract without ERC777TokensRecipient" ) ; } }
function withdrawCollateral ( address token , uint amount ) public { require ( token != 0 ) ; require ( isAcceptedToken ( token ) , "ERC20 not authorised" ) ; require ( isMasternodeOwner ( msg . sender ) ) ; require ( tokens [ token ] [ msg . sender ] == amount ) ; uint amountToWithdraw = tokens [ token ] [ msg . sender ] ; tokens [ token ] [ msg . sender ] = 0 ; deleteMasternode ( getLastPerUser ( msg . sender ) ) ; if ( ! StandardToken ( token ) . transfer ( msg . sender , amountToWithdraw ) ) revert ( ) ; emit Withdraw ( token , msg . sender , amountToWithdraw , amountToWithdraw ) ; }
function migrate ( uint256 _value ) external onlyUnlocked ( ) { if ( migrationAgent == 0 ) revert ( ) ; if ( _value == 0 ) revert ( ) ; if ( _value > balances [ msg . sender ] ) revert ( ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; totalMigrated += _value ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }
function playerCancelActiveGame ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; if ( game . status == GameStatus . ACTIVE ) { game . endInitiatedTime = block . timestamp ; game . status = GameStatus . PLAYER_INITIATED_END ; LogPlayerRequestedEnd ( msg . sender , gameId ) ; } else if ( game . status == GameStatus . SERVER_INITIATED_END && game . roundId == 0 ) { closeGame ( game , gameId , playerAddress , ReasonEnded . REGULAR_ENDED , 0 ) ; payOut ( game , playerAddress ) ; } else { revert ( ) ; } }
function whitelist ( address _affiliate , uint256 _rate ) onlyOwner public { require ( _rate <= hardCodedMaximumRate ) ; whitelistRates [ _affiliate ] = _rate ; Whitelisted ( _affiliate , _rate ) ; }
function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; doTransfer ( _from , _to , _amount ) ; return true ; }
function createDividend ( uint256 _maturity , uint256 _expiry , bytes32 _name ) external payable withPerm ( MANAGE ) { createDividendWithExclusions ( _maturity , _expiry , excluded , _name ) ; }
function amountReceivedFromTransfer ( uint value ) external view returns ( uint ) { return value . divideDecimal ( transferFeeRate . add ( SafeDecimalMath . unit ( ) ) ) ; }
function acceptBuyOffer ( uint32 _canvasId , uint _minPrice ) external stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; require ( canvas . owner == msg . sender ) ; BuyOffer memory offer = buyOffers [ _canvasId ] ; require ( offer . hasOffer ) ; require ( offer . amount > 0 ) ; require ( offer . buyer != 0x0 ) ; require ( offer . amount >= _minPrice ) ; uint toTransfer ; ( , , toTransfer ) = _registerTrade ( _canvasId , offer . amount ) ; addressToCount [ canvas . owner ] -- ; addressToCount [ offer . buyer ] ++ ; canvas . owner = offer . buyer ; addPendingWithdrawal ( msg . sender , toTransfer ) ; buyOffers [ _canvasId ] = BuyOffer ( false , 0x0 , 0 ) ; canvasForSale [ _canvasId ] = SellOffer ( false , 0x0 , 0 , 0x0 ) ; emit CanvasSold ( _canvasId , offer . amount , msg . sender , offer . buyer ) ; }
function approve ( address spender , uint256 value ) returns ( bool success ) { allowance [ msg . sender ] [ spender ] = value ; return true ; }
function name ( ) public pure returns ( string ) { return "Pirate Conquest Token" ; }
function tokensBoughtWithBTC ( address _beneficiary , uint256 _tokens ) public payable { require ( msg . sender == btcTokenBoughtAddress ) ; require ( started ) ; require ( ! finished ) ; require ( _beneficiary != address ( 0 ) ) ; require ( whitelist [ _beneficiary ] ) ; require ( fidaToken . totalSupply ( ) < 24750 * 10 ** 3 * 10 ** DECIMALS ) ; require ( _tokens >= 50 * 10 ** DECIMALS ) ; if ( ! earlybirdEnded ) { _investAsEarlybird ( _beneficiary , _tokens ) ; } else { _investAsBonusProgram ( _beneficiary , _tokens ) ; } }
function increaseApproval ( address _spender , uint256 _addedValue ) public returns ( bool ) { require ( ! freezeTransfer || isOps ( ) , "all transfers are currently frozen" ) ; require ( _spender != address ( 0 ) , "zero address is not allowed" ) ; require ( _addedValue >= 1000 , "must approve more than 1000 sip" ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _addedValue ) ; emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }
function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }
function setMinter ( address _who ) public onlyValidator { _setMinter ( _who ) ; }
function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; if ( guaranteedBuyersLimit [ _th ] > 0 ) { buyGuaranteed ( _th ) ; } else { buyNormal ( _th ) ; } return true ; }
function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard external { require ( _idPayment < authorizedPayments . length ) ; require ( _delay <= 10 ** 18 ) ; Payment storage p = authorizedPayments [ _idPayment ] ; require ( p . securityGuardDelay + _delay <= maxSecurityGuardDelay ) ; require ( ! p . paid ) ; require ( ! p . canceled ) ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }
function setVault ( address _newVaultAddress ) onlyOwner { vaultAddress = _newVaultAddress ; }
function release ( ) public { require ( now >= releaseTime ) ; assert ( current_month <= 5 ) ; uint diff = now - releaseTime ; if ( diff > month ) { releaseTime = now ; } else { releaseTime = now . add ( month . sub ( diff ) ) ; } current_month ++ ; token . safeTransfer ( beneficiary , twenty_percent_of_amount ) ; }
function unfreezeAmount ( address target ) onlyOwner public { frozenAmount [ target ] = 0 ; emit UnfrozenAmt ( target ) ; }
function addMultipleParticipants ( address [ ] _participants ) public onlyAdmin returns ( bool ) { for ( uint i = 0 ; i < _participants . length ; i ++ ) { require ( addParticipant ( _participants [ i ] ) ) ; } return true ; }
function begin ( ) external view onlyOwner returns ( address ) { return LinkedList . begin ( darknodes ) ; }
function _emitERC20DividendDepositedEvent ( uint256 _checkpointId , uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 currentSupply , uint256 dividendIndex , bytes32 _name ) internal { emit ERC20DividendDeposited ( msg . sender , _checkpointId , now , _maturity , _expiry , _token , _amount , currentSupply , dividendIndex , _name ) ; }
function requireMultiple ( uint256 _amount ) internal view { require ( _amount . div ( mGranularity ) . mul ( mGranularity ) == _amount , "You can only use tokens using the granularity currently set." ) ; }
function finishMinting ( ) internal returns ( bool ) { require ( finalized == true ) ; require ( super . finishMinting ( ) ) ; return true ; }
function withdrawEther ( ) public onlyContractOwner { uint balance = address ( this ) . balance ; if ( balance > 0 ) { contractOwner . transfer ( balance ) ; } }
function removeTokensFromAccount ( bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses onlyRegisteredAccount ( _uuid ) whenNotPaused internal returns ( bool ) { balances [ _uuid ] = balances [ _uuid ] . sub ( _tokensCount ) ; return true ; }
function getTotalRewards ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; if ( _lastIndex < 0 ) { return 0 ; } return _history . rewardsCumulative [ _lastIndex ] ; }
function mint ( address _owner , uint256 _amount ) public onlyMinter validate_address ( _owner ) returns ( bool success ) { if ( totalSupply + _amount < totalSupply ) revert ( ) ; if ( balances [ _owner ] + _amount < balances [ _owner ] ) revert ( ) ; totalSupply += _amount ; balances [ _owner ] += _amount ; Transfer ( 0x0 , msg . sender , _amount ) ; Transfer ( msg . sender , _owner , _amount ) ; return true ; }
function batchTransferFrom ( address _from , address _to , uint32 [ ] _tokenIds ) public whenNotPaused { for ( uint32 i = 0 ; i < _tokenIds . length ; i ++ ) { uint32 _tokenId = _tokenIds [ i ] ; require ( _approvedFor ( _to , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _owns ( msg . sender , _tokenId ) || ( msg . sender == playerTokenToApproved [ _tokenId ] ) || operators [ _from ] [ msg . sender ] ) ; _transfer ( _from , _to , _tokenId ) ; } }
function getTagsByTypeAndToken ( uint8 _moduleType , address _securityToken ) external view returns ( bytes32 [ ] , address [ ] ) { address [ ] memory modules = getModulesByTypeAndToken ( _moduleType , _securityToken ) ; return _tagsByModules ( modules ) ; }
function changeIsPayableEnabled ( ) onlyMultiSig { isPayableEnabled = ! isPayableEnabled ; LogChangeIsPayableEnabled ( isPayableEnabled ) ; }
function getPositionId ( uint256 _tokenId ) external view returns ( uint256 ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; uint256 positionId = uint256 ( uint8 ( obj . assetDetails >> 104 ) ) ; return positionId ; }
function noError ( ) public onlyGameManager whenPaused { error = false ; }
function getNumberInvestors ( ) public view returns ( uint256 ) { return investorCount ; }
function __transferFromWithReference ( address _from , address _to , uint _value , string _reference , address _sender ) onlyAccess ( _sender ) public returns ( bool ) { return chronoBankPlatform . proxyTransferFromWithReference ( _from , _to , _value , smbl , _reference , _sender ) == OK ; }
function commitVote ( uint _pollID , bytes32 _secretHash , uint _numTokens , uint _prevPollID ) external { require ( commitPeriodActive ( _pollID ) ) ; require ( voteTokenBalance [ msg . sender ] >= _numTokens ) ; require ( _pollID != 0 ) ; require ( _prevPollID == 0 || getCommitHash ( msg . sender , _prevPollID ) != 0 ) ; uint nextPollID = dllMap [ msg . sender ] . getNext ( _prevPollID ) ; nextPollID = ( nextPollID == _pollID ) ? dllMap [ msg . sender ] . getNext ( _pollID ) : nextPollID ; require ( validPosition ( _prevPollID , nextPollID , msg . sender , _numTokens ) ) ; dllMap [ msg . sender ] . insert ( _prevPollID , _pollID , nextPollID ) ; bytes32 UUID = attrUUID ( msg . sender , _pollID ) ; store . setAttribute ( UUID , "numTokens" , _numTokens ) ; store . setAttribute ( UUID , "commitHash" , uint ( _secretHash ) ) ; VoteCommitted ( msg . sender , _pollID , _numTokens ) ; }
function updateRegisteredWallet ( address addr ) onlyOwner external { registered_wallet = addr ; }
function burn ( uint256 _value , uint256 _confirmation ) onlyOwner public returns ( bool success ) { require ( _confirmation == 7007 ) ; require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; emit Burn ( msg . sender , _value ) ; return true ; }
function updateTimeLock ( uint256 _timelockEndTime ) onlyOwner public returns ( bool ) { timelockEndTime = _timelockEndTime ; emit UpdateTimeLock ( _timelockEndTime ) ; return true ; }
function checkBtcRequestSignature ( bytes requestData , bytes payeesPaymentAddress , uint256 expirationDate , bytes signature ) internal view returns ( bool ) { bytes32 hash = getBtcRequestHash ( requestData , payeesPaymentAddress , expirationDate ) ; uint8 v = uint8 ( signature [ 64 ] ) ; v = v < 27 ? v . add ( 27 ) : v ; bytes32 r = Bytes . extractBytes32 ( signature , 0 ) ; bytes32 s = Bytes . extractBytes32 ( signature , 32 ) ; return isValidSignature ( Bytes . extractAddress ( requestData , 0 ) , hash , v , r , s ) ; }
function emitTransfer ( address _from , address _to , uint _value ) onlyChronoBankPlatform public { emit Transfer ( _from , _to , _value ) ; }
function getWithdrawableOperationFeeDatesAndAmount ( ) external view returns ( uint32 [ ] , uint256 ) { if ( msg . sender != owner ) { return ( new uint32 [ ] ( 0 ) , 0 ) ; } uint32 cutoffTime = uint32 ( now ) . sub ( WITHDRAW_BUFFER ) ; uint32 maxLength = cutoffTime . sub ( MAY_FIRST_2018 ) . div ( DAY ) . add ( 1 ) ; uint32 [ ] memory withdrawableDates = new uint32 [ ] ( maxLength ) ; uint256 index = 0 ; uint256 withdrawAmount = 0 ; uint32 date = MAY_FIRST_2018 ; while ( date < cutoffTime ) { if ( ! dateToContestStatus [ date ] . operationFeeWithdrawn ) { uint256 amount = calculateOperationFee ( date ) ; if ( amount > 0 ) { withdrawableDates [ index ] = date ; withdrawAmount = withdrawAmount . add ( amount ) ; index += 1 ; } } date = date . add ( DAY ) ; } return ( withdrawableDates , withdrawAmount ) ; }
function getAssetAttachment ( uint256 _tokenId ) external view returns ( uint256 [ ] ) { uint256 [ ] _attachments = nftCollectibleAttachments [ _tokenId ] ; uint256 [ ] attachments ; for ( uint i = 0 ; i < _attachments . length ; i ++ ) { attachments . push ( _attachments [ i ] ) ; } return attachments ; }
function freeze ( address _target , uint256 _frozenAmount , uint256 _releaseAmount ) byToken public returns ( bool ) { require ( _target != 0x0 ) ; require ( _frozenAmount > 0 ) ; require ( _releaseAmount < _frozenAmount ) ; totalFrozen = totalFrozen . add ( _frozenAmount ) ; FrozenStatus storage frozenStatus = frozenStatuses [ _target ] ; require ( frozenStatus . frozenAmount == 0 ) ; frozenStatus . frozenTimestamp = now ; frozenStatus . frozenAmount = _frozenAmount ; frozenStatus . releaseAmount = _releaseAmount ; FreezeTokens ( _target , _frozenAmount ) ; return true ; }
function setIssuer ( address _issuer ) public { }
function getBudgetOfCampaign ( bytes32 bidId ) public view returns ( uint budget ) { return advertisementStorage . getCampaignBudgetById ( bidId ) ; }
function claimByAddress ( address _address ) public returns ( bool ) { return claimInternal ( _address ) ; }
function transfer ( address _to , uint _value ) returns ( bool success ) ;
function changeGasLimit ( uint256 _gasLimit ) public { require ( msg . sender == priceCheckerAddress ) ; gasLimit = _gasLimit ; }
function sendTokens ( address _to , uint _value ) public onlyMinter validAddress ( _to ) notZero ( _value ) { balances [ _to ] = SafeMath . add ( balances [ _to ] , _value ) ; totalSupply = SafeMath . add ( totalSupply , _value ) ; Transfer ( 0x0 , _to , _value ) ; }
function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Sufficent Allowance is not provided" ) ; require ( USDTieredSTOProxyAddress != address ( 0 ) , "Proxy contract should be pre-set" ) ; address usdTieredSTO = IUSDTieredSTOProxy ( USDTieredSTOProxyAddress ) . deploySTO ( msg . sender , address ( polyToken ) , address ( this ) ) ; require ( Util . getSig ( _data ) == IUSDTieredSTOProxy ( USDTieredSTOProxyAddress ) . getInitFunction ( usdTieredSTO ) , "Invalid data" ) ; require ( address ( usdTieredSTO ) . call ( _data ) , "Unsuccessfull call" ) ; emit GenerateModuleFromFactory ( usdTieredSTO , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( usdTieredSTO ) ; }
function addAttribute ( uint256 attributeTypeID , uint256 value , uint256 validatorFee , bytes signature ) external payable ;
function setMinStandingBalance ( uint balance ) external onlyOwner { minStandingBalance = balance ; }
function addTx ( bytes32 _key , bytes4 _sig , address _contract ) external onlyAuthorized returns ( uint ) { require ( _key != bytes32 ( 0 ) ) ; require ( _sig != bytes4 ( 0 ) ) ; require ( _contract != 0x0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; require ( isPolicyExist ( _policyHash ) ) ; if ( isTxExist ( _key ) ) { return _emitError ( PENDING_DUPLICATE_TX ) ; } if ( _policyHash == bytes32 ( 0 ) ) { return _emitError ( PENDING_MANAGER_POLICY_NOT_FOUND ) ; } uint _index = txCount . add ( 1 ) ; txCount = _index ; index2txKey [ _index ] = _key ; txKey2index [ _key ] = _index ; Guard storage _guard = txKey2guard [ _key ] ; _guard . basePolicyIndex = policyId2Index [ _policyHash ] ; _guard . state = GuardState . InProcess ; Policy storage _policy = policyId2policy [ _policyHash ] ; uint _counter = _policy . securesCount . add ( 1 ) ; _policy . securesCount = _counter ; _policy . index2txIndex [ _counter ] = _index ; _policy . txIndex2index [ _index ] = _counter ; ProtectionTxAdded ( _key , _policyHash , block . number ) ; return OK ; }
function claimed ( address investor ) public { delete _commitments [ msg . sender ] [ investor ] ; }
function generateTokens ( address _owner , uint _amount ) public returns ( bool ) ;
function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( ( _value != 0 ) && ( allowed [ msg . sender ] [ _spender ] != 0 ) ) { return false ; } allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function changeResource ( bytes32 _resource ) public onlyOwner returns ( bool ) { resource = _resource ; ChangedResource ( _resource ) ; return true ; }
function takeOrder ( uint exchangeNumber , uint id , uint receiveQuantity ) external pre_cond ( isOwner ( ) ) pre_cond ( ! isShutDown ) { Order memory order ; ( order . sellAsset , order . buyAsset , order . sellQuantity , order . buyQuantity ) = exchanges [ exchangeNumber ] . exchangeAdapter . getOrder ( exchanges [ exchangeNumber ] . exchange , id ) ; require ( order . sellAsset != address ( this ) ) ; require ( module . pricefeed . existsPriceOnAssetPair ( order . buyAsset , order . sellAsset ) ) ; require ( isInAssetList [ order . sellAsset ] || ownedAssets . length < MAX_FUND_ASSETS ) ; var ( isRecent , referencePrice , ) = module . pricefeed . getReferencePrice ( order . buyAsset , order . sellAsset ) ; require ( isRecent ) ; require ( receiveQuantity <= order . sellQuantity ) ; uint spendQuantity = mul ( receiveQuantity , order . buyQuantity ) / order . sellQuantity ; require ( AssetInterface ( order . buyAsset ) . approve ( exchanges [ exchangeNumber ] . exchange , spendQuantity ) ) ; require ( module . riskmgmt . isTakePermitted ( module . pricefeed . getOrderPrice ( order . buyAsset , order . sellAsset , order . buyQuantity , order . sellQuantity ) , referencePrice , order . buyAsset , order . sellAsset , order . buyQuantity , order . sellQuantity ) ) ; require ( address ( exchanges [ exchangeNumber ] . exchangeAdapter ) . delegatecall ( bytes4 ( keccak256 ( "takeOrder(address,uint256,uint256)" ) ) , exchanges [ exchangeNumber ] . exchange , id , receiveQuantity ) ) ; if ( ! isInAssetList [ order . sellAsset ] ) { ownedAssets . push ( order . sellAsset ) ; isInAssetList [ order . sellAsset ] = true ; } order . exchangeId = id ; order . status = OrderStatus . fullyFilled ; order . orderType = OrderType . take ; order . timestamp = now ; order . fillQuantity = receiveQuantity ; orders . push ( order ) ; OrderUpdated ( id ) ; }
function changeRate ( uint256 _rate ) external whenNotPaused onlyAdmin { require ( _rate > 0 , "Rate must be greater than 0" ) ; emit RateChanged ( _rate , rate ) ; rate = _rate ; }
function nextPhase ( ) public onlyOwner { require ( currentPhase . id != PhaseID . Closed , "already reached the closed phase" ) ; uint8 nextPhaseNum = uint8 ( currentPhase . id ) + 1 ; if ( PhaseID ( nextPhaseNum ) == PhaseID . First ) { currentPhase = firstPhase ; deadline = now + 365 * 1 days ; } if ( PhaseID ( nextPhaseNum ) == PhaseID . Second ) { currentPhase = secondPhase ; } if ( PhaseID ( nextPhaseNum ) == PhaseID . Third ) { currentPhase = thirdPhase ; } if ( PhaseID ( nextPhaseNum ) == PhaseID . Closed ) { currentPhase = closedPhase ; } emit PhaseEntered ( currentPhase . id ) ; }
function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 0 ) ; return availableTags ; }
function onERC721Received ( address operator , address from , uint256 tokenId , bytes data ) public returns ( bytes4 ) ;
function startPreICO ( ) onlyOwner public { require ( state == State . NotStarted ) ; require ( baseRate != 0 ) ; state = State . PreICO ; }
function setCampaignOwnerById ( bytes32 bidId , address newOwner ) public onlyIfCampaignExists ( "setCampaignOwnerById" , bidId ) onlyIfWhitelisted ( "setCampaignOwnerById" , msg . sender ) { campaigns [ bidId ] . setOwner ( newOwner ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
function setPrice ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; }
function withdrawTokens ( ) onlyOwner public returns ( bool ) { require ( token . transfer ( owner , token . balanceOf ( this ) ) ) ; return true ; }
function withdrawBalance ( ) external { uint256 etherOwed = addressToEtherOwed [ msg . sender ] ; require ( etherOwed > 0 ) ; delete addressToEtherOwed [ msg . sender ] ; outstandingEther -= etherOwed ; msg . sender . transfer ( etherOwed ) ; }
function reparametrizeMultisig ( bytes32 msigId , uint unlockTime ) public payable { Multisig storage multisig = multisigs [ msigId ] ; multisig . deposit = add ( multisig . deposit , msg . value ) ; assert ( multisig . unlockTime <= unlockTime ) ; multisig . unlockTime = unlockTime ; }
function renounceOwner ( ) public onlyOwner { emit TransferredOwner ( _owner , address ( 0 ) ) ; _owner = address ( 0 ) ; }
function unstakeCommunityTokens ( ) public { uint amount = communityAccount . stakedBalances ( msg . sender ) ; require ( now - communityAccount . timeStaked ( msg . sender ) >= lockupPeriodSeconds ) ; communityAccount . setStakedBalances ( 0 , msg . sender ) ; communityAccount . setTotalStaked ( SafeMath . sub ( communityAccount . totalStaked ( ) , amount ) ) ; require ( communityAccount . transferTokensOut ( address ( communityTokenInstance ) , msg . sender , amount ) ) ; logger . emitGenericLog ( "unstakeCommunityTokens" , "" ) ; }
function ownersOfArea ( uint256 x , uint256 y , uint256 x2 , uint256 y2 ) external view returns ( address [ ] result ) { require ( x2 > x && y2 > y ) ; require ( x2 <= WIDTH && y2 <= HEIGHT ) ; result = new address [ ] ( ( y2 - y ) * ( x2 - x ) ) ; uint256 r = 0 ; for ( uint256 i = y ; i < y2 ; i ++ ) { uint256 tokenId = i * WIDTH ; for ( uint256 j = x ; j < x2 ; j ++ ) { result [ r ] = pixelIndexToOwner [ tokenId + j ] ; r ++ ; } } }
function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) { return competitionAddress == ofParticipant ; }
function internalOrderExecution ( Tokens tokens , DEXOrders orders ) internal { transferTokens ( tokens ) ; uint256 tokensLength = tokens . tokenAddresses . length ; uint256 ordersLength = orders . tokenForOrder . length ; uint256 etherBalance = msg . value ; uint256 orderIndex = 0 ; for ( uint256 tokenIndex = 0 ; tokenIndex < tokensLength ; tokenIndex ++ ) { uint256 amountRemaining = tokens . amountToGive [ tokenIndex ] ; uint256 amountObtained = 0 ; while ( orderIndex < ordersLength ) { require ( tokens . tokenAddresses [ tokenIndex ] == orders . tokenForOrder [ orderIndex ] ) ; require ( handlerWhitelist [ orders . exchanges [ orderIndex ] ] ) ; if ( amountRemaining > 0 ) { if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { require ( etherBalance >= amountRemaining ) ; } ( amountRemaining , amountObtained ) = performTrade ( tokens . buyOrSell [ tokenIndex ] , amountRemaining , amountObtained , orders , orderIndex ) ; } orderIndex = SafeMath . add ( orderIndex , 1 ) ; if ( orderIndex == ordersLength || orders . tokenForOrder [ SafeMath . sub ( orderIndex , 1 ) ] != orders . tokenForOrder [ orderIndex ] ) { break ; } } uint256 amountGiven = SafeMath . sub ( tokens . amountToGive [ tokenIndex ] , amountRemaining ) ; require ( orderWasValid ( amountObtained , amountGiven , tokens . amountToObtain [ tokenIndex ] , tokens . amountToGive [ tokenIndex ] ) ) ; if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { etherBalance = SafeMath . sub ( etherBalance , amountGiven ) ; if ( amountObtained > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountObtained ) ) ; } } else { etherBalance = SafeMath . add ( etherBalance , amountObtained ) ; if ( amountRemaining > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountRemaining ) ) ; } } } if ( etherBalance > 0 ) { msg . sender . transfer ( etherBalance ) ; } }
function isOps ( address _address ) internal view returns ( bool ) { return ( opsAddress != address ( 0 ) && _address == opsAddress ) || isOwner ( _address ) ; }
function pushDividendPaymentToAddresses ( uint256 _dividendIndex , address [ ] _payees ) public withPerm ( DISTRIBUTE ) validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; for ( uint256 i = 0 ; i < _payees . length ; i ++ ) { if ( ( ! dividend . claimed [ _payees [ i ] ] ) && ( ! dividend . dividendExcluded [ _payees [ i ] ] ) ) { _payDividend ( _payees [ i ] , dividend , _dividendIndex ) ; } } }
function acceptOwnership ( ) { require ( msg . sender == newOwner ) ; OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; }
function whitelistUserForTransfers ( address _user ) onlyOwner public { require ( ! isUserAllowedToTransfer ( _user ) ) ; transfersWhitelist [ _user ] = true ; UserAllowedToTransfer ( _user ) ; }
function setClaimDividendPercentage ( uint256 _claimDividendPercentage ) external onlyCFO { require ( 10000 <= _claimDividendPercentage && _claimDividendPercentage <= 100000 ) ; claimDividendPercentage = _claimDividendPercentage ; }
function initializeTokenSale ( uint _saleStartTime , uint _saleEndTime , uint _price , uint _amountForSale , address _beneficiary ) public ownerOnly { initializeSale ( _saleStartTime , _saleEndTime , _price , _amountForSale , _beneficiary ) ; }
function offerToChannels ( uint256 _venAmount ) onlyOwner { Stage stg = stage ( ) ; require ( stg == Stage . Early || stg == Stage . Normal || stg == Stage . Closed ) ; channelsSold = channelsSold . add ( _venAmount ) ; require ( channelsSold <= channelsLimit ) ; ven . mint ( venVault , _venAmount , true ) ; onSold ( venVault , _venAmount , 0 ) ; }
function _supportsERC165Interface ( address account , bytes4 interfaceId ) private view returns ( bool ) { ( bool success , bool result ) = _callERC165SupportsInterface ( account , interfaceId ) ; return ( success && result ) ; }
function requestMortgageId ( Engine engine , LandMarket landMarket , uint256 loanId , uint256 deposit , uint256 landId , TokenConverter tokenConverter ) public returns ( uint256 id ) { require ( engine . getCurrency ( loanId ) == MANA_CURRENCY , "Loan currency is not MANA" ) ; address borrower = engine . getBorrower ( loanId ) ; require ( engines [ engine ] , "Engine not authorized" ) ; require ( engine . getStatus ( loanId ) == Engine . Status . initial , "Loan status is not inital" ) ; require ( msg . sender == borrower || ( msg . sender == engine . getCreator ( loanId ) && creators [ msg . sender ] ) , "Creator should be borrower or authorized" ) ; require ( engine . isApproved ( loanId ) , "Loan is not approved" ) ; require ( rcn . allowance ( borrower , this ) >= REQUIRED_ALLOWANCE , "Manager cannot handle borrower's funds" ) ; require ( tokenConverter != address ( 0 ) , "Token converter not defined" ) ; require ( loanToLiability [ engine ] [ loanId ] == 0 , "Liability for loan already exists" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 loanAmount = engine . getAmount ( loanId ) ; require ( loanAmount + deposit >= landCost , "Not enought total amount" ) ; require ( mana . transferFrom ( msg . sender , this , deposit ) , "Error pulling mana" ) ; id = mortgages . push ( Mortgage ( { owner : borrower , engine : engine , loanId : loanId , deposit : deposit , landMarket : landMarket , landId : landId , landCost : landCost , status : Status . Pending , tokenConverter : tokenConverter } ) ) - 1 ; loanToLiability [ engine ] [ loanId ] = id ; emit RequestedMortgage ( { _id : id , _borrower : borrower , _engine : engine , _loanId : loanId , _landMarket : landMarket , _landId : landId , _deposit : deposit , _tokenConverter : tokenConverter } ) ; }
function register ( address _darknodeID , bytes _publicKey , uint256 _bond ) external onlyRefunded ( _darknodeID ) { require ( _bond >= minimumBond , "insufficient bond" ) ; require ( ren . transferFrom ( msg . sender , address ( this ) , _bond ) , "bond transfer failed" ) ; ren . transfer ( address ( store ) , _bond ) ; store . appendDarknode ( _darknodeID , msg . sender , _bond , _publicKey , currentEpoch . blocknumber + minimumEpochInterval , 0 ) ; numDarknodesNextEpoch += 1 ; emit LogDarknodeRegistered ( _darknodeID , _bond ) ; }
function createEscrow ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint32 _paymentWindowInSeconds , uint32 _expiry , uint8 _v , bytes32 _r , bytes32 _s ) payable external { bytes32 _tradeHash = keccak256 ( abi . encodePacked ( _tradeID , _seller , _buyer , _value , _fee ) ) ; require ( ! escrows [ _tradeHash ] . exists , "Trade already exists" ) ; bytes32 _invitationHash = keccak256 ( abi . encodePacked ( _tradeHash , _paymentWindowInSeconds , _expiry ) ) ; require ( recoverAddress ( _invitationHash , _v , _r , _s ) == relayer , "Must be relayer" ) ; require ( block . timestamp < _expiry , "Signature has expired" ) ; require ( msg . value == _value && msg . value > 0 , "Incorrect ether sent" ) ; uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0 ? 1 : uint32 ( block . timestamp ) + _paymentWindowInSeconds ; escrows [ _tradeHash ] = Escrow ( true , _sellerCanCancelAfter , 0 ) ; emit Created ( _tradeHash ) ; }
function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _amount ) ; Approve ( msg . sender , _spender , _amount ) ; return true ; }
function ( ) public payable { deposit ( msg . sender ) ; }
function getClaim ( address issuer , address subject , bytes32 key ) public view returns ( bytes32 ) { if ( hasRole ( issuer , ROLE_ISSUER ) ) { return claims [ subject ] [ key ] . hash ; } else { return bytes32 ( 0 ) ; } }
function balanceBlocksIn ( address account , uint256 startBlock , uint256 endBlock ) public view returns ( uint256 ) { require ( startBlock < endBlock ) ; require ( account != address ( 0 ) ) ; if ( balanceBlockNumbers [ account ] . length == 0 || endBlock < balanceBlockNumbers [ account ] [ 0 ] ) return 0 ; uint256 i = 0 ; while ( i < balanceBlockNumbers [ account ] . length && balanceBlockNumbers [ account ] [ i ] < startBlock ) i ++ ; uint256 r ; if ( i >= balanceBlockNumbers [ account ] . length ) r = balances [ account ] [ balanceBlockNumbers [ account ] . length - 1 ] . mul ( endBlock . sub ( startBlock ) ) ; else { uint256 l = ( i == 0 ) ? startBlock : balanceBlockNumbers [ account ] [ i - 1 ] ; uint256 h = balanceBlockNumbers [ account ] [ i ] ; if ( h > endBlock ) h = endBlock ; h = h . sub ( startBlock ) ; r = ( h == 0 ) ? 0 : balanceBlocks [ account ] [ i ] . mul ( h ) . div ( balanceBlockNumbers [ account ] [ i ] . sub ( l ) ) ; i ++ ; while ( i < balanceBlockNumbers [ account ] . length && balanceBlockNumbers [ account ] [ i ] < endBlock ) { r = r . add ( balanceBlocks [ account ] [ i ] ) ; i ++ ; } if ( i >= balanceBlockNumbers [ account ] . length ) r = r . add ( balances [ account ] [ balanceBlockNumbers [ account ] . length - 1 ] . mul ( endBlock . sub ( balanceBlockNumbers [ account ] [ balanceBlockNumbers [ account ] . length - 1 ] ) ) ) ; else if ( balanceBlockNumbers [ account ] [ i - 1 ] < endBlock ) r = r . add ( balanceBlocks [ account ] [ i ] . mul ( endBlock . sub ( balanceBlockNumbers [ account ] [ i - 1 ] ) ) . div ( balanceBlockNumbers [ account ] [ i ] . sub ( balanceBlockNumbers [ account ] [ i - 1 ] ) ) ) ; } return r ; }
function setSymbol ( string _symbol ) onlyAccountAddressForSponsee { symbol = _symbol ; LogSetSymbol ( _symbol ) ; }
function addToWhitelist ( address _sender , uint256 _plannedContribution ) public onlyOwner { require ( whitelist [ _sender ] == 0 ) ; whitelist [ _sender ] = _plannedContribution ; whitelistedPlannedContributions = whitelistedPlannedContributions . add ( _plannedContribution ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; assert ( c >= a ) ; return c ; }
function pricesAreStale ( ) public view returns ( bool ) { return lastPriceUpdateTime . add ( priceStalePeriod ) < now ; }
function createGame ( bytes32 _endHash ) public payable onlyValidValue onlyValidHouseStake ( activeGames + 1 ) onlyNotPaused { address playerAddress = msg . sender ; uint previousGameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ previousGameId ] ; require ( game . status == GameStatus . ENDED ) ; uint gameId = gameIdCntr ++ ; playerGameId [ playerAddress ] = gameId ; Game storage newGame = gameIdGame [ gameId ] ; newGame . stake = msg . value ; newGame . status = GameStatus . WAITING_FOR_SERVER ; activeGames = activeGames + 1 ; LogGameCreated ( playerAddress , gameId , msg . value , _endHash ) ; }
function execScript ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { require ( _blacklist . length == 0 ) ; require ( _script . length == SCRIPT_START_LOCATION + 20 ) ; return delegate ( _script . addressAt ( SCRIPT_START_LOCATION ) , _input ) ; }
function changeHatchEscapeCaller ( address _newEscapeHatchCaller ) public onlyEscapeHatchCallerOrOwner { escapeHatchCaller = _newEscapeHatchCaller ; }
function setODEMClaim ( address subject , bytes32 key , bytes uri , bytes32 hash ) public onlyRole ( ROLE_ISSUER ) { address resolved = resolveAddress ( subject ) ; claims [ resolved ] [ key ] . uri = uri ; claims [ resolved ] [ key ] . hash = hash ; hasClaims [ resolved ] = true ; emit ClaimSet ( msg . sender , subject , key , hash , now ) ; }
function isAdmin ( address _address ) public view returns ( bool ) { if ( _address == owner ( ) ) { return true ; } return admins [ _address ] ; }
function setExchangeRate ( uint256 _sellExchangeRate , uint256 _buyExchangeRate ) onlyOwner public { sellExchangeRate = _sellExchangeRate ; buyExchangeRate = _buyExchangeRate ; }
function authorizePayment ( bytes32 _ref , address _dest , uint _amount ) public onlyLiquidPledging returns ( uint ) { uint idPayment = payments . length ; payments . length ++ ; payments [ idPayment ] . state = PaymentStatus . Pending ; payments [ idPayment ] . ref = _ref ; payments [ idPayment ] . dest = _dest ; payments [ idPayment ] . amount = _amount ; AuthorizePayment ( idPayment , _ref , _dest , _amount ) ; if ( autoPay ) { doConfirmPayment ( idPayment ) ; } return idPayment ; }
function reclaimTokenOwnership ( ) onlyOwner public { token . claimOwnership ( ) ; }
function transferAndCall ( address _to , uint256 _value , bytes _data ) public returns ( bool ) ;
function transferProfitToHouse ( ) public { require ( lastProfitTransferTimestamp + profitTransferTimeSpan <= block . timestamp ) ; if ( houseProfit <= 0 ) { lastProfitTransferTimestamp = block . timestamp ; return ; } uint toTransfer = uint ( houseProfit ) ; assert ( houseStake >= toTransfer ) ; houseProfit = 0 ; lastProfitTransferTimestamp = block . timestamp ; houseStake = houseStake - toTransfer ; houseAddress . transfer ( toTransfer ) ; }
function addProject ( string name , string url , address projectAdmin , uint64 parentProject , uint64 commitTime , ILiquidPledgingPlugin plugin ) returns ( uint64 idProject ) { require ( isValidPlugin ( plugin ) ) ; if ( parentProject != 0 ) { PledgeAdmin storage pa = findAdmin ( parentProject ) ; require ( pa . adminType == PledgeAdminType . Project ) ; require ( getProjectLevel ( pa ) < MAX_SUBPROJECT_LEVEL ) ; } idProject = uint64 ( admins . length ) ; admins . push ( PledgeAdmin ( PledgeAdminType . Project , projectAdmin , name , url , commitTime , parentProject , false , plugin ) ) ; ProjectAdded ( idProject ) ; }
function approve ( address spender , uint quantity ) public pausableIfNotSelfDestructing returns ( bool ) { require ( spender != address ( 0 ) , "Approvals for 0x0 disallowed." ) ; allowance [ msg . sender ] [ spender ] = quantity ; emit Approval ( msg . sender , spender , quantity ) ; return true ; }
function preAllocate ( address _to , uint256 _value , uint256 _price ) onlyOwner { require ( block . timestamp < START_DATE ) ; balances [ this ] = safeSub ( balances [ this ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; soldAmount = safeAdd ( soldAmount , _value ) ; paidAmount = safeAdd ( paidAmount , _price ) ; Transfer ( this , _to , _value ) ; }
function totalSupply ( ) public view returns ( uint256 ) { return erc20Impl . totalSupply ( ) ; }
function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 3 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 6 ) ) ) { require ( collectedTokens < total . percent ( 25 ) ) ; canExtract = total . percent ( 25 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 6 ) ) && getTime ( ) <= finalizedTime . add ( months ( 9 ) ) ) { require ( collectedTokens < total . percent ( 50 ) ) ; canExtract = total . percent ( 50 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 9 ) ) && getTime ( ) <= finalizedTime . add ( months ( 12 ) ) ) { require ( collectedTokens < total . percent ( 75 ) ) ; canExtract = total . percent ( 75 ) ; } else { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( ( totalDistributed == hardCap || now > SaleDeadline ) && state != State . Successful && state != State . Paused ) { pending [ creator ] = tokenReward . balanceOf ( address ( this ) ) . sub ( totalDistributed ) ; state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } }
function extractAddress ( bytes data , uint offset ) internal pure returns ( address m ) { require ( offset >= 0 && offset + 20 <= data . length , "offset value should be in the correct range" ) ; assembly { m := and ( mload ( add ( data , add ( 20 , offset ) ) ) , 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) } }
function setNonlistedUser ( address _who ) public onlyValidator { _setNonlistedUser ( _who ) ; }
function revealVote ( uint _pollID , uint _voteOption , uint _salt ) public { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( abi . encodePacked ( _voteOption , _salt ) ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; pollMap [ _pollID ] . voteOptions [ msg . sender ] = _voteOption ; emit _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender , _salt ) ; }
function createMarket ( string question , uint32 timeout , uint32 opening_ts , address asker , uint256 nonce , address designated_reporter ) onlyInitialized external payable { bytes32 question_id = keccak256 ( keccak256 ( template_id , opening_ts , question ) , this , timeout , asker , nonce ) ; require ( realitio_questions [ question_id ] . bounty > 0 , "Arbitration must have been requested (paid for)" ) ; require ( realitio_questions [ question_id ] . augur_market == IMarket ( 0x0 ) , "The market must not have been created yet" ) ; _callAugurMarketCreate ( question_id , question , designated_reporter ) ; }
function registerEOSAddress ( string eosAddress ) public { assert ( bytes ( eosAddress ) . length <= 64 ) ; eosAddressBook [ msg . sender ] = eosAddress ; emit LogRegisterEOSAddress ( msg . sender , eosAddress ) ; }
function pauseIssuance ( ) public onlyOwner whenNotPaused whenIssuanceNotPaused { _issuancePaused = true ; emit IssuancePaused ( ) ; }
function startTokenVotes ( address [ 15 ] tokens ) public onlyAdmins { uint _proposalId = tokenBatches . length ; if ( _proposalId > 0 ) { TokenProposal memory op = tokenBatches [ _proposalId - 1 ] ; DestructibleMiniMeToken ( op . votingToken ) . recycle ( ) ; } tokenBatches . length ++ ; TokenProposal storage p = tokenBatches [ _proposalId ] ; p . duration = VOTING_DURATION * ( 1 days ) ; p . consideredTokens = tokens ; p . votingToken = tokenFactory . createDestructibleCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( "EfxTokenVotes-" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( "EfxTokenVotes-" , _proposalId ) , true ) ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; emit NewTokens ( _proposalId ) ; }
function isGroupInPolicy ( bytes32 _policyHash , bytes32 _groupName ) public view returns ( bool ) { Policy storage _policy = policyId2policy [ _policyHash ] ; return _policy . groupName2index [ _groupName ] != 0 ; }
function _balanceOf ( uint _holderId , bytes32 _symbol ) public view returns ( uint ) { return assets [ _symbol ] . wallets [ _holderId ] . balance ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) ;
function depositEther ( ) external payable onlyActiveState { require ( msg . value > 0 , 'Invalid value' ) ; balances [ msg . sender ] [ etherAddr ] = balances [ msg . sender ] [ etherAddr ] . add ( msg . value ) ; emit BalanceIncrease ( msg . sender , etherAddr , msg . value , ReasonDeposit ) ; }
function approveAll ( address _to ) public { require ( _to != msg . sender , "cant approve yourself" ) ; require ( _to != address ( 0 ) , "invalid owner" ) ; operatorApprovals [ msg . sender ] [ _to ] = true ; emit ApprovalForAll ( msg . sender , _to , true ) ; }
function _changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) internal { perms [ _module ] [ _delegate ] [ _perm ] = _valid ; emit ChangePermission ( _delegate , _module , _perm , _valid , now ) ; }
function decreaseApproval ( address _spender , uint256 _subtractedValue ) public returns ( bool ) { require ( ! freezeTransfer || isOps ( ) , "all transfers are currently frozen" ) ; require ( _spender != address ( 0 ) , "zero address is not allowed" ) ; require ( _subtractedValue >= 1000 , "must approve more than 1000 sip" ) ; uint256 oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }
function setRegisteredAuthority ( string firmName , address authority , bool _authorized ) public onlyAuthority ( firmName , msg . sender ) returns ( bool success ) { require ( lib . setRegisteredAuthority ( firmName , authority , _authorized ) , "Error: Failed to register authority for issuer firm with storage contract! Please check your arguments and ensure firmName is registered before allowing an authority of said firm" ) ; return true ; }
function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) { uint256 discount = 0 ; if ( _etherAmount > minDiscountEther && _etherAmount <= firstTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( FIRST_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > firstTierDiscountUpperLimitEther && _etherAmount <= secondTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( SECOND_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > secondTierDiscountUpperLimitEther && _etherAmount <= thirdTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( THIRD_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > thirdTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( FOURTH_TIER_DISCOUNT ) . div ( 100 ) ; } DiscountApplied ( _etherAmount , _contributorTokens , discount ) ; return discount . add ( _contributorTokens ) ; }
function _transferFrom ( address _from , address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _approvedFor ( _to , _tokenId ) ) ; ethernautsStorage . transfer ( _from , _to , _tokenId ) ; }
function getEndDate ( Campaign storage _campaign ) internal view returns ( uint _endDate ) { return _campaign . endDate ; }
function transfer ( address _to , uint256 _tokenId ) external whenNotPaused onlyOwnerOf ( _tokenId ) { _clearApprovalAndTransfer ( msg . sender , _to , _tokenId ) ; }
function allBalancesOf ( address owner ) external constant returns ( uint256 [ 2 ] [ ] ) { Values [ ] storage values = _balances [ owner ] ; uint256 [ 2 ] [ ] memory balances = new uint256 [ 2 ] [ ] ( values . length ) ; for ( uint256 ii = 0 ; ii < values . length ; ++ ii ) { balances [ ii ] = [ values [ ii ] . snapshotId , values [ ii ] . value ] ; } return balances ; }
function _addTicker ( address _owner , string _ticker , string _tokenName , uint256 _registrationDate , uint256 _expiryDate , bool _status , bool _fromAdmin , uint256 _fee ) internal { _setTickerOwnership ( _owner , _ticker ) ; _storeTickerDetails ( _ticker , _owner , _registrationDate , _expiryDate , _tokenName , _status ) ; emit RegisterTicker ( _owner , _ticker , _tokenName , _registrationDate , _expiryDate , _fromAdmin , _fee ) ; }
function addPartOwner ( address _partowner ) external onlyContractOwner returns ( uint ) { partowners [ _partowner ] = true ; return OK ; }
function numberOfProposals ( ) public view returns ( uint ) { return tokenBatches . length ; }
function setPaymentStatus ( uint256 _paymentId , bool _active ) external authP ( MANAGE_PAYMENTS_ROLE , arr ( _paymentId , uint256 ( _active ? 1 : 0 ) ) ) paymentExists ( _paymentId ) { payments [ _paymentId ] . inactive = ! _active ; emit ChangePaymentState ( _paymentId , _active ) ; }
function addSupplier ( SupplierInterface supplier , bool add ) public onlyAdmin { if ( add ) { require ( ! isSupplier [ supplier ] ) ; suppliers . push ( supplier ) ; isSupplier [ supplier ] = true ; emit AddSupplier ( supplier , true ) ; } else { isSupplier [ supplier ] = false ; for ( uint i = 0 ; i < suppliers . length ; i ++ ) { if ( suppliers [ i ] == supplier ) { suppliers [ i ] = suppliers [ suppliers . length - 1 ] ; suppliers . length -- ; emit AddSupplier ( supplier , false ) ; break ; } } } }
function setFxBpsRate ( string currency , uint bpsRate , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setFxUSDBPSRate ( currency , bpsRate ) , "Error: Unable to set FX USD basis points rate. Please ensure issuerFirm is authorized" ) ; return true ; }
function releaseForeignToken ( ERC20 _token , uint256 amount ) onlyOwner public { require ( _token != token ) ; _token . transfer ( owner , amount ) ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address _owner ) { return IndexToOwner [ _tokenId ] ; }
function getFeeMin ( Data storage self , address contractAddress ) internal view returns ( uint feeMin ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.min' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }
function pauseGame ( uint256 _gameID , bool _paused ) external isActivated ( _gameID ) isOngoing ( _gameID ) isOwner ( ) { game_ [ _gameID ] . paused = _paused ; emit onGamePaused ( _gameID , _paused , now ) ; }
function hasRole ( address addr , string role ) public view returns ( bool ) { return roles [ addr ] [ role ] ; }
function withdrawPendingAmounts ( ) returns ( bool ) ;
function calculatePrice ( uint [ ] _pickedAssets , address _owner ) public view returns ( uint ) { if ( _pickedAssets . length == 0 ) { return 0 ; } uint [ ] memory pickedAssetPacks = assetManager . pickUniquePacks ( _pickedAssets ) ; uint finalPrice = 0 ; for ( uint i = 0 ; i < pickedAssetPacks . length ; i ++ ) { if ( assetManager . checkHasPermissionForPack ( _owner , pickedAssetPacks [ i ] ) == false ) { finalPrice += assetManager . getAssetPackPrice ( pickedAssetPacks [ i ] ) ; } } return finalPrice ; }
function getAccountSpendingPeriod ( Data storage self , address account ) internal view returns ( uint period ) { bytes32 id = keccak256 ( abi . encodePacked ( 'limit.spending.period' , account ) ) ; return self . Storage . getUint ( id ) ; }
function releaseTransfer ( bytes32 sha , uint8 v , bytes32 r , bytes32 s ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; bytes32 transferFromSha = keccak256 ( "transferFrom" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; bytes32 transferSha = keccak256 ( "transfer" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; require ( sha == transferSha || sha == transferFromSha ) ; require ( verify ( sha , v , r , s ) == true ) ; if ( transferFromSha == sha ) { address _spender = biometricAllowee [ sha ] ; address _from = biometricFrom [ sha ] ; address _to = biometricTo [ sha ] ; uint256 _value = biometricAmount [ sha ] ; require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ _spender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; } if ( transferSha == sha ) { super . transfer ( biometricTo [ sha ] , biometricAmount [ sha ] ) ; } biometricCompleted [ sha ] = true ; return true ; }
function private_list_bytes_from_bytes ( bytes32 _current_item , uint256 _count , bool _including_current , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next ) private constant returns ( bytes32 [ ] _bytes32_items ) { uint256 _i ; uint256 _real_count = 0 ; bytes32 _last_item ; _last_item = _function_last ( ) ; if ( _count == 0 || _last_item == bytes32 ( 0x0 ) ) { _bytes32_items = new bytes32 [ ] ( 0 ) ; } else { bytes32 [ ] memory _items_temp = new bytes32 [ ] ( _count ) ; bytes32 _this_item ; if ( _including_current == true ) { _items_temp [ 0 ] = _current_item ; _real_count = 1 ; } _this_item = _current_item ; for ( _i = _real_count ; ( _i < _count ) && ( _this_item != _last_item ) ; _i ++ ) { _this_item = _function_next ( _this_item ) ; if ( _this_item != bytes32 ( 0x0 ) ) { _real_count ++ ; _items_temp [ _i ] = _this_item ; } } _bytes32_items = new bytes32 [ ] ( _real_count ) ; for ( _i = 0 ; _i < _real_count ; _i ++ ) { _bytes32_items [ _i ] = _items_temp [ _i ] ; } } }
function deedOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < countOfDeedsByOwner ( _owner ) ) ; uint256 seen = 0 ; uint256 totalDeeds = countOfDeeds ( ) ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = identifiers [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { if ( seen == _index ) { return identifier ; } seen ++ ; } } }
function createAndJoinCDP ( ) public stoppable payable returns ( bytes32 id ) { require ( msg . value >= minETH ) ; gem . deposit . value ( msg . value ) ( ) ; id = _openAndJoinCDPWETH ( msg . value ) ; tub . give ( id , msg . sender ) ; }
function calculateGrantClaim ( address _recipient ) public view returns ( uint16 , uint128 ) { Grant storage tokenGrant = tokenGrants [ _recipient ] ; if ( now < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint elapsedTime = sub ( now , tokenGrant . startTime ) ; uint elapsedMonths = elapsedTime / SECONDS_PER_MONTH ; if ( elapsedMonths < tokenGrant . vestingCliff ) { return ( 0 , 0 ) ; } if ( elapsedMonths >= tokenGrant . vestingDuration ) { uint128 remainingGrant = tokenGrant . amount - tokenGrant . totalClaimed ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint16 monthsVested = uint16 ( sub ( elapsedMonths , tokenGrant . monthsClaimed ) ) ; uint amountVestedPerMonth = tokenGrant . amount / tokenGrant . vestingDuration ; uint128 amountVested = uint128 ( mul ( monthsVested , amountVestedPerMonth ) ) ; return ( monthsVested , amountVested ) ; } }
function finalize ( ) public onlyOwner initialized { require ( time ( ) >= startTime ) ; require ( finalizedBlock == 0 ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; uint256 tokensToSecondRound = 90000000 ether ; uint256 tokensToReserve = 90000000 ether ; uint256 tokensToAngelAndOther = 30000000 ether ; tokensToSecondRound = tokensToSecondRound . add ( maxFirstRoundTokenLimit ) . sub ( totalNormalTokenGenerated ) ; tokensToSecondRound = tokensToSecondRound . add ( maxIssueTokenLimit ) . sub ( totalIssueTokenGenerated ) ; uint256 totalTokens = 300000000 ether ; require ( totalTokens == ATT . totalSupply ( ) . add ( tokensToSecondRound ) . add ( tokensToReserve ) . add ( tokensToAngelAndOther ) ) ; assert ( ATT . generateTokens ( 0xb1 , tokensToSecondRound ) ) ; assert ( ATT . generateTokens ( 0xb2 , tokensToReserve ) ) ; assert ( ATT . generateTokens ( destTokensAngel , tokensToAngelAndOther ) ) ; ATT . changeController ( attController ) ; Finalized ( ) ; }
function setCommissionRate ( uint256 commissionRateInWei ) isOwner { require ( commissionRateInWei >= 0 ) ; commissionRate = commissionRateInWei ; }
function submitAnswer ( bytes32 question_id , bytes32 answer , uint256 max_previous ) stateOpen ( question_id ) bondMustDouble ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external payable { _addAnswerToHistory ( question_id , answer , msg . sender , msg . value , false ) ; _updateCurrentAnswer ( question_id , answer , questions [ question_id ] . timeout ) ; }
function revoke ( bytes32 _key ) external returns ( uint ) { return _revoke ( _key , msg . sender ) ; }
function approve ( address _spender , uint256 _value ) public userNotBlacklisted ( _spender ) userNotBlacklisted ( msg . sender ) whenNotPaused whenUnlocked returns ( bool ) { tokenStorage . setAllowance ( msg . sender , _spender , _value ) ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
function withdraw ( uint256 _gameID ) external isHuman ( ) isActivated ( _gameID ) isEnded ( _gameID ) { require ( now < game_ [ _gameID ] . withdrawDeadline , "withdraw deadline already passed" ) ; require ( gameStatus_ [ _gameID ] . fundCleared == false , "fund already cleared" ) ; uint256 _pID = FSBook . pIDxAddr_ ( msg . sender ) ; require ( _pID != 0 , "player has not played this game" ) ; require ( players_ [ _pID ] [ _gameID ] . withdrawn == false , "player already cashed out" ) ; players_ [ _pID ] [ _gameID ] . withdrawn = true ; if ( game_ [ _gameID ] . canceled ) { uint256 _totalInvestment = players_ [ _pID ] [ _gameID ] . eth . mul ( 95 ) / 100 ; if ( _totalInvestment > 0 ) { FSBook . getPlayerAddr ( _pID ) . transfer ( _totalInvestment ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalInvestment . add ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; } emit FSEvents . onWithdraw ( _gameID , _pID , msg . sender , FSBook . getPlayerName ( _pID ) , _totalInvestment , now ) ; } else { uint256 _totalWinnings = getPlayerInstWinning ( _gameID , _pID , game_ [ _gameID ] . winnerTeam ) . add ( getPlayerPotWinning ( _gameID , _pID , game_ [ _gameID ] . winnerTeam ) ) ; if ( _totalWinnings > 0 ) { FSBook . getPlayerAddr ( _pID ) . transfer ( _totalWinnings ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalWinnings . add ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; } emit FSEvents . onWithdraw ( _gameID , _pID , msg . sender , FSBook . getPlayerName ( _pID ) , _totalWinnings , now ) ; } }
function getFinalizeTS ( bytes32 question_id ) public view returns ( uint32 ) { return questions [ question_id ] . finalize_ts ; }
function isOwner ( address _address ) internal view returns ( bool ) { return ( _address == owner ) ; }
function setNextGameSettings ( uint256 rows , uint256 cols , uint256 initialActivityTimer , uint256 finalActivityTimer , uint256 numberOfFlipsToFinalActivityTimer , uint256 timeoutBonusTime , uint256 unclaimedTilePrice , uint256 buyoutReferralBonusPercentage , uint256 firstBuyoutPrizePoolPercentage , uint256 buyoutPrizePoolPercentage , uint256 buyoutDividendPercentage , uint256 buyoutFeePercentage , uint256 buyoutPriceIncreasePercentage ) public onlyCFO { require ( 2000 <= buyoutDividendPercentage && buyoutDividendPercentage <= 12500 ) ; require ( buyoutFeePercentage <= 5000 ) ; if ( numberOfFlipsToFinalActivityTimer == 0 ) { require ( initialActivityTimer == finalActivityTimer ) ; } nextGameSettings = GameSettings ( { rows : rows , cols : cols , initialActivityTimer : initialActivityTimer , finalActivityTimer : finalActivityTimer , numberOfFlipsToFinalActivityTimer : numberOfFlipsToFinalActivityTimer , timeoutBonusTime : timeoutBonusTime , unclaimedTilePrice : unclaimedTilePrice , buyoutReferralBonusPercentage : buyoutReferralBonusPercentage , firstBuyoutPrizePoolPercentage : firstBuyoutPrizePoolPercentage , buyoutPrizePoolPercentage : buyoutPrizePoolPercentage , buyoutDividendPercentage : buyoutDividendPercentage , buyoutFeePercentage : buyoutFeePercentage , buyoutPriceIncreasePercentage : buyoutPriceIncreasePercentage } ) ; NextGame ( rows , cols , initialActivityTimer , finalActivityTimer , numberOfFlipsToFinalActivityTimer , timeoutBonusTime , unclaimedTilePrice , buyoutReferralBonusPercentage , firstBuyoutPrizePoolPercentage , buyoutPrizePoolPercentage , buyoutDividendPercentage , buyoutFeePercentage , buyoutPriceIncreasePercentage ) ; }
function cancelQuery ( uint256 id ) external { address subscriber = getSubscriber ( id ) ; address provider = getProvider ( id ) ; bytes32 endpoint = getEndpoint ( id ) ; require ( subscriber == msg . sender , "Error: Wrong subscriber" ) ; require ( Status ( getStatus ( id ) ) == Status . Pending , "Error: Query is not pending" ) ; setCanceled ( id , true ) ; bondage . returnDots ( subscriber , provider , endpoint , 1 ) ; emit CanceledRequest ( id , getSubscriber ( id ) , getProvider ( id ) ) ; }
function investors ( uint256 _index ) external view returns ( address ) ;
function proxyPayment ( address _owner ) payable returns ( bool ) { doPayment ( _owner ) ; return true ; }
function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { bytes32 hash = sha256 ( abi . encodePacked ( address ( exchange ) , data . takerToken , data . takerAmount , data . makerToken , data . makerAmount , data . expires , data . nonce ) ) ; if ( ecrecover ( sha3 ( abi . encodePacked ( "\x19Ethereum Signed Message:\n32" , hash ) ) , data . v , data . r , data . s ) != data . user || block . number > data . expires ) { return false ; } return true ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "Error: Unsafe multiplication operation!" ) ; return c ; }
function updateLandData ( uint256 id , string data ) external returns ( bool ) { require ( _isAuthorized ( msg . sender , id ) , "Sender not authorized" ) ; ( int256 x , int256 y ) = land . decodeTokenId ( mortgages [ id ] . landId ) ; land . updateLandData ( x , y , data ) ; emit UpdatedLandData ( msg . sender , id , data ) ; return true ; }
function setCampaignBudgetById ( bytes32 bidId , uint newBudget ) public onlyIfCampaignExists ( "setCampaignBudgetById" , bidId ) onlyIfWhitelisted ( "setCampaignBudgetById" , msg . sender ) { campaigns [ bidId ] . setBudget ( newBudget ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
function earlySafeWithdrawal ( uint256 _amount ) public onlyOwner { require ( fundingGoalReached , "funding goal has not been reached" ) ; require ( beneficiary == msg . sender , "message sender is not the beneficiary" ) ; require ( address ( this ) . balance >= _amount , "contract has less ether in balance than requested" ) ; beneficiary . transfer ( _amount ) ; emit FundsWithdrawal ( beneficiary , _amount ) ; }
function setBool ( bytes32 _key , bool _value ) public onlyOwner returns ( bool success ) { boolStorage [ _key ] = _value ; return true ; }
function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return _operator == _tokenHolder || mAuthorized [ _operator ] [ _tokenHolder ] ; }
function setCreator ( address creator , bool authorized ) external onlyOwner returns ( bool ) { emit SetCreator ( creator , authorized ) ; creators [ creator ] = authorized ; return true ; }
function _revokeAttribute ( address account ) internal returns ( bool ) { _jurisdiction . revokeAttribute ( account , _validAttributeTypeID ) ; return true ; }
function addBalance ( address _owner , uint256 _balanceIncrease ) public onlyImpl { balances [ _owner ] = balances [ _owner ] + _balanceIncrease ; }
function isPresent ( bytes32 channelId ) public view returns ( bool ) { return ! isAbsent ( channelId ) ; }
function getChannelInfo ( address _sender_address , address _receiver_address , uint32 _open_block_number ) external view returns ( bytes32 , uint192 , uint32 , uint192 , uint192 ) { bytes32 key = getKey ( _sender_address , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > 0 ) ; return ( key , channels [ key ] . deposit , closing_requests [ key ] . settle_block_number , closing_requests [ key ] . closing_balance , withdrawn_balances [ key ] ) ; }
function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 9412000000 ; }
function uint8Min ( uint8 a , uint8 b ) pure internal returns ( uint8 ) { return a > b ? b : a ; }
function symbol ( ) public pure returns ( string _deedSymbol ) { _deedSymbol = "BURN" ; }
function setFeePeriodDuration ( uint _feePeriodDuration ) external optionalProxy_onlyOwner { require ( _feePeriodDuration >= MIN_FEE_PERIOD_DURATION , "New fee period cannot be less than minimum fee period duration" ) ; require ( _feePeriodDuration <= MAX_FEE_PERIOD_DURATION , "New fee period cannot be greater than maximum fee period duration" ) ; feePeriodDuration = _feePeriodDuration ; emitFeePeriodDurationUpdated ( _feePeriodDuration ) ; }
function releaseAllVestedToken ( ) public checkGlobalTokenTransferLock returns ( bool ) { emit AllVestedTokenReleased ( ) ; PeriodicTokenVesting tokenVesting ; for ( uint256 i = 0 ; i < vestedAddresses . length ; i ++ ) { tokenVesting = tokenVestingContracts [ vestedAddresses [ i ] ] ; if ( tokenVesting . releasableAmount ( ERC20 ( address ( this ) ) ) > 0 ) { tokenVesting . release ( ERC20 ( address ( this ) ) ) ; emit VestedTokenReleased ( vestedAddresses [ i ] ) ; } } return true ; }
function setDefaultExcluded ( address [ ] _excluded ) public withPerm ( MANAGE ) { require ( _excluded . length <= EXCLUDED_ADDRESS_LIMIT , "Too many excluded addresses" ) ; for ( uint256 j = 0 ; j < _excluded . length ; j ++ ) { require ( _excluded [ j ] != address ( 0 ) , "Invalid address" ) ; for ( uint256 i = j + 1 ; i < _excluded . length ; i ++ ) { require ( _excluded [ j ] != _excluded [ i ] , "Duplicate exclude address" ) ; } } excluded = _excluded ; emit SetDefaultExcludedAddresses ( excluded , now ) ; }
function tokenURI ( uint256 _tokenId ) external view mustBeValidToken ( _tokenId ) returns ( string _tokenURI ) { _tokenURI = "https://tenthousandsu.com/erc721/00000.json" ; bytes memory _tokenURIBytes = bytes ( _tokenURI ) ; _tokenURIBytes [ 33 ] = byte ( 48 + ( _tokenId / 10000 ) % 10 ) ; _tokenURIBytes [ 34 ] = byte ( 48 + ( _tokenId / 1000 ) % 10 ) ; _tokenURIBytes [ 35 ] = byte ( 48 + ( _tokenId / 100 ) % 10 ) ; _tokenURIBytes [ 36 ] = byte ( 48 + ( _tokenId / 10 ) % 10 ) ; _tokenURIBytes [ 37 ] = byte ( 48 + ( _tokenId / 1 ) % 10 ) ; }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external ;
function fracExp ( uint256 _k , uint256 _q , uint256 _n , uint256 _p ) public pure returns ( uint256 ) { uint256 s = 0 ; uint256 N = 1 ; uint256 B = 1 ; for ( uint256 i = 0 ; i < _p ; ++ i ) { s += _k * N / B / ( _q ** i ) ; N = N * ( _n - i ) ; B = B * ( i + 1 ) ; } return s ; }
function removeListing ( uint64 _pixelconIndex ) public { Listing storage listing = marketPixelconListings [ _pixelconIndex ] ; require ( listing . seller != address ( 0 ) , "Market listing does not exist" ) ; require ( msg . sender == listing . seller || msg . sender == admin , "Insufficient permissions" ) ; uint256 tokenId = pixelconsContract . tokenByIndex ( _pixelconIndex ) ; address seller = listing . seller ; clearListingData ( seller , _pixelconIndex ) ; pixelconsContract . transferFrom ( address ( this ) , seller , tokenId ) ; emit Remove ( _pixelconIndex , msg . sender ) ; }
function enableMigration ( IMigrationTarget migration ) public onlyMigrationEnabledOnce ( ) only ( MIGRATION_ADMIN ) { require ( migration . currentMigrationSource ( ) == address ( this ) ) ; _migration = migration ; LogMigrationEnabled ( _migration ) ; }
function getFirmFromAuthority ( address authority ) public view returns ( string firm ) { return lib . getFirmFromAuthority ( authority ) ; }
function getEndTime ( ) internal constant returns ( uint ) ;
function balanceOf ( address _owner ) public view returns ( uint256 ) { return _balance [ _owner ] ; }
function transfer ( address _to , uint256 _value ) returns ( bool success ) { _transfer ( msg . sender , _to , _value ) ; return true ; }
function getStorageAddress ( ) public view returns ( address storageContract ) { require ( msg . sender == address ( advertisementFinance ) ) ; return address ( advertisementStorage ) ; }
function refund ( ) public returns ( bool ) { return refundTo ( msg . sender ) ; }
function setKyberNetwork ( address _KyberNetwork ) public onlyOperator { KyberNetwork = _KyberNetwork ; }
function withdrawMILs ( uint256 _MILs ) public postEnd funded { uint256 daysSinceEnd = ( now - lockUpEnd ) / 1 days ; uint256 maxPct = min ( ( ( daysSinceEnd / 30 + 1 ) * 25 ) , 100 ) ; uint256 allowed = award [ msg . sender ] ; allowed = allowed * maxPct / 100 ; allowed -= withdrawn [ msg . sender ] ; require ( _MILs <= allowed ) ; militaryToken . transfer ( msg . sender , _MILs ) ; withdrawn [ msg . sender ] += _MILs ; currentAwards -= _MILs ; }
function ableTransfer ( ) ;
function _approveEscrow ( bytes32 _id , uint256 _amount ) internal returns ( bool ) { claimable = claimable . add ( _amount ) ; claimableRewards [ _id ] = _amount ; return true ; }
function getTimeout ( bytes32 question_id ) public view returns ( uint32 ) { }
function uncooperativeClose ( address _receiver_address , uint32 _open_block_number , uint192 _balance ) external { bytes32 key = getKey ( msg . sender , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > 0 ) ; require ( closing_requests [ key ] . settle_block_number == 0 ) ; require ( _balance <= channels [ key ] . deposit ) ; closing_requests [ key ] . settle_block_number = uint32 ( block . number ) + challenge_period ; require ( closing_requests [ key ] . settle_block_number > block . number ) ; closing_requests [ key ] . closing_balance = _balance ; ChannelCloseRequested ( msg . sender , _receiver_address , _open_block_number , _balance ) ; }
function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; cityIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { return false ; }
function getEIN ( address _address ) public view _hasIdentity ( _address , true ) returns ( uint ein ) { return associatedAddressDirectory [ _address ] ; }
function changeTreasury ( address _newTreasury ) external onlyOwner { treasury = _newTreasury ; emit ChangeTreasury ( msg . sender , _newTreasury ) ; }
function ( ) payable public { revert ( ) ; }
function priceIsStale ( ) public view returns ( bool ) { return safeAdd ( lastPriceUpdateTime , priceStalePeriod ) < now ; }
function pause ( ) external whenNotPaused onlyOwner { set ( Encoder . getKey ( "paused" ) , true ) ; emit Pause ( now ) ; }
function buy ( ) public payable nonReentrant timedStateChange requiresState ( IcoState . ICO ) fundsChecker returns ( uint ) { address investor = msg . sender ; uint256 payment = msg . value ; require ( payment >= c_MinInvestment ) ; uint startingInvariant = this . balance . add ( m_funds . balance ) ; uint fundsAllowed = getMaximumFunds ( ) . sub ( m_funds . totalInvested ( ) ) ; assert ( 0 != fundsAllowed ) ; payment = fundsAllowed . min256 ( payment ) ; uint256 change = msg . value . sub ( payment ) ; uint stq = calcSTQAmount ( payment ) ; m_token . mint ( investor , stq ) ; m_funds . invested . value ( payment ) ( investor ) ; FundTransfer ( investor , payment , true ) ; if ( change > 0 ) { assert ( getMaximumFunds ( ) == m_funds . totalInvested ( ) ) ; finishICO ( ) ; investor . transfer ( change ) ; assert ( startingInvariant == this . balance . add ( m_funds . balance ) . add ( change ) ) ; } else assert ( startingInvariant == this . balance . add ( m_funds . balance ) ) ; return stq ; }
function setTrading ( bool status ) public onlyOwner { tradingLive = status ; }
function _internalExchange ( address from , bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey , address destinationAddress , bool chargeFee ) internal notFeeAddress ( from ) returns ( bool ) { require ( destinationAddress != address ( 0 ) , "Zero destination" ) ; require ( destinationAddress != address ( this ) , "Synthetix is invalid destination" ) ; require ( destinationAddress != address ( proxy ) , "Proxy is invalid destination" ) ; synths [ sourceCurrencyKey ] . burn ( from , sourceAmount ) ; uint destinationAmount = effectiveValue ( sourceCurrencyKey , sourceAmount , destinationCurrencyKey ) ; uint amountReceived = destinationAmount ; uint fee = 0 ; if ( chargeFee ) { amountReceived = feePool . amountReceivedFromExchange ( destinationAmount ) ; fee = destinationAmount . sub ( amountReceived ) ; } synths [ destinationCurrencyKey ] . issue ( destinationAddress , amountReceived ) ; if ( fee > 0 ) { uint xdrFeeAmount = effectiveValue ( destinationCurrencyKey , fee , "XDR" ) ; synths [ "XDR" ] . issue ( feePool . FEE_ADDRESS ( ) , xdrFeeAmount ) ; } synths [ destinationCurrencyKey ] . triggerTokenFallbackIfNeeded ( from , destinationAddress , amountReceived ) ; return true ; }
function hasAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; return ( ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) || ( _attributeTypes [ attributeTypeID ] . secondarySource != address ( 0 ) && secondaryHasAttribute ( _attributeTypes [ attributeTypeID ] . secondarySource , account , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID ) ) ) ; }
function removeValidator ( address validator ) external ;
function buy ( ) payable public { uint amount = uint ( msg . value ) / uint ( buyPrice ) ; _transfer ( this , msg . sender , amount * 10 ** uint256 ( decimals ) ) ; }
function getEndTime ( ) public pure returns ( uint ) { return 1521331200 ; }
function withdrawRequest ( address _auditor , bytes32 _codeHash ) public { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; uint8 outcome = SolidStampRegister ( SolidStampRegisterAddress ) . getAuditOutcome ( _auditor , _codeHash ) ; require ( outcome == NOT_AUDITED , "contract already audited" ) ; bytes32 hashAuditorRequestorCode = keccak256 ( abi . encodePacked ( _auditor , msg . sender , _codeHash ) ) ; AuditRequest storage request = AuditRequests [ hashAuditorRequestorCode ] ; require ( request . amount > 0 , "nothing to withdraw" ) ; require ( now > request . expireDate , "cannot withdraw before request.expireDate" ) ; uint amount = request . amount ; delete request . amount ; delete request . expireDate ; Rewards [ hashAuditorCode ] = Rewards [ hashAuditorCode ] . sub ( amount ) ; TotalRequestsAmount = TotalRequestsAmount . sub ( amount ) ; emit RequestWithdrawn ( _auditor , msg . sender , _codeHash , amount ) ; msg . sender . transfer ( amount ) ; }
function transfer ( address _to , uint _tokenId ) whenNotPaused external { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function enableMigration ( IMigrationTarget migration ) public onlyMigrationEnabledOnce ( ) only ( MIGRATION_ADMIN ) { require ( migration . currentMigrationSource ( ) == address ( this ) ) ; _migration = migration ; emit LogMigrationEnabled ( _migration ) ; }
function mint ( address _investor , uint256 _value ) external returns ( bool success ) ;
function upper ( string _base ) internal pure returns ( string ) { bytes memory _baseBytes = bytes ( _base ) ; for ( uint i = 0 ; i < _baseBytes . length ; i ++ ) { bytes1 b1 = _baseBytes [ i ] ; if ( b1 >= 0x61 && b1 <= 0x7A ) { b1 = bytes1 ( uint8 ( b1 ) - 32 ) ; } _baseBytes [ i ] = b1 ; } return string ( _baseBytes ) ; }
function revoke ( address who , address origin ) payable external only_delegate { require ( msg . value == fee ) ; bool found ; for ( uint i = 0 ; i < s_paid [ who ] . length ; i ++ ) { if ( s_paid [ who ] [ i ] != origin ) { continue ; } found = true ; uint last = s_paid [ who ] . length - 1 ; s_paid [ who ] [ i ] = s_paid [ who ] [ last ] ; delete s_paid [ who ] [ last ] ; s_paid [ who ] . length -= 1 ; break ; } require ( found ) ; who . transfer ( msg . value ) ; }
function calcUnclaimedFees ( uint gav ) view returns ( uint managementFee , uint performanceFee , uint unclaimedFees ) { uint timePassed = sub ( now , atLastUnclaimedFeeAllocation . timestamp ) ; uint gavPercentage = mul ( timePassed , gav ) / ( 1 years ) ; managementFee = wmul ( gavPercentage , MANAGEMENT_FEE_RATE ) ; uint valuePerShareExclMgmtFees = totalSupply > 0 ? calcValuePerShare ( sub ( gav , managementFee ) , totalSupply ) : toSmallestShareUnit ( 1 ) ; if ( valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation . highWaterMark ) { uint gainInSharePrice = sub ( valuePerShareExclMgmtFees , atLastUnclaimedFeeAllocation . highWaterMark ) ; uint investmentProfits = wmul ( gainInSharePrice , totalSupply ) ; performanceFee = wmul ( investmentProfits , PERFORMANCE_FEE_RATE ) ; } unclaimedFees = add ( managementFee , performanceFee ) ; }
function allowance ( address tokenOwner , address spender ) constant public returns ( uint coinsRemaining ) { return allowance [ tokenOwner ] [ spender ] ; }
function withdrawFunds ( ) { externalEnter ( ) ; withdrawFundsRP ( ) ; externalLeave ( ) ; }
function transferPreSignedHashing ( address _operator , address _to , address _delegate , uint256 _value , uint256 _fee , uint256 _nonce , bytes _userData ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _operator , _to , _delegate , _value , _fee , _nonce , _userData ) ) ; }
function setOperatingOfficer ( address _operatingOfficerAddress ) external onlyExecutiveOfficer { require ( _operatingOfficerAddress != address ( 0 ) ) ; operatingOfficerAddress = _operatingOfficerAddress ; }
function _setPendingAnchor ( address asset , uint newScaledPrice ) public returns ( uint ) { if ( msg . sender != anchorAdmin ) { return failOracle ( asset , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PENDING_ANCHOR_PERMISSION_CHECK ) ; } uint oldScaledPrice = pendingAnchors [ asset ] ; pendingAnchors [ asset ] = newScaledPrice ; emit NewPendingAnchor ( msg . sender , asset , oldScaledPrice , newScaledPrice ) ; return uint ( OracleError . NO_ERROR ) ; }
function getBoardSingleSpaceDetails ( uint boardId , uint8 row , uint8 col ) external view returns ( uint8 ) { uint8 position = row * BOARD_ROW_SIZE + col ; return allBoards [ boardId ] . positionToColor [ position ] ; }
function destroy ( ) public onlyOwner { token . transfer ( owner , token . balanceOf ( this ) ) ; selfdestruct ( owner ) ; }
function buyArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) external whenNotPaused payable { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; require ( canPay ( areaPrice ( fromX , fromY , toX , toY ) ) ) ; depositFunds ( ) ; uint id = market . buyBlocks ( msg . sender , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogBuys ( id , fromX , fromY , toX , toY , msg . sender ) ; }
function getValidAttributeID ( ) external view returns ( uint256 ) { return _validAttributeTypeID ; }
function worktime ( uint256 _factoryId ) public view returns ( uint256 ) { return worktimeAtDate ( factories [ _factoryId ] . collected_at ) ; }
function withdrawStake ( ) public whenNotPaused ( ) staking ( msg . sender ) { uint256 stakeAmount = refundUserBalance ( msg . sender ) ; delete registeredInvitationCodes [ members [ msg . sender ] . invitationCode ] ; Member storage member = members [ msg . sender ] ; member . stakeTimestamp = 0 ; member . startOfLoyaltyRewardEligibility = 0 ; emit StakeWithdrawn ( msg . sender , stakeAmount ) ; }
function setProxy ( address _proxyAddress , bytes32 _symbol ) public onlyOneOfContractOwners returns ( uint ) { if ( proxies ( _symbol ) != 0x0 ) { return CHRONOBANK_PLATFORM_PROXY_ALREADY_EXISTS ; } set ( store , proxiesStorage , _symbol , _proxyAddress ) ; return OK ; }
function enableTrade ( bool enable ) returns ( bool ) { if ( msg . sender != reserveOwner ) { ErrorReport ( tx . origin , 0x830000000 , uint ( msg . sender ) ) ; return false ; } tradeEnabled = enable ; ErrorReport ( tx . origin , 0 , 0 ) ; EnableTrade ( enable ) ; return true ; }
function changeRegistrationStatuses ( address [ ] targets , bool isRegistered ) public onlyBy ( owner ) { for ( uint i = 0 ; i < targets . length ; i ++ ) { changeRegistrationStatus ( targets [ i ] , isRegistered ) ; } }
function _getEarlyBonus ( ) internal view returns ( uint ) { if ( getState ( ) == State . PrivateFunding ) return privateBonus ; else if ( getState ( ) == State . PreFunding ) return preBonus ; else return 0 ; }
function burn ( uint256 _value ) public returns ( bool success ) { require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
function cancelSale ( uint256 _tokenId ) external whenNotPaused { Sale memory sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _cancelSale ( _tokenId , seller ) ; }
function reclaimDividend ( uint256 _dividendIndex ) external withPerm ( MANAGE ) { require ( _dividendIndex < dividends . length , "Incorrect dividend index" ) ; require ( now >= dividends [ _dividendIndex ] . expiry , "Dividend expiry is in the future" ) ; require ( ! dividends [ _dividendIndex ] . reclaimed , "Dividend is already claimed" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; dividend . reclaimed = true ; uint256 remainingAmount = dividend . amount . sub ( dividend . claimedAmount ) ; address owner = IOwnable ( securityToken ) . owner ( ) ; owner . transfer ( remainingAmount ) ; emit EtherDividendReclaimed ( owner , _dividendIndex , remainingAmount ) ; }
function tokenFactory ( uint256 _amount ) onlyOwner returns ( bool success ) { require ( tokenMinter ( _amount ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; Transfer ( 0 , msg . sender , _amount ) ; return true ; }
function purchase ( uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . hasAnyAttrs ( _tokenId , ATTR_GOLDENGOOSE ) ) ; require ( ! isExploring ( _tokenId ) ) ; address oldOwner = ethernautsStorage . ownerOf ( _tokenId ) ; address newOwner = msg . sender ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( oldOwner != newOwner ) ; require ( newOwner != address ( 0 ) ) ; require ( msg . value >= sellingPrice ) ; uint256 payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee1Step ) , 100 ) ) ; uint256 purchaseExcess = SafeMath . sub ( msg . value , sellingPrice ) ; uint256 newPrice = sellingPrice ; if ( sellingPrice < firstStepLimit ) { newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage1Step ) , percentageBase ) ; } else if ( sellingPrice < secondStepLimit ) { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee2Step ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage2Step ) , percentageBase ) ; } else { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFeeSteps ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentageSteps ) , percentageBase ) ; } if ( oldOwner != address ( this ) ) { oldOwner . transfer ( payment ) ; } ethernautsStorage . transfer ( oldOwner , newOwner , _tokenId ) ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; Purchase ( _tokenId , sellingPrice , newPrice , oldOwner , newOwner ) ; msg . sender . transfer ( purchaseExcess ) ; }
function getMemeSellingPrices ( uint256 [ ] _tokenIds ) public view returns ( uint256 [ ] sellingPrices ) { sellingPrices = new uint256 [ ] ( _tokenIds . length ) ; for ( uint i = 0 ; i < _tokenIds . length ; i ++ ) { sellingPrices [ i ] = memeIndexToPrice [ _tokenIds [ i ] ] ; } }
function setManager ( address _newManager ) external requireGod { require ( _newManager != address ( 0 ) ) ; managerAddress = _newManager ; }
function proxyPayment ( address _owner ) public payable returns ( bool ) ;
function cofounderApproveSwitchRequest ( address _newFounderAddr , bytes32 _oneTimesharedPhrase ) external returns ( bool success ) { if ( msg . sender != cofounder || sha3 ( _newFounderAddr , founderHash , _oneTimesharedPhrase ) != tempHashes [ _newFounderAddr ] ) throw ; previousFounders . push ( founder ) ; founder = _newFounderAddr ; FounderSwitchedEvent ( _newFounderAddr ) ; return true ; }
function changeController ( address _newController ) onlyOwner public { tokenContract . changeController ( _newController ) ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = masterpieceToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
function emitCampaignUpdated ( CampaignLibrary . Campaign storage campaign ) private { emit CampaignUpdated ( campaign . getBidId ( ) , campaign . getPrice ( ) , campaign . getBudget ( ) , campaign . getStartDate ( ) , campaign . getEndDate ( ) , campaign . getValidity ( ) , campaign . getOwner ( ) ) ; }
function getNotApprovedProposals ( ) public view returns ( uint [ ] ) { uint count = 0 ; for ( uint i = 0 ; i < proposals . length ; i ++ ) { if ( ! proposals [ i ] . approved && ! proposals [ i ] . denied ) { count ++ ; } } uint [ ] memory notApprovedProposals = new uint [ ] ( count ) ; count = 0 ; for ( i = 0 ; i < proposals . length ; i ++ ) { if ( ! proposals [ i ] . approved && ! proposals [ i ] . denied ) { notApprovedProposals [ count ] = i ; count ++ ; } } return notApprovedProposals ; }
function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { doTransfer ( msg . sender , _to , _amount ) ; return true ; }
function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( ethernautsStorage ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; ethernautsStorage . transfer ( msg . sender , _to , _tokenId ) ; }
function depositETH ( ) payable { DonationDeposited4Matching ( msg . sender , msg . value ) ; }
function setProtocolVersion ( address _STFactoryAddress , uint8 _major , uint8 _minor , uint8 _patch ) external onlyOwner { require ( _STFactoryAddress != address ( 0 ) , "0x address is not allowed" ) ; _setProtocolVersion ( _STFactoryAddress , _major , _minor , _patch ) ; }
function setLogger ( address newLoggerAddress ) public onlyCurator { logger = Logger ( newLoggerAddress ) ; logger . emitGenericLog ( "setLogger" , "" ) ; }
function setRate ( ERC20 [ ] sources , ERC20 [ ] dests , uint [ ] conversionRates , uint [ ] expiryBlocks , bool validate ) returns ( bool ) { if ( msg . sender != reserveOwner ) { ErrorReport ( tx . origin , 0x820000000 , uint ( msg . sender ) ) ; return false ; } if ( validate ) { if ( ( sources . length != dests . length ) || ( sources . length != conversionRates . length ) || ( sources . length != expiryBlocks . length ) ) { ErrorReport ( tx . origin , 0x820000001 , 0 ) ; return false ; } } for ( uint i = 0 ; i < sources . length ; i ++ ) { SetRate ( sources [ i ] , dests [ i ] , conversionRates [ i ] , expiryBlocks [ i ] ) ; pairConversionRate [ sha3 ( sources [ i ] , dests [ i ] ) ] = ConversionRate ( conversionRates [ i ] , expiryBlocks [ i ] ) ; } ErrorReport ( tx . origin , 0 , 0 ) ; return true ; }
function reopenSale ( ) public onlyOwner { require ( crowdsaleClosed == true ) ; crowdsaleClosed = false ; }
function getOpeningTS ( bytes32 question_id ) public view returns ( uint32 ) { }
function ( ) external payable { require ( msg . value > 0 ) ; _flushBalance ( ) ; }
function setAccessPolicy ( IAccessPolicy newPolicy , address newAccessController ) public ;
function kill ( ) public onlyOwner { selfdestruct ( owner ) ; }
function _setPaused ( bool requestedState ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_PAUSED_OWNER_CHECK ) ; } paused = requestedState ; emit SetPaused ( requestedState ) ; return uint ( Error . NO_ERROR ) ; }
function harvest ( uint256 amount ) onlyOwner public { require ( this . balance >= amount ) ; msg . sender . transfer ( amount ) ; }
function settlementRegistration ( uint64 _settlementID ) external view returns ( bool ) { return settlementDetails [ _settlementID ] . registered ; }
function approve ( address _to , uint256 _tokenId ) external onlyOwnerOf ( _tokenId ) { address _owner = ownerOf ( _tokenId ) ; require ( _to != _owner , "already owns" ) ; if ( getApproved ( _tokenId ) != 0 || _to != 0 ) { tokenApprovals [ _tokenId ] = _to ; emit Approval ( _owner , _to , _tokenId ) ; } }
function transfer ( address _to , uint _value ) public returns ( bool ) { if ( _to != 0x0 ) { return _transferWithReference ( _to , _value , "" ) ; } }
function onTransfer ( address _from , address _to , uint _amount ) returns ( bool success ) { if ( _from == vaultAddress ) { return true ; } return false ; }
function destroy ( ) public onlyOwner { selfdestruct ( owner ( ) ) ; }
function setAttributeTypeSecondarySource ( uint256 ID , address attributeRegistry , uint256 sourceAttributeTypeID ) external { require ( isAttributeType ( ID ) , "unable to set secondary source, no attribute type with the provided ID" ) ; _attributeTypes [ ID ] . secondarySource = attributeRegistry ; _attributeTypes [ ID ] . secondaryAttributeTypeID = sourceAttributeTypeID ; }
function transferWithData ( address _to , uint256 _value , bytes _data ) public returns ( bool success ) { require ( _updateTransfer ( msg . sender , _to , _value , _data ) , "Transfer invalid" ) ; require ( super . transfer ( _to , _value ) ) ; return true ; }
function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) private { address recipientImplementation = interfaceAddr ( _to , "ERC777TokensRecipient" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) ) ; } }
function balanceOf ( address _person ) public view returns ( uint256 balance ) { return balances [ _person ] ; }
function isHolderAddress ( address _address ) public view returns ( bool ) ;
function isPaused ( ) external view returns ( bool ) ;
function createCheckpoint ( ) public onlyModule ( CHECKPOINT_KEY , true ) returns ( uint256 ) { require ( currentCheckpointId < 2 ** 256 - 1 ) ; currentCheckpointId = currentCheckpointId + 1 ; emit LogCheckpointCreated ( currentCheckpointId , now ) ; return currentCheckpointId ; }
function release ( ) public { require ( block . timestamp >= _releaseTime ) ; uint256 amount = _token . balanceOf ( address ( this ) ) ; require ( amount > 0 ) ; _token . safeTransfer ( _beneficiary , amount ) ; }
function receiveApproval ( address from , uint256 , address _token , bytes _data ) public returns ( bool ) { require ( msg . sender == _token ) ; require ( _data . length == 0 ) ; require ( _token == address ( NEUMARK ) , "NF_ONLY_NEU" ) ; unlockInvestor ( from ) ; return true ; }
function checkValidity ( string _symbol , address _owner , string _tokenName ) public returns ( bool ) { string memory symbol = upper ( _symbol ) ; require ( msg . sender == securityTokenRegistry , "msg.sender should be SecurityTokenRegistry contract" ) ; require ( registeredSymbols [ symbol ] . status != true , "Symbol status should not equal to true" ) ; require ( registeredSymbols [ symbol ] . owner == _owner , "Owner of the symbol should matched with the requested issuer address" ) ; require ( registeredSymbols [ symbol ] . timestamp . add ( expiryLimit ) >= now , "Ticker should not be expired" ) ; registeredSymbols [ symbol ] . tokenName = _tokenName ; registeredSymbols [ symbol ] . status = true ; return true ; }
function destroyTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }
function mDestroyTokens ( address owner , uint256 amount ) internal ;
function lock ( address _beneficiary , bool _isStraight , uint [ ] _releaseTimes , uint [ ] _releaseRatios ) external onlyOwner onlyState ( State . Init ) onlyBeneficiary ( _beneficiary ) { require ( ! locked [ _beneficiary ] ) ; require ( _releaseRatios . length != 0 ) ; require ( _releaseRatios . length == _releaseTimes . length ) ; uint i ; uint len = _releaseRatios . length ; require ( _releaseRatios [ len - 1 ] == coeff ) ; for ( i = 0 ; i < len - 1 ; i ++ ) { require ( _releaseTimes [ i ] < _releaseTimes [ i + 1 ] ) ; require ( _releaseRatios [ i ] < _releaseRatios [ i + 1 ] ) ; } if ( _isStraight ) { require ( len == 2 ) ; } numLocks = numLocks . add ( 1 ) ; releases [ _beneficiary ] . isStraight = _isStraight ; releases [ _beneficiary ] . releaseTimes = _releaseTimes ; releases [ _beneficiary ] . releaseRatios = _releaseRatios ; locked [ _beneficiary ] = true ; emit Locked ( _beneficiary , _isStraight ) ; if ( numLocks == numBeneficiaries ) { state = State . Ready ; emit StateChanged ( state ) ; } }
function maxSupply ( ) external view returns ( uint256 ) ;
function withdrawToken ( address _token , uint256 _amount ) external onlyOwner returns ( bool ) { return ERC20SafeTransfer . safeTransfer ( _token , owner , _amount ) ; }
function removeTagByModuleType ( uint8 _moduleType , bytes32 [ ] _removedTags ) public onlyOwner { for ( uint8 i = 0 ; i < availableTags [ _moduleType ] . length ; i ++ ) { for ( uint8 j = 0 ; j < _removedTags . length ; j ++ ) { if ( availableTags [ _moduleType ] [ i ] == _removedTags [ j ] ) { delete availableTags [ _moduleType ] [ i ] ; } } } }
function checkIfFundingCompleteOrExpired ( ) public { if ( now > ICOdeadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
function isTokenEscapable ( address _token ) view public returns ( bool ) { return ! escapeBlacklist [ _token ] ; }
function claimTokens ( address _token ) onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }
function updateProfiterole ( address _profiterole , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _profiterole ) , _block ) ; if ( OK != _code ) { return _code ; } profiterole = _profiterole ; return OK ; }
function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , "ERC777TokensRecipient" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) ) ; } }
function getCampaignOwnerById ( bytes32 bidId ) public view returns ( address campOwner ) { return campaigns [ bidId ] . getOwner ( ) ; }
function approve ( address _spender , uint256 _value ) external { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; }
function setPrices ( uint256 priceForPreIcoInWei , uint256 priceForIcoInWei ) isOwner { require ( priceForPreIcoInWei > 0 ) ; require ( priceForIcoInWei > 0 ) ; preICOprice = priceForPreIcoInWei ; ICOprice = priceForIcoInWei ; updatePrices ( ) ; }
function getFinalAnswerIfMatches ( bytes32 question_id , bytes32 content_hash , address arbitrator , uint32 min_timeout , uint256 min_bond ) stateFinalized ( question_id ) external view returns ( bytes32 ) { require ( content_hash == questions [ question_id ] . content_hash , "content hash must match" ) ; require ( arbitrator == questions [ question_id ] . arbitrator , "arbitrator must match" ) ; require ( min_timeout <= questions [ question_id ] . timeout , "timeout must be long enough" ) ; require ( min_bond <= questions [ question_id ] . bond , "bond must be high enough" ) ; return questions [ question_id ] . best_answer ; }
function ownerOf ( uint _tokenId ) external view returns ( address ) { require ( tokenIndexToOwner [ _tokenId ] != address ( 0 ) ) ; return tokenIndexToOwner [ _tokenId ] ; }
function checkPermission ( address _delegate , address _module , bytes32 _perm ) external view returns ( bool ) ;
function isManagingProxy ( address _account , address _accountProxy ) public view returns ( bool ) { address _userRouter = Owned ( _accountProxy ) . contractOwner ( ) ; return _account == Owned ( _userRouter ) . contractOwner ( ) ; }
function allowAddress ( address _address , bool _allow ) onlyOwner { allowedAddresses [ _address ] = _allow ; }
function proxyPurchase ( address _addr ) public payable returns ( bool ) ;
function authorize ( string _contractName , address _accessor ) external onlyContractOwner ( _contractName , _accessor ) view returns ( bool ) { return true ; }
function approvePreSignedHashing ( address _token , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xf7ac9c2e ) , _token , _spender , _value , _fee , _nonce ) ) ; }
function setPoolToClosed ( ) public isAdmin isOpen { state = PoolState . CLOSED ; emit PoolIsClosed ( ) ; }
function release ( address who ) public onlyTransferAgent returns ( bool ) { Holding memory holding = heldTokens [ who ] ; require ( ! holding . isAffiliate , "To release tokens for an affiliate use partialRelease()." ) ; if ( block . timestamp > holding . releaseDate ) { bool res = ERC20Interface ( tokenContract ) . transfer ( who , holding . quantity ) ; if ( res ) { heldTokens [ who ] = Holding ( 0 , 0 , holding . isAffiliate ) ; emit TokensReleased ( who , holding . quantity ) ; return true ; } } return false ; }
function startTokenVotes ( address [ 10 ] tokens ) public onlyAdmins { uint _proposalId = tokenBatches . length ; if ( _proposalId > 0 ) { TokenProposal memory op = tokenBatches [ _proposalId - 1 ] ; DestructibleMiniMeToken ( op . votingToken ) . recycle ( ) ; } tokenBatches . length ++ ; TokenProposal storage p = tokenBatches [ _proposalId ] ; p . duration = VOTING_DURATION * ( 1 days ) ; p . consideredTokens = tokens ; p . votingToken = tokenFactory . createDestructibleCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( "EfxTokenVotes-" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( "EfxTokenVotes-" , _proposalId ) , true ) ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; emit NewTokens ( _proposalId ) ; }
function addReserve ( KyberReserve reserve , bool add ) { if ( msg . sender != admin ) { ErrorReport ( msg . sender , 0x87000000 , 0 ) ; return ; } if ( add ) { reserves . push ( reserve ) ; AddReserve ( reserve , true ) ; } else { for ( uint i = 0 ; i < reserves . length ; i ++ ) { if ( reserves [ i ] == reserve ) { if ( reserves . length == 0 ) return ; reserves [ i ] = reserves [ -- reserves . length ] ; AddReserve ( reserve , false ) ; break ; } } } ErrorReport ( msg . sender , 0 , 0 ) ; }
function convert ( uint _amount ) { if ( ! arcToken . transferFrom ( msg . sender , vaultAddress , _amount ) ) { throw ; } if ( ! tokenContract . generateTokens ( msg . sender , _amount ) ) { throw ; } }
function setBuyoutDividendPercentage ( uint256 _buyoutDividendPercentage ) external onlyCFO { require ( 2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500 ) ; buyoutDividendPercentage = _buyoutDividendPercentage ; }
function setGasPrice ( uint256 _gasPrice ) onlyOwner public { oraclize_setCustomGasPrice ( _gasPrice ) ; }
function balanceOf ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return _tokensOfOwnerWithSubstitutions [ _owner ] . length ; }
function _depositTokens ( address _beneficiary , uint256 _amountTokens ) internal { require ( _amountTokens != 0 ) ; if ( investors [ _beneficiary ] == 0 ) { investorCount ++ ; } investors [ _beneficiary ] = investors [ _beneficiary ] . add ( _amountTokens ) ; mintableFida . sendBoughtTokens ( _beneficiary , _amountTokens ) ; }
function transfer ( address _to , uint256 _amount ) stopOnPause public returns ( bool success ) { bytes memory empty ; if ( _transfer ( msg . sender , _to , _amount , empty ) ) { emit Transfer ( msg . sender , _to , _amount ) ; return true ; } return false ; }
function getTitle ( ) public view returns ( string ) ;
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { success = TokenApprovalController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_APPROVAL ) ) . approve ( msg . sender , _spender , _value ) ; }
function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( SENToken ) { SENToken newToken = new SENToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
function validatePurchaseAndDistributeFunds ( uint24 [ ] purchase , uint24 [ ] purchasedAreas , uint256 [ ] areaIndices ) private returns ( uint256 ) { require ( purchase . length == 4 ) ; Geometry . Rect memory plotToPurchase = Geometry . Rect ( purchase [ 0 ] , purchase [ 1 ] , purchase [ 2 ] , purchase [ 3 ] ) ; require ( plotToPurchase . x < GRID_WIDTH && plotToPurchase . x >= 0 ) ; require ( plotToPurchase . y < GRID_HEIGHT && plotToPurchase . y >= 0 ) ; require ( plotToPurchase . w > 0 && plotToPurchase . w + plotToPurchase . x <= GRID_WIDTH ) ; require ( plotToPurchase . h > 0 && plotToPurchase . h + plotToPurchase . y <= GRID_HEIGHT ) ; require ( plotToPurchase . w * plotToPurchase . h < MAXIMUM_PURCHASE_AREA ) ; require ( purchasedAreas . length >= 4 ) ; require ( areaIndices . length > 0 ) ; require ( purchasedAreas . length % 4 == 0 ) ; require ( purchasedAreas . length / 4 == areaIndices . length ) ; Geometry . Rect [ ] memory subPlots = new Geometry . Rect [ ] ( areaIndices . length ) ; uint256 totalArea = 0 ; uint256 i = 0 ; uint256 j = 0 ; for ( i = 0 ; i < areaIndices . length ; i ++ ) { Geometry . Rect memory rect = Geometry . Rect ( purchasedAreas [ ( i * 4 ) ] , purchasedAreas [ ( i * 4 ) + 1 ] , purchasedAreas [ ( i * 4 ) + 2 ] , purchasedAreas [ ( i * 4 ) + 3 ] ) ; subPlots [ i ] = rect ; require ( rect . w > 0 ) ; require ( rect . h > 0 ) ; totalArea = SafeMath . add ( totalArea , SafeMath . mul ( rect . w , rect . h ) ) ; require ( Geometry . rectContainedInside ( rect , plotToPurchase ) ) ; } require ( totalArea == plotToPurchase . w * plotToPurchase . h ) ; for ( i = 0 ; i < subPlots . length ; i ++ ) { for ( j = i + 1 ; j < subPlots . length ; j ++ ) { require ( ! Geometry . doRectanglesOverlap ( subPlots [ i ] , subPlots [ j ] ) ) ; } } uint256 remainingBalance = checkHolesAndDistributePurchaseFunds ( subPlots , areaIndices ) ; uint256 purchasePrice = SafeMath . sub ( msg . value , remainingBalance ) ; return purchasePrice ; }
function symbol ( ) external pure returns ( string _symbol ) { return "BC" ; }
function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ) ;
function transferFrom ( address _owner , address _receiver , uint256 _amount ) { require ( ! tokenTransfersFrozen ) ; require ( sub ( allowance [ _owner ] [ msg . sender ] , _amount ) >= 0 ) ; if ( transferCheck ( _owner , _receiver , _amount ) ) { balances [ _owner ] = sub ( balances [ _owner ] , _amount ) ; balances [ _receiver ] = add ( balances [ _receiver ] , _amount ) ; allowance [ _owner ] [ _receiver ] = sub ( allowance [ _owner ] [ _receiver ] , _amount ) ; Transfer ( _owner , _receiver , _amount ) ; } else { revert ( ) ; } }
function withdrawTokens ( ) public whenNotPaused returns ( bool ) { uint256 amount = rewards [ msg . sender ] ; require ( amount > 0 , "amount is zero" ) ; rewards [ msg . sender ] = 0 ; emit TokensWithdrawn ( msg . sender , amount ) ; require ( token . transfer ( msg . sender , amount ) , "token transfer failed" ) ; return true ; }
function mint ( address _investor , uint256 _value ) public returns ( bool success ) { return mintWithData ( _investor , _value , "" ) ; }
function addPartOwner ( address _partowner ) public onlyContractOwner returns ( uint ) { set ( store , partownersStorage , _partowner , true ) ; return OK ; }
function claimTokenTokens ( address _token ) public onlyOwner { require ( _token != address ( ethealToken ) ) ; ethealToken . claimTokens ( _token ) ; }
function lockToken ( address target , uint256 lockAmount , uint256 lockPeriod ) onlyOwner public returns ( bool res ) { require ( balanceOf [ msg . sender ] >= lockAmount ) ; require ( lockedAmount [ target ] == 0 ) ; balanceOf [ msg . sender ] -= lockAmount ; lockedAmount [ target ] = lockAmount ; lockedTime [ target ] = now + lockPeriod ; LockToken ( target , lockAmount , now + lockPeriod ) ; return true ; }
function listPairForReserve ( address reserve , ERC20 src , ERC20 dest , bool add ) public onlyAdmin { ( perReserveListedPairs [ reserve ] ) [ keccak256 ( src , dest ) ] = add ; if ( src != ETH_TOKEN_ADDRESS ) { if ( add ) { src . approve ( reserve , 2 ** 255 ) ; } else { src . approve ( reserve , 0 ) ; } } setDecimals ( src ) ; setDecimals ( dest ) ; ListReservePairs ( reserve , src , dest , add ) ; }
function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( "pMinDeposit" ) ; bytes32 propID = keccak256 ( _name , _value ) ; require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now + get ( "pApplyStageLen" ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now + get ( "pApplyStageLen" ) + get ( "pCommitStageLen" ) + get ( "pRevealStageLen" ) + PROCESSBY , value : _value } ) ; _ReparameterizationProposal ( msg . sender , _name , _value , propID ) ; return propID ; }
function setManualOverride ( bool _override ) public onlyOwner { manualOverride = _override ; emit LogSetManualOverride ( _override , now ) ; }
function ( ) payable internal { uint amount ; uint amountRaised ; if ( now <= presale ) { amount = msg . value * 15000 ; } else if ( now > presale && now <= coresale ) { amount = msg . value * 13000 ; } else if ( now > coresale ) { amount = msg . value * 10000 ; } amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
function transferOwnership ( address newOwner ) public onlyOwner { if ( newOwner != address ( 0 ) ) { owner = newOwner ; } }
function division ( uint numerator , uint denominator ) public view returns ( uint result ) { uint _quotient = numerator / denominator ; return _quotient ; }
function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( owner ) ; owner = address ( 0 ) ; }
function getAddress ( string _nameKey ) external view returns ( address ) { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; require ( storedAddresses [ key ] != address ( 0 ) , "Invalid address key" ) ; return storedAddresses [ key ] ; }
function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = approvePreSignedHashing ( address ( this ) , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; checkValue ( from , _fee ) ; allowed [ from ] [ _spender ] = _value ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , _value , _fee ) ; return true ; }
function approve ( address _to , uint256 _tokenId ) public whenNotPaused { address owner = ownerOf ( _tokenId ) ; require ( _to != owner ) ; require ( ( msg . sender == owner ) || ( operators [ ownerOf ( _tokenId ) ] [ msg . sender ] ) ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; }
function collectEstimation ( int256 _expectedAmount ) public view returns ( uint256 ) { if ( _expectedAmount < 0 ) { return 0 ; } uint256 computedCollect = uint256 ( _expectedAmount ) . mul ( rateFeesNumerator ) ; if ( rateFeesDenominator != 0 ) { computedCollect = computedCollect . div ( rateFeesDenominator ) ; } return computedCollect < maxFees ? computedCollect : maxFees ; }
function multiCancel ( uint [ ] _idPayments ) public onlyOwner { for ( uint i = 0 ; i < _idPayments . length ; i ++ ) { doCancelPayment ( _idPayments [ i ] ) ; } }
function transferOtherERC20Token ( address tokenAddress , uint256 amount ) onlyOwner returns ( bool success ) { require ( tokenAddress != address ( this ) || transferable ) ; return ERC20 ( tokenAddress ) . transfer ( owner , amount ) ; }
function startPresale ( ) whenNotPaused onlyOwner external { require ( ! isPresaleStarted ) ; currentStatus = Status . Presale ; isPresaleStarted = true ; presaleStartTime = now ; PresaleStarted ( presaleStartTime ) ; }
function closePreSale ( ) private { closed = true ; SaleClosed ( now ) ; }
function setAquariumCost ( uint256 _fee ) onlyOwner public { aquariumCost = _fee ; }
function setFundingFueled ( uint _proposalID ) external ;
function symbol ( ) public pure returns ( string result ) { return "HEALP" ; }
function ( ) payable { if ( now < PRESALE_START_DATE ) throw ; if ( now > PRESALE_END_DATE ) throw ; if ( msg . value < MIN_AMOUNT ) throw ; if ( msg . value > MAX_AMOUNT ) throw ; if ( safeIncrement ( totalFunding , msg . value ) > PRESALE_MAXIMUM_FUNDING ) throw ; addBalance ( msg . sender , msg . value ) ; }
function listPairForReserve ( address reserve , ERC20 source , ERC20 dest , bool add ) { if ( msg . sender != admin ) { ErrorReport ( msg . sender , 0x88000000 , 0 ) ; return ; } ( perReserveListedPairs [ reserve ] ) [ sha3 ( source , dest ) ] = add ; ListPairsForReserve ( reserve , source , dest , add ) ; ErrorReport ( tx . origin , 0 , 0 ) ; }
function approvePayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( msg . sender != arbitrator ) { require ( job . manager == msg . sender ) ; require ( job . proofOfLastWorkVerified == true ) ; } require ( job . noOfTotalPayments > job . noOfPaymentsMade ) ; uint currentPayment = job . salaryDeposited . div ( job . noOfTotalPayments ) ; job . paymentAvailableForWorker = job . paymentAvailableForWorker + currentPayment ; job . salaryDeposited = job . salaryDeposited - currentPayment ; job . noOfPaymentsMade ++ ; if ( job . noOfTotalPayments == job . noOfPaymentsMade ) { job . status = JobStatus . Completed ; } emit PaymentApproved ( msg . sender , _JobID , currentPayment ) ; }
function _isSTOAttached ( ) internal view returns ( bool ) { bool attached = ISecurityToken ( securityToken ) . getModulesByType ( 3 ) . length > 0 ; return attached ; }
function setICOEndDate ( uint _date ) public onlyAdmin { require ( ICOEndDate == 0 ) ; require ( _date > now ) ; ICOEndDate = _date ; emit ICOEndDateSet ( _date ) ; }
function addToWhitelist ( address [ ] _bidder_addresses ) public isWhitelister { for ( uint32 i = 0 ; i < _bidder_addresses . length ; i ++ ) { whitelist [ _bidder_addresses [ i ] ] = true ; } }
function burn ( address _where , uint _amount ) external onlyOwner { _burn ( _where , _amount ) ; }
function deleteUncompletableRequest ( bytes32 _requestMsgHash ) public { Request storage request = requestMap [ _requestMsgHash ] ; uint256 idx = request . idx ; require ( 0 < idx && idx < lastCompletedIdxs [ request . callbackAddress ] [ request . callbackSelector ] ) ; delete requestMap [ _requestMsgHash ] ; }
function tileTimeoutTimestamp ( uint256 identifier , address player ) public view returns ( uint256 ) { uint256 bonusTime = gameSettings . timeoutBonusTime . mul ( gameStates [ gameIndex ] . addressToNumberOfTiles [ player ] ) ; uint256 timeoutTimestamp = block . timestamp . add ( calculateBaseTimeout ( ) ) . add ( bonusTime ) ; uint256 currentTimeoutTimestamp = gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ identifier ] ; if ( currentTimeoutTimestamp == 0 ) { currentTimeoutTimestamp = gameStates [ gameIndex ] . gameStartTimestamp . add ( gameSettings . initialActivityTimer ) ; } if ( timeoutTimestamp >= currentTimeoutTimestamp ) { return timeoutTimestamp ; } else { return currentTimeoutTimestamp ; } }
function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) private { address senderImplementation = interfaceAddr ( _from , "ERC777TokensSender" ) ; if ( senderImplementation != 0 ) { ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } }
function setMaximumIssuableAttributes ( address organization , uint256 maximumIssuableAttributes ) external onlyOwner whenNotPaused { require ( _organizations [ organization ] . exists == true , "an organization does not exist at the provided account address" ) ; require ( _organizations [ organization ] . accounts . length <= maximumIssuableAttributes , "maximum cannot be set to amounts less than the current account total" ) ; _organizations [ organization ] . maximumAccounts = maximumIssuableAttributes ; }
function participantClaimCredits ( ) external { require ( now >= TOKEN_WITHDRAWAL_START_DATE ) ; require ( now < TOKEN_WITHDRAWAL_END_DATE ) ; require ( totalFunding >= PRESALE_MINIMUM_FUNDING ) ; require ( creditBalanceOf [ msg . sender ] > 0 ) ; var tokensToApprove = creditBalanceOf [ msg . sender ] ; spentParsecCredits = spentParsecCredits . add ( tokensToApprove ) ; creditBalanceOf [ msg . sender ] = 0 ; parsecToken . approve ( msg . sender , tokensToApprove ) ; }
function mintToken ( uint256 mintedAmount ) onlyOwner public { balanceOf [ this ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( 0 , this , mintedAmount ) ; }
function setSale ( address account , bool isSale ) external validAddress ( account ) privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { m_sales [ account ] = isSale ; }
function getCity ( uint256 _tokenId ) public view returns ( string cityName , uint256 sellingPrice , address owner ) { City storage city = citys [ _tokenId ] ; cityName = city . name ; sellingPrice = cityIndexToPrice [ _tokenId ] ; owner = cityIndexToOwner [ _tokenId ] ; }
function manualTransfer ( address _to , uint _value ) public onlyOwner returns ( bool success ) { require ( totalSupply >= _value ) ; require ( ! frozenAccount [ _to ] ) ; totalSupply -= _value ; balanceOf [ _to ] += _value ; emit Transfer ( address ( 0 ) , _to , _value ) ; return true ; }
function registerDevice ( bytes32 _deviceIdHash , bytes32 _deviceType , bytes32 _devicePublicKey ) public onlyManufacturer whenNotPaused returns ( bool ) { uint256 registrationFee = settings . registrationFee ( ) ; Device memory d = _registerDevice ( msg . sender , _deviceIdHash , _deviceType , _devicePublicKey ) ; emit DeviceRegistered ( msg . sender , registrationFee , _deviceIdHash , d . manufacturerId , _deviceType ) ; _depositTokens ( msg . sender , registrationFee ) ; require ( token . transferFrom ( msg . sender , address ( this ) , registrationFee ) , "transferFrom failed" ) ; return true ; }
function sell ( uint256 amount ) public { require ( balances [ msg . sender ] >= amount , "You don't have enough tokens" ) ; require ( owner . balance > amount . mul ( sellPrice_ ) , "The contract does not have enough ether to buy your tokens" ) ; transferFrom ( msg . sender , owner , amount ) ; msg . sender . transfer ( amount . mul ( sellPrice_ ) ) ; }
function withdraw ( bytes32 _userKey , uint _value , address _withdrawAddress , uint _feeAmount , address _feeAddress ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; _makeWithdrawForPeriod ( _userKey , _value ) ; uint _periodsCount = periodsCount ; user2lastPeriodParticipated [ _userKey ] = periodsCount ; delete periods [ _periodsCount ] . startDate ; ERC20 _token = ERC20 ( token ) ; if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || _token . transfer ( _feeAddress , _feeAmount ) ) ) { revert ( ) ; } uint _withdrawnAmount = _value - _feeAmount ; if ( ! _token . transfer ( _withdrawAddress , _withdrawnAmount ) ) { revert ( ) ; } TreasuryWithdrawn ( _userKey , _withdrawnAmount ) ; return OK ; }
function decodeAssets ( bytes32 [ ] _potentialAssets ) public pure returns ( uint [ ] assets ) { require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetsCopy = new uint [ ] ( _potentialAssets . length * 10 ) ; uint numberOfAssets = 0 ; for ( uint j = 0 ; j < _potentialAssets . length ; j ++ ) { uint input ; bytes32 pot = _potentialAssets [ j ] ; assembly { input := pot } for ( uint i = 10 ; i > 0 ; i -- ) { uint mask = ( 2 << ( ( i - 1 ) * 24 ) ) / 2 ; uint b = ( input & ( mask * 16777215 ) ) / mask ; if ( b != 0 ) { assetsCopy [ numberOfAssets ] = b ; numberOfAssets ++ ; } } } assets = new uint [ ] ( numberOfAssets ) ; for ( i = 0 ; i < numberOfAssets ; i ++ ) { assets [ i ] = assetsCopy [ i ] ; } }
function takeFee ( uint256 _amount ) public withPerm ( FEE_ADMIN ) returns ( bool ) { require ( polyToken . transferFrom ( securityToken , Ownable ( factory ) . owner ( ) , _amount ) , "Unable to take fee" ) ; return true ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = ethernautsStorage . ownerOf ( _tokenId ) ; require ( owner != address ( 0 ) ) ; }
function buyTokens ( address _beneficiary ) public payable nonReentrant { if ( ! allowBeneficialInvestments ) { require ( _beneficiary == msg . sender , "Beneficiary address does not match msg.sender" ) ; } require ( ! paused , "Should not be paused" ) ; require ( fundRaiseTypes [ uint8 ( FundRaiseType . ETH ) ] , "Mode of investment is not ETH" ) ; uint256 weiAmount = msg . value ; _processTx ( _beneficiary , weiAmount ) ; _forwardFunds ( ) ; _postValidatePurchase ( _beneficiary , weiAmount ) ; }
function buy ( ) public payable { iaOnInvested ( msg . sender , msg . value , false ) ; }
function addChunk4ToWhiteList ( ) external onlyOwner { require ( ! chunk4IsAdded ) ; addToWhitelist ( 0x47169f78750Be1e6ec2DEb2974458ac4F8751714 , 1 ether ) ; addToWhitelist ( 0x499114EF97E50c0F01EDD6558aD6203A9B295419 , 1 ether ) ; addToWhitelist ( 0x49C11D994DC19C5Edb62F70DFa76c393941d5fFf , 1 ether ) ; addToWhitelist ( 0x4bCC31189527dCdFde2f4c887A59b0b0C5dBBB1c , 1 ether ) ; addToWhitelist ( 0x4E5Be470d1B97400ce5E141Da1372e06575383ee , 1 ether ) ; addToWhitelist ( 0x5203CDD1D0b8cDc6d7CF60228D0c7E7146642405 , 1 ether ) ; addToWhitelist ( 0x554C033720EfDaD25e5d6400Bdea854bF9E709b6 , 1 ether ) ; addToWhitelist ( 0x5700e809Ea5b49f80B6117335FB7f6B29E0E4529 , 1 ether ) ; addToWhitelist ( 0x62f33168582712391f916b4d42f9d7433ed390ea , 1 ether ) ; addToWhitelist ( 0x62f4e10FA6f1bA0f2b8282973FF4fE2141F917D6 , 1 ether ) ; addToWhitelist ( 0x635Dc49b059dB00BF0d2723645Fa68Ffc839a525 , 1 ether ) ; addToWhitelist ( 0x6465dFa666c6bFDF3E9bd95b5EC1E502843eeEB7 , 1 ether ) ; addToWhitelist ( 0x6E88904BA0A062C7c13772c1895900E1482deC8e , 1 ether ) ; addToWhitelist ( 0x70580eA14d98a53fd59376dC7e959F4a6129bB9b , 1 ether ) ; addToWhitelist ( 0x70EbC02aBc8922c34fA901Bd0931A94634e5B6b2 , 1 ether ) ; addToWhitelist ( 0x71b492cd6695fd85b21af5ae9f818c53f3823046 , 1 ether ) ; addToWhitelist ( 0x7b8a0D81e8A760D1BCC058250D77F79d4827Fd3c , 1 ether ) ; addToWhitelist ( 0x7ba67f190771Cf0C751F2c4e461f40180e8a595c , 1 ether ) ; addToWhitelist ( 0x7ce2C04EfC51EaA4Ca7e927a61D51F4dc9A19f41 , 1 ether ) ; addToWhitelist ( 0x7E8658A0467e34c3ac955117FA3Ba9C18d25d22A , 1 ether ) ; addToWhitelist ( 0x7eedaC1991eE2A59B072Be8Dc6Be82CCE9031f91 , 1 ether ) ; addToWhitelist ( 0x7aa1bb9e0e5439298ec71fb67dc1574f85fecbd1 , 1 ether ) ; addToWhitelist ( 0x832aC483326472Da0c177EAAf437EA681fAb3ABe , 1 ether ) ; addToWhitelist ( 0x861739a2fe0D7d16544c4a295b374705aEEA004F , 1 ether ) ; addToWhitelist ( 0x898C86446CcE1B7629aC7f5B5fD8eA0F51a933b3 , 1 ether ) ; addToWhitelist ( 0x8b2F96cEc0849C6226cf5cFAF32044c12B16eeD9 , 1 ether ) ; addToWhitelist ( 0x8fF73A67b4406341AfBc4b37c9f595a77Aa062A2 , 1 ether ) ; addToWhitelist ( 0x964b513c0F30E28B93081195231305a2D92C7762 , 1 ether ) ; addToWhitelist ( 0x96BC6015ff529eC3a3d0B5e1B7164935Df2bF2fd , 1 ether ) ; addToWhitelist ( 0x96BF1A8660C8D74603b3c4f429f6eC53AD32b0B0 , 1 ether ) ; addToWhitelist ( 0x9840a6b89C53DDB6D6ef57240C6FC972cC97731A , 1 ether ) ; addToWhitelist ( 0xA8625D251046abd3F2858D0163A827368a068bac , 1 ether ) ; addToWhitelist ( 0xa93e77C28fB6A77518e5C3E61348Aec81E5004fD , 1 ether ) ; addToWhitelist ( 0xaEafb182b64FD2CC3866766BA72B030F9AcE69f0 , 1 ether ) ; addToWhitelist ( 0xB3eA2C6feDb15CDC5228dd0B8606592d712c53e1 , 1 ether ) ; addToWhitelist ( 0xBde128e0b3EA8E4a6399401A671ce9731282C4C2 , 1 ether ) ; addToWhitelist ( 0xC3dA85745022fC89CdC774e1FE95ABC4F141292f , 1 ether ) ; addToWhitelist ( 0xC62c61Bbcd61A4817b95dA22339A4c856EC4A3F9 , 1 ether ) ; addToWhitelist ( 0xcE13de0cBd0D7Bde1d2444e2d513868177D2B15F , 1 ether ) ; addToWhitelist ( 0xd45546Cbc3C4dE75CC2B1f324d621A7753f25bB3 , 1 ether ) ; addToWhitelist ( 0xDAF8247Ebcd4BB033D0B82947c3c64a3E5089444 , 1 ether ) ; addToWhitelist ( 0xEF2F95dbEEd23a04DD674898eaB10cA4C883d780 , 1 ether ) ; addToWhitelist ( 0xDe3b6c96f7E6c002c1018b77f93b07956C6fB3e8 , 1 ether ) ; addToWhitelist ( 0xe415638FC30b277EC7F466E746ABf2d406f821FF , 1 ether ) ; addToWhitelist ( 0xE4A12D142b218ed96C75AA8D43aa153dc774F403 , 1 ether ) ; addToWhitelist ( 0xEEBEA0A8303aAc18D2cABaca1033f04c4a43E358 , 1 ether ) ; addToWhitelist ( 0xf12059ad0EB7D393E41AC3b3250FB5E446AA8dFB , 1 ether ) ; addToWhitelist ( 0xF94EfB6049B7bca00cE8e211C9A3f5Ca7ff4800b , 1 ether ) ; addToWhitelist ( 0xFBCe0CBB70bD0Bf43B11f721Beaf941980C5fF4a , 1 ether ) ; addToWhitelist ( 0x573648f395c26f453bf06Fd046a110A016274710 , 1.2 ether ) ; addToWhitelist ( 0x95159e796569A9A7866F9A6CF0E36B8D6ddE9c02 , 1.2 ether ) ; addToWhitelist ( 0xEafF321951F891EBD791eF57Dc583A859626E295 , 1.2 ether ) ; chunk4IsAdded = true ; }
function setRateFees ( uint256 _rateFeesNumerator , uint256 _rateFeesDenominator ) external onlyOwner { rateFeesNumerator = _rateFeesNumerator ; rateFeesDenominator = _rateFeesDenominator ; emit UpdateRateFees ( rateFeesNumerator , rateFeesDenominator ) ; }
function setPrices ( uint256 newSellPrice , uint256 newSellMultiplier , uint256 newBuyPrice , uint256 newBuyMultiplier ) onlyOwner public { sellPrice = newSellPrice ; sellMultiplier = newSellMultiplier ; buyPrice = newBuyPrice ; buyMultiplier = newBuyMultiplier ; }
function setMasterFeeContract ( Data storage self , address contractAddress ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.contract.master' ) ) ; require ( self . Storage . setAddress ( id , contractAddress ) , "Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract." ) ; return true ; }
function withdraw ( ) pre_cond ( isBeneficiary ( ) ) pre_cond ( isVestingStarted ( ) ) { uint withdrawable = calculateWithdrawable ( ) ; withdrawn = withdrawn . add ( withdrawable ) ; require ( MELON_CONTRACT . transfer ( beneficiary , withdrawable ) ) ; }
function reduce ( uint256 amount ) isPeonyContract returns ( bool ) { require ( balances [ owner ] . sub ( amount ) >= 0 ) ; require ( totalSupply . sub ( amount ) >= 0 ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; totalSupply = totalSupply . sub ( amount ) ; return true ; }
function distributeTokens ( address _token , address [ ] _to , uint256 [ ] _value ) external onlyOwner { require ( _to . length == _value . length ) ; ERC20 token = ERC20 ( _token ) ; for ( uint256 i = 0 ; i < _to . length ; i ++ ) { token . transfer ( _to [ i ] , _value [ i ] ) ; } }
function manualTransfer ( address _to , uint256 _value ) public onlyOwner returns ( bool success ) { require ( totalSupply >= _value ) ; require ( ! frozenAccount [ _to ] ) ; totalSupply -= _value ; balanceOf [ _to ] += _value ; emit Transfer ( address ( 0 ) , _to , _value ) ; return true ; }
function issueAttribute ( bool doYouLoveCats , bool doYouLoveDogsMoreThanCats , bool areYouACrazyCatLady ) external { require ( doYouLoveCats , "only cat lovers allowed" ) ; require ( doYouLoveDogsMoreThanCats , "no liars allowed" ) ; require ( ! areYouACrazyCatLady , "we are very particular" ) ; require ( _issueAttribute ( msg . sender ) ) ; }
function poll ( uint _idPoll ) public view returns ( uint _startBlock , uint _endBlock , bool _canVote , bool _canceled , bytes _description , uint8 _numBallots , bool _finalized , uint _voters , address _author , uint [ 15 ] _tokenTotal , uint [ 15 ] _quadraticVotes ) { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll storage p = _polls [ _idPoll ] ; _startBlock = p . startBlock ; _endBlock = p . endBlock ; _canceled = p . canceled ; _canVote = canVote ( _idPoll ) ; _description = p . description ; _numBallots = p . numBallots ; _author = p . author ; _finalized = ( ! p . canceled ) && ( block . number >= _endBlock ) ; _voters = p . voters ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { _tokenTotal [ i ] = p . results [ i ] ; _quadraticVotes [ i ] = p . qvResults [ i ] ; } }
function createRequestAsPayeeAction ( address [ ] _payeesIdAddress , bytes _payeesPaymentAddress , int256 [ ] _expectedAmounts , address _payer , bytes _payerRefundAddress , string _data ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( msg . sender == _payeesIdAddress [ 0 ] && msg . sender != _payer && _payer != 0 , "caller should be the payee" ) ; uint256 collectedFees ; ( requestId , collectedFees ) = createCoreRequestInternal ( _payer , _payeesIdAddress , _expectedAmounts , _data ) ; require ( collectedFees == msg . value , "fees should be the correct amout" ) ; extractAndStoreBitcoinAddresses ( requestId , _payeesIdAddress . length , _payeesPaymentAddress , _payerRefundAddress ) ; return requestId ; }
function setNextUpgradeAgent ( address agent ) external { if ( agent == 0x0 ) revert ( ) ; if ( msg . sender != nextUpgradeMaster ) revert ( ) ; nextUpgradeAgent = NextUpgradeAgent ( agent ) ; if ( ! nextUpgradeAgent . isUpgradeAgent ( ) ) revert ( ) ; nextUpgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( nextUpgradeAgent ) ; }
function addNFToken ( address _to , uint256 _tokenId ) noOwnerExists ( _tokenId ) internal { nft [ _tokenId ] . owner = _to ; ownerToTokenList [ _to ] . push ( _tokenId ) ; }
function increasePot ( ) public payable { pot += msg . value ; }
function moveTokensToAddress ( bytes16 _uuid , address _address , uint256 _tokensCount ) onlyAllowedAddresses onlyRegisteredAccount ( _uuid ) whenNotPaused public returns ( bool ) { removeTokensFromAccount ( _uuid , _tokensCount ) ; rntToken . transfer ( _address , _tokensCount ) ; tokens = tokens . sub ( _tokensCount ) ; tokenTransfers [ _address ] = _uuid ; return true ; }
function adjustTotalSupplyCheckpoints ( ) internal { adjustCheckpoints ( checkpointTotalSupply , totalSupply ( ) ) ; }
function getModule ( address _module ) external view returns ( bytes32 , address , address , bool , uint8 , uint256 , uint256 ) ;
function tokenAddress ( ) constant returns ( address ) { return data . token ; }
function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; idToOwnerIndex [ _tokenId ] = 0 ; }
function refund ( ) minCapNotReached salePeriodCompleted registeredUser isValidState external { require ( msg . sender != gmtFundAddress ) ; uint256 gmtVal = balances [ msg . sender ] ; require ( gmtVal > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( gmtVal ) ; assignedSupply = assignedSupply . sub ( gmtVal ) ; uint256 ethVal = gmtVal . div ( tokenExchangeRate ) ; msg . sender . transfer ( ethVal ) ; RefundSent ( msg . sender , ethVal ) ; }
function fill ( address makerAddress , uint makerAmount , address makerToken , address takerAddress , uint takerAmount , address takerToken , uint256 expiration , uint256 nonce , uint8 v , bytes32 r , bytes32 s ) external payable ;
function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return approved [ _owner ] [ _spender ] ; }
function setTransferAgent ( address who ) public onlyIssuer { transferAgent = who ; }
function hurmint ( address _client , uint256 _value ) onlyowner public { require ( totalToken <= totalHurify ) ; uint256 numHur = _value * ( 10 ** decimals ) ; balances [ owner ] = safeSub ( balances [ owner ] , numHur ) ; balances [ _client ] = safeAdd ( balances [ _client ] , numHur ) ; totalToken = safeAdd ( totalToken , numHur ) ; Transfer ( owner , _client , numHur ) ; }
function rolloverFeePeriodIfElapsed ( ) public { if ( now >= feePeriodStartTime + feePeriodDuration ) { lastFeesCollected = nomin . feePool ( ) ; lastFeePeriodStartTime = feePeriodStartTime ; feePeriodStartTime = now ; emitFeePeriodRollover ( now ) ; } }
function halvingSubsidy ( uint256 _halving ) public constant notBeforeGenesis returns ( uint256 ) { uint256 startBlock = halvingStartBlock ( _halving ) ; return blockSubsidy ( startBlock ) . mul ( subsidyHalvingInterval ) ; }
function setSelfDestructBeneficiary ( address _beneficiary ) external onlyOwner { require ( _beneficiary != address ( 0 ) , "Beneficiary must not be the zero address" ) ; selfDestructBeneficiary = _beneficiary ; emit SelfDestructBeneficiaryUpdated ( _beneficiary ) ; }
function setMinSellAmount ( uint256 _minSellAmount ) onlyOwner public { minSellAmount = _minSellAmount ; }
function distributeTokens ( address _to , uint256 _amount ) public onlyOwnerOrCrowdsale { require ( _to != address ( 0 ) ) ; require ( _amount > 0 ) ; require ( tokensRaised . add ( _amount ) <= crowdsaleTokens ) ; tokensRaised = tokensRaised . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; }
function anyTokenWithdrawal ( address _address , uint _amount ) public onlyOwner { require ( _address != address ( tokenReward ) ) ; StandardToken token = StandardToken ( _address ) ; token . transfer ( beneficiary , _amount ) ; TokensWithdraw ( beneficiary , _address , _amount ) ; }
function addRole ( address addr , string role ) public onlyOwnerOrAdmin { roles [ addr ] [ role ] = true ; emit RoleAdded ( addr , role ) ; }
function getFeeFlat ( Data storage self , address contractAddress ) internal view returns ( uint feeFlat ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.flat' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }
function getPreICOBonus ( ) internal constant returns ( uint ) { return 33 ; }
function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safeSub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function updateCounters ( uint256 _etherAmount ) internal ;
function extractBytes32 ( bytes _data , uint offset ) public pure returns ( bytes32 bs ) { require ( offset >= 0 && offset + 32 <= _data . length , "offset value should be in the correct range" ) ; assembly { bs := mload ( add ( _data , add ( 32 , offset ) ) ) } }
function getCurrencySymbol ( ) external view returns ( bytes32 ) { return bytes32 ( "ETH" ) ; }
function registerAudits ( bytes32 [ ] _codeHashes , bytes _reportIPFS , bool _isApproved ) public { for ( uint i = 0 ; i < _codeHashes . length ; i ++ ) { registerAudit ( _codeHashes [ i ] , _reportIPFS , _isApproved ) ; } }
function launchContract ( ) public onlyOwner returns ( bool launched ) { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; LaunchContract ( msg . sender , true ) ; return true ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _tokenId ) { require ( _index < balanceOf ( _owner ) ) ; return ownedTokens [ _owner ] [ _index ] ; }
function verifyTransfer ( address , address _to , uint256 , bytes , bool ) public returns ( Result ) { if ( ! paused ) { if ( maxHolderCount < ISecurityToken ( securityToken ) . getInvestorCount ( ) ) { if ( ISecurityToken ( securityToken ) . balanceOf ( _to ) != 0 ) { return Result . NA ; } return Result . INVALID ; } return Result . NA ; } return Result . NA ; }
function getStats ( uint256 _tokenId ) public view returns ( uint8 [ STATS_SIZE ] ) { return assets [ _tokenId ] . stats ; }
function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( saleAuction ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }
function addVest ( address _vester , uint256 _totalAmountToVest , uint256 [ ] _releaseDates , uint256 [ ] _releaseAmounts ) public nonActiveVester ( _vester ) onlyAdmin returns ( bool ) { require ( _releaseDates . length > 0 && _releaseAmounts . length > 0 && _totalAmountToVest > 0 , "attempting to use non zero values" ) ; require ( _releaseDates . length == _releaseAmounts . length , "array lengths are not equal" ) ; uint256 total ; for ( uint256 i = 0 ; i < _releaseAmounts . length ; i ++ ) { total = total . add ( _releaseAmounts [ i ] ) ; require ( now < _releaseDates [ i ] , "release date must be in the future" ) ; } require ( total == _totalAmountToVest , "invalid total amount to vest" ) ; Vest memory v = Vest ( { totalVest : _totalAmountToVest , releaseDates : _releaseDates , releaseAmounts : _releaseAmounts , state : VestState . vesting } ) ; vests [ _vester ] = v ; require ( RTI . transferFrom ( msg . sender , address ( this ) , _totalAmountToVest ) , "transfer from failed, most likely needs approval" ) ; return true ; }
function issueAndFreeze ( address _to , uint _value , uint _freezePeriod ) onlyOwner public { _transfer ( msg . sender , _to , _value ) ; freezeAccount [ _to ] = FreezeAccountInfo ( { freezeStartTime : now , freezePeriod : _freezePeriod , freezeTotal : _value } ) ; emit IssueAndFreeze ( _to , _value , _freezePeriod ) ; }
function acceptSellOffer ( uint32 _canvasId ) external payable stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; SellOffer memory sellOffer = canvasForSale [ _canvasId ] ; require ( msg . sender != canvas . owner ) ; require ( sellOffer . isForSale ) ; require ( msg . value >= sellOffer . minPrice ) ; require ( sellOffer . seller == canvas . owner ) ; require ( sellOffer . onlySellTo == 0x0 || sellOffer . onlySellTo == msg . sender ) ; uint toTransfer ; ( , , toTransfer ) = _registerTrade ( _canvasId , msg . value ) ; addPendingWithdrawal ( sellOffer . seller , toTransfer ) ; addressToCount [ canvas . owner ] -- ; addressToCount [ msg . sender ] ++ ; canvas . owner = msg . sender ; _cancelSellOfferInternal ( _canvasId , false ) ; emit CanvasSold ( _canvasId , msg . value , sellOffer . seller , msg . sender ) ; BuyOffer memory offer = buyOffers [ _canvasId ] ; if ( offer . buyer == msg . sender ) { buyOffers [ _canvasId ] = BuyOffer ( false , 0x0 , 0 ) ; if ( offer . amount > 0 ) { addPendingWithdrawal ( offer . buyer , offer . amount ) ; } } }
function addOwner ( address _who ) public onlyOwner returns ( bool ) { _setOwner ( _who , true ) ; }
function dissolveTokenGroup ( uint256 _tokenId ) external onlyCOO whenForking { var group = tokenIndexToGroup [ _tokenId ] ; require ( group . exists ) ; require ( group . purchasePrice == 0 ) ; for ( uint i = 0 ; i < tokenIndexToGroup [ _tokenId ] . contributorArr . length ; i ++ ) { address userAdd = tokenIndexToGroup [ _tokenId ] . contributorArr [ i ] ; var userContribution = group . addressToContribution [ userAdd ] ; _clearGroupRecordInContributor ( _tokenId , userAdd ) ; tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] = 0 ; tokenIndexToGroup [ _tokenId ] . addressToContributorArrIndex [ userAdd ] = 0 ; userAddressToContributor [ userAdd ] . withdrawableBalance += userContribution ; ProceedsDeposited ( _tokenId , userAdd , userContribution ) ; } activeGroups -= 1 ; tokenIndexToGroup [ _tokenId ] . exists = false ; }
function updateDetails ( bytes32 _details ) public returns ( bool allowed ) { require ( _details != 0x0 ) ; require ( owner == msg . sender ) ; bytes32 prevDetails = details ; details = _details ; DetailsUpdated ( prevDetails , details , now ) ; return true ; }
function addLocation ( uint _location ) onlyOwner public { locations . push ( _location ) ; }
function setMaxGasPrice ( uint256 _maxGasPrice ) public onlyOwner { maxGasPrice = _maxGasPrice ; }
function buy ( ) public payable { internalBuy ( msg . sender , msg . value , true ) ; }
function requestInvestment ( uint giveQuantity , uint shareQuantity , address investmentAsset ) external pre_cond ( ! isShutDown ) pre_cond ( isInvestAllowed [ investmentAsset ] ) pre_cond ( modules . compliance . isInvestmentPermitted ( msg . sender , giveQuantity , shareQuantity ) ) { requests . push ( Request ( { participant : msg . sender , status : RequestStatus . active , requestAsset : investmentAsset , shareQuantity : shareQuantity , giveQuantity : giveQuantity , receiveQuantity : shareQuantity , timestamp : now , atUpdateId : modules . pricefeed . getLastUpdateId ( ) } ) ) ; emit RequestUpdated ( getLastRequestId ( ) ) ; }
function withdraw ( uint64 idPledge , uint amount ) { idPledge = normalizePledge ( idPledge ) ; Pledge storage p = findPledge ( idPledge ) ; require ( p . pledgeState == PledgeState . Pledged ) ; PledgeAdmin storage owner = findAdmin ( p . owner ) ; checkAdminOwner ( owner ) ; uint64 idNewPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Paying ) ; doTransfer ( idPledge , idNewPledge , amount ) ; vault . authorizePayment ( bytes32 ( idNewPledge ) , owner . addr , amount ) ; }
function getPendingManager ( ) public view returns ( address ) { return pendingManager ; }
function getPlotData ( uint256 plotIndex ) public view returns ( string ipfsHash , string url , bool plotBlocked ) { require ( plotIndex < ownership . length ) ; return ( data [ plotIndex ] . url , data [ plotIndex ] . ipfsHash , plotBlockedTags [ plotIndex ] ) ; }
function changeFactorySubscriptionFee ( uint256 _newSubscriptionCost ) external ;
function _processBonus ( address _beneficiary , uint256 _tokenAmount ) internal { uint256 bonusTokens = getBonusTokens ( _tokenAmount ) ; if ( BONUS_TOKENS < bonusTokens ) { bonusTokens = BONUS_TOKENS ; } if ( bonusTokens > 0 ) { BONUS_TOKENS = BONUS_TOKENS . sub ( bonusTokens ) ; token . transfer ( _beneficiary , bonusTokens ) ; emit BonusSent ( address ( token ) , _beneficiary , _tokenAmount , bonusTokens ) ; tokensSold = tokensSold . add ( bonusTokens ) ; } }
function setOracleQueryType ( string _oracleQueryType ) onlyOwner public { oracleQueryType = _oracleQueryType ; }
function release ( address account ) public isVestedAccount ( account ) { uint256 unreleased = releasableAmount ( account ) ; require ( unreleased > 0 ) ; beneficiary [ account ] . releasedAmount = beneficiary [ account ] . releasedAmount . add ( unreleased ) ; token . transfer ( account , unreleased ) ; emit Released ( account , unreleased ) ; if ( beneficiary [ account ] . releasedAmount == beneficiary [ account ] . totalAmount ) { delete beneficiary [ account ] ; } }
function setRentAuctionContractAddress ( address _address ) external onlyOwner { RentAuction _contract = RentAuction ( _address ) ; require ( _contract . isRentAuction ( ) ) ; rentAuctionContract = _contract ; }
function seal ( ) { if ( now < endFundingTime ) throw ; tokenContract . seal ( ) ; }
function setTokensContract ( address _addressSCTokens ) public onlyOwner { addressSCTokens = _addressSCTokens ; SCTokens = Tokens ( _addressSCTokens ) ; }
function mintToken ( address _target , uint _mintedAmount ) onlyOwner public { balances [ _target ] = balances [ _target ] . add ( _mintedAmount ) ; _totalSupply = _totalSupply . add ( _mintedAmount ) ; Transfer ( address ( 0 ) , _target , _mintedAmount ) ; }
function withdrawERC20 ( address _tokenContract , uint256 _value ) external ;
function getCurrentSellOffer ( uint32 _canvasId ) external view returns ( bool isForSale , address seller , uint minPrice , address onlySellTo ) { SellOffer storage offer = canvasForSale [ _canvasId ] ; return ( offer . isForSale , offer . seller , offer . minPrice , offer . onlySellTo ) ; }
function onERC721Received ( address _from , uint256 _tokenId , bytes _data ) public returns ( bytes4 ) ;
function tokenPriceInEuroCents ( ) public constant returns ( uint ) ;
function addToAccountList ( address addr ) internal { require ( ! readOnly , "Read only mode engaged" ) ; addressLinkedList [ addr ] = addressLinkedList [ 0x0 ] ; addressLinkedList [ 0x0 ] = addr ; accountCount ++ ; }
function mintPartOfEmission ( address to , uint part , uint partOfEmissionForPublicSales ) public payloadSizeIs ( 32 * 3 ) validAddress ( to ) requiresState ( State . MINTING2POOLS ) onlyBy ( m_pools ) { uint poolTokens = m_publiclyDistributedTokens . mul ( part ) . div ( partOfEmissionForPublicSales ) ; m_SMR . mint ( to , poolTokens ) ; }
function updateCurrentGameCardId ( uint256 _gameCardNumber , uint256 _playerId ) public whenNotPaused { require ( contractsApprovedList [ msg . sender ] ) ; NFT memory obj = _getAttributesOfToken ( _playerId ) ; obj . currentGameCardId = _gameCardNumber ; if ( _gameCardNumber == 0 ) { obj . isAttached = 0 ; } else { obj . isAttached = 1 ; } allNFTs [ _playerId ] = obj ; }
function removeAsset ( address ofAsset , uint assetIndex ) auth pre_cond ( assetInformation [ ofAsset ] . exists ) { require ( registeredAssets [ assetIndex ] == ofAsset ) ; delete assetInformation [ ofAsset ] ; delete registeredAssets [ assetIndex ] ; for ( uint i = assetIndex ; i < registeredAssets . length - 1 ; i ++ ) { registeredAssets [ i ] = registeredAssets [ i + 1 ] ; } registeredAssets . length -- ; assert ( ! assetInformation [ ofAsset ] . exists ) ; }
function numberOfAuthorizedPayments ( ) public view returns ( uint ) { return authorizedPayments . length ; }
function setGameStarterDividendPercentage ( uint256 _gameStarterDividendPercentage ) external onlyCFO { require ( 500 <= _gameStarterDividendPercentage && _gameStarterDividendPercentage <= 4000 ) ; gameStarterDividendPercentage = _gameStarterDividendPercentage ; }
function balanceOf ( address _owner ) public view returns ( uint count ) { return howManyDoYouHave [ _owner ] ; }
function addPoll ( uint _startBlock , uint _endBlock , bytes _description , uint8 _numBallots ) public onlySNTHolder returns ( uint _idPoll ) { require ( _endBlock > block . number , "End block must be greater than current block" ) ; require ( _startBlock >= block . number && _startBlock < _endBlock , "Start block must not be in the past, and should be less than the end block" ) ; require ( _numBallots <= 15 , "Only a max of 15 ballots are allowed" ) ; _idPoll = _polls . length ; _polls . length ++ ; Poll storage p = _polls [ _idPoll ] ; p . startBlock = _startBlock ; p . endBlock = _endBlock ; p . voters = 0 ; p . numBallots = _numBallots ; p . description = _description ; p . author = msg . sender ; emit PollCreated ( _idPoll ) ; }
function transferFrom ( address from , address to , uint256 value ) returns ( bool ) { if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value && safeAdd ( balances [ to ] , value ) > balances [ to ] ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { return false ; } }
function isMakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { return true ; }
function totalSupply ( ) public view returns ( uint256 _supply ) ;
function updateCounters ( uint256 _etherAmount ) internal { totalEtherPaid = totalEtherPaid . add ( _etherAmount ) ; }
function renameCollection ( uint64 _collectionIndex , bytes8 _name ) validIndex ( _collectionIndex ) public returns ( uint64 ) { require ( _collectionIndex < totalCollections ( ) , "Collection does not exist" ) ; uint64 [ ] storage collection = collectionTokens [ _collectionIndex ] ; require ( collection . length > 0 , "Collection has been cleared" ) ; for ( uint i = 0 ; i < collection . length ; i ++ ) { PixelCon storage pixelcon = pixelcons [ collection [ i ] ] ; require ( isCreatorAndOwner ( msg . sender , pixelcon . tokenId ) , "Sender is not the creator and owner of the PixelCons" ) ; } collectionNames [ _collectionIndex ] = _name ; emit RenameCollection ( _collectionIndex , _name ) ; return _collectionIndex ; }
function setLastBidId ( bytes32 _newBidId ) internal { lastBidId = _newBidId ; }
function calculateTimeout ( ) public view returns ( uint256 ) { if ( wagerIndex >= numberOfWagersToMinimumTimeout || numberOfWagersToMinimumTimeout == 0 ) { return minimumTimeout ; } else { uint256 difference = timeout - minimumTimeout ; uint256 decrease = difference . mul ( wagerIndex ) . div ( numberOfWagersToMinimumTimeout ) ; return ( timeout - decrease ) ; } }
function getVaultBalance ( ) onlyAllowedAddresses public constant returns ( uint256 ) { return rntToken . balanceOf ( ) ; }
function getInstructions ( ) public view returns ( string ) { return "Add and remove permissions for the SecurityToken and associated modules. Permission types should be encoded as bytes32 values, and attached using the withPerm modifier to relevant functions.No initFunction required." ; }
function partyHash ( address address_one , address address_two ) internal constant returns ( bytes32 ) { if ( address_one < address_two ) { return sha3 ( address_one , address_two ) ; } else { return sha3 ( address_two , address_one ) ; } }
function setGameStarterDividendPercentage ( uint256 _gameStarterDividendPercentage ) external onlyCFO { require ( 500 <= _gameStarterDividendPercentage && _gameStarterDividendPercentage <= 5000 ) ; gameStarterDividendPercentage = _gameStarterDividendPercentage ; }
function setPoolToOpen ( ) public isAdmin isClosed { state = PoolState . OPEN ; emit PoolIsOpen ( ) ; }
function pause ( ) public onlyOwner { require ( now < endTime ) ; super . _pause ( ) ; }
function withdrawFreeBalance ( ) external onlyCFO { uint256 freeBalance = this . balance . sub ( totalPayments ) . sub ( prizePool ) . sub ( wagerPool ) ; cfoAddress . transfer ( freeBalance ) ; }
function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner { requireMultiple ( _amount ) ; mTotalSupply = mTotalSupply . add ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , "" , _operatorData , true ) ; emit Minted ( msg . sender , _tokenHolder , _amount , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( 0x0 , _tokenHolder , _amount ) ; } }
function getTagsByType ( uint8 _moduleType ) external view returns ( bytes32 [ ] , address [ ] ) { address [ ] memory modules = getModulesByType ( _moduleType ) ; return _tagsByModules ( modules ) ; }
function getTotalDepositsAmountLeft ( ) public view returns ( uint _amount ) { uint _lastDepositDate = lastDepositDate ; for ( uint _startDate = firstDepositDate ; _startDate <= _lastDepositDate || _startDate != 0 ; _startDate = distributionDeposits [ _startDate ] . nextDepositDate ) { _amount = _amount . add ( distributionDeposits [ _startDate ] . left ) ; } }
function allowTransfers ( bool _transferable ) onlyController { transferable = _transferable ; }
function callWithdraw ( address realitycheck ) onlyOwner public { RealityCheckAPI ( realitycheck ) . withdraw ( ) ; }
function unpause ( ) public onlyCEO whenPaused { paused = false ; Unpaused ( ) ; }
function getEuroCollected ( ) public constant returns ( uint ) { return wei2euroCents ( getWeiCollected ( ) ) . div ( 100 ) ; }
function getTokenMinted ( ) public constant returns ( uint ) ;
function getBuyPrices ( uint256 _gameID , uint256 [ ] memory _keys ) public view isActivated ( _gameID ) returns ( uint256 , uint256 [ ] ) { uint256 _totalEth = 0 ; uint256 _nt = game_ [ _gameID ] . numberOfTeams ; uint256 [ ] memory _eth = new uint256 [ ] ( _nt ) ; uint256 i ; require ( _nt == _keys . length , "Incorrect number of teams" ) ; for ( i = 0 ; i < _nt ; i ++ ) { if ( _keys [ i ] > 0 ) { _eth [ i ] = getBuyPrice ( _gameID , i , _keys [ i ] ) ; _totalEth = _totalEth . add ( _eth [ i ] ) ; } } return ( _totalEth , _eth ) ; }
function convertToUSD ( FundRaiseType _fundRaiseType , uint256 _amount ) public view returns ( uint256 ) { uint256 rate = getRate ( _fundRaiseType ) ; return DecimalMath . mul ( _amount , rate ) ; }
function unlock ( ) external { require ( block . number > unlockedAtBlockNumber ) ; if ( ! synchroCoin . transfer ( businessAddress , synchroCoin . balanceOf ( this ) ) ) revert ( ) ; }
function listAcceptedTokens ( ) public view returns ( address [ ] ) { return tokensList ; }
function retrieveFunds ( ) public onlyController { uint sntBalance = SNT . balanceOf ( address ( this ) ) ; require ( SNT . transfer ( msg . sender , sntBalance ) , "Transfer did not work" ) ; selfdestruct ( msg . sender ) ; }
function getListing ( uint64 _pixelconIndex ) public view returns ( address _seller , uint256 _startPrice , uint256 _endPrice , uint256 _currPrice , uint64 _startDate , uint64 _duration , uint64 _timeLeft ) { Listing storage listing = marketPixelconListings [ _pixelconIndex ] ; require ( listing . seller != address ( 0 ) , "Market listing does not exist" ) ; _seller = listing . seller ; _startPrice = uint256 ( listing . startAmount ) * WEI_PER_GWEI ; _endPrice = uint256 ( listing . endAmount ) * WEI_PER_GWEI ; _currPrice = calcCurrentPrice ( uint256 ( listing . startAmount ) , uint256 ( listing . endAmount ) , uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; _startDate = listing . startDate ; _duration = listing . duration ; _timeLeft = calcTimeLeft ( uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; }
function setAllowance ( address _owner , address _spender , uint256 _value ) public onlyImpl { allowed [ _owner ] [ _spender ] = _value ; }
function cancelOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { revert ( ) ; }
function propExists ( bytes32 _propID ) view public returns ( bool ) { return proposals [ _propID ] . processBy > 0 ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }
function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return ownerOperators [ _owner ] [ _operator ] ; }
function newRepoWithVersion ( string _name , address _dev , uint16 [ 3 ] _initialSemanticVersion , address _contractAddress , bytes _contentURI ) public auth ( CREATE_REPO_ROLE ) returns ( Repo ) { Repo repo = _newRepo ( _name , this ) ; repo . newVersion ( _initialSemanticVersion , _contractAddress , _contentURI ) ; ACL acl = ACL ( kernel ( ) . acl ( ) ) ; acl . revokePermission ( this , repo , repo . CREATE_VERSION_ROLE ( ) ) ; acl . grantPermission ( _dev , repo , repo . CREATE_VERSION_ROLE ( ) ) ; acl . setPermissionManager ( _dev , repo , repo . CREATE_VERSION_ROLE ( ) ) ; return repo ; }
function newDaoRulesProposal ( uint _minQuorumDivisor , uint _minBoardMeetingFees , uint _minutesSetProposalPeriod , uint _minMinutesDebatePeriod , uint _feesRewardInflationRate , bool _transferable , address _dao , uint _minutesDebatingPeriod ) payable returns ( uint ) ;
function withdrawPool ( uint256 amountToWithdraw ) public onlyOwner { if ( amountToWithdraw > 0 ) { require ( totalPoolBalance >= amountToWithdraw && ixtToken . transfer ( msg . sender , amountToWithdraw ) , "Unable to withdraw this value of IXT." ) ; totalPoolBalance = SafeMath . sub ( totalPoolBalance , amountToWithdraw ) ; } emit PoolWithdraw ( msg . sender , amountToWithdraw ) ; }
function withdrawByAdmin_Unau ( uint256 [ ] inputs ) external onlyAdmin { uint256 amount = inputs [ 0 ] ; uint256 gasFee = inputs [ 1 ] ; uint256 data = inputs [ 2 ] ; uint256 paymentMethod = data & PAYMENT_METHOD_MASK ; address token = tokenId2Address [ ( data & WITHDRAW_TOKEN_MASK ) >> 32 ] ; address user = userId2Address [ data & USER_MASK ] ; bytes32 hash = keccak256 ( this , amount , gasFee , data & SIGN_MASK | uint256 ( token ) ) ; require ( ! usedHash [ hash ] ) ; require ( verify ( hash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ 3 ] ) , bytes32 ( inputs [ 4 ] ) ) ) ; address gasToken = 0 ; if ( paymentMethod == PAY_BY_JOY ) { gasToken = joyToken ; } else if ( paymentMethod == PAY_BY_TOKEN ) { gasToken = token ; } if ( gasToken == token ) { balances [ token ] [ user ] = balances [ token ] [ user ] . sub ( amount . add ( gasFee ) ) ; } else { balances [ token ] [ user ] = balances [ token ] [ user ] . sub ( amount ) ; balances [ gasToken ] [ user ] = balances [ gasToken ] [ user ] . sub ( gasFee ) ; } balances [ gasToken ] [ joysoWallet ] = balances [ gasToken ] [ joysoWallet ] . add ( gasFee ) ; usedHash [ hash ] = true ; if ( token == 0 ) { user . transfer ( amount ) ; } else { require ( ERC20 ( token ) . transfer ( user , amount ) ) ; } }
function getBudget ( Campaign storage _campaign ) internal view returns ( uint _budget ) { return _campaign . budget ; }
function approve ( address _spender , uint256 _value ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) ) ; return super . approve ( _spender , _value ) ; }
function CancelAuction ( ) public isOwner atStage ( Stages . AuctionStarted ) { token . transfer ( walletAddress , numTokensAuctioned ) ; stage = Stages . AuctionCanceled ; AuctionCanceled ( ) ; }
function computeStablecoinFee ( uint256 _amount , address _stablecoin ) public view returns ( uint256 ) { uint256 fee = fees [ _stablecoin ] ; return computeFee ( _amount , fee ) ; }
function finalizePresale ( ) whenNotPaused onlyOwner external { require ( isPresaleStarted && ! isPresaleFinalized ) ; require ( presaleFinalizeAgent . isSane ( ) ) ; uint256 presaleSupply = token . totalSupply ( ) ; presaleSupply = presaleSupply . div ( 5 ) ; presaleFinalizeAgent . finalizePresale ( presaleSupply ) ; uint tokenWei = presaleFinalizeAgent . weiPerToken ( ) ; pricingStrategy . setTokenPriceInWei ( tokenWei ) ; TokensPerWeiReceived ( tokenWei ) ; require ( tokenWei > 0 ) ; currentStatus = Status . Unknown ; isPresaleFinalized = true ; presaleEndTime = now ; PresaleFinalized ( presaleEndTime ) ; }
function getPayeeExpectedAmount ( bytes32 _requestId , uint8 _payeeIndex ) public view returns ( int256 ) { if ( _payeeIndex == 0 ) { return requests [ _requestId ] . payee . expectedAmount ; } else { return subPayees [ _requestId ] [ _payeeIndex - 1 ] . expectedAmount ; } }
function tokensup ( uint256 _value ) onlyowner public { totalHurify = safeAdd ( totalHurify , _value * ( 10 ** decimals ) ) ; balances [ owner ] = safeAdd ( balances [ owner ] , _value * ( 10 ** decimals ) ) ; }
function getState ( ) public constant returns ( State ) { if ( finalizedCrowdfunding ) return State . Success ; if ( block . number < fundingStartBlock ) return State . PreFunding ; else if ( block . number <= fundingEndBlock && totalSupply < tokenCreationMax ) return State . Funding ; else if ( totalSupply >= tokenCreationMin ) return State . Success ; else return State . Failure ; }
function getPartialAmount ( uint numerator , uint denominator , uint target ) public pure returns ( uint ) { return numerator . mul ( target ) . div ( denominator ) ; }
function BTImint ( address _client , uint256 _value ) onlyowner public { require ( totalToken <= totalBhinneka ) ; uint256 numBTI = _value * ( 10 ** decimals ) ; balances [ owner ] = safeSub ( balances [ owner ] , numBTI ) ; balances [ _client ] = safeAdd ( balances [ _client ] , numBTI ) ; totalToken = safeAdd ( totalToken , numBTI ) ; Transfer ( owner , _client , numBTI ) ; }
function addBounty ( address _hunter , uint256 _amount ) onlyOwner public { require ( _hunter != 0x0 ) ; require ( toWei ( _amount ) <= safeSub ( bonusAndBountyTokens , toWei ( _amount ) ) ) ; bounties [ _hunter ] = safeAdd ( bounties [ _hunter ] , toWei ( _amount ) ) ; bonusAndBountyTokens = safeSub ( bonusAndBountyTokens , toWei ( _amount ) ) ; emit AddBounty ( _hunter , toWei ( _amount ) ) ; }
function onApprove ( address _owner , address _spender , uint256 _amount ) returns ( bool ) ;
function _checkSig ( bytes32 _hash , uint8 _v , bytes32 _r , bytes32 _s ) internal view { address signer = ecrecover ( keccak256 ( abi . encodePacked ( "\x19Ethereum Signed Message:\n32" , _hash ) ) , _v , _r , _s ) ; require ( signer == Ownable ( securityToken ) . owner ( ) || signer == signingAddress , "Incorrect signer" ) ; }
function _sameClassAxiesPrice ( uint8 _class , uint256 _quantity ) private view returns ( uint256 _totalPrice , uint256 _currentIncrement , uint256 _currentPrice ) { _currentIncrement = priceIncrement [ _class ] ; _currentPrice = currentPrice [ _class ] ; uint256 _nextPrice ; for ( uint256 i = 0 ; i < _quantity ; i ++ ) { _totalPrice = _totalPrice . add ( _currentPrice ) ; _nextPrice = _currentPrice . add ( _currentIncrement ) ; if ( _nextPrice / 100 finney != _currentPrice / 100 finney ) { _currentIncrement >>= 1 ; } _currentPrice = _nextPrice ; } }
function decreaseApproval ( address _spender , uint256 _subtractedValue ) public canTransfer ( msg . sender ) whenNotPaused returns ( bool ) { require ( _spender != address ( 0 ) ) ; return super . decreaseApproval ( _spender , _subtractedValue ) ; }
function setTransferEnabled ( bool enable ) onlyOwner public { token . setTransferEnabled ( enable ) ; }
function balanceOf ( address who ) public view returns ( uint256 ) { return isOwner ( who ) ? m_SMR . balanceOf ( this ) : 0 ; }
function sendTokens ( address msg_sender , uint msg_value ) internal { var prices = price1stWeek ; if ( now >= startTime + 2 weeks ) prices = price3rdWeek ; else if ( now >= startTime + 1 weeks ) prices = price2ndWeek ; uint currentPrice = prices [ 0 ] ; if ( balanceOf [ msg_sender ] + msg_value >= discountValue5 ) { currentPrice = prices [ 1 ] ; if ( balanceOf [ msg_sender ] + msg_value >= discountValue10 ) currentPrice = prices [ 2 ] ; } uint amountSendTokens = msg_value / currentPrice ; if ( amountSendTokens > ( tokensAvailableForSale - tokensSoldOnPublicRound ) ) { uint tokensAvailable = tokensAvailableForSale - tokensSoldOnPublicRound ; uint refund = msg_value - ( tokensAvailable * currentPrice ) ; amountSendTokens = tokensAvailable ; tokensSoldOnPublicRound += amountSendTokens ; msg_sender . transfer ( refund ) ; balanceOf [ msg_sender ] += ( msg_value - refund ) ; } else { tokensSoldOnPublicRound += amountSendTokens ; balanceOf [ msg_sender ] += msg_value ; } tokenReward . transfer ( msg_sender , amountSendTokens ) ; DGZTokensSold ( msg_sender , amountSendTokens ) ; }
function enableTransfers ( bool _transfersEnabled ) ownerOrController public { transfersEnabled = _transfersEnabled ; }
function changeTitle ( string _newTitle ) public onlyOwner { require ( bytes ( _newTitle ) . length > 0 , "Invalid title" ) ; title = _newTitle ; }
function submitLocation ( uint encryptKey , uint8 locationNumber ) public payable { require ( encryptKey != 0 ) ; require ( locationNumber < locations . length ) ; if ( ! grace ) { require ( msg . value >= cost ) ; uint contribution = cost - cost / 10 ; ownersBalance += cost - contribution ; pot += contribution ; } hunters [ msg . sender ] [ locationNumber ] = KeyLog ( encryptKey , block . number ) ; }
function setBTHFoundationWallet ( address _wallet ) external onlymanyowners ( sha3 ( msg . data ) ) nonZeroAddress ( _wallet ) { bthFoundationWallet = _wallet ; LogBTHFoundationWalletChanged ( _wallet ) ; }
function requestRedemption ( uint shareQuantity , uint receiveQuantity , bool isNativeAsset ) external pre_cond ( ! isShutDown ) pre_cond ( isRedeemAllowed ) pre_cond ( module . compliance . isRedemptionPermitted ( msg . sender , shareQuantity , receiveQuantity ) ) { requests . push ( Request ( { participant : msg . sender , status : RequestStatus . active , requestType : RequestType . redeem , requestAsset : isNativeAsset ? address ( NATIVE_ASSET ) : address ( QUOTE_ASSET ) , shareQuantity : shareQuantity , giveQuantity : shareQuantity , receiveQuantity : receiveQuantity , timestamp : now , atUpdateId : module . pricefeed . getLastUpdateId ( ) } ) ) ; RequestUpdated ( getLastRequestId ( ) ) ; }
function mint ( address _holder , uint256 _tokens ) public onlyMintingAgents ( ) { require ( allowedMinting == true && totalSupply_ . add ( _tokens ) <= maxSupply ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ _holder ] = balanceOf ( _holder ) . add ( _tokens ) ; if ( totalSupply_ == maxSupply ) { allowedMinting = false ; } emit Mint ( _holder , _tokens ) ; }
function bulkTransfer ( address [ ] _destinations , uint256 [ ] _amounts ) public onlyAdmin { require ( _destinations . length == _amounts . length ) ; uint256 requiredBalance = sumOf ( _amounts ) ; require ( balances [ msg . sender ] >= requiredBalance ) ; for ( uint256 i = 0 ; i < _destinations . length ; i ++ ) { transfer ( _destinations [ i ] , _amounts [ i ] ) ; } emit BulkTransferPerformed ( _destinations , _amounts ) ; }
function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( saleAuction ) ) ; require ( _to != address ( siringAuction ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function getDescription ( ) public view returns ( string ) { return "Create ETH dividends for token holders at a specific checkpoint" ; }
function doBuy ( address _caller , uint256 etherAmount ) internal { Contribution ( etherAmount , _caller ) ; uint256 callerTokens = etherAmount . mul ( CALLER_EXCHANGE_RATE ) ; uint256 callerTokensWithDiscount = applyDiscount ( etherAmount , callerTokens ) ; uint256 reserveTokens = etherAmount . mul ( RESERVE_EXCHANGE_RATE ) ; uint256 founderTokens = etherAmount . mul ( FOUNDER_EXCHANGE_RATE ) ; uint256 bountyTokens = etherAmount . mul ( BOUNTY_EXCHANGE_RATE ) ; uint256 vestingTokens = founderTokens . add ( reserveTokens ) ; founderTokenCount = founderTokenCount . add ( founderTokens ) ; reserveTokenCount = reserveTokenCount . add ( reserveTokens ) ; payAffiliate ( callerTokensWithDiscount , msg . value , msg . sender ) ; shp . generateTokens ( _caller , callerTokensWithDiscount ) ; shp . generateTokens ( bountyAddress , bountyTokens ) ; shp . generateTokens ( trusteeAddress , vestingTokens ) ; NewSale ( _caller , etherAmount , callerTokensWithDiscount ) ; NewSale ( trusteeAddress , etherAmount , vestingTokens ) ; NewSale ( bountyAddress , etherAmount , bountyTokens ) ; etherEscrowAddress . transfer ( etherAmount ) ; updateCounters ( etherAmount ) ; }
function setRenewable ( uint256 _productId , bool _newRenewable ) external onlyCLevel { _setRenewable ( _productId , _newRenewable ) ; ProductRenewableChanged ( _productId , _newRenewable ) ; }
function allocate ( ) external { uint256 unallocated = address ( this ) . balance . sub ( balanceTotal ) ; require ( unallocated > 0 , "No funds to allocate" ) ; uint256 num_recipients = recipients . length ; uint256 each = unallocated / num_recipients ; require ( each > 0 , "No money left to be allocated after rounding down" ) ; uint256 i ; for ( i = 0 ; i < num_recipients ; i ++ ) { address recip = recipients [ i ] ; balanceOf [ recip ] = balanceOf [ recip ] . add ( each ) ; balanceTotal = balanceTotal . add ( each ) ; } assert ( address ( this ) . balance >= balanceTotal ) ; }
function quoteBid ( ) private returns ( uint256 ) { if ( initialSaleComplete ) { bid = fracExp ( 1e16 , R , ( _totalSupply / 1e16 ) - 1 , P ) ; } else { bid = ICObid ; } return bid ; }
function addVineyardEndorsement ( string _mappingID , uint _index , bool positive , string title , string description ) external returns ( bool success ) { vineyardEndorsements [ keccak256 ( _mappingID , _index ) ] . push ( Endorsement ( positive , title , description , msg . sender ) ) ; return true ; }
function get ( MapStorage storage self , uint index ) public view returns ( address ) { require ( index < self . addresses . length ) ; return self . addresses [ index ] ; }
function transferToGrant ( uint256 _id , uint256 _amount ) public onlyOwner { require ( _id < tokenGrants . length && _amount > 0 && now <= tokenGrants [ _id ] . start ( ) ) ; require ( ethealToken . transfer ( address ( tokenGrants [ _id ] ) , _amount ) ) ; }
function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = propertyIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
function releaseToAdvisor ( address _beneficiary , uint256 _releaseAmount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , "Beneficiary is not whitelisted" ) ; require ( now >= releaseTimeToUnlockAdvisorTokens , "Release Advisor tokens on or after GMT: Wednesday, 21 August 2019 00:00:00" ) ; uint256 releaseAmount = _releaseAmount . mul ( E18 ) ; require ( totalTokensIssuedToAdvisor . add ( releaseAmount ) <= ADVISORS_SUPPLY_LIMIT ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( releaseAmount ) ; totalTokensIssuedToAdvisor = totalTokensIssuedToAdvisor . add ( releaseAmount ) ; emit Released ( _releaseAmount ) ; }
function convertSafe ( TokenConverter converter , Token from , Token to , uint256 amount ) internal returns ( uint256 bought ) { require ( from . approve ( converter , amount ) , "Error approve convert safe" ) ; uint256 prevBalance = to . balanceOf ( this ) ; bought = converter . convert ( from , to , amount , 1 ) ; require ( to . balanceOf ( this ) . sub ( prevBalance ) >= bought , "Bought amount incorrect" ) ; require ( from . approve ( converter , 0 ) , "Error remove approve convert safe" ) ; }
function cancelAuction ( uint256 _axieId ) external { Auction storage _auction = auctions [ _axieId ] ; require ( _isOnAuction ( _auction ) ) ; require ( msg . sender == _auction . seller ) ; _cancelAuction ( _axieId , _auction . seller ) ; }
function ( ) payable { buy ( ) ; }
function removeBlacklistedUser ( address _who ) public onlyValidator { _removeBlacklistedUser ( _who ) ; }
function updateEthUsdManually ( uint _newEthUsd ) public onlyOwner { require ( _newEthUsd > 0 ) ; uint256 newRate = _newEthUsd . mul ( 10 ** 18 ) ; require ( newRate > 0 ) ; ethUsd = newRate ; }
function updateMinimumBond ( uint256 _nextMinimumBond ) external onlyOwner { nextMinimumBond = _nextMinimumBond ; }
function getChannelWith ( Data storage self , address partner ) constant returns ( address ) { bytes32 party_hash = partyHash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; if ( channel_pos != 0 ) { return self . all_channels [ channel_pos - 1 ] ; } }
function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external { _safeTransferFrom ( _from , _to , _tokenId , "" ) ; }
function removeUserPermission ( address _who , bytes4 _methodsignature ) public onlyValidator { require ( permissions [ _methodsignature ] . active , "Permission being removed must be for a valid method signature" ) ; userPermissions [ _who ] [ _methodsignature ] = false ; }
function getCertification ( address student ) payable requestFeePaid returns ( bool certified , uint256 timestamp , address certifier , uint256 documentCount ) { Certification certification = studentCertifications [ student ] ; return ( certification . certified , certification . timestamp , certification . certifier , certification . documents . length ) ; }
function milestoneCompleted ( uint _idMilestone ) onlyRecipient campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) throw ; if ( now < milestone . minCompletionDate ) throw ; if ( now > milestone . maxCompletionDate ) throw ; milestone . status = MilestoneStatus . Completed ; milestone . doneTime = now ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }
function approve ( address _approved , uint256 _tokenId ) external canOperate ( _tokenId ) validNFToken ( _tokenId ) { address tokenOwner = idToOwner [ _tokenId ] ; require ( _approved != tokenOwner ) ; idToApprovals [ _tokenId ] = _approved ; emit Approval ( tokenOwner , _approved , _tokenId ) ; }
function worktimeAtDate ( uint256 _collected_at ) public view returns ( uint256 ) { return ( now - _collected_at ) / 60 ; }
function approveAndCall ( address spender , uint256 amount , bytes extraData ) public returns ( bool success ) ;
function ownerWithdraw ( uint256 value ) external onlyOwner { if ( now <= PRESALE_END_DATE ) throw ; if ( totalFunding < PRESALE_MINIMUM_FUNDING ) throw ; if ( ! owner . send ( value ) ) throw ; }
function isUserEnabledForContract ( address marketContractAddress , address userAddress ) external view returns ( bool ) { return contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ userAddress ] >= lockQtyToAllowTrading ; }
function acceptOwnership ( ) public { require ( msg . sender == newOwner ) ; OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalLoans = loans . length - 1 ; uint256 resultIndex = 0 ; uint256 loanId ; for ( loanId = 0 ; loanId <= totalLoans ; loanId ++ ) { if ( loans [ loanId ] . lender == _owner && loans [ loanId ] . status == Status . lent ) { result [ resultIndex ] = loanId ; resultIndex ++ ; } } return result ; } }
function _setCampaign ( bytes32 bidId , uint price , uint budget , uint startDate , uint endDate , bool valid , address owner ) public onlyIfWhitelisted ( "setCampaign" , msg . sender ) { CampaignLibrary . Campaign storage campaign = campaigns [ bidId ] ; campaign . setBidId ( bidId ) ; campaign . setPrice ( price ) ; campaign . setBudget ( budget ) ; campaign . setStartDate ( startDate ) ; campaign . setEndDate ( endDate ) ; campaign . setValidity ( valid ) ; bool newCampaign = ( campaigns [ bidId ] . getOwner ( ) == 0x0 ) ; campaign . setOwner ( owner ) ; if ( newCampaign ) { emitCampaignCreated ( campaign ) ; setLastBidId ( bidId ) ; } else { emitCampaignUpdated ( campaign ) ; } }
function getFirmFromAuthority ( Data storage self , address authorityAddress ) internal view returns ( string issuerFirm ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.authority.firm' , getForwardedAccount ( self , authorityAddress ) ) ) ; return self . Storage . getString ( id ) ; }
function changeOwner ( address _newOwner ) onlyOwner { newOwner = _newOwner ; }
function getAuditOutcome ( address _auditor , bytes32 _codeHash ) public view returns ( uint8 ) { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; return Audits [ hashAuditorCode ] . outcome ; }
function setMinter ( address _minter ) external onlyOwner validAddress ( _minter ) { minter = _minter ; }
function verifyTransfer ( address , address _to , uint256 _amount , bool ) public returns ( Result ) { if ( ! paused ) { if ( whitelist [ _to ] ) { return Result . NA ; } uint256 newBalance = ISecurityToken ( securityToken ) . balanceOf ( _to ) . add ( _amount ) ; if ( newBalance . mul ( 10 ** uint256 ( ISecurityToken ( securityToken ) . decimals ( ) ) ) . div ( ISecurityToken ( securityToken ) . totalSupply ( ) ) > maxHolderPercentage ) { return Result . INVALID ; } return Result . NA ; } return Result . NA ; }
function getName ( ) public view returns ( bytes32 ) { return "CappedSTO" ; }
function setQuestionFee ( uint256 fee ) onlyOwner public { realitycheck . setQuestionFee ( fee ) ; LogSetQuestionFee ( fee ) ; }
function changeAccredited ( address [ ] _investors , bool [ ] _accredited ) public onlyOwner { require ( _investors . length == _accredited . length , "Array length mismatch" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { accredited [ _investors [ i ] ] = _accredited [ i ] ; emit SetAccredited ( _investors [ i ] , _accredited [ i ] ) ; } }
function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( siringAuction != address ( 0 ) ) ; require ( geneScience != address ( 0 ) ) ; require ( lottery != address ( 0 ) ) ; require ( variation != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
function verifyModule ( address _moduleFactory , bool _verified ) external onlyOwner { require ( getUint ( Encoder . getKey ( "registry" , _moduleFactory ) ) != uint256 ( 0 ) , "Module factory must be registered" ) ; set ( Encoder . getKey ( "verified" , _moduleFactory ) , _verified ) ; emit ModuleVerified ( _moduleFactory , _verified ) ; }
function supportsInterface ( bytes4 _interfaceId ) external view returns ( bool ) ;
function withdrawAll ( ) { Splitter . withdrawInternal ( 0 , true ) ; }
function transfer ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { require ( _to != address ( 0 ) , "to address cannot be 0x0" ) ; require ( _amount <= balanceOf ( msg . sender ) , "not enough balance to transfer" ) ; tokenStorage . subBalance ( msg . sender , _amount ) ; tokenStorage . addBalance ( _to , _amount ) ; emit Transfer ( msg . sender , _to , _amount ) ; return true ; }
function requestTokenPayment ( address _payer , address _receiver , uint256 _amount , bytes32 _nonce , bytes _paymentSig ) external onlyAttestationLogic { validatePaymentSig ( _payer , _receiver , _amount , _nonce , _paymentSig ) ; payTokensFromEscrow ( _payer , _receiver , _amount ) ; emit TokenMarketplaceEscrowPayment ( _payer , _receiver , _amount ) ; }
function approvePreSignedHashing ( address _token , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0xf7ac9c2e ) , _token , _spender , _value , _fee , _nonce ) ; }
function isDataResponseValid ( address order , address seller , address notary , string dataHash , bytes signature ) public pure returns ( bool ) { require ( order != address ( 0 ) ) ; require ( seller != address ( 0 ) ) ; require ( notary != address ( 0 ) ) ; bytes memory packed = bytes ( dataHash ) . length > 0 ? abi . encodePacked ( order , notary , dataHash ) : abi . encodePacked ( order , notary ) ; bytes32 hash = keccak256 ( packed ) ; return isSignedBy ( hash , seller , signature ) ; }
function claimTokens ( address _token ) onlyOwner public { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } TokenERC20 token = TokenERC20 ( _token ) ; uint balance = token . balanceOf ( address ( this ) ) ; token . transfer ( owner , balance ) ; }
function collectAll ( uint8 max ) public returns ( uint8 collected ) { max = uint8 ( min ( max , contributors . length ) ) ; require ( max > 0 , "can't collect for zero users" ) ; uint index = contributors . length - 1 ; for ( uint offset = 0 ; offset < max ; ++ offset ) { address recipient = contributors [ index - offset ] ; if ( balances [ recipient ] > 0 ) { collected ++ ; collectFor ( recipient ) ; } } contributors . length -= offset ; }
function tokensOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 tokenId ) { uint256 count = 0 ; for ( uint256 i = 1 ; i <= totalSupply ( ) ; i ++ ) { if ( fighterIndexToOwner [ i ] == _owner ) { if ( count == _index ) { return i ; } else { count ++ ; } } } revert ( ) ; }
function finishPreICO ( ) onlyOwner external { require ( state == State . PreICO ) ; require ( icoStartTimestamp != 0 && icoEndTimestamp != 0 ) ; state = State . ICO ; }
function getProjectLevel ( PledgeAdmin m ) internal returns ( uint ) { assert ( m . adminType == PledgeAdminType . Project ) ; if ( m . parentProject == 0 ) return ( 1 ) ; PledgeAdmin storage parentNM = findAdmin ( m . parentProject ) ; return getProjectLevel ( parentNM ) + 1 ; }
function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; mAuthorized [ _operator ] [ msg . sender ] = true ; emit AuthorizedOperator ( _operator , msg . sender ) ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( now < ICOdeadline && state != State . Successful ) { if ( state == State . Ongoin && totalRaised >= SoftCap ) { state = State . SoftCap ; completedAt = now ; } else if ( state == State . SoftCap && now > completedAt . add ( 24 hours ) ) { state == State . Successful ; closedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } } else if ( now > ICOdeadline && state != State . Successful ) { state = State . Successful ; if ( completedAt == 0 ) { completedAt = now ; } closedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
function isResolverFor ( uint ein , address resolver ) public view returns ( bool ) { return identityDirectory [ ein ] . resolvers . contains ( resolver ) ; }
function unpause ( ) external onlyAdmin whenPaused { paused = false ; emit Unpaused ( ) ; }
function registerAccount ( bytes16 _uuid ) public { accountsStatuses [ _uuid ] = true ; accountsCount = accountsCount . add ( 1 ) ; }
function claimTokensByUser ( ) public { uint256 tokens = balance [ msg . sender ] ; balance [ msg . sender ] = 0 ; require ( tokenReward . transfer ( msg . sender , tokens ) ) ; tokensSent [ msg . sender ] = tokensSent [ msg . sender ] . add ( tokens ) ; emit LogContributorsPayout ( msg . sender , tokens ) ; }
function getApproved ( uint256 _tokenId ) public view returns ( address ) { return tokenApprovals [ _tokenId ] ; }
function _updateWhitelist ( address _account , uint8 _phase ) internal { if ( _phase == 1 ) { _whitelist [ _account ] = _invCap ; } else { _whitelist [ _account ] = 0 ; } emit WhitelistUpdated ( _account , _phase ) ; }
function eligibleForDividence ( address _user ) public view returns ( bool _success ) { if ( moneySpent [ _user ] == 0 ) { return false ; } else if ( ( balances [ _user ] + allowed [ selfAddress ] [ _user ] ) / moneySpent [ _user ] > 20 ) { return false ; } return true ; }
function alterBankBalance ( address _toAlter , uint256 _amount , bool sign ) external DAppOnline isAdmin { if ( sign && ( _amount + allowed [ selfAddress ] [ _toAlter ] ) > allowed [ selfAddress ] [ _toAlter ] ) { allowed [ selfAddress ] [ _toAlter ] = _amount + allowed [ selfAddress ] [ _toAlter ] ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } else { allowed [ selfAddress ] [ _toAlter ] = safeSub ( allowed [ selfAddress ] [ _toAlter ] , _amount ) ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } }
function approve ( address _approved , uint256 _tokenId ) external payable canOperate ( _tokenId ) { address _owner = _tokenOwnerWithSubstitutions [ _tokenId ] ; if ( _owner == address ( 0 ) ) { _owner = address ( this ) ; } tokenApprovals [ _tokenId ] = _approved ; emit Approval ( _owner , _approved , _tokenId ) ; }
function approve ( address spender , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; tokenState . setAllowance ( sender , spender , value ) ; emitApproval ( sender , spender , value ) ; return true ; }
function addMember ( bytes32 _membershipNumber , address _memberAddress , bytes32 _invitationCode , bytes32 _referralInvitationCode ) public onlyValidator isNotMember ( _memberAddress ) notStaking ( _memberAddress ) { require ( _memberAddress != address ( 0x0 ) , "Member address was set to 0." ) ; Member memory member = Member ( { addedTimestamp : block . timestamp , stakeTimestamp : 0 , startOfLoyaltyRewardEligibility : 0 , membershipNumber : _membershipNumber , invitationCode : _invitationCode , stakeBalance : 0 , invitationRewards : 0 , previouslyAppliedLoyaltyBalance : 0 } ) ; members [ _memberAddress ] = member ; membersArray . push ( _memberAddress ) ; registeredInvitationCodes [ member . invitationCode ] = _memberAddress ; address rewardMemberAddress = registeredInvitationCodes [ _referralInvitationCode ] ; if ( rewardMemberAddress != address ( 0x0 ) ) { Member storage rewardee = members [ rewardMemberAddress ] ; rewardee . invitationRewards = SafeMath . add ( rewardee . invitationRewards , invitationReward ) ; emit InvitationRewardGiven ( rewardMemberAddress , _memberAddress , invitationReward ) ; } emit MemberAdded ( _memberAddress , _membershipNumber , _invitationCode ) ; }
function owner ( bytes32 _symbol ) public view returns ( address ) { return _address ( _assetOwner ( _symbol ) ) ; }
function assignShareTokens ( uint _count ) public onlyOwner { require ( status == state . success ) ; uint count = _count ; if ( winner_bids < assigned_bids . add ( count ) ) { count = winner_bids . sub ( assigned_bids ) ; } require ( count > 0 ) ; uint cursor = assigned_bids ; assigned_bids = assigned_bids . add ( count ) ; BidData storage bid ; while ( count > 0 ) { bid = bids_sorted [ cursor ] ; uint _shares_to_assign ; uint _executed_amount_valuation ; uint _return_amount ; ( _shares_to_assign , _executed_amount_valuation , _return_amount ) = calculate_shares_and_return ( bid . shares_count , bid . share_price , bid . transfer_valuation , final_share_price , bids [ bid . origin_index ] . art_price , bid . transfer_token ) ; bid . executed_amount = _executed_amount_valuation ; bid . asigned_shares_count = _shares_to_assign ; assigned_shares = assigned_shares . add ( _shares_to_assign ) ; final_fundraise = final_fundraise . add ( _executed_amount_valuation ) ; final_shares_sold = final_shares_sold . add ( _shares_to_assign ) ; if ( _return_amount > 0 ) { art_token_contract . transfer ( bid . investor_address , _return_amount ) ; } bid . closed = true ; if ( shares_holders_balance [ bid . investor_address ] == 0 ) { shares_holders [ shares_holders_count ++ ] = bid . investor_address ; } emit Assigned ( bid . origin_index , _shares_to_assign , _executed_amount_valuation , _return_amount ) ; shares_holders_balance [ bid . investor_address ] = shares_holders_balance [ bid . investor_address ] . add ( _shares_to_assign ) ; cursor ++ ; count -- ; } }
function withdrawBalance ( ) external onlyCEOOrCFO { require ( withdrawalAddress != address ( 0 ) ) ; withdrawalAddress . transfer ( this . balance ) ; }
function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { remaining = TokenInfoController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_INFO ) ) . get_allowance ( _owner , _spender ) ; }
function findBestRate ( ERC20 src , ERC20 dest , uint srcAmount ) public view returns ( uint obsolete , uint rate ) { BestRateResult memory result = findBestRateTokenToToken ( src , dest , srcAmount , EMPTY_HINT ) ; return ( 0 , result . rate ) ; }
function acceptOwnership ( ) public { require ( msg . sender == newOwnerCandidate ) ; address oldOwner = owner ; owner = newOwnerCandidate ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }
function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyAuthorized public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }
function getToken ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = collectibleIndexToPrice [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = getInitialPriceOfToken ( _tokenId ) ; owner = collectibleIndexToOwner [ _tokenId ] ; nextSellingPrice = getNextPrice ( sellingPrice , _tokenId ) ; }
function freezeMinting ( ) external ;
function fundsOf ( address _address ) constant returns ( uint valueWei ) { return funds [ _address ] ; }
function setFeePeriodDuration ( uint duration ) external optionalProxy_onlyOwner { require ( MIN_FEE_PERIOD_DURATION <= duration && duration <= MAX_FEE_PERIOD_DURATION , "Duration must be between MIN_FEE_PERIOD_DURATION and MAX_FEE_PERIOD_DURATION" ) ; feePeriodDuration = duration ; emitFeePeriodDurationUpdated ( duration ) ; rolloverFeePeriodIfElapsed ( ) ; }
function setInterfaceImplementer ( address addr , bytes32 iHash , address implementer ) public canManage ( addr ) { interfaces [ addr ] [ iHash ] = implementer ; InterfaceImplementerSet ( addr , iHash , implementer ) ; }
function setFallback ( address _fallback ) public onlyOwner returns ( bool ) { fallback = _fallback ; return true ; }
function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( _owner ) ; _owner = address ( 0 ) ; }
function getRawPendingAmount ( uint index ) public view returns ( uint256 ) { Loan memory loan = loans [ index ] ; return safeSubtract ( safeAdd ( safeAdd ( loan . amount , loan . interest ) , loan . punitoryInterest ) , loan . paid ) ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = elementToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
function applyBooster ( uint256 _tokenId , uint256 _booster ) onlyFishOwner ( _tokenId ) public { require ( msg . sender == boosters . ownerOf ( _booster ) ) ; require ( boosters . getBoosterAmount ( _booster ) >= 1 ) ; Fish storage tempFish = fishes [ _tokenId ] ; uint8 boosterType = uint8 ( boosters . getBoosterType ( _booster ) ) ; if ( boosterType == 1 || boosterType == 2 || boosterType == 3 ) { tempFish . boosterStrength = boosters . getBoosterStrength ( _booster ) ; tempFish . activeBooster = boosterType ; tempFish . boostedTill = boosters . getBoosterDuration ( _booster ) * boosters . getBoosterAmount ( _booster ) + uint64 ( now ) ; tempFish . boosterRaiseValue = boosters . getBoosterRaiseValue ( _booster ) ; } else if ( boosterType == 4 ) { require ( tempFish . boostedTill > uint64 ( now ) ) ; tempFish . boosterStrength = boosters . getBoosterStrength ( _booster ) ; tempFish . boostedTill += boosters . getBoosterDuration ( _booster ) * boosters . getBoosterAmount ( _booster ) ; } else if ( boosterType == 5 ) { require ( boosters . getBoosterAmount ( _booster ) == 1 ) ; tempFish . canFightAgain = 0 ; } require ( boosters . transferFrom ( msg . sender , address ( 0 ) , _booster ) ) ; BoosterApplied ( _tokenId , _booster ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public payloadSizeIs ( 3 * 32 ) returns ( bool ) { thawSomeTokens ( _from , _value ) ; return super . transferFrom ( _from , _to , _value ) ; }
function reclaimEther ( ) external onlyAdmin { msg . sender . transfer ( address ( this ) . balance ) ; }
function setApprovalForAll ( address _operator , bool _approved ) external { if ( _approved ) { addressToApprovedAll [ msg . sender ] = _operator ; } else { delete addressToApprovedAll [ msg . sender ] ; } emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
function setGuaranteedAddress ( address _th , uint256 _limit ) public initialized onlyOwner { require ( getBlockNumber ( ) < startBlock ) ; require ( _limit > 0 && _limit <= maxGuaranteedLimit ) ; guaranteedBuyersLimit [ _th ] = _limit ; GuaranteedAddress ( _th , _limit ) ; }
function createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) public withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _token , _amount , _checkpointId , _excluded , _name ) ; }
function authorizePayment ( address _recipient , uint _amount , uint _paymentDelay ) returns ( uint ) { if ( ! allowedSpenders [ msg . sender ] ) throw ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; if ( _paymentDelay > 10 ** 18 ) throw ; p . earliestPayTime = _paymentDelay >= timeLock ? now + _paymentDelay : now + timeLock ; p . recipient = _recipient ; p . amount = _amount ; PaymentAuthorized ( idPayment , p . recipient , p . amount ) ; return idPayment ; }
function pickRandomAssetPosition ( uint _randomSeed , uint _width , uint _height ) public pure returns ( uint x , uint y , uint zoom , uint rotation , uint layer ) { x = _randomSeed % _width ; y = _randomSeed % _height ; zoom = _randomSeed % 200 + 800 ; rotation = _randomSeed % 360 ; layer = _randomSeed % 1234567 ; }
function updateTokenDetails ( string _newTokenDetails ) external ;
function updateNameAndSymbol ( string _newname , string _newsymbol ) onlyOwner public { name = _newname ; symbol = _newsymbol ; }
function claimPlotWithData ( uint256 _deedId , uint256 _buyoutPrice , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; claimPlotMultipleWithData ( _deedIds , _buyoutPrice , name , description , imageUrl , infoUrl ) ; }
function release ( string _id ) external onlyArbitrator { require ( escrows [ _id ] . exists ) ; EscrowDeposit storage escrowDeposit = escrows [ _id ] ; uint256 gasFees = RELEASE_GAS_FEES . mul ( tx . gasprice ) ; uint256 amount = escrowDeposit . amount . sub ( gasFees ) ; address bidder = escrowDeposit . bidder ; delete escrows [ _id ] ; accumulatedGasFees = accumulatedGasFees . add ( gasFees ) ; bidder . transfer ( amount ) ; emit Released ( msg . sender , bidder , amount , _id ) ; }
function getPrices ( address [ ] ofAssets ) view returns ( bool areRecent , uint [ ] prices , uint [ ] decimals ) { areRecent = true ; for ( uint i ; i < ofAssets . length ; i ++ ) { var ( isRecent , price , decimal ) = getPrice ( ofAssets [ i ] ) ; if ( ! isRecent ) { areRecent = false ; } prices [ i ] = price ; decimals [ i ] = decimal ; } }
function playerForceGameEnd ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; require ( game . status == GameStatus . PLAYER_INITIATED_END ) ; int newBalance = conflictRes . playerForceGameEnd ( game . gameType , game . betNum , game . betValue , game . balance , game . stake , game . endInitiatedTime ) ; closeGame ( game , gameId , game . roundId , playerAddress , ReasonEnded . END_FORCED_BY_PLAYER , newBalance ) ; }
function adminSetTokenURITemplate ( string _newTokenURITemplate ) public { require ( msg . sender == admin , "Only the admin can call this function" ) ; tokenURITemplate = _newTokenURITemplate ; }
function revealMulti ( uint256 [ ] _limits , uint256 [ ] _slopeFactors , uint256 [ ] _collectMinimums , bool [ ] _lasts , bytes32 [ ] _salts ) public { require ( _limits . length != 0 && _limits . length == _slopeFactors . length && _limits . length == _collectMinimums . length && _limits . length == _lasts . length && _limits . length == _salts . length ) ; for ( uint256 i = 0 ; i < _limits . length ; i = i . add ( 1 ) ) { revealCeiling ( _limits [ i ] , _slopeFactors [ i ] , _collectMinimums [ i ] , _lasts [ i ] , _salts [ i ] ) ; } }
function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; address permissionManager = new GeneralPermissionManager ( msg . sender , address ( polyToken ) ) ; emit LogGenerateModuleFromFactory ( address ( permissionManager ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( permissionManager ) ; }
function withdrawAuctionBalance ( address beneficiary ) external { require ( msg . sender == beneficiary || msg . sender == address ( deedContract ) ) ; uint256 etherOwed = addressToEtherOwed [ beneficiary ] ; require ( etherOwed > 0 ) ; delete addressToEtherOwed [ beneficiary ] ; outstandingEther -= etherOwed ; beneficiary . transfer ( etherOwed ) ; }
function makeListing ( address _seller , uint256 _tokenId , uint256 _startPrice , uint256 _endPrice , uint256 _duration ) internal { require ( _startPrice <= maxPrice , "Start price is higher than the max allowed" ) ; require ( _startPrice >= minPrice , "Start price is lower than the min allowed" ) ; require ( _endPrice <= maxPrice , "End price is higher than the max allowed" ) ; require ( _endPrice >= minPrice , "End price is lower than the min allowed" ) ; _startPrice = _startPrice / WEI_PER_GWEI ; _endPrice = _endPrice / WEI_PER_GWEI ; require ( _endPrice > uint256 ( 0 ) , "End price cannot be zero (gwei)" ) ; require ( _startPrice >= _endPrice , "Start price is lower than the end price" ) ; require ( _startPrice < uint256 ( 2 ** 64 ) , "Start price is out of bounds" ) ; require ( _endPrice < uint256 ( 2 ** 64 ) , "End price is out of bounds" ) ; uint256 startDate = ( now / uint256 ( startDateRoundValue ) ) * uint256 ( startDateRoundValue ) ; require ( startDate < uint256 ( 2 ** 64 ) , "Start date is out of bounds" ) ; _duration = ( _duration / uint256 ( durationRoundValue ) ) * uint256 ( durationRoundValue ) ; require ( _duration > uint256 ( 0 ) , "Duration cannot be zero" ) ; require ( _duration <= uint256 ( maxDuration ) , "Duration is higher than the max allowed" ) ; require ( _duration >= uint256 ( minDuration ) , "Duration is lower than the min allowed" ) ; uint64 pixelconIndex = pixelconsContract . getTokenIndex ( _tokenId ) ; Listing storage listing = marketPixelconListings [ pixelconIndex ] ; listing . startAmount = uint64 ( _startPrice ) ; listing . endAmount = uint64 ( _endPrice ) ; listing . startDate = uint64 ( startDate ) ; listing . duration = uint64 ( _duration ) ; listing . seller = _seller ; uint64 [ ] storage sellerTokens = sellerPixelconIndexes [ _seller ] ; uint sellerTokensIndex = sellerTokens . length ; uint forSaleIndex = forSalePixelconIndexes . length ; require ( sellerTokensIndex < uint256 ( 2 ** 32 - 1 ) , "Max number of market listings has been exceeded for seller" ) ; require ( forSaleIndex < uint256 ( 2 ** 64 - 1 ) , "Max number of market listings has been exceeded" ) ; listing . sellerIndex = uint32 ( sellerTokensIndex ) ; listing . forSaleIndex = uint64 ( forSaleIndex ) ; sellerTokens . length ++ ; sellerTokens [ sellerTokensIndex ] = pixelconIndex ; forSalePixelconIndexes . length ++ ; forSalePixelconIndexes [ forSaleIndex ] = pixelconIndex ; emit Create ( pixelconIndex , _seller , _startPrice , _endPrice , uint64 ( _duration ) ) ; }
function addProposal ( uint _duration , bytes32 _storageHash ) public returns ( uint _proposalId ) { require ( _duration >= MIN_PROPOSAL_DURATION ) ; require ( _duration <= MAX_PROPOSAL_DURATION ) ; uint amount = MiniMeToken ( nectarToken ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; _proposalId = proposals . length ; proposals . length ++ ; Proposal storage p = proposals [ _proposalId ] ; p . storageHash = _storageHash ; p . duration = _duration * ( 1 days ) ; p . proposer = msg . sender ; emit NewProposal ( _proposalId , _duration , _storageHash ) ; }
function countValidators ( ) external view returns ( uint256 ) ;
function licenseInfo ( uint256 _licenseId ) public view returns ( uint256 , uint256 , uint256 , uint256 , address ) { return ( licenseProductId ( _licenseId ) , licenseAttributes ( _licenseId ) , licenseIssuedTime ( _licenseId ) , licenseExpirationTime ( _licenseId ) , licenseAffiliate ( _licenseId ) ) ; }
function checkPermission ( address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { for ( uint256 i = 0 ; i < modules [ PERMISSION_KEY ] . length ; i ++ ) { if ( ! modulesToData [ modules [ PERMISSION_KEY ] [ i ] ] . isArchived ) return TokenLib . checkPermission ( modules [ PERMISSION_KEY ] , _delegate , _module , _perm ) ; } return false ; }
function hasAssetRights ( address _owner , bytes32 _symbol ) public view returns ( bool ) { uint holderId = getHolderId ( _owner ) ; return isCreated ( _symbol ) && ( assets [ _symbol ] . owner == holderId || assets [ _symbol ] . partowners [ holderId ] ) ; }
function ( ) external payable { _addToFund ( msg . value , true ) ; }
function unfreezeTransfers ( ) public onlyOwner { require ( freeze ) ; freeze = false ; emit LogFreezeTransfers ( freeze , now ) ; }
function totalSupply ( ) external view returns ( uint256 ) { return TOTAL_SUPPLY ; }
function getSecurityTokenAddress ( string _symbol ) public view returns ( address ) { string memory __symbol = upper ( _symbol ) ; return symbols [ __symbol ] ; }
function giveMeETH ( ) public auth { msg . sender . transfer ( address ( this ) . balance ) ; }
function goalReached ( ) internal { emit SoftcapReached ( treasury , fundingGoal ) ; fundingGoalReached = true ; if ( weiRaisedInPICO < fundingGoal ) { PICO . extGoalReached ( ) ; } }
function updateWhitelist ( address _address , bool _status ) public onlyOwner { whitelisted [ _address ] = _status ; }
function _answerData ( bytes32 question_id , bytes32 last_history_hash , bytes32 last_answer_or_commitment_id , uint256 last_bond , address last_answerer , bool is_commitment ) internal view returns ( bool , bytes32 ) { bool is_pending_arbitration ; bytes32 history_hash ; if ( last_bond == 0 ) { return ( false , bytes32 ( 0 ) ) ; } bytes32 last_answer ; bool is_answered ; if ( is_commitment ) { uint256 reveal_ts ; bool is_revealed ; bytes32 revealed_answer ; ( reveal_ts , is_revealed , revealed_answer ) = realitio . commitments ( last_answer_or_commitment_id ) ; if ( is_revealed ) { last_answer = revealed_answer ; is_answered = true ; } else { require ( reveal_ts < uint32 ( now ) , "Arbitration cannot be done until the last answerer has had time to reveal their commitment" ) ; is_answered = false ; } } else { last_answer = last_answer_or_commitment_id ; is_answered = true ; } return ( is_answered , last_answer ) ; }
function buy ( ) public payable { require ( msg . value >= 20 ether ) ; uint256 rate = exchangeRate ( ) ; require ( rate > 0 ) ; uint256 requested = msg . value . mul ( rate ) ; Stage n_stage = stage ( ) ; require ( n_stage == Stage . Early || n_stage == Stage . Normal ) ; uint256 remained ; if ( n_stage == Stage . Early ) { remained = cornerstoneSupply . sub ( soldOut . cornerstoneValue ) ; } else { remained = vcSupply . sub ( soldOut . vcValue ) ; } if ( requested > remained ) { requested = remained ; } uint256 ethCost = requested . div ( rate ) ; if ( requested > 0 ) { you . createOption ( msg . sender , requested , uint32 ( endTime ) , 365 ) ; ethVault . transfer ( ethCost ) ; if ( n_stage == Stage . Early ) { soldOut . cornerstoneValue = requested . add ( soldOut . cornerstoneValue ) ; } else { soldOut . vcValue = requested . add ( soldOut . vcValue ) ; } LogSold ( msg . sender , requested , ethCost ) ; } uint256 toReturn = msg . value . sub ( ethCost ) ; if ( toReturn > 0 ) { msg . sender . transfer ( toReturn ) ; } }
function transfer ( address _to , uint _value ) returns ( bool ) { if ( balances [ msg . sender ] >= _value ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
function cloneOrder ( address _contractorAddress , uint _contractorProposalID , uint _orderAmount , uint _lastOrderDate ) { if ( projectManager != 0 ) throw ; addOrder ( _contractorAddress , _contractorProposalID , _orderAmount , _lastOrderDate ) ; }
function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; msg . sender . transfer ( revenue ) ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) public { address tokenOwner = ownerOf ( _tokenId ) ; require ( isSenderApprovedFor ( _tokenId ) || ( approvedContractAddresses [ msg . sender ] && tokenOwner == tx . origin ) , "not an approved sender" ) ; require ( tokenOwner == _from , "wrong owner" ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , _to , _tokenId ) ; }
function saleNonEther ( address beneficiary , uint256 amount , string ) public onlyOwner { mintTokens ( beneficiary , amount ) ; }
function removeDarknode ( address darknodeID ) external onlyOwner { uint256 bond = darknodeRegistry [ darknodeID ] . bond ; delete darknodeRegistry [ darknodeID ] ; LinkedList . remove ( darknodes , darknodeID ) ; require ( ren . transfer ( owner , bond ) , "bond transfer failed" ) ; }
function cumulativeInverse ( uint256 neumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public constant returns ( uint256 euroUlps ) { require ( maxEurUlps >= minEurUlps ) ; require ( cumulative ( minEurUlps ) <= neumarkUlps ) ; require ( cumulative ( maxEurUlps ) >= neumarkUlps ) ; uint256 min = minEurUlps ; uint256 max = maxEurUlps ; while ( max > min ) { uint256 mid = ( max + min ) / 2 ; uint256 val = cumulative ( mid ) ; if ( val < neumarkUlps ) { min = mid + 1 ; } else { max = mid ; } } return max ; }
function refund ( address recipient ) onlyOwner { RefundInvoice ( address ( this ) , now ) ; }
function mintToken ( uint256 amount ) isOwner { require ( amount > 0 ) ; require ( tokenBalanceOf [ this ] <= icoMin ) ; require ( _totalSupply + amount > _totalSupply ) ; require ( tokenBalanceOf [ this ] + amount > tokenBalanceOf [ this ] ) ; _totalSupply += amount ; tokenBalanceOf [ this ] += amount ; allowed [ this ] [ owner ] = tokenBalanceOf [ this ] ; allowed [ this ] [ supervisor ] = tokenBalanceOf [ this ] ; tokenCreated ( msg . sender , amount , "Additional tokens created!" ) ; }
function insertAfter ( List storage self , address target , address newNode ) internal { require ( ! isInList ( self , newNode ) , "already in list" ) ; require ( isInList ( self , target ) || target == NULL , "not in list" ) ; address n = self . list [ target ] . next ; self . list [ newNode ] . previous = target ; self . list [ newNode ] . next = n ; self . list [ target ] . next = newNode ; self . list [ n ] . previous = newNode ; self . list [ newNode ] . inList = true ; }
function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }
function ( ) payable { require ( ! sale_pause ) ; buy ( ) ; }
function initialize ( ) public onlyInit { initialized ( ) ; executorsNextIndex = 1 ; }
function executeTransaction ( address destination , uint value , bytes data ) public onlyOwner { if ( destination . call . value ( value ) ( data ) ) emit Execution ( destination , value , data ) ; else emit ExecutionFailure ( destination , value , data ) ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < balanceOf ( _owner ) , "index out of range" ) ; return ownerToTokenList [ _owner ] [ _index ] ; }
function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x48664c16 ) , _token , _to , _value , _fee , _nonce ) ; }
function appendVestingEntry ( address account , uint time , uint quantity ) public onlyOwner onlyDuringSetup { require ( now < time , "Time must be in the future" ) ; require ( quantity != 0 , "Quantity cannot be zero" ) ; totalVestedBalance = totalVestedBalance . add ( quantity ) ; require ( totalVestedBalance <= synthetix . balanceOf ( this ) , "Must be enough balance in the contract to provide for the vesting entry" ) ; uint scheduleLength = vestingSchedules [ account ] . length ; require ( scheduleLength <= MAX_VESTING_ENTRIES , "Vesting schedule is too long" ) ; if ( scheduleLength == 0 ) { totalVestedAccountBalance [ account ] = quantity ; } else { require ( getVestingTime ( account , numVestingEntries ( account ) - 1 ) < time , "Cannot add new vested entries earlier than the last one" ) ; totalVestedAccountBalance [ account ] = totalVestedAccountBalance [ account ] . add ( quantity ) ; } vestingSchedules [ account ] . push ( [ time , quantity ] ) ; }
function buy ( ) public payable returns ( uint256 amount ) { if ( initialSaleComplete ) { uint256 b = 0 ; uint256 p = 0 ; uint8 ps = 0 ; ( p , ps ) = power ( 1000008 , 1000000 , ( uint32 ) ( 1 + _totalSupply / SU ) , 1 ) ; p = ( S * p ) >> ps ; b = ( ln_fixed3_lnr_18 ( RS * msg . value / SU + p , 1 ) - 1e18 * lnRS - 1e18 * FIXED_3 ) / FIXED_3 ; refund = msg . value - ( msg . value / SU ) * SU ; amount = b * SU / 1e18 - _totalSupply ; reserveAddress . transfer ( ( msg . value / SU ) * SU ) ; balances [ reserveAddress ] += msg . value - refund ; mintToken ( msg . sender , amount ) ; msg . sender . transfer ( refund ) ; quoteAsk ( ) ; quoteBid ( ) ; } else { ask = ICOask ; amount = 1e16 * msg . value / ask ; refund = msg . value - ( amount * ask / 1e16 ) ; reserveAddress . transfer ( msg . value - refund ) ; msg . sender . transfer ( refund ) ; balances [ reserveAddress ] += msg . value - refund ; mintToken ( msg . sender , amount ) ; if ( _totalSupply >= ICOAmount ) { initialSaleComplete = true ; } } return amount ; }
function closeSale ( ) public onlyOwner { closePreSale ( ) ; }
function mintTokens ( uint256 _tokens ) external ;
function lock ( ) public onlyOwner { unlocked = false ; }
function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }
function setPricesManually ( string _prices ) external onlyOwner { require ( priceExpired ( ) || updateRequestExpired ( ) ) ; setPrices ( _prices ) ; }
function ( ) payable { require ( msg . sender == tx . origin ) ; process_contribution ( msg . sender ) ; }
function withdrawEther ( address to ) public validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) { to . transfer ( address ( this ) . balance ) ; }
function emergencyWithdraw ( address _withdrawer , address _token , uint256 _amount ) external onlyCoordinator onlyInactiveState { _withdraw ( _withdrawer , _token , _amount , etherAddr , 0 ) ; }
function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( saleAuction ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; require ( warriors [ _tokenId ] . action == IDLE ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function cancelItemSale ( uint256 _id ) public itemIsForSale ( _id ) onlyOwnerOfItem ( _id ) { Item storage item = items [ _id ] ; _cancelItemSale ( item ) ; }
function withdraw ( address addr ) onlyOwner public { addr . transfer ( this . balance ) ; }
function setAllowedAddress ( address _addr ) public onlyOwner ( "setAllowedAddress" ) { if ( allowedAddress != 0x0 ) { StorageUser storageUser = StorageUser ( _addr ) ; address storageContract = storageUser . getStorageAddress ( ) ; require ( storageContract == advStorageContract ) ; } super . setAllowedAddress ( _addr ) ; }
function fundICO ( uint256 _amount , uint8 _stage ) public returns ( bool ) { if ( nextStage != _stage ) { error ( 'Escrow: ICO stage already funded' ) ; return false ; } if ( msg . sender != addressSCICO || tx . origin != owner ) { error ( 'Escrow: not allowed to fund the ICO' ) ; return false ; } if ( deposited [ this ] < _amount ) { error ( 'Escrow: not enough balance' ) ; return false ; } bool success = SCTokens . transfer ( addressSCICO , _amount ) ; if ( success ) { deposited [ this ] = deposited [ this ] . sub ( _amount ) ; nextStage ++ ; emit FundICO ( addressSCICO , _amount ) ; } return success ; }
function getStartDate ( ) public view returns ( uint32 ) { uint32 startDate = getNextDate ( uint32 ( now ) ) ; uint32 lastRegisterDate = getLastRegisterDate ( ) ; if ( startDate <= lastRegisterDate ) { startDate = getNextDate ( lastRegisterDate ) ; } return startDate ; }
function saleNonEther ( address beneficiary , uint256 amount , string ) onlyOwner external { mintTokens ( beneficiary , amount ) ; }
function toggleContractStopped ( ) public onlyOwner { contractStopped = ! contractStopped ; }
function challengeBefore ( uint64 slot , bytes prevTxBytes , bytes txBytes , bytes prevTxInclusionProof , bytes txInclusionProof , bytes signature , uint256 [ 2 ] blocks ) external payable isBonded isState ( slot , State . EXITING ) { doInclusionChecks ( prevTxBytes , txBytes , prevTxInclusionProof , txInclusionProof , signature , blocks ) ; setChallenged ( slot , txBytes . getOwner ( ) , blocks [ 1 ] , txBytes . getHash ( ) ) ; }
function newTokenDeposit ( ERC20 _token , uint _amount , uint _block ) public onlyOwner returns ( uint _idDeposit ) { require ( _amount > 0 ) ; require ( _block < block . number ) ; require ( _token . transferFrom ( msg . sender , address ( this ) , _amount ) ) ; _idDeposit = deposits . length ++ ; Deposit storage d = deposits [ _idDeposit ] ; d . block = _block == 0 ? block . number - 1 : _block ; d . token = _token ; d . amount = _amount ; NewDeposit ( _idDeposit , _token , _amount ) ; }
function deleteRate ( bytes4 currencyKey ) external onlyOracle { require ( rates [ currencyKey ] > 0 , "Rate is zero" ) ; delete rates [ currencyKey ] ; delete lastRateUpdateTimes [ currencyKey ] ; emit RateDeleted ( currencyKey ) ; }
function redeemVoucherSingle ( uint256 voucherCode , address voucherOwner , address seller , uint256 quantity ) public onlyOwner payable { TradeOrder memory order = orderBook [ seller ] ; execute ( seller , quantity , order . price ) ; emit VoucherRedeemed ( voucherCode , voucherOwner , seller , quantity ) ; }
function approveAddress ( address _addr ) public onlyApi { approvedAddresses [ _addr ] = true ; }
function addVersion ( address ofVersion ) pre_cond ( msg . sender == address ( this ) ) returns ( uint id ) { require ( msg . sender == address ( this ) ) ; Version memory info ; info . version = ofVersion ; info . active = true ; info . timestamp = now ; versions . push ( info ) ; emit VersionUpdated ( versions . length - 1 ) ; }
function releaseTokensFromEscrowFor ( address _sender , uint256 _amount , bytes32 _nonce , bytes _delegationSig ) external { validateReleaseTokensSig ( _sender , _amount , _nonce , _delegationSig ) ; releaseTokensFromEscrowForUser ( _sender , _amount ) ; }
function approve ( address _spender , uint _value ) returns ( bool success ) { }
function claimTokens ( address _token ) public onlyOwner { if ( SNT . controller ( ) == address ( this ) ) { SNT . claimTokens ( _token ) ; } if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
function updatePrice ( uint gasPriceInWei ) public payable whenNotPaused { if ( gasPriceInWei > 0 ) { oraclize_setCustomGasPrice ( gasPriceInWei ) ; } if ( oraclize_getPrice ( "URL" ) > address ( this ) . balance ) { emit LogOraclizeQuery ( "" , gasPriceInWei , "Oraclize query was NOT sent, please add some ETH to cover for the query fee" ) ; } else { bytes32 queryId = oraclize_query ( 0 , "URL" , REQUEST_URL , callbackGasLimit ) ; validIds [ queryId ] = true ; emit LogOraclizeQuery ( queryId , gasPriceInWei , "Oraclize query was sent, standing by for the answer..." ) ; } }
function get_Sponsors_list_by_Job ( uint _JobID ) public view returns ( address [ ] list ) { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; list = new address [ ] ( job . sponsorsCount ) ; list = job . sponsorList ; }
function debtLedgerLength ( ) external view returns ( uint ) { return debtLedger . length ; }
function hasRecentPrices ( address [ ] ofAssets ) view returns ( bool areRecent ) { for ( uint i ; i < ofAssets . length ; i ++ ) { if ( ! hasRecentPrice ( ofAssets [ i ] ) ) { return false ; } } return true ; }
function setUpgradeHasBegun ( ) internal { if ( ! upgradeHasBegun ) { upgradeHasBegun = true ; UpgradeHasBegun ( ) ; } }
function multiCall ( address [ ] _addresses , uint [ ] _amounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addresses . length ; i ++ ) { _safeCall ( _addresses [ i ] , _amounts [ i ] ) ; MultiCall ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }
function pushDividendPayment ( uint256 _dividendIndex , uint256 _start , uint256 _iterations ) public withPerm ( DISTRIBUTE ) validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; address [ ] memory investors = ISecurityToken ( securityToken ) . getInvestors ( ) ; uint256 numberInvestors = Math . min256 ( investors . length , _start . add ( _iterations ) ) ; for ( uint256 i = _start ; i < numberInvestors ; i ++ ) { address payee = investors [ i ] ; if ( ( ! dividend . claimed [ payee ] ) && ( ! dividend . dividendExcluded [ payee ] ) ) { _payDividend ( payee , dividend , _dividendIndex ) ; } } }
function cancelProject ( uint uuid ) public onlyCurator { communityAccount . setTotalProjectEscrow ( SafeMath . sub ( communityAccount . totalProjectEscrow ( ) , communityAccount . escrowedProjectBalances ( uuid ) ) ) ; communityAccount . setEscrowedProjectBalances ( uuid , 0 ) ; logger . emitGenericLog ( "cancelProject" , "" ) ; }
function requestRefund ( ) external { assert ( getState ( ) == State . Failure ) ; assert ( funders [ msg . sender ] > 0 ) ; msg . sender . transfer ( funders [ msg . sender ] ) ; emit Refund ( msg . sender , funders [ msg . sender ] , block . number ) ; funders [ msg . sender ] = 0 ; }
function getLibrary ( uint256 _tokenId ) public view returns ( string language , string libraryName , uint256 tokenPrice , uint256 funds , address tokenOwner , address founder ) { Library storage x = libraries [ _tokenId ] ; libraryName = x . name ; language = x . language ; founder = libraryIndexToFounder [ _tokenId ] ; funds = libraryIndexToFunds [ _tokenId ] ; tokenPrice = libraryIndexToPrice [ _tokenId ] ; tokenOwner = libraryIndexToOwner [ _tokenId ] ; }
function mint ( address _to , uint256 _tokenId ) auth ( MINT_ROLE ) public { _mint ( _to , _tokenId ) ; }
function selfDestruct ( ) external onlyOwner { require ( selfDestructInitiated , "Self destruct has not yet been initiated" ) ; require ( initiationTime + SELFDESTRUCT_DELAY < now , "Self destruct delay has not yet elapsed" ) ; address beneficiary = selfDestructBeneficiary ; emit SelfDestructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; }
function getMinerHalvingHashRate ( ) public constant returns ( uint256 ) { return getMinerHalvingHashRateOf ( msg . sender ) ; }
function finalize ( ) public onlyOwner { require ( hasEnded ( ) ) ; require ( ! isFinalized ) ; isFinalized = true ; token . generateTokens ( operationAdress , OPERATION_AMOUNT ) ; token . generateTokens ( bountyAdress , BOUNTY_AMOUNT ) ; token . generateTokens ( commonBudgetAdress , COMMON_BUDGET_AMOUNT ) ; token . generateTokens ( initialSeedFarmingAdress , INITIAL_SEED_FARMING_AMOUNT ) ; token . generateTokens ( founderAdress , FOUNDER_AMOUNT ) ; token . generateTokens ( reserveAdress , RESERVE_AMOUNT ) ; vault . close ( ) ; token . enableTransfers ( true ) ; token . changeController ( newTokenOwner ) ; vault . transferOwnership ( owner ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( checkVestingCondition ( msg . sender ) ) ; _transfer ( msg . sender , _to , _value ) ; return true ; }
function personalizeSquare ( uint256 _squareId , bytes _rgbData , string _title , string _href ) external onlyOwnerOf ( _squareId ) payable { require ( bytes ( _title ) . length <= 64 ) ; require ( bytes ( _href ) . length <= 96 ) ; require ( _rgbData . length == 300 ) ; suSquares [ _squareId ] . version ++ ; suSquares [ _squareId ] . rgbData = _rgbData ; suSquares [ _squareId ] . title = _title ; suSquares [ _squareId ] . href = _href ; if ( suSquares [ _squareId ] . version > 3 ) { require ( msg . value == 10 finney ) ; } emit Personalized ( _squareId ) ; }
function createGame ( string _name , bytes32 [ ] _teamNames ) external isHuman ( ) onlyDevOrOwner ( ) returns ( uint256 ) { uint256 _gameID = gameIDIndex_ ; gameIDIndex_ ++ ; game_ [ _gameID ] . name = _name ; uint256 _nt = _teamNames . length ; require ( _nt > 0 , "number of teams must be larger than 0" ) ; game_ [ _gameID ] . numberOfTeams = _nt ; for ( uint256 i = 0 ; i < _nt ; i ++ ) { teams_ [ _gameID ] [ i ] = BMDatasets . Team ( _teamNames [ i ] , 0 , 0 , 0 , 0 ) ; } emit onGameCreated ( _gameID , now ) ; return _gameID ; }
function unlockBBK ( uint256 _amount ) external returns ( bool ) { require ( _amount > 0 ) ; IBrickblockToken _bbk = IBrickblockToken ( registry . getContractAddress ( "BrickblockToken" ) ) ; require ( _amount <= lockedBbkPerUser [ msg . sender ] ) ; require ( settleCurrentLockPeriod ( msg . sender ) ) ; lockedBbkPerUser [ msg . sender ] = lockedBbkPerUser [ msg . sender ] . sub ( _amount ) ; totalLockedBBK = totalLockedBBK . sub ( _amount ) ; require ( _bbk . transfer ( msg . sender , _amount ) ) ; emit BbkUnlocked ( msg . sender , _amount , totalLockedBBK ) ; return true ; }
function isReserved ( string _symbol , address _owner , string _tokenName , bytes32 _swarmHash ) public returns ( bool ) { string memory symbol = upper ( _symbol ) ; require ( msg . sender == securityTokenRegistry , "msg.sender should be SecurityTokenRegistry contract" ) ; if ( registeredSymbols [ symbol ] . owner == _owner && ! expiryCheck ( _symbol ) ) { registeredSymbols [ symbol ] . status = true ; return false ; } else if ( registeredSymbols [ symbol ] . owner == address ( 0 ) || expiryCheck ( symbol ) ) { registeredSymbols [ symbol ] = SymbolDetails ( _owner , now , _tokenName , _swarmHash , true ) ; emit LogRegisterTicker ( _owner , symbol , _tokenName , _swarmHash , now ) ; return false ; } else return true ; }
function transferFrom ( address _from , address _to , uint256 _value ) public canTransfer releaseTokenValid ( msg . sender , now , _value ) returns ( bool success ) { require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value <= allowances [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; balances [ _to ] += _value ; allowances [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }
function disableScriptExecutor ( uint256 _executorId ) external authP ( REGISTRY_MANAGER_ROLE , arr ( _executorId ) ) { ExecutorEntry storage executorEntry = executors [ _executorId ] ; require ( executorEntry . enabled , ERROR_EXECUTOR_DISABLED ) ; executorEntry . enabled = false ; emit DisableExecutor ( _executorId , executorEntry . executor ) ; }
function unlock ( ) external { require ( allocations [ msg . sender ] . locked ) ; require ( now >= allocations [ msg . sender ] . end ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( allocations [ msg . sender ] . value ) ; allocations [ msg . sender ] . locked = false ; Transfer ( this , msg . sender , allocations [ msg . sender ] . value ) ; Unlock ( this , msg . sender , allocations [ msg . sender ] . value ) ; }
function collect ( ) public { assert ( getBlockNumber ( ) > contribution . startBlock ( ) ) ; uint256 balance = sit . balanceOfAt ( msg . sender , contribution . initializedBlock ( ) ) ; uint256 amount = balance . sub ( collected [ msg . sender ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( msp . transfer ( msg . sender , amount ) ) ; TokensCollected ( msg . sender , amount ) ; }
function removeModule ( address _moduleFactory ) external ;
function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; require ( _weiAmount >= 500000000000000000 ) ; }
function buyoutWithData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { require ( buyoutsEnabledFromTimestamp <= block . timestamp ) ; address currentOwner = identifierToOwner [ _deedId ] ; require ( currentOwner != 0x0 ) ; uint256 [ ] memory claimedSurroundingPlots = _claimedSurroundingPlots ( _deedId ) ; uint256 totalCost = _calculateAndAssignBuyoutProceeds ( currentOwner , _deedId , claimedSurroundingPlots ) ; require ( msg . value >= totalCost ) ; _transfer ( currentOwner , msg . sender , _deedId ) ; SetData ( _deedId , name , description , imageUrl , infoUrl ) ; identifierToBuyoutPrice [ _deedId ] = nextBuyoutPrice ( totalCost ) ; if ( ! identifierToBoughtOutOnce [ _deedId ] ) { identifierToBoughtOutOnce [ _deedId ] = true ; } uint256 excess = msg . value - totalCost ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function exchangeRate ( ) public constant returns ( uint256 ) { if ( stage ( ) == Stage . Early ) { return cornerstoneStage ; } if ( stage ( ) == Stage . Normal ) { return vcStage ; } return 0 ; }
function updatePrices ( ) internal { uint256 oldPrice = currentTokenPrice ; if ( preIcoIsRunning ) { checkPreIcoStatus ( ) ; } if ( preIcoIsRunning ) { currentTokenPrice = preICOprice ; } else { currentTokenPrice = ICOprice ; } if ( oldPrice != currentTokenPrice ) { priceUpdated ( oldPrice , currentTokenPrice , "Metadollar price updated!" ) ; } }
function removeTokenMetadata ( uint256 _tokenId ) public onlyPlatform exists ( _tokenId ) { delete metadata [ _tokenId ] ; }
function setPrices ( address [ ] assets , uint [ ] requestedPriceMantissas ) public returns ( uint [ ] memory ) { uint numAssets = assets . length ; uint numPrices = requestedPriceMantissas . length ; uint [ ] memory result ; if ( msg . sender != poster ) { result = new uint [ ] ( 1 ) ; result [ 0 ] = failOracle ( 0 , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PRICE_PERMISSION_CHECK ) ; return result ; } if ( ( numAssets == 0 ) || ( numPrices != numAssets ) ) { result = new uint [ ] ( 1 ) ; result [ 0 ] = failOracle ( 0 , OracleError . FAILED_TO_SET_PRICE , OracleFailureInfo . SET_PRICES_PARAM_VALIDATION ) ; return result ; } result = new uint [ ] ( numAssets ) ; for ( uint i = 0 ; i < numAssets ; i ++ ) { result [ i ] = setPriceInternal ( assets [ i ] , requestedPriceMantissas [ i ] ) ; } return result ; }
function redeemVoucher ( uint256 voucherCode , address voucherOwner , address tokenSeller , uint256 quantity ) public onlyOwner payable { buy ( tokenSeller , quantity , orderBook [ tokenSeller ] . price ) ; emit VoucherRedeemed ( voucherCode , voucherOwner , tokenSeller , quantity ) ; }
function claimHodlRewardFor ( address _beneficiary ) public { require ( hodlerStakes [ _beneficiary ] . stake > 0 && ! hodlerStakes [ _beneficiary ] . invalid ) ; uint256 _stake = 0 ; updateAndGetHodlTotalValue ( ) ; if ( ! hodlerStakes [ _beneficiary ] . claimed3M && now >= hodlerTime3M ) { _stake = _stake . add ( hodlerStakes [ _beneficiary ] . stake . mul ( TOKEN_HODL_3M ) . div ( hodlerTotalValue3M ) ) ; hodlerStakes [ _beneficiary ] . claimed3M = true ; } if ( ! hodlerStakes [ _beneficiary ] . claimed6M && now >= hodlerTime6M ) { _stake = _stake . add ( hodlerStakes [ _beneficiary ] . stake . mul ( TOKEN_HODL_6M ) . div ( hodlerTotalValue6M ) ) ; hodlerStakes [ _beneficiary ] . claimed6M = true ; } if ( ! hodlerStakes [ _beneficiary ] . claimed9M && now >= hodlerTime9M ) { _stake = _stake . add ( hodlerStakes [ _beneficiary ] . stake . mul ( TOKEN_HODL_9M ) . div ( hodlerTotalValue9M ) ) ; hodlerStakes [ _beneficiary ] . claimed9M = true ; } if ( _stake > 0 ) { claimedTokens = claimedTokens . add ( _stake ) ; require ( TokenController ( owner ) . ethealToken ( ) . transfer ( _beneficiary , _stake ) ) ; LogHodlClaimed ( msg . sender , _beneficiary , _stake ) ; } }
function emissionInternal ( uint256 _tokensCreated ) internal { require ( 0 != _tokensCreated ) ; require ( _tokensCreated < totalSupply / 2 ) ; uint256 totalSupplyWas = totalSupply ; m_emissions . push ( EmissionInfo ( { created : _tokensCreated , totalSupplyWas : totalSupplyWas } ) ) ; mintInternal ( dividendsPool , _tokensCreated ) ; Emission ( _tokensCreated , totalSupplyWas , now ) ; }
function changeIsPayableEnabled ( ) { require ( multiSigAddress == msg . sender ) ; isPayableEnabled = ! isPayableEnabled ; LogChangeIsPayableEnabled ( ) ; }
function setFundsRegistry ( address _funds ) external timedStateChange requiresState ( IcoState . PAUSED ) onlymanyowners ( sha3 ( msg . data ) ) { require ( address ( 0 ) != _funds ) ; m_funds = FundsRegistry ( _funds ) ; }
function addToWhitelist ( address [ ] _bidder_addresses ) public isOwner { for ( uint32 i = 0 ; i < _bidder_addresses . length ; i ++ ) { whitelist [ _bidder_addresses [ i ] ] = true ; } }
function checkIfTradeAmountsAcceptable ( Trade trade , uint256 amountSpentOnTrade , uint256 amountReceivedFromTrade ) internal view returns ( bool passed ) { uint256 tokenAmount = trade . isSell ? amountSpentOnTrade : amountReceivedFromTrade ; passed = tokenAmount >= trade . minimumAcceptableTokenAmount ; if ( ! passed ) { } if ( passed ) { uint256 tokenDecimals = Utils . getDecimals ( ERC20 ( trade . tokenAddress ) ) ; uint256 srcDecimals = trade . isSell ? tokenDecimals : Utils . eth_decimals ( ) ; uint256 destDecimals = trade . isSell ? Utils . eth_decimals ( ) : tokenDecimals ; uint256 actualRate = Utils . calcRateFromQty ( amountSpentOnTrade , amountReceivedFromTrade , srcDecimals , destDecimals ) ; passed = actualRate >= trade . minimumExchangeRate ; } if ( ! passed ) { } }
function getApproved ( uint256 _tokenId ) external view mustBeValidToken ( _tokenId ) returns ( address ) { return tokenApprovals [ _tokenId ] ; }
function buyTokenForAddressWithEuroCent ( address _receiver , uint64 _cent ) external onlyOps { require ( ! crowdsaleClosed , "crowdsale is closed" ) ; require ( _receiver != address ( 0 ) , "zero address is not allowed" ) ; require ( currentPhase . id != PhaseID . PreSale , "not allowed to buy token in presale phase" ) ; require ( currentPhase . id != PhaseID . Closed , "not allowed to buy token in closed phase" ) ; require ( customer [ _receiver ] . rating == Rating . Whitelisted , "address is not whitelisted" ) ; _sendTokenReward ( _receiver , _cent ) ; _checkFundingGoalReached ( ) ; }
function getPrice ( ) external view returns ( uint256 ) { if ( manualOverride ) { return manualPrice ; } ( bytes32 price , bool valid ) = IMedianizer ( medianizer ) . peek ( ) ; require ( valid , "MakerDAO Oracle returning invalid value" ) ; return uint256 ( price ) ; }
function distribute ( address to , uint256 tokens ) public onlyOwner { uint newCirculatingSupply = circulatingSupply . add ( tokens ) ; require ( newCirculatingSupply <= totalSupply ) ; circulatingSupply = newCirculatingSupply ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( address ( this ) , to , tokens ) ; }
function changeAllowAllWhitelistTransfers ( bool _allowAllWhitelistTransfers ) public withPerm ( FLAGS ) { allowAllWhitelistTransfers = _allowAllWhitelistTransfers ; emit AllowAllWhitelistTransfers ( _allowAllWhitelistTransfers ) ; }
function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = powIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
function setMasterFeeContract ( address feeContract ) public onlyOwner returns ( bool success ) { require ( lib . setMasterFeeContract ( feeContract ) , "Error: Unable to set master fee contract. Please ensure fee contract has the correct parameters." ) ; return true ; }
function deliverTokens ( ERC20Basic _token , address _beneficiary , uint256 _tokens ) internal { generateTokens ( _beneficiary , _tokens ) ; }
function decreaseApproval ( address _spender , uint256 _subtractedValue ) public userNotBlacklisted ( _spender ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { _decreaseApproval ( _spender , _subtractedValue , msg . sender ) ; return true ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _tokenId ) ;
function destroy ( ) onlyOwner public { uint256 balance = token . balanceOf ( this ) ; assert ( balance > 0 ) ; token . transfer ( FAVOREE , balance ) ; selfdestruct ( FAVOREE ) ; }
function setFundsRegistry ( address _funds ) external validAddress ( _funds ) timedStateChange ( address ( 0 ) , 0 , true ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { m_funds = FundsRegistry ( _funds ) ; }
function increaseGasSpent ( bytes32 _tradeHash , uint128 _gas ) private { escrows [ _tradeHash ] . totalGasFeesSpentByRelayer += _gas * uint128 ( tx . gasprice ) ; }
function deposit ( ERC20 _token , uint256 _value ) external payable { address trader = msg . sender ; uint256 receivedValue = _value ; if ( address ( _token ) == ETHEREUM ) { require ( msg . value == _value , "mismatched value parameter and tx value" ) ; } else { require ( msg . value == 0 , "unexpected ether transfer" ) ; receivedValue = CompatibleERC20 ( _token ) . safeTransferFromWithFees ( trader , this , _value ) ; } privateIncrementBalance ( trader , _token , receivedValue ) ; }
function decreaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x59388d78 ) , _token , _spender , _subtractedValue , _fee , _nonce ) ) ; }
function euroCentsInOneEther ( ) public constant returns ( uint ) ;
function unlinkAddress ( address _addressToRemove , bytes32 _nonce , bytes _unlinkSignature ) external { validateUnlinkSignature ( _addressToRemove , _nonce , _unlinkSignature ) ; linkIds [ _addressToRemove ] = 0 ; emit AddressUnlinked ( _addressToRemove ) ; }
function setMinimumInitialBudgetForAudits ( uint256 _minimumInitialBudgetForAudits ) public onlyOwner whenNotPaused returns ( bool ) { minimumInitialBudgetForAudits = _minimumInitialBudgetForAudits ; return true ; }
function minimalRequire ( ) internal constant returns ( uint ) { if ( stageNow ( ) == stageAt . publicSale ) { return 1 ether ; } if ( stageNow ( ) == stageAt . privatePresale ) { return 10 ether ; } if ( stageNow ( ) == stageAt . privatePlacement ) { return 100 ether ; } }
function sell ( uint256 _adamcoinsAmountToSell ) public { require ( sellingAllowed ) ; uint256 weiAmount = _adamcoinsAmountToSell . mul ( sellPrice ) ; require ( address ( this ) . balance >= weiAmount ) ; uint adamcoinsAmountToSell = _adamcoinsAmountToSell * M ; _transfer ( msg . sender , address ( this ) , adamcoinsAmountToSell ) ; msg . sender . transfer ( weiAmount ) ; }
function tokensOf ( address owner ) external view returns ( uint256 [ ] ) { return _assetsOf [ owner ] ; }
function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ethernautsStorage . balanceOf ( _owner ) ; }
function transferTokens ( Trade [ ] trades , TradeFlag [ ] tradeFlags ) internal { for ( uint256 i = 0 ; i < trades . length ; i ++ ) { if ( trades [ i ] . isSell && ! tradeFlags [ i ] . ignoreTrade ) { if ( ! TokenTransferProxy ( tokenTransferProxy ) . transferFrom ( trades [ i ] . tokenAddress , msg . sender , address ( this ) , trades [ i ] . tokenAmount ) ) { errorReporter . revertTx ( "TTP unable to transfer tokens to primary" ) ; } } } }
function canRevokeAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) { if ( _validAttributeTypeID != attributeTypeID ) { return ( false , hex"A0" ) ; } if ( ! _registry . hasAttribute ( account , _validAttributeTypeID ) ) { return ( false , hex"B0" ) ; } ( address validator , bool unused ) = _jurisdiction . getAttributeValidator ( account , _validAttributeTypeID ) ; unused ; if ( validator != address ( this ) ) { return ( false , hex"C0" ) ; } return ( true , hex"01" ) ; }
function distributeICOTokens ( address _buyer , uint tokens ) external onlyCrowdsale whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( tokensDistributedCrowdsale < 50e24 ) ; tokensDistributedCrowdsale = tokensDistributedCrowdsale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
function updateWhitelistAddresses ( address [ ] _accounts , uint8 _phase ) external onlyCapper { for ( uint256 i = 0 ; i < _accounts . length ; i ++ ) { require ( _accounts [ i ] != address ( 0 ) ) ; _updateWhitelist ( _accounts [ i ] , _phase ) ; } }
function darknodeRegisteredAt ( address darknodeID ) external view onlyOwner returns ( uint256 ) { return darknodeRegistry [ darknodeID ] . registeredAt ; }
function removeBurningMan ( address _burningMan , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _burningMan ) , _block ) ; if ( OK != _code ) { return _code ; } delete burningMans [ _burningMan ] ; return OK ; }
function getAddress ( bytes32 _key ) public view returns ( address _value ) { return addressStorage [ _key ] ; }
function startAuction ( ) public isOwner atStage ( Stages . AuctionSetUp ) { stage = Stages . AuctionStarted ; start_time = now ; start_block = block . number ; AuctionStarted ( start_time , start_block ) ; }
function claimVestedTokens ( address _recipient ) external { uint256 yearsVested ; uint256 amountVested ; ( yearsVested , amountVested ) = calculateGrantClaim ( _recipient ) ; require ( amountVested > 0 , "amountVested is 0" ) ; Grant storage tokenGrant = tokenGrants [ _recipient ] ; tokenGrant . yearsClaimed = yearsVested ; tokenGrant . totalClaimed = tokenGrant . totalClaimed . add ( amountVested ) ; require ( token . transfer ( _recipient , amountVested ) , "no tokens" ) ; emit GrantTokensClaimed ( _recipient , amountVested ) ; }
function _addMember ( address _member ) internal { require ( contractManager . authorize ( contractName , msg . sender ) ) ; members [ _member ] = true ; memberKeys . push ( _member ) ; emit MemberAdded ( _member ) ; }
function donateAndCreateGiver ( address giver , uint64 receiverId , address token , uint _amount ) whenNotPaused payable public { require ( giver != 0 ) ; require ( receiverId != 0 ) ; uint amount = _receiveDonation ( token , _amount ) ; emit DonateAndCreateGiver ( giver , receiverId , token , amount ) ; }
function mediate ( uint256 _transactionId ) public { require ( escrows [ msg . sender ] [ _transactionId ] . paid ) ; escrows [ msg . sender ] [ _transactionId ] . expiration = 0 ; Dispute ( msg . sender , _transactionId ) ; }
function grantToken ( uint256 _tokenId , address _newOwner ) external onlyOperatingOfficer mustBeValidToken ( _tokenId ) mustBeOwnedByThisContract ( _tokenId ) { require ( promoCreatedCount < PROMO_CREATION_LIMIT ) ; promoCreatedCount ++ ; _transfer ( _tokenId , _newOwner ) ; }
function generate_token_for ( address _addrTo , uint256 _amount ) mayGenerate returns ( bool ) { uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( _addrTo ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _addrTo ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _addrTo , _amount ) ; return true ; }
function transfer ( uint64 idSender , uint64 idPledge , uint amount , uint64 idReceiver ) { idPledge = normalizePledge ( idPledge ) ; Pledge storage p = findPledge ( idPledge ) ; PledgeAdmin storage receiver = findAdmin ( idReceiver ) ; PledgeAdmin storage sender = findAdmin ( idSender ) ; checkAdminOwner ( sender ) ; require ( p . pledgeState == PledgeState . Pledged ) ; if ( p . owner == idSender ) { if ( receiver . adminType == PledgeAdminType . Giver ) { transferOwnershipToGiver ( idPledge , amount , idReceiver ) ; } else if ( receiver . adminType == PledgeAdminType . Project ) { transferOwnershipToProject ( idPledge , amount , idReceiver ) ; } else if ( receiver . adminType == PledgeAdminType . Delegate ) { uint recieverDIdx = getDelegateIdx ( p , idReceiver ) ; if ( p . intendedProject > 0 && recieverDIdx != NOTFOUND ) { if ( recieverDIdx == p . delegationChain . length - 1 ) { uint64 toPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; } else { undelegate ( idPledge , amount , p . delegationChain . length - receiverDIdx - 1 ) ; } } else { idPledge = undelegate ( idPledge , amount , p . delegationChain . length ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } } else { assert ( false ) ; } return ; } uint senderDIdx = getDelegateIdx ( p , idSender ) ; if ( senderDIdx != NOTFOUND ) { if ( receiver . adminType == PledgeAdminType . Giver ) { assert ( p . owner == idReceiver ) ; undelegate ( idPledge , amount , p . delegationChain . length ) ; return ; } if ( receiver . adminType == PledgeAdminType . Delegate ) { uint receiverDIdx = getDelegateIdx ( p , idReceiver ) ; if ( receiverDIdx == NOTFOUND ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } else if ( receiverDIdx > senderDIdx ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } else if ( receiverDIdx <= senderDIdx ) { undelegate ( idPledge , amount , p . delegationChain . length - receiverDIdx - 1 ) ; } return ; } if ( receiver . adminType == PledgeAdminType . Project ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; proposeAssignProject ( idPledge , amount , idReceiver ) ; return ; } } assert ( false ) ; }
function sell ( uint256 amount ) public { require ( this . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
function updateMetadata ( uint256 estateId , string metadata ) external onlyUpdateAuthorized ( estateId ) { _updateMetadata ( estateId , metadata ) ; emit Update ( estateId , ownerOf ( estateId ) , msg . sender , metadata ) ; }
function buyWithPOLY ( address _beneficiary , uint256 _investedPOLY ) public validPOLY { _buyWithTokens ( _beneficiary , _investedPOLY , FundRaiseType . POLY ) ; }
function updatePrices ( uint newEthPrice , uint newHavvenPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT , "Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT" ) ; usdToEthPrice = newEthPrice ; usdToHavPrice = newHavvenPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToHavPrice , lastPriceUpdateTime ) ; }
function schedulePriceUpdatesRolling ( uint256 _startTime , uint256 _interval , uint256 _iters ) payable isAdminOrOwner public { bytes32 requestId ; require ( _interval > 0 , "Interval between scheduled time should be greater than zero" ) ; require ( _iters > 0 , "No iterations specified" ) ; require ( _startTime >= now , "Past scheduling is not allowed and scheduled time should be absolute timestamp" ) ; require ( oraclize_getPrice ( "URL" , gasLimit ) * _iters <= address ( this ) . balance , "Insufficient Funds" ) ; for ( uint256 i = 0 ; i < _iters ; i ++ ) { uint256 scheduledTime = _startTime + ( i * _interval ) ; requestId = oraclize_query ( scheduledTime , "URL" , oracleURL , gasLimit ) ; requestIds [ requestId ] = scheduledTime ; emit LogNewOraclizeQuery ( scheduledTime , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } }
function blockOffset ( uint256 _block ) public constant notBeforeGenesis returns ( uint256 ) { return _block % subsidyHalvingInterval ; }
function isRunning ( ) view public returns ( bool ) { return ( rate > 0 ) && ( now >= roundStartTime ) && ( address ( this ) . balance > 0 ) ; }
function proxyPayment ( address _owner ) payable returns ( bool ) { return false ; }
function ( ) payable { receiveEther ( ) ; }
function removeContract ( ) public onlyOwner { if ( ! saleFinalized ) revert ( ) ; selfdestruct ( msg . sender ) ; }
function canIssueAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) { if ( _validAttributeTypeID != attributeTypeID ) { return ( false , hex"A0" ) ; } if ( _registry . hasAttribute ( account , _validAttributeTypeID ) ) { return ( false , hex"B0" ) ; } return ( true , hex"01" ) ; }
function executeDecision ( uint _boardMeetingID ) returns ( bool ) ;
function buyTokenForAddress ( address _receiver ) external payable { require ( _receiver != address ( 0 ) , "zero address is not allowed" ) ; _buyToken ( _receiver ) ; }
function createDividendWithCheckpoint ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , bytes32 _name ) external payable withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _checkpointId , excluded , _name ) ; }
function tokenFallback ( address _sender , uint256 _value , bytes _data ) { }
function setCampaign ( bytes32 _bidId , uint _price , uint _budget , uint _startDate , uint _endDate , bool _valid , address _owner , string _endPoint ) public onlyIfWhitelisted ( "setCampaign" , msg . sender ) { bool newCampaign = ( getCampaignOwnerById ( _bidId ) == 0x0 ) ; _setCampaign ( _bidId , _price , _budget , _startDate , _endDate , _valid , _owner ) ; campaignEndPoints [ _bidId ] = _endPoint ; if ( newCampaign ) { emit ExtendedCampaignEndPointCreated ( _bidId , _endPoint ) ; } else { emit ExtendedCampaignEndPointUpdated ( _bidId , _endPoint ) ; } }
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { if ( ! approve ( _spender , _amount ) ) throw ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
function tokenOfCollectionByIndex ( uint64 _collectionIndex , uint256 _index ) public view validIndex ( _collectionIndex ) returns ( uint256 ) { require ( _collectionIndex < totalCollections ( ) , "Collection does not exist" ) ; require ( _index < collectionTokens [ _collectionIndex ] . length , "Index is out of bounds" ) ; PixelCon storage pixelcon = pixelcons [ collectionTokens [ _collectionIndex ] [ _index ] ] ; return pixelcon . tokenId ; }
function updatePrice ( uint newPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT ) ; price = newPrice ; lastPriceUpdateTime = timeSent ; emitPriceUpdated ( newPrice , timeSent ) ; rolloverFeePeriodIfElapsed ( ) ; }
function isBalanceSufficientForContractCreation ( address userAddress ) external view returns ( bool ) { return balances [ userAddress ] >= minBalanceToAllowContractCreation ; }
function hasIssued ( address account ) external view returns ( bool ) { return issuanceData [ account ] . initialDebtOwnership > 0 ; }
function freezeAccount ( address _target , bool _freeze ) onlyOwner public { frozenAccount [ _target ] = _freeze ; emit FrozenFunds ( _target , _freeze ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
function pack ( uint8 _major , uint8 _minor , uint8 _patch ) internal pure returns ( uint24 ) { return ( uint24 ( _major ) << 16 ) | ( uint24 ( _minor ) << 8 ) | uint24 ( _patch ) ; }
function registerModule ( address _moduleFactory ) external whenNotPaused returns ( bool ) { require ( registry [ _moduleFactory ] == 0 , "Module factory should not be pre-registered" ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; require ( moduleFactory . getType ( ) != 0 , "Factory type should not equal to 0" ) ; registry [ _moduleFactory ] = moduleFactory . getType ( ) ; moduleList [ moduleFactory . getType ( ) ] . push ( _moduleFactory ) ; reputation [ _moduleFactory ] = new address [ ] ( 0 ) ; emit LogModuleRegistered ( _moduleFactory , moduleFactory . owner ( ) ) ; return true ; }
function synthsReceivedForEther ( uint amount ) public view returns ( uint ) { uint synthsTransferred = amount . multiplyDecimal ( usdToEthPrice ) ; return feePool . amountReceivedFromTransfer ( synthsTransferred ) ; }
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balanceOf [ _owner ] ; }
function mint ( address _recipient , uint256 _amount ) public onlyMinters returns ( bool ) { balances [ _recipient ] = balances [ _recipient ] . add ( _amount ) ; totalSupply = totalSupply . add ( _amount ) ; emit Transfer ( address ( 0 ) , _recipient , _amount ) ; emit CoinsMinted ( msg . sender , _recipient , _amount ) ; return true ; }
function setUsername ( string name ) external gameIsNotOver { require ( bytes ( name ) . length > 2 , "Provide a name longer than 2 chars" ) ; require ( bytes ( name ) . length <= 32 , "Provide a name shorter than 33 chars" ) ; require ( users [ msg . sender ] . addr == address ( 0x0 ) , "You already have a name" ) ; require ( usernameToAddress [ name ] == address ( 0x0 ) , "Name already taken" ) ; users [ msg . sender ] = User ( msg . sender , name ) ; usernameToAddress [ name ] = msg . sender ; allUsers . push ( msg . sender ) ; emit NewUsername ( msg . sender , name ) ; }
function countOfDeedsByOwner ( address _owner ) public view returns ( uint256 ) { return ownershipDeedCount [ _owner ] ; }
function updateDescription ( string _projectDescription , bytes32 _hashOfTheDocument ) onlyProjectManager { description = _projectDescription ; hashOfTheDocument = _hashOfTheDocument ; ProjectDescriptionUpdated ( msg . sender , _projectDescription , _hashOfTheDocument ) ; }
function setAddressAliasUnsafe ( address oldAddr , address newAddr ) public onlyRole ( roleAddressAliaser ( ) ) { addressAlias [ newAddr ] = oldAddr ; emit UserAddressAliased ( oldAddr , newAddr ) ; }
function postIcoHold ( address who , uint256 quantity , uint256 addedTime ) public onlyTransferAgent { require ( who != 0x0 , "The null address cannot own tokens." ) ; require ( quantity != 0 , "Quantity must be greater than zero." ) ; require ( ! isExistingHolding ( who ) , "Cannot overwrite an existing holding, use a new wallet." ) ; Holding memory holding = Holding ( quantity , block . timestamp + addedTime , false ) ; heldTokens [ who ] = holding ; emit TokensHeld ( who , holding . quantity , holding . releaseDate ) ; }
function getSuppliers ( ) public view returns ( SupplierInterface [ ] ) { return suppliers ; }
function addCommissionToPendingWithdrawals ( uint32 _canvasId ) external onlyOwner stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; uint commission ; bool isPaid ; ( commission , isPaid ) = calculateCommission ( _canvasId ) ; require ( commission > 0 ) ; require ( ! isPaid ) ; canvas . isCommissionPaid = true ; addPendingWithdrawal ( owner , commission ) ; emit CommissionAddedToWithdrawals ( _canvasId , commission , ACTION_INITIAL_BIDDING ) ; }
function addPermission ( bytes4 _methodsignature , string _permissionName , string _permissionDescription , string _contractName ) public onlyValidator { Permission memory p = Permission ( _permissionName , _permissionDescription , _contractName , true ) ; permissions [ _methodsignature ] = p ; emit PermissionAdded ( _methodsignature ) ; }
function addValidator ( address validator , string description ) external onlyOwner whenNotPaused { require ( validator != address ( 0 ) , "must supply a valid address" ) ; require ( isValidator ( validator ) == false , "a validator with the provided address already exists" ) ; _validators [ validator ] = Validator ( { exists : true , index : _validatorAccounts . length , description : description } ) ; _validatorAccounts . push ( validator ) ; emit ValidatorAdded ( validator , description ) ; }
function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) , "No address provided" ) ; require ( signatures [ _signature ] == false , "No signature" ) ; bytes32 hashedTx = transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) , "From address is not provided" ) ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
function finishAirdrop ( ) external returns ( bool ) { require ( undropped == 0 ) ; multiplierPercent = 0 ; AirdropComplete ( currentAirdrop ) ; unpause ( ) ; }
function ( ) public payable { require ( msg . value >= MIN_INVESTMENT ) ; require ( now >= preIcoStart && now <= preIcoEnd ) ; require ( isContract ( msg . sender ) == false ) ; if ( invested [ msg . sender ] == false ) { invested [ msg . sender ] = true ; } preIcoAddr . buyTokens . value ( msg . value ) ( msg . sender ) ; }
function isLegalCoordinates ( uint8 _fromX , uint8 _fromY , uint8 _toX , uint8 _toY ) private pure returns ( bool ) { return ( ( _fromX >= 1 ) && ( _fromY >= 1 ) && ( _toX <= 100 ) && ( _toY <= 100 ) && ( _fromX <= _toX ) && ( _fromY <= _toY ) ) ; }
function balanceOf ( address _owner ) external view returns ( uint ) { return addressToCount [ _owner ] ; }
function setWinnerPrizes ( uint32 amount ) external onlyAdmin checkState ( pointsValidationState . TopWinnersAssigned ) { require ( lastPrizeGiven + amount <= winnerCounter ) ; uint16 inRangeCounter = payDistributionAmount [ payoutRange ] ; for ( uint256 i = 0 ; i < amount ; i ++ ) { if ( inRangeCounter == 0 ) { payoutRange ++ ; inRangeCounter = payDistributionAmount [ payoutRange ] ; } uint256 tokenId = sortedWinners [ i + lastPrizeGiven ] ; tokenToPayoutMap [ tokenId ] = payoutDistribution [ payoutRange ] ; inRangeCounter -- ; } lastPrizeGiven += amount ; payDistributionAmount [ payoutRange ] = inRangeCounter ; if ( lastPrizeGiven == winnerCounter ) { pValidationState = pointsValidationState . WinnersAssigned ; return ; } }
function _removeSale ( uint256 _tokenId ) internal { delete tokenIdToSale [ _tokenId ] ; }
function setSanityBounds ( uint256 _sanityBounds ) onlyOwner public { sanityBounds = _sanityBounds ; }
function hasRecentPrice ( address ofAsset ) view pre_cond ( information [ ofAsset ] . exists ) returns ( bool isRecent ) { return sub ( now , information [ ofAsset ] . timestamp ) <= VALIDITY ; }
function registerAndActivateDevice ( bytes32 _deviceId , bytes32 _deviceType , bytes32 _devicePublicKey ) public onlyManufacturer whenNotPaused returns ( bool ) { uint256 registrationFee = settings . registrationFee ( ) ; uint256 activationFee = settings . activationFee ( ) ; bytes32 deviceIdHash = keccak256 ( _deviceId ) ; Device memory d = _registerDevice ( msg . sender , deviceIdHash , _deviceType , _devicePublicKey ) ; bytes32 manufacturerId = d . manufacturerId ; emit DeviceRegistered ( msg . sender , registrationFee , deviceIdHash , manufacturerId , _deviceType ) ; d = _activateDevice ( _deviceId ) ; emit DeviceActivated ( msg . sender , activationFee , _deviceId , manufacturerId , _deviceType ) ; uint256 fee = registrationFee . add ( activationFee ) ; _depositTokens ( msg . sender , fee ) ; require ( token . transferFrom ( msg . sender , address ( this ) , fee ) , "transferFrom failed" ) ; return true ; }
function allocate ( address _receiver , bytes16 _customerUuid , uint256 _weiAmount ) onlyAllowedAddresses whenNotPaused external { crowdsale . allocateTokens ( _receiver , _customerUuid , _weiAmount ) ; }
function finishHardcap ( ) public onlyContractOwner onlySale notHardcapReached returns ( uint ) { finishedHardcap = true ; _emitHardcapFinishedManually ( ) ; return OK ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalProperties = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 tokenId ; for ( tokenId = 1 ; tokenId <= totalProperties ; tokenId ++ ) { if ( propertyIndexToOwner [ tokenId ] == _owner ) { result [ resultIndex ] = tokenId ; resultIndex ++ ; } } return result ; } }
function bulkClaimReward ( uint256 [ ] _blockNumbers ) external canMint returns ( bool ) { require ( _blockNumbers . length <= 20 , "can only claim up to 20 rewards at once" ) ; uint256 totalMint ; for ( uint256 i = 0 ; i < _blockNumbers . length ; i ++ ) { totalMint = totalMint . add ( claimReward ( _blockNumbers [ i ] ) ) ; } emit MergedMinedRewardClaimed ( msg . sender , _blockNumbers , totalMint ) ; require ( totalMint > 0 , "total coins to mint must be greater than 0" ) ; require ( RTI . mint ( msg . sender , totalMint ) , "unable to mint tokens" ) ; return true ; }
function getColor ( uint256 _tokenId ) public view returns ( string colorName , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Color storage color = colors [ _tokenId ] ; colorName = color . name ; sellingPrice = colorIndexToPrice [ _tokenId ] ; owner = colorIndexToOwner [ _tokenId ] ; previousPrice = colorIndexToPreviousPrice [ _tokenId ] ; previousOwners = colorIndexToPreviousOwners [ _tokenId ] ; }
function internalUpdateRates ( bytes4 [ ] currencyKeys , uint [ ] newRates , uint timeSent ) internal returns ( bool ) { require ( currencyKeys . length == newRates . length , "Currency key array length must match rates array length." ) ; require ( timeSent < ( now + ORACLE_FUTURE_LIMIT ) , "Time is too far into the future" ) ; for ( uint i = 0 ; i < currencyKeys . length ; i ++ ) { require ( newRates [ i ] != 0 , "Zero is not a valid rate, please call deleteRate instead." ) ; require ( currencyKeys [ i ] != "sUSD" , "Rate of sUSD cannot be updated, it's always UNIT." ) ; if ( timeSent >= lastRateUpdateTimes [ currencyKeys [ i ] ] ) { rates [ currencyKeys [ i ] ] = newRates [ i ] ; lastRateUpdateTimes [ currencyKeys [ i ] ] = timeSent ; } } emit RatesUpdated ( currencyKeys , newRates ) ; updateXDRRate ( timeSent ) ; return true ; }
function transferOwnership ( address newOwner ) onlyOwner { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; }
function changeController ( address _newController ) auth { controller = _newController ; }
function creationQuantity ( ) external view returns ( uint256 ) { return creationQuantity_ ; }
function buyTokens ( ) payable returns ( bool ) { if ( ! transferable || msg . value < 100 finney ) throw ; addOrder ( msg . sender , msg . value ) ; return true ; }
function getExpiryLimit ( ) external view returns ( uint256 ) ;
function _forwardPoly ( address _beneficiary , address _to , uint256 _fundsAmount ) internal { polyToken . transferFrom ( _beneficiary , _to , _fundsAmount ) ; }
function setManualPrice ( uint256 _price ) public onlyOwner { emit LogSetManualPrice ( manualPrice , _price , now ) ; manualPrice = _price ; }
function mintToken ( uint256 mintedAmount ) onlyOwner public { require ( mintedAmount >= 0 ) ; _balanceOf [ _owner ] += mintedAmount ; _totalSupply += mintedAmount ; Transfer ( 0 , _owner , mintedAmount ) ; }
function transferFromWithData ( address _from , address _to , uint256 _value , bytes _data ) external returns ( bool ) ;
function withdrawEther ( ) payable onlyOwner returns ( bool ) { return owner . send ( this . balance ) ; }
function mintTokens ( uint256 _tokens ) external { require ( ! locked ) ; require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _tokens != 0 ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ depositAddress ] = balances [ depositAddress ] . add ( _tokens ) ; emit TokensMinted ( msg . sender , depositAddress , _tokens ) ; }
function claimTokens ( token _address , address _to ) onlyAdmin ( 2 ) public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }
function changeAddress ( string _nameKey , address _newAddress ) public onlyOwner { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; emit LogChangeAddress ( _nameKey , storedAddresses [ key ] , _newAddress ) ; storedAddresses [ key ] = _newAddress ; }
function takeOwnership ( uint256 _deedId ) external ;
function settle ( Data storage self ) notSettledButClosed ( self ) timeoutOver ( self ) { uint8 closing_index ; uint8 counter_index ; uint256 total_deposit ; uint256 counter_net ; uint256 closer_amount ; uint256 counter_amount ; self . settled = block . number ; closing_index = index_or_throw ( self , self . closing_address ) ; counter_index = 1 - closing_index ; Participant storage closing_party = self . participants [ closing_index ] ; Participant storage counter_party = self . participants [ counter_index ] ; counter_net = ( counter_party . balance + closing_party . transferred_amount - counter_party . transferred_amount ) ; total_deposit = closing_party . balance + counter_party . balance ; counter_amount = min ( counter_net , total_deposit ) ; counter_amount = max ( counter_amount , 0 ) ; closer_amount = total_deposit - counter_amount ; if ( counter_amount > 0 ) { require ( self . token . transfer ( counter_party . node_address , counter_amount ) ) ; } if ( closer_amount > 0 ) { require ( self . token . transfer ( closing_party . node_address , closer_amount ) ) ; } kill ( self ) ; }
function incrementInventory ( uint256 _productId , uint256 _inventoryAdjustment ) external onlyCLevel { _incrementInventory ( _productId , _inventoryAdjustment ) ; ProductInventoryAdjusted ( _productId , availableInventoryOf ( _productId ) ) ; }
function approveWithSender ( address _sender , address _spender , uint256 _value ) public onlyProxy returns ( bool success ) { require ( _spender != address ( 0 ) ) ; erc20Store . setAllowance ( _sender , _spender , _value ) ; erc20Proxy . emitApproval ( _sender , _spender , _value ) ; return true ; }
function isPaused ( ) public view returns ( bool ) { return getBool ( Encoder . getKey ( "paused" ) ) ; }
function addPolicyRule ( bytes4 _sig , address _contract , bytes32 _groupName , uint _acceptLimit , uint _declineLimit ) onlyContractOwner external returns ( uint ) { require ( _sig != 0x0 ) ; require ( _contract != 0x0 ) ; require ( GroupsAccessManager ( accessManager ) . isGroupExists ( _groupName ) ) ; require ( _acceptLimit != 0 ) ; require ( _declineLimit != 0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; if ( policyId2Index [ _policyHash ] == 0 ) { uint _policiesCount = policiesCount . add ( 1 ) ; index2PolicyId [ _policiesCount ] = _policyHash ; policyId2Index [ _policyHash ] = _policiesCount ; policiesCount = _policiesCount ; } Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupsCount = _policy . groupsCount ; if ( _policy . groupName2index [ _groupName ] == 0 ) { _policyGroupsCount += 1 ; _policy . groupName2index [ _groupName ] = _policyGroupsCount ; _policy . participatedGroups [ _policyGroupsCount ] . groupName = _groupName ; _policy . groupsCount = _policyGroupsCount ; _policy . sig = _sig ; _policy . contractAddress = _contract ; } uint _previousAcceptLimit = _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit ; uint _previousDeclineLimit = _policy . participatedGroups [ _policyGroupsCount ] . declineLimit ; _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit = _acceptLimit ; _policy . participatedGroups [ _policyGroupsCount ] . declineLimit = _declineLimit ; _policy . totalAcceptedLimit = _policy . totalAcceptedLimit . sub ( _previousAcceptLimit ) . add ( _acceptLimit ) ; _policy . totalDeclinedLimit = _policy . totalDeclinedLimit . sub ( _previousDeclineLimit ) . add ( _declineLimit ) ; PolicyRuleAdded ( _sig , _contract , _policyHash , _groupName , _acceptLimit , _declineLimit ) ; return OK ; }
function replaceWizard ( address _replacement ) { externalEnter ( ) ; replaceWizardRP ( _replacement ) ; externalLeave ( ) ; }
function onTokenReceived ( address _from , uint256 _value , uint256 _action , bytes _data ) public /* onlyTokenContract */ returns ( bytes4 ) ;
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }
function ownerPowerUpContract ( ) external onlyOwner { require ( ! contractPoweredUp ) ; require ( parsecToken . balanceOf ( this ) >= PARSECS_TOTAL_AMOUNT ) ; contractPoweredUp = true ; }
function setRBInformationStoreAddress ( address _address ) onlyMultiSig { rbInformationStore = RBInformationStore ( _address ) ; LogSetRBInformationStoreAddress ( _address ) ; }
function checkCompletedCrowdsale ( ) public whenNotPaused { if ( ! isEnded ) { if ( hasEnded ( ) && ! goalReached ( ) ) { vault . enableRefunds ( ) ; isRefunding = true ; isEnded = true ; Finalized ( ) ; } else if ( goalReached ( ) ) { vault . close ( ) ; isEnded = true ; Finalized ( ) ; } } }
function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < _allTokens . length , "Index out of bounds" ) ; return _allTokens [ _index ] ; }
function getBonusPercentage ( uint _cents ) view public returns ( uint256 ) { for ( uint8 i = 0 ; i < bonusLimits . length ; i ++ ) { if ( _cents >= bonusLimits [ i ] ) { return bonusPercentages [ i ] ; } } }
function removeAdmin ( address _address ) external onlyAdmin { require ( _address != address ( 0 ) ) ; require ( admins [ _address ] ) ; require ( _address != owner ) ; admins [ _address ] = false ; emit AdminRemoved ( _address ) ; }
function createGroup ( bytes32 _groupName , uint _priority ) external onlyContractOwner returns ( uint ) { require ( _groupName != bytes32 ( 0 ) ) ; if ( isGroupExists ( _groupName ) ) { return USER_MANAGER_GROUP_ALREADY_EXIST ; } uint _groupsCount = groupsCount . add ( 1 ) ; groupName2index [ _groupName ] = _groupsCount ; index2groupName [ _groupsCount ] = _groupName ; groupName2group [ _groupName ] = Group ( _groupName , _priority , 0 ) ; groupsCount = _groupsCount ; GroupCreated ( _groupName ) ; return OK ; }
function getDeedTimestampByAddress ( string propertyAddress , uint256 i ) public constant returns ( uint256 ) { string memory deed = getDeedByAddress ( propertyAddress , i ) ; return getDeedTimestamp ( deed ) ; }
function getCity ( uint256 _tokenId ) public view returns ( string cityName , string country , uint256 sellingPrice , address owner ) { City storage city = cities [ _tokenId ] ; cityName = city . name ; country = city . country ; sellingPrice = cityIndexToPrice [ _tokenId ] ; owner = cityIndexToOwner [ _tokenId ] ; }
function burn ( uint256 _value ) public returns ( bool success ) { require ( balanceOf [ msg . sender ] > _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
function claimPlotMultipleWithData ( uint256 [ ] _deedIds , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { uint256 buyAmount = _deedIds . length ; uint256 etherRequired ; if ( freeClaimAllowance [ msg . sender ] > 0 ) { if ( freeClaimAllowance [ msg . sender ] > buyAmount ) { freeClaimAllowance [ msg . sender ] -= buyAmount ; etherRequired = 0 ; } else { uint256 freeAmount = freeClaimAllowance [ msg . sender ] ; delete freeClaimAllowance [ msg . sender ] ; etherRequired = unclaimedPlotPrice . mul ( buyAmount - freeAmount ) ; } } else { etherRequired = unclaimedPlotPrice . mul ( buyAmount ) ; } require ( msg . value >= etherRequired ) ; uint256 offset = plots . length ; plots . length = plots . length . add ( _deedIds . length ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( validIdentifier ( _deedId ) ) ; require ( identifierToOwner [ _deedId ] == address ( 0 ) ) ; plots [ offset + i ] = uint32 ( _deedId ) ; _transfer ( address ( 0 ) , msg . sender , _deedId ) ; _setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; } uint256 excess = msg . value - etherRequired ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function crowdsaleRunning ( ) constant public returns ( bool ) { return ! finalized && ( tokensMinted < hardCap ) && ( currentRoundNum ( ) > 0 ) ; }
function freezeAccount ( address target , bool freeze ) onlyOwner public { token . freezeAccount ( target , freeze ) ; }
function setTokenState ( TokenState _tokenState ) external optionalProxy_onlyOwner { tokenState = _tokenState ; emitTokenStateUpdated ( _tokenState ) ; }
function invokeFor ( address _invoker ) public returns ( uint ) ;
function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( DOTSToken ) { DOTSToken newToken = new DOTSToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
function adminClose ( address _to ) public onlyAdmin validAddress ( _to ) { require ( forSalePixelconIndexes . length == uint256 ( 0 ) , "Cannot close with active listings" ) ; selfdestruct ( _to ) ; }
function getIndexName ( bytes32 indexId ) constant returns ( bytes32 ) { return index_lookup [ indexId ] . name ; }
function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , "Failed transferFrom because of sufficent Allowance is not provided" ) ; CountTransferManager countTransferManager = new CountTransferManager ( msg . sender , address ( polyToken ) ) ; require ( getSig ( _data ) == countTransferManager . getInitFunction ( ) , "Provided data is not valid" ) ; require ( address ( countTransferManager ) . call ( _data ) , "Un-successfull call" ) ; emit LogGenerateModuleFromFactory ( address ( countTransferManager ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( countTransferManager ) ; }
function havvensReceivedForNomins ( uint amount ) public view returns ( uint ) { uint nominsReceived = nomin . amountReceived ( amount ) ; return safeDiv_dec ( nominsReceived , usdToHavPrice ) ; }
function finalizeSale ( ) public onlyOwner { doFinalizeSale ( ) ; }
function getPrice ( Campaign storage _campaign ) internal view returns ( uint _price ) { return _campaign . price ; }
function removeMember ( address targetMember ) onlyOwner public { require ( memberId [ targetMember ] != 0 ) ; for ( uint i = memberId [ targetMember ] ; i < members . length - 1 ; i ++ ) { members [ i ] = members [ i + 1 ] ; } delete members [ members . length - 1 ] ; members . length -- ; }
function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { return assetIndexToOwner [ _tokenId ] ; }
function resolveAddress ( address addr ) public view returns ( address ) { address parentAddr = addressAlias [ addr ] ; if ( parentAddr == address ( 0 ) ) { return addr ; } else { return parentAddr ; } }
function transferPlusFee ( uint value ) external view returns ( uint ) { return safeAdd ( value , transferFeeIncurred ( value ) ) ; }
function pay ( uint index , uint256 _amount , address _from , bytes oracleData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent ) ; addInterest ( index ) ; uint256 toPay = min ( getPendingAmount ( index ) , _amount ) ; PartialPayment ( index , msg . sender , _from , toPay ) ; loan . paid = safeAdd ( loan . paid , toPay ) ; if ( getRawPendingAmount ( index ) == 0 ) { TotalPayment ( index ) ; loan . status = Status . paid ; lendersBalance [ loan . lender ] -= 1 ; activeLoans -= 1 ; Transfer ( loan . lender , 0x0 , index ) ; } uint256 transferValue = convertRate ( loan . oracle , loan . currency , oracleData , toPay ) ; require ( transferValue > 0 || toPay < _amount ) ; lockTokens ( rcn , transferValue ) ; require ( rcn . transferFrom ( msg . sender , this , transferValue ) ) ; loan . lenderBalance = safeAdd ( transferValue , loan . lenderBalance ) ; return true ; }
function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) throw ; } return super . approve ( _spender , _amount ) ; }
function _adjustBalanceCheckpoints ( address _investor ) internal { TokenLib . adjustCheckpoints ( checkpointBalances [ _investor ] , balanceOf ( _investor ) , currentCheckpointId ) ; }
function checkMonthlyLimit ( ) external constant returns ( uint256 remaining ) { return monthlyLimit [ msg . sender ] ; }
function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = WHITELIST ; return allPermissions ; }
function checkPermission ( address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { if ( modules [ PERMISSIONMANAGER_KEY ] . length == 0 ) { return false ; } for ( uint8 i = 0 ; i < modules [ PERMISSIONMANAGER_KEY ] . length ; i ++ ) { if ( IPermissionManager ( modules [ PERMISSIONMANAGER_KEY ] [ i ] . moduleAddress ) . checkPermission ( _delegate , _module , _perm ) ) { return true ; } } }
function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _tokenExists ( _tokenId ) ) ; require ( _approvedFor ( _to , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _owns ( msg . sender , _tokenId ) || ( msg . sender == playerTokenToApproved [ _tokenId ] ) || operators [ _from ] [ msg . sender ] ) ; _transfer ( _from , _to , _tokenId ) ; }
function ensureInAccountList ( address addr ) internal { require ( ! readOnly , "Read only mode engaged" ) ; bool found = false ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { if ( current == addr ) { found = true ; break ; } current = addressLinkedList [ current ] ; } if ( ! found ) { addToAccountList ( addr ) ; } }
function claimTokens ( address _token ) public onlyOwner { NEC token = NEC ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) ;
function getValueAt ( Checkpoint [ ] storage _checkpoints , uint256 _checkpointId , uint256 _currentValue ) public view returns ( uint256 ) { if ( _checkpointId == 0 ) { return 0 ; } if ( _checkpoints . length == 0 ) { return _currentValue ; } if ( _checkpoints [ 0 ] . checkpointId >= _checkpointId ) { return _checkpoints [ 0 ] . value ; } if ( _checkpoints [ _checkpoints . length - 1 ] . checkpointId < _checkpointId ) { return _currentValue ; } if ( _checkpoints [ _checkpoints . length - 1 ] . checkpointId == _checkpointId ) { return _checkpoints [ _checkpoints . length - 1 ] . value ; } uint256 min = 0 ; uint256 max = _checkpoints . length - 1 ; while ( max > min ) { uint256 mid = ( max + min ) / 2 ; if ( _checkpoints [ mid ] . checkpointId == _checkpointId ) { max = mid ; break ; } if ( _checkpoints [ mid ] . checkpointId < _checkpointId ) { min = mid + 1 ; } else { max = mid ; } } return _checkpoints [ max ] . value ; }
function setPreDGZtoDgzRate ( uint rate ) public onlyOwner { preDGZtoDGZExchangeRate = rate ; tokensAvailableForSale = totalTokensAvailableForSale - preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 - privateSalesTokensSold ; }
function withdraw ( uint256 _gameID ) external isHuman ( ) isActivated ( _gameID ) isEnded ( _gameID ) { require ( now < game_ [ _gameID ] . withdrawDeadline , "withdraw deadline already passed" ) ; require ( gameStatus_ [ _gameID ] . fundCleared == false , "fund already cleared" ) ; uint256 _pID = BMBook . pIDxAddr_ ( msg . sender ) ; require ( _pID != 0 , "player has not played this game" ) ; require ( players_ [ _pID ] [ _gameID ] . withdrawn == false , "player already cashed out" ) ; players_ [ _pID ] [ _gameID ] . withdrawn = true ; if ( game_ [ _gameID ] . canceled ) { uint256 _totalInvestment = players_ [ _pID ] [ _gameID ] . eth . mul ( 95 ) / 100 ; if ( _totalInvestment > 0 ) { BMBook . getPlayerAddr ( _pID ) . transfer ( _totalInvestment ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalInvestment . add ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; } emit BMEvents . onWithdraw ( _gameID , _pID , msg . sender , BMBook . getPlayerName ( _pID ) , _totalInvestment , now ) ; } else { uint256 _totalWinnings = getPlayerInstWinning ( _gameID , _pID , game_ [ _gameID ] . winnerTeam ) . add ( getPlayerPotWinning ( _gameID , _pID , game_ [ _gameID ] . winnerTeam ) ) ; if ( _totalWinnings > 0 ) { BMBook . getPlayerAddr ( _pID ) . transfer ( _totalWinnings ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalWinnings . add ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; } emit BMEvents . onWithdraw ( _gameID , _pID , msg . sender , BMBook . getPlayerName ( _pID ) , _totalWinnings , now ) ; } }
function updateFromRegistry ( ) external ;
function getPoll ( bytes32 _hash ) external constant returns ( bool , string , uint8 , uint256 , uint256 , bool , uint256 , uint256 , uint256 ) { Poll poll = polls [ _hash ] ; return ( poll . exists , poll . title , poll . percentage , poll . hashRate , totalHashRate , poll . approved , poll . approvalBlock , poll . approvalHashRate , poll . approvalTotalHashRate ) ; }
function tokenBurner ( uint256 _amount ) public onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( totalSupply . sub ( _amount ) >= 0 ) ; require ( balances [ msg . sender ] >= _amount ) ; require ( balances [ msg . sender ] . sub ( _amount ) >= 0 ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; Transfer ( msg . sender , 0 , _amount ) ; return true ; }
function contribute ( address _miner ) internal notBeforeGenesis nonZeroValued notPaused returns ( bool ) { uint256 block = currentBlock ( ) ; uint256 halving = currentHalving ( ) ; uint256 hashRate = HASH_RATE_MULTIPLIER . mul ( msg . value ) ; Miner miner = miners [ _miner ] ; if ( halving != 0 && halving < maxHalvings ) { uint256 I ; uint256 n = 0 ; for ( I = halving - 1 ; I > 0 ; I -- ) { if ( ! halvingsHashRate [ I ] . carried ) { n = n . add ( 1 ) ; } else { break ; } } for ( I = halving - n ; I < halving ; I ++ ) { if ( ! halvingsHashRate [ I ] . carried ) { halvingsHashRate [ I ] . carried = true ; halvingsHashRate [ I ] . rate = halvingsHashRate [ I ] . rate . add ( halvingsHashRate [ I - 1 ] . rate ) ; } } } if ( halving < maxHalvings ) { halvingsHashRate [ halving ] . rate = halvingsHashRate [ halving ] . rate . add ( hashRate ) ; } if ( miner . block == 0 ) { miner . block = block ; } miner . hashRate [ halving ] . rate = miner . hashRate [ halving ] . rate . add ( hashRate ) ; miner . totalHashRate = miner . totalHashRate . add ( hashRate ) ; totalHashRate = totalHashRate . add ( hashRate ) ; if ( ! bthFoundationWallet . send ( msg . value ) ) { throw ; } LogContribution ( _miner , msg . value , hashRate , block , halving ) ; return true ; }
function emergencySplitToggle ( ) isAdmin external { splitInService = ! splitInService ; }
function checkRelease ( ERC20 token ) public { uint _unRelease = 0 ; for ( uint i = 0 ; i < _amount . length ; i ++ ) { _unRelease = _unRelease . add ( _amount [ i ] ) ; } if ( _unRelease == 0 && block . timestamp >= _unlocktime ) { token . transfer ( owner , token . balanceOf ( this ) ) ; } }
function setMigrationAgent ( address _agent ) external isUpgrading onlyOwner { require ( _agent != 0x00 ) ; agent = MigrationAgent ( _agent ) ; if ( ! agent . isMigrationAgent ( ) ) { revert ( ) ; } if ( agent . originalSupply ( ) != supply ) { revert ( ) ; } }
function ( ) external payable { require ( msg . sender == address ( saleAuction ) || msg . sender == address ( siringAuction ) || msg . sender == ceoAddress ) ; }
function changeController ( address _newController ) public auth { require ( _newController != 0x0 ) ; pls . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
function ( ) public payable { distribute ( ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( crowdsaleSuccessful ) ; require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; uint256 allowed = allowance [ _from ] [ msg . sender ] ; require ( _value <= allowed || _from == msg . sender ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; balanceOf [ _from ] = balanceOf [ _from ] . sub ( _value ) ; if ( allowed != MAX_UINT256 && _from != msg . sender ) { allowance [ _from ] [ msg . sender ] = allowed . sub ( _value ) ; } Transfer ( _from , _to , _value ) ; success = true ; }
function addProductEndorsement ( string _mappingID , uint _operationIndex , int _productIndex , bool positive , string title , string description ) external returns ( bool success ) { require ( _productIndex > 0 ) ; productOperationEndorsements [ keccak256 ( _mappingID , _operationIndex , _productIndex ) ] . push ( Endorsement ( positive , title , description , msg . sender ) ) ; return true ; }
function collateralisationRatio ( address issuer ) public view returns ( uint ) { uint totalOwnedSynthetix = collateral ( issuer ) ; if ( totalOwnedSynthetix == 0 ) return 0 ; uint debtBalance = debtBalanceOf ( issuer , "SNX" ) ; return debtBalance . divideDecimalRound ( totalOwnedSynthetix ) ; }
function batchTransfer ( address [ ] _tos , uint256 [ ] _values ) public returns ( bool success ) { require ( _tos . length == _values . length ) ; uint256 numTransfers = _tos . length ; uint256 senderBalance = erc20Store . balances ( msg . sender ) ; for ( uint256 i = 0 ; i < numTransfers ; i ++ ) { address to = _tos [ i ] ; require ( to != address ( 0 ) ) ; uint256 v = _values [ i ] ; require ( senderBalance >= v ) ; if ( msg . sender != to ) { senderBalance -= v ; erc20Store . addBalance ( to , v ) ; } erc20Proxy . emitTransfer ( msg . sender , to , v ) ; } erc20Store . setBalance ( msg . sender , senderBalance ) ; return true ; }
function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) private whenNotPaused { address senderImplementation = interfaceAddr ( _from , "ERC777TokensSender" ) ; if ( senderImplementation != 0 ) { ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } }
function sellMaximumPossibleAmountOfTokens ( ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( this . balance > sellPrice ) ; if ( tokenBalanceOf [ msg . sender ] * sellPrice <= this . balance ) { sell ( tokenBalanceOf [ msg . sender ] ) ; } else { sell ( this . balance / sellPrice ) ; } }
function claim ( address engine , uint256 loanId , bytes ) external returns ( bool ) { uint256 mortgageId = loanToLiability [ engine ] [ loanId ] ; Mortgage storage mortgage = mortgages [ mortgageId ] ; require ( mortgage . status == Status . Ongoing , "Mortgage not ongoing" ) ; require ( mortgage . loanId == loanId , "Mortgage don't match loan id" ) ; if ( mortgage . engine . getStatus ( loanId ) == Engine . Status . paid || mortgage . engine . getStatus ( loanId ) == Engine . Status . destroyed ) { require ( _isAuthorized ( msg . sender , mortgageId ) , "Sender not authorized" ) ; mortgage . status = Status . Paid ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit PaidMortgage ( msg . sender , mortgageId ) ; } else if ( isDefaulted ( mortgage . engine , loanId ) ) { require ( msg . sender == mortgage . engine . ownerOf ( loanId ) , "Sender not lender" ) ; mortgage . status = Status . Defaulted ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit DefaultedMortgage ( mortgageId ) ; } else { revert ( "Mortgage not defaulted/paid" ) ; } _destroy ( mortgageId ) ; delete mortgageByLandId [ mortgage . landId ] ; return true ; }
function deedName ( uint256 _deedId ) external pure returns ( string _deedName ) ;
function blockTime ( ) constant returns ( uint32 ) { return uint32 ( block . timestamp ) ; }
function getBalance ( bytes32 _requestId ) public view returns ( int256 ) { int256 balance = requests [ _requestId ] . payee . balance ; for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { balance = balance . add ( subPayees [ _requestId ] [ i ] . balance ) ; } return balance ; }
function paymentMixed ( uint256 _regularTokenAmount , uint256 _rewardTokenAmount , uint256 _rewardPercentageIndex ) public { paymentRewardTokens ( _rewardTokenAmount ) ; paymentRegularTokens ( _regularTokenAmount , _rewardPercentageIndex ) ; }
function freezeAccount ( address _target , bool _freeze ) public onlyOwner returns ( bool ) { _frozenAccount [ _target ] = _freeze ; AccountFrozen ( _target , _freeze ) ; return true ; }
function bulkTransfer ( address [ ] _destinations , uint256 [ ] _amounts ) public onlyAdmin returns ( bool ) { require ( _destinations . length == _amounts . length , "Invalid operation." ) ; uint256 requiredBalance = sumOf ( _amounts ) ; require ( balances [ msg . sender ] >= requiredBalance , "You don't have sufficient funds to transfer amount that large." ) ; for ( uint256 i = 0 ; i < _destinations . length ; i ++ ) { transfer ( _destinations [ i ] , _amounts [ i ] ) ; } emit BulkTransferPerformed ( _destinations , _amounts ) ; return true ; }
function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) { return _contributorTokens ; }
function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes _data ) public returns ( bytes4 ) ;
function STARTMETADOLLAR ( ) { sellPrice = 900000000000000 ; mtdAmount = 1000000000000000000 ; ethAmount = 1000000000000000 ; mtdPreAmount = 1 ; ethPreAmount = 1 ; preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = mtdAmount * ethAmount ; preICOprice = mtdPreAmount * ethPreAmount ; ICOprice = mtdAmount * ethAmount ; sellPrice = 0 ; updatePrices ( ) ; }
function incremental ( uint256 totalEuroUlps , uint256 euroUlps ) public pure returns ( uint256 neumarkUlps ) { require ( totalEuroUlps + euroUlps >= totalEuroUlps ) ; uint256 from = cumulative ( totalEuroUlps ) ; uint256 to = cumulative ( totalEuroUlps + euroUlps ) ; assert ( to >= from ) ; return to - from ; }
function setDirectPaymentThreshold ( uint256 threshold ) external onlyCFO { directPaymentThreshold = threshold ; }
function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < ownerToRareArray [ _owner ] . length ) ; if ( _owner != address ( 0 ) ) { uint256 tokenId = ownerToRareArray [ _owner ] [ _index ] ; return tokenId ; } }
function withdrawHavvens ( uint quantity ) external onlyOwner onlyDuringSetup { havven . transfer ( havven , quantity ) ; }
function getItem ( uint256 _tokenId ) public view returns ( string itemName , uint256 sellingPrice , address owner , bytes32 itemMessage , address creator ) { Item storage item = items [ _tokenId ] ; itemName = item . name ; itemMessage = item . message ; sellingPrice = itemIndexToPrice [ _tokenId ] ; owner = itemIndexToOwner [ _tokenId ] ; creator = item . creatoraddress ; }
function delegateVote ( address _to ) public { require ( ! gaveVote ( msg . sender ) ) ; require ( ! isDelegate [ msg . sender ] ) ; require ( isDelegate [ _to ] ) ; require ( myDelegate [ msg . sender ] == address ( 0 ) ) ; myDelegate [ msg . sender ] = _to ; myVotes [ _to ] . push ( msg . sender ) ; }
function approve ( address _spender , uint256 _amount ) returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] > 0 ) ; allowance [ msg . sender ] [ _spender ] = _amount ; Approve ( msg . sender , _spender , _amount ) ; return true ; }
function transferFrom ( address from , address to , uint value ) public returns ( bool ) ;
function depositERC20 ( address _user , address _token , uint256 _amount ) external onlyCoordinator onlyActiveState { require ( _amount > 0 , 'Invalid value' ) ; balances [ _user ] [ _token ] = balances [ _user ] [ _token ] . add ( _amount ) ; require ( ERC20 ( _token ) . transferFrom ( _user , address ( this ) , _amount ) , "transferFrom failed." ) ; emit BalanceIncrease ( _user , _token , _amount , ReasonDeposit ) ; }
function price ( ) public constant returns ( uint ) { if ( stage == Stages . AuctionEnded || stage == Stages . AuctionCanceled || stage == Stages . TokensDistributed ) { return 0 ; } return calcTokenPrice ( ) ; }
function burnFrom ( address _from , uint256 _value ) public returns ( bool success ) { require ( balances [ _from ] >= _value ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( _from , _value ) ; return true ; }
function changeEscapeCaller ( address _newEscapeCaller ) onlyEscapeCallerOrOwner { escapeCaller = _newEscapeCaller ; }
function tokenFallback ( address _sender_address , uint256 _deposit , bytes _data ) external { require ( msg . sender == address ( token ) ) ; uint192 deposit = uint192 ( _deposit ) ; require ( deposit == _deposit ) ; uint length = _data . length ; require ( length == 40 || length == 44 ) ; address channel_sender_address = address ( addressFromBytes ( _data , 0x20 ) ) ; require ( _sender_address == channel_sender_address || trusted_contracts [ _sender_address ] ) ; address channel_receiver_address = address ( addressFromBytes ( _data , 0x34 ) ) ; if ( length == 40 ) { createChannelPrivate ( channel_sender_address , channel_receiver_address , deposit ) ; } else { uint32 open_block_number = uint32 ( blockNumberFromBytes ( _data , 0x48 ) ) ; updateInternalBalanceStructs ( channel_sender_address , channel_receiver_address , open_block_number , deposit ) ; } }
function canClaim ( bytes32 channelId , uint256 payment , address origin , bytes signature ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isReceiver = origin == channel . receiver ; bytes32 hash = recoveryPaymentDigest ( channelId , payment ) ; bool isSigned = channel . sender == ECRecovery . recover ( hash , signature ) ; return isReceiver && isSigned ; }
function transferFromPreSigned ( bytes _signature , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; bytes32 hashedTx = transferFromPreSignedHashing ( address ( this ) , _from , _to , _value , _fee , _nonce ) ; address spender = recover ( hashedTx , _signature ) ; require ( spender != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ spender ] = allowed [ _from ] [ spender ] . sub ( _value ) ; balances [ spender ] = balances [ spender ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Transfer ( _from , _to , _value ) ; emit Transfer ( spender , msg . sender , _fee ) ; return true ; }
function transferFrom ( address from , address to , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ from ] == 0 || value <= transferableHavvens ( from ) , "Value to transfer exceeds available havvens" ) ; _transferFrom_byProxy ( sender , from , to , value ) ; return true ; }
function setRoundRate ( uint32 roundNum , uint256 rate ) public onlyOwner { require ( roundNum < rounds . length ) ; rounds [ roundNum ] . rate = rate ; }
function finalize ( ) external isNotFinalized onlyOwner { finalized = true ; Finalize ( msg . sender , totalSupply ) ; }
function removeAssetPartOwner ( bytes32 _symbol , address _partowner ) external onlyOneOfOwners ( _symbol ) returns ( uint ) { uint holderId = getHolderId ( _partowner ) ; delete assets [ _symbol ] . partowners [ holderId ] ; Emitter ( eventsHistory ) . emitOwnershipChange ( _partowner , 0x0 , _symbol ) ; return OK ; }
function payOut ( ) public { require ( msg . sender == creator ) ; require ( creator . send ( this . balance ) ) ; LogBeneficiaryPaid ( creator ) ; }
function withdraw ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . verifyAccount ( account ) , "Error: Account is not verified!" ) ; require ( lib . withdraw ( currency , account , amount , issuerFirm ) , "Error: Unable to withdraw funds. Please check issuerFirm and firm authority are registered and have issued funds that can be withdrawn" ) ; return true ; }
function transferFrom ( address from , address to , uint256 tokenAmount ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokenAmount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( from , to , tokenAmount ) ; return true ; }
function startBuyback ( uint256 _roundStartTime , uint256 _rate ) onlyOwner external payable { require ( _roundStartTime > now ) ; roundStartTime = _roundStartTime ; rate = _rate ; }
function claimTokensByUser ( ) public { require ( KYCValid [ msg . sender ] == true ) ; uint256 tokens = balance [ msg . sender ] ; balance [ msg . sender ] = 0 ; require ( tokenReward . transfer ( msg . sender , tokens ) ) ; tokensSent [ msg . sender ] = tokensSent [ msg . sender ] . add ( tokens ) ; emit LogContributorsPayout ( msg . sender , tokens ) ; }
function getAssetPackData ( uint _assetPackId ) public view returns ( bytes32 , address , uint , uint [ ] , uint [ ] , bytes32 [ ] , string , string , bytes32 ) { require ( _assetPackId < numberOfAssetPacks ) ; AssetPack memory assetPack = assetPacks [ _assetPackId ] ; bytes32 [ ] memory hashes = new bytes32 [ ] ( assetPack . assetIds . length ) ; for ( uint i = 0 ; i < assetPack . assetIds . length ; i ++ ) { hashes [ i ] = getAssetIpfs ( assetPack . assetIds [ i ] ) ; } uint [ ] memory attributes = getAttributesForAssets ( assetPack . assetIds ) ; return ( assetPack . packCover , assetPack . creator , assetPack . price , assetPack . assetIds , attributes , hashes , assetPack . ipfsHash , userManager . getUsername ( assetPack . creator ) , userManager . getProfilePicture ( assetPack . creator ) ) ; }
function createNewTask ( uint uuid , uint amount ) public onlyCurator sufficientDevFundBalance ( amount ) { communityAccount . setEscrowedTaskBalances ( uuid , amount ) ; communityAccount . setTotalTaskEscrow ( SafeMath . add ( communityAccount . totalTaskEscrow ( ) , amount ) ) ; logger . emitTaskCreated ( uuid , amount ) ; logger . emitGenericLog ( "createNewTask" , "" ) ; }
function addInvestorBonusInPercent ( address _to , uint8 p ) public onlyOwner { require ( p > 0 && p <= 5 ) ; uint bonus = balances [ _to ] . mul ( p ) . div ( 100 ) ; investorGiven = investorGiven . add ( bonus ) ; require ( investorGiven <= investorSupply ) ; _freezeTransfer ( _to , bonus ) ; }
function withdraw ( uint256 amount ) public { require ( _balances [ msg . sender ] >= amount ) ; _balances [ msg . sender ] = sub ( _balances [ msg . sender ] , amount ) ; _totalSupply = sub ( _totalSupply , amount ) ; LogWithdrawal ( msg . sender , amount ) ; Transfer ( msg . sender , address ( 0 ) , amount ) ; }
function ( ) payable { if ( controller == 0 ) throw ; if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) throw ; } else { if ( ! controller . send ( msg . value ) ) throw ; } }
function getCEOHashing ( address _newCEO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x486A0F3E ) , _newCEO , _nonce ) ; }
function maxCommitTime ( Pledge p ) internal returns ( uint commitTime ) { PledgeAdmin storage m = findAdmin ( p . owner ) ; commitTime = m . commitTime ; for ( uint i = 0 ; i < p . delegationChain . length ; i ++ ) { m = findAdmin ( p . delegationChain [ i ] ) ; if ( m . commitTime > commitTime ) commitTime = m . commitTime ; } }
function enableTransfers ( bool _transfersEnabled ) onlyController public { transfersEnabled = _transfersEnabled ; }
function seal ( ) onlyController returns ( bool success ) { tokenController = 0 ; return true ; }
function setNextGameSettings ( uint256 rows , uint256 cols , uint256 activityTimer , uint256 unclaimedTilePrice , uint256 buyoutReferralBonusPercentage , uint256 buyoutPrizePoolPercentage , uint256 buyoutDividendPercentage , uint256 buyoutFeePercentage ) public onlyCFO { require ( 2000 <= buyoutDividendPercentage && buyoutDividendPercentage <= 12500 ) ; require ( buyoutFeePercentage <= 5000 ) ; nextGameSettings = GameSettings ( { rows : rows , cols : cols , activityTimer : activityTimer , unclaimedTilePrice : unclaimedTilePrice , buyoutReferralBonusPercentage : buyoutReferralBonusPercentage , buyoutPrizePoolPercentage : buyoutPrizePoolPercentage , buyoutDividendPercentage : buyoutDividendPercentage , buyoutFeePercentage : buyoutFeePercentage } ) ; NextGame ( rows , cols , activityTimer , unclaimedTilePrice , buyoutReferralBonusPercentage , buyoutPrizePoolPercentage , buyoutDividendPercentage , buyoutFeePercentage ) ; }
function canMateWith ( uint256 _matronId , uint256 _sireId ) external view returns ( bool ) { require ( _matronId > 0 ) ; require ( _sireId > 0 ) ; Pony storage matron = ponies [ _matronId ] ; Pony storage sire = ponies [ _sireId ] ; return _isValidMatingPair ( matron , _matronId , sire , _sireId ) && _isMatingPermitted ( _sireId , _matronId ) ; }
function changeDonor ( address _newDonor ) onlyDonor { donor = _newDonor ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) public validAddress ( _from ) validAddress ( _to ) validId ( _tokenId ) { require ( isApprovedOrOwner ( msg . sender , _tokenId ) , "Sender does not have permission to transfer PixelCon" ) ; clearApproval ( _from , _tokenId ) ; removeTokenFrom ( _from , _tokenId ) ; addTokenTo ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }
function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; require ( creator . send ( this . balance ) ) ; tokenReward . transfer ( creator , remanent ) ; LogBeneficiaryPaid ( creator ) ; LogContributorsPayout ( creator , remanent ) ; }
function replaySweep ( address [ ] _froms , address _to ) public onlySweeper { require ( _to != address ( 0 ) ) ; uint256 lenFroms = _froms . length ; uint256 sweptBalance = 0 ; for ( uint256 i = 0 ; i < lenFroms ; ++ i ) { address from = _froms [ i ] ; if ( sweptSet [ from ] ) { uint256 fromBalance = erc20Store . balances ( from ) ; if ( fromBalance > 0 ) { sweptBalance += fromBalance ; erc20Store . setBalance ( from , 0 ) ; erc20Proxy . emitTransfer ( from , _to , fromBalance ) ; } } } if ( sweptBalance > 0 ) { erc20Store . addBalance ( _to , sweptBalance ) ; } }
function calculateSeed ( uint [ ] _randomHashIds , uint _timestamp ) public view returns ( uint ) { require ( _timestamp != 0 ) ; require ( _randomHashIds . length == 10 ) ; bytes32 randomSeed = keccak256 ( abi . encodePacked ( randomHashes [ _randomHashIds [ 0 ] ] , randomHashes [ _randomHashIds [ 1 ] ] , randomHashes [ _randomHashIds [ 2 ] ] , randomHashes [ _randomHashIds [ 3 ] ] , randomHashes [ _randomHashIds [ 4 ] ] , randomHashes [ _randomHashIds [ 5 ] ] , randomHashes [ _randomHashIds [ 6 ] ] , randomHashes [ _randomHashIds [ 7 ] ] , randomHashes [ _randomHashIds [ 8 ] ] , randomHashes [ _randomHashIds [ 9 ] ] , _timestamp ) ) ; return uint ( randomSeed ) ; }
function isRegisteredInEpoch ( address _darknodeID , Epoch _epoch ) private view returns ( bool ) { uint256 registeredAt = store . darknodeRegisteredAt ( _darknodeID ) ; uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; bool registered = registeredAt != 0 && registeredAt <= _epoch . blocknumber ; bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch . blocknumber ; return registered && notDeregistered ; }
function transferToSelf ( uint256 _value ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ selfAddress ] = balances [ selfAddress ] + _value ; Transfer ( msg . sender , selfAddress , _value ) ; allowed [ selfAddress ] [ msg . sender ] = _value + allowed [ selfAddress ] [ msg . sender ] ; IOUSupply += _value ; Approval ( selfAddress , msg . sender , allowed [ selfAddress ] [ msg . sender ] ) ; return true ; }
function claimPlotMultiple ( uint256 [ ] _deedIds , uint256 _buyoutPrice ) external payable whenNotPaused { claimPlotMultipleWithData ( _deedIds , _buyoutPrice , "" , "" , "" , "" ) ; }
function getAssetInfo ( uint id ) public view returns ( uint , uint , uint , bytes32 ) { require ( id >= 0 ) ; require ( id < numberOfAssets ) ; Asset memory asset = assets [ id ] ; return ( asset . id , asset . packId , asset . attributes , asset . ipfsHash ) ; }
function isInitialized ( ) public view returns ( bool ) { return _isInitialized ; }
function finalizeSale ( ) onlyController { require ( now > endFundingTime || totalCollected >= maximumFunding ) ; require ( ! finalized ) ; uint256 reservedTokens = 225000000 * 0.35 * 10 ** 18 ; if ( ! tokenContract . generateTokens ( vaultAddress , reservedTokens ) ) { revert ( ) ; } finalized = true ; }
function isOpen ( bytes32 channelId ) public view returns ( bool ) { return isPresent ( channelId ) && ! isSettling ( channelId ) ; }
function getAttributeTypeDescription ( uint256 attributeTypeID ) external view returns ( string description ) { return _attributeTypes [ attributeTypeID ] . description ; }
function release ( address token ) public onlyOwner { uint256 unreleased = _releasableAmount ( token ) ; require ( unreleased > 0 ) ; _released [ token ] = _released [ token ] . add ( unreleased ) ; tokenReward . transfer ( _beneficiary , unreleased ) ; }
function participantWithdrawIfMinimumFundingNotReached ( uint256 value ) external { if ( now <= PRESALE_END_DATE ) throw ; if ( totalFunding >= PRESALE_MINIMUM_FUNDING ) throw ; if ( balanceOf [ msg . sender ] < value ) throw ; balanceOf [ msg . sender ] = safeDecrement ( balanceOf [ msg . sender ] , value ) ; if ( ! msg . sender . send ( value ) ) throw ; }
function getSecurityTokenData ( address _securityToken ) public view returns ( string , address , string ) { return ( securityTokens [ _securityToken ] . symbol , ISecurityToken ( _securityToken ) . owner ( ) , securityTokens [ _securityToken ] . tokenDetails ) ; }
function blockNumber ( bytes32 _symbol ) public view returns ( uint ) { return get ( store , assetBlockNumber , _symbol ) ; }
function approve ( address _spender , uint256 _value ) public onlyIfLockTimePassed returns ( bool ) { require ( _spender != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _spender ] == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
function procNormalSales ( ) payable public returns ( uint256 ) { uint256 amount = msg . value / buyPrice ; amount = amount * 10 ** uint256 ( decimals ) ; _transfer ( owner , msg . sender , amount ) ; owner . transfer ( msg . value ) ; return amount ; }
function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; tradeActive = true ; }
function extract ( address _to ) onlyController { require ( _to != 0x0 ) ; uint256 available = availableNow ( ) ; require ( available > 0 ) ; extracted = extracted . add ( available ) ; assert ( token . transfer ( _to , available ) ) ; Extract ( _to , available ) ; }
function addValidatorApproval ( address validator , uint256 attributeTypeID ) external onlyOwner whenNotPaused { require ( isValidator ( validator ) && isAttributeType ( attributeTypeID ) , "must specify both a valid attribute and an available validator" ) ; require ( _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] == false , "validator is already approved on the provided attribute" ) ; _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] = true ; uint256 index = _validatorApprovals [ validator ] . length ; _validatorApprovalsIndex [ validator ] [ attributeTypeID ] = index ; _validatorApprovals [ validator ] . push ( attributeTypeID ) ; emit ValidatorApprovalAdded ( validator , attributeTypeID ) ; }
function lockedBbkOf ( address _address ) external view returns ( uint256 ) { return lockedBbkPerUser [ _address ] ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address _owner ) { _owner = tokenIdToOwner [ _tokenId ] ; require ( _owner != address ( 0 ) ) ; }
function unfreezeAdministrationContract ( ) public onlyAdmin isFrozen returns ( bool unfrozen ) { administrationContractFrozen = false ; return true ; }
function transferFrom ( address _from , address _to , uint256 _amount ) public erc20 returns ( bool success ) { require ( _amount <= mAllowed [ _from ] [ msg . sender ] , "Not enough funds allowed" ) ; mAllowed [ _from ] [ msg . sender ] = mAllowed [ _from ] [ msg . sender ] . sub ( _amount ) ; doSend ( msg . sender , _from , _to , _amount , "" , "" , false ) ; return true ; }
function setTokenConverter ( TokenConverter _tokenConverter ) external onlyOwner returns ( bool ) { emit SetTokenConverter ( tokenConverter , _tokenConverter ) ; tokenConverter = _tokenConverter ; return true ; }
function setMigrationAgent ( address _agent ) external onlyOwner { require ( migrationAgent == 0x0 && totalMigrated == 0 ) ; migrationAgent = _agent ; }
function vote ( uint _proposalId , bool _yes ) public { require ( _proposalId < proposals . length ) ; require ( checkIfCurrentlyActive ( _proposalId ) ) ; Proposal memory p = proposals [ _proposalId ] ; uint amount = MiniMeToken ( p . token ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; require ( MiniMeToken ( p . token ) . transferFrom ( msg . sender , address ( this ) , amount ) ) ; if ( _yes ) { proposals [ _proposalId ] . yesVotes += amount ; } else { proposals [ _proposalId ] . noVotes += amount ; } emit Vote ( _proposalId , msg . sender , _yes , amount ) ; }
function recoverUnawardedMILs ( ) public { uint256 MILs = militaryToken . balanceOf ( address ( this ) ) ; if ( totalAwards < MILs ) { militaryToken . transfer ( owner , MILs - totalAwards ) ; } }
function setApprove ( address _sender , address _spender , uint256 _value ) external onlyModule returns ( bool ) { allowed [ _sender ] [ _spender ] = _value ; return true ; }
function transfer ( address to , uint256 tokens ) public returns ( bool success ) { requireTrade ( msg . sender ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; ensureInAccountList ( to ) ; return true ; }
function unvote ( uint _idPoll ) public { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll storage p = _polls [ _idPoll ] ; require ( block . number >= p . startBlock && block . number < p . endBlock && ! p . canceled , "Poll is inactive" ) ; if ( p . voters == 0 ) return ; p . voters -- ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { uint ballotAmount = p . ballots [ i ] [ msg . sender ] ; p . ballots [ i ] [ msg . sender ] = 0 ; if ( ballotAmount != 0 ) { p . qvResults [ i ] -= sqrt ( ballotAmount / 1 ether ) ; p . results [ i ] -= ballotAmount ; } } emit Unvote ( _idPoll , msg . sender ) ; }
function setSlippage ( uint slip ) public auth { require ( slip < WAD ) ; slippage = slip ; }
function proxy_contribution ( address _toAddr ) public payable { require ( _toAddr != 0x0 ) ; process_contribution ( _toAddr ) ; }
function createERC20TokenNetwork ( address _token_address ) canCreateTokenNetwork external returns ( address token_network_address ) { require ( token_to_token_networks [ _token_address ] == address ( 0x0 ) ) ; token_network_created = true ; TokenNetwork token_network ; token_network = new TokenNetwork ( _token_address , secret_registry_address , chain_id , settlement_timeout_min , settlement_timeout_max , deprecation_executor ) ; token_network_address = address ( token_network ) ; token_to_token_networks [ _token_address ] = token_network_address ; emit TokenNetworkCreated ( _token_address , token_network_address ) ; return token_network_address ; }
function setWallet ( address _wallet ) external validAddress ( _wallet ) onlyOwner { wallet = _wallet ; }
function _burn ( address _owner , uint256 _tokenId ) internal { super . _burn ( _owner , _tokenId ) ; assert ( tokens . length > 0 ) ; uint256 tokenIndex = idToIndex [ _tokenId ] ; assert ( tokens [ tokenIndex ] == _tokenId ) ; uint256 lastTokenIndex = tokens . length . sub ( 1 ) ; uint256 lastToken = tokens [ lastTokenIndex ] ; tokens [ tokenIndex ] = lastToken ; tokens . length -- ; idToIndex [ lastToken ] = tokenIndex ; idToIndex [ _tokenId ] = 0 ; }
function getAllModulesAndPermsFromTypes ( address _delegate , uint8 [ ] _types ) external view returns ( address [ ] , bytes32 [ ] ) ;
function payToEvaluator ( uint _JobID , uint _payment ) public { require ( _JobID >= 0 ) ; require ( _payment > 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender == job . manager ) ; address evaluator = job . evaluator ; require ( DAI . allowance ( job . manager , address ( this ) ) >= _payment ) ; emit EvaluatorPaid ( msg . sender , evaluator , _JobID , _payment ) ; DAI . transferFrom ( job . manager , evaluator , _payment ) ; }
function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 2 ) ; allPermissions [ 0 ] = WHITELIST ; allPermissions [ 1 ] = ADMIN ; return allPermissions ; }
function removeModule ( address _moduleFactory ) external whenNotPausedOrOwner { uint256 moduleType = getUint ( Encoder . getKey ( "registry" , _moduleFactory ) ) ; require ( moduleType != 0 , "Module factory should be registered" ) ; require ( msg . sender == IOwnable ( _moduleFactory ) . owner ( ) || msg . sender == owner ( ) , "msg.sender must be the Module Factory owner or registry curator" ) ; uint256 index = getUint ( Encoder . getKey ( "moduleListIndex" , _moduleFactory ) ) ; uint256 last = getArrayAddress ( Encoder . getKey ( "moduleList" , moduleType ) ) . length - 1 ; address temp = getArrayAddress ( Encoder . getKey ( "moduleList" , moduleType ) ) [ last ] ; if ( index != last ) { setArrayIndexValue ( Encoder . getKey ( "moduleList" , moduleType ) , index , temp ) ; set ( Encoder . getKey ( "moduleListIndex" , temp ) , index ) ; } deleteArrayAddress ( Encoder . getKey ( "moduleList" , moduleType ) , last ) ; set ( Encoder . getKey ( "registry" , _moduleFactory ) , uint256 ( 0 ) ) ; setArray ( Encoder . getKey ( "reputation" , _moduleFactory ) , new address [ ] ( 0 ) ) ; set ( Encoder . getKey ( "verified" , _moduleFactory ) , false ) ; set ( Encoder . getKey ( "moduleListIndex" , _moduleFactory ) , uint256 ( 0 ) ) ; emit ModuleRemoved ( _moduleFactory , msg . sender ) ; }
function addPlotAndData ( uint24 [ ] purchase , string ipfsHash , string url , uint256 initialBuyoutPriceInWeiPerPixel ) private returns ( uint256 ) { uint256 newPlotIndex = ownership . length ; ownership . push ( PlotOwnership ( purchase [ 0 ] , purchase [ 1 ] , purchase [ 2 ] , purchase [ 3 ] , msg . sender ) ) ; data [ newPlotIndex ] = PlotData ( ipfsHash , url ) ; if ( initialBuyoutPriceInWeiPerPixel > 0 ) { plotIdToPrice [ newPlotIndex ] = initialBuyoutPriceInWeiPerPixel ; } return newPlotIndex ; }
function addDistributionPeriod ( ) public onlyProfiterole returns ( uint ) { uint _periodsCount = periodsCount ; uint _nextPeriod = _periodsCount . add ( 1 ) ; periodDate2periodIdx [ now ] = _periodsCount ; Period storage _previousPeriod = periods [ _periodsCount ] ; uint _totalBmcDeposit = _getTotalBmcDaysAmount ( now , _periodsCount ) ; periods [ _nextPeriod ] . startDate = now ; periods [ _nextPeriod ] . bmcDaysPerDay = _previousPeriod . bmcDaysPerDay ; periods [ _nextPeriod ] . totalBmcDays = _totalBmcDeposit ; periodsCount = _nextPeriod ; return OK ; }
function stage ( ) public constant returns ( Stage ) { if ( finalized ) { return Stage . Finalized ; } if ( ! initialized ) { return Stage . Created ; } if ( block . timestamp < startTime ) { return Stage . Initialized ; } if ( uint256 ( soldOut . cornerstoneValue ) . add ( soldOut . vcValue ) >= publicSupply ) { return Stage . Closed ; } if ( block . timestamp < endTime ) { if ( block . timestamp < startTime . add ( earlyStageLasts ) ) { return Stage . Early ; } return Stage . Normal ; } return Stage . Closed ; }
function breedWith ( uint40 _momId , uint40 _dadId ) public whenNotPaused returns ( uint40 ) { require ( _isOwner ( msg . sender , _momId ) ) ; require ( _isBreedingPermitted ( _dadId , _momId ) ) ; Cutie storage mom = cuties [ _momId ] ; require ( _canBreed ( mom ) ) ; Cutie storage dad = cuties [ _dadId ] ; require ( _canBreed ( dad ) ) ; require ( _canPairMate ( mom , _momId , dad , _dadId ) ) ; return _breedWith ( _momId , _dadId ) ; }
function addNFToken ( address _to , uint256 _tokenId ) internal { super . addNFToken ( _to , _tokenId ) ; uint256 length = ownerToIds [ _to ] . push ( _tokenId ) ; idToOwnerIndex [ _tokenId ] = length - 1 ; }
function convert_valuation_to_art ( uint _valuation , uint _art_price ) view public returns ( uint amount ) { amount = ( ( _valuation . mul ( oracle_price_decimals_factor ) ) . div ( _art_price ) ) . mul ( decimal_precission_difference_factor ) ; }
function addHandlerToWhitelist ( address handler ) public onlyOwner handlerNotWhitelisted ( handler ) { handlerWhitelistMap [ handler ] = true ; handlerWhitelistArray . push ( handler ) ; emit GenericEvent ( 1 ) ; }
function clearApproval ( address _owner , uint256 _tokenId ) public { require ( msg . sender == _ownerOf ( _tokenId ) ) ; _clearApproval ( msg . sender , _tokenId ) ; }
function changeRegistrationStatus ( address target , bool isRegistered ) public onlyBy ( owner ) { registered [ target ] = isRegistered ; }
function withdrawFees ( address _to , uint256 _amount ) onlyOwner external { require ( _amount <= feesAvailableForWithdraw , "Amount is higher than amount available" ) ; feesAvailableForWithdraw -= _amount ; _to . transfer ( _amount ) ; }
function upgrade ( uint256 value ) external { if ( nextUpgradeAgent . owner ( ) == 0x0 ) revert ( ) ; if ( finalizedNextUpgrade ) revert ( ) ; if ( value == 0 ) revert ( ) ; if ( value > balances [ msg . sender ] ) revert ( ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; nextUpgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , nextUpgradeAgent , value ) ; }
function requestImplChange ( address _proposedImpl ) public returns ( bytes32 lockId ) { require ( _proposedImpl != address ( 0 ) ) ; lockId = generateLockId ( ) ; implChangeReqs [ lockId ] = ImplChangeRequest ( { proposedNew : _proposedImpl } ) ; emit ImplChangeRequested ( lockId , msg . sender , _proposedImpl ) ; }
function getFeeContract ( Data storage self , address contractAddress ) internal view returns ( address feeContract ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.account' , contractAddress ) ) ; address feeAccount = self . Storage . getAddress ( id ) ; if ( feeAccount == 0x0 ) { return getMasterFeeContract ( self ) ; } else { return feeAccount ; } }
function addNFToken ( address _to , uint256 _tokenId ) internal { super . addNFToken ( _to , _tokenId ) ; uint256 length = ownerToIds [ _to ] . length ; ownerToIds [ _to ] . push ( _tokenId ) ; idToOwnerIndex [ _tokenId ] = length ; }
function tokenURI ( uint256 _tokenId ) external view returns ( string ) { return appendUintToString ( hostname , _tokenId ) ; }
function undelegate ( uint64 idPledge , uint amount , uint q ) internal returns ( uint64 ) { Pledge storage p = findPledge ( idPledge ) ; uint64 [ ] memory newDelegationChain = new uint64 [ ] ( p . delegationChain . length - q ) ; for ( uint i = 0 ; i < p . delegationChain . length - q ; i ++ ) { newDelegationChain [ i ] = p . delegationChain [ i ] ; } uint64 toPledge = findOrCreatePledge ( p . owner , newDelegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; return toPledge ; }
function getTokenBalance ( string currency , address account ) public view returns ( uint balance ) { return lib . getTokenBalance ( currency , account ) ; }
function performSellOrder_ ( OrderData data ) public onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { uint256 amountToGiveForOrder = toUint ( msg . data , msg . data . length - 32 ) ; approveAddress ( ERC20_ASSET_PROXY , toAddress ( data . takerAssetData , 16 ) ) ; LibFillResults . FillResults memory results = exchange . fillOrder ( getZeroExOrder ( data ) , amountToGiveForOrder , data . signature ) ; weth . withdraw ( results . makerAssetFilledAmount ) ; totlePrimary . transfer ( results . makerAssetFilledAmount ) ; amountSpentOnOrder = results . takerAssetFilledAmount ; amountReceivedFromOrder = results . makerAssetFilledAmount ; }
function getTokenMinted ( ) public constant returns ( uint ) { return m_tokensMinted ; }
function submitTransactionWithVRS ( address destination , uint value , bytes data , bytes pass , bytes32 [ 3 ] signerParams ) public payable returns ( uint transactionId ) { transactionId = addTransaction ( destination , value , data ) ; bytes32 _message = getMessageForTransaction ( transactionId , pass ) ; address _owner = getSigner ( _message , uint8 ( signerParams [ 0 ] ) , signerParams [ 1 ] , signerParams [ 2 ] ) ; _assertMultisigInitiator ( _owner , BytesLib . getSig ( data ) ) ; confirmTransactionWithVRS ( transactionId , pass , uint8 ( signerParams [ 0 ] ) , signerParams [ 1 ] , signerParams [ 2 ] ) ; }
function setPartners ( bool _valid , uint _from , uint _to ) ;
function unlock ( ) external { if ( now < unlockedAt ) throw ; uint256 vested = allocations [ msg . sender ] * 10 ** decimals ; if ( vested < 0 ) throw ; allocations [ msg . sender ] = 0 ; reservedTokens = safeSub ( reservedTokens , vested ) ; balances [ msg . sender ] = safeAdd ( balances [ msg . sender ] , vested ) ; Vested ( msg . sender , vested ) ; }
function setBlacklistDestroyer ( address _who ) public onlyValidator { require ( isPermission ( DESTROY_BLACKLISTED_TOKENS_SIG ) , "Blacklist token destruction not supported by token" ) ; setUserPermission ( _who , DESTROY_BLACKLISTED_TOKENS_SIG ) ; emit LogSetBlacklistDestroyer ( _who ) ; }
function createETHCardCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } rewardsRedeemed ++ ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 2 , _nftData ) ; }
function forward ( bytes _evmScript ) public { require ( canForward ( msg . sender , _evmScript ) , ERROR_CAN_NOT_FORWARD ) ; _newVote ( _evmScript , "" , true , true ) ; }
function addUsersToGroup ( bytes32 _groupName , address [ ] _users ) external onlyContractOwner returns ( uint ) { require ( isGroupExists ( _groupName ) ) ; Group storage _group = groupName2group [ _groupName ] ; uint _groupMembersCount = _group . membersCount ; for ( uint _userIdx = 0 ; _userIdx < _users . length ; ++ _userIdx ) { address _user = _users [ _userIdx ] ; uint _memberIndex = memberAddress2index [ _user ] ; require ( _memberIndex != 0 ) ; if ( _group . memberAddress2index [ _user ] != 0 ) { continue ; } _groupMembersCount = _groupMembersCount . add ( 1 ) ; _group . memberAddress2index [ _user ] = _groupMembersCount ; _group . index2globalIndex [ _groupMembersCount ] = _memberIndex ; _addGroupToMember ( _user , _groupName ) ; UserToGroupAdded ( _user , _groupName ) ; } _group . membersCount = _groupMembersCount ; return OK ; }
function updateEndTime ( uint256 _endTime ) onlyOwner public returns ( bool ) { endTime = _endTime ; emit UpdateEndTime ( _endTime ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( approved [ _from ] [ msg . sender ] >= _value && balances [ _from ] >= _value && _value > 0 ) ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; approved [ _from ] [ msg . sender ] = safeSub ( approved [ _from ] [ msg . sender ] , _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
function createGame ( string _name , bytes32 [ ] _teamNames ) external isHuman ( ) isOwner ( ) returns ( uint256 ) { uint256 _gameID = gameIDIndex_ ; gameIDIndex_ ++ ; game_ [ _gameID ] . name = _name ; uint256 _nt = _teamNames . length ; require ( _nt > 0 , "number of teams must be larger than 0" ) ; game_ [ _gameID ] . numberOfTeams = _nt ; for ( uint256 i = 0 ; i < _nt ; i ++ ) { teams_ [ _gameID ] [ i ] = FSdatasets . Team ( _teamNames [ i ] , 0 , 0 , 0 , 0 ) ; } emit onGameCreated ( _gameID , now ) ; return _gameID ; }
function removeRecipient ( address old_addr ) onlyOwner external { uint256 idx = _firstRecipientIndex ( old_addr ) ; assert ( recipients [ idx ] == old_addr ) ; uint256 last_idx = recipients . length - 1 ; if ( idx != last_idx ) { recipients [ idx ] = recipients [ last_idx ] ; } recipients . length -- ; }
function createTemplateAndAskQuestion ( string content , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { }
function setRequiredMajority ( uint fraction ) external onlyOwner { require ( MIN_REQUIRED_MAJORITY <= fraction ) ; requiredMajority = fraction ; }
function removeUsers ( address [ ] _blacklist ) public onlyOracleOrOwner onlySale returns ( uint ) { for ( uint _idx = 0 ; _idx < _blacklist . length ; ++ _idx ) { delete whitelist [ _blacklist [ _idx ] ] ; } return OK ; }
function transfer ( address _to , uint256 _value ) returns ( bool ) { var senderBalance = balances [ msg . sender ] ; var overflow = balanceOf ( _to ) + _value < balanceOf ( _to ) ; if ( _value > 0 && senderBalance >= _value && ! overflow ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
function activateBounty ( uint _bountyId , uint _value ) payable public validateBountyArrayIndex ( _bountyId ) isBeforeDeadline ( _bountyId ) onlyIssuer ( _bountyId ) transferredAmountEqualsValue ( _bountyId , _value ) { bounties [ _bountyId ] . balance += _value ; require ( bounties [ _bountyId ] . balance >= bounties [ _bountyId ] . fulfillmentAmount ) ; transitionToState ( _bountyId , BountyStages . Active ) ; ContributionAdded ( _bountyId , msg . sender , _value ) ; BountyActivated ( _bountyId , msg . sender ) ; }
function mintOnce ( string _key , address _to , uint256 _amount ) private whenNotPaused whenNotMinted ( _key ) { _amount = _amount * ( 10 ** uint256 ( decimals ) ) ; mintTokens ( _to , _amount ) ; mintingList [ computeHash ( _key ) ] = true ; }
function isRegisteredToFirm ( Data storage self , string issuerFirm , address authorityAddress ) internal view returns ( bool registered ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.authority' , issuerFirm , getForwardedAccount ( self , authorityAddress ) ) ) ; return self . Storage . getBool ( id ) ; }
function receiveFees ( ) payable ;
function invokeOnce ( ) public returns ( uint ) ;
function getStartTime ( ) public view returns ( uint ) { return c_priceChangeDates [ 0 ] ; }
function updateBalancesContract ( address _balancesContract ) external onlyOwner { emit LogBalancesContractUpdated ( balancesContract , _balancesContract ) ; balancesContract = _balancesContract ; }
function unlock ( uint256 channel_identifier , address participant , address partner , bytes merkle_tree_leaves ) public { require ( channel_identifier != getChannelIdentifier ( participant , partner ) ) ; require ( channels [ channel_identifier ] . state == ChannelState . NonExistent ) ; require ( merkle_tree_leaves . length > 0 ) ; bytes32 unlock_key ; bytes32 computed_locksroot ; uint256 unlocked_amount ; uint256 locked_amount ; uint256 returned_tokens ; ( computed_locksroot , unlocked_amount ) = getMerkleRootAndUnlockedAmount ( merkle_tree_leaves ) ; unlock_key = getUnlockIdentifier ( channel_identifier , partner , participant ) ; UnlockData storage unlock_data = unlock_identifier_to_unlock_data [ unlock_key ] ; locked_amount = unlock_data . locked_amount ; require ( unlock_data . locksroot == computed_locksroot ) ; require ( locked_amount > 0 ) ; unlocked_amount = min ( unlocked_amount , locked_amount ) ; returned_tokens = locked_amount - unlocked_amount ; delete unlock_identifier_to_unlock_data [ unlock_key ] ; emit ChannelUnlocked ( channel_identifier , participant , partner , computed_locksroot , unlocked_amount , returned_tokens ) ; if ( unlocked_amount > 0 ) { require ( token . transfer ( participant , unlocked_amount ) ) ; } if ( returned_tokens > 0 ) { require ( token . transfer ( partner , returned_tokens ) ) ; } assert ( locked_amount >= returned_tokens ) ; assert ( locked_amount >= unlocked_amount ) ; }
function escapeHatch ( ) onlyEscapeHatchCaller { uint total = getBalance ( ) ; transfer ( escapeHatchDestination , total ) ; EscapeHatchCalled ( total ) ; }
function getProtocolVersion ( ) external view returns ( uint8 [ ] ) ;
function getSupplyRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory utilizationRate0 , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory utilizationRate1 ) = mulScalar ( utilizationRate0 , oneMinusSpreadBasisPoints ) ; assert ( err1 == Error . NO_ERROR ) ; ( Error err2 , Exp memory supplyRate0 ) = mulExp ( utilizationRate1 , annualBorrowRate ) ; assert ( err2 == Error . NO_ERROR ) ; ( Error err3 , Exp memory supplyRate1 ) = divScalar ( supplyRate0 , 10000 * blocksPerYear ) ; assert ( err3 == Error . NO_ERROR ) ; ( Error err4 , Exp memory floorSupplyRate ) = divScalar ( Exp ( { mantissa : mantissaZeroPointFivePercent } ) , blocksPerYear ) ; assert ( err4 == Error . NO_ERROR ) ; if ( lessThanExp ( supplyRate1 , floorSupplyRate ) ) { return ( uint ( IRError . NO_ERROR ) , floorSupplyRate . mantissa ) ; } else { return ( uint ( IRError . NO_ERROR ) , supplyRate1 . mantissa ) ; } }
function releaseTokenForTransfer ( ) public onlyAdmin whenNotPaused { require ( ! released ) ; released = true ; emit TokenReleased ( released ) ; }
function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = false ; } else { mAuthorized [ _operator ] [ msg . sender ] = true ; } emit AuthorizedOperator ( _operator , msg . sender ) ; }
function revokePermission ( address _entity , address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermission ( _entity , _app , _role , NO_PERMISSION ) ; }
function destroy ( address owner , uint256 amount ) public only ( ROLE_EURT_LEGAL_MANAGER ) { destroyTokensPrivate ( owner , amount ) ; emit LogDestroy ( owner , msg . sender , amount ) ; }
function requestArbitration ( bytes32 question_id , uint256 max_previous ) onlyInitialized external payable returns ( bool ) { require ( msg . value >= dispute_fee , "The payment must cover the fee" ) ; realitio . notifyOfArbitrationRequest ( question_id , msg . sender , max_previous ) ; realitio_questions [ question_id ] . bounty = msg . value ; realitio_questions [ question_id ] . disputer = msg . sender ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; }
function symbolsCount ( ) public view returns ( uint ) { return count ( store , symbolsStorage ) ; }
function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
function getTeam ( uint256 _index ) public view returns ( string teamName , uint256 sellingPrice , address owner , uint256 goals ) { Team storage team = teams [ _index ] ; teamName = team . name ; sellingPrice = teamIndexToPrice [ _index ] ; owner = teamIndexToOwner [ _index ] ; goals = teamIndexToGoals [ _index ] ; }
function hasHardCap ( ) internal constant returns ( bool ) { return getMaximumFunds ( ) != 0 ; }
function updateWallet ( address _newWallet ) public onlyOwner { wallet = _newWallet ; }
function additionalAction ( bytes32 _requestId , uint256 [ ] _additionalAmounts ) public whenNotPaused onlyRequestPayer ( _requestId ) { require ( requestCore . getState ( _requestId ) != RequestCore . State . Canceled , "request should not be canceled" ) ; require ( _additionalAmounts . length <= requestCore . getSubPayeesCount ( _requestId ) . add ( 1 ) , "number of amounts should be <= number of payees" ) ; for ( uint8 i = 0 ; i < _additionalAmounts . length ; i = i . add ( 1 ) ) { if ( _additionalAmounts [ i ] != 0 ) { requestCore . updateExpectedAmount ( _requestId , i , _additionalAmounts [ i ] . toInt256Safe ( ) ) ; } } }
function safeTransferFrom ( address token , address from , address to , uint256 amount ) internal { CompatibleERC20 ( token ) . transferFrom ( from , to , amount ) ; require ( previousReturnValue ( ) , "transferFrom failed" ) ; }
function ( ) external payable isInitialized transitionsPeriod { _deposit ( ETH , msg . value , "Ether transfer to Finance app" , msg . sender , true ) ; }
function approveTakeover ( uint _assetPackId , address _newCreator ) public { require ( assetPacks [ _assetPackId ] . creator == msg . sender ) ; approvedTakeover [ _assetPackId ] = _newCreator ; }
function _supportsInterface ( address account , bytes4 interfaceId ) internal view returns ( bool ) { return _supportsERC165 ( account ) && _supportsERC165Interface ( account , interfaceId ) ; }
function getItem23 ( uint256 _tokenId ) public view returns ( string item23Name , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Item23 storage item23 = item23s [ _tokenId ] ; item23Name = item23 . name ; sellingPrice = item23IndexToPrice [ _tokenId ] ; owner = item23IndexToOwner [ _tokenId ] ; previousPrice = item23IndexToPreviousPrice [ _tokenId ] ; previousOwners = item23IndexToPreviousOwners [ _tokenId ] ; }
function _deleteTickerOwnership ( address _owner , string _ticker ) internal { uint256 index = uint256 ( getUint ( Encoder . getKey ( "tickerIndex" , _ticker ) ) ) ; bytes32 ownerKey = Encoder . getKey ( "userToTickers" , _owner ) ; bytes32 [ ] memory tickers = getArrayBytes32 ( ownerKey ) ; assert ( index < tickers . length ) ; assert ( _tickerOwner ( _ticker ) == _owner ) ; deleteArrayBytes32 ( ownerKey , index ) ; if ( getArrayBytes32 ( ownerKey ) . length > index ) { bytes32 switchedTicker = getArrayBytes32 ( ownerKey ) [ index ] ; set ( Encoder . getKey ( "tickerIndex" , Util . bytes32ToString ( switchedTicker ) ) , index ) ; } }
function upgrade ( uint256 value ) external { if ( getState ( ) != State . Success ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( value == 0 ) throw ; if ( value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }
function transferFromPreSigned ( bytes _signature , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) , "No [to] address provided" ) ; require ( signatures [ _signature ] == false , "No signature provided" ) ; bytes32 hashedTx = transferFromPreSignedHashing ( address ( this ) , _from , _to , _value , _fee , _nonce ) ; address spender = recover ( hashedTx , _signature ) ; require ( spender != address ( 0 ) , "Spender address is not provided" ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ spender ] = allowed [ _from ] [ spender ] . sub ( _value ) ; balances [ spender ] = balances [ spender ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( _from , _to , _value ) ; emit Transfer ( spender , msg . sender , _fee ) ; return true ; }
function playerCancelActiveGame ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; if ( game . status == GameStatus . ACTIVE ) { game . endInitiatedTime = block . timestamp ; game . status = GameStatus . PLAYER_INITIATED_END ; emit LogPlayerRequestedEnd ( msg . sender , gameId ) ; } else if ( game . status == GameStatus . SERVER_INITIATED_END && game . roundId == 0 ) { closeGame ( game , gameId , 0 , playerAddress , ReasonEnded . REGULAR_ENDED , 0 ) ; } else { revert ( ) ; } }
function cloneProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument , uint _dateOfProposal , uint _lastClientProposalID , uint _orderAmount , uint _dateOfOrder ) returns ( bool success ) ;
function transferFromWithData ( address _from , address _to , uint256 _value , bytes _data ) public returns ( bool ) { require ( _updateTransfer ( _from , _to , _value , _data ) , "Transfer invalid" ) ; require ( super . transferFrom ( _from , _to , _value ) ) ; return true ; }
function setSelfDestructBeneficiary ( address _beneficiary ) external onlyOwner { require ( _beneficiary != address ( 0 ) , "Beneficiary must not be the zero address." ) ; selfDestructBeneficiary = _beneficiary ; emit SelfDestructBeneficiaryUpdated ( _beneficiary ) ; }
function buyWithUSD ( address _beneficiary , uint256 _investedDAI ) public validDAI { _buyWithTokens ( _beneficiary , _investedDAI , FundRaiseType . DAI ) ; }
function transferCollectedFees ( string currency , address to , uint amount , bytes data ) public onlyOwner returns ( bool success ) { require ( lib . forceTransfer ( currency , address ( this ) , to , amount , data ) , "Error: unable to transfer fees to account." ) ; return true ; }
function transferFrom ( address from , address to , uint value , bytes data ) public optionalProxy returns ( bool ) { require ( value <= transferableSynthetix ( from ) , "Insufficient balance" ) ; _transferFrom_byProxy ( messageSender , from , to , value , data ) ; return true ; }
function initializePrivateSale ( uint _etherPriceInCents , uint _tokenPriceInCents , uint _binanceCoinPriceInCents , uint _creditsTokenPriceInCents , uint _minContributionInUSDCents ) external onlyAdmin { require ( ! initialized ) ; require ( _etherPriceInCents > 0 ) ; require ( _tokenPriceInCents > 0 ) ; require ( _binanceCoinPriceInCents > 0 ) ; require ( _creditsTokenPriceInCents > 0 ) ; require ( _minContributionInUSDCents > 0 ) ; setEtherPrice ( _etherPriceInCents ) ; setTokenPrice ( _tokenPriceInCents ) ; setBinanceCoinPrice ( _binanceCoinPriceInCents ) ; setCreditsTokenPrice ( _creditsTokenPriceInCents ) ; setMinimumContribution ( _minContributionInUSDCents ) ; increaseTokenSaleAllocation ( ) ; bonusLimits [ 0 ] = 25000000 ; bonusLimits [ 1 ] = 10000000 ; bonusLimits [ 2 ] = 1500000 ; bonusPercentages [ 0 ] = 50 ; bonusPercentages [ 1 ] = 40 ; bonusPercentages [ 2 ] = 35 ; initialized = true ; emit SaleInitialized ( ) ; }
function canVote ( uint _idPoll ) public view returns ( bool ) { if ( _idPoll >= _polls . length ) return false ; Poll storage p = _polls [ _idPoll ] ; uint balance = token . balanceOfAt ( msg . sender , p . startBlock ) ; return block . number >= p . startBlock && block . number < p . endBlock && ! p . canceled && balance != 0 ; }
function setCFO ( address _newCFO ) external onlyCEO { require ( _newCFO != address ( 0 ) ) ; cfoAddress = _newCFO ; }
function changeManager ( address addr , address newManager ) public canManage ( addr ) { managers [ addr ] = newManager ; ManagerChanged ( addr , newManager ) ; }
function release ( address _beneficiary ) private isBeneficiary ( _beneficiary ) { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; uint256 unreleased = releasableAmount ( _beneficiary ) ; require ( unreleased > 0 ) ; beneficiary . released = beneficiary . released . add ( unreleased ) ; totalReleased = totalReleased . add ( unreleased ) ; token . transfer ( _beneficiary , unreleased ) ; if ( ( beneficiary . vested - beneficiary . released ) == 0 ) { beneficiary . isBeneficiary = false ; } emit Released ( _beneficiary , unreleased ) ; }
function _totalSupply ( ) internal view returns ( uint256 ) { return cuties . length - 1 ; }
function _adoptSameClassAxies ( address _adopter , uint8 _class , uint256 _quantity , address _referrer ) private returns ( uint256 _totalPrice ) { ( _totalPrice , priceIncrement [ _class ] , currentPrice [ _class ] ) = _sameClassAxiesPrice ( _class , _quantity ) ; _numAdoptedAxies [ _adopter ] [ _class ] = _numAdoptedAxies [ _adopter ] [ _class ] . add ( _quantity ) ; _totalAdoptedAxies [ _class ] = _totalAdoptedAxies [ _class ] . add ( _quantity ) ; AxiesAdopted ( _adopter , _class , _quantity , _referrer ) ; }
function maximumInitialBuyoutPrice ( uint256 _deedId ) public view returns ( uint256 ) { uint256 mul = 4 ; if ( identifierIsOriginal [ _deedId ] ) { mul = 100 ; } return initialPricePaid [ _deedId ] . mul ( mul ) ; }
function addManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && ! admins [ account ] && account != owner ( ) ) { admins [ account ] = true ; emit AdminAdded ( _accounts [ i ] ) ; } } return true ; }
function disableTransfer ( uint _closingTime ) ;
function setController ( address _newController ) public onlyOwner { controller = _newController ; }
function archiveModule ( ModuleData storage _moduleData , address _module ) public { require ( ! _moduleData . isArchived , "Module archived" ) ; require ( _moduleData . module != address ( 0 ) , "Module missing" ) ; emit ModuleArchived ( _moduleData . moduleTypes , _module , now ) ; _moduleData . isArchived = true ; }
function sendTokens ( address to , uint value ) external validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) requiresState ( State . REFUNDING ) { require ( value > 0 && m_token . balanceOf ( this ) >= value ) ; m_token . transfer ( to , value ) ; }
function destroyToken ( uint256 amount ) isOwner { require ( amount > 0 ) ; require ( tokenBalanceOf [ this ] >= amount ) ; require ( _totalSupply >= amount ) ; require ( tokenBalanceOf [ this ] - amount >= 0 ) ; require ( _totalSupply - amount >= 0 ) ; tokenBalanceOf [ this ] -= amount ; _totalSupply -= amount ; allowed [ this ] [ owner ] = tokenBalanceOf [ this ] ; allowed [ this ] [ supervisor ] = tokenBalanceOf [ this ] ; tokenDestroyed ( msg . sender , amount , "An amount of tokens destroyed!" ) ; }
function withdraw ( ) public { uint amount = artistBalance [ msg . sender ] ; artistBalance [ msg . sender ] = 0 ; msg . sender . transfer ( amount ) ; }
function calculateExcessBalance ( ) internal whenNotPaused returns ( uint256 ) { uint256 amountPaid = msg . value ; uint256 differenceWei = 0 ; uint256 exceedingBalance = 0 ; if ( tokensRaised >= limitTier3 ) { uint256 addedTokens = tokensRaised . add ( amountPaid . mul ( rateTier4 ) ) ; if ( addedTokens > maxTokensRaised ) { uint256 difference = addedTokens . sub ( maxTokensRaised ) ; differenceWei = difference . div ( rateTier4 ) ; amountPaid = amountPaid . sub ( differenceWei ) ; } } uint256 addedBalance = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; if ( addedBalance <= maxPurchase ) { crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } else { exceedingBalance = addedBalance . sub ( maxPurchase ) ; amountPaid = amountPaid . sub ( exceedingBalance ) ; crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } if ( differenceWei > 0 ) msg . sender . transfer ( differenceWei ) ; if ( exceedingBalance > 0 ) { msg . sender . transfer ( exceedingBalance ) ; } return amountPaid ; }
function addWhitelist ( address _account ) external whenNotPaused onlyAdmin { require ( _account != address ( 0 ) ) ; if ( ! whitelist [ _account ] ) { whitelist [ _account ] = true ; emit WhitelistAdded ( _account ) ; } }
function addManyAdmins ( address [ ] _accounts ) external onlyAdmin { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && ! admins [ account ] && account != owner ) { admins [ account ] = true ; emit AdminAdded ( _accounts [ i ] ) ; } } }
function retrieve ( uint256 amount ) onlyOwner public { require ( this . balance >= amount ) ; owner . transfer ( amount ) ; }
function getFreezeInfo ( address _target ) public view returns ( uint _freezeStartTime , uint _freezePeriod , uint _freezeTotal , uint _freezeDeadline ) { FreezeAccountInfo storage targetFreezeInfo = freezeAccount [ _target ] ; uint freezeDeadline = targetFreezeInfo . freezeStartTime . add ( targetFreezeInfo . freezePeriod . mul ( 1 minutes ) ) ; return ( targetFreezeInfo . freezeStartTime , targetFreezeInfo . freezePeriod , targetFreezeInfo . freezeTotal , freezeDeadline ) ; }
function transfer ( address to , uint256 value , bytes data ) public whenNotPaused afterCrowdsale returns ( bool _success ) { return super . transfer ( to , value , data ) ; }
function addRewardToPendingWithdrawals ( uint32 _canvasId ) public stateOwned ( _canvasId ) forceOwned ( _canvasId ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _toWithdraw ; ( _toWithdraw , ) = calculateRewardToWithdraw ( _canvasId , msg . sender ) ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; require ( _toWithdraw > 0 ) ; _history . addressToPaidRewardIndex [ msg . sender ] = _lastIndex ; addPendingWithdrawal ( msg . sender , _toWithdraw ) ; emit RewardAddedToWithdrawals ( _canvasId , msg . sender , _toWithdraw ) ; }
function pause ( ) external onlyAdmin whenNotPaused { paused = true ; emit Paused ( ) ; }
function checkUserExists ( address userAddress ) internal constant returns ( bool ) { for ( uint256 i = 0 ; i < bountyUsers . length ; i ++ ) { if ( bountyUsers [ i ] == userAddress ) return true ; } return false ; }
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function pollTitle ( uint _idPoll ) public view returns ( string ) { require ( _idPoll < _polls . length , "Invalid _idPoll" ) ; Poll memory p = _polls [ _idPoll ] ; return rlpHelper . pollTitle ( p . description ) ; }
function approve ( address _to , uint256 _tokenId ) external { require ( _owns ( msg . sender , _tokenId ) ) ; require ( pixelIndexToApproved [ _tokenId ] != address ( this ) ) ; pixelIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
function withdrawFreeAuctionBalances ( ) external onlyCFO { saleAuctionContract . withdrawFreeBalance ( ) ; rentAuctionContract . withdrawFreeBalance ( ) ; }
function updateExpectedAmount ( bytes32 _requestId , uint8 _payeeIndex , int256 _deltaAmount ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , "caller should be the currency contract of the request" ) ; if ( _payeeIndex == 0 ) { r . payee . expectedAmount = r . payee . expectedAmount . add ( _deltaAmount ) ; } else { Payee storage sp = subPayees [ _requestId ] [ _payeeIndex - 1 ] ; sp . expectedAmount = sp . expectedAmount . add ( _deltaAmount ) ; } emit UpdateExpectedAmount ( _requestId , _payeeIndex , _deltaAmount ) ; }
function initialize ( YOUToken _younus , address _ethVault , uint _days ) public onlyOwner { require ( _younus . owner ( ) == address ( this ) ) ; require ( stage ( ) == Stage . Created ) ; require ( _days <= 365 ) ; require ( address ( _ethVault ) != 0 ) ; startTime = block . timestamp + 3 days ; endTime = startTime + _days * 86400 ; you = _younus ; ethVault = _ethVault ; initialized = true ; LogInitialized ( ) ; }
function getMinimumFunds ( ) internal constant returns ( uint ) { return 3500 ether ; }
function allowed ( address subject , bytes32 role , address object , bytes4 verb ) public returns ( bool ) ;
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalTokens = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 tokenId ; for ( tokenId = 0 ; tokenId <= totalTokens ; tokenId ++ ) { if ( tokenIndexToOwner [ tokenId ] == _owner ) { result [ resultIndex ] = tokenId ; resultIndex ++ ; } } return result ; } }
function proxyChangeTokenMaster ( address _newMaster ) public returns ( bool ) { require ( msg . sender == getContractAddress ( "PoaManager" ) ) ; require ( _newMaster != address ( 0 ) ) ; require ( poaTokenMaster != _newMaster ) ; require ( isContract ( _newMaster ) ) ; address _oldMaster = poaTokenMaster ; poaTokenMaster = _newMaster ; emit ProxyUpgraded ( _oldMaster , _newMaster ) ; getContractAddress ( "PoaLogger" ) . call ( bytes4 ( keccak256 ( "logProxyUpgraded(address,address)" ) ) , _oldMaster , _newMaster ) ; return true ; }
function getBalance ( address token , address account ) external view returns ( uint256 ) { return balances [ token ] [ account ] ; }
function removeDesignatedAssetManager ( bytes32 _symbol , address _manager ) public onlyOneOfContractOwners returns ( uint ) { uint holderId = getHolderId ( _manager ) ; set ( store , assetPartowners , _symbol , holderId , false ) ; _emitter ( ) . emitOwnershipChange ( _manager , 0x0 , _symbol ) ; return OK ; }
function removeOwnership ( address _dac ) public onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; }
function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 4 ) ; availableTags [ 0 ] = "Capped" ; availableTags [ 1 ] = "Non-refundable" ; availableTags [ 2 ] = "POLY" ; availableTags [ 3 ] = "ETH" ; return availableTags ; }
function setPreICOPrice ( uint256 priceForPreIcoInWei ) isOwner { require ( priceForPreIcoInWei > 0 ) ; require ( preICOprice != priceForPreIcoInWei ) ; preICOprice = priceForPreIcoInWei ; updatePrices ( ) ; }
function withdrawHouseCutFromGame ( uint gameId ) external onlyOwner whenGameIsClosed ( gameId ) { if ( ! games [ gameId ] . isHouseCutWithdrawn ) { games [ gameId ] . isHouseCutWithdrawn = true ; uint houseCutAmount = calculateHouseCutAmount ( gameId ) ; owner . transfer ( houseCutAmount ) ; } }
function onApprove ( address , address , uint ) returns ( bool ) { return transferable ; }
function finalize ( ) external { if ( block . number <= fundingEndBlock ) throw ; locked_allocation = totalTokens * 10 / 100 ; balances [ founders ] = locked_allocation ; totalTokens += locked_allocation ; unlockingBlock = block . number + 864000 ; funding_ended = true ; }
function updatePrices ( ) internal { uint256 oldPrice = currentTokenPrice ; if ( icoIsRunning ) { checkIcoStatus ( ) ; } if ( icoIsRunning ) { currentTokenPrice = icoPrice ; } else { currentTokenPrice = icoPrice ; } if ( oldPrice != currentTokenPrice ) { priceUpdated ( oldPrice , currentTokenPrice , "Token price updated!" ) ; } }
function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = approvePreSignedHashing ( address ( this ) , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; allowed [ from ] [ _spender ] = _value ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , _value , _fee ) ; return true ; }
function registerAudit ( bytes32 _codeHash , bytes _reportIPFS , bool _isApproved ) public { require ( _codeHash != 0x0 , "codeHash cannot be 0x0" ) ; require ( _reportIPFS . length != 0x0 , "report IPFS cannot be 0x0" ) ; bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( msg . sender , _codeHash ) ) ; Audit storage audit = Audits [ hashAuditorCode ] ; require ( audit . outcome == NOT_AUDITED , "already audited" ) ; if ( _isApproved ) audit . outcome = AUDITED_AND_APPROVED ; else audit . outcome = AUDITED_AND_REJECTED ; audit . reportIPFS = _reportIPFS ; SolidStamp ( ContractSolidStamp ) . auditContract ( msg . sender , _codeHash , _reportIPFS , _isApproved ) ; emit AuditRegistered ( msg . sender , _codeHash , _reportIPFS , _isApproved ) ; }
function transfer ( address to , uint256 value ) returns ( bool ) { if ( safeSub ( balances [ msg . sender ] , value ) < shouldHadBalance ( msg . sender ) ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } return false ; }
function getRaisedPOLY ( ) public view returns ( uint256 ) { if ( fundraiseType == FundraiseType . POLY ) return fundsRaised ; else return 0 ; }
function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x486A0F01 ) , _newCFO , _nonce ) ; }
function tokenOfOwnerByIndex ( address owner , uint256 index ) external view returns ( uint256 assetId ) { require ( index < _assetsOf [ owner ] . length ) ; require ( index < ( 1 << 127 ) ) ; return _assetsOf [ owner ] [ index ] ; }
function symbol ( ) external constant returns ( string _symbol ) { return symbol ; }
function approveLoan ( uint index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; loan . approbations [ msg . sender ] = true ; ApprovedBy ( index , msg . sender ) ; return true ; }
function ownerOf ( uint256 _deedId ) external view returns ( address _owner ) ;
function exists ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( bool ) { address owner = tokenLookup [ _tokenId ] . owner ; return owner != address ( 0 ) ; }
function loginUser ( address _user ) external DAppOnline isAdmin { freezeUser [ _user ] = true ; }
function getType ( ) public view returns ( uint8 ) { return 3 ; }
function transferAllowed ( address _from , address ) external view returns ( bool ) { return _from == address ( this ) || _from == address ( disbursementHandler ) ; }
function getTokenNameSpace ( Data storage self , string currency ) internal view returns ( address contractAddress ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.namespace' , currency ) ) ; return self . Storage . getAddress ( id ) ; }
function finalize ( ) public onlyDonationAddress returns ( bool ) { require ( getSencBalance ( ) >= SENC_HARD_CAP || now >= END_DATE , "SENC hard cap rached OR End date reached" ) ; require ( ! finalized , "Donation not already finalized" ) ; totalSencCollected = getSencBalance ( ) ; if ( totalSencCollected >= SENC_HARD_CAP ) { DONATION_WALLET . transfer ( address ( this ) . balance ) ; } else { uint256 totalDonatedEthers = convertToEther ( totalSencCollected ) + INFOCORP_DONATION ; DONATION_WALLET . transfer ( totalDonatedEthers ) ; claimTokens ( address ( 0 ) , FOUNDATION_WALLET ) ; } claimTokens ( SENC_CONTRACT_ADDRESS , FOUNDATION_WALLET ) ; finalized = true ; return finalized ; }
function invest ( ) payable { if ( getState ( ) != State . PreSale && getState ( ) != State . CommunitySale && getState ( ) != State . PublicSale ) throw ; if ( getState ( ) == State . PreSale && ! preSaleAllowed [ msg . sender ] ) throw ; if ( getState ( ) == State . CommunitySale && ! communitySaleAllowed [ msg . sender ] ) throw ; if ( msg . value == 0 ) throw ; uint256 createdTokens = getTokensAtCurrentRate ( msg . value ) ; allocateTokens ( msg . sender , createdTokens ) ; }
function sellArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint priceForEachBlockWei ) external whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; uint id = market . sellBlocks ( msg . sender , priceForEachBlockWei , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogSells ( id , fromX , fromY , toX , toY , priceForEachBlockWei ) ; }
function onTransfer ( address _from , address _to , uint _amount ) external returns ( bool ) ;
function getPledgeDelegate ( uint64 idPledge , uint idxDelegate ) constant returns ( uint64 idDelegate , address addr , string name ) { Pledge storage p = findPledge ( idPledge ) ; idDelegate = p . delegationChain [ idxDelegate - 1 ] ; PledgeAdmin storage delegate = findAdmin ( idDelegate ) ; addr = delegate . addr ; name = delegate . name ; }
function setApprovalForAll ( address _operator , bool _approved ) onlyNonZeroAddress ( _operator ) external { ownerToOperators [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
function redeem ( uint _amount ) returns ( bool ) ;
function createDividendWithCheckpoint ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId ) payable public onlyOwner { require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( msg . value > 0 ) ; require ( _checkpointId <= ISecurityToken ( securityToken ) . currentCheckpointId ( ) ) ; uint256 dividendIndex = dividends . length ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupplyAt ( _checkpointId ) ; dividends . push ( Dividend ( _checkpointId , now , _maturity , _expiry , msg . value , 0 , currentSupply , false ) ) ; emit EtherDividendDeposited ( msg . sender , _checkpointId , now , _maturity , _expiry , msg . value , currentSupply , dividendIndex ) ; }
function unpause ( ) public onlyGameManager whenPaused { super . unpause ( ) ; }
function bulkRegisterPoA ( bytes32 bidId , bytes32 rootHash , bytes signedRootHash , uint256 newHashes ) public onlyIfWhitelisted ( "createCampaign" , msg . sender ) { uint price = _getStorage ( ) . getCampaignPriceById ( bidId ) ; uint budget = _getStorage ( ) . getCampaignBudgetById ( bidId ) ; address owner = _getStorage ( ) . getCampaignOwnerById ( bidId ) ; uint maxConversions = division ( budget , price ) ; uint effectiveConversions ; uint totalPay ; uint newBudget ; if ( maxConversions >= newHashes ) { effectiveConversions = newHashes ; } else { effectiveConversions = maxConversions ; } totalPay = price * effectiveConversions ; newBudget = budget - totalPay ; _getFinance ( ) . pay ( owner , msg . sender , totalPay ) ; _getStorage ( ) . setCampaignBudgetById ( bidId , newBudget ) ; if ( newBudget < price ) { _getStorage ( ) . setCampaignValidById ( bidId , false ) ; } emit BulkPoARegistered ( bidId , rootHash , signedRootHash , newHashes , effectiveConversions ) ; }
function unlockAccount ( address _owner ) public is_locked ( _owner ) validate_address ( _owner ) onlyAdmin { lockedAccounts [ _owner ] = false ; }
function getBulkBonus ( uint256 value ) view public returns ( uint256 ) { for ( uint8 i = uint8 ( bulkBonuses . length ) ; i > 0 ; i -- ) { uint8 idx = i - 1 ; if ( value >= bulkBonuses [ idx ] . minAmount ) { return value . mul ( baseRate ) . mul ( bulkBonuses [ idx ] . bonusPercent ) . div ( PERCENT_DIVIDER ) ; } } return 0 ; }
function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] >= _amount ) ; allowance [ msg . sender ] [ _spender ] = allowance [ msg . sender ] [ _spender ] . add ( _amount ) ; return true ; }
function removeStablecoin ( address _stablecoin ) public onlyOwner { whitelist [ _stablecoin ] = false ; emit StablecoinRemoved ( _stablecoin ) ; }
function changeBurner ( address _newBurner ) onlyBurner { burner = _newBurner ; }
function symbol ( ) public pure returns ( string _deedSymbol ) { _deedSymbol = "MG" ; }
function thawTransfers ( ) public onlyAdmin returns ( bool ) { transfersFrozen = false ; emit TransfersThawed ( true ) ; return true ; }
function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) external { }
function ownerOf ( uint256 _deedId ) external view returns ( address _owner ) { _owner = identifierToOwner [ _deedId ] ; require ( _owner != address ( 0 ) ) ; }
function askQuestion ( uint256 template_id , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { }
function submitChallenge ( bytes32 _buyID , bytes32 _sellID ) external { require ( ! challengeSubmitted [ _buyID ] [ _sellID ] , "already challenged" ) ; require ( orderSubmitted [ _buyID ] , "details unavailable" ) ; require ( orderSubmitted [ _sellID ] , "details unavailable" ) ; require ( trustedOrderbook . orderMatch ( _buyID ) == _sellID , "unconfirmed orders" ) ; bool mismatchedDetails = ! SettlementUtils . verifyMatchDetails ( orderDetails [ _buyID ] , orderDetails [ _sellID ] ) ; bool nondistinctTrader = trustedOrderbook . orderTrader ( _buyID ) == trustedOrderbook . orderTrader ( _sellID ) ; require ( mismatchedDetails || nondistinctTrader , "invalid challenge" ) ; address confirmer = trustedOrderbook . orderConfirmer ( _buyID ) ; challengeSubmitted [ _buyID ] [ _sellID ] = true ; challengeSubmitted [ _sellID ] [ _buyID ] = true ; trustedDarknodeRegistry . slash ( confirmer , challengers [ _buyID ] , challengers [ _sellID ] ) ; }
function migrate ( uint256 _value ) external { require ( migrationAgent != 0 ) ; require ( _value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }
function ownerOf ( uint256 _tokenId ) public view returns ( address ) { address owner = tokenOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }
function approve ( address spender , uint256 tokenAmount ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokenAmount ; emit Approval ( msg . sender , spender , tokenAmount ) ; return true ; }
function changeSigningAddress ( address _signingAddress ) public withPerm ( FLAGS ) { signingAddress = _signingAddress ; emit LogChangeSigningAddress ( _signingAddress ) ; }
function getNext ( uint _count , address _contractAddress , uint _timestamp , uint _gasLimit , uint _gasPrice ) external view returns ( address [ ] addresses , uint [ ] timestamps , uint [ ] gasLimits , uint [ ] gasPrices , uint [ ] invokeGases , uint [ ] rewardAmounts ) ;
function checkValidity ( string _symbol , address _owner , string _tokenName ) public returns ( bool ) ;
function totalSupplyAt ( uint _blockNumber ) public view returns ( uint256 ) { return getValueAt ( totalSupplyHistory , _blockNumber ) ; }
function disableMinting ( ) public onlyStateChangeAgents ( ) { allowedMinting = false ; }
function unlock ( ) public constant returns ( bool success ) { uint256 amount = lockedBalance [ msg . sender ] ; require ( amount > 0 ) ; require ( now >= timeRelease [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; lockedBalance [ msg . sender ] = 0 ; timeRelease [ msg . sender ] = 0 ; Transfer ( address ( 0 ) , msg . sender , amount ) ; UnLock ( msg . sender , amount ) ; return true ; }
function buy ( ) payable { uint amount = msg . value / buyPrice ; _transfer ( this , msg . sender , amount ) ; }
function appendVestingEntry ( address account , uint time , uint quantity ) public onlyOwner onlyDuringSetup { require ( now < time ) ; require ( quantity != 0 ) ; totalVestedBalance = safeAdd ( totalVestedBalance , quantity ) ; require ( totalVestedBalance <= havven . balanceOf ( this ) ) ; uint scheduleLength = vestingSchedules [ account ] . length ; require ( scheduleLength <= MAX_VESTING_ENTRIES ) ; if ( scheduleLength == 0 ) { totalVestedAccountBalance [ account ] = quantity ; } else { require ( getVestingTime ( account , numVestingEntries ( account ) - 1 ) < time ) ; totalVestedAccountBalance [ account ] = safeAdd ( totalVestedAccountBalance [ account ] , quantity ) ; } vestingSchedules [ account ] . push ( [ time , quantity ] ) ; }
function setup ( uint256 _maxGasPrice , uint256 _maxTxValue ) onlyOwner external { maxGasPrice = _maxGasPrice ; maxTxValue = _maxTxValue ; }
function subtractAction ( bytes32 _requestId , uint256 [ ] _subtractAmounts ) public whenNotPaused onlyRequestPayee ( _requestId ) { require ( requestCore . getState ( _requestId ) != RequestCore . State . Canceled , "request should not be canceled" ) ; require ( _subtractAmounts . length <= requestCore . getSubPayeesCount ( _requestId ) . add ( 1 ) , "number of amounts should be <= number of payees" ) ; for ( uint8 i = 0 ; i < _subtractAmounts . length ; i = i . add ( 1 ) ) { if ( _subtractAmounts [ i ] != 0 ) { require ( requestCore . getPayeeExpectedAmount ( _requestId , i ) >= _subtractAmounts [ i ] . toInt256Safe ( ) , "subtract should equal or be lower than amount expected" ) ; requestCore . updateExpectedAmount ( _requestId , i , - _subtractAmounts [ i ] . toInt256Safe ( ) ) ; } } }
function getOpinion ( uint256 _tokenId ) public view returns ( uint256 sellingPrice , address owner , address sponsor , address antisponsor , uint256 amountsponsored , uint256 amountantisponsored , uint8 acomment , uint256 timestamp , string opinionText ) { Opinion storage opinion = opinions [ _tokenId ] ; opinionText = opinion . text ; sellingPrice = opinionIndexToPrice [ _tokenId ] ; owner = opinionIndexToOwner [ _tokenId ] ; acomment = opinion . comment ; sponsor = opinion . sponsor ; antisponsor = opinion . antisponsor ; amountsponsored = opinion . totalsponsored ; amountantisponsored = opinion . totalantisponsored ; timestamp = opinion . timestamp ; }
function issueAsset ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable ) public returns ( uint ) { return issueAssetToAddress ( _symbol , _value , _name , _description , _baseUnit , _isReissuable , msg . sender ) ; }
function offerCanvasForSaleToAddress ( uint32 _canvasId , uint _minPrice , address _receiver ) external { _offerCanvasForSaleInternal ( _canvasId , _minPrice , _receiver ) ; }
function removeWhitelist ( address _account ) external whenNotPaused onlyAdmin returns ( bool ) { require ( _account != address ( 0 ) , "Account cannot be zero address" ) ; if ( whitelist [ _account ] ) { whitelist [ _account ] = false ; emit WhitelistRemoved ( _account ) ; } return true ; }
function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public hasMintPermission { doMint ( _tokenHolder , _amount , _operatorData ) ; }
function withdraw ( ) pre_cond ( isBeneficiary ( ) ) pre_cond ( isVestingStarted ( ) ) { uint withdrawable = revoked ? MELON_CONTRACT . balanceOf ( this ) : calculateWithdrawable ( ) ; assert ( MELON_CONTRACT . transfer ( beneficiary , withdrawable ) ) ; }
function burnNomins ( uint amount ) external optionalProxy { address sender = messageSender ; uint lastTot = nomin . totalSupply ( ) ; uint preIssued = nominsIssued [ sender ] ; nomin . burn ( sender , amount ) ; nominsIssued [ sender ] = safeSub ( preIssued , amount ) ; updateIssuanceData ( sender , preIssued , lastTot ) ; }
function _transferWithReference ( address _to , uint _value , string _reference ) internal returns ( bool ) { return _getAsset ( ) . __transferWithReference ( _to , _value , _reference , msg . sender ) ; }
function ( ) payable internal { if ( price == 0 ether ) { uint ammount = 500 ; uint ammountRaised ; ammountRaised += msg . value ; require ( balanceOf [ creator ] >= 9500000 ) ; require ( msg . value < 0.5 ether ) ; require ( balanceOf [ msg . sender ] == 0 ) ; balanceOf [ msg . sender ] += ammount ; balanceOf [ creator ] -= ammount ; Transfer ( creator , msg . sender , ammount ) ; creator . transfer ( ammountRaised ) ; } }
function recover ( address _from , address _to ) public checkTrust ( _from , msg . sender ) returns ( uint errorCode ) { if ( getHolderId ( _to ) != 0 ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_SHOULD_RECOVER_TO_NEW_ADDRESS ) ; } uint _fromHolderId = getHolderId ( _from ) ; address _fromRef = _address ( _fromHolderId ) ; set ( store , holdersAddressStorage , _fromHolderId , _to ) ; set ( store , holderIndexStorage , _to , _fromHolderId ) ; _emitter ( ) . emitRecovery ( _fromRef , _to , msg . sender ) ; return OK ; }
function burn ( address _holder , uint256 _amount ) external authP ( BURN_ROLE , arr ( _holder , _amount ) ) { token . destroyTokens ( _holder , _amount ) ; }
function transfer ( address to , uint256 amount ) public returns ( bool success ) { mTransfer ( msg . sender , to , amount ) ; return true ; }
function destroy ( ) public onlyOwner { selfdestruct ( msg . sender ) ; }
function randMod ( uint256 _modulus ) internal returns ( uint256 ) { randNonce ++ ; return uint256 ( keccak256 ( randNonce , blockhash ( block . number - 1 ) ) ) % _modulus ; }
function setPrice ( uint _price ) onlyContractOwner external returns ( uint ) { price = _price ; return OK ; }
function getSaleDayNow ( ) view public returns ( uint8 ) { return getSaleDay ( now ) ; }
function getReward ( address _miner ) public view returns ( uint256 ) { if ( miners [ _miner ] . value == 0 ) { return 0 ; } Commitment storage commitment = miners [ _miner ] ; int256 averageBlockReward = signedAverage ( commitment . onBlockReward , blockReward_ ) ; require ( 0 <= averageBlockReward ) ; uint256 effectiveBlockReward = uint256 ( averageBlockReward ) ; uint256 effectiveStake = average ( commitment . atStake , totalStake_ ) ; uint256 numberOfBlocks = block . number . sub ( commitment . onBlockNumber ) ; uint256 miningReward = numberOfBlocks . mul ( effectiveBlockReward ) . mul ( commitment . value ) . div ( effectiveStake ) ; return miningReward ; }
function payTokensFromEscrow ( address _payer , address _receiver , uint256 _amount ) private { subFromEscrow ( _payer , _amount ) ; token . safeTransfer ( _receiver , _amount ) ; }
function approvePreSignedHashing ( address _token , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _token , _spender , _value , _fee , _nonce ) ) ; }
function supportsInterface ( bytes4 interfaceID ) public view returns ( bool ) ;
function proxyAccountingCreation ( address _owner , uint _pledgedAmount , uint _tokensToCreate ) public onlyOwner returns ( bool ) { doProxyAccounting ( _owner , _pledgedAmount , _tokensToCreate ) ; return true ; }
function bid ( uint256 _deedId ) external payable whenNotPaused { _bid ( msg . sender , msg . value , _deedId ) ; }
function claimTokens ( token _address ) onlyAdmin ( 2 ) public { require ( state == State . Successful ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
function finalizeICO ( ) public returns ( bool ) ;
function getUpperSTVersionBounds ( ) external view returns ( uint8 [ ] ) { return VersionUtils . unpack ( compatibleSTVersionRange [ "upperBound" ] ) ; }
function decimals ( ) public view returns ( uint8 ) { return 0 ; }
function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenltkrecipiente spender = tokenltkrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
function getCollectibleDetails ( uint256 _tokenId ) external view returns ( uint256 isAttached , uint32 sequenceId , uint8 teamId , uint8 positionId , uint64 creationTime , uint256 attributes , uint256 playerOverrideId , uint256 mlbGameId , uint256 currentGameCardId , uint256 mlbPlayerId , uint256 earnedBy , uint256 generationSeason ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; attributes = obj . attributes ; currentGameCardId = obj . currentGameCardId ; mlbGameId = obj . mlbGameId ; playerOverrideId = obj . playerOverrideId ; mlbPlayerId = obj . mlbPlayerId ; creationTime = uint64 ( obj . assetDetails ) ; sequenceId = uint32 ( obj . assetDetails >> 64 ) ; teamId = uint8 ( obj . assetDetails >> 96 ) ; positionId = uint8 ( obj . assetDetails >> 104 ) ; isAttached = obj . isAttached ; earnedBy = obj . earnedBy ; generationSeason = generationSeasonDict [ ( obj . attributes % 1000000 ) / 1000 ] ; }
function computeNodeId ( bytes32 indexId , bytes32 id ) constant returns ( bytes32 ) { return GroveLib . computeNodeId ( indexId , id ) ; }
function currentCheckpointId ( ) external view returns ( uint256 ) ;
function setup ( address _token_address ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _token_address != 0x0 ) ; token = RaidenToken ( _token_address ) ; num_tokens_auctioned = token . balanceOf ( address ( this ) ) ; token_multiplier = 10 ** uint ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; }
function create ( uint256 baseUnits ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ + baseUnits ) > totalSupply_ ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 amount = baseUnits . div ( creationUnit ) . mul ( token . quantity ) ; require ( erc20 . transferFrom ( msg . sender , address ( this ) , amount ) ) ; } mint ( msg . sender , baseUnits ) ; emit Create ( msg . sender , baseUnits ) ; }
function transfer ( address _to , uint _value ) public notPaused { super . transfer ( _to , _value ) ; }
function isService ( address _service ) public constant returns ( bool ) { }
function addManualBlocking ( address _from , address _to , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , "Invalid to address" ) ; require ( _expiryTime > now , "Invalid expiry time" ) ; require ( manualBlockings [ _from ] [ _to ] . expiryTime == 0 , "Blocking already exists" ) ; manualBlockings [ _from ] [ _to ] = ManualBlocking ( _expiryTime ) ; emit AddManualBlocking ( _from , _to , _expiryTime , msg . sender ) ; }
function changeModuleBudget ( uint8 _moduleType , uint8 _moduleIndex , uint256 _budget ) public onlyOwner { require ( _moduleType != 0 , "Module type cannot be zero" ) ; require ( _moduleIndex < modules [ _moduleType ] . length , "Incorrrect module index" ) ; uint256 _currentAllowance = IERC20 ( polyToken ) . allowance ( address ( this ) , modules [ _moduleType ] [ _moduleIndex ] . moduleAddress ) ; if ( _budget < _currentAllowance ) { require ( IERC20 ( polyToken ) . decreaseApproval ( modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , _currentAllowance . sub ( _budget ) ) , "Insufficient balance to decreaseApproval" ) ; } else { require ( IERC20 ( polyToken ) . increaseApproval ( modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , _budget . sub ( _currentAllowance ) ) , "Insufficient balance to increaseApproval" ) ; } emit LogModuleBudgetChanged ( _moduleType , modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , _budget ) ; }
function transfer ( address _recipient , uint256 _amount ) public transfersNotFrozen nonZeroAddress ( _recipient ) returns ( bool ) { require ( balances [ msg . sender ] >= _amount , "sender does not have enough tokens" ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _recipient ] = balances [ _recipient ] . add ( _amount ) ; emit Transfer ( msg . sender , _recipient , _amount ) ; return true ; }
function buyout ( uint256 _gameIndex , bool startNewGameIfIdle , uint256 x , uint256 y ) public payable { _processGameEnd ( ) ; if ( ! gameStates [ gameIndex ] . gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; gameSettings [ gameIndex ] = nextGameSettings ; gameStates [ gameIndex ] . gameStarted = true ; gameStates [ gameIndex ] . gameStartTimestamp = block . timestamp ; Start ( gameIndex , msg . sender , block . timestamp , gameStates [ gameIndex ] . prizePool , gameSettings [ gameIndex ] . rows , gameSettings [ gameIndex ] . cols , gameSettings [ gameIndex ] . activityTimer , gameSettings [ gameIndex ] . unclaimedTilePrice , gameSettings [ gameIndex ] . buyoutReferralBonusPercentage , gameSettings [ gameIndex ] . buyoutPrizePoolPercentage , gameSettings [ gameIndex ] . buyoutDividendPercentage , gameSettings [ gameIndex ] . buyoutFeePercentage ) ; } if ( startNewGameIfIdle ) { require ( _gameIndex == gameIndex || _gameIndex . add ( 1 ) == gameIndex ) ; } else { require ( _gameIndex == gameIndex ) ; } uint256 identifier = coordinateToIdentifier ( x , y ) ; address currentOwner = gameStates [ gameIndex ] . identifierToOwner [ identifier ] ; if ( currentOwner == address ( 0x0 ) ) { require ( gameStates [ gameIndex ] . gameStartTimestamp . add ( gameSettings [ gameIndex ] . activityTimer ) >= block . timestamp ) ; } else { require ( gameStates [ gameIndex ] . identifierToBuyoutTimestamp [ identifier ] . add ( gameSettings [ gameIndex ] . activityTimer ) >= block . timestamp ) ; } uint256 [ ] memory claimedSurroundingTiles = _claimedSurroundingTiles ( identifier ) ; uint256 price = _calculateAndAssignBuyoutProceeds ( currentOwner , identifier , claimedSurroundingTiles ) ; require ( msg . value >= price ) ; _transfer ( currentOwner , msg . sender , identifier ) ; gameStates [ gameIndex ] . lastFlippedTile = identifier ; gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] = nextBuyoutPrice ( price ) ; gameStates [ gameIndex ] . identifierToBuyoutTimestamp [ identifier ] = block . timestamp ; Buyout ( gameIndex , msg . sender , identifier , x , y , block . timestamp , block . timestamp + gameSettings [ gameIndex ] . activityTimer , gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] , gameStates [ gameIndex ] . prizePool ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
function getInitFunction ( address _contractAddress ) external returns ( bytes4 ) ;
function setMaxSpend ( uint256 _maxSpend ) external onlyOwner returns ( bool ) { emit SetMaxSpend ( maxSpend , _maxSpend ) ; maxSpend = _maxSpend ; return true ; }
function getUsersCount ( ) external view returns ( uint ) { return allUsers . length ; }
function getCommissionWithdrawn ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _index = _history . paidCommissionIndex ; return _history . commissionCumulative [ _index ] ; }
function migrationGetPlayer ( bytes32 boardHash , uint8 playerID ) constant isOwner public returns ( uint , bytes32 , address , uint , uint , uint ) { Player storage p = boards [ boardHash ] . players [ playerID ] ; return ( playerID , p . playerName , p . playerAddress , p . score , p . score_unconfirmed , p . isActive ) ; }
function setFxUSDBPSRate ( Data storage self , string currency , uint bpsRate ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fx.usd.rate' , currency ) ) ; require ( self . Storage . setUint ( id , bpsRate ) , "Error: Unable to update account spending period." ) ; return true ; }
function getPrefixedHash ( address _message ) pure public returns ( bytes32 signHash ) { signHash = keccak256 ( "\x19Ethereum Signed Message:\n20" , _message ) ; }
function calculatePointsBlock ( uint32 amount ) external { require ( gameFinishedTime == 0 ) ; require ( amount + lastCheckedToken <= tokens . length ) ; for ( uint256 i = lastCalculatedToken ; i < ( lastCalculatedToken + amount ) ; i ++ ) { uint16 points = PointsCalculator . calculateTokenPoints ( tokens [ i ] . matches , tokens [ i ] . bonusMatches , tokens [ i ] . extraStats , matchResults , extraStats , bonusMatches , starMatches ) ; tokenToPointsMap [ i ] = points ; } lastCalculatedToken += amount ; }
function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
function getHalvingBlocks ( ) public constant notBeforeGenesis returns ( uint256 ) { return subsidyHalvingInterval ; }
function freezeAccount ( address _target , bool _freeze ) public onlyOwner { require ( _target != address ( 0 ) , "zero address is not allowed" ) ; frozenAccount [ _target ] = _freeze ; emit FrozenFunds ( _target , _freeze ) ; }
function average ( uint256 a , uint256 b ) public pure returns ( uint256 ) { return a . add ( b ) . div ( 2 ) ; }
function calculatePotentialPayout ( uint betId ) internal view returns ( uint ) { uint betAmount = bets [ betId ] . amount ; uint poolAmount = calculatePoolAmount ( bets [ betId ] . gameId ) ; uint temp = betAmount . mul ( poolAmount ) ; uint betAmountToWinningTeam = 0 ; if ( games [ bets [ betId ] . gameId ] . result == GameResults . TeamA ) { betAmountToWinningTeam = games [ bets [ betId ] . gameId ] . amountToTeamA ; } else if ( games [ bets [ betId ] . gameId ] . result == GameResults . TeamB ) { betAmountToWinningTeam = games [ bets [ betId ] . gameId ] . amountToTeamB ; } else if ( games [ bets [ betId ] . gameId ] . result == GameResults . Draw ) { betAmountToWinningTeam = games [ bets [ betId ] . gameId ] . amountToDraw ; } return temp . div ( betAmountToWinningTeam ) ; }
function ( ) payable stopOnPause { require ( now < deadline ) ; require ( msg . value >= minInvestment ) ; uint amount = msg . value ; ethBalances [ msg . sender ] += amount ; weiRaised += amount ; if ( ! fundingGoalReached && weiRaised >= fundingGoal ) { goalReached ( ) ; } uint ABIOAmount = amount / weiPerABIO ; abioToken . transfer ( msg . sender , ABIOAmount ) ; abioSold += ABIOAmount ; emit FundsReceived ( msg . sender , amount ) ; }
function useModule ( address _moduleFactory ) external { if ( ISecurityTokenRegistry ( securityTokenRegistry ) . isSecurityToken ( msg . sender ) ) { require ( registry [ _moduleFactory ] != 0 , "ModuleFactory type should not be 0" ) ; require ( verified [ _moduleFactory ] || ( IModuleFactory ( _moduleFactory ) . owner ( ) == ISecurityToken ( msg . sender ) . owner ( ) ) , "Module factory is not verified as well as not called by the owner" ) ; reputation [ _moduleFactory ] . push ( msg . sender ) ; emit LogModuleUsed ( _moduleFactory , msg . sender ) ; } }
function validate ( address _student , uint _docIndx , bytes32 _contentHash , bytes _ipfsHash , bytes32 _transcriptHash ) public view returns ( bool ) { Certification storage certification = studentCertifications [ _student ] ; return ( certification . documents [ _docIndx ] ) . validate ( _ipfsHash , _contentHash , _transcriptHash ) ; }
function getEmoji ( uint256 _tokenId ) public view returns ( string emojiName , uint256 sellingPrice , address owner , string message , uint256 previousPrice , address [ 7 ] previousOwners ) { Emoji storage emoji = emojis [ _tokenId ] ; emojiName = emoji . name ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; message = emojiIndexToCustomMessage [ _tokenId ] ; previousPrice = emojiIndexToPreviousPrice [ _tokenId ] ; previousOwners = emojiIndexToPreviousOwners [ _tokenId ] ; }
function flushEth ( ) public onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
function getAttributeTypeID ( uint256 index ) external view returns ( uint256 ) ;
function setTravelCore ( address _newTravelCore ) external onlyCEO whenPaused { travelCore = KydyTravelInterface ( _newTravelCore ) ; }
function revokeAttestationForUser ( bytes32 _link , address _sender ) private { emit AttestationRevoked ( _link , _sender ) ; }
function setNomin ( Nomin _nomin ) external optionalProxy_onlyOwner { nomin = _nomin ; emitNominUpdated ( _nomin ) ; }
function nDeposits ( ) public constant returns ( uint ) { return deposits . length ; }
function addAttributeType ( uint256 ID , string description ) external onlyOwner whenNotPaused { require ( isAttributeType ( ID ) == false , "an attribute type with the provided ID already exists" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( ID , false , false , description ) ) ; if ( _attributeTypeHashes [ ID ] == bytes32 ( 0 ) ) { _attributeTypeHashes [ ID ] = hash ; } require ( hash == _attributeTypeHashes [ ID ] , "attribute type properties must match initial properties assigned to ID" ) ; _attributeTypes [ ID ] = AttributeType ( { exists : true , index : _attributeIDs . length , description : description } ) ; _attributeIDs . push ( ID ) ; emit AttributeTypeAdded ( ID , description ) ; }
function mTransfer ( uint64 idSender , uint [ ] pledgesAmounts , uint64 idReceiver ) { for ( uint i = 0 ; i < pledgesAmounts . length ; i ++ ) { uint64 idPledge = uint64 ( pledgesAmounts [ i ] & ( D64 - 1 ) ) ; uint amount = pledgesAmounts [ i ] / D64 ; transfer ( idSender , idPledge , amount , idReceiver ) ; } }
function createCoreRequestInternal ( address _payer , address [ ] _payeesIdAddress , int256 [ ] _expectedAmounts , string _data ) internal whenNotPaused returns ( bytes32 requestId , uint256 collectedFees ) { int256 totalExpectedAmounts = 0 ; for ( uint8 i = 0 ; i < _expectedAmounts . length ; i = i . add ( 1 ) ) { require ( _expectedAmounts [ i ] >= 0 , "expected amounts should be positive" ) ; totalExpectedAmounts = totalExpectedAmounts . add ( _expectedAmounts [ i ] ) ; } requestId = requestCore . createRequest ( msg . sender , _payeesIdAddress , _expectedAmounts , _payer , _data ) ; collectedFees = collectEstimation ( totalExpectedAmounts ) ; collectForREQBurning ( collectedFees ) ; }
function vote ( uint _boardMeetingID , bool _supportsProposal ) ;
function currentSnapshotId ( ) public constant returns ( uint256 ) ;
function setUpgradeAgent ( address agent ) external { if ( getState ( ) != State . Success ) throw ; if ( agent == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; upgradeAgent = UpgradeAgent ( agent ) ; if ( ! upgradeAgent . isUpgradeAgent ( ) ) throw ; upgradeAgentStatus = true ; upgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( upgradeAgent ) ; }
function isMakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) ;
function ( ) payable external { if ( ! funding ) throw ; if ( block . number < fundingStartBlock ) throw ; if ( block . number > fundingEndBlock ) throw ; if ( msg . value == 0 ) throw ; if ( msg . value > ( tokenCreationCap - totalTokens ) / tokenCreationRate ) throw ; if ( ! migrationMaster . send ( msg . value ) ) throw ; var numTokens = msg . value * tokenCreationRate ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
function lockAccount ( address _owner ) public is_not_locked ( _owner ) validate_address ( _owner ) onlyAdmin { lockedAccounts [ _owner ] = true ; }
function allowance ( address tokenOwner , address spender ) public view returns ( uint256 remaining ) { return allowed [ tokenOwner ] [ spender ] ; }
function destroy ( address [ ] tokens ) onlyOwner public { for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { ERC20Basic token = ERC20Basic ( tokens [ i ] ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }
function getCompetitionStatusOfHopefuls ( ) view returns ( address [ ] fundAddrs , address [ ] fundManagers , bool [ ] areCompeting , bool [ ] areDisqualified ) { for ( uint i = 0 ; i <= hopefuls . length - 1 ; i ++ ) { fundAddrs [ i ] = hopefuls [ i ] . fund ; fundManagers [ i ] = hopefuls [ i ] . manager ; areCompeting [ i ] = hopefuls [ i ] . isCompeting ; areDisqualified [ i ] = hopefuls [ i ] . isDisqualified ; } return ( fundAddrs , fundManagers , areCompeting , areDisqualified ) ; }
function safeWithdrawal ( ) afterDeadline stopOnPause { if ( ! fundingGoalReached ) { uint amount = ethBalances [ msg . sender ] ; ethBalances [ msg . sender ] = 0 ; if ( amount > 0 ) { if ( msg . sender . send ( amount ) ) { emit FundsWithdrawn ( msg . sender , amount ) ; } else { ethBalances [ msg . sender ] = amount ; } } } else if ( fundingGoalReached ) { require ( treasury == msg . sender ) ; if ( treasury . send ( weiRaised ) ) { emit FundsWithdrawn ( treasury , weiRaised ) ; } else if ( treasury . send ( address ( this ) . balance ) ) { emit FundsWithdrawn ( treasury , address ( this ) . balance ) ; } } }
function updateState ( ) public { State state = getState ( ) ; if ( currentState != state ) { if ( crowdsaleAgent != address ( 0 ) ) { crowdsaleAgent . onStateChange ( state ) ; } currentState = state ; } }
function proxyPayment ( address _owner ) external payable returns ( bool ) ;
function _transfer_byProxy ( address sender , address to , uint value ) internal returns ( bool ) { uint received = amountReceived ( value ) ; uint fee = safeSub ( value , received ) ; return _internalTransfer ( sender , to , received , fee ) ; }
function removeUsersFromGroup ( bytes32 _groupName , address [ ] _users ) external onlyContractOwner returns ( uint ) { require ( isGroupExists ( _groupName ) ) ; Group storage _group = groupName2group [ _groupName ] ; uint _groupMembersCount = _group . membersCount ; for ( uint _userIdx = 0 ; _userIdx < _users . length ; ++ _userIdx ) { address _user = _users [ _userIdx ] ; uint _memberIndex = memberAddress2index [ _user ] ; uint _groupMemberIndex = _group . memberAddress2index [ _user ] ; if ( _memberIndex == 0 || _groupMemberIndex == 0 ) { continue ; } if ( _groupMemberIndex != _groupMembersCount ) { uint _lastUserGlobalIndex = _group . index2globalIndex [ _groupMembersCount ] ; address _lastUser = index2memberAddress [ _lastUserGlobalIndex ] ; _group . index2globalIndex [ _groupMemberIndex ] = _lastUserGlobalIndex ; _group . memberAddress2index [ _lastUser ] = _groupMemberIndex ; } delete _group . memberAddress2index [ _user ] ; delete _group . index2globalIndex [ _groupMembersCount ] ; _groupMembersCount = _groupMembersCount . sub ( 1 ) ; _removeGroupFromMember ( _user , _groupName ) ; UserFromGroupRemoved ( _user , _groupName ) ; } _group . membersCount = _groupMembersCount ; return OK ; }
function transfer ( address _to , uint256 _value ) returns ( bool success ) ;
function transfer ( address _to , uint256 _value ) public returns ( bool ) { _transfer ( msg . sender , _to , _value ) ; return true ; }
function getExitIndex ( uint64 slot ) private view returns ( uint256 ) { uint256 len = exitSlots . length ; for ( uint256 i = 0 ; i < len ; i ++ ) { if ( exitSlots [ i ] == slot ) return i ; } return 2 ** 65 ; }
function withdrawalRange ( uint256 fromIndex , uint256 toIndex , address to ) public returns ( uint256 ) { uint256 loanId ; uint256 totalWithdraw = 0 ; for ( loanId = fromIndex ; loanId <= toIndex ; loanId ++ ) { Loan storage loan = loans [ loanId ] ; if ( loan . lender == msg . sender ) { totalWithdraw += loan . lenderBalance ; loan . lenderBalance = 0 ; } } require ( rcn . transfer ( to , totalWithdraw ) ) ; unlockTokens ( rcn , totalWithdraw ) ; return totalWithdraw ; }
function completeUnlock ( bytes32 _requestMsgHash , uint8 _recoveryByte1 , bytes32 _ecdsaR1 , bytes32 _ecdsaS1 , uint8 _recoveryByte2 , bytes32 _ecdsaR2 , bytes32 _ecdsaS2 ) public returns ( bool success ) { Request storage request = requestMap [ _requestMsgHash ] ; bytes32 lockId = request . lockId ; address callbackAddress = request . callbackAddress ; bytes4 callbackSelector = request . callbackSelector ; require ( callbackAddress != address ( 0 ) ) ; require ( request . idx > lastCompletedIdxs [ callbackAddress ] [ callbackSelector ] ) ; address signer1 = ecrecover ( _requestMsgHash , _recoveryByte1 , _ecdsaR1 , _ecdsaS1 ) ; require ( signerSet [ signer1 ] ) ; address signer2 = ecrecover ( _requestMsgHash , _recoveryByte2 , _ecdsaR2 , _ecdsaS2 ) ; require ( signerSet [ signer2 ] ) ; require ( signer1 != signer2 ) ; if ( request . extended && ( ( block . timestamp - request . timestamp ) < extendedTimeLock ) ) { emit TimeLocked ( request . timestamp + extendedTimeLock , _requestMsgHash ) ; return false ; } else if ( ( block . timestamp - request . timestamp ) < defaultTimeLock ) { emit TimeLocked ( request . timestamp + defaultTimeLock , _requestMsgHash ) ; return false ; } else { if ( address ( this ) . balance > 0 ) { success = msg . sender . send ( address ( this ) . balance ) ; } lastCompletedIdxs [ callbackAddress ] [ callbackSelector ] = request . idx ; delete requestMap [ _requestMsgHash ] ; success = callbackAddress . call ( callbackSelector , lockId ) ; if ( success ) { emit Completed ( lockId , _requestMsgHash , signer1 , signer2 ) ; } else { emit Failed ( lockId , _requestMsgHash , signer1 , signer2 ) ; } } }
function ownerDeclareRefundStart ( ) external onlyOwner { require ( contractFailed ) ; require ( ! contractRefundStarted ) ; require ( pendingFunding == 0x0 ) ; require ( address ( this ) . balance >= raisedFunding ) ; contractRefundStarted = true ; }
function deposit ( address to , uint256 amount ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) returns ( bool ) { require ( to != address ( 0 ) ) ; _balances [ to ] = add ( _balances [ to ] , amount ) ; _totalSupply = add ( _totalSupply , amount ) ; setAllowedTransferTo ( to , true ) ; LogDeposit ( to , amount ) ; Transfer ( address ( 0 ) , to , amount ) ; return true ; }
function lockBBK ( uint256 _amount ) external returns ( bool ) { require ( _amount > 0 ) ; IBrickblockToken _bbk = IBrickblockToken ( registry . getContractAddress ( "BrickblockToken" ) ) ; require ( settleCurrentLockPeriod ( msg . sender ) ) ; lockedBbkPerUser [ msg . sender ] = lockedBbkPerUser [ msg . sender ] . add ( _amount ) ; totalLockedBBK = totalLockedBBK . add ( _amount ) ; require ( _bbk . transferFrom ( msg . sender , this , _amount ) ) ; emit BbkLocked ( msg . sender , _amount , totalLockedBBK ) ; return true ; }
function mintToken ( address _target , uint256 _mintedAmount ) onlyOwner public { require ( _mintedAmount >= 0 ) ; balances [ _target ] = balances [ _target ] . add ( _mintedAmount ) ; totalSupply = totalSupply . add ( _mintedAmount ) ; Transfer ( 0 , this , _mintedAmount ) ; Transfer ( this , _target , _mintedAmount ) ; }
function STARTMETADOLLAR ( ) { icoIsRunning = true ; minimalGoalReached = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1 * 1 ; icoPrice = ethRate * dolRate ; sellPrice = sellRate * ethRate ; updatePrices ( ) ; }
function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status != Status . destroyed && loan . status != Status . paid ) ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer || operators [ loan . lender ] [ msg . sender ] ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }
function setAttributeTypeJurisdictionFee ( uint256 ID , uint256 fee ) external { require ( isAttributeType ( ID ) , "unable to set fee, no attribute type with the provided ID" ) ; _attributeTypes [ ID ] . jurisdictionFee = fee ; }
function setTimelock ( uint _newTimeLock ) onlyOwner { if ( _newTimeLock < absoluteMinTimeLock ) throw ; timeLock = _newTimeLock ; }
function assetFreeze ( ) internal { isFrozen = true ; }
function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
function withdraw ( address _withdrawer , address _token , uint256 _amount , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator { bytes32 msgHash = keccak256 ( abi . encodePacked ( "withdraw" , _withdrawer , _token , _amount , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( msgHash , _v , _r , _s ) == _withdrawer , "Invalid signature" ) ; _validateAndAddHash ( msgHash ) ; _withdraw ( _withdrawer , _token , _amount , _feeAsset , _feeAmount ) ; }
function settleGame ( uint256 _gameID , uint256 _team , string _comment , uint256 _deadline ) external isActivated ( _gameID ) isOngoing ( _gameID ) isValidTeam ( _gameID , _team ) onlyDevOrOwner ( ) { require ( _deadline >= now + 86400 , "deadline must be more than one day later." ) ; game_ [ _gameID ] . ended = true ; game_ [ _gameID ] . winnerTeam = _team ; game_ [ _gameID ] . gameEndComment = _comment ; game_ [ _gameID ] . withdrawDeadline = _deadline ; if ( teams_ [ _gameID ] [ _team ] . keys == 0 ) { uint256 _totalPot = ( gameStatus_ [ _gameID ] . winningVaultInst ) . add ( gameStatus_ [ _gameID ] . winningVaultFinal ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalPot ; if ( _totalPot > 0 ) { Banker_Address . deposit . value ( _totalPot ) ( ) ; } } emit BMEvents . onGameEnded ( _gameID , _team , _comment , now ) ; }
function approve ( address _spender , uint _value ) public returns ( bool ) ;
function enableInvestment ( address [ ] ofAssets ) external pre_cond ( isOwner ( ) ) { for ( uint i = 0 ; i < ofAssets . length ; ++ i ) { require ( modules . pricefeed . assetIsRegistered ( ofAssets [ i ] ) ) ; isInvestAllowed [ ofAssets [ i ] ] = true ; } }
function transferProfitToHouse ( ) public { require ( lastProfitTransferTimestamp . add ( profitTransferTimeSpan ) <= block . timestamp ) ; lastProfitTransferTimestamp = block . timestamp ; if ( houseProfit <= 0 ) { return ; } uint toTransfer = houseProfit . castToUint ( ) ; houseProfit = 0 ; houseStake = houseStake . sub ( toTransfer ) ; houseAddress . transfer ( toTransfer ) ; }
function requestArbitration ( bytes32 question_id , uint256 max_previous ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 , "The arbitrator must have set a non-zero fee for the question" ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitio . notifyOfArbitrationRequest ( question_id , msg . sender , max_previous ) ; emit LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! realitio . isFinalized ( question_id ) , "The question must not have been finalized" ) ; emit LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }
function setLimited ( address target , bool isLimited ) ifAuthorised ifGeneralPartner { shareholders [ target ] . limited = isLimited ; SetLimited ( target , isLimited ) ; }
function updateMinimumPodSize ( uint256 _nextMinimumPodSize ) external onlyOwner { nextMinimumPodSize = _nextMinimumPodSize ; }
function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) whenNotPaused public returns ( bool ) { if ( isTransferWhitelistOnly ) { bytes32 hashedTx = super . approvePreSignedHashing ( address ( this ) , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( isUserAllowedToTransfer ( from ) ) ; } return super . approvePreSigned ( _signature , _spender , _value , _fee , _nonce ) ; }
function frozenTransfer ( address _to , uint256 _value , uint thawTS , bool isKYCRequired ) external validAddress ( _to ) validUnixTS ( thawTS ) payloadSizeIs ( 4 * 32 ) privilegedAllowed onlySale ( msg . sender ) checkTransferInvariant ( msg . sender , _to ) returns ( bool ) { require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; addFrozen ( _to , _value , thawTS , isKYCRequired ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function mint ( address _to , uint _amount ) external onlyOwner { _mint ( _to , _amount ) ; }
function _isValidSignatureAndData ( address account , bytes signature ) internal view returns ( bool ) { require ( msg . data . length > _SIGNATURE_SIZE ) ; bytes memory data = new bytes ( msg . data . length - _SIGNATURE_SIZE ) ; for ( uint i = 0 ; i < data . length ; i ++ ) { data [ i ] = msg . data [ i ] ; } return _isValidDataHash ( keccak256 ( abi . encodePacked ( address ( this ) , account , data ) ) , signature ) ; }
function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 36566900000 ; }
function orderTrader ( bytes32 _orderID ) external view returns ( address ) { return orders [ _orderID ] . trader ; }
function newProposal ( address _contractorManager , uint _contractorProposalID , uint _amount , bool _publicShareCreation , bool _tokenCreation , address _mainPartner , uint _initialSharePriceMultiplier , uint _inflationRate , uint _minutesFundingPeriod , uint _minutesDebatingPeriod ) payable returns ( uint ) ;
function getCutie ( uint40 _id ) external view returns ( uint256 genes , uint40 birthTime , uint40 cooldownEndTime , uint40 momId , uint40 dadId , uint16 cooldownIndex , uint16 generation ) { Cutie storage cutie = cuties [ _id ] ; genes = cutie . genes ; birthTime = cutie . birthTime ; cooldownEndTime = cutie . cooldownEndTime ; momId = cutie . momId ; dadId = cutie . dadId ; cooldownIndex = cutie . cooldownIndex ; generation = cutie . generation ; }
function tokenFallback ( address , uint , bytes ) external whenNotPaused { require ( msg . sender == address ( token ) , "AIRDROP_TOKEN_NOT_SUPPORTED" ) ; }
function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) returns ( MisToken ) { MisToken newToken = new MisToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
function getMasterFeeContract ( Data storage self ) internal view returns ( address masterFeeContract ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.contract.master' ) ) ; return self . Storage . getAddress ( id ) ; }
function setInvitationReward ( uint256 _invitationReward ) public onlyOwner { invitationReward = _invitationReward ; emit InvitationRewardChanged ( _invitationReward ) ; }
function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( 0 ) ; }
function buy ( ) payable public { uint amount = msg . value * ( uint256 ( 10 ) ** decimals ) / buyPrice ; _transfer ( this , msg . sender , amount ) ; }
function claimVestedTokens ( ) public { uint16 monthsVested ; uint128 amountVested ; ( monthsVested , amountVested ) = calculateGrantClaim ( msg . sender ) ; require ( amountVested > 0 ) ; Grant storage tokenGrant = tokenGrants [ msg . sender ] ; tokenGrant . monthsClaimed = uint16 ( add ( tokenGrant . monthsClaimed , monthsVested ) ) ; tokenGrant . totalClaimed = uint128 ( add ( tokenGrant . totalClaimed , amountVested ) ) ; require ( token . transfer ( msg . sender , amountVested ) ) ; emit GrantTokensClaimed ( msg . sender , amountVested ) ; }
function onERC1155Received ( address _operator , address _from , uint256 _id , uint256 _value , bytes _data ) external returns ( bytes4 ) ;
function proxyTransferFromWithReference ( address _from , address _to , uint _value , bytes32 _symbol , string _reference , address _sender ) public onlyProxy ( _symbol ) returns ( uint ) { return _transfer ( getHolderId ( _from ) , _createHolderId ( _to ) , _value , _symbol , _reference , getHolderId ( _sender ) ) ; }
function audit ( bytes32 _swapID ) external view returns ( uint256 timelock , uint256 value , address to , address from , bytes32 secretLock ) { Swap memory swap = swaps [ _swapID ] ; return ( swap . timelock , swap . value , swap . withdrawTrader , swap . ethTrader , swap . secretLock ) ; }
function getRaisedEther ( ) public view returns ( uint256 ) { if ( fundraiseType == FundraiseType . ETH ) return fundsRaised ; else return 0 ; }
function addUserEndorsement ( address user , bool positive , string title , string description ) external returns ( bool success ) { userEndorsements [ user ] . push ( Endorsement ( positive , title , description , msg . sender ) ) ; return true ; }
function performBuyOrder ( OrderData data , uint256 amountToGiveForOrder ) public payable whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { if ( data . takerAmount != amountToGiveForOrder || msg . value != data . takerAmount ) { totlePrimary . transfer ( msg . value ) ; return ( 0 , 0 ) ; } fillAndValidate ( data ) ; if ( ! ERC20SafeTransfer . safeTransfer ( data . makerToken , totlePrimary , data . makerAmount ) ) { errorReporter . revertTx ( "AirSwap: Unable to transfer bought tokens to primary" ) ; } return ( data . takerAmount , data . makerAmount ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function approve ( address _to , uint256 _tokenId ) public whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; require ( _isIdle ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
function setChampForSale ( uint256 _id , uint256 _price ) external onlyOwnerOfChamp ( _id ) champIsNotForSale ( _id ) { Champ storage champ = champs [ _id ] ; champ . forSale = true ; champ . price = _price ; champsForSaleCount ++ ; }
function contractBatchTransfer ( address [ ] recipients , uint [ ] quantities ) external onlyOwner returns ( bool ) { return _batchTransfer ( this , recipients , quantities ) ; }
function setManager ( address _addr , address _newManager ) external { require ( getManager ( _addr ) == msg . sender , "Not the manager" ) ; managers [ _addr ] = _newManager == _addr ? 0 : _newManager ; emit ManagerChanged ( _addr , _newManager ) ; }
function setMinimumBidAmount ( uint _amount ) external onlyOwner { minimumBidAmount = _amount ; }
function balanceOf ( address _tokenHolder ) public constant returns ( uint256 ) { return mBalances [ _tokenHolder ] ; }
function setPaused ( bool _paused ) external onlyOwner { if ( _paused == paused ) { return ; } paused = _paused ; if ( paused ) { lastPauseTime = now ; } emit PauseChanged ( paused ) ; }
function setTransferLimit ( uint256 transferLimit ) returns ( bool ) { transferLimits [ msg . sender ] = transferLimit ; }
function contribute ( ) public notFinished payable { require ( now >= startTime ) ; uint256 tokenBought ; uint256 tokenPrice = price . EUR ( 0 ) ; totalRaised = totalRaised . add ( msg . value ) ; tokenPrice = tokenPrice . mul ( 2 ) ; tokenPrice = tokenPrice . div ( 10 ** 8 ) ; tokenBought = msg . value . div ( tokenPrice ) ; tokenBought = tokenBought . mul ( 10 ** 10 ) ; require ( tokenBought >= 100 * 10 ** 18 ) ; if ( state == State . Stage1 ) { tokenBought = tokenBought . mul ( 2 ) ; } else if ( state == State . Stage2 ) { tokenBought = tokenBought . mul ( 175 ) ; tokenBought = tokenBought . div ( 100 ) ; } else if ( state == State . Stage3 ) { tokenBought = tokenBought . mul ( 15 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( state == State . Stage4 ) { tokenBought = tokenBought . mul ( 125 ) ; tokenBought = tokenBought . div ( 100 ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; creator . transfer ( msg . value ) ; emit LogBeneficiaryPaid ( creator ) ; emit LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; emit LogContributorsPayout ( msg . sender , tokenBought ) ; checkIfFundingCompleteOrExpired ( ) ; }
function approveCompletedMilestone ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . reviewer ) || ( milestone . status != MilestoneStatus . Completed ) ) throw ; authorizePayment ( _idMilestone ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
function closeMotion ( uint motionID ) external { require ( ( motionConfirming ( motionID ) && ! motionPasses ( motionID ) ) || motionWaiting ( motionID ) ) ; _closeMotion ( motionID ) ; }
function optIn ( ) public returns ( bool ) { delete userOptOutVersion [ msg . sender ] ; return true ; }
function isExistingHolding ( address who ) public view returns ( bool ) { Holding memory h = heldTokens [ who ] ; return ( h . quantity != 0 || h . releaseDate != 0 ) ; }
function suicide ( ) onlyOwner returns ( bool ) { selfdestruct ( owner ) ; return true ; }
function unpause ( ) external timedStateChange ( address ( 0 ) , 0 , true ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { changeState ( IcoState . ACTIVE ) ; checkTime ( ) ; }
function clear ( address _follower , address _oracle , int256 _profitAmount ) public returns ( uint256 amountToTrader , uint256 amountToFollower ) { require ( msg . sender == InvestContractAddress ) ; require ( _oracle == oracle [ _follower ] ) ; uint256 balance = investBalances [ _follower ] ; delete investBalances [ _follower ] ; delete startTime [ _follower ] ; delete oracle [ _follower ] ; if ( _profitAmount <= 0 ) { amountToTrader = 0 ; } else { amountToTrader = uint256 ( _profitAmount ) * rewardPercentage / 100 ; if ( amountToTrader > balance ) { amountToTrader = balance ; } } amountToFollower = balance - amountToTrader ; }
function changeEscapeCaller ( address _newEscapeHatchCaller ) onlyEscapeHatchCallerOrOwner { escapeHatchCaller = _newEscapeHatchCaller ; }
function buy ( ) payable public { uint amount = msg . value / buyPrice ; _transfer ( address ( this ) , msg . sender , amount ) ; }
function ( ) payable public { require ( getState ( ) != State . Success ) ; require ( getState ( ) != State . Failure ) ; require ( msg . value != 0 ) ; if ( getState ( ) == State . PrivateFunding ) { require ( msg . value >= minPrivateContribution ) ; } else if ( getState ( ) == State . PreFunding ) { require ( msg . value >= minPreContribution && msg . value < maxContributionAmount ) ; } else if ( getState ( ) == State . Funding ) { require ( msg . value >= minContributionAmount && msg . value < maxContributionAmount ) ; } uint256 createdTokens = safeMul ( msg . value , tokensPerEther ) ; uint256 brokerBonus = 0 ; uint256 earlyBonus = safeDiv ( safeMul ( createdTokens , _getEarlyBonus ( ) ) , hundredPercent ) ; createdTokens = safeAdd ( createdTokens , earlyBonus ) ; if ( getState ( ) == State . PrivateFunding ) { require ( safeAdd ( tokensSold , createdTokens ) <= tokenPrivateMax ) ; } else { require ( safeAdd ( tokensSold , createdTokens ) <= tokenCreationMax ) ; } tokensSold = safeAdd ( tokensSold , createdTokens ) ; collectedETH = safeAdd ( collectedETH , msg . value ) ; if ( referrals [ msg . sender ] != 0x0 ) { brokerBonus = safeDiv ( safeMul ( createdTokens , referralBonus ) , hundredPercent ) ; bonus [ referrals [ msg . sender ] ] = safeAdd ( bonus [ referrals [ msg . sender ] ] , brokerBonus ) ; emit ReferralBonus ( msg . sender , referrals [ msg . sender ] , brokerBonus ) ; } funders [ msg . sender ] = safeAdd ( funders [ msg . sender ] , msg . value ) ; investors [ msg . sender ] = safeAdd ( investors [ msg . sender ] , createdTokens ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , createdTokens ) ; emit FundTransfer ( msg . sender , msg . value , createdTokens , block . number ) ; emit Transfer ( 0 , msg . sender , createdTokens ) ; }
function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 6000000000 ; }
function burnRestTokens ( ) afterDeadline { require ( ! restTokensBurned ) ; abioToken . burnMyBalance ( ) ; restTokensBurned = true ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( isSenderApprovedFor ( _tokenId ) ) ; require ( ownerOf ( _tokenId ) == _from ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , _to , _tokenId ) ; }
function changeCommissionRecipient ( address newCommissionRecipient ) public only_exchange_operator { COMMISSION_RECIPIENT = newCommissionRecipient ; }
function claimTokens ( ) respectTimeFrame isValidState payable public { require ( msg . value >= minimumPayment ) ; uint256 tokenExchangeRate = calculateTokenExchangeRate ( ) ; require ( tokenExchangeRate > 0 ) ; uint256 tokens = msg . value . mul ( tokenExchangeRate ) . div ( 100 ) ; require ( tokens <= maximumTokensToBuy ( ) ) ; uint256 checkedSupply = assignedSupply . add ( tokens ) ; require ( checkedSupply . add ( escFund ) <= totalSupply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; purchases [ msg . sender ] = purchases [ msg . sender ] . add ( tokens ) ; assignedSupply = checkedSupply ; ClaimESC ( msg . sender , tokens ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }
function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( frozen [ msg . sender ] == false ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function transferOwnershipToGiver ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { uint64 toPledge = findOrCreatePledge ( idReceiver , new uint64 [ ] ( 0 ) , 0 , 0 , 0 , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }
function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F02 ) , _newCOO , _nonce ) ) ; }
function transfer ( address _to , uint256 _value ) { require ( msg . sender == owner || now > 1509467422 ) ; _transfer ( msg . sender , _to , _value ) ; }
function beneficiaryWithdraw ( ) external { require ( msg . sender == _beneficiary ) ; require ( _ended ) ; require ( ! _beneficiaryWithdrawn ) ; uint total = 0 ; for ( uint i = 0 ; i < 100 ; ++ i ) { total = total . add ( _topBids [ i ] . bid ) ; } _beneficiaryWithdrawn = true ; _beneficiary . transfer ( total ) ; }
function addTagByModuleType ( uint8 _moduleType , bytes32 [ ] _tag ) public onlyOwner { for ( uint8 i = 0 ; i < _tag . length ; i ++ ) { availableTags [ _moduleType ] . push ( _tag [ i ] ) ; } }
function transferToMany ( address [ ] _addrs , uint [ ] _amounts ) public returns ( bool ) ;
function metaTransferHash ( address _to , uint256 _amount , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , "metaTransfer" , _to , _amount , _nonce , _reward ) ) ; }
function multiBuy ( address [ ] sellers , uint256 lastQuantity ) public payable { for ( uint i = 0 ; i < sellers . length ; i ++ ) { TradeOrder memory to = orderBook [ sellers [ i ] ] ; if ( i == sellers . length - 1 ) { buy ( sellers [ i ] , lastQuantity , to . price ) ; } else { buy ( sellers [ i ] , to . quantity , to . price ) ; } } }
function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( "pVoteQuorum" ) , get ( "pCommitStageLen" ) , get ( "pRevealStageLen" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( "pDispensationPct" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; var ( commitEndDate , revealEndDate , ) = voting . pollMap ( pollID ) ; emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate , msg . sender ) ; return pollID ; }
function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool ) { require ( allowed [ _from ] [ _to ] >= _amount ) ; uint256 _fee = validator . validateAndGetTransferFee ( owner , _from , _to , _amount ) ; store . transfer ( _from , _to , _amount ) ; if ( _fee > 0 ) store . transfer ( _from , store . getSettingAddress ( "feeReturnAddress" ) , _fee ) ; allowed [ _from ] [ _to ] -= _amount ; Transfer ( _from , _to , _amount ) ; return true ; }
function supplyICOContract ( address _addr ) public onlyOwner { require ( _addr != 0x0 ) ; ICOAddress = _addr ; ICO = ABIO_ICO ( _addr ) ; if ( ! fundingGoalReached && weiRaised + ICO . weiRaised ( ) >= fundingGoal ) { goalReached ( ) ; } finalDeadline = ICO . deadline ( ) ; }
function handleAbovePlannedWhitelistedContribution ( uint256 allowedContribution , uint256 plannedContribution , uint256 refundAmount ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( plannedContribution ) ; AllowedContributionCheck ( plannedContribution , AllowedContributionState . AboveWhitelisted ) ; return ( plannedContribution , msg . value . sub ( plannedContribution ) ) ; }
function calculateExcessBalance ( ) internal whenNotPaused returns ( uint256 ) { uint256 amountPaid = msg . value ; uint256 differenceWei = 0 ; uint256 exceedingBalance = 0 ; if ( tokensRaised >= 37.5e24 ) { uint256 addedTokens = tokensRaised . add ( amountPaid . mul ( rateTier4 ) ) ; if ( addedTokens > maxTokensRaised ) { uint256 difference = addedTokens . sub ( maxTokensRaised ) ; differenceWei = difference . div ( rateTier4 ) ; amountPaid = amountPaid . sub ( differenceWei ) ; } } uint256 addedBalance = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; if ( addedBalance <= maxPurchase ) { crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } else { exceedingBalance = addedBalance . sub ( maxPurchase ) ; amountPaid = msg . value . sub ( exceedingBalance ) ; crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } if ( differenceWei > 0 ) msg . sender . transfer ( differenceWei ) ; if ( exceedingBalance > 0 ) { msg . sender . transfer ( exceedingBalance ) ; } return amountPaid ; }
function onTransfer ( address _from , address _to , uint256 _amount ) public returns ( bool ) ;
function adjustInvestorCount ( InvestorDataStorage storage _investorData , address _from , address _to , uint256 _value , uint256 _balanceTo , uint256 _balanceFrom ) public { if ( ( _value == 0 ) || ( _from == _to ) ) { return ; } if ( ( _balanceTo == 0 ) && ( _to != address ( 0 ) ) ) { _investorData . investorCount = ( _investorData . investorCount ) . add ( 1 ) ; } if ( _value == _balanceFrom ) { _investorData . investorCount = ( _investorData . investorCount ) . sub ( 1 ) ; } if ( ! _investorData . investorListed [ _to ] && ( _to != address ( 0 ) ) ) { _investorData . investors . push ( _to ) ; _investorData . investorListed [ _to ] = true ; } }
function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . transferOwnership ( msg . sender ) ; emit CreatedToken ( _tokenSymbol , address ( newToken ) ) ; return newToken ; }
function approveProposal ( uint _proposalId ) public onlyAdmins { require ( proposals . length > _proposalId ) ; require ( ! proposals [ _proposalId ] . denied ) ; Proposal storage p = proposals [ _proposalId ] ; require ( ! p . approved ) ; p . token = tokenFactory . createCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( "NectarProposal-" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( "NP-" , _proposalId ) , true ) ; p . approved = true ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; emit Approved ( _proposalId ) ; }
function _addToken ( address _to , uint256 _tokenId ) private { uint256 newTokenIndex = ownedTokens [ _to ] . length ; ownedTokens [ _to ] . push ( _tokenId ) ; require ( newTokenIndex == uint256 ( uint32 ( newTokenIndex ) ) , "overflow" ) ; tokenOwnerAndTokensIndex [ _tokenId ] = AddressAndTokenIndex ( { owner : _to , tokenIndex : uint32 ( newTokenIndex ) } ) ; }
function changeAllowAllTransfers ( bool _allowAllTransfers ) public withPerm ( FLAGS ) { allowAllTransfers = _allowAllTransfers ; emit LogAllowAllTransfers ( _allowAllTransfers ) ; }
function getNumberOfAssets ( ) public view returns ( uint ) { return numberOfAssets ; }
function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; require ( block . number <= _validUntil ) ; bytes32 hashedTx = transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce , _validUntil ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
function isNotaryAdditionValid ( address order , address notary , uint256 responsesPercentage , uint256 notarizationFee , string notarizationTermsOfService , bytes notarySignature ) public pure returns ( bool ) { require ( order != address ( 0 ) ) ; require ( notary != address ( 0 ) ) ; bytes32 hash = keccak256 ( abi . encodePacked ( order , responsesPercentage , notarizationFee , notarizationTermsOfService ) ) ; return isSignedBy ( hash , notary , notarySignature ) ; }
function withdraw ( address _recipient ) public returns ( bool ) { require ( shares [ _recipient ] > 0 ) ; require ( totalAtWithdrawal [ _recipient ] < totalReceived ) ; uint left = totalReceived . sub ( totalAtWithdrawal [ _recipient ] ) ; uint share = left . mul ( shares [ _recipient ] ) . div ( 10000 ) ; totalAtWithdrawal [ _recipient ] = totalReceived ; ERC20 ( holdingToken ) . transfer ( _recipient , share ) ; return true ; }
function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
function approve ( address _to , uint256 _deedId ) external payable ;
function transferFrom ( address from , address to , uint tokens ) public tokenTradingMustBeLive ( from ) returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; Transfer ( from , to , tokens ) ; return true ; }
function freezeAmount ( address target , uint256 _value ) onlyOwner public { require ( _value > 0 ) ; frozenAmount [ target ] = _value ; emit FrozenAmt ( target , _value ) ; }
function destroy ( ) public onlyOwner { selfdestruct ( owners [ 0 ] ) ; }
function link ( address _newAddress ) internal returns ( bool ) { currentApplicationEntityAddress = _newAddress ; currentApp = ApplicationEntityABI ( currentApplicationEntityAddress ) ; if ( ! currentApp . initialize ( ) ) { revert ( ) ; } EventGatewayNewAddress ( currentApplicationEntityAddress ) ; return true ; }
function createSingleSeedAuction ( uint8 _teamId , uint8 _posId , uint256 _attributes , uint256 _playerOverrideId , uint256 _mlbPlayerId , uint256 _startPrice , uint256 _endPrice , uint256 _saleDuration ) public onlyGameManager whenNotPaused { require ( nonFungibleContract != address ( 0 ) ) ; require ( _teamId != 0 ) ; uint256 nftId = nonFungibleContract . createSeedCollectible ( _teamId , _posId , _attributes , address ( this ) , 0 , _playerOverrideId , _mlbPlayerId ) ; uint256 startPrice = 0 ; uint256 endPrice = 0 ; uint256 duration = 0 ; if ( _startPrice == 0 ) { startPrice = _computeNextSeedPrice ( 0 , _teamId ) ; } else { startPrice = _startPrice ; } if ( _endPrice != 0 ) { endPrice = _endPrice ; } else { endPrice = 0 ; } if ( _saleDuration == 0 ) { duration = SALES_DURATION ; } else { duration = _saleDuration ; } _createSale ( nftId , startPrice , endPrice , duration , address ( this ) ) ; }
function addChunk5ToWhiteList ( ) external onlyOwner { require ( ! chunk5IsAdded ) ; addToWhitelist ( 0x439f5420d4eD1DE8c982100Fcf808C5FcEeC1bFa , 1.25 ether ) ; addToWhitelist ( 0xfd5D41Dad5218C312d693a8b6b1128889cFFec43 , 1.25 ether ) ; addToWhitelist ( 0x1FBB99bf7E6e8920Fac8Ab371cEB5A90e0801656 , 1.5 ether ) ; addToWhitelist ( 0x6d767fE3e87b6Ffb762cd46138aaaB48a6788d06 , 1.5 ether ) ; addToWhitelist ( 0x9C299486fc9b5B1bA1dbE2d6D93E3580f9A64995 , 1.5 ether ) ; addToWhitelist ( 0x009e511c89e033142bdd1f34f7cad0f3e188696d , 2 ether ) ; addToWhitelist ( 0x25929fF98a1e8D7d1c14674bD883A24C26FB1df4 , 2 ether ) ; addToWhitelist ( 0x2a54850a5166d2fCC805B78A1D436b96e4477e09 , 2 ether ) ; addToWhitelist ( 0x3D212E369e08fB9D5585a35449595df044cdD7a4 , 2 ether ) ; addToWhitelist ( 0x417EcaE932D3bAE2d93a2af6dA91441d46532A7C , 2 ether ) ; addToWhitelist ( 0x53070A3A5faF50280563ea4fB4b5e6AcA53B7221 , 2 ether ) ; addToWhitelist ( 0x67314b5CdFD52A1D5c4794C02C5b3b2cc4bdc21B , 2 ether ) ; addToWhitelist ( 0x67fb2006dd8990de950d1eb41f07ff7f929c3bca , 2 ether ) ; addToWhitelist ( 0x76b3a5aad6aD161680F9e7C9dd09bA9626135765 , 2 ether ) ; addToWhitelist ( 0x77446d3Df1216B1e8Ea1913203B05F5cb182B112 , 2 ether ) ; addToWhitelist ( 0x788b7433ddf168544b2adae3c6aa416d3f6fa112 , 2 ether ) ; addToWhitelist ( 0x790310b3f668019056a8b811ced6e2a0af533660 , 2 ether ) ; addToWhitelist ( 0x7dD1b95E76F7893002E4FB9a533628994b703479 , 2 ether ) ; addToWhitelist ( 0x821578e6212651CAa996184404787ccC09C71014 , 2 ether ) ; addToWhitelist ( 0x8b91B39Ef4ae08bEacC128d3C2e19140AbD0245F , 2 ether ) ; addToWhitelist ( 0x8f566cdE6724DEA78756B8C252055e6eA7D3d7a4 , 2 ether ) ; addToWhitelist ( 0x90f7f982c2Ab40534e5E3bE449967B716ef04BB1 , 2 ether ) ; addToWhitelist ( 0x91FDae97a5a3Ba806fA3Eb8B3cd3F0bEE6431b77 , 2 ether ) ; addToWhitelist ( 0x99cf8060BaFca88C04Aa2Eace46CA880bE75F166 , 2 ether ) ; addToWhitelist ( 0xa099638b5CFE746C0B3DD1a3998051c2Ac1F3dC8 , 2 ether ) ; addToWhitelist ( 0xb9a2ACF30FB774881371F249928Cb48Ccc184bAC , 2 ether ) ; addToWhitelist ( 0xC301Fc1acCF9ab89Fa68Fd240dCDaa0Bd9a3658F , 2 ether ) ; addToWhitelist ( 0xc4f5bFad8Ec83Bcd4AB3b3a27266f08b4517f59B , 2 ether ) ; addToWhitelist ( 0xd1EA23d6713ca22cc1f2e10dc6FD8B1DfB65b563 , 2 ether ) ; addToWhitelist ( 0xd4F2ad288874653F09e3Cc522C1106692E30394C , 2 ether ) ; addToWhitelist ( 0xddF81dabe498118df262b1b907492b391211321e , 2 ether ) ; addToWhitelist ( 0xE4fBc54c0a08a5d0CD1EEBC8bf0Ea48fdBFd7E0c , 2 ether ) ; addToWhitelist ( 0xf42F3c005B1723782FC25E5771748a6A1fff5e03 , 2 ether ) ; addToWhitelist ( 0xff7ef21aC94961a3C9F71a3deFFfe2f58e102E1f , 2 ether ) ; addToWhitelist ( 0xa27A60769B426b1eEA3be951DF29D352B48ec5Da , 2.5 ether ) ; addToWhitelist ( 0xba334469f45f8e0ca1d61fa036fece3b4d5ec0f7 , 2.5 ether ) ; addToWhitelist ( 0xdE47f3C16cDb757027F61D07a44c881d2D32B161 , 2.5 ether ) ; addToWhitelist ( 0xfCD47A33207eD5a03390330Fd6EcFF2DFf8F5a2b , 2.5 ether ) ; addToWhitelist ( 0x27fcA80168B7eDC487B22F0F334BA922d1e26E2D , 3 ether ) ; addToWhitelist ( 0x36bd14eaf211d65164e1e0a2eab5c98b4b734875 , 3 ether ) ; addToWhitelist ( 0x3D1a96c1fE8D1281537c5A8C93A89215DF254d3f , 3 ether ) ; addToWhitelist ( 0x40ED9F03BFfFA1cB30E36910907cd55ac27Be05d , 3 ether ) ; addToWhitelist ( 0x5Da227c19913F4deEB64A6E7fE41B30B230161D2 , 3 ether ) ; addToWhitelist ( 0x7e443aA16aC53419CFd8056Bcc30b674864Ac55F , 3 ether ) ; addToWhitelist ( 0x80F30bAc95966922f1E8c66c0fD088959a00f15f , 3 ether ) ; addToWhitelist ( 0x8862004b5a7C21B8F771AF3213b79bD9b81f9DA0 , 3 ether ) ; addToWhitelist ( 0x904063eF93eEEd9584f6B0131F9FD047d7c3C28d , 3 ether ) ; addToWhitelist ( 0xa14aC1A9B3D52aBD0652C5Aca346099A6eb16b54 , 3 ether ) ; addToWhitelist ( 0xA2Ef14F0d1ae84609Cd104feB91EAeD4B39C4852 , 3 ether ) ; addToWhitelist ( 0xA4D1905ceF480Fb9089578F88D3C128cf386ebd5 , 3 ether ) ; addToWhitelist ( 0xa5D5404864E9eA3104ec6721CA08E563964Ae536 , 3 ether ) ; addToWhitelist ( 0xB3ADF1FB9c488DBB42378876ff4Fc2be4c1B4365 , 3 ether ) ; chunk5IsAdded = true ; }
function computeIssuanceData ( uint preBalance , IssuanceData preIssuance ) internal view returns ( IssuanceData ) { uint currentBalanceSum = preIssuance . currentBalanceSum ; uint lastAverageBalance = preIssuance . lastAverageBalance ; uint lastModified = preIssuance . lastModified ; if ( lastModified < feePeriodStartTime ) { if ( lastModified < lastFeePeriodStartTime ) { lastAverageBalance = preBalance ; } else { uint timeUpToRollover = feePeriodStartTime - lastModified ; uint lastFeePeriodDuration = feePeriodStartTime - lastFeePeriodStartTime ; uint lastBalanceSum = safeAdd ( currentBalanceSum , safeMul ( preBalance , timeUpToRollover ) ) ; lastAverageBalance = lastBalanceSum / lastFeePeriodDuration ; } currentBalanceSum = safeMul ( preBalance , now - feePeriodStartTime ) ; } else { currentBalanceSum = safeAdd ( currentBalanceSum , safeMul ( preBalance , now - lastModified ) ) ; } return IssuanceData ( currentBalanceSum , lastAverageBalance , now ) ; }
function setRate ( uint256 _rate ) public onlyOwner { require ( _rate > 0 ) ; rate = _rate ; emit NewRate ( rate ) ; }
function isPolicyExist ( bytes32 _policyHash ) public view returns ( bool ) { return policyId2Index [ _policyHash ] != 0 ; }
function darknodeOwner ( address darknodeID ) external view onlyOwner returns ( address ) { return darknodeRegistry [ darknodeID ] . owner ; }
function offer_energy ( uint32 aday , uint32 aprice , uint64 aenergy , uint64 atimestamp ) onlyRegisteredProducers external { require ( aenergy >= kWh ) ; uint idx = bidsIndex [ msg . sender ] [ aday ] ; if ( ( bids . length > idx ) && ( bids [ idx ] . producer == msg . sender ) && ( bids [ idx ] . day == aday ) ) { require ( atimestamp > bids [ idx ] . timestamp ) ; emit BidRevoked ( bids [ idx ] . producer , bids [ idx ] . day , bids [ idx ] . price , bids [ idx ] . energy ) ; } idx = bids . length ; bidsIndex [ msg . sender ] [ aday ] = idx ; bids . push ( Bid ( { producer : msg . sender , day : aday , price : aprice , energy : aenergy , timestamp : atimestamp } ) ) ; emit BidMade ( bids [ idx ] . producer , bids [ idx ] . day , bids [ idx ] . price , bids [ idx ] . energy ) ; }
function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 30636000000 ; }
function register ( string _nameString ) external payable isHuman ( ) { bytes32 _name = _nameString . nameFilter ( ) ; address _agent = msg . sender ; require ( msg . value >= 10000000000000000 ) ; require ( agentxName_ [ _name ] == address ( 0 ) ) ; if ( ! player [ _agent ] . isAgent ) { agents += 1 ; player [ _agent ] . isAgent = true ; player [ _agent ] . id = agents ; player [ _agent ] . level = 1 ; agentxID_ [ agents ] = _agent ; } player [ _agent ] . name = _name ; agentxName_ [ _name ] = _agent ; if ( ! community . send ( msg . value ) ) { pot = pot . add ( msg . value ) ; } }
function _setPaused ( bool requestedState ) public returns ( uint ) { if ( msg . sender != anchorAdmin ) { return failOracle ( 0 , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PAUSED_OWNER_CHECK ) ; } paused = requestedState ; emit SetPaused ( requestedState ) ; return uint ( Error . NO_ERROR ) ; }
function transferFrom ( address from , address to , uint256 amount ) public returns ( bool success ) ;
function retire ( address _to ) onlyOwner whenPaused public { require ( now > lastDepositTime . add ( commissionExpiryTime ) ) ; _to . transfer ( this . balance ) ; retired = true ; }
function halvingStartBlock ( uint256 _halving ) public constant notBeforeGenesis returns ( uint256 ) { return _halving . mul ( subsidyHalvingInterval ) ; }
function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) { return false ; } allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
function getNumberOfAssetPacks ( ) public view returns ( uint ) { return numberOfAssetPacks ; }
function withdrawMarginPreSignedHashing ( address _investContract , address _from , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x7701c52d ) , _investContract , _from , _value , _fee , _nonce , _validUntil ) ) ; }
function transferOwnership ( address _newOwner ) public onlyOwner { require ( _newOwner != address ( 0 ) , "newOwner cannot be zero address" ) ; owner = _newOwner ; }
function getTimeBonus ( uint256 value ) view public returns ( uint256 ) { uint256 maxBonus = value . mul ( baseRate ) . mul ( maxTimeBonusPercent ) . div ( PERCENT_DIVIDER ) ; return maxBonus . mul ( endTimestamp - now ) . div ( endTimestamp - startTimestamp ) ; }
function whitelistedSenderAddresses ( ) external view returns ( address [ NUMBER_OF_CHOICES ] ) { return whitelistedSenderAdresses ; }
function changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) public withPerm ( CHANGE_PERMISSION ) returns ( bool ) { require ( delegateDetails [ _delegate ] != bytes32 ( 0 ) , "Delegate details not set" ) ; perms [ _module ] [ _delegate ] [ _perm ] = _valid ; emit LogChangePermission ( _delegate , _module , _perm , _valid , now ) ; return true ; }
function addTokens ( bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses whenNotPaused external { rntTokenVault . addTokensToAccount ( _uuid , _tokensCount ) ; rntToken . transferFrom ( owner , address ( rntTokenVault ) , _tokensCount ) ; }
function buyOilFactory ( ) public payable returns ( uint256 ) { return buyFactory ( FactoryType . Oil ) ; }
function purgeUpgrade ( ) public onlyAssetOwner returns ( bool ) { if ( pendingVersion == 0x0 ) { return false ; } delete pendingVersion ; delete pendingVersionTimestamp ; return true ; }
function getPermissionParam ( address _entity , address _app , bytes32 _role , uint _index ) external view returns ( uint8 , uint8 , uint240 ) { Param storage param = permissionParams [ permissions [ permissionHash ( _entity , _app , _role ) ] ] [ _index ] ; return ( param . id , param . op , param . value ) ; }
function getAddress ( string _nameKey ) view public returns ( address ) { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; require ( storedAddresses [ key ] != address ( 0 ) , "Invalid address key" ) ; return storedAddresses [ key ] ; }
function airdropMinting ( address [ ] _to_list , uint [ ] _values ) public { require ( msg . sender == owner ) ; require ( _to_list . length == _values . length ) ; for ( uint i = 0 ; i < _to_list . length ; i ++ ) { mintToken ( _to_list [ i ] , _values [ i ] ) ; } }
function newRepo ( string _name , address _dev ) public auth ( CREATE_REPO_ROLE ) returns ( Repo ) { return _newRepo ( _name , _dev ) ; }
function balanceOf ( address account ) public view returns ( uint balance ) { return lib . getTokenBalance ( lib . getTokenSymbol ( address ( this ) ) , account ) ; }
function ( ) external payable { assembly { let _poaTokenMaster := sload ( poaTokenMaster_slot ) calldatacopy ( 0x0 , 0x0 , calldatasize ) let result := delegatecall ( gas , _poaTokenMaster , 0x0 , calldatasize , 0x0 , 0 ) if iszero ( result ) { revert ( 0 , 0 ) } returndatacopy ( 0x0 , 0x0 , returndatasize ) return ( 0x0 , returndatasize ) } }
function transferMultiple ( address _to , uint256 [ ] _deedIds ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( _owns ( msg . sender , _deedId ) ) ; _transfer ( msg . sender , _to , _deedId ) ; } }
function frozenTransferFrom ( address _from , address _to , uint256 _value , uint thawTS , bool isKYCRequired ) external validAddress ( _to ) validUnixTS ( thawTS ) payloadSizeIs ( 5 * 32 ) privilegedAllowed checkTransferInvariant ( _from , _to ) returns ( bool ) { require ( isSale ( msg . sender ) && isSale ( _to ) ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; subFrozen ( _from , _value , thawTS , isKYCRequired ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }
function burnFrom ( address _from , uint256 _value ) public onlyOwner returns ( bool success ) { bool bAccountFrozen = frozenAccount ( _from ) ; if ( bAccountFrozen ) { freezeAccount ( _from , false ) ; } _transfer ( _from , _owner , _value ) ; if ( bAccountFrozen ) { freezeAccount ( _from , bAccountFrozen ) ; } burn ( _value ) ; return true ; }
function getValidity ( Campaign storage _campaign ) internal view returns ( bool _valid ) { return _campaign . valid ; }
function deleteDelegate ( address _delegate ) external ;
function forceTransfer ( Data storage self , string currency , address from , address to , uint amount , bytes data ) internal returns ( bool success ) { require ( address ( to ) != 0x0 , "Error: `to` address must not be null." ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , from ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , to ) ) ) ; require ( self . Storage . setUint ( id_a , self . Storage . getUint ( id_a ) . sub ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; require ( self . Storage . setUint ( id_b , self . Storage . getUint ( id_b ) . add ( amount ) ) , "Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract." ) ; emit Transfer ( currency , from , to , amount , data ) ; return true ; }
function claimTokens ( address _token ) public onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }
function renounceOwnership ( ) public onlyAdmin { burnAdmin = address ( 0 ) ; }
function getAllDelegatesWithPerm ( address _module , bytes32 _perm ) external view returns ( address [ ] ) ;
function lockCurrentApp ( ) internal { if ( ! currentApp . lock ( ) ) { revert ( ) ; } }
function withdrawOperationFees ( uint32 [ ] _dates ) external { require ( msg . sender == owner ) ; uint256 withdrawAmount = 0 ; uint256 datesLength = _dates . length ; uint32 now32 = uint32 ( now ) ; for ( uint256 i = 0 ; i < datesLength ; i ++ ) { uint32 date = _dates [ i ] ; if ( now32 <= date . add ( WITHDRAW_BUFFER ) ) { continue ; } if ( dateToContestStatus [ date ] . operationFeeWithdrawn ) { continue ; } dateToContestStatus [ date ] . operationFeeWithdrawn = true ; withdrawAmount = withdrawAmount . add ( calculateOperationFee ( date ) ) ; } if ( withdrawAmount > 0 ) { msg . sender . transfer ( withdrawAmount ) ; } LogOperationFeeWithdraw ( msg . sender , withdrawAmount ) ; }
function proxyPayment ( address ) public payable returns ( bool ) { require ( msg . sender == address ( token ) , ERROR_PROXY_PAYMENT_WRONG_SENDER ) ; return false ; }
function buy ( address _to ) public validAddress ( _to ) isNotFinalized payable { uint256 _amount = msg . value ; assert ( _amount > 0 ) ; uint256 _tokens = _amount . mul ( rate ) ; assert ( totalSupply . add ( _tokens ) <= totalMaxBuy ) ; totalSupply = totalSupply . add ( _tokens ) ; totalETH = totalETH . add ( _amount ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _tokens ) ; wallet . transfer ( _amount ) ; Buy ( msg . sender , _to , rate , _tokens ) ; Transfer ( this , _to , _tokens ) ; FundTransfer ( msg . sender , _amount , true ) ; }
function approve ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; require ( warriors [ _tokenId ] . action == IDLE ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
function updateContract ( string _contractName , address _newAddress ) external onlyContractOwner ( "ContractManager" , msg . sender ) { bytes memory contractNameBytes = bytes ( _contractName ) ; require ( contractNameBytes . length != 0 ) ; require ( contracts [ _contractName ] != address ( 0 ) ) ; require ( _newAddress != address ( 0 ) ) ; address oldAddress = contracts [ _contractName ] ; contracts [ _contractName ] = _newAddress ; emit ContractUpdated ( oldAddress , _newAddress , _contractName ) ; }
function refund ( ) ;
function destroy ( ) public onlyOwner { selfdestruct ( owner ) ; }
function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { if ( ! oasis . isActive ( data . offerId ) ) { return false ; } address pay_gem ; address buy_gem ; ( , pay_gem , , buy_gem ) = oasis . getOffer ( data . offerId ) ; bool isBuyOrPayWeth = pay_gem == address ( weth ) || buy_gem == address ( weth ) ; if ( ! isBuyOrPayWeth ) { return false ; } return true ; }
function removeNFToken ( address _from , uint256 _tokenId ) internal { require ( nft [ _tokenId ] . owner == _from , "from address must be owner of tokenId" ) ; uint256 [ ] storage tokenList = ownerToTokenList [ _from ] ; assert ( tokenList . length > 0 ) ; for ( uint256 i = 0 ; i < tokenList . length ; i ++ ) { if ( tokenList [ i ] == _tokenId ) { tokenList [ i ] = tokenList [ tokenList . length - 1 ] ; delete tokenList [ tokenList . length - 1 ] ; tokenList . length -- ; break ; } } delete nft [ _tokenId ] . owner ; }
function revealCeiling ( uint256 _limit , uint256 _slopeFactor , uint256 _collectMinimum , bool _last , bytes32 _salt ) public { require ( ! allRevealed ) ; require ( ceilings [ revealedCeilings ] . hash == calculateHash ( _limit , _slopeFactor , _collectMinimum , _last , _salt ) ) ; require ( _limit != 0 && _slopeFactor != 0 && _collectMinimum != 0 ) ; if ( revealedCeilings > 0 ) { require ( _limit >= ceilings [ revealedCeilings . sub ( 1 ) ] . limit ) ; } ceilings [ revealedCeilings ] . limit = _limit ; ceilings [ revealedCeilings ] . slopeFactor = _slopeFactor ; ceilings [ revealedCeilings ] . collectMinimum = _collectMinimum ; revealedCeilings = revealedCeilings . add ( 1 ) ; if ( _last ) { allRevealed = true ; } }
function transferForeignToken ( address _tokenAddress , address _recipient , uint256 _amount ) public onlyAdmin nonZeroAddress ( _recipient ) returns ( bool ) { require ( _tokenAddress != address ( this ) , "token address can't be this contract" ) ; ERC20Interface eI = ERC20Interface ( _tokenAddress ) ; require ( eI . transfer ( _recipient , _amount ) , "token transfer failed" ) ; emit ForeignTokenTransfer ( msg . sender , _recipient , _amount ) ; return true ; }
function claim ( ) public notBeforeGenesis notPaused isMiner ( msg . sender ) returns ( uint256 ) { return claimHalvingsSubsidies ( claimableHalvings ( ) ) ; }
function getMinInvestment ( ) public constant returns ( uint ) { return 10 finney ; }
function updateWhitelistedContribution ( uint256 plannedContribution ) private { whitelistedPlannedContributions = whitelistedPlannedContributions . sub ( plannedContribution ) ; WhitelistedCounterUpdated ( whitelistedPlannedContributions , plannedContribution ) ; }
function sendEther ( address to , uint value ) external validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) requiresState ( State . SUCCEEDED ) { require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }
function initialize ( VEN _ven , address _ethVault , address _venVault , uint256 _channelsLimit , uint _startTime , uint _endTime , uint _earlyStageLasts ) onlyOwner { require ( stage ( ) == Stage . Created ) ; require ( _ven . owner ( ) == address ( this ) ) ; require ( address ( _ethVault ) != 0 ) ; require ( address ( _venVault ) != 0 ) ; require ( _startTime > blockTime ( ) ) ; require ( _startTime . add ( _earlyStageLasts ) < _endTime ) ; ven = _ven ; ethVault = _ethVault ; venVault = _venVault ; channelsLimit = _channelsLimit ; officialLimit = publicSupply . sub ( _channelsLimit ) ; startTime = _startTime ; endTime = _endTime ; earlyStageLasts = _earlyStageLasts ; ven . mint ( venVault , reservedForTeam . add ( reservedForOperations ) , false ) ; ven . mint ( venVault , privateSupply . add ( commercialPlan ) , true ) ; initialized = true ; onInitialized ( ) ; }
function getPackage ( uint idPackage ) constant public returns ( string name , DAppNodePackageStatus status ) { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; name = c . name ; status = c . status ; }
function performSellOrder ( OrderData data , uint256 amountToSpend ) public whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { uint256 maxPayGem ; address payGem ; uint256 maxBuyGem ; address buyGem ; ( maxPayGem , payGem , maxBuyGem , buyGem ) = oasis . getOffer ( data . offerId ) ; if ( payGem != address ( weth ) ) { errorReporter . revertTx ( "payGem != address(weth)" ) ; } approveAddress ( address ( oasis ) , address ( buyGem ) ) ; uint256 amountToBuy = SafeMath . div ( SafeMath . mul ( amountToSpend , maxPayGem ) , maxBuyGem ) ; if ( amountToBuy == 0 ) { ERC20 ( buyGem ) . transfer ( totlePrimary , amountToSpend ) ; return ( 0 , 0 ) ; } if ( ! oasis . buy ( data . offerId , amountToBuy ) ) { errorReporter . revertTx ( "Oasis buy failed" ) ; } uint256 newMaxPayGem ; uint256 newMaxBuyGem ; ( newMaxPayGem , , newMaxBuyGem , ) = oasis . getOffer ( data . offerId ) ; amountReceivedFromOrder = maxPayGem - newMaxPayGem ; amountSpentOnOrder = maxBuyGem - newMaxBuyGem ; if ( amountSpentOnOrder < amountToSpend ) { ERC20 ( buyGem ) . transfer ( totlePrimary , amountToSpend - amountSpentOnOrder ) ; } weth . withdraw ( amountReceivedFromOrder ) ; totlePrimary . transfer ( amountReceivedFromOrder ) ; }
function setFreezeOracle ( bool _frozen ) onlyOwner public { freezeOracle = _frozen ; }
function buy ( ) public payable nonReentrant returns ( uint ) { address investor = msg . sender ; uint256 payment = msg . value ; require ( payment >= c_MinInvestment ) ; require ( now < 1507766400 ) ; uint stq = payment . mul ( c_STQperETH ) ; m_token . mint ( investor , stq ) ; m_funds . transfer ( payment ) ; FundTransfer ( investor , payment , true ) ; return stq ; }
function addManualBlocking ( address _from , address _to , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , "Invalid from address" ) ; require ( _to != address ( 0 ) , "Invalid to address" ) ; require ( _expiryTime > now , "Invalid expiry time" ) ; require ( manualBlockings [ _from ] [ _to ] . expiryTime == 0 , "Blocking already exists" ) ; manualBlockings [ _from ] [ _to ] = ManualBlocking ( _expiryTime ) ; emit AddManualBlocking ( _from , _to , _expiryTime , msg . sender ) ; }
function currentMigrationTarget ( ) public constant returns ( IMigrationTarget ) { return _migration ; }
function transferWithSignature ( address _to , uint256 _amount , uint256 _fee , bytes _data , uint256 _nonce , bytes _sig ) public returns ( bool ) { doSendWithSignature ( _to , _amount , _fee , _data , _nonce , _sig , false ) ; return true ; }
function tokenURI ( uint256 _tokenId ) external view returns ( string ) ;
function forceTransfer ( address _from , address _to , uint256 _value , bytes _data , bytes _log ) public onlyController { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; bool verified = _updateTransfer ( _from , _to , _value , _data ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit ForceTransfer ( msg . sender , _from , _to , _value , verified , _log ) ; emit Transfer ( _from , _to , _value ) ; }
function setFeeReceiver ( address _feeReceiver ) public onlyOwner { require ( _feeReceiver != address ( 0 ) , "zero address is not allowed" ) ; feeReceiver = _feeReceiver ; }
function isAllowedAsset ( address asset , string currency ) public view returns ( bool allowed ) { if ( isTokenXContract ( asset , currency ) ) { return true ; } else { bytes32 id = keccak256 ( abi . encodePacked ( 'allowed.stable.asset' , asset , currency ) ) ; return lib . Storage . getBool ( id ) ; } }
function symbol ( ) external view returns ( string ) { return _symbol ; }
function onTransfer ( address _from , address _to , uint _amount ) returns ( bool ) ;
function hasError ( ) public onlyManager whenPaused { error = true ; }
function ( ) external payable { }
function distributeBonuses ( uint _amount ) public onlyDistributionSource returns ( uint ) { ERC20Interface _bonusToken = ERC20Interface ( bonusToken ) ; if ( _bonusToken . allowance ( msg . sender , address ( this ) ) < _amount ) { return _emitError ( PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE ) ; } if ( ! _bonusToken . transferFrom ( msg . sender , wallet , _amount ) ) { return _emitError ( PROFITEROLE_ERROR_TRANSFER_ERROR ) ; } if ( firstDepositDate == 0 ) { firstDepositDate = now ; } uint _lastDepositDate = lastDepositDate ; if ( _lastDepositDate != 0 ) { distributionDeposits [ _lastDepositDate ] . nextDepositDate = now ; } lastDepositDate = now ; distributionDeposits [ now ] = Deposit ( _amount , _amount , 0 ) ; Treasury ( treasury ) . addDistributionPeriod ( ) ; DepositPendingAdded ( _amount , msg . sender , now ) ; return OK ; }
function ownerOf ( uint _tokenId ) external view returns ( address owner ) { owner = rabbitToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
function collectionOf ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( uint256 ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , "PixelCon does not exist" ) ; return pixelcons [ tokenLookup [ _tokenId ] . tokenIndex ] . collectionIndex ; }
function performRebalance ( Trade [ ] trades ) public payable whenNotPaused { TradeFlag [ ] memory tradeFlags = initialiseTradeFlags ( trades ) ; staticChecks ( trades , tradeFlags ) ; transferTokens ( trades , tradeFlags ) ; uint256 etherBalance = msg . value ; for ( uint256 i ; i < trades . length ; i ++ ) { Trade memory thisTrade = trades [ i ] ; TradeFlag memory thisTradeFlag = tradeFlags [ i ] ; CurrentAmounts memory amounts = CurrentAmounts ( { amountSpentOnTrade : 0 , amountReceivedFromTrade : 0 , amountLeftToSpendOnTrade : thisTrade . isSell ? thisTrade . tokenAmount : calculateMaxEtherSpend ( thisTrade , etherBalance ) } ) ; performTrade ( thisTrade , thisTradeFlag , amounts ) ; if ( amounts . amountReceivedFromTrade == 0 && thisTrade . optionalTrade ) { continue ; } if ( ! checkIfTradeAmountsAcceptable ( thisTrade , amounts . amountSpentOnTrade , amounts . amountReceivedFromTrade ) ) { errorReporter . revertTx ( "Amounts spent/received in trade not acceptable" ) ; } if ( thisTrade . isSell ) { etherBalance = SafeMath . add ( etherBalance , amounts . amountReceivedFromTrade ) ; } else { etherBalance = SafeMath . sub ( etherBalance , amounts . amountSpentOnTrade ) ; } transferTokensToUser ( thisTrade . tokenAddress , thisTrade . isSell ? amounts . amountLeftToSpendOnTrade : amounts . amountReceivedFromTrade ) ; } if ( etherBalance > 0 ) { msg . sender . transfer ( etherBalance ) ; } }
function transferTickerOwnership ( address _newOwner , string _ticker ) external ;
function requestFreeDistribution ( ) external { require ( getState ( ) == State . Success ) ; assert ( investors [ msg . sender ] > 0 ) ; uint256 unSoldTokens = safeSub ( tokenCreationMax , tokensSold ) ; require ( unSoldTokens > 0 ) ; uint256 freeTokens = safeDiv ( safeMul ( unSoldTokens , investors [ msg . sender ] ) , tokensSold ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , freeTokens ) ; investors [ msg . sender ] = 0 ; emit FreeDistribution ( msg . sender , freeTokens , block . number ) ; emit Transfer ( 0 , msg . sender , freeTokens ) ; }
function setState ( State _state ) external onlyOwner { state = _state ; }
function tokenURI ( uint256 _tokenId ) public view returns ( string ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , "PixelCon does not exist" ) ; PixelCon storage pixelcon = pixelcons [ lookupData . tokenIndex ] ; bytes8 pixelconName = pixelconNames [ lookupData . tokenIndex ] ; string memory finalTokenURI = tokenURITemplate ; finalTokenURI = StringUtils . replace ( finalTokenURI , "<tokenId>" , StringUtils . toHexString ( _tokenId , 32 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , "<tokenIndex>" , StringUtils . toHexString ( uint256 ( lookupData . tokenIndex ) , 8 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , "<name>" , StringUtils . toHexString ( uint256 ( pixelconName ) , 8 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , "<owner>" , StringUtils . toHexString ( uint256 ( lookupData . owner ) , 20 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , "<creator>" , StringUtils . toHexString ( uint256 ( pixelcon . creator ) , 20 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , "<dateCreated>" , StringUtils . toHexString ( uint256 ( pixelcon . dateCreated ) , 8 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , "<collectionIndex>" , StringUtils . toHexString ( uint256 ( pixelcon . collectionIndex ) , 8 ) ) ; return finalTokenURI ; }
function unpause ( ) public onlyCOO whenPaused { paused = false ; }
function changeOwnership ( address _newOwner ) onlyOwner { require ( _newOwner != 0x0 ) ; address oldOwner = owner ; owner = _newOwner ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }
function ownerOf ( uint256 _tokenId ) external view returns ( address ) { return _ownerOf ( _tokenId ) ; }
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( frozen [ _from ] == false ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
function pauseGame ( uint256 _gameID , bool _paused ) external isActivated ( _gameID ) isOngoing ( _gameID ) onlyDevOrOwner ( ) { game_ [ _gameID ] . paused = _paused ; emit onGamePaused ( _gameID , _paused , now ) ; }
function transferToContract ( address to , uint256 value , bytes data ) public returns ( bool _success ) { require ( to != address ( 0 ) ) ; require ( value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; ContractReceiver ( to ) . tokenFallback ( msg . sender , value , data ) ; Transfer ( msg . sender , to , value , data ) ; return true ; }
function acceptOwnership ( ) public { require ( msg . sender == newOwner , "You have not been selected as the new owner." ) ; emit OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; newOwner = address ( 0 ) ; }
function createDividendWithExclusions ( uint256 _maturity , uint256 _expiry , address [ ] _excluded , bytes32 _name ) public payable withPerm ( MANAGE ) { uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , checkpointId , _excluded , _name ) ; }
function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }
function startWineryProductByRegulator ( string _harvestTrackID , string _producerOffChainIdentity , string _wineryOperationTrackIDs , string _wineryOffChainIdentity , int _productIndex ) external regulatorsOnly returns ( bool success ) { require ( _productIndex >= 0 ) ; address producer = getAddress ( _producerOffChainIdentity ) ; bytes32 harvestMappingID = keccak256 ( _harvestTrackID , producer ) ; address winery = getAddress ( _wineryOffChainIdentity ) ; bytes32 wineryOperationMappingID = keccak256 ( _wineryOperationTrackIDs , winery ) ; harvests [ harvestMappingID ] . child = IndexElem ( wineryOperationMappingID , _productIndex ) ; wineries [ wineryOperationMappingID ] [ uint ( _productIndex ) ] . parentList . push ( IndexElem ( harvestMappingID , - 1 ) ) ; return true ; }
function createLoan ( Oracle _oracleContract , address _borrower , bytes32 _currency , uint256 _amount , uint256 _interestRate , uint256 _interestRatePunitory , uint256 _duesIn , uint256 _cancelableAt , uint256 _expirationRequest , string _metadata ) public returns ( uint256 ) { require ( ! deprecated ) ; require ( _cancelableAt <= _duesIn ) ; require ( _oracleContract != address ( 0 ) || _currency == 0x0 ) ; require ( _borrower != address ( 0 ) ) ; require ( _amount != 0 ) ; require ( _interestRatePunitory != 0 ) ; require ( _interestRate != 0 ) ; require ( _expirationRequest > block . timestamp ) ; var loan = Loan ( Status . initial , _oracleContract , _borrower , 0x0 , msg . sender , 0x0 , _amount , 0 , 0 , 0 , 0 , _interestRate , _interestRatePunitory , 0 , _duesIn , _currency , _cancelableAt , 0 , 0x0 , _expirationRequest , _metadata ) ; uint index = loans . push ( loan ) - 1 ; CreatedLoan ( index , _borrower , msg . sender ) ; bytes32 identifier = getIdentifier ( index ) ; require ( identifierToIndex [ identifier ] == 0 ) ; identifierToIndex [ identifier ] = index ; if ( msg . sender == _borrower ) { approveLoan ( index ) ; } return index ; }
function isRefunded ( address _darknodeID ) public view returns ( bool ) { uint256 registeredAt = store . darknodeRegisteredAt ( _darknodeID ) ; uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return registeredAt == 0 && deregisteredAt == 0 ; }
function cashBack ( address _to ) public { uint usd ; ( usd , , ) = ICOStatus ( ) ; require ( now > crowdsaleEndTime && usd < softcapUSD ) ; require ( ethSent [ _to ] > 0 ) ; delete ethSent [ _to ] ; _to . transfer ( ethSent [ _to ] ) ; }
function unregisterUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; uint _memberIndex = memberAddress2index [ _user ] ; if ( _memberIndex == 0 || address2member [ _user ] . groupsCount != 0 ) { return _emitError ( USER_MANAGER_INVALID_INVOCATION ) ; } uint _membersCount = membersCount ; delete memberAddress2index [ _user ] ; if ( _memberIndex != _membersCount ) { address _lastUser = index2memberAddress [ _membersCount ] ; index2memberAddress [ _memberIndex ] = _lastUser ; memberAddress2index [ _lastUser ] = _memberIndex ; } delete address2member [ _user ] ; delete index2memberAddress [ _membersCount ] ; delete memberAddress2index [ _user ] ; membersCount = _membersCount . sub ( 1 ) ; UserDeleted ( _user ) ; return OK ; }
function claimWinnings ( bytes32 question_id , bytes32 [ ] history_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) stateFinalized ( question_id ) public { require ( history_hashes . length > 0 ) ; address payee = question_claims [ question_id ] . payee ; uint256 last_bond = question_claims [ question_id ] . last_bond ; uint256 queued_funds = question_claims [ question_id ] . queued_funds ; bytes32 last_history_hash = questions [ question_id ] . history_hash ; bytes32 best_answer = questions [ question_id ] . best_answer ; uint256 i ; for ( i = 0 ; i < history_hashes . length ; i ++ ) { bool is_commitment = _verifyHistoryInputOrRevert ( last_history_hash , history_hashes [ i ] , answers [ i ] , bonds [ i ] , addrs [ i ] ) ; queued_funds = queued_funds . add ( last_bond ) ; ( queued_funds , payee ) = _processHistoryItem ( question_id , best_answer , queued_funds , payee , addrs [ i ] , bonds [ i ] , answers [ i ] , is_commitment ) ; last_bond = bonds [ i ] ; last_history_hash = history_hashes [ i ] ; } if ( last_history_hash != NULL_HASH ) { if ( payee != NULL_ADDRESS ) { _payPayee ( question_id , payee , queued_funds ) ; queued_funds = 0 ; } question_claims [ question_id ] . payee = payee ; question_claims [ question_id ] . last_bond = last_bond ; question_claims [ question_id ] . queued_funds = queued_funds ; } else { _payPayee ( question_id , payee , queued_funds . add ( last_bond ) ) ; delete question_claims [ question_id ] ; } questions [ question_id ] . history_hash = last_history_hash ; }
function pay ( address who ) external payable { require ( who != 0x0 ) ; require ( msg . value == fee ) ; require ( s_paid [ who ] . length < 10 ) ; s_paid [ who ] . push ( msg . sender ) ; Paid ( who , msg . sender ) ; treasury . transfer ( msg . value ) ; }
function incTotalSupply ( uint _val ) external onlyOwner returns ( bool ) { totalSupply = totalSupply . add ( _val ) ; return true ; }
function batchEscrowToTeamContract ( address _owner , uint32 [ ] _tokenIds ) public whenNotPaused { require ( teamContract != address ( 0 ) ) ; require ( msg . sender == address ( teamContract ) ) ; for ( uint32 i = 0 ; i < _tokenIds . length ; i ++ ) { uint32 _tokenId = _tokenIds [ i ] ; require ( _owns ( _owner , _tokenId ) ) ; _transfer ( _owner , teamContract , _tokenId ) ; } }
function setLocked ( address _target , uint _timeStamp ) public onlyAdmin returns ( bool ) { locked [ _target ] = _timeStamp ; emit LockStatus ( _target , _timeStamp ) ; return true ; }
function getCurrencyAddress ( ) external view returns ( address ) { return address ( 0 ) ; }
function remainingCap ( ) private returns ( uint256 ) { return preSaleCap ; }
function revoke ( address who , address origin ) payable external only_delegate { require ( msg . value == fee ) ; bool found ; for ( uint i = 0 ; i < s_paid [ who ] . length ; i ++ ) { if ( s_paid [ who ] [ i ] != origin ) { continue ; } found = true ; uint last = s_paid [ who ] . length - 1 ; s_paid [ who ] [ i ] = s_paid [ who ] [ last ] ; delete s_paid [ who ] [ last ] ; s_paid [ who ] . length -= 1 ; break ; } require ( found ) ; origin . transfer ( msg . value ) ; }
function approve ( address _spender , uint _value ) public returns ( bool success ) ;
function cumulativeInverse ( uint256 neumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public pure returns ( uint256 euroUlps ) { require ( maxEurUlps >= minEurUlps ) ; require ( cumulative ( minEurUlps ) <= neumarkUlps ) ; require ( cumulative ( maxEurUlps ) >= neumarkUlps ) ; uint256 min = minEurUlps ; uint256 max = maxEurUlps ; while ( max > min ) { uint256 mid = ( max + min ) / 2 ; uint256 val = cumulative ( mid ) ; if ( val < neumarkUlps ) { min = mid + 1 ; } else { max = mid ; } } return max ; }
function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( isTransferWhitelistOnly ) { require ( isUserAllowedToTransfer ( msg . sender ) ) ; } return super . transfer ( _to , _value ) ; }
function getOwners ( ) public constant returns ( address [ ] ) { address [ ] memory result = new address [ ] ( m_numOwners ) ; for ( uint i = 0 ; i < m_numOwners ; i ++ ) result [ i ] = getOwner ( i ) ; return result ; }
function setPrivateSaleTokensSold ( uint tokens ) public onlyOwner { privateSalesTokensSold = tokens ; tokensAvailableForSale = totalTokensAvailableForSale - preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 - privateSalesTokensSold ; }
function killTo ( address _to , bytes32 _hash ) external nonZeroAddress ( _to ) pollApproved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) { selfdestruct ( _to ) ; }
function setFundingFueled ( ) external ;
function getModulesByType ( uint8 _type ) external view returns ( address [ ] ) ;
function mint ( address _investor , uint256 _amount ) public onlyModule ( STO_KEY , true ) checkGranularity ( _amount ) isMintingAllowed ( ) returns ( bool success ) { require ( _investor != address ( 0 ) , "Investor address should not be 0x" ) ; adjustInvestorCount ( address ( 0 ) , _investor , _amount ) ; require ( verifyTransfer ( address ( 0 ) , _investor , _amount ) , "Transfer is not valid" ) ; adjustBalanceCheckpoints ( _investor ) ; adjustTotalSupplyCheckpoints ( ) ; totalSupply_ = totalSupply_ . add ( _amount ) ; balances [ _investor ] = balances [ _investor ] . add ( _amount ) ; emit Minted ( _investor , _amount ) ; emit Transfer ( address ( 0 ) , _investor , _amount ) ; return true ; }
function moveToNextCeiling ( ) public onlyOwner { currentIndex = currentIndex . add ( 1 ) ; }
function totalSupplyAt ( uint256 _checkpointId ) public view returns ( uint256 ) { return getValueAt ( checkpointTotalSupply , _checkpointId , totalSupply ( ) ) ; }
function collectForREQBurning ( uint256 _amount ) internal { requestBurnerContract . transfer ( _amount ) ; }
function fillAndValidate ( OrderData data ) internal { exchange . fill . value ( msg . value ) ( data . makerAddress , data . makerAmount , data . makerToken , data . takerAddress , data . takerAmount , data . takerToken , data . expiration , data . nonce , data . v , data . r , data . s ) ; bytes32 orderHash ; ( orderHash , ) = getOrderHash ( data ) ; if ( ! exchange . fills ( orderHash ) ) { errorReporter . revertTx ( "AirSwap: Order failed validation after execution" ) ; } }
function newChannel ( address client , address receiver , uint close_timeout , uint settle_timeout , uint audit_timeout , address auditor ) returns ( address ) { address new_channel_address = new ChannelContract ( this , msg . sender , client , receiver , close_timeout , settle_timeout , audit_timeout , auditor ) ; ChannelNew ( new_channel_address , msg . sender , client , receiver , close_timeout , settle_timeout , audit_timeout ) ; return new_channel_address ; }
function calculateGrantClaim ( address _recipient ) public view returns ( uint16 , uint128 ) { Grant storage tokenGrant = tokenGrants [ _recipient ] ; uint elapsedTime = sub ( now , tokenGrant . startTime ) ; uint elapsedMonths = elapsedTime / SECONDS_PER_MONTH ; if ( elapsedMonths < tokenGrant . vestingCliff ) { return ( 0 , 0 ) ; } if ( elapsedMonths >= tokenGrant . vestingDuration ) { uint128 remainingGrant = tokenGrant . amount - tokenGrant . totalClaimed ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint16 monthsVested = uint16 ( sub ( elapsedMonths , tokenGrant . monthsClaimed ) ) ; uint amountVestedPerMonth = tokenGrant . amount / tokenGrant . vestingDuration ; uint128 amountVested = uint128 ( mul ( monthsVested , amountVestedPerMonth ) ) ; return ( monthsVested , amountVested ) ; } }
function setMetaData ( string _metadata ) onlyOwner public { metadata = _metadata ; }
function getInstructions ( ) public view returns ( string ) { return "Create a dividend which will be paid out to token holders proportional to their balances at the point the dividend is created" ; }
function proxyClaimTokens ( address receiverAddress ) public atStage ( Stages . AuctionEnded ) returns ( bool ) { require ( now > endTime + tokenClaimWaitingPeriod ) ; require ( receiverAddress != 0x0 ) ; if ( bids [ receiverAddress ] == 0 ) { return false ; } uint num = ( tokenMultiplier * bids [ receiverAddress ] ) / finalPrice ; uint auctionTokensBalance = token . balanceOf ( address ( this ) ) ; if ( num > auctionTokensBalance ) { num = auctionTokensBalance ; } fundsClaimed += bids [ receiverAddress ] ; bids [ receiverAddress ] = 0 ; require ( token . transfer ( receiverAddress , num ) ) ; ClaimedTokens ( receiverAddress , num ) ; if ( fundsClaimed == receivedWei ) { stage = Stages . TokensDistributed ; TokensDistributed ( ) ; } assert ( token . balanceOf ( receiverAddress ) >= num ) ; assert ( bids [ receiverAddress ] == 0 ) ; return true ; }
function destroyTokens ( uint256 _tokens , address _destination ) onlyOwner { shp . destroyTokens ( _destination , _tokens ) ; }
function cancelSellOffer ( uint32 _canvasId ) external { cancelSellOfferInternal ( _canvasId , true ) ; }
function orderTrader ( bytes32 _orderID ) external view returns ( address ) ;
function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
function cancelPayment ( uint _idPayment ) onlyOwner external { require ( _idPayment < authorizedPayments . length ) ; Payment storage p = authorizedPayments [ _idPayment ] ; require ( ! p . canceled ) ; require ( ! p . paid ) ; p . canceled = true ; emit PaymentCanceled ( _idPayment ) ; }
function balanceOf ( address _owner ) public view validAddress ( _owner ) returns ( uint256 ) { return ownedTokens [ _owner ] . length ; }
function initialize ( ) public onlyOwner { require ( initialized == false ) ; require ( tokensAvailable ( ) == CAP ) ; initialized = true ; }
function transferOwnership ( address _newOwner ) public onlyOwner { balances [ _newOwner ] = safeAdd ( balances [ owner ] , balances [ _newOwner ] ) ; balances [ owner ] = 0 ; Ownable . transferOwnership ( _newOwner ) ; }
function finalizeCrowdsale ( ) onlyOwner public { finalized = true ; assert ( token . finishMinting ( ) ) ; token . setTransferEnabled ( true ) ; token . transferOwnership ( owner ) ; claimEther ( ) ; }
function transfer ( address _to , uint256 _amount ) onlyPayloadSize ( 2 * 32 ) public returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }
function changeFactorySubscriptionFee ( uint256 _newSubscriptionCost ) public onlyOwner { emit ChangeFactorySubscriptionFee ( monthlySubscriptionCost , _newSubscriptionCost , address ( this ) ) ; monthlySubscriptionCost = _newSubscriptionCost ; }
function approveToken ( Token _tokenContract , address _spender , uint256 _value ) onlyOwner external { _tokenContract . approve ( _spender , _value ) ; }
function updateTransfer ( uint64 nonce , uint256 transferred_amount , bytes32 locksroot , bytes32 extra_hash , bytes signature ) { data . updateTransfer ( nonce , transferred_amount , locksroot , extra_hash , signature ) ; TransferUpdated ( msg . sender , block . number ) ; }
function getPledgeLevel ( Pledge p ) internal returns ( uint ) { if ( p . oldPledge == 0 ) return 0 ; Pledge storage oldN = findPledge ( p . oldPledge ) ; return getPledgeLevel ( oldN ) + 1 ; }
function ids ( address _service ) public constant returns ( uint256 serviceId ) { }
function transfer ( address _to , uint _value ) returns ( bool success ) { }
function acceptOwnership ( ) { require ( msg . sender == newOwnerCandidate ) ; address oldOwner = owner ; owner = newOwnerCandidate ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }
function checkMerkleProof ( bytes32 _merkleRoot , bytes32 [ ] _proof , uint _position , bytes32 _leaf ) public pure returns ( bool ) { bytes32 _computedHash = _leaf ; uint _checkedPosition = _position ; for ( uint i = 0 ; i < _proof . length ; i += 1 ) { bytes32 _proofElement = _proof [ i ] ; if ( _checkedPosition % 2 == 0 ) { _computedHash = keccak256 ( abi . encodePacked ( _computedHash , _proofElement ) ) ; } else { _computedHash = keccak256 ( abi . encodePacked ( _proofElement , _computedHash ) ) ; } _checkedPosition /= 2 ; } return _computedHash == _merkleRoot ; }
function extractTokens ( address _token , address _claimer ) onlyOwner public { if ( _token == 0x0 ) { _claimer . transfer ( this . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( _claimer , balance ) ; ExtractedTokens ( _token , _claimer , balance ) ; }
function giveChamp ( address _to , uint256 _champId ) external onlyOwnerOfChamp ( _champId ) { transferChamp ( msg . sender , _to , _champId ) ; }
function getCollection ( uint256 _collectionId ) public view returns ( uint256 id , string collectionName , uint256 [ ] editionIds ) { Collection storage collection = allCollections [ _collectionId - 1 ] ; id = collection . id ; collectionName = collection . name ; editionIds = collection . editionIds ; }
function distribute ( ) internal { if ( operatingAddress . balance < opThreshold ) { if ( address ( this ) . balance < ( opThreshold - operatingAddress . balance ) ) { operatingAddress . transfer ( address ( this ) . balance ) ; } else { operatingAddress . transfer ( opThreshold - operatingAddress . balance ) ; coldStorage . transfer ( address ( this ) . balance ) ; } } else { coldStorage . transfer ( address ( this ) . balance ) ; } }
function checkCompletedCrowdsale ( ) public whenNotPaused { if ( ! isEnded ) { if ( hasEnded ( ) && ! goalReached ( ) ) { vault . enableRefunds ( ) ; isRefunding = true ; isEnded = true ; Finalized ( ) ; } else if ( hasEnded ( ) && goalReached ( ) ) { isEnded = true ; if ( tokensRaised < maxTokensRaised ) { token . burnTokens ( ) ; } Finalized ( ) ; } } }
function launchContract ( ) public onlyOwner { require ( ! contractLaunched ) ; tokenIsFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; emit LaunchContract ( msg . sender , true ) ; }
function addInvestor ( address _wallet ) external isManager returns ( bool ) { if ( walletsICO [ _wallet ] ) { error ( 'addInvestor: this wallet has been previously granted as ICO investor' ) ; return false ; } walletsICO [ _wallet ] = true ; emit AddInvestor ( _wallet , timestamp ( ) ) ; return true ; }
function setPrices ( uint256 newBuyPrice , uint256 newSellPrice ) onlyOwner public { buyPrice = newBuyPrice ; sellPrice = newSellPrice ; }
function transferFrom ( address _from , address _to , uint256 _tokenId ) external canTransfer ( _tokenId ) validNFToken ( _tokenId ) { address tokenOwner = idToOwner [ _tokenId ] ; require ( tokenOwner == _from ) ; require ( _to != address ( 0 ) ) ; _transfer ( _to , _tokenId ) ; }
function mDestroyTokens ( address owner , uint256 amount ) internal { require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= amount ) ; uint256 previousBalanceFrom = balanceOf ( owner ) ; require ( previousBalanceFrom >= amount ) ; uint256 newTotalSupply = curTotalSupply - amount ; uint256 newBalanceFrom = previousBalanceFrom - amount ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceFrom ) ; Transfer ( owner , 0 , amount ) ; }
function accept ( bytes32 _requestId ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , "caller should be the currency contract of the request" ) ; r . state = State . Accepted ; emit Accepted ( _requestId ) ; }
function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
function contributeToTokenGroup ( uint256 _tokenId ) external payable whenNotForking whenNotPaused { address userAdd = msg . sender ; require ( _addressNotNull ( userAdd ) ) ; var group = tokenIndexToGroup [ _tokenId ] ; var contributor = userAddressToContributor [ userAdd ] ; if ( ! group . exists ) { group . exists = true ; activeGroups += 1 ; } else { require ( group . addressToContributorArrIndex [ userAdd ] == 0 ) ; } if ( ! contributor . exists ) { userAddressToContributor [ userAdd ] . exists = true ; } else { require ( contributor . tokenIdToGroupArrIndex [ _tokenId ] == 0 ) ; } require ( group . purchasePrice == 0 ) ; uint256 tokenPrice = linkedContract . priceOf ( _tokenId ) ; require ( msg . value >= uint256 ( SafeMath . div ( tokenPrice , MAX_CONTRIBUTION_SLOTS ) ) ) ; uint256 cIndex = tokenIndexToGroup [ _tokenId ] . contributorArr . push ( userAdd ) ; tokenIndexToGroup [ _tokenId ] . addressToContributorArrIndex [ userAdd ] = cIndex ; uint256 amountNeeded = SafeMath . sub ( tokenPrice , group . contributedBalance ) ; if ( msg . value > amountNeeded ) { tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] = amountNeeded ; tokenIndexToGroup [ _tokenId ] . contributedBalance += amountNeeded ; userAddressToContributor [ userAdd ] . withdrawableBalance += SafeMath . sub ( msg . value , amountNeeded ) ; FundsDeposited ( userAdd , SafeMath . sub ( msg . value , amountNeeded ) ) ; } else { tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] = msg . value ; tokenIndexToGroup [ _tokenId ] . contributedBalance += msg . value ; } uint256 gIndex = userAddressToContributor [ userAdd ] . groupArr . push ( _tokenId ) ; userAddressToContributor [ userAdd ] . tokenIdToGroupArrIndex [ _tokenId ] = gIndex ; JoinGroup ( _tokenId , userAdd , tokenIndexToGroup [ _tokenId ] . contributedBalance , tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] ) ; if ( tokenIndexToGroup [ _tokenId ] . contributedBalance >= tokenPrice ) { _purchase ( _tokenId , tokenPrice ) ; } }
function releaseEQUITokens ( bytes32 hash , uint8 v , bytes32 r , bytes32 s ) public whenNotPaused { require ( balances [ msg . sender ] > 0 ) ; uint256 amount = 0 ; for ( uint8 i = 0 ; i < ledger [ msg . sender ] . releaseTime . length ; i ++ ) { uint256 time = ledger [ msg . sender ] . releaseTime [ i ] ; if ( now >= time && ledger [ msg . sender ] . balance [ time ] > 0 ) { amount = ledger [ msg . sender ] . balance [ time ] ; ledger [ msg . sender ] . balance [ time ] = 0 ; continue ; } } if ( amount <= 0 || balances [ msg . sender ] < amount ) { revert ( ) ; } if ( isKYCRequired ) { require ( isWhitelistedAddress ( hash , v , r , s ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; if ( ! token . transferFrom ( tokenWallet , msg . sender , amount ) ) { revert ( ) ; } emit TokenReleased ( msg . sender , amount ) ; } else { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; if ( ! token . transferFrom ( tokenWallet , msg . sender , amount ) ) { revert ( ) ; } emit TokenReleased ( msg . sender , amount ) ; } }
function withdraw ( uint256 _value ) private pure { _value = _value ; }
function updateFromRegistry ( ) external onlyOwner { address _polymathRegistry = getAddress ( Encoder . getKey ( "polymathRegistry" ) ) ; set ( Encoder . getKey ( "securityTokenRegistry" ) , IPolymathRegistry ( _polymathRegistry ) . getAddress ( "SecurityTokenRegistry" ) ) ; set ( Encoder . getKey ( "featureRegistry" ) , IPolymathRegistry ( _polymathRegistry ) . getAddress ( "FeatureRegistry" ) ) ; set ( Encoder . getKey ( "polyToken" ) , IPolymathRegistry ( _polymathRegistry ) . getAddress ( "PolyToken" ) ) ; }
function setConfirmationPeriod ( uint duration ) external onlyOwner { require ( MIN_CONFIRMATION_PERIOD <= duration && duration <= MAX_CONFIRMATION_PERIOD ) ; confirmationPeriod = duration ; }
function getTitle ( ) public view returns ( string ) { return "Count Transfer Manager" ; }
function destroyTokens ( address _user , uint _amount ) onlyOwner public returns ( bool ) { require ( balanceOf [ _user ] >= _amount ) ; balanceOf [ owner ] += _amount ; balanceOf [ _user ] -= _amount ; Transfer ( _user , 0 , _amount ) ; Burn ( _user , _amount ) ; return true ; }
function setPercentages ( uint8 _Fee1 , uint8 _Fee2 , uint8 _Fees , uint8 _1Step , uint8 _2Step , uint8 _Steps ) public onlyCLevel { percentageFee1Step = _Fee1 ; percentageFee2Step = _Fee2 ; percentageFeeSteps = _Fees ; percentage1Step = _1Step ; percentage2Step = _2Step ; percentageSteps = _Steps ; }
function collectResources ( ) public onlyExistingUser { uint256 index = addressToUser [ msg . sender ] ; User storage user = users [ index ] ; uint256 [ ] storage factoriesIds = userToFactories [ addressToUser [ msg . sender ] ] ; for ( uint256 i = 0 ; i < factoriesIds . length ; i ++ ) { _collectResource ( factories [ factoriesIds [ i ] ] , user ) ; } }
function moveAllTokensToAddress ( bytes16 _uuid , address _address ) onlyAllowedAddresses onlyRegisteredAccount ( _uuid ) whenNotPaused public returns ( bool ) { uint256 accountBalance = balances [ _uuid ] ; removeTokensFromAccount ( _uuid , accountBalance ) ; rntToken . transfer ( _address , accountBalance ) ; tokens = tokens . sub ( accountBalance ) ; tokenTransfers [ _address ] = _uuid ; return true ; }
function getCertificationDocument ( address _student , uint _docIndx ) public view onlyOwner returns ( bytes , bytes32 , bytes32 ) { return ( ( studentCertifications [ _student ] . documents [ _docIndx ] ) . ipfsHash , ( studentCertifications [ _student ] . documents [ _docIndx ] ) . contentHash , ( studentCertifications [ _student ] . documents [ _docIndx ] ) . transcriptHash ) ; }
function cancelVote ( uint motionID ) external { require ( ! motionConfirming ( motionID ) ) ; Vote senderVote = vote [ msg . sender ] [ motionID ] ; require ( senderVote != Vote . Abstention ) ; if ( motionVoting ( motionID ) ) { if ( senderVote == Vote . Yea ) { votesFor [ motionID ] = safeSub ( votesFor [ motionID ] , voteWeight [ msg . sender ] [ motionID ] ) ; } else { votesAgainst [ motionID ] = safeSub ( votesAgainst [ motionID ] , voteWeight [ msg . sender ] [ motionID ] ) ; } emit VoteCancelled ( msg . sender , motionID ) ; } delete voteWeight [ msg . sender ] [ motionID ] ; delete vote [ msg . sender ] [ motionID ] ; }
function claimPresaleTokens ( ) whenNotPaused external { require ( isPresaleFinalized == true ) ; uint256 senderEther = deposit . receivedEtherFrom ( msg . sender ) ; uint256 multiplier = 10 ** 18 ; senderEther = senderEther . mul ( multiplier ) ; uint256 tokenWei = pricingStrategy . oneTokenInWei ( ) ; uint256 tokensAmount = senderEther . div ( tokenWei ) ; require ( tokensAmount > 0 ) ; token . transferFrom ( owner , msg . sender , tokensAmount ) ; PresaleTokensClaimed ( tokensAmount ) ; }
function closed ( ) constant returns ( uint ) { return data . closed ; }
function unlock ( ) external { if ( getTime ( ) < unlockedAtTime ) revert ( ) ; if ( ! decentBetToken . transfer ( decentBetMultisig , decentBetToken . balanceOf ( this ) ) ) revert ( ) ; }
function registerToken ( address tokenAddress , uint256 index ) external onlyAdmin { require ( index > 1 ) ; require ( tokenAddress2Id [ tokenAddress ] == 0 ) ; require ( tokenId2Address [ index ] == 0 ) ; tokenAddress2Id [ tokenAddress ] = index ; tokenId2Address [ index ] = tokenAddress ; }
function nominateNewOwner ( address _owner ) public onlyOwner { nominatedOwner = _owner ; emit OwnerNominated ( _owner ) ; }
function isBuyOrder ( bytes32 _orderID ) private view returns ( bool ) { uint64 tokens = orderDetails [ _orderID ] . tokens ; uint32 firstToken = uint32 ( tokens >> 32 ) ; uint32 secondaryToken = uint32 ( tokens ) ; return ( firstToken < secondaryToken ) ; }
function distributeCustomSaleProceeds ( uint256 _tokenId , uint256 _amount ) external onlyCOO { var group = tokenIndexToGroup [ _tokenId ] ; require ( group . exists ) ; require ( group . purchasePrice > 0 ) ; require ( _amount > 0 ) ; _distributeProceeds ( _tokenId , _amount ) ; }
function ( ) public payable notPaused { proxyPayment ( msg . sender ) ; }
function checkIn ( ) external { uint32 nowDate = getDate ( uint32 ( now ) ) ; require ( userDateToStatus [ msg . sender ] [ nowDate ] == UserEntryStatus . REGISTERED ) ; userDateToStatus [ msg . sender ] [ nowDate ] = UserEntryStatus . COMPLETED ; dateToContestStatus [ nowDate ] . numCompleted += 1 ; }
function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( multisigs [ msigId ] . owner == msg . sender ) ; require ( multisigs [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= min ( now + 1 days , multisigs [ msigId ] . unlockTime ) ) ; require ( amount > 0 ) ; require ( ! isAntecedentHashedSecret [ hashedSecret ] ) ; isAntecedentHashedSecret [ hashedSecret ] = true ; multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , add ( amount , fee ) ) ; swapId = keccak256 ( msigId , msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; emit AtomicSwapInitialised ( swapId ) ; AtomicSwap storage swap = atomicswaps [ swapId ] ; swap . msigId = msigId ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; FEE_RECIPIENT . transfer ( fee ) ; }
function claimHodlReward ( ) public { claimHodlRewardFor ( msg . sender ) ; }
function withdraw ( ) isOwner public returns ( bool ) { uint _amount = address ( this ) . balance ; emit Withdrawal ( owner , _amount ) ; owner . transfer ( _amount ) ; balance -= _amount ; return true ; }
function proxyPayment ( address _owner ) payable { doPayment ( _owner ) ; }
function burn ( uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . subtract ( _value ) ; totalSupply_ = totalSupply_ . subtract ( _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }
function claimableHalvingsOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { Miner miner = miners [ _miner ] ; uint256 halving = currentHalving ( ) ; uint256 minerHalving = blockHalving ( miner . block ) ; if ( minerHalving == halving ) { return 0 ; } else { if ( currentBlock ( ) % subsidyHalvingInterval < miner . block % subsidyHalvingInterval ) { return halving . sub ( minerHalving ) . sub ( 1 ) ; } else { return halving . sub ( minerHalving ) ; } } }
function addScriptExecutor ( IEVMScriptExecutor _executor ) external auth ( REGISTRY_ADD_EXECUTOR_ROLE ) returns ( uint256 id ) { uint256 executorId = executorsNextIndex ++ ; executors [ executorId ] = ExecutorEntry ( _executor , true ) ; emit EnableExecutor ( executorId , _executor ) ; return executorId ; }
function addPlayerToBoard ( bytes32 boardHash , bytes32 playerName ) public payable returns ( bool ) { require ( msg . value >= playerCost ) ; Board storage g = boards [ boardHash ] ; split ( g . boardOwner , msg . value ) ; uint newPlayerID = g . numPlayers ++ ; g . players [ newPlayerID ] = Player ( playerName , msg . sender , 0 , 0 , 1 ) ; return true ; }
function disableTransfers ( ) external onlyOwner { require ( transfersEnabled ) ; transfersEnabled = false ; DisableTransfers ( msg . sender ) ; }
function ( ) external payable { require ( isContract ( controller ) ) ; require ( ITokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) == true ) ; }
function getPrices ( ) public view returns ( uint256 , uint256 ) { return ( sellPrice_ , buyPrice_ ) ; }
function STARTMETADOLLAR ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1000 * 1 ; preICOprice = 1000 * 1 ; ICOprice = 1000 * 1 ; sellPrice = 1000 ; commission1 = 1000 ; commission2 = 950 ; updatePrices ( ) ; }
function assignToEarlyBirds ( address [ ] earlyBirds , uint256 amount ) onlyOwner public { require ( amount > 0 ) ; for ( uint i = 0 ; i < earlyBirds . length ; i ++ ) _transfer ( msg . sender , earlyBirds [ i ] , amount * 10 ** 18 ) ; }
function name ( ) external view returns ( string _name ) ;
function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( approved [ _from ] [ msg . sender ] >= _value && balances [ _from ] >= _value && _value > 0 ) ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; approved [ _from ] [ msg . sender ] = safeSub ( approved [ _from ] [ msg . sender ] , _value ) ; Transfer ( _from , _to , _value ) ; return true ; }
function getAmountFida ( uint256 _weiAmount ) public view returns ( uint256 _fidaAmount ) { require ( _weiAmount != 0 ) ; _fidaAmount = _weiAmount . mul ( fidaPerEther ) . div ( 100000 ) ; return _fidaAmount ; }
function distributeFixed ( uint index , address [ ] _addrs , uint _amoutToEach ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _amoutToEach ) ; } } else revert ( "Distribution Failed: Countdown not finished yet" ) ; }
function approveAndCall ( address spender , uint256 amount , uint256 nonce , bytes extraData ) external returns ( bool success ) { address _trg = libAddress ; assembly { let m := mload ( 0x20 ) calldatacopy ( m , 0 , calldatasize ) let success := delegatecall ( gas , _trg , m , calldatasize , m , 0x20 ) switch success case 0 { invalid } default { return ( m , 0x20 ) } } }
function hasClosed ( ) public view returns ( bool ) { return ( totalTokensSold >= totalSaleAllocation ) || super . hasClosed ( ) ; }
function _freezeTransfer ( address _to , uint cst ) private { _transfer ( owner , _to , cst ) ; freezed [ _to ] = freezed [ _to ] . add ( cst ) ; }
function getChannelWith ( address partner ) constant returns ( address ) { return data . getChannelWith ( partner ) ; }
function decision ( ) external returns ( bool ) ;
function transferFrom ( address _from , address _to , uint256 _tokenId ) public ;
function checkCooldown ( address _allower , address _allowee ) external constant returns ( uint256 remaining ) { if ( cooldown [ _allower ] [ _allowee ] > now ) { return ( cooldown [ _allower ] [ _allowee ] - now ) ; } else { return 0 ; } }
function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ;
function missingTokensFallback ( ) public { uint256 missingTokens = token . balanceOf ( this ) . sub ( totalFrozen ) ; require ( missingTokens > 0 ) ; TokenWithOwner tokenWithOwner = TokenWithOwner ( token ) ; token . safeTransfer ( tokenWithOwner . owner ( ) , missingTokens ) ; }
function sell ( uint256 amount ) public { amount = amount * 10 ** uint256 ( decimals ) ; require ( this . balance >= amount / sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount / sellPrice ) ; }
function pauseContribution ( ) public onlyOwner { paused = true ; }
function mintCUSD ( address _to , uint256 _amount ) public requiresPermission whenNotPaused userNotBlacklisted ( _to ) { return _mintCUSD ( _to , _amount ) ; }
function allowFreezeBypass ( address sender ) public onlyOwner returns ( bool success ) { freezeBypassing [ sender ] = true ; return true ; }
function removeOwnership ( uint _dac ) onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; }
function buyPreciousMetal ( ) public payable returns ( uint256 ) { return buyFactory ( FactoryType . PreciousMetal ) ; }
function changeCertifier ( address newCertifier ) pre_cond ( isOracle ( ) ) { CERTIFIER = Certifier ( newCertifier ) ; }
function transferCheck ( address _sender , address _receiver , uint256 _amount ) private constant returns ( bool success ) { require ( ! tokenIsFrozen ) ; require ( _amount > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] . sub ( _amount ) >= 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > balances [ _receiver ] ) ; return true ; }
function setNextGame ( uint256 _price , uint256 _timeout , uint256 _minimumTimeout , uint256 _numberOfWagersToMinimumTimeout ) external onlyCFO { require ( _timeout >= _minimumTimeout ) ; nextPrice = _price ; nextTimeout = _timeout ; nextMinimumTimeout = _minimumTimeout ; nextNumberOfWagersToMinimumTimeout = _numberOfWagersToMinimumTimeout ; NextGame ( nextPrice , nextTimeout , nextMinimumTimeout , nextNumberOfWagersToMinimumTimeout ) ; }
function changeForeignBridge ( address _newForeignBridge ) public onlyController { foreignBridge = _newForeignBridge ; }
function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( mBalances [ _from ] >= _amount ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( _from , _to , _amount ) ; } }
function isAirDropUnique ( uint index , address receiver , address sc ) private view returns ( bool ) { Airdrop storage airdrop = airdrops [ index ] ; if ( airdrop . uniqueAirdrop [ receiver ] == sc ) { return true ; } else return false ; }
function sell ( uint256 amount ) { require ( this . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
function calculateFees ( Data storage self , address contractAddress , uint amount ) internal view returns ( uint calculatedFees ) { uint maxFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.max' , contractAddress ) ) ) ; uint minFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.min' , contractAddress ) ) ) ; uint bpsFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.bps' , contractAddress ) ) ) ; uint flatFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.flat' , contractAddress ) ) ) ; uint fees = ( ( amount . mul ( bpsFee ) ) . div ( 10000 ) ) . add ( flatFee ) ; if ( fees > maxFee ) { return maxFee ; } else if ( fees < minFee ) { return minFee ; } else { return fees ; } }
function convertToEther ( uint256 _value ) private pure returns ( uint256 ) { return _value * FIXED_RATE / 10 ** 18 ; }
function upgrade ( uint256 _value ) public { UpgradeState _state = getUpgradeState ( ) ; require ( _state == UpgradeState . ReadyToUpgrade || _state == UpgradeState . Upgrading , "State must be correct for upgrade" ) ; require ( _value > 0 , "Upgrade value must be greater than zero" ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; totalUpgraded = totalUpgraded . add ( _value ) ; upgradeAgent . upgradeFrom ( msg . sender , _value ) ; emit Upgrade ( msg . sender , upgradeAgent , _value ) ; }
function onApprove ( address _owner , address _spender , uint _amount ) returns ( bool ) { return true ; }
function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) external returns ( bool success ) ;
function removeNFToken ( address _from , uint256 _tokenId ) internal { require ( idToOwner [ _tokenId ] == _from ) ; assert ( ownerToNFTokenCount [ _from ] > 0 ) ; ownerToNFTokenCount [ _from ] = ownerToNFTokenCount [ _from ] . sub ( 1 ) ; delete idToOwner [ _tokenId ] ; }
