code,nl
"function sendEther ( address to , uint value ) external onlymanyowners ( keccak256 ( msg . data ) ) { require ( address ( 0 ) != to ) ; require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }
","Send ` value ` of ether to address ` to `
"
"function isReadyToMate ( uint256 _ponyId ) public view returns ( bool ) { require ( _ponyId > 0 ) ; Pony storage pon = ponies [ _ponyId ] ; return _isReadyToMate ( pon ) ; }
","Checks that a given pony is able to breed ( i.e .
"
"function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }
","Returns the amount which _spender is still allowed to withdraw from _owner
"
"function isValidator ( ) external view returns ( bool ) { uint256 totalValidators = _jurisdiction . countValidators ( ) ; for ( uint256 i = 0 ; i < totalValidators ; i ++ ) { address validator = _jurisdiction . getValidator ( i ) ; if ( validator == address ( this ) ) { return true ; } } return false ; }
","Check if contract is assigned as a validator on the jurisdiction .
"
"function issueAttribute ( address account , uint256 attributeTypeID , uint256 value ) external payable whenNotPaused { require ( msg . value == 0 , ""Basic jurisdictions do not support payments when assigning attributes"" ) ; require ( canValidate ( msg . sender , attributeTypeID ) , ""only approved validators may assign attributes of this type"" ) ; require ( _issuedAttributes [ account ] [ attributeTypeID ] . validator == address ( 0 ) , ""duplicate attributes are not supported, remove existing attribute first"" ) ; _issuedAttributes [ account ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , validator : msg . sender , value : value } ) ; emit AttributeAdded ( msg . sender , account , attributeTypeID , value ) ; }
","Issue an attribute of the type with ID ` attributeTypeID ` and a value of ` value ` to ` account ` if ` message.caller.address ( ) ` is approved validator .
"
"function closeDataResponse ( address seller , bool transactionCompleted ) public onlyOwner validAddress ( seller ) returns ( bool ) { require ( orderStatus != OrderStatus . TransactionCompleted ) ; require ( transactionCompletedAt == 0 ) ; require ( hasSellerBeenAccepted ( seller ) ) ; require ( sellerInfo [ seller ] . status == DataResponseStatus . DataResponseAdded ) ; sellerInfo [ seller ] . status = transactionCompleted ? DataResponseStatus . TransactionCompleted : DataResponseStatus . RefundedToBuyer ; sellerInfo [ seller ] . closedAt = uint32 ( block . timestamp ) ; return true ; }
","Closes a DataResponse .
"
"function deposit ( uint256 amount ) returns ( bool ) { bool success ; uint256 balance ; ( success , balance ) = data . deposit ( amount ) ; if ( success == true ) { ChannelNewBalance ( data . token , msg . sender , balance , block . number ) ; } return success ; }
","Caller makes a deposit into their channel balance .
"
"function lockAndDistributeTokens ( address _tokenHolder , uint256 _amount , uint256 _percentageToLock , uint256 _unlockTime ) public onlyOwner { requireMultiple ( _amount ) ; require ( _percentageToLock <= 100 && _percentageToLock > 0 , ""You can only lock a percentage between 0 and 100."" ) ; require ( mLockedBalances [ _tokenHolder ] . amount == 0 , ""You can only lock one amount of tokens for a given address. It is currently indicating that there are already locked tokens for this address."" ) ; uint256 amountToLock = _amount . mul ( _percentageToLock ) . div ( 100 ) ; mBalances [ msg . sender ] = mBalances [ msg . sender ] . sub ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; mLockedBalances [ _tokenHolder ] = lockedTokens ( { amount : amountToLock , timeLockedUntil : _unlockTime } ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , """" , """" , true ) ; emit LockedTokens ( _tokenHolder , amountToLock , _unlockTime ) ; if ( mErc20compatible ) { emit Transfer ( 0x0 , _tokenHolder , _amount ) ; } }
","locks a percentage of tokens for a specified time period and then grants ownership to the specified owner
"
"function trade ( TradeInput tradeInput ) internal returns ( uint ) { require ( isEnabled ) ; require ( tx . gasprice <= maxGasPriceValue ) ; require ( validateTradeInput ( tradeInput . src , tradeInput . srcAmount , tradeInput . dest , tradeInput . destAddress ) ) ; BestRateResult memory rateResult = findBestRateTokenToToken ( tradeInput . src , tradeInput . dest , tradeInput . srcAmount ) ; require ( rateResult . rate > 0 ) ; require ( rateResult . rate < MAX_RATE ) ; require ( rateResult . rate >= tradeInput . minConversionRate ) ; uint actualDestAmount ; uint weiAmount ; uint actualSrcAmount ; ( actualSrcAmount , weiAmount , actualDestAmount ) = calcActualAmounts ( tradeInput . src , tradeInput . dest , tradeInput . srcAmount , tradeInput . maxDestAmount , rateResult ) ; if ( actualSrcAmount < tradeInput . srcAmount ) { if ( tradeInput . src == ETH_TOKEN_ADDRESS ) { tradeInput . trader . transfer ( tradeInput . srcAmount - actualSrcAmount ) ; } else { tradeInput . src . transfer ( tradeInput . trader , ( tradeInput . srcAmount - actualSrcAmount ) ) ; } } require ( weiAmount <= getUserCapInWei ( tradeInput . trader ) ) ; require ( doReserveTrade ( tradeInput . src , actualSrcAmount , ETH_TOKEN_ADDRESS , this , weiAmount , KyberReserveInterface ( rateResult . reserve1 ) , rateResult . rateSrcToEth , true ) ) ; require ( doReserveTrade ( ETH_TOKEN_ADDRESS , weiAmount , tradeInput . dest , tradeInput . destAddress , actualDestAmount , KyberReserveInterface ( rateResult . reserve2 ) , rateResult . rateEthToDest , true ) ) ; if ( tradeInput . src != ETH_TOKEN_ADDRESS ) require ( feeBurnerContract . handleFees ( weiAmount , rateResult . reserve1 , tradeInput . walletId ) ) ; if ( tradeInput . dest != ETH_TOKEN_ADDRESS ) require ( feeBurnerContract . handleFees ( weiAmount , rateResult . reserve2 , tradeInput . walletId ) ) ; KyberTrade ( tradeInput . trader , tradeInput . src , actualSrcAmount , tradeInput . destAddress , tradeInput . dest , actualDestAmount ) ; return actualDestAmount ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function revoke ( ERC20 token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }
","Allows the owner to revoke the vesting .
"
"function transferFromPreSigned ( bytes _signature , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = transferFromPreSignedHashing ( address ( this ) , _from , _to , _value , _fee , _nonce ) ; address spender = recover ( hashedTx , _signature ) ; require ( spender != address ( 0 ) ) ; checkValue ( spender , _fee ) ; checkValue ( _from , _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ spender ] = allowed [ _from ] [ spender ] . sub ( _value ) ; balances [ spender ] = balances [ spender ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( _from , _to , _value ) ; emit Transfer ( spender , msg . sender , _fee ) ; return true ; }
","Transfer tokens from one address to another
"
"function totalSupply ( ) public view returns ( uint256 ) { return totalSupply ; }
","Used to get the total supply
"
"function approve ( address _to , uint256 _tokenId ) external payable { require ( msg . value == 0 ) ; address owner = _ownerOf ( _tokenId ) ; require ( _to != owner ) ; require ( msg . sender == owner || _isApprovedForAll ( owner , msg . sender ) ) ; _tokenApprovals [ _tokenId ] = _to ; emit Approval ( owner , _to , _tokenId ) ; }
","Change or reaffirm the approved address for an NFT
"
"function register ( string _identifier , uint _version , Template _template ) public { require ( opened || msg . sender == owner ) ; require ( _template . supportsInterface ( 0x01ffc9a7 ) ) ; require ( _template . supportsInterface ( 0xd48445ff ) ) ; address registrant = registrantOfIdentifier [ _identifier ] ; require ( registrant == address ( 0 ) || registrant == msg . sender , ""identifier already registered by another registrant"" ) ; if ( registrant == address ( 0 ) ) { identifiers . push ( _identifier ) ; registrantOfIdentifier [ _identifier ] = msg . sender ; } uint [ ] storage versions = versionsOfIdentifier [ _identifier ] ; if ( versions . length > 0 ) { require ( _version > versions [ versions . length - 1 ] , ""new version must be greater than old versions"" ) ; } versions . push ( _version ) ; templateOfVersionOfIdentifier [ _identifier ] [ _version ] = _template ; }
","Registers a new ` Template ` .
"
"function isDeregistered ( address _darknodeID ) public view returns ( bool ) { uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return deregisteredAt != 0 && deregisteredAt <= currentEpoch . blocknumber ; }
","Returns if a darknode is in the deregistered state .
"
"function disqualifyHopeful ( uint withId ) pre_cond ( isOracle ( ) ) { hopefuls [ withId ] . isDisqualified = true ; }
","Disqualify and participant
"
"function _isOnSale ( Sale memory _sale ) internal pure returns ( bool ) { return ( _sale . startedAt > 0 ) ; }
","Internal function to check if an
"
"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x0d2d1bf5 ) , _token , _to , _value , _fee , _nonce , _validUntil ) ; }
","Hash ( keccak256 ) of the payload used by transferPreSigned
"
"function totalSupply ( ) public view returns ( uint256 _totalSupply ) { return totalSupply ; }
","Used to retrieve total supply
"
"function ICOSplit ( ) external isAdmin oneTime { uint i ; if ( ! isFrozen ) { require ( ( relativeDateSave - now ) >= ( relativeDateSave - 150 days ) ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 50000000000000 ) ; currentProfits = ( ( balances [ selfAddress ] - 50000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 300000000000000 , balances [ selfAddress ] ) ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { if ( msg . gas < 240000 ) { currentIteration = i ; break ; } actualProfitSplit += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; balances [ users [ i ] ] += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; if ( i == users . length - 1 ) { assetThaw ( ) ; balances [ selfAddress ] = balances [ selfAddress ] - actualProfitSplit ; hasICORun = true ; } Transfer ( selfAddress , users [ i ] , ( balances [ users [ i ] ] / amountInCirculation ) * currentProfits ) ; } } }
","Split the unsold WBC of the ICO
"
"function _mintFish ( address _owner , uint32 _weight , uint8 _power , uint8 _agility , uint8 _speed , bytes16 _color ) internal { fishes . length += 1 ; uint256 newFishId = fishes . length - 1 ; Fish storage newFish = fishes [ newFishId ] ; newFish . owner = _owner ; newFish . weight = _weight ; newFish . power = _power ; newFish . agility = _agility ; newFish . speed = _speed ; newFish . color = _color ; balances [ _owner ] ++ ; Transfer ( address ( 0 ) , _owner , newFishId ) ; }
","Internal method for minting a fish
"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","send ` _value ` token to ` _to `
"
"function updateGiver ( uint64 idGiver , address newAddr , string newName , string newUrl , uint64 newCommitTime ) { PledgeAdmin storage giver = findAdmin ( idGiver ) ; require ( giver . adminType == PledgeAdminType . Giver ) ; require ( giver . addr == msg . sender ) ; giver . addr = newAddr ; giver . name = newName ; giver . url = newUrl ; giver . commitTime = newCommitTime ; GiverUpdated ( idGiver ) ; }
","Updates a Giver 's info to change the address , name , url , or commitTime , it can not be used to change a plugin , and it must be called by the current address of the Giver
"
"function getOrderPriceInfo ( address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( uint orderPrice ) { return mul ( buyQuantity , 10 ** uint ( getDecimals ( sellAsset ) ) ) / sellQuantity ; }
","Gets price of Order
"
"function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens -= voterTokens ; challenges [ _challengeID ] . rewardPool -= reward ; require ( token . transfer ( msg . sender , reward ) ) ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; }
","claim the tokens owed for the msg.sender in the provided challenge
"
"function claimProfitEquivalent ( ) public { uint256 toPay ; for ( uint k = 0 ; k <= yearsPast . length - 1 ; k ++ ) { toPay += snapShot [ yearsPast [ k ] ] [ msg . sender ] ; snapShot [ yearsPast [ k ] ] [ msg . sender ] = 0 ; } msg . sender . transfer ( toPay ) ; peLastPeriod -= toPay ; }
","Allow user to claim his PE on his Ethereum Address .
"
"function removeFromWhitelist ( address [ ] _bidder_addresses ) public isWhitelister { for ( uint32 i = 0 ; i < _bidder_addresses . length ; i ++ ) { whitelist [ _bidder_addresses [ i ] ] = false ; } }
","Removes account addresses from whitelist .
"
"function getTime ( ) internal view returns ( uint256 ) { return now ; }
","This function is overrided by the test Mocks .
"
"function QToken ( address target , uint256 qAmount ) onlyOwner public { balanceOf [ target ] += qAmount ; totalSupply += qAmount ; emit Transfer ( 0 , this , qAmount ) ; emit Transfer ( this , target , qAmount ) ; }
","Create ` qAmount ` tokens and send it to ` target `
"
"function getMembersArrayLength ( ) public view returns ( uint256 ) { return membersArray . length ; }
","Called in order to get the number of members on the platform
"
"function unlockMiner ( ) public locked onlyOwner { require ( block . timestamp >= minerRelaseTime ) ; require ( minerLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= minerLockedAmount ) ; token . transfer ( minerLockAddress , minerLockedAmount ) ; minerLockedAmount = 0 ; }
","Transfers tokens held by timelock to miner .
"
"function setCurrentPrice ( uint256 newPrice ) public onlyOwner { currentPrice = newPrice ; }
","Allows the owner of this contract to set the currentPrice for each token
"
"function finalize ( bool _forceRefund ) onlyOwner public returns ( bool ) { if ( isFinalized ) { error ( 'finalize: ICO is already finalized.' ) ; return false ; } if ( weisRaised >= weisSoftCap && ! _forceRefund ) { if ( ! SCRefundVault . close ( ) ) { error ( 'finalize: SCRefundVault.close() failed' ) ; return false ; } } else { if ( ! SCRefundVault . enableRefunds ( ) ) { error ( 'finalize: SCRefundVault.enableRefunds() failed' ) ; return false ; } if ( _forceRefund ) { emit ForceRefund ( ) ; } } uint256 balanceAmount = SCTokens . balanceOf ( this ) ; if ( ! SCTokens . transfer ( address ( SCEscrow ) , balanceAmount ) ) { error ( 'finalize: unable to return remaining ICO tokens' ) ; return false ; } if ( ! SCEscrow . deposit ( balanceAmount ) ) { error ( 'finalize: unable to return remaining ICO tokens' ) ; return false ; } isFinalized = true ; emit Finalized ( ) ; return true ; }
","Must be called by owner before or after ICO ends , to check whether soft cap is reached and transfer collected funds
"
"function registerDeed ( string propertyAddress , string document ) public { require ( __isSenderInRole ( ROLE_DEED_REGISTRANT ) ) ; uint256 documentHash = uint256 ( keccak256 ( document ) ) ; require ( documentRegistry [ documentHash ] == 0 ) ; require ( document . contains ( propertyAddress ) ) ; documentRegistry [ documentHash ] = now ; uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; if ( addressRegistry [ propertyAddressHash ] . length == 0 ) { knownPropertyAddresses . push ( propertyAddress ) ; } addressRegistry [ propertyAddressHash ] . push ( document ) ; emit DeedRegistered ( propertyAddress , document ) ; }
","A ` document ` may not necessarily represent a document itself , it can also be its metadata or just a hash
"
"function calculateCurrentBlock ( uint256 _stakeNumber ) internal view returns ( uint256 currentBlock ) { currentBlock = block . number ; if ( currentBlock >= stakes [ msg . sender ] [ _stakeNumber ] . blockUnlocked ) { currentBlock = stakes [ msg . sender ] [ _stakeNumber ] . blockUnlocked ; } }
","This is a helper function used to calculate how many blocks to mint coins for
"
"function SetContractorManager ( address _contractorManager ) ;
","Function used by the creator to set the contractor manager smart contract
"
"function isSigned ( address _address , bytes32 messageHash , uint8 v , bytes32 r , bytes32 s ) public pure returns ( bool ) { return _isSigned ( _address , messageHash , v , r , s ) || _isSignedPrefixed ( _address , messageHash , v , r , s ) ; }
","Determines whether the passed signature of ` messageHash ` was made by the private key of ` _address ` .
"
"function commitVote ( uint _pollID , bytes32 _secretHash , uint _numTokens , uint _prevPollID ) external { require ( commitPeriodActive ( _pollID ) ) ; require ( voteTokenBalance [ msg . sender ] >= _numTokens ) ; require ( _pollID != 0 ) ; require ( _prevPollID == 0 || dllMap [ msg . sender ] . contains ( _prevPollID ) ) ; uint nextPollID = dllMap [ msg . sender ] . getNext ( _prevPollID ) ; nextPollID = ( nextPollID == _pollID ) ? dllMap [ msg . sender ] . getNext ( _pollID ) : nextPollID ; require ( validPosition ( _prevPollID , nextPollID , msg . sender , _numTokens ) ) ; dllMap [ msg . sender ] . insert ( _prevPollID , _pollID , nextPollID ) ; bytes32 UUID = attrUUID ( msg . sender , _pollID ) ; store . setAttribute ( UUID , ""numTokens"" , _numTokens ) ; store . setAttribute ( UUID , ""commitHash"" , uint ( _secretHash ) ) ; pollMap [ _pollID ] . didCommit [ msg . sender ] = true ; _VoteCommitted ( _pollID , _numTokens , msg . sender ) ; }
","Commits vote using hash of choice and secret salt to conceal vote until reveal
"
"function createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) public payable withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _checkpointId , _excluded , _name ) ; }
","Creates a dividend with a provided checkpoint , specifying explicit excluded addresses
"
"function totalSupply ( ) public view returns ( uint ) { return rabbits . length - 1 ; }
","Returns the total number of rabbits currently in existence .
"
"function staticChecks ( Trade [ ] trades , TradeFlag [ ] tradeFlags ) public view whenNotPaused { bool previousBuyOccured = false ; for ( uint256 i ; i < trades . length ; i ++ ) { Trade memory thisTrade = trades [ i ] ; if ( thisTrade . isSell ) { if ( previousBuyOccured ) { errorReporter . revertTx ( ""A buy has occured before this sell"" ) ; } if ( ! Utils . tokenAllowanceAndBalanceSet ( msg . sender , thisTrade . tokenAddress , thisTrade . tokenAmount , tokenTransferProxy ) ) { if ( ! thisTrade . optionalTrade ) { errorReporter . revertTx ( ""Taker has not sent allowance/balance on a non-optional trade"" ) ; } tradeFlags [ i ] . ignoreTrade = true ; continue ; } } else { previousBuyOccured = true ; } for ( uint256 j ; j < thisTrade . orders . length ; j ++ ) { Order memory thisOrder = thisTrade . orders [ j ] ; if ( ! handlerWhitelistMap [ thisOrder . exchangeHandler ] ) { tradeFlags [ i ] . ignoreOrder [ j ] = true ; continue ; } } } }
","Performs static checks on the rebalance payload before execution
"
"function channelsSold ( ) constant returns ( uint256 ) { return soldOut . channels ; }
","returns tokens sold via channels
"
"function onTransfer ( address _from , address _to , uint _amount ) public initialized returns ( bool ) { return false ; }
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function transferToAddress ( address to , uint256 value , bytes data ) public whenNotPaused afterCrowdsale returns ( bool _success ) { return super . transferToAddress ( to , value , data ) ; }
","Override the functions to not allow token transfers until the end of the ICO
"
"function setOracleURL ( string _oracleURL ) onlyOwner public { oracleURL = _oracleURL ; }
","Allows owner to set URL used in Oraclize queries
"
"function updateAsset ( address ofAsset , bytes32 inputName , bytes8 inputSymbol , uint inputDecimals , string inputUrl , string inputIpfsHash , address [ 2 ] ofBreakInBreakOut , uint [ ] inputStandards , bytes4 [ ] inputFunctionSignatures ) auth pre_cond ( assetInformation [ ofAsset ] . exists ) { Asset asset = assetInformation [ ofAsset ] ; asset . name = inputName ; asset . symbol = inputSymbol ; asset . decimals = inputDecimals ; asset . url = inputUrl ; asset . ipfsHash = inputIpfsHash ; asset . breakIn = ofBreakInBreakOut [ 0 ] ; asset . breakOut = ofBreakInBreakOut [ 1 ] ; asset . standards = inputStandards ; asset . functionSignatures = inputFunctionSignatures ; }
","Updates description information of a registered Asset
"
"function removeAttribute ( uint256 attributeTypeID ) external { require ( ! _attributeTypes [ attributeTypeID ] . restricted , ""only jurisdiction or issuing validator may remove a restricted attribute"" ) ; require ( _issuedAttributes [ msg . sender ] [ attributeTypeID ] . exists , ""only existing attributes may be removed"" ) ; address validator = _issuedAttributes [ msg . sender ] [ attributeTypeID ] . validator ; uint256 stake = _issuedAttributes [ msg . sender ] [ attributeTypeID ] . stake ; address refundAddress ; if ( _issuedAttributes [ msg . sender ] [ attributeTypeID ] . setPersonally ) { refundAddress = msg . sender ; } else { address operator = _issuedAttributes [ msg . sender ] [ attributeTypeID ] . operator ; if ( operator == address ( 0 ) ) { refundAddress = validator ; } else { refundAddress = operator ; } } delete _issuedAttributes [ msg . sender ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , msg . sender , attributeTypeID ) ; if ( stake > 0 && address ( this ) . balance >= stake ) { if ( refundAddress . send ( stake ) ) { emit StakeRefunded ( refundAddress , attributeTypeID , stake ) ; } } }
","Remove an attribute of the type with ID ` attributeTypeID ` from account of ` msg.sender ` .
"
"function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; require ( this . balance >= revenue ) ; uint commission = msg . value / sellCommission ; require ( address ( this ) . send ( commission ) ) ; msg . sender . transfer ( revenue ) ; }
","Sell metadollars and receive ether from contract
"
"function getCanvasesWithSellOffer ( bool includePrivateOffers ) external view returns ( uint32 [ ] ) { uint32 [ ] memory result = new uint32 [ ] ( canvases . length ) ; uint currentIndex = 0 ; for ( uint32 i = 0 ; i < canvases . length ; i ++ ) { SellOffer storage offer = canvasForSale [ i ] ; if ( offer . isForSale && ( includePrivateOffers || offer . onlySellTo == 0x0 ) ) { result [ currentIndex ] = i ; currentIndex ++ ; } } return _slice ( result , 0 , currentIndex ) ; }
","Returns array of canvas 's ids .
"
"function removeEmissionProvider ( address _provider , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _provider ) , _block ) ; if ( OK != _code ) { return _code ; } delete emissionProviders [ _provider ] ; return OK ; }
","Remove emission provider
"
"function getSecurityTokenLaunchFee ( ) external view returns ( uint256 ) ;
","Gets the security token launch fee
"
"function claimTokens ( token _address ) public { require ( state == State . Successful ) ; require ( msg . sender == creator ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( creator , remainder ) ; }
","Function to claim any token stuck on contract
"
"function getCurrencySymbol ( ) external view returns ( bytes32 ) { return currencySymbol ; }
","Returns symbol of oracle currency ( 0x0 for ETH )
"
"function changeOwner ( address _newOwner ) onlyOwner public { owner = _newOwner ; }
","Changes the owner of the contract
"
"function getGameResult ( uint gameId ) public view returns ( GameResults ) { return games [ gameId ] . result ; }
","Returns the result of a specific game
"
"function buyFood ( uint32 _bundles ) external payable whenNotPaused returns ( bool ) { require ( newContractAddress == address ( 0 ) ) ; uint cost = _bundles * price ; require ( msg . value >= cost ) ; uint fundsExcess = msg . value - cost ; if ( fundsExcess > 1 finney ) { msg . sender . transfer ( fundsExcess ) ; } emit Bought ( msg . sender , _bundles ) ; return true ; }
","customer buy food
"
"function batchReclaimExpiredSwaps ( bytes32 msigId , bytes32 [ ] swapIds ) public { for ( uint i = 0 ; i < swapIds . length ; ++ i ) reclaimExpiredSwaps ( msigId , swapIds [ i ] ) ; }
","Reclaim all the expired , non-empty swaps into a multisig
"
"function close ( uint64 nonce , uint256 transferred_amount , bytes32 locksroot , bytes32 extra_hash , bytes signature ) { data . close ( nonce , transferred_amount , locksroot , extra_hash , signature ) ; ChannelClosed ( msg . sender , data . closed ) ; }
","Close the channel .
"
"function rename ( uint256 _tokenId , bytes8 _name ) public validId ( _tokenId ) returns ( uint64 ) { require ( isCreatorAndOwner ( msg . sender , _tokenId ) , ""Sender is not the creator and owner"" ) ; TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; pixelconNames [ lookupData . tokenIndex ] = _name ; emit Rename ( _tokenId , _name ) ; return lookupData . tokenIndex ; }
","Rename PixelCon ` ( _tokenId ) `
"
"function getTypes ( ) external view returns ( uint8 [ ] ) { uint8 [ ] memory res = new uint8 [ ] ( 1 ) ; res [ 0 ] = 3 ; return res ; }
","Type of the Module factory
"
"function setupEventsHistory ( address _eventsHistory ) external auth returns ( uint ) { require ( _eventsHistory != 0x0 ) ; _setEventsHistory ( _eventsHistory ) ; return OK ; }
","Sets up events history address Allowed only for authorized roles .
"
"function contribute ( address _ref ) public notFinished payable { address referral = _ref ; uint256 referralBase = 0 ; uint256 referralTokens = 0 ; uint256 tokenBought = 0 ; if ( refLed [ msg . sender ] == 0 ) { refLed [ msg . sender ] = referral ; } else { referral = refLed [ msg . sender ] ; } totalRaised = totalRaised . add ( msg . value ) ; if ( state == State . stage1 ) { tokenBought = msg . value . mul ( rates [ 0 ] ) ; } else if ( state == State . stage2 ) { tokenBought = msg . value . mul ( rates [ 1 ] ) ; } else if ( state == State . stage3 ) { tokenBought = msg . value . mul ( rates [ 2 ] ) ; } else if ( state == State . stage4 ) { tokenBought = msg . value . mul ( rates [ 3 ] ) ; } else if ( state == State . stage5 ) { tokenBought = msg . value . mul ( rates [ 4 ] ) ; } referralBase = tokenBought ; if ( msg . value >= 5 ether ) { tokenBought = tokenBought . mul ( 102 ) ; tokenBought = tokenBought . div ( 100 ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; stageDistributed = stageDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; emit LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; emit LogContributorsPayout ( msg . sender , tokenBought ) ; if ( referral != address ( 0 ) && referral != msg . sender ) { referralTokens = referralBase . div ( 20 ) ; totalDistributed = totalDistributed . add ( referralTokens ) ; stageDistributed = stageDistributed . add ( referralTokens ) ; tokenReward . transfer ( referral , referralTokens ) ; emit LogContributorsPayout ( referral , referralTokens ) ; } checkIfFundingCompleteOrExpired ( ) ; }
","contribution handler
"
"function issueNomins ( uint amount ) public optionalProxy requireIssuer ( messageSender ) { address sender = messageSender ; require ( amount <= remainingIssuableNomins ( sender ) ) ; uint lastTot = nomin . totalSupply ( ) ; uint preIssued = nominsIssued [ sender ] ; nomin . issue ( sender , amount ) ; nominsIssued [ sender ] = safeAdd ( preIssued , amount ) ; updateIssuanceData ( sender , preIssued , lastTot ) ; }
","Issue nomins against the sender 's havvens .
"
"function changeBeneficiary ( address _beneficiary ) public onlyOwner { beneficiary = _beneficiary ; }
","Owner can change beneficiary address
"
"function transfer ( address to , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ sender ] == 0 || value <= transferableHavvens ( sender ) , ""Value to transfer exceeds available havvens"" ) ; _transfer_byProxy ( sender , to , value ) ; return true ; }
","ERC20 transfer function .
"
"function _forwardFunds ( ) internal { }
","Stops the crowdsale contract from sending ethers .
"
"function setAllowedTransferTo ( address to , bool allowed ) public only ( ROLE_EURT_LEGAL_MANAGER ) { setAllowedTransferToPrivate ( to , allowed ) ; }
","enables or disables address to be receipient of EUR-T
"
"function yearlyOwnerTokenWithdrawal ( ) public onlyOwner { require ( crowdsaleClosed == true ) ; require ( ( ( now > stopTime + 1 years ) && ( yearlyTeamTokensPaid [ 0 ] == false ) ) || ( ( now > stopTime + 2 years ) && ( yearlyTeamTokensPaid [ 1 ] == false ) ) || ( ( now > stopTime + 3 years ) && ( yearlyTeamTokensPaid [ 2 ] == false ) ) ) ; tokenReward . transfer ( beneficiary , yearlyTeamAmount ) ; if ( yearlyTeamTokensPaid [ 0 ] == false ) yearlyTeamTokensPaid [ 0 ] = true ; else if ( yearlyTeamTokensPaid [ 1 ] == false ) yearlyTeamTokensPaid [ 1 ] = true ; else if ( yearlyTeamTokensPaid [ 2 ] == false ) yearlyTeamTokensPaid [ 2 ] = true ; }
","A function to withdraw team tokens .
"
"function motionVoting ( uint motionID ) public view returns ( bool ) { return motionStartTime [ motionID ] < now && now < motionStartTime [ motionID ] + votingPeriod ; }
","There is a motion in progress on the specified account , and votes are being accepted in that motion .
"
"function allocateTokens ( address _receiver , bytes16 _customerUuid , uint256 _weiAmount ) whenNotPaused canAllocateTokens public { allocateInternal ( _receiver , _customerUuid , _weiAmount ) ; }
","Allocate tokens to specified address .
"
"function tokenURI ( uint256 _tokenId ) external view returns ( string ret ) { string memory tokenIdAsString = uintToString ( uint ( _tokenId ) ) ; ret = string ( abi . encodePacked ( _tokenURI , tokenIdAsString , ""/"" ) ) ; }
","A distinct Uniform Resource Identifier ( URI ) for a given asset .
"
"function purchase ( uint256 _nftId ) external payable mustBeValidToken ( _nftId ) mustBeOwnedByThisContract ( _nftId ) { require ( msg . value == SALE_PRICE ) ; _transfer ( _nftId , msg . sender ) ; }
","The price is always 0.5 ether , and you can buy any available square Be sure you are calling this from a regular account ( not a smart contract ) or if you are calling from a smart contract , make sure it can use ERC-721 non-fungible tokens
"
"function send ( address _to , uint256 _amount , bytes _data ) public { doSend ( msg . sender , msg . sender , _to , _amount , _data , """" , true ) ; }
","Send ` _amount ` of tokens to address ` _to ` passing ` _data ` to the recipient
"
"function purchase ( ) public payable { __purchase_impl ( msg . sender , msg . value ) ; }
","Token purchase function .
"
"function batchTransferFrom ( uint256 [ ] _tokenIds , address _from , address _to ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _from != address ( 0 ) && _to != address ( 0 ) ) ; uint256 _id ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 ) ; _id = _tokenIds [ i ] ; transferFrom ( _from , _to , _id ) ; } }
","Batch TransferFrom with the same to & from address
"
"function transfer ( address to , uint value , bytes data ) public optionalProxy returns ( bool ) { require ( value <= transferableSynthetix ( messageSender ) , ""Insufficient balance"" ) ; _transfer_byProxy ( messageSender , to , value , data ) ; return true ; }
","ERC223 transfer function .
"
"function transfer ( address _to , uint256 _identifier ) external whenNotPaused { require ( _owns ( msg . sender , _identifier ) ) ; _transfer ( msg . sender , _to , _identifier ) ; }
","Transfer a deed to another address .
"
"function totalSupplyOf ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . supply ; }
","The total supply of a product
"
"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; memeIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function balanceOf ( address _owner ) constant returns ( uint256 balance ) ;
","Get the account balance of another account with address _owner
"
"function pickUniquePacks ( uint [ ] assetIds ) public view returns ( uint [ ] ) { require ( assetIds . length > 0 ) ; uint [ ] memory packs = new uint [ ] ( assetIds . length ) ; uint packsCount = 0 ; for ( uint i = 0 ; i < assetIds . length ; i ++ ) { Asset memory asset = assets [ assetIds [ i ] ] ; bool exists = false ; for ( uint j = 0 ; j < packsCount ; j ++ ) { if ( asset . packId == packs [ j ] ) { exists = true ; } } if ( ! exists ) { packs [ packsCount ] = asset . packId ; packsCount ++ ; } } uint [ ] memory finalPacks = new uint [ ] ( packsCount ) ; for ( i = 0 ; i < packsCount ; i ++ ) { finalPacks [ i ] = packs [ i ] ; } return finalPacks ; }
","method that gets all unique packs from array of assets
"
"function destroy ( address [ ] tokens ) onlyOwner public { require ( now > unlockTime || ( contributorCount ( ) == 0 && paused ) ) ; super . destroy ( tokens ) ; }
","Shuts down the contract
"
"function init ( ChronoBankPlatform _chronoBankPlatform , string _symbol , string _name ) public returns ( bool ) { if ( address ( chronoBankPlatform ) != 0x0 ) { return false ; } chronoBankPlatform = _chronoBankPlatform ; symbol = _symbol ; smbl = stringToBytes32 ( _symbol ) ; name = _name ; return true ; }
","Sets platform address , assigns symbol and name .
"
"function finalize ( ) public onlyController { assert ( token . totalSupply ( ) >= distributionCap ( ) ) ; doMint ( reserveWallet , totalReserve ) ; finalizedBlock = getBlockNumber ( ) ; token . finalize ( ) ; token . changeController ( controller ) ; Finalized ( ) ; }
","This method can be called the distribution cap is reached only
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { testmonedarecipiente spender = testmonedarecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it
"
"function setMaxSecurityGuardDelay ( uint _maxSecurityGuardDelay ) onlyOwner external { maxSecurityGuardDelay = _maxSecurityGuardDelay ; }
","` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment
"
"function purchase ( uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . hasAnyAttrs ( _tokenId , ATTR_GOLDENGOOSE ) ) ; address oldOwner = ethernautsStorage . ownerOf ( _tokenId ) ; address newOwner = msg . sender ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( oldOwner != newOwner ) ; require ( newOwner != address ( 0 ) ) ; require ( msg . value >= sellingPrice ) ; uint256 payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee1Step ) , 100 ) ) ; uint256 purchaseExcess = SafeMath . sub ( msg . value , sellingPrice ) ; uint256 newPrice = sellingPrice ; if ( sellingPrice < firstStepLimit ) { newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage1Step ) , percentageBase ) ; } else if ( sellingPrice < secondStepLimit ) { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee2Step ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage2Step ) , percentageBase ) ; } else { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFeeSteps ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentageSteps ) , percentageBase ) ; } if ( oldOwner != address ( this ) ) { oldOwner . transfer ( payment ) ; } ethernautsStorage . transfer ( oldOwner , newOwner , _tokenId ) ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; Purchase ( _tokenId , sellingPrice , newPrice , oldOwner , newOwner ) ; msg . sender . transfer ( purchaseExcess ) ; }
","Allows someone buy obtain an GoldenGoose asset token
"
"function setTransfersEnabled ( bool enable ) onlyOwner public { transfersEnabled = enable ; }
","Use for disable transfers before exchange to main BOB tokens
"
"function getInfo ( string _zitetag ) external view returns ( string ) { bytes32 hash = keccak256 ( abi . encodePacked ( 'zitetag.' , _zitetag ) ) ; string memory info = zer0netDb . getString ( hash ) ; return ( info ) ; }
","Retrieves the registration info for the given zitetag .
"
"function verifyModule ( address _moduleFactory , bool _verified ) external onlyOwner returns ( bool ) { require ( registry [ _moduleFactory ] != 0 , ""Module factory should have been already registered"" ) ; verified [ _moduleFactory ] = _verified ; emit LogModuleVerified ( _moduleFactory , _verified ) ; return true ; }
","( The only exception to this is that the author of the module is the owner of the ST )
"
"function updateContract ( string _contractName , address _newAddress ) external ;
","Update an existing contract ( changing the address )
"
"function create ( ) payable external { if ( getState ( ) != State . Funding ) throw ; if ( msg . value == 0 ) throw ; uint256 createdTokens = safeMul ( msg . value , tokensPerEther ) ; totalSupply = safeAdd ( totalSupply , createdTokens ) ; if ( totalSupply > tokenCreationMax ) throw ; balances [ msg . sender ] = safeAdd ( balances [ msg . sender ] , createdTokens ) ; Transfer ( 0 , msg . sender , createdTokens ) ; }
","Create tokens when funding is active .
"
"function roundMoneyUpToWholeFinney ( uint _valueWei ) constant internal returns ( uint valueFinney ) { return ( 1 finney + _valueWei - 1 wei ) / 1 finney ; }
","Convert ` _valueWei ` into a whole number of finney .
"
"function approveSynthesizing ( address _address , uint256 _yangId ) external whenNotPaused { require ( _owns ( msg . sender , _yangId ) ) ; synthesizeAllowedToAddress [ _yangId ] = _address ; }
","Grants approval to another user to synthesize with one of your Kydys .
"
"function moveTokens ( address _to , bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses whenNotPaused external { rntTokenVault . moveTokensToAddress ( _uuid , _to , _tokensCount ) ; }
","Function for transfering tokens from account to specified address .
"
"function setLiquidPledging ( address _newLiquidPledging ) public onlyOwner { require ( address ( liquidPledging ) == 0x0 ) ; liquidPledging = LiquidPledging ( _newLiquidPledging ) ; }
","` onlyOwner ` used to attach a specific liquidPledging instance to this LPvault ; keep in mind that once a liquidPledging contract is attached it can not be undone , this vault will be forever connected
"
"function unpause ( ) public onlyManager { paused = false ; }
","This is public rather than external so it can be called by derived contracts .
"
"function getContentHash ( bytes32 question_id ) public view returns ( bytes32 ) { }
","Returns the questions 's content hash , identifying the question content
"
"function unlock ( ) external onlyOwner vaultLocked { require ( unlockedAt == 0 , ""Must not be unlocked yet"" ) ; require ( block . timestamp >= lockedAt . add ( vestingPeriod ) , ""Lock up must be over"" ) ; unlockedAt = block . timestamp ; emit Unlocked ( ) ; }
","Unlock the vault , allowing the tokens to be distributed to their beneficiaries .
"
"function getModulesByTypeAndToken ( uint8 _moduleType , address _securityToken ) external view returns ( address [ ] ) ;
","Returns the list of available Module factory addresses of a particular type for a given token .
"
"function getMinerBlock ( ) public constant returns ( uint256 ) { return getBlockOf ( msg . sender ) ; }
","Return the block in which the miner is
"
"function claimTokensByMerkleProof ( bytes32 [ ] _proof , bytes32 _operationId , uint _position , uint _amount ) external whenNotPaused returns ( uint ) { bytes32 leaf = _calculateMerkleLeaf ( _operationId , _position , msg . sender , _amount ) ; require ( completedAirdrops [ _operationId ] == false , ""AIRDROP_ALREADY_CLAIMED"" ) ; require ( checkMerkleProof ( merkleRoot , _proof , _position , leaf ) , ""AIRDROP_INVALID_PROOF"" ) ; require ( token . transfer ( msg . sender , _amount ) , ""AIRDROP_TRANSFER_FAILURE"" ) ; completedAirdrops [ _operationId ] = true ; emit LogAirdropClaimed ( msg . sender , _operationId , _amount ) ; return OK ; }
","Claim tokens held by airdrop contract based on proof provided by sender ` msg.sender ` based on position ` _position ` in airdrop list .
"
"function transferExternalToken ( address _kAddr , address _to , uint _amount ) public returns ( bool ) ;
","Salvage ` _amount ` tokens at ` _kaddr ` and send them to ` _to `
"
"function addNewAirdrop ( uint _tokenAmount , string _name , uint _countDown , address _smartContract ) public minEth payable { Token t = Token ( _smartContract ) ; if ( t . balanceOf ( this ) >= _tokenAmount ) { uint lastIndex = airdrops . length ++ ; Airdrop storage airdrop = airdrops [ lastIndex ] ; airdrop . id = idCounter ; airdrop . tokenAmount = _tokenAmount ; airdrop . name = _name ; airdrop . countDown = _countDown ; airdrop . distributor = msg . sender ; airdrop . tokenSC = Token ( _smartContract ) ; airdrop . uniqueAirdrop [ msg . sender ] = _smartContract ; idCounter = airdrop . id + 1 ; } else revert ( 'Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop' ) ; }
","Adds a new airdrop to the smart contract and starts the count down until it is distributed
"
"function getApplicationAddress ( ) external view returns ( address ) { return currentApplicationEntityAddress ; }
","Get current ApplicationEntity Contract address
"
"function getSale ( uint256 _tokenId ) external view returns ( address seller , uint256 startingPrice , uint256 endingPrice , uint256 duration , uint256 startedAt , uint256 [ 9 ] tokenIds ) { Sale memory sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; return ( sale . seller , sale . startingPrice , sale . endingPrice , sale . duration , sale . startedAt , sale . tokenIds ) ; }
","Fetches the details related to the Sale
"
"function registerToken ( uint32 _tokenCode , address _tokenAddress , uint8 _tokenDecimals ) public onlyOwner ;
","Allows the owner to register and the details for a token .
"
"function getListingContractAddress ( ) external view returns ( address ) { return currentApp . ListingContractEntity ( ) ; }
","Get current Listing Contract address
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { return transferFromWithData ( _from , _to , _value , """" ) ; }
","Overloaded version of the transferFrom function
"
"function initialize ( address _snt , address _sntController , uint256 _startBlock , uint256 _endBlock , address _dynamicCeiling , address _destEthDevs , address _destTokensReserve , address _destTokensSgt , address _destTokensDevs , address _sgt , uint256 _maxSGTSupply ) public onlyOwner { require ( address ( SNT ) == 0x0 ) ; SNT = MiniMeToken ( _snt ) ; require ( SNT . totalSupply ( ) == 0 ) ; require ( SNT . controller ( ) == address ( this ) ) ; require ( SNT . decimals ( ) == 18 ) ; require ( _sntController != 0x0 ) ; sntController = _sntController ; require ( _startBlock >= getBlockNumber ( ) ) ; require ( _startBlock < _endBlock ) ; startBlock = _startBlock ; endBlock = _endBlock ; require ( _dynamicCeiling != 0x0 ) ; dynamicCeiling = DynamicCeiling ( _dynamicCeiling ) ; require ( _destEthDevs != 0x0 ) ; destEthDevs = _destEthDevs ; require ( _destTokensReserve != 0x0 ) ; destTokensReserve = _destTokensReserve ; require ( _destTokensSgt != 0x0 ) ; destTokensSgt = _destTokensSgt ; require ( _destTokensDevs != 0x0 ) ; destTokensDevs = _destTokensDevs ; require ( _sgt != 0x0 ) ; SGT = MiniMeToken ( _sgt ) ; require ( _maxSGTSupply >= MiniMeToken ( SGT ) . totalSupply ( ) ) ; maxSGTSupply = _maxSGTSupply ; }
","This method should be called by the owner before the contribution period starts This initializes most of the parameters
"
"function mint ( address _to , uint _amount ) public onlyForeignBridge returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _to ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _to ] , previousBalanceTo + _amount ) ; emit Mint ( _to , _amount ) ; emit Transfer ( 0x0 , _to , _amount ) ; return true ; }
","Mints ` _amount ` tokens that are assigned to ` _owner `
"
"function upgradeController ( address _newControllerAddress ) public onlyOwner { tokenContract . changeController ( _newControllerAddress ) ; UpgradedController ( _newControllerAddress ) ; }
","` onlyOwner ` can upgrade the controller contract
"
"function initialize ( address _token , address _destTokensReserve , address _destTokensTeam , address _destTokensBounties , address _destTokensAirdrop , address _destTokensAdvisors , address _destTokensEarlyInvestors ) public onlyOwner { require ( address ( token ) == 0x0 ) ; token = MiniMeToken ( _token ) ; require ( token . totalSupply ( ) == 0 ) ; require ( token . controller ( ) == address ( this ) ) ; require ( token . decimals ( ) == 8 ) ; require ( _destTokensReserve != 0x0 ) ; destTokensReserve = _destTokensReserve ; require ( _destTokensTeam != 0x0 ) ; destTokensTeam = _destTokensTeam ; require ( _destTokensBounties != 0x0 ) ; destTokensBounties = _destTokensBounties ; require ( _destTokensAirdrop != 0x0 ) ; destTokensAirdrop = _destTokensAirdrop ; require ( _destTokensAdvisors != 0x0 ) ; destTokensAdvisors = _destTokensAdvisors ; require ( _destTokensEarlyInvestors != 0x0 ) ; destTokensEarlyInvestors = _destTokensEarlyInvestors ; }
","This method should be called by the owner before the contribution period starts This initializes most of the parameters
"
"function initiateCreateSale ( uint256 _tokenId , uint256 _startingPrice , uint256 _endingPrice , uint256 _duration ) external { require ( _tokenId != 0 ) ; address owner = ownerOf ( _tokenId ) ; require ( owner == msg . sender ) ; require ( _startingPrice == _startingPrice ) ; require ( _endingPrice == _endingPrice ) ; require ( _duration == _duration ) ; require ( checkIsAttached ( _tokenId ) == 0 ) ; _approveForSale ( msg . sender , address ( saleManagerAddress ) , _tokenId ) ; saleManagerAddress . createSale ( _tokenId , _startingPrice , _endingPrice , _duration , msg . sender ) ; }
","Helps a wallet to create a sale using our Sale Contract
"
"function checkMonthlyLimit ( address _owner ) external constant returns ( uint256 remaining ) { return monthlyLimit [ _owner ] ; }
","Check how much Casino withdrawal balance remains for address
"
"function addValidator ( address validator , string description ) external ;
","Add account ` validator ` as a validator with a description ` description ` who can be approved to set attributes of specific types .
"
"function ( ) public payable { }
","Any funds sent here are for dividend payment .
"
"function rollbackTransfer ( address _from , address _to , uint _value ) onlyPayloadSize ( 3 * 32 ) onlyMultiSig { balances [ _to ] = balances [ _to ] . sub ( _value ) ; balances [ _from ] = balances [ _from ] . add ( _value ) ; LogRollbackTransfer ( _from , _to , _value ) ; Transfer ( _from , _to , _value ) ; }
","Rollback transfer .
"
"function addToken ( address token_address ) doesNotExist ( token_address ) returns ( address ) { address manager_address ; manager_address = new ChannelManagerContract ( token_address ) ; registry [ token_address ] = manager_address ; tokens . push ( token_address ) ; TokenAdded ( token_address , manager_address ) ; return manager_address ; }
","Register a new ERC20 token
"
"function getInstructions ( ) external view returns ( string ) { return ""Create ERC20 dividend to be paid out to token holders based on their balances at dividend creation time"" ; }
","Returns the instructions associated with the module
"
"function finalize ( ) onlyOwner { require ( stage ( ) == Stage . Closed ) ; uint256 unsold = publicSupply . sub ( officialSold_ . get ( ) ) . sub ( channelsSold ) ; if ( unsold > 0 ) { ven . offerBonus ( unsold ) ; } ven . seal ( ) ; finalized = true ; onFinalized ( ) ; }
","finalize
"
"function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = DISTRIBUTE ; return allPermissions ; }
","Return the permissions flag that are associated with STO
"
"function updateERC165Cache ( address _contract , bytes4 _interfaceId ) external { interfaces [ _contract ] [ _interfaceId ] = implementsERC165InterfaceNoCache ( _contract , _interfaceId ) ? _contract : 0 ; erc165Cached [ _contract ] [ _interfaceId ] = true ; }
","Updates the cache with whether the contract implements an ERC165 interface or not .
"
"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; allStarIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function getUpperSTVersionBounds ( ) external view returns ( uint8 [ ] ) ;
","Used to get the upper bound
"
"function renew ( uint256 _tokenId , uint256 _numCycles ) external payable whenNotPaused { require ( _numCycles != 0 ) ; require ( ownerOf ( _tokenId ) != address ( 0 ) ) ; uint256 productId = licenseProductId ( _tokenId ) ; _requireRenewableProduct ( productId ) ; uint256 renewalCost = costForProductCycles ( productId , _numCycles ) ; require ( msg . value == renewalCost ) ; _performRenewal ( _tokenId , _numCycles ) ; if ( renewalCost > 0 && licenseAffiliate ( _tokenId ) != address ( 0 ) && _affiliateProgramIsActive ( ) && licenseIssuedTime ( _tokenId ) . add ( renewalsCreditAffiliatesFor ) > now ) { _handleAffiliate ( licenseAffiliate ( _tokenId ) , productId , _tokenId , msg . value ) ; } }
","Renews a subscription
"
"function removeOfficialOperator ( address _operator ) external onlyOwner { require ( mIsOfficialOperator [ _operator ] , ""_operator is not an official operator."" ) ; mIsOfficialOperator [ _operator ] = false ; emit OfficialOperatorRemoved ( _operator ) ; }
","Delete an address from the list of official operators .
"
"function disapproveAll ( address _to ) public { require ( _to != msg . sender , ""cant unapprove yourself"" ) ; delete operatorApprovals [ msg . sender ] [ _to ] ; emit ApprovalForAll ( msg . sender , _to , false ) ; }
","Removes approval for another address to claim for the ownership of any tokens owned by this account .
"
"function getFinalAnswer ( bytes32 question_id ) stateFinalized ( question_id ) external constant returns ( bytes32 ) { return questions [ question_id ] . best_answer ; }
","Return the final answer to the specified question , or revert if there is n't one
"
"function getMinerHashRate ( uint256 _halving ) public constant returns ( bool , uint256 ) { return getHashRateOf ( msg . sender , _halving ) ; }
","Calculate the halving hash rate of a miner
"
"function transferAndCall ( address _to , uint _amount , bytes _data ) public returns ( bool ) { require ( transfer ( _to , _amount ) ) ; emit Transfer ( msg . sender , _to , _amount , _data ) ; if ( isContract ( _to ) ) { ERC677Receiver ( _to ) . tokenFallback ( msg . sender , _amount , _data ) ; } return true ; }
","` msg.sender ` transfers ` _amount ` to ` _to ` contract and then tokenFallback ( ) function is triggered in the ` _to ` contract .
"
"function deposit ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . verifyAccount ( account ) , ""Error: Account is not verified!"" ) ; require ( lib . deposit ( currency , account , amount , issuerFirm ) , ""Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered"" ) ; return true ; }
","Issues a specified account to recipient account of a given currency
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value <= approved [ _from ] [ msg . sender ] ) ; approved [ _from ] [ msg . sender ] = approved [ _from ] [ msg . sender ] . minus ( _value ) ; _transfer ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` on behalf of ` _from `
"
"function setPreferredCurrency ( bytes4 currencyKey ) external optionalProxy { require ( currencyKey == 0 || ! exchangeRates . rateIsStale ( currencyKey ) , ""Currency rate is stale or doesn't exist."" ) ; synthetixState . setPreferredCurrency ( messageSender , currencyKey ) ; emitPreferredCurrencyChanged ( messageSender , currencyKey ) ; }
","Set your preferred currency .
"
"function proxyPayment ( address _owner ) payable public returns ( bool ) { return false ; }
","Called when ` _owner ` sends ether to the MiniMe Token contract
"
"function unfreezeAccount ( address target ) onlyOwner public { require ( frozenAccount [ target ] . frozen ) ; require ( frozenAccount [ target ] . till < now ) ; frozenInfo memory fi = frozenInfo ( false , 0 ) ; frozenAccount [ target ] = fi ; FrozenFunds ( target , false , 0 ) ; }
","` unfreeze ?
"
"function setLootboxFee ( uint _fee ) external onlyOwner { lootboxFee = _fee ; }
","Change `` lootboxFee '' .
"
"function transferFrom ( bytes32 _from , bytes32 _to , uint256 _value ) returns ( bool ) { var sender = sha3 ( msg . sender ) ; var avail = allowances [ _from ] [ sender ] > balances [ _from ] ? balances [ _from ] : allowances [ _from ] [ sender ] ; if ( avail >= _value ) { allowances [ _from ] [ sender ] -= _value ; balances [ _from ] -= _value ; balances [ _to ] += _value ; TransferHash ( _from , _to , _value ) ; return true ; } return false ; }
","from ` _from ` will be sended ` _value ` tokens to ` _to `
"
"function safeWithdrawal ( ) afterDeadline stopOnPause { if ( ! fundingGoalReached && now >= finalDeadline ) { uint amount = ethBalances [ msg . sender ] ; ethBalances [ msg . sender ] = 0 ; if ( amount > 0 ) { if ( msg . sender . send ( amount ) ) { emit FundsWithdrawn ( msg . sender , amount ) ; } else { ethBalances [ msg . sender ] = amount ; } } } else if ( fundingGoalReached && treasury == msg . sender ) { if ( treasury . send ( weiRaised ) ) { emit FundsWithdrawn ( treasury , weiRaised ) ; } else if ( treasury . send ( address ( this ) . balance ) ) { emit FundsWithdrawn ( treasury , address ( this ) . balance ) ; } } }
","Lets treasury collect the funds if ` fundingGoal ` was reached .
"
"function prolongCrowdsale ( ) public onlyOwnerAndDirector { require ( now < crowdsaleEndTime ) ; crowdsaleEndTime = crowdsaleHardEndTime ; }
","extend crowdsale for 2 weeks
"
"function setTotalSupply ( uint256 _newTotalSupply ) public onlyImpl { totalSupply = _newTotalSupply ; }
","The function to set the total supply of tokens .
"
"function approve ( address _spender , uint256 _amount ) public erc20 returns ( bool success ) { mAllowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
","ERC20 backwards compatible approve .
"
"function getAllProductIds ( ) public view returns ( uint256 [ ] ) { return allProductIds ; }
","Get all product ids
"
"function _setPendingAnchorAdmin ( address newPendingAnchorAdmin ) public returns ( uint ) { if ( msg . sender != anchorAdmin ) { return failOracle ( 0 , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK ) ; } address oldPendingAnchorAdmin = pendingAnchorAdmin ; pendingAnchorAdmin = newPendingAnchorAdmin ; emit NewPendingAnchorAdmin ( oldPendingAnchorAdmin , newPendingAnchorAdmin ) ; return uint ( Error . NO_ERROR ) ; }
","Begins transfer of anchor admin rights .
"
"function changeOwner ( address _newOwner ) onlyOwner { owner = _newOwner ; NewOwner ( msg . sender , _newOwner ) ; }
","` owner ` can step down and assign some other address to this role
"
"function addAmountBoughtAsMember ( address _member , uint256 _amountBought ) external ;
","Add to the amount this member has bought
"
"function _ownerOf ( uint256 _tokenId ) internal view returns ( address ) { address owner = _tokenOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }
","Find the owner of an NFT
"
"function distributeEther ( address [ ] sellers ) onlyOwner payable public { require ( currentState == State . Distribution ) ; require ( currentPeriodRate > 0 ) ; for ( uint256 i = 0 ; i < sellers . length ; i ++ ) { address seller = sellers [ i ] ; require ( seller != address ( 0 ) ) ; uint256 tokenAmount = soldTokens [ seller ] ; if ( tokenAmount == 0 ) continue ; uint256 etherAmount = tokenAmount . div ( currentPeriodRate ) ; uint256 fee = etherAmount . mul ( sellFeeMilliPercent ) . div ( MILLI_PERCENT_DIVIDER ) ; etherAmount = etherAmount . sub ( fee ) ; soldTokens [ seller ] = 0 ; currentPeriodTokenCollected = currentPeriodTokenCollected . sub ( tokenAmount ) ; if ( ! seller . send ( etherAmount ) ) { DistributionError ( seller , etherAmount ) ; owner . transfer ( etherAmount ) ; } } }
","Distribute ether to sellers If not enough ether is available on contract ballance
"
"function setStakeContract ( address _contractAddress ) external onlyOwner nonAdminAddress ( _contractAddress ) returns ( bool ) { if ( stakeContractAddress != address ( 0 ) ) { require ( stake . activeStakes ( ) == 0 , ""staking contract already configured, to change it must have 0 active stakes"" ) ; } stakeContractAddress = _contractAddress ; minters [ _contractAddress ] = true ; stake = StakeInterface ( _contractAddress ) ; emit StakeContractSet ( _contractAddress ) ; return true ; }
","This is used to set the staking contract
"
"function getFactories ( uint256 _user_id ) public view returns ( uint256 [ ] ) { return userToFactories [ _user_id ] ; }
","get factories of user
"
"function calculateDividend ( uint256 _dividendIndex , address _payee ) public view returns ( uint256 ) { Dividend storage dividend = dividends [ _dividendIndex ] ; if ( dividend . claimed [ _payee ] ) { return 0 ; } uint256 balance = ISecurityToken ( securityToken ) . balanceOfAt ( _payee , dividends [ _dividendIndex ] . checkpointId ) ; return balance . mul ( dividends [ _dividendIndex ] . amount ) . div ( dividends [ _dividendIndex ] . totalSupply ) ; }
","Calculate amount of dividends claimable
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; require ( _index < ownerToManagerArray [ _owner ] . length ) ; return ownerToManagerArray [ _owner ] [ _index ] ; }
","Enumerate TTMs assigned to an owner
"
"function isProjectCanceled ( uint64 projectId ) constant returns ( bool ) { PledgeAdmin storage m = findAdmin ( projectId ) ; if ( m . adminType == PledgeAdminType . Giver ) return false ; assert ( m . adminType == PledgeAdminType . Project ) ; if ( m . canceled ) return true ; if ( m . parentProject == 0 ) return false ; return isProjectCanceled ( m . parentProject ) ; }
","A getter to find if a specified Project has been canceled
"
"function finalize ( ) public onlyOwner { require ( ! isFinalized , ""STO is already finalized"" ) ; isFinalized = true ; uint256 tempReturned ; uint256 tempSold ; uint256 remainingTokens ; for ( uint8 i = 0 ; i < tokensPerTierTotal . length ; i ++ ) { remainingTokens = tokensPerTierTotal [ i ] . sub ( mintedPerTierTotal [ i ] ) ; tempReturned = tempReturned . add ( remainingTokens ) ; tempSold = tempSold . add ( mintedPerTierTotal [ i ] ) ; if ( remainingTokens > 0 ) { mintedPerTierTotal [ i ] = tokensPerTierTotal [ i ] ; } } require ( ISecurityToken ( securityToken ) . mint ( reserveWallet , tempReturned ) , ""Error in minting"" ) ; emit ReserveTokenMint ( msg . sender , reserveWallet , tempReturned , currentTier ) ; finalAmountReturned = tempReturned ; totalTokensSold = tempSold ; }
","Reserve address must be whitelisted to successfully finalize
"
"function getNotaryInfo ( address notary ) public view validAddress ( notary ) returns ( address , uint256 , uint256 , string , uint32 ) { require ( hasNotaryBeenAdded ( notary ) ) ; NotaryInfo memory info = notaryInfo [ notary ] ; return ( notary , info . responsesPercentage , info . notarizationFee , info . notarizationTermsOfService , uint32 ( info . addedAt ) ) ; }
","Gets the notary information .
"
"function convertCountryIndexToBytes ( uint [ ] countries ) public pure returns ( uint countries1 , uint countries2 , uint countries3 ) { countries1 = 0 ; countries2 = 0 ; countries3 = 0 ; for ( uint i = 0 ; i < countries . length ; i ++ ) { uint index = countries [ i ] ; if ( index < 256 ) { countries1 = countries1 | uint ( 1 ) << index ; } else if ( index < 512 ) { countries2 = countries2 | uint ( 1 ) << ( index - 256 ) ; } else { countries3 = countries3 | uint ( 1 ) << ( index - 512 ) ; } } return ( countries1 , countries2 , countries3 ) ; }
","Converts country index list into 3 uints Expects a list of country indexes such that the 2 digit country code is converted to an index .
"
"function calculateWithdrawable ( ) constant returns ( uint withdrawable ) { uint timePassed = now . sub ( vestingStartTime ) ; if ( timePassed < vestingPeriod ) { uint vested = totalVestedAmount . mul ( timePassed ) . div ( vestingPeriod ) ; withdrawable = vested . sub ( withdrawn ) ; } else { withdrawable = totalVestedAmount . sub ( withdrawn ) ; } }
","Calculates the quantity of Melon asset that 's currently withdrawable
"
"function proxyPayment ( address _owner ) public payable whenNotPaused returns ( bool ) { doPayment ( _owner ) ; return true ; }
","` proxyPayment ( ) ` allows the caller to send ether to the Campaign and have the tokens created in an address of their choosing
"
"function updateWhitelist ( address _account , uint8 _phase ) external onlyCapper returns ( bool ) { require ( _account != address ( 0 ) ) ; _updateWhitelist ( _account , _phase ) ; return true ; }
","function to whitelist an address which can be called only by the capper address .
"
"function havvensReceivedForEther ( uint amount ) public view returns ( uint ) { uint valueSentInNomins = safeMul_dec ( amount , usdToEthPrice ) ; return havvensReceivedForNomins ( valueSentInNomins ) ; }
","Calculate how many havvens you will receive if you transfer an amount of ether .
"
"function getValidatorDescription ( address validator ) external view returns ( string description ) { return _validators [ validator ] . description ; }
","Get a description of the validator at account ` validator ` .
"
"function _clearApprovalAndTransfer ( address _from , address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; require ( _to != ownerOf ( _tokenId ) ) ; require ( ownerOf ( _tokenId ) == _from ) ; require ( _isValidLicense ( _tokenId ) ) ; _clearApproval ( _from , _tokenId ) ; _removeToken ( _from , _tokenId ) ; _addToken ( _to , _tokenId ) ; Transfer ( _from , _to , _tokenId ) ; }
","Internal function to clear current approval and transfer the ownership of a given token ID
"
"function finished ( ) public { require ( state == State . Successful ) ; require ( beneficiary . send ( this . balance ) ) ; uint256 remaining = tokenReward . balanceOf ( this ) ; tokenReward . transfer ( beneficiary , remaining ) ; LogBeneficiaryPaid ( beneficiary ) ; }
","closure handler
"
"function approve ( address _spender , uint _value ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to transfer ` _value ` tokens from ` msg.sender ` to any address .
"
"function setMinContribution ( uint256 _minContribution ) public onlyOwner beforeSale { minContribution = _minContribution ; }
","Sets min contribution before sale
"
"function isLocked ( ) public constant returns ( bool success ) { return lockedUntilBlock > block . number ; }
","Are transfers currently disallowed
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint256 _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function setBalance ( address _owner , uint256 _newBalance ) public onlyImpl { balances [ _owner ] = _newBalance ; }
","Sets the balance of ` _owner ` to ` _newBalance ` .
"
"function revealVote ( uint _pollID , uint _voteOption , uint _salt ) external { require ( revealPeriodActive ( _pollID ) ) ; require ( ! hasBeenRevealed ( msg . sender , _pollID ) ) ; require ( keccak256 ( _voteOption , _salt ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) pollMap [ _pollID ] . votesFor += numTokens ; else pollMap [ _pollID ] . votesAgainst += numTokens ; dllMap [ msg . sender ] . remove ( _pollID ) ; VoteRevealed ( msg . sender , _pollID , numTokens , _voteOption ) ; }
","Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens
"
"function updatePrices ( uint newEthPrice , uint newHavvenPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent , ""Time must be later than last update"" ) ; require ( timeSent < ( now + ORACLE_FUTURE_LIMIT ) , ""Time must be less than now + ORACLE_FUTURE_LIMIT"" ) ; usdToEthPrice = newEthPrice ; usdToHavPrice = newHavvenPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToHavPrice , lastPriceUpdateTime ) ; }
","Access point for the oracle to update the prices of havvens / eth .
"
"function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ;
","Get the account balance of address _owner
"
"function withdrawAuctionBalances ( ) external { if ( saleAuctionContract . addressToEtherOwed ( msg . sender ) > 0 ) { saleAuctionContract . withdrawAuctionBalance ( msg . sender ) ; } if ( rentAuctionContract . addressToEtherOwed ( msg . sender ) > 0 ) { rentAuctionContract . withdrawAuctionBalance ( msg . sender ) ; } }
","Allow withdrawing balances from the auction contracts in a single step .
"
"function _supportsAllInterfaces ( address account , bytes4 [ ] interfaceIds ) internal view returns ( bool ) { if ( ! _supportsERC165 ( account ) ) { return false ; } for ( uint256 i = 0 ; i < interfaceIds . length ; i ++ ) { if ( ! _supportsERC165Interface ( account , interfaceIds [ i ] ) ) { return false ; } } return true ; }
","Query if a contract implements interfaces , also checks support of ERC165
"
"function airdropTokens ( address _tokenAddress , uint _totalTokensToDistribute , uint _expirationTime ) public ifNotPaused { require ( tokenWhitelist [ _tokenAddress ] ) ; require ( ! airdropperBlacklist [ msg . sender ] ) ; uint tokensForOwner = _totalTokensToDistribute . mul ( ownersCut ) . div ( 100 ) ; _totalTokensToDistribute = _totalTokensToDistribute . sub ( tokensForOwner ) ; TokenAirdropID memory taid = TokenAirdropID ( _tokenAddress , airdroppedTokens [ _tokenAddress ] . length ) ; TokenAirdrop memory ta = TokenAirdrop ( _tokenAddress , airdroppedTokens [ _tokenAddress ] . length , msg . sender , now , now + _expirationTime , _totalTokensToDistribute , _totalTokensToDistribute , userSignupCount ) ; airdroppedTokens [ _tokenAddress ] . push ( ta ) ; airdrops . push ( taid ) ; E_AirdropSubmitted ( _tokenAddress , ta . tokenOwner , ta . totalDropped , ta . airdropDate , ta . airdropExpirationDate ) ; }
","Before calling this function , you must have given the Airdrop Central an allowance of the tokens to distribute .
"
"function totalSupplyAt ( uint _blockNumber ) public constant returns ( uint ) ;
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function setApprovalForAll ( address _operator , bool _approved ) external { operatorApprovals [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
","Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets
"
"function isLocked ( address _target ) public view returns ( bool ) { if ( locked [ _target ] > now ) { return true ; } else { return false ; } }
","Getter returns false if tokens are available and true if unavailable
"
"function buy ( ) payable public { require ( ! frozenAccount [ msg . sender ] ) ; require ( msg . value > 0 ) ; uint commission = msg . value / buyCommission ; require ( address ( this ) . send ( commission ) ) ; buyToken ( ) ; }
","Buy metadollars from contract by sending ether
"
"function releaseCarbonDollar ( uint256 _amount ) public onlyOwner returns ( bool ) { require ( _amount <= balanceOf ( address ( this ) ) , ""not enough balance to transfer"" ) ; tokenStorage . subBalance ( address ( this ) , _amount ) ; tokenStorage . addBalance ( msg . sender , _amount ) ; emit Transfer ( address ( this ) , msg . sender , _amount ) ; return true ; }
","release collected CUSD fees to owner
"
"function getAllModulesAndPermsFromTypes ( address _delegate , uint8 [ ] _types ) external view returns ( address [ ] , bytes32 [ ] ) { uint256 counter = 0 ; for ( uint256 i = 0 ; i < _types . length ; i ++ ) { address [ ] memory _currentTypeModules = ISecurityToken ( securityToken ) . getModulesByType ( _types [ i ] ) ; for ( uint256 j = 0 ; j < _currentTypeModules . length ; j ++ ) { bytes32 [ ] memory _allModulePerms = IModule ( _currentTypeModules [ j ] ) . getPermissions ( ) ; for ( uint256 k = 0 ; k < _allModulePerms . length ; k ++ ) { if ( perms [ _currentTypeModules [ j ] ] [ _delegate ] [ _allModulePerms [ k ] ] ) { counter ++ ; } } } } address [ ] memory _allModules = new address [ ] ( counter ) ; bytes32 [ ] memory _allPerms = new bytes32 [ ] ( counter ) ; counter = 0 ; for ( i = 0 ; i < _types . length ; i ++ ) { _currentTypeModules = ISecurityToken ( securityToken ) . getModulesByType ( _types [ i ] ) ; for ( j = 0 ; j < _currentTypeModules . length ; j ++ ) { _allModulePerms = IModule ( _currentTypeModules [ j ] ) . getPermissions ( ) ; for ( k = 0 ; k < _allModulePerms . length ; k ++ ) { if ( perms [ _currentTypeModules [ j ] ] [ _delegate ] [ _allModulePerms [ k ] ] ) { _allModules [ counter ] = _currentTypeModules [ j ] ; _allPerms [ counter ] = _allModulePerms [ k ] ; counter ++ ; } } } } return ( _allModules , _allPerms ) ; }
","Used to return all permission of a single or multiple module
"
"function countOfDeeds ( ) public view returns ( uint256 _count ) ;
","Count deeds tracked by this contract
"
"function vote ( uint256 [ ] _votes ) public { require ( _votes . length == itemCount ) ; require ( now >= start && now < end ) ; address voter = msg . sender ; if ( ! voted [ voter ] ) { voted [ voter ] = true ; voters . push ( voter ) ; } for ( uint256 i = 0 ; i < itemCount ; i ++ ) { require ( _votes [ i ] >= voteItems [ i ] . minValue && _votes [ i ] <= voteItems [ i ] . maxValue ) ; voteItems [ i ] . votes [ voter ] = _votes [ i ] ; } }
","Function to case vote in this carbon voting
"
"function Tradable ( ) public view returns ( bool ) { return tradable ; }
","shows tradability of the contract
"
"function transferEther ( address _to , uint256 _value ) public onlyContractOwner { require ( _to != 0x0 , ""INVALID_ETHER_RECEPIENT_ADDRESS"" ) ; if ( _value > address ( this ) . balance ) { revert ( ""INVALID_VALUE_TO_TRANSFER_ETHER"" ) ; } _to . transfer ( _value ) ; }
","Transfers ether to another address .
"
"function claimPayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( job . worker == msg . sender ) ; require ( job . noOfPaymentsMade > 0 ) ; uint payment = job . paymentAvailableForWorker ; require ( payment > 0 ) ; job . paymentAvailableForWorker = 0 ; job . totalPaidToWorker = job . totalPaidToWorker + payment ; emit PaymentClaimed ( msg . sender , payment , _JobID ) ; DAI . transfer ( msg . sender , payment ) ; }
","this function lets the worker claim the approved payment
"
"function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = CHANGE_PERMISSION ; return allPermissions ; }
","Use to get the Permission flag related the ` this ` contract
"
"function setNewToken ( address _newToken ) external { if ( msg . sender != owner ) revert ( ) ; if ( _newToken == 0x0 ) revert ( ) ; if ( upgradeHasBegun ) revert ( ) ; newToken = NewDecentBetToken ( _newToken ) ; if ( ! newToken . isNewToken ( ) ) revert ( ) ; NewTokenSet ( newToken ) ; }
","Sets the new token contract address
"
"function register ( uint32 _expectedStartDate ) external payable { require ( REGISTRATION_FEE . mul ( NUM_REGISTER_DAYS ) == msg . value ) ; require ( _expectedStartDate <= getDate ( uint32 ( now ) ) . add ( NINETY_DAYS ) ) ; uint32 startDate = getStartDate ( ) ; require ( startDate == _expectedStartDate ) ; for ( uint32 i = 0 ; i < NUM_REGISTER_DAYS ; i ++ ) { uint32 date = startDate . add ( i . mul ( DAY ) ) ; require ( userDateToStatus [ msg . sender ] [ date ] == UserEntryStatus . NULL ) ; userDateToStatus [ msg . sender ] [ date ] = UserEntryStatus . REGISTERED ; userToDates [ msg . sender ] . push ( date ) ; dateToUsers [ date ] . push ( msg . sender ) ; dateToContestStatus [ date ] . numRegistered += 1 ; } }
","Changes state
"
"function addBalanceFor ( address account , uint256 value ) public { lockedBalances [ account ] = lockedBalances [ account ] . add ( value ) ; token . safeTransferFrom ( msg . sender , address ( this ) , value ) ; }
","To be called by the account that holds Mio tokens .
"
"function setCampaign ( address _campaign ) public { }
","enables the setting of the campaign , if any
"
"function setPeriodDuration ( uint64 _periodDuration ) external authP ( CHANGE_PERIOD_ROLE , arr ( uint256 ( _periodDuration ) , uint256 ( settings . periodDuration ) ) ) transitionsPeriod { require ( _periodDuration >= 1 days , ERROR_SET_PERIOD_TOO_SHORT ) ; settings . periodDuration = _periodDuration ; emit ChangePeriodDuration ( _periodDuration ) ; }
","Change period duration to ` @ transformTime ( _periodDuration ) ` , effective for next accounting period
"
"function buy ( ) whenNotPaused whenSaleRunning private { address buyer = msg . sender ; totalContributions += msg . value ; uint tokensPurchased = purchaseTokens ( ) ; totalTokensPurchased = add ( totalTokensPurchased , tokensPurchased ) ; uint previousBalance = balances [ buyer ] ; balances [ buyer ] = add ( previousBalance , tokensPurchased ) ; if ( previousBalance == 0 ) { contributors . push ( buyer ) ; } emit Purchase ( buyer , msg . value , tokensPurchased ) ; }
","Executes a purchase .
"
"function removeAddressFromWhitelistAndRefund ( address _address ) public isWhitelistEnabled canDeposit ( _address ) { whitelist [ _address ] = false ; refundAddress ( _address ) ; }
","Removes a user from the whitelist and processes a refund .
"
"function getPrices ( address [ ] ofAssets ) view returns ( uint [ ] , uint [ ] ) { uint [ ] memory prices = new uint [ ] ( ofAssets . length ) ; uint [ ] memory timestamps = new uint [ ] ( ofAssets . length ) ; for ( uint i ; i < ofAssets . length ; i ++ ) { var ( price , timestamp ) = getPrice ( ofAssets [ i ] ) ; prices [ i ] = price ; timestamps [ i ] = timestamp ; } return ( prices , timestamps ) ; }
","Price of a registered asset in format ( bool areRecent , uint [ ] prices , uint [ ] decimals )
"
"function getSecurityTokenAddress ( string _ticker ) external view returns ( address ) { string memory ticker = Util . upper ( _ticker ) ; return getAddress ( Encoder . getKey ( ""tickerToSecurityToken"" , ticker ) ) ; }
","Returns the security token address by ticker symbol
"
"function archiveModule ( address _module ) external ;
","Archives a module attached to the SecurityToken
"
"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; return address ( new ERC20DividendCheckpoint ( msg . sender , address ( polyToken ) ) ) ; }
","used to launch the Module with the help of factory
"
"function sencToken ( ) public view returns ( ERC20Basic ) { return ERC20Basic ( SENC_CONTRACT_ADDRESS ) ; }
","The ` sencToken ( ) ` is the getter for the SENC Token .
"
"function getTotalGames ( ) public view returns ( uint ) { return games . length ; }
","Returns the total number of games
"
"function resoucesOf ( ) public view returns ( uint256 [ ] ) { return users [ addressToUser [ msg . sender ] ] . resources ; }
","getter for resources of user
"
"function redeemLevAndFeeByStaker ( ) external { redeemLevAndFee ( msg . sender ) ; }
","To unlock and recover your LEV and FEE tokens after staking and fee to any user
"
"function freezeAccount ( address account , bool freeze ) isOwner { require ( account != owner ) ; require ( account != supervisor ) ; frozenAccount [ account ] = freeze ; if ( freeze ) { FrozenFunds ( msg . sender , account , ""Account set frozen!"" ) ; } else { FrozenFunds ( msg . sender , account , ""Account set free for use!"" ) ; } }
","'freeze ?
"
"function finished ( ) public { require ( state == State . Successful ) ; uint256 remainder = tokenReward . balanceOf ( this ) ; require ( creator . send ( this . balance ) ) ; tokenReward . transfer ( creator , remainder ) ; LogBeneficiaryPaid ( creator ) ; LogContributorsPayout ( creator , remainder ) ; }
","Function for closure handle
"
"function transfer ( address _to , uint256 _value , bytes _data ) external isRunning noFreeze returns ( bool success ) { if ( _to == selfAddress ) { return transferToSelf ( _value ) ; } else if ( isContract ( _to ) ) { return transferToContract ( _to , _value , _data ) ; } else { return transferToAddress ( _to , _value ) ; } }
","Transfer the specified amount to the target address with embedded bytes data ~ ERC-223 Proposed Standard
"
"function contributionOpen ( ) public constant returns ( bool ) { Tier tier = tiers [ tierCount ] ; return ( getBlockTimestamp ( ) >= tier . startTime ( ) && getBlockTimestamp ( ) <= tier . endTime ( ) && tier . finalizedTime ( ) == 0 ) ; }
","Provides information if contribution is open
"
"function ( ) payable internal { uint amount = msg . value * buyPrice ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
","Buy tokens from contract by sending ether
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; } doTransfer ( _from , _to , _amount ) ; return true ; }
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function updateClient ( address _newClient ) ;
","Function to update the client address
"
"function totalSold ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . sold ; }
","The total sold of a product
"
"function initialize ( address _permissionsCreator ) public onlyInit { initialized ( ) ; require ( msg . sender == address ( kernel ( ) ) , ERROR_AUTH_INIT_KERNEL ) ; _createPermission ( _permissionsCreator , this , CREATE_PERMISSIONS_ROLE , _permissionsCreator ) ; }
","Initialize an ACL instance and set ` _permissionsCreator ` as the entity that can create other permissions
"
"function initializeTokenSaleWithToken ( uint _saleStartTime , uint _saleEndTime , uint _price , uint _amountForSale , address _beneficiary , address _tokenAddress ) public ownerOnly { buyModeEth = false ; payableTokenAddress = _tokenAddress ; initializeSale ( _saleStartTime , _saleEndTime , _price , _amountForSale , _beneficiary ) ; }
","Uses the same signature as initializeTokenSale ( ) with :
"
"function withdraw ( ERC20 _token , uint256 _value , bytes _signature ) external withBrokerSignatureOrSignal ( _token , _signature ) { address trader = msg . sender ; privateDecrementBalance ( trader , _token , _value ) ; if ( address ( _token ) == ETHEREUM ) { trader . transfer ( _value ) ; } else { CompatibleERC20 ( _token ) . safeTransfer ( trader , _value ) ; } }
","Withdraws ETH or an ERC20 token from the contract .
"
"function getPriceOfCampaign ( bytes32 bidId ) public view returns ( uint price ) { return advertisementStorage . getCampaignPriceById ( bidId ) ; }
","Get the price of a campaign Based on the Campaign id return the value paid for each proof of attention registered .
"
"function setGenerationSeasonController ( uint256 _season ) public onlyManager whenNotPaused { require ( generationSeasonController [ _season ] == 0 ) ; _updateGenerationSeasonFlag ( _season , 1 ) ; }
","_value of 1 : means generation of collectible is allowed .
"
"function getRequest ( bytes32 _requestId ) external view returns ( address payer , address currencyContract , State state , address payeeAddr , int256 payeeExpectedAmount , int256 payeeBalance ) { Request storage r = requests [ _requestId ] ; return ( r . payer , r . currencyContract , r . state , r . payee . addr , r . payee . expectedAmount , r . payee . balance ) ; }
","Gets a request .
"
"function setFundraiseLimits ( uint _min_share_price , uint _fundraise_max ) public onlyOwner { require ( ! fundraise_defined ) ; require ( _min_share_price > 0 ) ; require ( _fundraise_max > 0 ) ; require ( status == state . ended ) ; fundraise_max = _fundraise_max ; min_share_price = _min_share_price ; emit FundraiseDefined ( min_share_price , fundraise_max ) ; fundraise_defined = true ; }
","Allows configuration of the final parameters needed for auction end state calculation .
"
"function ( ) payable { require ( isPayableEnabled && rbInformationStore . isPayableEnabledForAll ( ) ) ; if ( msg . value <= 0 ) { revert ( ) ; } uint supportedAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) . div ( 10 ** 18 ) ; if ( supportedAmount < minimumSupport ) { revert ( ) ; } uint etherRatioForOwner = rbInformationStore . etherRatioForOwner ( ) ; uint etherRatioForSponsee = uint ( 100 ) . sub ( etherRatioForOwner ) . sub ( etherRatioForInvestor ) ; uint etherForOwner = msg . value . mul ( etherRatioForOwner ) . div ( 100 ) ; uint etherForInvestor = msg . value . mul ( etherRatioForInvestor ) . div ( 100 ) ; uint etherForSponsee = msg . value . mul ( etherRatioForSponsee ) . div ( 100 ) ; address profitContainerAddress = rbInformationStore . profitContainerAddress ( ) ; address companyWalletAddress = rbInformationStore . companyWalletAddress ( ) ; if ( ! profitContainerAddress . send ( etherForInvestor ) ) { revert ( ) ; } if ( ! companyWalletAddress . send ( etherForOwner ) ) { revert ( ) ; } if ( ! sponseeAddress . send ( etherForSponsee ) ) { revert ( ) ; } uint tokenAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokenAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; if ( totalSupply > cap ) { revert ( ) ; } LogReceivedEther ( msg . sender , this , msg . value , name ) ; LogExchange ( msg . sender , this , tokenAmount ) ; Transfer ( address ( 0x0 ) , msg . sender , tokenAmount ) ; }
","Receive ether from any EOA accounts .
"
"function calcCommission ( uint _amount ) private view returns ( uint ) { return _amount . mul ( commission ) / 100 ; }
","calculates the SolidStamp commmission
"
"function contributeMethodABI ( ) public constant returns ( string ) { }
","use to determine the contribution method abi/structure
"
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) ;
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function deregisterSettlement ( uint64 _settlementID ) external onlyOwner { require ( settlementDetails [ _settlementID ] . registered , ""not registered"" ) ; delete settlementDetails [ _settlementID ] ; emit LogSettlementDeregistered ( _settlementID ) ; }
","Deregisteres a settlement layer , clearing the details .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { success = TokenTransferController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_TRANSFER ) ) . put_transfer ( msg . sender , _to , 0x0 , _value , false ) ; }
","transfer amount to account
"
"function getCard ( uint256 _tokenId ) public view returns ( string name , uint256 token , uint256 price , uint256 nextprice , string imagepath , string category , uint256 wildcard , address _owner ) { uint256 index = cardTokenToPosition [ _tokenId ] ; Card storage card = cards [ index ] ; name = card . name ; token = card . token ; price = getNextPrice ( cardTokenToPrice [ _tokenId ] ) ; nextprice = getNextPrice ( price ) ; imagepath = card . imagepath ; category = card . category ; wildcard = card . Iswildcard ; _owner = card . owner ; }
","Returns all the relevant information about a specific card .
"
"function getBasicData ( uint64 [ ] _tokenIndexes ) public view returns ( uint256 [ ] , bytes8 [ ] , address [ ] , uint64 [ ] ) { uint256 [ ] memory tokenIds = new uint256 [ ] ( _tokenIndexes . length ) ; bytes8 [ ] memory names = new bytes8 [ ] ( _tokenIndexes . length ) ; address [ ] memory owners = new address [ ] ( _tokenIndexes . length ) ; uint64 [ ] memory collectionIdxs = new uint64 [ ] ( _tokenIndexes . length ) ; for ( uint i = 0 ; i < _tokenIndexes . length ; i ++ ) { uint64 tokenIndex = _tokenIndexes [ i ] ; require ( tokenIndex < totalSupply ( ) , ""PixelCon index is out of bounds"" ) ; tokenIds [ i ] = pixelcons [ tokenIndex ] . tokenId ; names [ i ] = pixelconNames [ tokenIndex ] ; owners [ i ] = tokenLookup [ pixelcons [ tokenIndex ] . tokenId ] . owner ; collectionIdxs [ i ] = pixelcons [ tokenIndex ] . collectionIndex ; } return ( tokenIds , names , owners , collectionIdxs ) ; }
","Get the basic data for the given PixelCon indexes
"
"function closeOrder ( address orderAddr ) public whenNotPaused isOrderLegit ( orderAddr ) returns ( bool ) { require ( openOrders . exist ( orderAddr ) ) ; DataOrder order = DataOrder ( orderAddr ) ; address buyer = order . buyer ( ) ; require ( msg . sender == buyer || msg . sender == owner ) ; bool okay = order . close ( ) ; if ( okay ) { uint256 remainingBudget = buyerRemainingBudgetForAudits [ buyer ] [ order ] ; buyerRemainingBudgetForAudits [ buyer ] [ order ] = 0 ; require ( token . transfer ( buyer , remainingBudget ) ) ; openOrders . remove ( orderAddr ) ; emit OrderClosed ( orderAddr ) ; } return okay ; }
","Closes the DataOrder .
"
"function allowAllocation ( address _addr , bool _allow ) onlyOwner external { tokensAllocationAllowed [ _addr ] = _allow ; }
","Allow address to call allocate function .
"
"function getPolicyDetails ( bytes4 _sig , address _contract ) public view returns ( bytes32 [ ] _groupNames , uint [ ] _acceptLimits , uint [ ] _declineLimits , uint _totalAcceptedLimit , uint _totalDeclinedLimit ) { require ( _sig != bytes4 ( 0 ) ) ; require ( _contract != 0x0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; uint _policyIdx = policyId2Index [ _policyHash ] ; if ( _policyIdx == 0 ) { return ; } Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupsCount = _policy . groupsCount ; _groupNames = new bytes32 [ ] ( _policyGroupsCount ) ; _acceptLimits = new uint [ ] ( _policyGroupsCount ) ; _declineLimits = new uint [ ] ( _policyGroupsCount ) ; for ( uint _idx = 0 ; _idx < _policyGroupsCount ; ++ _idx ) { Requirements storage _requirements = _policy . participatedGroups [ _idx + 1 ] ; _groupNames [ _idx ] = _requirements . groupName ; _acceptLimits [ _idx ] = _requirements . acceptLimit ; _declineLimits [ _idx ] = _requirements . declineLimit ; } ( _totalAcceptedLimit , _totalDeclinedLimit ) = ( _policy . totalAcceptedLimit , _policy . totalDeclinedLimit ) ; }
","Check policy details
"
"function uint256Min ( uint256 a , uint256 b ) pure internal returns ( uint256 ) { return a > b ? b : a ; }
","Minimum between two uint256 numbers
"
"function lockAccount ( address _addr , uint256 _timePeriod ) onlyOwner public { lockAccounts [ _addr ] = _timePeriod ; emit AccountLocked ( _addr , _timePeriod ) ; }
","Once an account is locked it ca n't be unlocked till the time period passes
"
"function claim ( ) public { require ( msg . sender == beneficiary ) ; release ( ) ; }
","Transfers tokens held by timelock to beneficiary .
"
"function updateIssuanceData ( address account , uint preBalance , uint lastTotalSupply ) internal { totalIssuanceData = computeIssuanceData ( lastTotalSupply , totalIssuanceData ) ; if ( issuanceData [ account ] . lastModified < feePeriodStartTime ) { hasWithdrawnFees [ account ] = false ; } issuanceData [ account ] = computeIssuanceData ( preBalance , issuanceData [ account ] ) ; }
","Update the havven balance averages since the last transfer or entitlement adjustment .
"
"function getPrice ( ) public view returns ( uint ) { for ( uint i = c_priceChangeDates . length - 2 ; i > 0 ; i -- ) { if ( getTime ( ) >= c_priceChangeDates [ i ] ) { return c_tokenPrices [ i ] ; } } return c_tokenPrices [ 0 ] ; }
","get token price in cents depending on the current date
"
"function convertToCents ( uint256 _tokenAmount , uint256 _priceInCents , uint256 _decimals ) public pure returns ( uint256 ) { return _tokenAmount . mul ( _priceInCents ) . div ( 10 ** _decimals ) ; }
","Converts the amount of Ether ( wei ) or amount of any token having 18 decimal place divisibleto cent value based on the cent price supplied .
"
"function migrateEuroTokenOwner ( address owner , uint256 amount ) public onlyMigrationSource ( ) ;
","accepts migration of single eur-t token holder
"
"function hasAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool ) ;
","Check if an attribute of the type with ID ` attributeTypeID ` has been assigned to the account at ` account ` and is currently valid .
"
"function claimTokens ( address _token ) public onlyOwner { if ( ATT . controller ( ) == address ( this ) ) { ATT . claimTokens ( _token ) ; } if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function getName ( ) public view returns ( bytes32 ) { return ""EtherDividendCheckpoint"" ; }
","Get the name of the Module
"
"function amountReceivedFromExchange ( uint value ) external view returns ( uint ) { return value . divideDecimal ( exchangeFeeRate . add ( SafeDecimalMath . unit ( ) ) ) ; }
","The amount the recipient will receive if you are performing an exchange and the destination currency will be worth a certain number of tokens .
"
"function addForkedUniverse ( ) onlyInitialized external { IUniverse child_universe = IUniverse ( latest_universe ) . getWinningChildUniverse ( ) ; latest_universe = child_universe ; }
","Register a new child universe after a fork
"
"function checkDelegate ( address _potentialDelegate ) external view returns ( bool ) ;
","Used to check if an address is a delegate or not
"
"function mint ( address _to , uint256 _amount ) public onlyMinter returns ( bool ) { uint256 available = availableTokens ( ) ; require ( _amount <= available ) ; leftOnLastMint = available . sub ( _amount ) ; lastMintTime = now ; require ( token . mint ( _to , _amount ) ) ; return true ; }
","Function to mint tokens
"
"function proxyWithdraw ( address receiverAddress ) public atStage ( Stages . AuctionCanceled ) returns ( bool ) { require ( receiverAddress != 0x0 ) ; if ( bids [ receiverAddress ] == 0 ) { return false ; } uint amount = bids [ receiverAddress ] ; bids [ receiverAddress ] = 0 ; receiverAddress . transfer ( amount ) ; assert ( bids [ receiverAddress ] == 0 ) ; return true ; }
","Withdraw ETH for ` receiverAddress ` after the auction has canceled .
"
"function resetAppendDecryptedBids ( uint _count ) public onlyOwner { require ( status == state . ended ) ; require ( bids_decrypted_count > 0 ) ; require ( _count > 0 ) ; if ( bids_reset_count == 0 ) { bids_reset_count = bids_decrypted_count ; } uint count = _count ; if ( bids_reset_count < count ) { count = bids_reset_count ; } do { bids_reset_count -- ; bids [ bids_decrypted [ bids_reset_count ] ] . is_decrypted = false ; bids [ bids_decrypted [ bids_reset_count ] ] . is_burned = false ; bids [ bids_decrypted [ bids_reset_count ] ] . will_compute = false ; count -- ; } while ( count > 0 ) ; if ( bids_reset_count == 0 ) { bids_sorted_count = 0 ; bids_ignored_count = 0 ; bids_decrypted_count = 0 ; bids_burned_count = 0 ; } }
","Allows resetting the entire bid decryption/appending process in case a mistake was made and it is not possible to continue appending further bids .
"
"function next ( address darknodeID ) external view onlyOwner returns ( address ) { return LinkedList . next ( darknodes , darknodeID ) ; }
","Returns the address of the next darknode in the store after the given address .
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _value == 0 || dataStorage . allowed ( msg . sender , _spender ) == 0 , 'Approve value is required to be zero or account has already been approved.' ) ; dataStorage . setAllowance ( msg . sender , _spender , _value ) ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","If this function is called again it overwrites the current allowance with ` _value ` .
"
"function withdrawRequest ( address _auditor , bytes32 _codeHash ) public { bytes32 hashAuditorCode = keccak256 ( _auditor , _codeHash ) ; uint8 outcome = auditOutcomes [ hashAuditorCode ] ; require ( outcome == NOT_AUDITED ) ; bytes32 hashAuditorRequestorCode = keccak256 ( _auditor , msg . sender , _codeHash ) ; AuditRequest storage request = auditRequests [ hashAuditorRequestorCode ] ; require ( request . amount > 0 ) ; require ( now > request . expireDate ) ; uint amount = request . amount ; delete request . amount ; delete request . expireDate ; rewards [ hashAuditorCode ] = rewards [ hashAuditorCode ] . sub ( amount ) ; totalRequestsAmount = totalRequestsAmount . sub ( amount ) ; emit RequestWithdrawn ( _auditor , msg . sender , _codeHash , amount ) ; msg . sender . transfer ( amount ) ; }
","withdraws an audit request
"
"function authorAddress ( ) external view returns ( address ) ;
","Returns an address of the toon author .
"
"function ( ) payable public { sale ( msg . sender , msg . value , address ( 0 ) ) ; }
","Sell tokens directly , without referral bonuses
"
"function requestMortgage ( uint256 [ 6 ] loanParams , string metadata , uint256 landId , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { uint256 loanId = createLoan ( loanParams , metadata ) ; NanoLoanEngine _nanoLoanEngine = nanoLoanEngine ; require ( _nanoLoanEngine . registerApprove ( _nanoLoanEngine . getIdentifier ( loanId ) , v , r , s ) , ""Signature not valid"" ) ; uint256 requiredDeposit = ( ( readLandCost ( landId ) * requiredTotal ) / 100 ) - _nanoLoanEngine . getAmount ( loanId ) ; Token _mana = mana ; _tokenTransferFrom ( _mana , msg . sender , this , requiredDeposit ) ; require ( _mana . approve ( mortgageManager , requiredDeposit ) , ""Error approve MANA transfer"" ) ; uint256 mortgageId = mortgageManager . requestMortgageId ( Engine ( _nanoLoanEngine ) , landMarket , loanId , requiredDeposit , landId , tokenConverter ) ; require ( _mana . approve ( mortgageManager , 0 ) , ""Error remove approve MANA transfer"" ) ; emit NewMortgage ( msg . sender , loanId , landId , mortgageId ) ; return mortgageId ; }
","Request a loan and attachs a mortgage request
"
"function setTimelock ( uint _newTimeLock ) onlyOwner external { require ( _newTimeLock >= absoluteMinTimeLock ) ; timeLock = _newTimeLock ; }
","` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `
"
"function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = true ; } else { mAuthorized [ _operator ] [ msg . sender ] = false ; } emit RevokedOperator ( _operator , msg . sender ) ; }
","Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
"
"function _sellPresale ( uint cst ) private { require ( cst >= bonusLevel0 . mul ( 9950 ) . div ( 10000 ) ) ; presaleSold = presaleSold . add ( cst ) ; require ( presaleSold <= presaleSupply ) ; }
","_sellPresale checks CST purchases during crowdsale
"
"function setMultiSigWallet ( address _walletAddress ) whenNotPaused onlyOwner external { wallet = _walletAddress ; }
","Set RNTMultiSigWallet address .
"
"function tokenURI ( uint256 _tokenId ) external view returns ( string ) { require ( _holderOf [ _tokenId ] != 0 , ""Asset does not exist"" ) ; URIProvider provider = _uriProvider ; return provider == address ( 0 ) ? """" : provider . tokenURI ( _tokenId ) ; }
","A distinct Uniform Resource Identifier ( URI ) for a given asset .
"
"function updatePrice ( ) public payable { require ( msg . sender == priceCheckerAddress ) ; _updatePrice ( ) ; }
","Function for updating the price stored in this contract
"
"function addContent ( string _name , string _description , uint _reward ) notLocked onlyBrand validReward ( _reward ) public returns ( bool _success ) { return content . put ( _name , _description , _reward ) ; }
","add content to the agreement
"
"function setAccountSpendingLimit ( address account , uint limit , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setAccountSpendingLimit ( account , limit ) , ""Error: Unable to set initial spending limit for account. Please check issuerFirm and firm authority are registered"" ) ; return true ; }
","Sets the spending limit for a given account
"
"function implementation ( ) internal view returns ( address ) ;
","Returns destination address for future calls
"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { _allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount .
"
"function orderMatch ( bytes32 _orderID ) external view returns ( bytes32 ) { return orders [ _orderID ] . matchedOrder ; }
","returns a list of matched orders to the given orderID .
"
"function withdraw ( uint256 amount ) onlyOwner public { uint256 minimumAmount = address ( this ) . balance ; require ( minimumAmount >= amount ) ; msg . sender . transfer ( amount ) ; }
","withDraw ` amount ` ETH to contract
"
"function setLimits ( uint _minAmountLimit , uint _maxAmountLimit , uint _divisorBalanceLimit , uint _multiplierSharesLimit , uint _divisorSharesLimit ) ;
","Function used by the creator to set the funding limits for the funding
"
"function internalOrderExecution ( Tokens tokens , DEXOrders orders ) internal { transferTokens ( tokens ) ; uint256 tokensLength = tokens . tokenAddresses . length ; uint256 ordersLength = orders . tokenForOrder . length ; uint256 etherBalance = msg . value ; uint256 orderIndex = 0 ; for ( uint256 tokenIndex = 0 ; tokenIndex < tokensLength ; tokenIndex ++ ) { uint256 amountRemaining = tokens . amountToGive [ tokenIndex ] ; uint256 amountObtained = 0 ; while ( orderIndex < ordersLength ) { require ( tokens . tokenAddresses [ tokenIndex ] == orders . tokenForOrder [ orderIndex ] , ""TotlePrimary - tokenAddress != tokenForOrder"" ) ; require ( handlerWhitelist [ orders . exchanges [ orderIndex ] ] , ""TotlePrimary - handler not in whitelist"" ) ; if ( amountRemaining > 0 ) { if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { require ( etherBalance >= amountRemaining , ""TotlePrimary - not enough ether left to fill next order"" ) ; } ( amountRemaining , amountObtained ) = performTrade ( tokens . buyOrSell [ tokenIndex ] , amountRemaining , amountObtained , orders , orderIndex ) ; } orderIndex = SafeMath . add ( orderIndex , 1 ) ; if ( orderIndex == ordersLength || orders . tokenForOrder [ SafeMath . sub ( orderIndex , 1 ) ] != orders . tokenForOrder [ orderIndex ] ) { break ; } } uint256 amountGiven = SafeMath . sub ( tokens . amountToGive [ tokenIndex ] , amountRemaining ) ; require ( orderWasValid ( amountObtained , amountGiven , tokens . amountToObtain [ tokenIndex ] , tokens . amountToGive [ tokenIndex ] ) , ""TotlePrimary - amount obtained for was not high enough"" ) ; if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { etherBalance = SafeMath . sub ( etherBalance , amountGiven ) ; if ( amountObtained > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountObtained ) , ""TotlePrimary - failed to transfer tokens bought to msg.sender"" ) ; } } else { etherBalance = SafeMath . add ( etherBalance , amountObtained ) ; if ( amountRemaining > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountRemaining ) , ""TotlePrimary - failed to transfer remaining tokens to msg.sender after sell"" ) ; } } } if ( etherBalance > 0 ) { msg . sender . transfer ( etherBalance ) ; } }
","The orders in this function have been wrapped in structs to reduce the local variable count
"
"function transferAdviser ( address [ ] _adv , uint [ ] _tokens ) public onlyOwnerAndDirector { require ( _adv . length == _tokens . length ) ; for ( uint i = 0 ; i < _adv . length ; i ++ ) { adviserSold = adviserSold . add ( _tokens [ i ] ) ; _freezeTransfer ( _adv [ i ] , _tokens [ i ] ) ; } require ( adviserSold <= adviserSupply ) ; }
","adviser tokens have their own supply
"
"function canUpgrade ( ) public view returns ( bool ) ;
","Can the contract be upgradead ?
"
"function spiceUp ( uint256 _gameIndex , string message ) external payable { _processGameEnd ( ) ; require ( _gameIndex == gameIndex ) ; require ( gameStarted || ! paused ) ; require ( msg . value > 0 ) ; prizePool = prizePool . add ( msg . value ) ; SpiceUpPrizePool ( gameIndex , msg . sender , msg . value , message , prizePool ) ; }
","Spice up the prize pool .
"
"function redeem ( uint256 _tokens ) public { __redeem_impl ( msg . sender , _tokens ) ; }
","Redeem required amount of tokens for the real asset
"
"function setExchangeFeeRate ( uint _exchangeFeeRate ) external optionalProxy_onlyOwner { require ( _exchangeFeeRate <= MAX_EXCHANGE_FEE_RATE , ""Exchange fee rate must be below MAX_EXCHANGE_FEE_RATE"" ) ; exchangeFeeRate = _exchangeFeeRate ; emitExchangeFeeUpdated ( _exchangeFeeRate ) ; }
","Set the exchange fee , anywhere within the range 0-10 % .
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { tokenrecipiente spender = tokenrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it
"
"function addListToWhiteList ( address [ ] _addresses ) public onlyOwner { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { if ( nonWLBalanceOf [ _addresses [ i ] ] > 0 ) { sendTokens ( _addresses [ i ] , nonWLBalanceOf [ _addresses [ i ] ] ) ; nonWLBalanceOf [ _addresses [ i ] ] = 0 ; } whiteList [ _addresses [ i ] ] = true ; } }
","Add multiple addresses to white list to allow purchase for more than 10 ETH .
"
"function getInstructions ( ) public view returns ( string ) { return ""Allows an issuer to restrict the total number of non-zero token holders"" ; }
","Get the Instructions that helped to used the module
"
"function release ( ERC20Basic token ) public { uint256 unreleased = releasableAmount ( token ) ; require ( unreleased > 0 ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . safeTransfer ( beneficiary , unreleased ) ; emit Released ( unreleased ) ; }
","Transfers vested tokens to beneficiary .
"
"function getRate ( ) returns ( uint32 , uint32 ) { return ( 1 , 1 ) ; }
","returns always 1 because exchange rate of the token to itself is always 1 .
"
"function ( ) public payable { revert ( ) ; }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function giveReserveTo ( address to , uint256 tokens ) public onlyOwner { require ( ! readOnly , ""Read only mode engaged"" ) ; balances [ address ( 0 ) ] = balances [ address ( 0 ) ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( address ( 0 ) , to , tokens ) ; ensureInAccountList ( to ) ; }
","Give tokens from the pool to account , creating the account if necessary
"
"function buy ( uint _bidPrice , uint _amount , bool _make ) payable returns ( bool ) ;
","Will buy ` _amount ` tokens at or below ` _price ` each .
"
"function buy ( uint256 x , uint256 y , uint256 sizeA , uint256 sizeB , uint8 _v , bytes32 _r , bytes32 _s ) public notHalted ( ) payable { address recoveredSigner = verify ( keccak256 ( msg . sender ) , _v , _r , _s ) ; require ( signers [ recoveredSigner ] == true ) ; require ( msg . value > 0 ) ; internalBuy ( x , y , sizeA , sizeB ) ; }
","sell new tokens during the round 0 all except logo
"
"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function finishSale ( ) external onlyIfSaleIsActive onlymanyowners ( keccak256 ( msg . data ) ) { require ( m_nextSale != address ( 0 ) ) ; m_active = false ; EthPriceDependent next = EthPriceDependent ( m_nextSale ) ; next . topUp . value ( this . balance ) ( ) ; m_token . transfer ( m_nextSale , m_token . balanceOf ( this ) ) ; m_token . switchToNextSale ( m_nextSale ) ; }
","stop accepting ether , transfer remaining tokens to the next sale and give new sale permissions to transfer frozen funds and revoke own ones Can be called anytime , even before the set finish date
"
"function convert ( uint _amount ) { if ( ! arcToken . transferFrom ( msg . sender , 0x0 , _amount ) ) { throw ; } if ( ! tokenContract . generateTokens ( msg . sender , _amount ) ) { throw ; } }
","converts ARC tokens to new SWT tokens and forwards ARC to the vault address .
"
"function announceCancel ( bytes32 _offerHash ) external { Offer memory offer = offers [ _offerHash ] ; require ( offer . maker == msg . sender , ""Invalid sender"" ) ; require ( offer . availableAmount > 0 , ""Offer already cancelled"" ) ; uint256 canCancelAt = now + cancelAnnounceDelay ; announcedCancellations [ _offerHash ] = canCancelAt ; emit CancelAnnounce ( offer . maker , _offerHash , canCancelAt ) ; }
","Announces intent to cancel tokens using ` slowCancel `
"
"function increaseApproval ( address _spender , uint _addedValue ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _addedValue ) ; emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }
","Increase the amount of tokens that an owner allowed to a spender .
"
"function mintToken ( uint256 mintedAmount ) onlyOwner public { _balanceOf [ owner ] += mintedAmount ; _totalSupply += mintedAmount ; Transfer ( 0 , owner , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` owner `
"
"function slowWithdraw ( address _withdrawer , address _token , uint256 _amount ) external { AnnouncedWithdrawal memory announcement = announcedWithdrawals [ _withdrawer ] [ _token ] ; require ( announcement . canWithdrawAt != 0 && announcement . canWithdrawAt <= now , ""Insufficient delay"" ) ; require ( announcement . amount == _amount , ""Invalid amount"" ) ; delete announcedWithdrawals [ _withdrawer ] [ _token ] ; _withdraw ( _withdrawer , _token , _amount , etherAddr , 0 ) ; }
","Withdraw tokens without requiring the coordinator
"
"function burn ( address _address , uint256 _value ) external onlyContract ( ""FeeManager"" ) returns ( bool ) { require ( _value <= balanceOf ( _address ) ) ; spentAct [ _address ] = spentAct [ _address ] . add ( _value ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; emit Burn ( _address , _value ) ; return true ; }
","Burns tokens through decrementing `` totalSupply '' and incrementing `` spentAct [ address ] ''
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; require ( _index < _balanceOf ( _owner ) ) ; return _ownedTokens [ _owner ] [ _index ] ; }
","Enumerate NFTs assigned to an owner
"
"function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = ""Percentage"" ; availableTags [ 1 ] = ""Transfer Restriction"" ; return availableTags ; }
","Get the tags related to the module factory
"
"function release ( ERC20Basic _token ) public { uint256 unreleased = releasableAmount ( _token ) ; require ( unreleased > 0 ) ; released [ _token ] = released [ _token ] . add ( unreleased ) ; _token . safeTransfer ( beneficiary , unreleased ) ; emit Released ( unreleased ) ; }
","Transfers vested tokens to beneficiary .
"
"function allowIcoExit ( bool exitAllowed ) isOwner { require ( icoExitIsPossible != exitAllowed ) ; icoExitIsPossible = exitAllowed ; }
","Allow user to exit ICO
"
"function claimPlot ( uint256 _deedId , uint256 _buyoutPrice ) external payable whenNotPaused { claimPlotWithData ( _deedId , _buyoutPrice , """" , """" , """" , """" ) ; }
","Buy an unclaimed plot .
"
"function changeToken ( address token_ ) onlyOwner public { token = token_ ; }
","Owner can change ERC20 contract address
"
"function removeManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && admins [ account ] && account != owner ( ) ) { admins [ account ] = false ; emit AdminRemoved ( _accounts [ i ] ) ; } } return true ; }
","Removes multiple addresses to the administrator list .
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = politicianIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function getTokenMinted ( ) public constant returns ( uint ) { return m_token . totalSupply ( ) ; }
","amount of wei-tokens minted
"
"function multiERC20TransferTightlyPacked ( ERC20 _token , bytes32 [ ] _addressesAndAmounts ) public { for ( uint i = 0 ; i < _addressesAndAmounts . length ; i ++ ) { address to = address ( _addressesAndAmounts [ i ] >> 96 ) ; uint amount = uint ( uint96 ( _addressesAndAmounts [ i ] ) ) ; _safeERC20Transfer ( _token , to , amount ) ; MultiERC20Transfer ( msg . sender , msg . value , to , amount , _token ) ; } }
","Send ERC20 tokens to multiple contracts using a byte32 array which includes the address and the amount .
"
"function addHarvestOperationEndorsement ( string _mappingID , bool positive , string title , string description ) external returns ( bool success ) { harvestOperationEndorsements [ keccak256 ( _mappingID ) ] . push ( Endorsement ( positive , title , description , msg . sender ) ) ; return true ; }
","Add new endorsement to harvest operation
"
"function exchangeEtherForNomins ( ) public payable pricesNotStale notPaused returns ( uint ) { uint ethToSend ; uint requestedToPurchase = safeMul_dec ( msg . value , usdToEthPrice ) ; uint remainingToFulfill = requestedToPurchase ; for ( uint i = depositStartIndex ; remainingToFulfill > 0 && i < depositEndIndex ; i ++ ) { nominDeposit memory deposit = deposits [ i ] ; if ( deposit . user == address ( 0 ) ) { depositStartIndex = safeAdd ( depositStartIndex , 1 ) ; } else { if ( deposit . amount > remainingToFulfill ) { deposit . amount = safeSub ( deposit . amount , remainingToFulfill ) ; totalSellableDeposits = safeSub ( totalSellableDeposits , remainingToFulfill ) ; ethToSend = safeDiv_dec ( remainingToFulfill , usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } nomin . transfer ( msg . sender , remainingToFulfill ) ; remainingToFulfill = 0 ; } else if ( deposit . amount <= remainingToFulfill ) { delete deposits [ i ] ; depositStartIndex = safeAdd ( depositStartIndex , 1 ) ; totalSellableDeposits = safeSub ( totalSellableDeposits , deposit . amount ) ; ethToSend = safeDiv_dec ( deposit . amount , usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } nomin . transfer ( msg . sender , deposit . amount ) ; remainingToFulfill = safeSub ( remainingToFulfill , deposit . amount ) ; } } } if ( remainingToFulfill > 0 ) { msg . sender . transfer ( safeDiv_dec ( remainingToFulfill , usdToEthPrice ) ) ; } uint fulfilled = safeSub ( requestedToPurchase , remainingToFulfill ) ; if ( fulfilled > 0 ) { emit Exchange ( ""ETH"" , msg . value , ""nUSD"" , fulfilled ) ; } return fulfilled ; }
","Exchange ETH to nUSD .
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { }
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function generateTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupplyAt ( block . number ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOfAt ( _owner , block . number ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; emit Transfer ( 0 , _owner , _amount ) ; return true ; }
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function approve ( address _spender , uint256 _value ) notPendingWithdrawal returns ( bool success ) { if ( balanceOf [ msg . sender ] < _value ) return false ; if ( ( _value != 0 ) && ( allowance [ msg . sender ] [ _spender ] != 0 ) ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function sellResources ( uint8 _type ) public onlyExistingUser returns ( uint256 ) { uint256 userId = addressToUser [ msg . sender ] ; uint256 sum = Math . min ( users [ userId ] . resources [ _type ] * getResourcePrice ( _type ) , address ( this ) . balance ) ; users [ userId ] . resources [ _type ] = 0 ; msg . sender . transfer ( sum ) ; emit Sell ( userId , _type , sum ) ; return sum ; }
","sell resources of user with type
"
"function onTimeout ( uint256 ) internal { selfdestruct ( msg . sender ) ; }
","Default action when timeout : override this .
"
"function bountyFreeze ( address target , bool freeze ) internal { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }
","` bountyFreeze ?
"
"function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < ( kitties . length - destroyKittyCount ) ) ; return _index ; }
","Enumerate valid NFTs
"
"function removeModule ( address _module ) external onlyOwner { require ( modulesToData [ _module ] . isArchived , ""Not archived"" ) ; require ( modulesToData [ _module ] . module != address ( 0 ) , ""Module missing"" ) ; emit ModuleRemoved ( modulesToData [ _module ] . moduleTypes , _module , now ) ; uint8 [ ] memory moduleTypes = modulesToData [ _module ] . moduleTypes ; for ( uint256 i = 0 ; i < moduleTypes . length ; i ++ ) { _removeModuleWithIndex ( moduleTypes [ i ] , modulesToData [ _module ] . moduleIndexes [ i ] ) ; } uint256 index = modulesToData [ _module ] . nameIndex ; bytes32 name = modulesToData [ _module ] . name ; uint256 length = names [ name ] . length ; names [ name ] [ index ] = names [ name ] [ length - 1 ] ; names [ name ] . length = length - 1 ; if ( ( length - 1 ) != index ) { modulesToData [ names [ name ] [ index ] ] . nameIndex = index ; } delete modulesToData [ _module ] ; }
","Removes a module attached to the SecurityToken
"
"function getHealBalance ( ) view public returns ( uint256 ) { return ethealController . ethealToken ( ) . balanceOf ( address ( this ) ) ; }
","How many HEAL tokens do this contract have
"
"function upgrade ( uint256 value ) external { require ( upgradeAgentStatus ) ; require ( value > 0 && upgradeAgent . owner ( ) != 0x0 ) ; require ( value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }
","Upgrade tokens to the new token contract .
"
"function getDetails ( string _symbol ) public view returns ( address , uint256 , string , bytes32 , bool ) { string memory symbol = upper ( _symbol ) ; if ( registeredSymbols [ symbol ] . status == true || registeredSymbols [ symbol ] . timestamp . add ( expiryLimit ) > now ) { return ( registeredSymbols [ symbol ] . owner , registeredSymbols [ symbol ] . timestamp , registeredSymbols [ symbol ] . tokenName , registeredSymbols [ symbol ] . swarmHash , registeredSymbols [ symbol ] . status ) ; } else return ( address ( 0 ) , uint256 ( 0 ) , """" , bytes32 ( 0 ) , false ) ; }
","Returns the owner and timestamp for a given symbol
"
"function isCrowdsaleOpen ( ) public view returns ( bool ) { return address ( crowdsale ) != address ( 0 ) && ! crowdsale . hasEnded ( ) && crowdsale . hasStarted ( ) ; }
","Is there a not ended crowdsale ?
"
"function ownershipLength ( ) public view returns ( uint256 ) { return ownership . length ; }
","Gets the length of the ownership array which represents the number of owned plots which exist
"
"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . transferControl ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function getNextVestingIndex ( address account ) public view returns ( uint ) { uint len = numVestingEntries ( account ) ; for ( uint i = 0 ; i < len ; i ++ ) { if ( getVestingTime ( account , i ) != 0 ) { return i ; } } return len ; }
","Obtain the index of the next schedule entry that will vest for a given user .
"
"function computeHash ( string _key ) private pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _key ) ) ; }
","Computes keccak256 hash of the supplied value .
"
"function processProposal ( bytes32 _propID ) public { ParamProposal storage prop = proposals [ _propID ] ; address propOwner = prop . owner ; uint propDeposit = prop . deposit ; if ( canBeSet ( _propID ) ) { set ( prop . name , prop . value ) ; _ProposalAccepted ( _propID , prop . name , prop . value ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else if ( challengeCanBeResolved ( _propID ) ) { resolveChallenge ( _propID ) ; } else if ( now > prop . processBy ) { _ProposalExpired ( _propID ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else { revert ( ) ; } assert ( get ( ""dispensationPct"" ) <= 100 ) ; assert ( get ( ""pDispensationPct"" ) <= 100 ) ; now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) ; delete proposals [ _propID ] ; }
","for the provided proposal ID , set it , resolve its challenge , or delete it depending on whether it can be set , has a challenge which can be resolved , or if its `` process by '' date has passed
"
"function createBoardHash ( bytes32 name , address admin ) pure public returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( name , admin ) ) ; }
","Simulate the creation of a leaderboard hash
"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; toRecord ( msg . sender , _to , _value ) ; return true ; }
","send ` _value ` token to ` _to `
"
"function getTokenDetails ( uint64 _tokens ) private view returns ( TokenPair memory ) { ( address priorityAddress , uint8 priorityDecimals , bool priorityRegistered ) = renExTokensContract . tokens ( uint32 ( _tokens >> 32 ) ) ; ( address secondaryAddress , uint8 secondaryDecimals , bool secondaryRegistered ) = renExTokensContract . tokens ( uint32 ( _tokens ) ) ; return TokenPair ( { priorityToken : RenExTokens . TokenDetails ( priorityAddress , priorityDecimals , priorityRegistered ) , secondaryToken : RenExTokens . TokenDetails ( secondaryAddress , secondaryDecimals , secondaryRegistered ) } ) ; }
","Gets the order details of the priority and secondary token from the RenExTokens contract and returns them as a single struct .
"
"function createTemplate ( string content ) stateAny ( ) public returns ( uint256 ) { uint256 id = nextTemplateID ; templates [ id ] = block . number ; template_hashes [ id ] = keccak256 ( content ) ; LogNewTemplate ( id , msg . sender , content ) ; nextTemplateID = id . add ( 1 ) ; return id ; }
","Create a reusable template , which should be a JSON document .
"
"function burn ( uint256 _value ) public { uint256 senderBalance = dataStorage . balances ( msg . sender ) ; require ( senderBalance >= _value , 'Burn value less than account balance required.' ) ; senderBalance = senderBalance . sub ( _value ) ; dataStorage . setBalance ( msg . sender , senderBalance ) ; uint256 totalSupply = dataStorage . totalSupply ( ) ; totalSupply = totalSupply . sub ( _value ) ; dataStorage . setTotalSupply ( totalSupply ) ; emit Burn ( msg . sender , _value ) ; emit Transfer ( msg . sender , address ( 0 ) , _value ) ; }
","Destroy tokens from your account .
"
"function price ( ) public constant returns ( uint ) { if ( stage == Stages . AuctionEnded || stage == Stages . TokensDistributed ) { return finalPrice ; } return calcTokenPrice ( ) ; }
","Get the XBET price in WEI during the auction , at the time of calling this function .
"
"function setFundingStartTime ( uint _startTime ) external ;
","Function used by the main partner to set the start time of the funding
"
"function addTrustedContracts ( address [ ] _trusted_contracts ) isOwner public { for ( uint256 i = 0 ; i < _trusted_contracts . length ; i ++ ) { if ( addressHasCode ( _trusted_contracts [ i ] ) ) { trusted_contracts [ _trusted_contracts [ i ] ] = true ; TrustedContract ( _trusted_contracts [ i ] , true ) ; } } }
","Function for adding trusted contracts .
"
"function totalIssuedSynths ( bytes4 currencyKey ) public view rateNotStale ( currencyKey ) returns ( uint ) { uint total = 0 ; uint currencyRate = exchangeRates . rateForCurrency ( currencyKey ) ; for ( uint8 i = 0 ; i < availableSynths . length ; i ++ ) { require ( ! exchangeRates . rateIsStale ( availableSynths [ i ] . currencyKey ( ) ) , ""Rate is stale"" ) ; uint synthValue = availableSynths [ i ] . totalSupply ( ) . multiplyDecimalRound ( exchangeRates . rateForCurrency ( availableSynths [ i ] . currencyKey ( ) ) ) . divideDecimalRound ( currencyRate ) ; total = total . add ( synthValue ) ; } return total ; }
","Total amount of synths issued by the system , priced in currencyKey
"
"function balanceOf ( address _owner ) public view returns ( uint256 _balance ) ;
","Returns the balance of an account with address ` _owner ` .
"
"function quoteBid ( ) public returns ( uint256 ) { if ( initialSaleComplete ) { bid = fracExp ( 1e18 , R , ( _totalSupply / 1e18 ) - 1 , P ) ; } else { bid = ICObid ; } return bid ; }
","Calculates the bid price in wei per aToken based on the current reserve amount
"
"function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) ) ; ERC20Basic token = ERC20Basic ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( owner , balance ) ) ; }
","Reclaim all ERC20Basic compatible tokens
"
"function ( ) external payable { buyWithETH ( msg . sender ) ; }
","fallback function - assumes ETH being invested
"
"function setGasLimit ( uint256 _gasLimit ) isAdminOrOwner public { gasLimit = _gasLimit ; }
","NB - this will only impact newly scheduled Oraclize queries , not future queries which have already been scheduled
"
"function setSynthetixState ( SynthetixState _synthetixState ) external optionalProxy_onlyOwner { synthetixState = _synthetixState ; emitStateContractChanged ( _synthetixState ) ; }
","Set the synthetixState contract address where issuance data is held .
"
"function _releaseTo ( address target ) internal { uint256 unreleased = releasableAmount ( ) ; released = released . add ( unreleased ) ; token . safeTransfer ( target , unreleased ) ; Released ( released ) ; }
","Transfers vested tokens to beneficiary .
"
"function transferFrom ( address from , address to , uint256 value ) returns ( bool ) { if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value && safeAdd ( balances [ to ] , value ) > balances [ to ] ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { throw ; } }
","This function is disabled during the funding .
"
"function callWithdraw ( ) onlyOwner public { realitycheck . withdraw ( ) ; }
","Withdraw any accumulated question fees from the specified address into this contract
"
"function decreaseCap ( uint _value ) onlyAccountAddressForSponsee { if ( totalSupply > cap . sub ( _value ) ) { revert ( ) ; } cap = cap . sub ( _value ) ; LogDecreaseCap ( _value ) ; }
","Decrease cap .
"
"function balanceOf ( address _holder , bytes32 _symbol ) public view returns ( uint ) { return _balanceOf ( getHolderId ( _holder ) , _symbol ) ; }
","Returns asset balance for a particular holder .
"
"function orderState ( bytes32 _orderID ) external view returns ( OrderState ) ;
","returns status of the given orderID .
"
"function getCurrencyAddress ( ) external view returns ( address ) ;
","Returns address of oracle currency ( 0x0 for ETH )
"
"function addToWhitelist ( address _address ) public onlyWhitelister { require ( _address != address ( 0 ) ) ; emit WhitelistAdd ( whitelister , _address ) ; whitelist [ _address ] = true ; }
","Only callable by the whitelister .
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = cityIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function getCard ( uint256 _tokenId ) public view returns ( string name , uint256 token ) { address owner = cardTokenToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; uint256 index = cardTokenToPosition [ _tokenId ] ; Card storage card = cards [ index ] ; name = card . name ; token = card . token ; }
","Returns all the relevant information about a specific card .
"
"function changeMedianier ( address _medianizer ) public onlyOwner { require ( _medianizer != address ( 0 ) , ""0x not allowed"" ) ; emit ChangeMedianizer ( _medianizer , medianizer , now ) ; medianizer = _medianizer ; }
","Updates medianizer address
"
"function procPreSales ( ) payable public returns ( uint256 ) { require ( isPreSales == true ) ; uint256 amount = msg . value / buyPrice ; amount = amount * 10 ** uint256 ( decimals ) ; if ( balanceOf [ owner ] - amount <= limitAMT ) { isPreSales = false ; } _transfer ( owner , msg . sender , amount ) ; owner . transfer ( msg . value ) ; return amount ; }
","Process presales transactions
"
"function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , block . number ) ; if ( curTotalSupply + _amount < curTotalSupply ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; var previousBalanceTo = balanceOf ( _owner ) ; if ( previousBalanceTo + _amount < previousBalanceTo ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function acceptAllOfficialOperators ( ) external { require ( mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] , ""Official operators are already accepted by msg.sender."" ) ; mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] = false ; emit OfficialOperatorsAcceptedByUser ( msg . sender ) ; }
","Authorize all official operators to manage ` msg.sender ` 's tokens .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; _transfer ( _from , _to , _value ) ; return true ; }
","Transfer tokens from other address
"
"function transfer ( address _to , uint256 _tokenId ) external { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","Transfers a element to another address
"
"function getCoversForPacks ( uint [ ] _packIds ) public view returns ( bytes32 [ ] ) { require ( _packIds . length > 0 ) ; bytes32 [ ] memory covers = new bytes32 [ ] ( _packIds . length ) ; for ( uint i = 0 ; i < _packIds . length ; i ++ ) { AssetPack memory assetPack = assetPacks [ _packIds [ i ] ] ; covers [ i ] = assetPack . packCover ; } return covers ; }
","Function to get cover image for every assetpack
"
"function unfrozenTokens ( ) public onlyOwner whenNotPaused { require ( frozenSupply >= 0 ) ; if ( contributorsCurrentPeriod < CONTRIBUTORS_PERIODS ) { unfrozenContributorsTokens ( ) ; unfrozenCompanyTokens ( ) ; } else { unfrozenCompanyTokens ( ) ; } }
","freeze unfrozenAmount
"
"function completeMinting ( ) onlyOwner public { mintingDone = true ; }
","Complete minting of the token .
"
"function offer ( bytes _model , bytes _objective , address _token , uint256 _cost , address _validator , address _lighthouse , uint256 _lighthouse_fee , uint256 _deadline , bytes32 _nonce , bytes _signature ) external returns ( bool ) ;
","It can be called by factory only
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; _balance [ msg . sender ] = _balance [ msg . sender ] . sub ( _value ) ; _balance [ _to ] = _balance [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","Transfers ` _value ` amount of tokens to address ` _to ` .
"
"function isOwner ( address _owner , bytes32 _symbol ) public view returns ( bool ) { return isCreated ( _symbol ) && ( _assetOwner ( _symbol ) == getHolderId ( _owner ) ) ; }
","Check if specified address has asset owner rights .
"
"function createTemplateAndAskQuestion ( string content , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { uint256 template_id = createTemplate ( content ) ; return askQuestion ( template_id , question , arbitrator , timeout , opening_ts , nonce ) ; }
","Create a new reusable template and use it to ask a question
"
"function getEscrowAndHash ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) view private returns ( Escrow , bytes32 ) { bytes32 _tradeHash = keccak256 ( abi . encodePacked ( _tradeID , _seller , _buyer , _value , _fee ) ) ; return ( escrows [ _tradeHash ] , _tradeHash ) ; }
","Hashes the values and returns the matching escrow object and trade hash .
"
"function distributeICOTokens ( address _buyer , uint tokens ) external onlyCrowdsale whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( tokensDistributedCrowdsale < 50000000 ) ; tokensDistributedCrowdsale = tokensDistributedCrowdsale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
","Distributes the ICO tokens .
"
"function symbol ( ) external view returns ( string _symbol ) { return _ERC721symbol ; }
","An abbreviated name for NFTs in this contract
"
"function closeGame ( uint gameId , GameResults result ) external onlyOwner whenGameIsFrozen ( gameId ) { games [ gameId ] . state = GameStates . Closed ; games [ gameId ] . result = result ; emit GameHasClosed ( gameId , result ) ; }
","We use this function to close a game
"
"function setPlotDataMultiple ( uint256 [ ] _deedIds , string name , string description , string imageUrl , string infoUrl ) external whenNotPaused { for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; } }
","Set the data associated with multiple plots .
"
"function currentResult ( ) external view returns ( uint32 [ NUMBER_OF_CHOICES ] ) { return currentVoteResults ; }
","Return array with sums of votes per choice .
"
"function setMigrationAgent ( address _agent ) external isUpgrading onlyOwner { require ( _agent != 0x00 ) ; agent = MigrationAgent ( _agent ) ; if ( ! agent . isMigrationAgent ( ) ) { revert ( ) ; } if ( agent . originalSupply ( ) != totalSupply ) { revert ( ) ; } }
","Set address of migration target contract and enable migration process .
"
"function quoteAsk ( ) private returns ( uint256 ) { if ( initialSaleComplete ) { ask = fracExp ( 1e16 , R , ( _totalSupply / 1e16 ) + 1 , P ) ; } else { ask = ICOask ; } return ask ; }
","Calculates the ask price in wei per aToken based on the current reserve amount
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external ;
","Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
"
"function getNewRegistry ( ) public view returns ( address ) { return address ( params [ NEW_REGISTRY_KEC ] ) ; }
","gets the address of the new registry , if set .
"
"function invalidate ( address _account ) public onlyOwner { if ( hodlerStakes [ _account ] . stake > 0 && ! hodlerStakes [ _account ] . invalid ) { hodlerStakes [ _account ] . invalid = true ; hodlerTotalValue = hodlerTotalValue . sub ( hodlerStakes [ _account ] . stake ) ; hodlerTotalCount = hodlerTotalCount . sub ( 1 ) ; } updateAndGetHodlTotalValue ( ) ; }
","Invalidates hodler account
"
"function setActive ( bool _active ) onlyContractOwner external returns ( uint ) { if ( active == _active ) { return ; } active = _active ; return OK ; }
","Sets contract to active/non active state .
"
"function getNumberInvestors ( ) public view returns ( uint256 ) ;
","Return the total no .
"
"function updateCap ( uint256 _newCap ) public onlyOwner { require ( _newCap > weiRaised ) ; cap = _newCap ; }
","Funtion to updateCap
"
"function requestMortgageId ( Engine engine , uint256 loanId , uint256 deposit , uint256 landId , TokenConverter tokenConverter ) public returns ( uint256 id ) { require ( engine . getCurrency ( loanId ) == MANA_CURRENCY , ""Loan currency is not MANA"" ) ; address borrower = engine . getBorrower ( loanId ) ; require ( engine . getStatus ( loanId ) == Engine . Status . initial , ""Loan status is not inital"" ) ; require ( msg . sender == engine . getBorrower ( loanId ) || ( msg . sender == engine . getCreator ( loanId ) && creators [ msg . sender ] ) , ""Creator should be borrower or authorized"" ) ; require ( engine . isApproved ( loanId ) , ""Loan is not approved"" ) ; require ( rcn . allowance ( borrower , this ) >= REQUIRED_ALLOWANCE , ""Manager cannot handle borrower's funds"" ) ; require ( tokenConverter != address ( 0 ) , ""Token converter not defined"" ) ; require ( loanToLiability [ engine ] [ loanId ] == 0 , ""Liability for loan already exists"" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 loanAmount = engine . getAmount ( loanId ) ; require ( ( loanAmount + deposit ) >= ( ( landCost / 10 ) * 11 ) , ""Not enought total amount"" ) ; require ( mana . transferFrom ( msg . sender , this , deposit ) , ""Error pulling mana"" ) ; id = mortgages . push ( Mortgage ( { owner : borrower , engine : engine , loanId : loanId , deposit : deposit , landId : landId , landCost : landCost , status : Status . Pending , tokenConverter : tokenConverter } ) ) - 1 ; loanToLiability [ engine ] [ loanId ] = id ; emit RequestedMortgage ( { _id : id , _borrower : borrower , _engine : engine , _loanId : loanId , _landId : landId , _deposit : deposit , _tokenConverter : tokenConverter } ) ; }
","Request a mortgage with a loan id
"
"function addHodlerStake ( address _beneficiary , uint256 _stake ) public onlyCrowdsale { hodlerReward . addHodlerStake ( _beneficiary , _stake ) ; }
","Proxy call for adding hodler stake
"
"function onERC721Received ( address _operator , address _from , uint _tokenId , bytes _data ) public returns ( bytes4 ) ;
","Handle the receipt of an NFT
"
"function price ( ) public constant returns ( uint ) { if ( stage == Stages . AuctionEnded || stage == Stages . TokensDistributed ) { return 0 ; } return calcTokenPrice ( ) ; }
","Get the RDN price in WEI during the auction , at the time of calling this function .
"
"function ownerPauseContract ( ) external onlyOwner { require ( contractStarted ) ; require ( ! contractFinished ) ; require ( ! contractPaused ) ; contractPaused = true ; }
","Pause contract ( transiently )
"
"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner canMint { requireMultiple ( _amount ) ; mTotalSupply = mTotalSupply . add ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , """" , _operatorData , false ) ; emit Minted ( msg . sender , _tokenHolder , _amount , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( 0x0 , _tokenHolder , _amount ) ; } }
","Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .
"
"function decBalance ( address _acct , uint _val ) public onlyModule returns ( bool ) { balances [ _acct ] = balances [ _acct ] . sub ( _val ) ; emit BalanceAdj ( msg . sender , _acct , _val , ""-"" ) ; return true ; }
","Decrement ` _acct ` balance by ` _val `
"
"function unlockPrivate ( ) public locked onlyOwner { require ( block . timestamp >= privateReleaseTime ) ; require ( privateLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= privateLockedAmount ) ; token . transfer ( privateLockAddress , privateLockedAmount ) ; privateLockedAmount = 0 ; }
","Transfers tokens held by timelock to private .
"
"function getRegistry ( ) external view returns ( address ) ;
","Get the account of the utilized attribute registry .
"
"function getOrdersForSeller ( address seller ) public view validAddress ( seller ) returns ( address [ ] ) { return ordersBySeller [ seller ] ; }
","Gets all the data orders associated with a seller .
"
"function transferToAddress ( address _to , uint256 _value ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","Handles transfer to an ECA ( Externally Controlled Account ) , a normal account ~ ERC-223 Proposed Standard
"
"function name ( ) public pure returns ( string ) { return ""Pirate Kitty Token"" ; }
","A descriptive name for a collection of NFTs in this contract
"
"function changeOwner ( address _owner ) external onlyOwner { require ( _owner != address ( 0 ) && _owner != owner ) ; owner = _owner ; ChangeOwner ( owner ) ; }
","Change the owner of the contract
"
"function performTrade ( Trade trade , TradeFlag tradeFlag , CurrentAmounts amounts ) internal { for ( uint256 j ; j < trade . orders . length ; j ++ ) { if ( amounts . amountReceivedFromTrade >= trade . minimumAcceptableTokenAmount ) { return ; } if ( tradeFlag . ignoreOrder [ j ] || amounts . amountLeftToSpendOnTrade == 0 ) { continue ; } uint256 amountSpentOnOrder = 0 ; uint256 amountReceivedFromOrder = 0 ; Order memory thisOrder = trade . orders [ j ] ; ExchangeHandler thisHandler = ExchangeHandler ( thisOrder . exchangeHandler ) ; uint256 amountToGiveForOrder = Utils . min ( thisHandler . getAmountToGive ( thisOrder . genericPayload ) , amounts . amountLeftToSpendOnTrade ) ; if ( amountToGiveForOrder == 0 ) { continue ; } if ( ! thisHandler . staticExchangeChecks ( thisOrder . genericPayload ) ) { continue ; } if ( trade . isSell ) { if ( ! ERC20SafeTransfer . safeTransfer ( trade . tokenAddress , address ( thisHandler ) , amountToGiveForOrder ) ) { if ( ! trade . optionalTrade ) errorReporter . revertTx ( ""Unable to transfer tokens to handler"" ) ; else { return ; } } ( amountSpentOnOrder , amountReceivedFromOrder ) = thisHandler . performSellOrder ( thisOrder . genericPayload , amountToGiveForOrder ) ; } else { ( amountSpentOnOrder , amountReceivedFromOrder ) = thisHandler . performBuyOrder . value ( amountToGiveForOrder ) ( thisOrder . genericPayload , amountToGiveForOrder ) ; } if ( amountReceivedFromOrder > 0 ) { amounts . amountLeftToSpendOnTrade = SafeMath . sub ( amounts . amountLeftToSpendOnTrade , amountSpentOnOrder ) ; amounts . amountSpentOnTrade = SafeMath . add ( amounts . amountSpentOnTrade , amountSpentOnOrder ) ; amounts . amountReceivedFromTrade = SafeMath . add ( amounts . amountReceivedFromTrade , amountReceivedFromOrder ) ; } } }
","Executes the given trade
"
"function remainingFundsToEndAuction ( ) constant public returns ( uint256 ) { uint256 required_wei_at_price = num_tokens_auctioned * price ( ) / token_multiplier ; if ( required_wei_at_price <= received_wei ) { return 0 ; } return required_wei_at_price - received_wei ; }
","Get the remaining funds needed to end the auction , calculated at the current GOT price in WEI .
"
"function rentOutArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint rentPricePerPeriodWei ) external whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; uint id = rentals . rentOutBlocks ( msg . sender , rentPricePerPeriodWei , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogRentsOut ( id , fromX , fromY , toX , toY , rentPricePerPeriodWei ) ; }
","Rent out an area of blocks at coordinates [ fromX , fromY , toX , toY ] at a price for each block in wei
"
"function withdrawAccumulatedFees ( address _to ) external onlyOwner { uint256 transferAmount = accumulatedGasFees ; accumulatedGasFees = 0 ; _to . transfer ( transferAmount ) ; }
","Withdraw accumulated gas fees from the arbitratror releasing escrow .
"
"function transferFrom ( address _from , address _to , uint256 _value ) external requireThaw userNotPlaying ( _to ) { require ( cooldown [ _from ] [ _to ] <= now ) ; var _allowance = allowed [ _from ] [ _to ] ; if ( _from == selfAddress ) { monthlyLimit [ _to ] = safeSub ( monthlyLimit [ _to ] , _value ) ; } balances [ _to ] = balances [ _to ] + _value ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; allowed [ _from ] [ _to ] = safeSub ( _allowance , _value ) ; addUser ( _to ) ; bytes memory empty ; Transfer ( _from , _to , _value , empty ) ; }
","Transfer tokens from an address to another ~ ERC-20 Standard
"
"function transferOwnershipToProject ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { Pledge storage p = findPledge ( idPledge ) ; require ( getPledgeLevel ( p ) < MAX_INTERPROJECT_LEVEL ) ; require ( ! isProjectCanceled ( idReceiver ) ) ; uint64 oldPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; uint64 toPledge = findOrCreatePledge ( idReceiver , new uint64 [ ] ( 0 ) , 0 , 0 , oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }
","` transferOwnershipToProject ` allows for the transfer of ownership to the project , but it can also be called by a project to un-delegate everyone by setting one 's own id for the idReceiver
"
"function ( ) public payable { require ( contractPoweredUp ) ; require ( now >= PRESALE_START_DATE ) ; require ( now < PRESALE_END_DATE ) ; require ( msg . value >= MINIMUM_PARTICIPATION_AMOUNT ) ; if ( now >= PRESALE_START_DATE && now < PRESALE_SECOND_DAY_START ) { require ( whitelist [ msg . sender ] == msg . value ) ; require ( balanceOf [ msg . sender ] == 0 ) ; } else if ( now >= PRESALE_SECOND_DAY_START && now < PRESALE_THIRD_DAY_START ) { require ( whitelist [ msg . sender ] != 0 ) ; } require ( totalFunding . add ( msg . value ) <= PRESALE_MAXIMUM_FUNDING ) ; addBalance ( msg . sender , msg . value ) ; grantCreditsForParticipation ( msg . sender , msg . value ) ; }
","A participant 's contribution will be rejected if the presale has been funded to the maximum amount
"
"function getAthlete ( uint256 _tokenId ) public view returns ( string athleteName , uint256 sellingPrice , address owner ) { Athlete storage athlete = athletes [ _tokenId ] ; athleteName = athlete . name ; sellingPrice = athleteIndexToPrice [ _tokenId ] ; owner = athleteIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific athlete .
"
"function burn ( uint256 _value ) onlyOwner public returns ( bool success ) { burnFrom ( _owner , _value ) ; return true ; }
","Destroy tokens from owener account , can be run only by owner Remove ` _value ` tokens from the system irreversibly
"
"function setNewCFO ( address newCFO ) public onlyOwner { require ( newCFO != 0 ) ; CFO = newCFO ; }
","Separating the CFO and the CEO responsibilities requires the ability to set the CFO account
"
"function batchCreateAccount ( address [ ] _newUsers ) public onlyRegistryAdmin { for ( uint256 i = 0 ; i < _newUsers . length ; i ++ ) { if ( registry . addressBelongsToAccount ( _newUsers [ i ] ) ) { emit addressSkipped ( _newUsers [ i ] ) ; } else { logic . createAccount ( _newUsers [ i ] ) ; } } }
","Create an account instantly without an invitation
"
"function transfer ( address _to , uint256 _tokenId ) external { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; require ( pixelIndexToApproved [ _tokenId ] != address ( this ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","Transfers a Pixel to another address .
"
"function generateSecurityToken ( string _name , string _symbol , string _tokenDetails , bool _divisible ) public ;
","Creates a new Security Token and saves it to the registry
"
"function attestFor ( address _subject , address _attester , address _requester , uint256 _reward , bytes _requesterSig , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig , bytes _delegationSig ) external { validateAttestForSig ( _subject , _attester , _requester , _reward , _dataHash , _requestNonce , _delegationSig ) ; attestForUser ( _subject , _attester , _requester , _reward , _requesterSig , _dataHash , _requestNonce , _subjectSig ) ; }
","Submit attestation for a user in order to pay the gas costs
"
"function decreaseApproval ( address _spender , uint _subtractedValue ) public returns ( bool success ) { uint oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }
","Decrease the amount of tokens that an owner allowed to a spender .
"
"function multiBatchSafeTransferFrom ( uint256 [ ] _tokenIds , address [ ] _fromB , address [ ] _toB ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _fromB . length > 0 && _toB . length > 0 ) ; uint256 _id ; address _to ; address _from ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 && _fromB [ i ] != 0 && _toB [ i ] != 0 ) ; _id = _tokenIds [ i ] ; _to = _toB [ i ] ; _from = _fromB [ i ] ; safeTransferFrom ( _from , _to , _id ) ; } }
","Batch SafeTransferFrom with multiple From and to Addresses
"
"function state ( ) public constant returns ( string ) { return stateNames [ uint ( currentState ( ) ) ] ; }
","returns current state of the voting .
"
"function updatePolyTokenAddress ( address _newAddress ) external ;
","Change the PolyToken address
"
"function sell ( uint256 amount ) public { require ( this . balance >= amount * sellPrice / ( uint256 ( 10 ) ** decimals ) ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice / ( uint256 ( 10 ) ** decimals ) ) ; }
","Sell ` amount ` tokens to contract
"
"function getHistoryHash ( bytes32 question_id ) public view returns ( bytes32 ) { }
","Returns the history hash of the question
"
"function claim ( address _arbitrator , uint256 _transactionId ) public { Lock memory lock = escrows [ _arbitrator ] [ _transactionId ] ; require ( lock . sender == msg . sender ) ; require ( lock . paid ) ; require ( lock . expiration < block . timestamp ) ; require ( lock . expiration != 0 ) ; delete escrows [ _arbitrator ] [ _transactionId ] ; token . transfer ( msg . sender , lock . value . add ( lock . fee ) ) ; Released ( _arbitrator , msg . sender , _transactionId ) ; }
","Only works after lock expired
"
"function drain ( ) public onlyOwner { for ( uint256 index = 0 ; index < membersArray . length ; index ++ ) { address memberAddress = membersArray [ index ] ; bool memberJoined = members [ memberAddress ] . stakeTimestamp != 0 ; uint256 amountRefunded = memberJoined ? refundUserBalance ( memberAddress ) : 0 ; delete registeredInvitationCodes [ members [ memberAddress ] . invitationCode ] ; delete members [ memberAddress ] ; emit MemberDrained ( memberAddress , amountRefunded ) ; } delete membersArray ; require ( ixtToken . transfer ( msg . sender , totalPoolBalance ) , ""Unable to withdraw this value of IXT."" ) ; totalPoolBalance = 0 ; emit PoolDrained ( msg . sender , totalPoolBalance ) ; emit ContractDrained ( msg . sender ) ; }
","This function can only be called by the contract owner
"
"function emergencyClawbackEther ( uint256 value ) external onlyOwnerOrMultisig { require ( contractFailed ) ; require ( contractRefundStarted ) ; require ( contractRefundFinished ) ; require ( value > 0 ) ; require ( value <= address ( this ) . balance ) ; msg . sender . transfer ( value ) ; }
","Contract owner or Multisig can clawback ether after refund period is finished
"
"function _changeTokenAddress ( address _tokenAddress ) internal { require ( _tokenAddress != address ( 0 ) ) ; address oldAddress = fidaTokenAddress ; fidaTokenAddress = _tokenAddress ; fidaToken = ERC20Basic ( _tokenAddress ) ; mintableFida = MintableTokenInterface ( _tokenAddress ) ; emit TokenAddressChanged ( oldAddress , _tokenAddress ) ; }
","Internal function for changing the token address
"
"function verifyMatchDetails ( OrderDetails memory _buy , OrderDetails memory _sell ) internal pure returns ( bool ) { if ( ! verifyTokens ( _buy . tokens , _sell . tokens ) ) { return false ; } if ( _buy . price < _sell . price ) { return false ; } if ( _buy . volume < _sell . minimumVolume ) { return false ; } if ( _sell . volume < _buy . minimumVolume ) { return false ; } if ( _buy . settlementID != _sell . settlementID ) { return false ; } return true ; }
","Verifies that two orders match when considering the tokens , price , volumes / minimum volumes and settlement IDs .
"
"function followTrader ( bytes _signature , address _trader , bytes32 _strategyID , uint256 _marginAmount , address _oracle , uint256 _validUntil ) public returns ( bool ) { require ( block . number <= _validUntil ) ; require ( followTraderSignatures [ _signature ] == false ) ; require ( traderProfile [ _trader ] [ _strategyID ] != address ( 0 ) ) ; TradeProfile profile = TradeProfile ( traderProfile [ _trader ] [ _strategyID ] ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( followTraderPreSignedHashing ( address ( this ) , _trader , _strategyID , _marginAmount , _oracle , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; marginBalances [ from ] = marginBalances [ from ] . sub ( _marginAmount ) ; require ( profile . follow ( from , _marginAmount , _oracle ) ) ; followTraderSignatures [ _signature ] = true ; emit FollowTrader ( from , _trader , _marginAmount ) ; return true ; }
","Follow a trader
"
"function getContentByKeyIndex ( ContentMapping storage self , uint _index ) public view returns ( Content storage _content ) { isValidIndex ( _index , self . keys . length ) ; return ( self . data [ self . keys [ _index ] ] ) ; }
","get content by _index into key array
"
"function changeLockPeriod ( uint256 periodInDays ) external onlyOwner { require ( periodInDays <= 30 && periodInDays >= 1 ) ; lockPeriod = periodInDays * 1 days ; }
","change lock period , only owner
"
"function getBorrowBalance ( address account , address asset ) view public returns ( uint ) { Error err ; uint newBorrowIndex ; uint userBorrowCurrent ; Market storage market = markets [ asset ] ; Balance storage borrowBalance = borrowBalances [ account ] [ asset ] ; ( err , newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; require ( err == Error . NO_ERROR ) ; ( err , userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , newBorrowIndex ) ; require ( err == Error . NO_ERROR ) ; return userBorrowCurrent ; }
","return borrow balance with any accumulated interest for ` asset ` belonging to ` account `
"
"function _transferFrom_byProxy ( address sender , address from , address to , uint value ) internal returns ( bool ) { uint received = amountReceived ( value ) ; uint fee = safeSub ( value , received ) ; tokenState . setAllowance ( from , sender , safeSub ( tokenState . allowance ( from , sender ) , value ) ) ; return _internalTransfer ( from , to , received , fee ) ; }
","ERC20 friendly transferFrom function .
"
"function updateDetails ( bytes32 _details ) public returns ( bool allowed ) ;
","` updateDetails `
"
"function assingAdminship ( address _newAdmin , uint8 _level ) onlyAdmin ( 2 ) public { admin [ _newAdmin ] = _level ; emit AssignAdminship ( _newAdmin , _level ) ; }
","This function transfer the adminship of the contract to _newAdmin
"
"function bid ( ) external payable { require ( block . number < _auctionEnd ) ; uint proposedBid = _bidders [ msg . sender ] . value . add ( msg . value ) ; require ( proposedBid > _lowestBid ) ; uint startPos = 99 ; if ( _bidders [ msg . sender ] . value >= _lowestBid ) { for ( uint i = 99 ; i < 100 ; -- i ) { if ( _topBids [ i ] . bidderAddress == msg . sender ) { startPos = i ; break ; } } } uint endPos ; for ( uint j = startPos ; j < 100 ; -- j ) { if ( j != 0 && proposedBid > _topBids [ j - 1 ] . bid ) { _topBids [ j ] = _topBids [ j - 1 ] ; } else { _topBids [ j ] . bid = proposedBid ; _topBids [ j ] . bidderAddress = msg . sender ; endPos = j ; break ; } } _bidders [ msg . sender ] . value = proposedBid ; _bidders [ msg . sender ] . lastTime = now ; _lowestBid = _topBids [ 99 ] . bid ; if ( endPos < 3 ) { TopThreeChanged ( _topBids [ 0 ] . bidderAddress , _topBids [ 0 ] . bid , _topBids [ 1 ] . bidderAddress , _topBids [ 1 ] . bid , _topBids [ 2 ] . bidderAddress , _topBids [ 2 ] . bid ) ; } NewBid ( msg . sender , _bidders [ msg . sender ] . value ) ; }
","Bid ` ( msg.value ) ` ether for a chance of winning a RareCoin
"
"function addNetworkMember ( address _member , bool _isIRNAdmin , bool _isManufacturer , bool _isIRNNode , bytes32 _memberId ) public onlyIRNorOwner returns ( bool ) { NetworkMember storage m = network [ _member ] ; require ( ! m . isIRNAdmin , ""already an irn admin"" ) ; require ( ! m . isManufacturer , ""already a manufacturer"" ) ; require ( ! m . isIRNNode , ""already an irn node"" ) ; require ( m . memberId == 0 , ""already assigned a member id"" ) ; m . isIRNAdmin = _isIRNAdmin ; m . isManufacturer = _isManufacturer ; m . isIRNNode = _isIRNNode ; m . memberId = _memberId ; if ( m . isManufacturer ) { require ( _memberId != 0 , ""manufacturer id is required"" ) ; require ( manufacturerRewards [ m . memberId ] == address ( 0 ) , ""manufacturer is already assigned"" ) ; manufacturerRewards [ m . memberId ] = _member ; if ( pools [ _member ] . rewardAmount == 0 ) { pools [ _member ] . rewardAmount = settings . defaultReputationReward ( ) ; } } emit NetworkMemberAdded ( msg . sender , _member , _memberId ) ; return true ; }
","add a member to the network
"
"function forwardFunds ( uint256 amountPaid ) internal whenNotPaused { if ( goalReached ( ) ) { wallet . transfer ( amountPaid ) ; } else { vault . deposit . value ( amountPaid ) ( msg . sender ) ; } checkCompletedCrowdsale ( ) ; }
","Sends the funds to the wallet or to the refund vault smart contract if the minimum goal of tokens has n't been reached yet
"
"function setExchangeRate ( IERC223Token numeratorToken , IERC223Token denominatorToken , uint256 rateFraction ) public only ( ROLE_TOKEN_RATE_ORACLE ) { setExchangeRatePrivate ( numeratorToken , denominatorToken , rateFraction ) ; }
","please read method description in the interface
"
"function createChamp ( address _affiliateAddress ) external payable whenNotPaused isPaid ( createChampFee ) distributeInput ( _affiliateAddress ) { uint256 id = champs . push ( Champ ( 0 , 2 + randMod ( 4 ) , 1 + randMod ( 4 ) , uint256 ( 1 days ) - uint256 ( randMod ( 9 ) * 1 hours ) , 0 , 0 , 0 , leaderboard . length + 1 , 0 , uint256 ( block . timestamp ) , 0 , 0 , 0 , false ) ) - 1 ; champs [ id ] . id = id ; leaderboard . push ( id ) ; champToOwner [ id ] = msg . sender ; addressInfo [ msg . sender ] . champsCount ++ ; emit NewChamp ( id , msg . sender ) ; }
","Creates new champ
"
"function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; require ( beneficiary . send ( this . balance ) ) ; tokenReward . transfer ( beneficiary , remanent ) ; LogBeneficiaryPaid ( beneficiary ) ; LogContributorsPayout ( beneficiary , remanent ) ; }
","closure handler
"
"function split ( address boardOwner , uint _amount ) internal returns ( bool ) { emit Withdrawal ( owner , _amount / 2 ) ; owner . transfer ( _amount / 2 ) ; boardOwner . transfer ( _amount / 2 ) ; return true ; }
","split the revenue of a new player between boardOwner and contract owner
"
"function addValidatorApproval ( address validator , uint256 attributeTypeID ) external ;
","Approve the validator at address ` validator ` to issue attributes of the type with ID ` attributeTypeID ` .
"
"function addressBelongsToAccount ( address _address ) public view returns ( bool ) { return accountByAddress [ _address ] > 0 ; }
","Check if an address is associated with any user account
"
"function transfer ( address _to , uint256 _value ) public notFrozen returns ( bool success ) { require ( tradable ) ; if ( balances [ msg . sender ] >= _value && _value > 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }
","transfers sender 's tokens to a specified address .
"
"function setBlacklistedUser ( address _who ) public onlyValidator { _setBlacklistedUser ( _who ) ; }
","Sets the necessary permissions for a `` blacklisted '' user .
"
"function existsPriceOnAssetPair ( address sellAsset , address buyAsset ) view returns ( bool isExistent ) { return hasRecentPrice ( sellAsset ) && hasRecentPrice ( buyAsset ) && ( buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET ) && ( buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET ) ; }
","Checks whether data exists for a given asset pair
"
"function bid ( ) public payable auctionNotEnded isMinimumBid isHighestBid { if ( highestBidder != address ( 0 ) ) { uint lastBid = bids [ highestBidder ] ; bids [ highestBidder ] = 0 ; if ( ! highestBidder . send ( lastBid ) ) { emit CheaterBidder ( highestBidder , lastBid ) ; } } highestBidder = msg . sender ; bids [ msg . sender ] = msg . value ; auctionState = AuctionStates . Ongoing ; emit HighestBidIncreased ( msg . sender , msg . value ) ; }
","Bid on the auction with the amount of ` msg.value ` The lesser value will be refunded .
"
"function getContract ( string _contractName ) external view returns ( address _contractAddress ) ;
","Get a contract by its name
"
"function addEmissionProvider ( address _provider , uint _block ) public returns ( uint _code ) { if ( emissionProviders [ _provider ] ) { return SERVICE_CONTROLLER_EMISSION_EXIST ; } _code = _multisig ( keccak256 ( _provider ) , _block ) ; if ( OK != _code ) { return _code ; } emissionProviders [ _provider ] = true ; return OK ; }
","Add emission provider
"
"function createGrant ( address _beneficiary , uint256 _start , uint256 _amount , bool _revocable , bool _advisor ) public onlyOwner { require ( _beneficiary != address ( 0 ) && _amount > 0 && _start >= now ) ; if ( _advisor ) { tokenGrants . push ( new TokenVesting ( _beneficiary , _start , VESTING_ADVISOR_CLIFF , VESTING_ADVISOR_DURATION , _revocable ) ) ; } else { tokenGrants . push ( new TokenVesting ( _beneficiary , _start , VESTING_TEAM_CLIFF , VESTING_TEAM_DURATION , _revocable ) ) ; } transferToGrant ( tokenGrants . length . sub ( 1 ) , _amount ) ; }
","Grant vesting token to an address
"
"function proxy_contribution ( address _toAddr ) public payable { require ( _toAddr != 0x0 ) ; require ( msg . sender == tx . origin ) ; process_contribution ( _toAddr ) ; }
","This function handles receiving Ether in favor of a third party address we can use this function for buying tokens on behalf
"
"function approveKYC ( address account , bool isApproved , uint limit , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setKYCApproval ( account , isApproved , issuerFirm ) , ""Error: Unable to approve account. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . setAccountStatus ( account , isApproved , issuerFirm ) , ""Error: Unable to set account status. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . setAccountSpendingLimit ( account , limit ) , ""Error: Unable to set initial spending limit for account. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . setAccountSpendingPeriod ( account , ( now + 86400 ) ) , ""Error: Unable to set spending period for account. Please check issuerFirm and firm authority are registered"" ) ; return true ; }
","Sets approval status of specified account
"
"function triggerShutdown ( uint ofVersionId ) { trigger ( versionIdToShutdownIds [ ofVersionId ] ) ; shutDownVersion ( ofVersionId ) ; }
","Trigger shutdown of Melon version
"
"function getPledge ( uint64 idPledge ) constant returns ( uint amount , uint64 owner , uint64 nDelegates , uint64 intendedProject , uint64 commitTime , uint64 oldPledge , PledgeState pledgeState ) { Pledge storage p = findPledge ( idPledge ) ; amount = p . amount ; owner = p . owner ; nDelegates = uint64 ( p . delegationChain . length ) ; intendedProject = p . intendedProject ; commitTime = p . commitTime ; oldPledge = p . oldPledge ; pledgeState = p . pledgeState ; }
","A getter that returns the details of the specified pledge
"
"function acceptOwnership ( ) { if ( msg . sender == newOwner ) { owner = newOwner ; } }
","` newOwner ` has to accept the ownership before it is transferred Any account or any contract with the ability to call ` acceptOwnership ` can be used to accept ownership of this contract , including a contract with no other functions
"
"function fundAnswerBounty ( bytes32 question_id ) stateOpen ( question_id ) external payable { questions [ question_id ] . bounty = questions [ question_id ] . bounty . add ( msg . value ) ; LogFundAnswerBounty ( question_id , msg . value , questions [ question_id ] . bounty , msg . sender ) ; }
","Add funds to the bounty for a question
"
"function getCampaignEndDateById ( bytes32 bidId ) public view returns ( uint endDate ) { return campaigns [ bidId ] . getEndDate ( ) ; }
","Get the end date of a campaign Based on the Campaign id , return the value ( in miliseconds ) corresponding to the end Date of the campaign .
"
"function getDeedTimestamp ( string document ) public constant returns ( uint256 ) { uint256 documentHash = uint256 ( keccak256 ( document ) ) ; uint256 timestamp = documentRegistry [ documentHash ] ; require ( timestamp > 0 ) ; return timestamp ; }
","Returns a unix timestamp when the proof of existence for a document was created
"
"function freezeTransfers ( ) external ;
","Freezes all the transfers
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ( _value == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Assign allowance _value to _spender address to use the msg.sender balance
"
"function onApprove ( address _owner , address _spender , uint _amount ) returns ( bool success ) { if ( _owner == vaultAddress ) { return true ; } return false ; }
","Notifies the controller about an approval , for this EarlyTokenSale all approvals are allowed by default and no extra notifications are needed
"
"function updateCounters ( uint256 _etherAmount ) internal { etherPaid = etherPaid . add ( _etherAmount ) ; totalContributions = totalContributions . add ( 1 ) ; CountersUpdated ( etherPaid , _etherAmount ) ; }
","Updates the counters for the amount of Ether paid
"
"function granularity ( ) external view returns ( uint256 ) ;
","Provides the granularity of the token
"
"function _storeSecurityTokenData ( address _securityToken , string _ticker , string _tokenDetails , uint256 _deployedAt ) internal { set ( Encoder . getKey ( ""securityTokens_ticker"" , _securityToken ) , _ticker ) ; set ( Encoder . getKey ( ""securityTokens_tokenDetails"" , _securityToken ) , _tokenDetails ) ; set ( Encoder . getKey ( ""securityTokens_deployedAt"" , _securityToken ) , _deployedAt ) ; }
","Internal - Stores the security token details
"
"function endAuction ( ) public onlyOwner { require ( status == state . active ) ; status = state . ended ; emit Ended ( block . number ) ; }
","Ends the auction , preventing new bids from entering
"
"function rentOut ( address _to , uint256 _rentPeriod , uint256 _deedId ) external whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; rentOutMultiple ( _to , _rentPeriod , _deedIds ) ; }
","Rents a plot out to another address .
"
"function calculateHash ( uint256 _limit , uint256 _slopeFactor , uint256 _collectMinimum , bool _last , bytes32 _salt ) public constant returns ( bytes32 ) { return keccak256 ( _limit , _slopeFactor , _collectMinimum , _last , _salt ) ; }
","Calculates the hash of a curve .
"
"function getInvestorsAt ( uint256 _checkpointId ) external view returns ( address [ ] ) ;
","returns an array of investors at a given checkpoint NB - this length may differ from investorCount as it contains all investors that ever held tokens
"
"function createInitialTokens ( address _holder , uint _quantity ) ;
","Function to create initial tokens
"
"function registerTradeProfile ( bytes _registerSignature , bytes32 _strategyID , uint256 _registerFee , uint256 _periodLength , uint256 _maxMarginDeposit , uint256 _minMarginDeposit , uint256 _rewardPercentage , uint256 _nonce , bytes _transferSignature , uint256 _validUntil ) public returns ( bool ) { require ( msg . sender == bincentive ) ; require ( registerSignatures [ _registerSignature ] == false ) ; require ( transferSignatures [ _transferSignature ] == false || _transferSignature . length == 0 ) ; LocalVariableGrouping memory localVariables ; localVariables . hashedTx = ECRecovery . toEthSignedMessageHash ( registerPreSignedHashing ( address ( this ) , _strategyID , _registerFee , _periodLength , _maxMarginDeposit , _minMarginDeposit , _rewardPercentage , _nonce ) ) ; localVariables . from = ECRecovery . recover ( localVariables . hashedTx , _registerSignature ) ; require ( traderProfile [ localVariables . from ] [ _strategyID ] == address ( 0 ) ) ; if ( _registerFee > 0 ) { localVariables . tokenContract = BCNTToken ( tokenAddress ) ; localVariables . hashedTx = ECRecovery . toEthSignedMessageHash ( localVariables . tokenContract . transferPreSignedHashing ( tokenAddress , address ( this ) , _registerFee , 0 , _nonce , _validUntil ) ) ; require ( ECRecovery . recover ( localVariables . hashedTx , _transferSignature ) == localVariables . from ) ; require ( localVariables . tokenContract . transferPreSigned ( _transferSignature , address ( this ) , _registerFee , 0 , _nonce , _validUntil ) ) ; } localVariables . profileAddr = new TradeProfileProxy ( tradeProfileImplementation , abi . encodeWithSignature ( ""init(address,uint256,uint256,uint256,uint256)"" , localVariables . from , _periodLength , _maxMarginDeposit , _minMarginDeposit , _rewardPercentage ) ) ; localVariables . profile = TradeProfile ( localVariables . profileAddr ) ; traderProfile [ localVariables . from ] [ _strategyID ] = localVariables . profile ; registerSignatures [ _registerSignature ] = true ; transferSignatures [ _transferSignature ] = true ; emit RegisterTradeProfile ( localVariables . from , localVariables . profile ) ; return true ; }
","Register a trade profile
"
"function setBeneficiary ( address _beneficiary ) onlyOwner public { beneficiary = _beneficiary ; }
","Sets the address getting the proceedings from fishing in the aquarium
"
"function deedUri ( uint256 _deedId ) external view returns ( string _uri ) ;
","A distinct URI ( RFC 3986 ) for a given token .
"
"function getMatchDetails ( bytes32 _orderID ) external view returns ( bool settled , bool orderIsBuy , bytes32 matchedID , uint256 priorityVolume , uint256 secondaryVolume , uint256 priorityFee , uint256 secondaryFee , uint32 priorityToken , uint32 secondaryToken ) { matchedID = orderbookContract . orderMatch ( _orderID ) ; orderIsBuy = isBuyOrder ( _orderID ) ; ( bytes32 buyID , bytes32 sellID ) = orderIsBuy ? ( _orderID , matchedID ) : ( matchedID , _orderID ) ; SettlementDetails memory settlementDetails = calculateSettlementDetails ( buyID , sellID , getTokenDetails ( orderDetails [ buyID ] . tokens ) ) ; return ( orderStatus [ _orderID ] == OrderStatus . Settled || orderStatus [ _orderID ] == OrderStatus . Slashed , orderIsBuy , matchedID , settlementDetails . leftVolume , settlementDetails . rightVolume , settlementDetails . leftTokenFee , settlementDetails . rightTokenFee , uint32 ( orderDetails [ buyID ] . tokens >> 32 ) , uint32 ( orderDetails [ buyID ] . tokens ) ) ; }
","Retrieves the settlement details of an order .
"
"function unpause ( ) public onlyMEGO whenPaused { paused = false ; }
","This is public rather than external so it can be called by derived contracts .
"
"function burn ( uint256 _amount ) userNotBlacklisted ( msg . sender ) public whenNotPaused { _burn ( msg . sender , _amount ) ; }
","Remove CUSD from supply
"
"function remainingTokens ( ) public view returns ( uint256 ) { return balances [ address ( 0 ) ] ; }
","Return the number of tokens not provisioned
"
"function removeAdmin ( address _admin ) public onlyOwner { admins [ _admin ] = false ; }
","Only owner is able to remove admin
"
"function honourWhitelist ( ) private returns ( bool ) { bool honourWhitelist = true ; if ( honourWhitelistEnd <= now ) { honourWhitelist = false ; preSaleCap = preSaleCap . add ( whitelistedPlannedContributions ) ; whitelistedPlannedContributions = 0 ; WhitelistedCounterUpdated ( whitelistedPlannedContributions , 0 ) ; } return honourWhitelist ; }
","Returns true if the whitelist period is still active , false otherwise .
"
"function transfer ( address _to , uint256 _value , bytes _data ) public onlyIfLockTimePassed returns ( bool ) { require ( transfer ( _to , _value ) ) ; uint codeLength ; assembly { codeLength := extcodesize ( _to ) } if ( codeLength > 0 ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } return true ; }
","Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract .
"
"function buyAssetPack ( address _to , uint _assetPackId ) public payable { require ( ! checkHasPermissionForPack ( _to , _assetPackId ) ) ; AssetPack memory assetPack = assetPacks [ _assetPackId ] ; require ( msg . value >= assetPack . price ) ; artistBalance [ assetPack . creator ] += msg . value * 95 / 100 ; artistBalance [ owner ] += msg . value * 5 / 100 ; boughtAssetPacks [ _to ] . push ( _assetPackId ) ; hasPermission [ _to ] [ _assetPackId ] = true ; emit AssetPackBought ( _assetPackId , _to ) ; }
","Method to buy right to use specific asset pack
"
"function giveMeToken ( DSToken token ) public auth { token . transfer ( msg . sender , token . balanceOf ( this ) ) ; }
","transfer any token from this contract to the sender
"
"function price ( ) public view returns ( uint256 _price ) { if ( block . timestamp <= start . add ( BONUS_DURATION_1 ) ) { return tokenPerEth . mul ( BONUS_TIER1 ) . div ( 1e2 ) ; } else if ( block . timestamp <= start . add ( BONUS_DURATION_2 ) ) { return tokenPerEth . mul ( BONUS_TIER2 ) . div ( 1e2 ) ; } else if ( block . timestamp <= start . add ( BONUS_DURATION_3 ) ) { return tokenPerEth . mul ( BONUS_TIER3 ) . div ( 1e2 ) ; } return tokenPerEth ; }
","Calculates the price as tokens/ether based on the corresponding bonus bracket .
"
"function setReleaseDate ( uint256 _releaseDate ) external onlyAdmin whenNotPaused { require ( releaseDate == 0 ) ; require ( _releaseDate > now ) ; releaseDate = _releaseDate ; emit BonusReleaseDateSet ( _releaseDate ) ; }
","Enables the administrators to set the bonus release date.Please note that the release date can only be set once .
"
"function implementsERC165InterfaceNoCache ( address _contract , bytes4 _interfaceId ) public view returns ( bool ) { uint256 success ; uint256 result ; ( success , result ) = noThrowCall ( _contract , ERC165ID ) ; if ( success == 0 || result == 0 ) { return false ; } ( success , result ) = noThrowCall ( _contract , INVALID_ID ) ; if ( success == 0 || result != 0 ) { return false ; } ( success , result ) = noThrowCall ( _contract , _interfaceId ) ; if ( success == 1 && result == 1 ) { return true ; } return false ; }
","Checks whether a contract implements an ERC165 interface or not without using nor updating the cache .
"
"function addManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && ! admins [ account ] && account != owner ) { admins [ account ] = true ; emit AdminAdded ( _accounts [ i ] ) ; } } return true ; }
","Adds multiple addresses to the administrator list .
"
"function burn ( uint256 _amount , bytes _holderData ) public onlyOwner { super . burn ( _amount , _holderData ) ; }
","Burns ` _amount ` tokens from ` _tokenHolder ` Silly example of overriding the ` burn ` function to only let the owner burn its tokens .
"
"function preICO ( address _beneficiary , uint256 _amount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , ""Buyer is not whitelisted"" ) ; uint256 amount = _amount . mul ( E18 ) ; require ( totalSupply_ . add ( amount ) <= TOTAL_SUPPLY_LIMIT ) ; uint256 remainingTokens = TOTAL_SUPPLY_LIMIT . sub ( totalSupply_ ) ; require ( amount <= remainingTokens ) ; preICOTokenIssuedTotal = preICOTokenIssuedTotal . add ( amount ) ; super . mint ( _beneficiary , amount ) ; emit Transfer ( address ( PREICO_EVENT ) , _beneficiary , amount ) ; }
","Pre ICO handler
"
"function getTokenBalance ( Data storage self , string currency , address account ) internal view returns ( uint balance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getUint ( id ) ; }
","Get the token balance for a given account
"
"function forgeItems ( uint256 _parentItemID , uint256 _childItemID ) external onlyOwnerOfItem ( _parentItemID ) onlyOwnerOfItem ( _childItemID ) ifItemForSaleThenCancelSale ( _parentItemID ) ifItemForSaleThenCancelSale ( _childItemID ) { require ( _parentItemID != _childItemID ) ; Item storage parentItem = items [ _parentItemID ] ; Item storage childItem = items [ _childItemID ] ; if ( childItem . onChamp ) { takeOffItem ( childItem . onChampId , childItem . itemType ) ; } parentItem . attackPower = ( parentItem . attackPower > childItem . attackPower ) ? parentItem . attackPower : childItem . attackPower ; parentItem . defencePower = ( parentItem . defencePower > childItem . defencePower ) ? parentItem . defencePower : childItem . defencePower ; parentItem . cooldownReduction = ( parentItem . cooldownReduction > childItem . cooldownReduction ) ? parentItem . cooldownReduction : childItem . cooldownReduction ; parentItem . itemRarity = uint8 ( 6 ) ; transferItem ( msg . sender , address ( 0 ) , _childItemID ) ; emit Forge ( _parentItemID ) ; }
","Forge items together
"
"function destroyBeneficiary ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; token . transfer ( owner , balance ) ; totalReleased = totalReleased . add ( balance ) ; beneficiary . isBeneficiary = false ; beneficiary . released = beneficiary . released . add ( balance ) ; BeneficiaryDestroyed ( _beneficiary ) ; }
","Allows the owner to destroy a beneficiary .
"
"function finalizeInvestorsByList ( address [ ] investors ) public onlyOwner mustBeAtStage ( Stage . Finished ) { for ( uint256 i = 0 ; i < investors . length ; i ++ ) { finalizeSingleInvestor ( investors [ i ] ) ; } }
","Transfers tokens to whitelisted addresses
"
"function transfer ( address to , uint tokens ) public returns ( bool success ) ;
","send ` tokens ` token to ` to ` from ` msg.sender `
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalPixels = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 pixelId ; for ( pixelId = 0 ; pixelId <= totalPixels ; pixelId ++ ) { if ( pixelIndexToOwner [ pixelId ] == _owner ) { result [ resultIndex ] = pixelId ; resultIndex ++ ; } } return result ; } }
","Returns a list of all Pixel IDs assigned to an address .
"
"function cancelMilestone ( uint _idMilestone ) onlyRecipient campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) && ( milestone . status != MilestoneStatus . Completed ) ) throw ; milestone . status = MilestoneStatus . Canceled ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }
","` onlyRecipient ` Cancels a previously accepted milestone
"
"function setMaxDividendDepth ( uint256 _maxDividendDepth ) external onlyCFO { maxDividendDepth = _maxDividendDepth ; }
","Set the maximum dividend depth .
"
"function confirmCustodianChangeProxy ( bytes32 _lockId ) public onlyCustodian { erc20Impl . confirmCustodianChange ( _lockId ) ; }
","Pass-through control of custodian change confirmation , allowing this contract 's custodian to act as the custodian of the associated active token implementation .
"
"function burn ( uint256 _value ) public whenNotPaused { super . burn ( _value ) ; }
","Burns the coins held by the sender .
"
"function partialRelease ( address who , address tradingWallet , uint256 amount ) public onlyTransferAgent returns ( bool ) { require ( tradingWallet != 0 , ""The destination wallet cannot be null."" ) ; require ( ! isExistingHolding ( tradingWallet ) , ""The destination wallet must be a new fresh wallet."" ) ; Holding memory holding = heldTokens [ who ] ; require ( holding . isAffiliate , ""Only affiliates can use this function; use release() for non-affiliates."" ) ; require ( amount <= holding . quantity , ""The holding has less than the specified amount of tokens."" ) ; if ( block . timestamp > holding . releaseDate ) { bool res = ERC20Interface ( tokenContract ) . transfer ( tradingWallet , amount ) ; if ( res ) { heldTokens [ who ] = Holding ( holding . quantity . sub ( amount ) , holding . releaseDate , holding . isAffiliate ) ; emit TokensReleased ( who , amount ) ; return true ; } } return false ; }
","Release some of an affiliate 's tokens to a broker/trading wallet .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( ! funding_ended ) throw ; if ( msg . sender == founders ) throw ; var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
","Transfer ` _value ` SAT tokens from sender 's account ` msg.sender ` to provided account address ` _to ` .
"
"function getExpiryLimit ( ) public view returns ( uint256 ) { return getUint ( EXPIRYLIMIT ) ; }
","Gets the expiry limit
"
"function getStakeBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return members [ memberAddress ] . stakeBalance ; }
","Called to obtain the stake balance of any given member
"
"function setAffiliate ( address who , bool isAffiliate ) public onlyTransferAgent returns ( bool ) { require ( who != 0 , ""The null address cannot be used."" ) ; Holding memory holding = heldTokens [ who ] ; require ( holding . isAffiliate != isAffiliate , ""Attempt to set the same affiliate status that is already set."" ) ; heldTokens [ who ] = Holding ( holding . quantity , holding . releaseDate , isAffiliate ) ; emit AffiliateStatusChanged ( who , isAffiliate ) ; return true ; }
","Company affiliates have added restriction , allow the Transfer Agent set/clear this flag as needed .
"
"function transferAndCall ( address to , uint256 value , bytes data ) public returns ( bool ) ;
","Transfer tokens from ` msg.sender ` to another address and then call ` onTransferReceived ` on receiver
"
"function withdrawBalance ( ) external onlyFinancialOfficer { financialOfficerAddress . transfer ( address ( this ) . balance ) ; }
","Collect funds from this contract
"
"function releaseTo ( address _beneficiary ) public onlyOwner { release ( _beneficiary ) ; }
","Allows the owner to transfers vested tokens to beneficiary .
"
"function getStartTime ( ) internal constant returns ( uint ) { return 1508346000 ; }
","start time of the pre-ICO
"
"function getODEMClaim ( address subject , bytes32 key ) public view returns ( bytes uri , bytes32 hash ) { address resolved = resolveAddress ( subject ) ; return ( claims [ resolved ] [ key ] . uri , claims [ resolved ] [ key ] . hash ) ; }
","Get an ODEM claim .
"
"function mintToken ( address _target , uint256 _mintedAmount ) onlyAdmin public { balances [ _target ] = SafeMath . add ( balances [ _target ] , _mintedAmount ) ; totalSupply = SafeMath . add ( totalSupply , _mintedAmount ) ; Transfer ( 0 , this , _mintedAmount ) ; Transfer ( this , _target , _mintedAmount ) ; }
","Mint _mintedAmount tokens to _target address .
"
"function tokenOfOwnerByIndex ( address owner , uint256 index ) public view returns ( uint256 tokenId ) ;
","Enumerate tokens assigned to an owner
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public erc20 returns ( bool success ) { require ( _amount <= mAllowed [ _from ] [ msg . sender ] ) ; mAllowed [ _from ] [ msg . sender ] = mAllowed [ _from ] [ msg . sender ] . sub ( _amount ) ; doSend ( msg . sender , _from , _to , _amount , """" , """" , false ) ; return true ; }
","ERC20 backwards compatible transferFrom .
"
"function withdrawBoardMeetingFees ( ) returns ( bool ) ;
","Function to withdraw the rewarded board meeting fees
"
"function ( ) payable { m_analytics . iaInvestedBy . value ( msg . value ) ( msg . sender ) ; }
","forward payment to analytics-capable contract
"
"function setParams ( address feeContract ) onlyOwner public returns ( bool success ) { require ( lib . setFeeContract ( feeContract ) , ""Error: Unable to set fee contract. Ensure contract is allowed by storage contract."" ) ; return true ; }
","Sets Merchant globals and fee paramters
"
"function send ( address _to , uint256 _amount , bytes _userData ) public whenNotPaused { doSend ( msg . sender , _to , _amount , _userData , msg . sender , """" , true ) ; }
","Send ` _amount ` of tokens to address ` _to ` passing ` _userData ` to the recipient
"
"function getMasterpiece ( uint256 _tokenId ) external view returns ( string name , string artist , uint256 birthTime , uint256 snatchWindow , uint256 sellingPrice , address owner ) { Masterpiece storage masterpiece = masterpieces [ _tokenId ] ; name = masterpiece . name ; artist = masterpiece . artist ; birthTime = uint256 ( masterpiece . birthTime ) ; snatchWindow = masterpieceToSnatchWindow [ _tokenId ] ; sellingPrice = masterpieceToPrice [ _tokenId ] ; owner = masterpieceToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific masterpiece .
"
"function claim ( ) public onlyOwner { require ( now >= releaseTime , ""now >= releaseTime"" ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 , ""amount > 0"" ) ; token . safeTransfer ( owner , amount ) ; }
","Transfers tokens held by timelock to owner .
"
"function getWithdrawalData ( uint _withdrawalID ) constant public returns ( uint , bool , bytes , address [ ] , uint , address [ ] ) { return ( withdrawals [ _withdrawalID ] . Amount , withdrawals [ _withdrawalID ] . approved , withdrawals [ _withdrawalID ] . reason , withdrawals [ _withdrawalID ] . backerApprovals , withdrawals [ _withdrawalID ] . totalStake , withdrawals [ _withdrawalID ] . destination ) ; }
","check withdrawal status of ` _withdrawalID `
"
"function getSolid ( uint256 _tokenId ) public view returns ( string solidName , uint256 price , address currentOwner , uint256 bagHolderFund , bool isBagFundAvailable ) { Solid storage solid = solids [ _tokenId ] ; solidName = solid . name ; price = priceOf ( _tokenId ) ; currentOwner = solidIndexToOwner [ _tokenId ] ; bagHolderFund = solid . bagHolderFund ; isBagFundAvailable = now > ( solid . saleTime + priceFallDuration ) ; }
","Returns all the relevant information about a specific solid .
"
"function uintToBytes ( uint256 _v ) internal pure returns ( bytes ) { uint256 v = _v ; if ( v == 0 ) { return ""0"" ; } uint256 digits = 0 ; uint256 v2 = v ; while ( v2 > 0 ) { v2 /= 10 ; digits += 1 ; } bytes memory result = new bytes ( digits ) ; for ( uint256 i = 0 ; i < digits ; i ++ ) { result [ digits - i - 1 ] = bytes1 ( ( v % 10 ) + 48 ) ; v /= 10 ; } return result ; }
","Converts a number to its string/bytes representation
"
"function addSynth ( Synth synth ) external optionalProxy_onlyOwner { bytes4 currencyKey = synth . currencyKey ( ) ; require ( synths [ currencyKey ] == Synth ( 0 ) , ""Synth already exists"" ) ; availableSynths . push ( synth ) ; synths [ currencyKey ] = synth ; emitSynthAdded ( currencyKey , synth ) ; }
","Add an associated Synth contract to the Synthetix system
"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; require ( state == SaleState . PrivateSale || state == SaleState . PreSale || state == SaleState . PublicSaleTier1 || state == SaleState . PublicSaleTier2 || state == SaleState . PublicSaleTier3 || state == SaleState . PublicSaleTier4 ) ; }
","Checks the state when validating a purchase
"
"function handleBelowPlannedWhitelistedContribution ( uint256 plannedContribution ) private returns ( uint256 , uint256 ) { uint256 belowPlanned = plannedContribution . sub ( msg . value ) ; preSaleCap = preSaleCap . add ( belowPlanned ) ; updateWhitelistedContribution ( msg . value ) ; AllowedContributionCheck ( msg . value , AllowedContributionState . BelowWhitelisted ) ; return ( msg . value , 0 ) ; }
","Returns the contribution and refund value to be used when the transaction value is lower than the whitelisted contribution for the sender .
"
"function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = ""ManualApproval"" ; availableTags [ 1 ] = ""Transfer Restriction"" ; return availableTags ; }
","Get the tags related to the module factory
"
"function transferToken ( Token _tokenContract , address _transferTo , uint256 _value ) onlyOwner external { _tokenContract . transfer ( _transferTo , _value ) ; }
","Send ERC20 tokens away .
"
"function isMember ( address memberAddress ) public view returns ( bool ) { return ( communityAccount . stakedBalances ( memberAddress ) >= minimumStakingRequirement ) ; }
","Checks that the user is fully staked
"
"function destroy ( ) external requireGod { selfdestruct ( godAddress ) ; }
","! ! !
"
"function howMuchCanXContributeNow ( address _beneficiary ) view public returns ( uint256 ) { require ( _beneficiary != address ( 0 ) ) ; if ( ! hasStarted ( ) || hasEnded ( ) ) { return 0 ; } uint256 weiToCap = cap . sub ( weiRaised ) ; uint8 _saleDay = getSaleDayNow ( ) ; if ( _saleDay <= whitelistDayCount ) { if ( ! whitelist [ _beneficiary ] ) { return 0 ; } uint256 weiToPersonalCap = whitelistDayMaxStake [ _saleDay ] . sub ( stakes [ _beneficiary ] ) ; if ( msg . value > 0 && maxGasPrice > 0 && tx . gasprice > maxGasPrice ) { weiToPersonalCap = weiToPersonalCap . mul ( 100 ) . div ( maxGasPricePenalty ) ; } weiToCap = uint256Min ( weiToCap , weiToPersonalCap ) ; } return weiToCap ; }
","How many wei can an ethereum address contribute now .
"
"function withdrawalEth ( uint256 amount ) onlyOwner public { require ( this . balance >= amount ) ; msg . sender . transfer ( amount ) ; }
","withdrawal ` amount ` eth from contract
"
"function addAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 validatorFee , bytes signature ) external payable { require ( ! _attributeTypes [ attributeTypeID ] . onlyPersonal , ""only operatable attributes may be added on behalf of another address"" ) ; require ( ! _issuedAttributes [ account ] [ attributeTypeID ] . exists , ""duplicate attributes are not supported, remove existing attribute first"" ) ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; uint256 stake = msg . value . sub ( validatorFee ) . sub ( jurisdictionFee ) ; require ( stake >= minimumStake , ""attribute requires a greater value than is currently provided"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( address ( this ) , account , msg . sender , msg . value , validatorFee , attributeTypeID , value ) ) ; require ( ! _invalidAttributeApprovalHashes [ hash ] , ""signed attribute approvals from validators may not be reused"" ) ; address signingKey = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; address validator = _signingKeys [ signingKey ] ; require ( canValidate ( validator , attributeTypeID ) , ""signature does not match an approved validator for provided attribute"" ) ; _issuedAttributes [ account ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , setPersonally : false , operator : msg . sender , validator : validator , value : value , stake : stake } ) ; _invalidAttributeApprovalHashes [ hash ] = true ; emit AttributeAdded ( validator , account , attributeTypeID , value ) ; if ( stake > 0 ) { emit StakeAllocated ( msg . sender , attributeTypeID , stake ) ; } if ( jurisdictionFee > 0 ) { if ( owner ( ) . send ( jurisdictionFee ) ) { emit FeePaid ( owner ( ) , msg . sender , attributeTypeID , jurisdictionFee ) ; } } if ( validatorFee > 0 ) { if ( validator . send ( validatorFee ) ) { emit FeePaid ( validator , msg . sender , attributeTypeID , validatorFee ) ; } } }
","Add an attribute of the type with ID ` attributeTypeID ` , an attribute value of ` value ` , and an associated validator fee of ` validatorFee ` to account ` account ` by passing in a signed attribute approval with signature ` signature ` .
"
"function totalSupply ( ) constant returns ( uint256 _totalSupply ) { return totalSupply ; }
","Used to retrieve total supply
"
"function checkSig ( bytes32 _hash , uint8 _v , bytes32 _r , bytes32 _s ) internal view { address signer = ecrecover ( keccak256 ( abi . encodePacked ( ""\x19Ethereum Signed Message:\n32"" , _hash ) ) , _v , _r , _s ) ; require ( signer == ISecurityToken ( securityToken ) . owner ( ) || signer == signingAddress , ""Incorrect signer"" ) ; }
","used to verify the signature
"
"function checkSplitEnd ( uint256 i ) internal { if ( i == users . length - 1 ) { assetThaw ( ) ; balances [ 0x66AE070A8501E816CA95ac99c4E15C7e132fd289 ] = balances [ 0x66AE070A8501E816CA95ac99c4E15C7e132fd289 ] + currentProfits / 20 ; balances [ selfAddress ] = balances [ selfAddress ] - actualProfitSplit - currentProfits / 20 ; } }
","Change variables on split end
"
"function onTransfer ( address _from , address , uint ) public returns ( bool success ) { if ( _from == controller || _from == address ( this ) ) { return true ; } return transferable ; }
","Notifies the controller about a transfer , for this TokenSale all transfers are allowed by default and no extra notifications are needed
"
"function setLockupPeriodSeconds ( uint _lockupPeriodSeconds ) public onlyCurator { lockupPeriodSeconds = _lockupPeriodSeconds ; logger . emitGenericLog ( ""setLockupPeriodSeconds"" , """" ) ; }
","Sets lockup period for community staking
"
"function rateForCurrency ( bytes4 currencyKey ) public view returns ( uint ) { return rates [ currencyKey ] ; }
","Retrieve the rate for a specific currency
"
"function getTokenVersion ( Data storage self , address contractAddress ) internal view returns ( string ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.version' , contractAddress ) ) ; return self . Storage . getString ( id ) ; }
","Get the token version for Token interfaces
"
"function getStatusContract ( address _contractAddress ) external view returns ( uint8 ) { return trustedCurrencyContracts [ _contractAddress ] ; }
","Gets the status of a trusted currencyContract .
"
"function withdraw ( ) public returns ( bool ) { uint amount ; if ( msg . sender == owner ) { amount = ownersBalance ; ownersBalance = 0 ; } else if ( msg . sender == winner ) { amount = pot ; pot = 0 ; } msg . sender . transfer ( amount ) ; }
","Withdrawal function for winner and admin
"
"function requestMortgage ( Engine engine , bytes32 loanIdentifier , uint256 deposit , LandMarket landMarket , uint256 landId , TokenConverter tokenConverter ) external returns ( uint256 id ) { return requestMortgageId ( engine , landMarket , engine . identifierToIndex ( loanIdentifier ) , deposit , landId , tokenConverter ) ; }
","Requests a mortgage with a loan identifier
"
"function configure ( uint256 _maxHolderPercentage ) public onlyFactory { maxHolderPercentage = _maxHolderPercentage ; }
","Used to intialize the variables of the contract
"
"function setSynthetix ( Synthetix _synthetix ) external onlyOwner { synthetix = _synthetix ; emit SynthetixUpdated ( _synthetix ) ; }
","Set the Synthetix contract that the issuance controller uses to issue SNX .
"
"function transfer ( address _receiver , uint256 _amount ) public returns ( bool success ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; emit Transfer ( msg . sender , _receiver , _amount ) ; return true ; }
","Used to transfer funds
"
"function exchangeFeeIncurred ( uint value ) public view returns ( uint ) { return value . multiplyDecimal ( exchangeFeeRate ) ; }
","Calculate the fee charged on top of a value being sent via an exchange
"
"function changePolyRegisterationFee ( uint256 _registrationFee ) public onlyOwner { require ( registrationFee != _registrationFee ) ; emit LogChangePolyRegisterationFee ( registrationFee , _registrationFee ) ; registrationFee = _registrationFee ; }
","set the ticker registration fee in POLY tokens
"
"function initLogo ( ) public onlyOwner { require ( isLogoInitied == false ) ; isLogoInitied = true ; logoId = token . mint ( platformWallet , logoX , logoY , 10 , 10 , 0 ether , 0 ether ) ; token . setTokenMetadata ( logoId , """" ) ; updateTierStatus ( 100 , 0 ) ; emit Minted ( msg . sender , logoId , logoX , logoY , 10 , 10 , 0 ether , 0 ether , now ) ; }
","init logo , call it as soon as possible call it after setting platform in the token Logo is BigIOToken which has 1010 size and position in the center of map
"
"function symbolsCount ( ) public view returns ( uint ) { return symbols . length ; }
","Provides a cheap way to get number of symbols registered in a platform
"
"function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { uint256 maxGasPrice = resolveExchangeAddress ( ) . maxGasPrice ( ) ; return ( maxGasPrice >= tx . gasprice ) ; }
","Perform exchange-specific checks on the given order
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { _transferFrom ( _from , _to , _tokenId ) ; }
","Transfer a Asset owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function removeOracles ( address [ ] _blacklist ) onlyContractOwner external returns ( uint ) { for ( uint _idx = 0 ; _idx < _blacklist . length ; ++ _idx ) { address _oracle = _blacklist [ _idx ] ; if ( _oracle != 0x0 && oracles [ _oracle ] ) { delete oracles [ _oracle ] ; _emitOracleRemoved ( _oracle ) ; } } return OK ; }
","Removes oracles from whitelist .
"
"function USDtoHAV ( uint usd_dec ) public view priceNotStale returns ( uint ) { return safeDiv_dec ( usd_dec , price ) ; }
","The value in HAV for a given amount of USD
"
"function symbol ( ) public pure returns ( string _deedSymbol ) { _deedSymbol = ""DWP"" ; }
","Symbol of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata .
"
"function founderSwitchRequest ( bytes32 _founderHash , bytes32 _oneTimesharedPhrase ) returns ( bool success ) { if ( sha3 ( _founderHash ) != founderHash ) throw ; tempHashes [ msg . sender ] = sha3 ( msg . sender , founderHash , _oneTimesharedPhrase ) ; FounderSwitchRequestEvent ( msg . sender ) ; return true ; }
","Founder address update to ` _newFounderAddr.address ( ) ` is being requested
"
"function setApprovalForAll ( address _to , bool _approved ) public validAddress ( _to ) { require ( _to != msg . sender , ""Cannot approve self"" ) ; operatorApprovals [ msg . sender ] [ _to ] = _approved ; emit ApprovalForAll ( msg . sender , _to , _approved ) ; }
","Set or unset the approval of operator ` ( _to ) `
"
"function validateRevokeForSig ( address _sender , bytes32 _link , bytes32 _nonce , bytes _delegationSig ) private { bytes32 _delegationDigest = generateRevokeAttestationForDelegationSchemaHash ( _link , _nonce ) ; require ( _sender == recoverSigner ( _delegationDigest , _delegationSig ) , 'Invalid RevokeFor Signature' ) ; burnSignatureDigest ( _delegationDigest , _sender ) ; }
","Verify revocation signature is valid
"
"function reparametrizeMultisig ( bytes32 msigId , uint unlockTime ) public payable { Multisig storage multisig = hashIdToMultisig [ msigId ] ; assert ( multisig . deposit + msg . value >= multisig . deposit ) ; multisig . deposit += msg . value ; assert ( multisig . unlockTime <= unlockTime ) ; multisig . unlockTime = unlockTime ; }
","Deposit msg.value ether into a multisig and set unlockTime
"
"function orderPriority ( bytes32 _orderID ) external view returns ( uint256 ) { return orders [ _orderID ] . priority ; }
","returns the priority of the given orderID .
"
"function tweakUpgrading ( ) external onlyOwner { upgrading = ! upgrading ; Upgrading ( upgrading ) ; }
","Enable upgrading to allow tokens migration to new contract process .
"
"function move ( address _from , address _to , uint256 _amount ) external onlyModule returns ( bool ) { balances [ _from ] = balances [ _from ] . sub ( _amount ) ; emit BalanceAdj ( msg . sender , _from , _amount , ""-"" ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit BalanceAdj ( msg . sender , _to , _amount , ""+"" ) ; return true ; }
","moving ` _amount ` from ` _from ` to ` _to `
"
"function mintCUSD ( address _to , uint256 _amount ) public requiresPermission whenNotPaused userWhitelisted ( _to ) { return _mintCUSD ( _to , _amount ) ; }
","Mints CarbonUSD for the user .
"
"function manuallyExchangeContractPreDGZtoDGZ ( address _address , uint preDGZAmount ) public onlyOwner { require ( _address != address ( 0 ) ) ; require ( preDGZAmount > 0 ) ; uint amountSendTokens = preDGZAmount * preDGZtoDGZExchangeRate / 100000000 ; preBalanceOf [ _address ] += preDGZAmount ; tokenReward . transfer ( _address , amountSendTokens ) ; }
","This function is needed to handled unlikely case when person who owns preDGZ tokens makes a mistake and send them to smartcontract without setting the allowance in advance .
"
"function approve ( address _spender , uint _value ) public returns ( bool ) { require ( _spender != 0x0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to transfer ` _value ` tokens from ` msg.sender ` to any address .
"
"function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( ""pMinDeposit"" ) ; bytes32 propID = keccak256 ( _name , _value ) ; if ( keccak256 ( _name ) == keccak256 ( 'dispensationPct' ) || keccak256 ( _name ) == keccak256 ( 'pDispensationPct' ) ) { require ( _value <= 100 ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( ""pApplyStageLen"" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry , msg . sender ) ; return propID ; }
","propose a reparamaterization of the key _name 's value to _value .
"
"function getUserEntryStatuses ( ) external view returns ( uint32 [ ] , uint32 [ ] ) { uint32 [ ] memory dates = userToDates [ msg . sender ] ; uint256 datesLength = dates . length ; uint32 [ ] memory statuses = new uint32 [ ] ( datesLength ) ; for ( uint256 i = 0 ; i < datesLength ; i ++ ) { statuses [ i ] = uint32 ( userDateToStatus [ msg . sender ] [ dates [ i ] ] ) ; } return ( dates , statuses ) ; }
","Does n't change state
"
"function cancelOrder ( address onExchange , uint id ) returns ( bool success ) { success = SimpleMarket ( onExchange ) . cancel ( id ) ; OrderUpdated ( id ) ; }
","Cancels an order on the given exchange
"
"function maxIssuableNomins ( address issuer ) view public priceNotStale returns ( uint ) { if ( ! isIssuer [ issuer ] ) { return 0 ; } if ( escrow != HavvenEscrow ( 0 ) ) { uint totalOwnedHavvens = safeAdd ( tokenState . balanceOf ( issuer ) , escrow . balanceOf ( issuer ) ) ; return safeMul_dec ( HAVtoUSD ( totalOwnedHavvens ) , issuanceRatio ) ; } else { return safeMul_dec ( HAVtoUSD ( tokenState . balanceOf ( issuer ) ) , issuanceRatio ) ; } }
","The maximum nomins an issuer can issue against their total havven quantity .
"
"function name ( ) external pure returns ( string _name ) { return ""BlockchainCuties"" ; }
","A descriptive name for a collection of NFTs in this contract
"
"function setAllowPrimaryIssuance ( bool _allowPrimaryIssuance ) public withPerm ( ADMIN ) { require ( _allowPrimaryIssuance != allowPrimaryIssuance , ""Must change setting"" ) ; allowPrimaryIssuance = _allowPrimaryIssuance ; emit SetAllowPrimaryIssuance ( _allowPrimaryIssuance , now ) ; }
","sets whether or not to consider primary issuance transfers
"
"function removeBeneficiary ( address beneficiary ) external onlyOwner { Info storage info = _info [ beneficiary ] ; require ( info . known , ""The address you are trying to remove is unknown to the contract"" ) ; _release ( beneficiary ) ; info . known = false ; info . totalAmount = 0 ; info . receivedAmount = 0 ; info . startTime = 0 ; info . releaseTime = 0 ; }
","Remove a beneficiary from the contract , preventing them from retrieving tokens in the future .
"
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } }
","Transfer tokens to account
"
"function applyHotFix ( address newICO ) public validAddress ( newICO ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { EthPriceDependent next = EthPriceDependent ( newICO ) ; next . topUp . value ( this . balance ) ( ) ; m_token . transfer ( newICO , m_token . balanceOf ( this ) ) ; }
","send everything to the new ( fixed ) ico smart contract
"
"function getWeiCollected ( ) public constant returns ( uint ) { return m_funds . totalInvested ( ) ; }
","amount of wei collected
"
"function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description ) { return _attributeTypes [ attributeTypeID ] . description ; }
","Get a description of the attribute type with ID ` attributeTypeID ` .
"
"function finishedSale ( ) public { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( started ) ; require ( ! finished ) ; finished = true ; emit FinishedSale ( ) ; }
","Function to finish this sale
"
"function refundable ( bytes32 _swapID ) external view returns ( bool ) { return ( now >= swaps [ _swapID ] . timelock && swapStates [ _swapID ] == States . OPEN ) ; }
","Checks whether a swap is refundable or not .
"
"function freezeGame ( uint gameId ) external onlyOwner whenGameIsOpen ( gameId ) { games [ gameId ] . state = GameStates . Frozen ; emit GameHasFrozen ( gameId ) ; }
","We use this function to froze a game
"
"function cancelAuction ( uint256 _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenId , seller ) ; }
","This is a state-modifying function that can be called while the contract is paused .
"
"function _removeToken ( address _from , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _from ) ; uint256 tokenIndex = ownedTokensIndex [ _tokenId ] ; uint256 lastTokenIndex = balanceOf ( _from ) . sub ( 1 ) ; uint256 lastToken = ownedTokens [ _from ] [ lastTokenIndex ] ; tokenOwner [ _tokenId ] = 0 ; ownedTokens [ _from ] [ tokenIndex ] = lastToken ; ownedTokens [ _from ] [ lastTokenIndex ] = 0 ; ownedTokens [ _from ] . length -- ; ownedTokensIndex [ _tokenId ] = 0 ; ownedTokensIndex [ lastToken ] = tokenIndex ; totalTokens = totalTokens . sub ( 1 ) ; }
","Internal function to remove a token ID from the list of a given address
"
"function tokenTransfer ( address _to , uint _value ) onlyOwner public { _transfer ( this , _to , _value ) ; }
","Allow contract to transfer tokens directly
"
"function changeResource ( bytes32 _resource ) public returns ( bool ) ;
","Change the resource to ` _resource `
"
"function setup ( address _tokenAddress ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _tokenAddress != 0x0 ) ; token = xChaingeToken ( _tokenAddress ) ; numTokensAuctioned = token . balanceOf ( address ( this ) ) ; tokenMultiplier = 10 ** uint ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; }
","Set ` _tokenAddress ` as the token address to be used in the auction .
"
"function getBorrowRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory _utilizationRate , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory standardBorrowRate ) = divScalar ( annualBorrowRate , blocksPerYear ) ; assert ( err1 == Error . NO_ERROR ) ; _utilizationRate ; ( Error err2 , uint finalBorrowRate ) = div ( standardBorrowRate . mantissa , 2 ) ; assert ( err2 == Error . NO_ERROR ) ; return ( uint ( IRError . NO_ERROR ) , finalBorrowRate ) ; }
","Gets the current borrow interest rate based on the given asset , total cash and total borrows
"
"function addToken ( bytes32 _name32 , bytes32 _symbol32 , bytes32 _fiatCurrency32 , address _custodian , uint256 _totalSupply , uint256 _startTimeForFundingPeriod , uint256 _durationForFiatFundingPeriod , uint256 _durationForEthFundingPeriod , uint256 _durationForActivationPeriod , uint256 _fundingGoalInCents ) public onlyActiveBroker returns ( address ) { address _tokenAddress = createPoaTokenProxy ( ) ; IPoaToken ( _tokenAddress ) . initializeToken ( _name32 , _symbol32 , msg . sender , _custodian , registry , _totalSupply ) ; IPoaCrowdsale ( _tokenAddress ) . initializeCrowdsale ( _fiatCurrency32 , _startTimeForFundingPeriod , _durationForFiatFundingPeriod , _durationForEthFundingPeriod , _durationForActivationPeriod , _fundingGoalInCents ) ; tokenMap [ _tokenAddress ] = addEntity ( _tokenAddress , tokenAddressList , false ) ; emit TokenAdded ( _tokenAddress ) ; return _tokenAddress ; }
","Creates a PoaToken contract with given parameters , and set active value to false
"
"function revealCurve ( uint256 _limit , uint256 _slopeFactor , uint256 _collectMinimum , bool _last , bytes32 _salt ) public { require ( ! allRevealed ) ; require ( curves [ revealedCurves ] . hash == calculateHash ( _limit , _slopeFactor , _collectMinimum , _last , _salt ) ) ; require ( _limit != 0 && _slopeFactor != 0 && _collectMinimum != 0 ) ; if ( revealedCurves > 0 ) { require ( _limit >= curves [ revealedCurves . sub ( 1 ) ] . limit ) ; } curves [ revealedCurves ] . limit = _limit ; curves [ revealedCurves ] . slopeFactor = _slopeFactor ; curves [ revealedCurves ] . collectMinimum = _collectMinimum ; revealedCurves = revealedCurves . add ( 1 ) ; if ( _last ) allRevealed = true ; }
","Anybody can reveal the next curve if he knows it .
"
"function registerSecret ( bytes32 secret ) public returns ( bool ) { bytes32 secrethash = keccak256 ( abi . encodePacked ( secret ) ) ; if ( secret == bytes32 ( 0x0 ) || secrethash_to_block [ secrethash ] > 0 ) { return false ; } secrethash_to_block [ secrethash ] = block . number ; emit SecretRevealed ( secrethash , secret ) ; return true ; }
","Registers a hash time lock secret and saves the block number .
"
"function updateLandData ( uint256 id , string data ) external returns ( bool ) { Mortgage memory mortgage = mortgages [ id ] ; require ( _isAuthorized ( msg . sender , id ) , ""Sender not authorized"" ) ; int256 x ; int256 y ; ( x , y ) = land . decodeTokenId ( mortgage . landId ) ; land . updateLandData ( x , y , data ) ; emit UpdatedLandData ( msg . sender , id , data ) ; return true ; }
","Enables the owner of a parcel to update the data field
"
"function exchangeEtherForNomins ( ) public payable pricesNotStale notPaused returns ( uint ) { uint requestedToPurchase = safeMul_dec ( msg . value , usdToEthPrice ) ; fundsWallet . transfer ( msg . value ) ; nomin . transfer ( msg . sender , requestedToPurchase ) ; emit Exchange ( ""ETH"" , msg . value , ""nUSD"" , requestedToPurchase ) ; return requestedToPurchase ; }
","Exchange ETH to nUSD .
"
"function shutForETH ( uint _id ) public auth stoppable { bytes32 id = bytes32 ( _id ) ; uint debt = tub . tab ( id ) ; if ( debt > 0 ) { require ( dai . transferFrom ( msg . sender , this , debt ) ) ; } uint ink = tub . ink ( id ) ; tub . shut ( id ) ; uint gemBalance = tub . bid ( ink ) ; tub . exit ( ink ) ; gem . withdraw ( min ( gemBalance , gem . balanceOf ( this ) ) ) ; msg . sender . transfer ( min ( gemBalance , address ( this ) . balance ) ) ; }
","Shuts a CDP and returns the value in the form of ETH .
"
"function removeAddressesFromWhitelist ( address [ ] _users ) external onlyAdmin { require ( _users . length > 0 , ""Cannot remove an empty list to whitelist!"" ) ; for ( uint256 i = 0 ; i < _users . length ; ++ i ) { address user = _users [ i ] ; if ( whitelist [ user ] ) { whitelist [ user ] = false ; emit WhitelistRemoved ( user ) ; } } }
","Removes a list of addresses from the whitelist .
"
"function approve ( address _spender , uint _value ) public returns ( bool success ) { require ( allowed [ msg . sender ] [ _spender ] == 0 || _value == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","You must set the allowance to zero before changing to a non-zero value
"
"function addTokensToAccount ( bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses whenNotPaused public returns ( bool ) { registerAccount ( _uuid ) ; balances [ _uuid ] = balances [ _uuid ] . add ( _tokensCount ) ; tokens = tokens . add ( _tokensCount ) ; return true ; }
","Function for adding tokens to specified account .
"
"function purchaseTokens ( ) saleStarted saleNotEnded payable setupComplete notInEmergency { uint excessAmount = msg . value % price ; uint purchaseAmount = msg . value - excessAmount ; uint tokenPurchase = purchaseAmount / price ; require ( tokenPurchase <= token . balanceOf ( this ) ) ; if ( excessAmount > 0 ) { msg . sender . transfer ( excessAmount ) ; } wallet . transfer ( purchaseAmount ) ; token . transfer ( msg . sender , tokenPurchase ) ; PurchasedTokens ( msg . sender , tokenPurchase ) ; }
","You 're about to purchase the equivalent of ` msg.value ` Wei in tokens
"
"function createCollectible ( uint256 identifier , address owner , uint256 parentIdentifier , uint256 price ) external onlyCFO { require ( identifier >= 1 ) ; require ( identifierToOwner [ identifier ] == 0x0 ) ; identifiers . push ( identifier ) ; address initialOwner = owner ; if ( initialOwner == 0x0 ) { initialOwner = address ( this ) ; } _transfer ( 0x0 , initialOwner , identifier ) ; identifierToParentIdentifier [ identifier ] = parentIdentifier ; identifierToPrice [ identifier ] = price ; Price ( identifier , price , nextPrice ( price ) ) ; }
","Create a collectible .
"
"function depositCollateral ( address token , uint amount ) public { require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( isValid ( token ) ) ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] . add ( amount ) ; require ( StandardToken ( token ) . transferFrom ( msg . sender , this , amount ) , ""error with token"" ) ; emit Deposit ( token , msg . sender , amount , tokens [ token ] [ msg . sender ] ) ; addMasternode ( msg . sender ) ; }
","Public function that allows any user to deposit accepted tokens as collateral to become a masternode .
"
"function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; mAuthorized [ _operator ] [ msg . sender ] = false ; emit RevokedOperator ( _operator , msg . sender ) ; }
","Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
"
"function transferOutEth ( ) public onlyAdmin returns ( bool ) { uint256 balance = address ( this ) . balance ; msg . sender . transfer ( address ( this ) . balance ) ; emit EthTransferOut ( msg . sender , balance ) ; return true ; }
","Transfers eth that is stuck in this contract ETH can be sent to the address this contract resides at before the contract is deployed A contract can be suicided , forcefully sending ether to this contract
"
"function _clearApproval ( address _owner , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _owner , ""wrong owner"" ) ; if ( tokenApprovals [ _tokenId ] != 0 ) { tokenApprovals [ _tokenId ] = 0 ; emit Approval ( _owner , 0 , _tokenId ) ; } }
","Internal function to clear current approval of a given token ID
"
"function uintToBytes ( uint256 i ) public view returns ( bytes32 b ) { b = bytes32 ( i ) ; }
","Converts a uint256 type variable to a byte32 type variable Mostly used internaly
"
"function collectTokens ( ) public onlyOwner { uint256 balance = snt . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 6 ) ) ) ; uint256 canExtract = total . mul ( getTime ( ) . sub ( finalizedTime ) ) . div ( months ( 24 ) ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; assert ( snt . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }
","The Dev ( Owner ) will call this method to extract the tokens
"
"function getOwnerOfCampaign ( bytes32 bidId ) public view returns ( address campaignOwner ) { return advertisementStorage . getCampaignOwnerById ( bidId ) ; }
","Get the owner of a campaign Based on the Campaign id return the address of the campaign owner
"
"function createPoll ( string _title , uint8 _percentage ) external onlymanyowners ( sha3 ( msg . data ) ) { bytes32 hash = sha3 ( _title ) ; Poll poll = polls [ hash ] ; if ( poll . exists ) { throw ; } if ( _percentage < 1 || _percentage > 100 ) { throw ; } poll . exists = true ; poll . title = _title ; poll . percentage = _percentage ; poll . hashRate = 0 ; poll . approved = false ; poll . approvalBlock = 0 ; poll . approvalHashRate = 0 ; poll . approvalTotalHashRate = 0 ; LogPollCreated ( hash ) ; }
","Create a new poll
"
"function getAbilitiesForCollectibleId ( uint256 _tokenId ) external view returns ( uint256 ability ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; uint256 _attributes = uint256 ( obj . attributes ) ; ability = ( _attributes % 1000 ) ; }
","Returns the ability of an asset/collectible/token from attributes .
"
"function removePartOwner ( address _partowner ) public onlyContractOwner returns ( uint ) { set ( store , partownersStorage , _partowner , false ) ; return OK ; }
","Removes a co-owner of a contract
"
"function release ( ) public { require ( block . timestamp >= releaseTime , ""Release time must pass"" ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; require ( amount > 0 , ""Contract must hold any tokens"" ) ; require ( token . transfer ( beneficiary , amount ) , ""Transfer must succeed"" ) ; }
","Transfers tokens held by timelock to beneficiary .
"
"function releaseVesting ( address _destination ) onlyOwner returns ( bool success ) { if ( block . timestamp > VESTING_1_DATE && vesting1Withdrawn == false ) { balances [ LOCKED_ADDRESS ] = safeSub ( balances [ LOCKED_ADDRESS ] , VESTING_1_AMOUNT ) ; balances [ _destination ] = safeAdd ( balances [ _destination ] , VESTING_1_AMOUNT ) ; vesting1Withdrawn = true ; Transfer ( LOCKED_ADDRESS , _destination , VESTING_1_AMOUNT ) ; return true ; } if ( block . timestamp > VESTING_2_DATE && vesting2Withdrawn == false ) { balances [ LOCKED_ADDRESS ] = safeSub ( balances [ LOCKED_ADDRESS ] , VESTING_2_AMOUNT ) ; balances [ _destination ] = safeAdd ( balances [ _destination ] , VESTING_2_AMOUNT ) ; vesting2Withdrawn = true ; Transfer ( LOCKED_ADDRESS , _destination , VESTING_2_AMOUNT ) ; return true ; } return false ; }
","Send vested amount to _destination
"
"function calculateOperationFee ( uint32 _date ) internal view returns ( uint256 ) { DailyContestStatus memory status = dateToContestStatus [ _date ] ; if ( status . numCompleted == 0 ) { return status . numRegistered . mul ( REGISTRATION_FEE ) ; } uint256 numFailed = status . numRegistered . sub ( status . numCompleted ) ; return numFailed . mul ( REGISTRATION_FEE ) . div ( 10 ) ; }
","Does n't change state
"
"function crowdsaleClosed ( ) internal { uint256 remainingTokens = tokenCap . sub ( tokensRaised ) ; _deliverTokens ( airdropWallet , remainingTokens ) ; LittlePhilCoin ( token ) . finishMinting ( ) ; }
","Crowdsale Closed
"
"function buy ( ) payable public { require ( buyMultiplier > 0 ) ; uint amount = msg . value * buyMultiplier / buyPrice ; _transfer ( this , msg . sender , amount ) ; }
","Buy tokens from contract by sending ether , with ` data ` = ` 0xa6f2ae3a ` .
"
"function holdersByIndices ( uint256 low , uint256 up , bool posOnly ) public view returns ( address [ ] ) { require ( low <= up ) ; up = up > holders . length - 1 ? holders . length - 1 : up ; uint256 length = 0 ; if ( posOnly ) { for ( uint256 i = low ; i <= up ; i ++ ) if ( 0 < balanceOf ( holders [ i ] ) ) length ++ ; } else length = up - low + 1 ; address [ ] memory _holders = new address [ ] ( length ) ; uint256 j = 0 ; for ( i = low ; i <= up ; i ++ ) if ( ! posOnly || 0 < balanceOf ( holders [ i ] ) ) _holders [ j ++ ] = holders [ i ] ; return _holders ; }
","Get the subset of holders ( optionally with positive balance only ) in the given 0 based index range
"
"function changeSupportRequiredPct ( uint64 _supportRequiredPct ) external authP ( MODIFY_SUPPORT_ROLE , arr ( uint256 ( _supportRequiredPct ) , uint256 ( supportRequiredPct ) ) ) { require ( minAcceptQuorumPct <= _supportRequiredPct , ERROR_CHANGE_SUPPORT_PCTS ) ; require ( _supportRequiredPct < PCT_BASE , ERROR_CHANGE_SUPPORT_TOO_BIG ) ; supportRequiredPct = _supportRequiredPct ; emit ChangeSupportRequired ( _supportRequiredPct ) ; }
","Change required support to ` @ formatPct ( _supportRequiredPct ) ` %
"
"function motionConfirming ( uint motionID ) public view returns ( bool ) { uint startTime = motionStartTime [ motionID ] ; return startTime + votingPeriod <= now && now < startTime + votingPeriod + confirmationPeriod ; }
","A vote on the target account has concluded , but the motion has not yet been approved , vetoed , or closed .
"
"function setHodlerStake ( address _beneficiary , uint256 _stake ) public onlyCrowdsale { hodlerReward . setHodlerStake ( _beneficiary , _stake ) ; }
","Proxy call for setting hodler stake
"
"function balanceOf ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return ownerTokenCount [ _owner ] ; }
","Count all NFTs assigned to an owner
"
"function claimHalvingsSubsidies ( uint256 _n ) public notBeforeGenesis notPaused isMiner ( msg . sender ) returns ( uint256 ) { Miner miner = miners [ msg . sender ] ; uint256 start = blockHalving ( miner . block ) ; uint256 end = start . add ( _n ) ; if ( end > currentHalving ( ) ) { return 0 ; } uint256 subsidy = 0 ; uint256 totalSubsidy = 0 ; uint256 unclaimed = 0 ; uint256 hashRate = 0 ; uint256 K ; for ( K = start ; K < end && K < maxHalvings ; K ++ ) { HalvingHashRate halvingHashRate = halvingsHashRate [ K ] ; if ( ! halvingHashRate . carried ) { halvingHashRate . carried = true ; halvingHashRate . rate = halvingHashRate . rate . add ( halvingsHashRate [ K - 1 ] . rate ) ; } MinerHashRate minerHashRate = miner . hashRate [ K ] ; if ( ! minerHashRate . carried ) { minerHashRate . carried = true ; minerHashRate . rate = minerHashRate . rate . add ( miner . hashRate [ K - 1 ] . rate ) ; } hashRate = minerHashRate . rate ; if ( hashRate != 0 ) { if ( K == currentHalving ( ) . sub ( 1 ) ) { if ( currentBlock ( ) % subsidyHalvingInterval < miner . block % subsidyHalvingInterval ) { continue ; } } Subsidy sub = halvingsSubsidies [ K ] ; if ( ! sub . claimed ) { sub . claimed = true ; sub . value = halvingSubsidy ( K ) ; } unclaimed = sub . value ; subsidy = halvingSubsidy ( K ) . mul ( hashRate ) . div ( halvingHashRate . rate ) ; if ( subsidy > unclaimed ) { subsidy = unclaimed ; } totalSubsidy = totalSubsidy . add ( subsidy ) ; sub . value = sub . value . sub ( subsidy ) ; LogClaimHalvingSubsidy ( msg . sender , miner . block , K , subsidy ) ; LogRemainingHalvingSubsidy ( K , sub . value ) ; } miner . block = miner . block . add ( subsidyHalvingInterval ) ; } if ( K < end ) { miner . block = miner . block . add ( subsidyHalvingInterval . mul ( end . sub ( K ) ) ) ; } if ( totalSubsidy != 0 ) { balances [ msg . sender ] = balances [ msg . sender ] . add ( totalSubsidy ) ; totalSupply = totalSupply . add ( totalSubsidy ) ; } return totalSubsidy ; }
","Miners subsidies must be claimed by the miners calling claimHalvingsSubsidies ( _n )
"
"function getAllListings ( ) public view returns ( uint64 [ ] ) { return forSalePixelconIndexes ; }
","Get all PixelCon indexes being sold on the market
"
"function unregisterNotary ( address notary ) public onlyOwner whenNotPaused validAddress ( notary ) returns ( bool ) { require ( allowedNotaries . remove ( notary ) ) ; emit NotaryUnregistered ( notary ) ; return true ; }
","Unregisters an existing notary .
"
"function getFeatureStatus ( string _nameKey ) external view returns ( bool ) ;
","Get the status of a feature
"
"function release ( ) public { uint256 amount = calculateAmountToRelease ( ) ; require ( amount > 0 ) ; balances [ beneficiary ] = balances [ beneficiary ] . add ( amount ) ; totalSupply = totalSupply . add ( amount ) ; Released ( amount ) ; }
","Transfers schedulable tokens to beneficiary .
"
"function getEndTime ( ) internal constant returns ( uint ) { return 1511568000 ; }
","end time of the pre-ICO
"
"function normalizePledge ( uint64 idPledge ) returns ( uint64 ) { Pledge storage p = findPledge ( idPledge ) ; if ( p . pledgeState != PledgeState . Pledged ) { return idPledge ; } if ( ( p . intendedProject > 0 ) && ( getTime ( ) > p . commitTime ) ) { uint64 oldPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; uint64 toPledge = findOrCreatePledge ( p . intendedProject , new uint64 [ ] ( 0 ) , 0 , 0 , oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , p . amount ) ; idPledge = toPledge ; p = findPledge ( idPledge ) ; } toPledge = getOldestPledgeNotCanceled ( idPledge ) ; if ( toPledge != idPledge ) { doTransfer ( idPledge , toPledge , p . amount ) ; } return toPledge ; }
","` normalizePledge ` only affects pledges with the Pledged PledgeState and does 2 things : # 1 : Checks if the pledge should be committed .
"
"function getPermissions ( ) external view returns ( bytes32 [ ] ) ;
","Return the permission flags that are associated with a module
"
"function transfer ( address _to , uint256 _value ) { _transfer ( msg . sender , _to , _value ) ; require ( now > 1508840297 ) ; }
","Send ` _value ` tokens to ` _to ` from your account
"
"function batchRegularTransfer ( bytes32 [ ] swapIds , bytes32 [ ] secrets ) public { require ( swapIds . length <= MAX_BATCH_ITERATIONS ) ; for ( uint i = 0 ; i < swapIds . length ; ++ i ) regularTransfer ( swapIds [ i ] , secrets [ i ] ) ; }
","Batch exection of regularTransfer ( ) function
"
"function addExtension ( address ext_ ) onlyOwner public { extention . push ( ext_ ) ; }
","Add external ERC20 tokens balances
"
"function contribute ( address _target ) public notFinished payable { require ( now > SaleStart ) ; address user ; if ( _target != address ( 0 ) && level [ msg . sender ] >= 1 ) { user = _target ; } else { user = msg . sender ; } require ( whiteList [ user ] == true ) ; totalRaised = totalRaised . add ( msg . value ) ; uint256 tokenBought = msg . value . mul ( rate ) ; uint256 bonus = 0 ; uint256 buyHelper = tokenBought ; if ( bonus1Remain > 0 ) { if ( buyHelper <= bonus1Remain ) { bonus1Remain = bonus1Remain . sub ( buyHelper ) ; bonus = bonus . add ( ( buyHelper . mul ( 2 ) ) . div ( 10 ) ) ; buyHelper = 0 ; } else { buyHelper = buyHelper . sub ( bonus1Remain ) ; bonus = bonus . add ( ( bonus1Remain . mul ( 2 ) ) . div ( 10 ) ) ; bonus1Remain = 0 ; } } if ( bonus2Remain > 0 && buyHelper > 0 ) { if ( buyHelper <= bonus2Remain ) { bonus2Remain = bonus2Remain . sub ( buyHelper ) ; bonus = bonus . add ( ( buyHelper . mul ( 15 ) ) . div ( 100 ) ) ; buyHelper = 0 ; } else { buyHelper = buyHelper . sub ( bonus2Remain ) ; bonus = bonus . add ( ( bonus2Remain . mul ( 15 ) ) . div ( 100 ) ) ; bonus2Remain = 0 ; } } if ( bonus3Remain > 0 && buyHelper > 0 ) { if ( buyHelper <= bonus3Remain ) { bonus3Remain = bonus3Remain . sub ( buyHelper ) ; bonus = bonus . add ( buyHelper . div ( 10 ) ) ; buyHelper = 0 ; } else { buyHelper = buyHelper . sub ( bonus3Remain ) ; bonus = bonus . add ( bonus3Remain . div ( 10 ) ) ; bonus3Remain = 0 ; } } if ( bonus4Remain > 0 && buyHelper > 0 ) { if ( buyHelper <= bonus4Remain ) { bonus4Remain = bonus4Remain . sub ( buyHelper ) ; bonus = bonus . add ( ( buyHelper . mul ( 5 ) ) . div ( 100 ) ) ; buyHelper = 0 ; } else { buyHelper = buyHelper . sub ( bonus4Remain ) ; bonus = bonus . add ( ( bonus4Remain . mul ( 5 ) ) . div ( 100 ) ) ; bonus4Remain = 0 ; } } tokenBought = tokenBought . add ( bonus ) ; require ( totalDistributed . add ( tokenBought ) <= hardCap ) ; pending [ user ] = pending [ user ] . add ( tokenBought ) ; totalDistributed = totalDistributed . add ( tokenBought ) ; emit LogFundingReceived ( user , msg . value , totalRaised ) ; checkIfFundingCompleteOrExpired ( ) ; }
","contribution handler
"
"function changeBank ( uint256 newBank ) isOwner { require ( bank != newBank ) ; bank = newBank ; updatePrices ( ) ; }
","Set New Bank
"
"function setName ( string _name ) onlyAccountAddressForSponsee { name = _name ; LogSetName ( _name ) ; }
","Change name .
"
"function issueAssetWithInitialReceiver ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable , uint _blockNumber , address _account ) public onlyOneOfContractOwners returns ( uint ) { if ( _value == 0 && ! _isReissuable ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE ) ; } if ( isCreated ( _symbol ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_ASSET_ALREADY_ISSUED ) ; } uint holderId = _createHolderId ( _account ) ; uint creatorId = _account == msg . sender ? holderId : _createHolderId ( msg . sender ) ; add ( store , symbolsStorage , _symbol ) ; set ( store , assetOwnerIdStorage , _symbol , creatorId ) ; set ( store , assetTotalSupply , _symbol , _value ) ; set ( store , assetName , _symbol , _name ) ; set ( store , assetDescription , _symbol , _description ) ; set ( store , assetIsReissuable , _symbol , _isReissuable ) ; set ( store , assetBaseUnit , _symbol , _baseUnit ) ; set ( store , assetWalletBalance , _symbol , holderId , _value ) ; set ( store , assetBlockNumber , _symbol , _blockNumber ) ; _emitter ( ) . emitIssue ( _symbol , _value , _address ( holderId ) ) ; return OK ; }
","Issues new asset token on the platform .
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it
"
"function buy ( uint32 _x , uint16 _y , uint32 _sizeSkin , bytes16 _names , bytes32 _message ) external payable returns ( uint ) { _checks ( _x , _y , _sizeSkin ) ; uint id = locks . push ( Lock ( msg . sender , _x , _y , _sizeSkin , _names , _message , block . timestamp ) ) - 1 ; Buy ( id , msg . sender , _x , _y , _sizeSkin , _names , _message ) ; return id ; }
","Locks must be purchased in 20x20 pixel blocks .
"
"function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( ""configure(uint256,uint256,uint256,uint256,uint8[],address)"" ) ) ; }
","This function returns the signature of configure function
"
"function finalizeCrowdfunding ( ) external { if ( getState ( ) != State . Success ) throw ; if ( finalizedCrowdfunding ) throw ; finalizedCrowdfunding = true ; uint256 vaultTokens = safeDiv ( safeMul ( totalSupply , vaultPercentOfTotal ) , crowdfundPercentOfTotal ) ; balances [ timeVault ] = safeAdd ( balances [ timeVault ] , vaultTokens ) ; Transfer ( 0 , timeVault , vaultTokens ) ; uint256 lunyrTokens = safeDiv ( safeMul ( totalSupply , lunyrPercentOfTotal ) , crowdfundPercentOfTotal ) ; balances [ lunyrMultisig ] = safeAdd ( balances [ lunyrMultisig ] , lunyrTokens ) ; Transfer ( 0 , lunyrMultisig , lunyrTokens ) ; totalSupply = safeAdd ( safeAdd ( totalSupply , vaultTokens ) , lunyrTokens ) ; if ( ! lunyrMultisig . send ( this . balance ) ) throw ; }
","Finalize crowdfunding
"
"function isReadyToBreed ( uint256 _dogId ) public view returns ( bool ) { require ( _dogId > 1 ) ; Dog storage dog = dogs [ _dogId ] ; return _isReadyToBreed ( dog ) ; }
","Checks that a given kitten is able to breed ( i.e .
"
"function batchReclaimExpiredSwaps ( bytes32 msigId , bytes32 [ ] swapIds ) public { require ( swapIds . length <= MAX_BATCH_ITERATIONS ) ; for ( uint i = 0 ; i < swapIds . length ; ++ i ) reclaimExpiredSwap ( msigId , swapIds [ i ] ) ; }
","Batch exection of reclaimExpiredSwaps ( ) function
"
"function getMinerOffset ( ) public constant returns ( uint256 ) { return getMinerOffsetOf ( msg . sender ) ; }
","Compute the miner halvings offset
"
"function blockTime ( ) constant returns ( uint ) { return block . timestamp ; }
","for test purpose
"
"function verify ( address _sender , uint8 _v , bytes32 _r , bytes32 _s ) public view returns ( address ) { bytes32 hash = keccak256 ( abi . encodePacked ( this , _sender ) ) ; bytes memory prefix = '\x19Ethereum Signed Message:\n32' ; return ecrecover ( keccak256 ( abi . encodePacked ( prefix , hash ) ) , _v , _r , _s ) ; }
","check sign
"
"function mateWithAuto ( uint256 _matronId , uint256 _sireId , uint8 _incubator , bytes _sig ) external payable whenNotPaused { require ( msg . value >= autoBirthFee ) ; require ( _owns ( msg . sender , _matronId ) ) ; require ( _isMatingPermitted ( _sireId , _matronId ) ) ; Pony storage matron = ponies [ _matronId ] ; require ( _isReadyToMate ( matron ) ) ; Pony storage sire = ponies [ _sireId ] ; require ( _isReadyToMate ( sire ) ) ; require ( _isValidMatingPair ( matron , _matronId , sire , _sireId ) ) ; if ( _incubator == 0 && hasIncubator [ msg . sender ] ) { _mateWith ( _matronId , _sireId , _incubator ) ; } else { bytes32 hashedTx = getIncubatorHashing ( msg . sender , _incubator , nonces [ msg . sender ] ) ; require ( signedBySystem ( hashedTx , _sig ) ) ; nonces [ msg . sender ] ++ ; if ( ! hasIncubator [ msg . sender ] ) { hasIncubator [ msg . sender ] = true ; } _mateWith ( _matronId , _sireId , _incubator ) ; } }
","Breed a Pony you own ( as matron ) with a sire that you own , or for which you have previously been given Siring approval .
"
"function editClass ( uint256 _classId , string _name , uint16 _rarity , uint16 _weapon , uint [ ] _statsMin , uint [ ] _statsMax , uint16 _amount , string _hostfile , uint16 _minLevel , string _desc , uint _price ) public onlyModerators { ItemClass storage _itemClass = classIdToClass [ _classId ] ; _itemClass . name = _name ; _itemClass . rarity = _rarity ; _itemClass . weapon = _weapon ; _itemClass . statsMin = _statsMin ; _itemClass . statsMax = _statsMax ; _itemClass . amount = _amount ; _itemClass . hostfile = _hostfile ; _itemClass . minLevel = _minLevel ; _itemClass . desc = _desc ; _itemClass . price = _price ; }
","All links inside the _hostfile string has to be seperated by commas .
"
"function ln_fixed3_lnr_18 ( uint256 _numerator , uint256 _denominator ) internal pure returns ( uint256 ) { assert ( _numerator <= MAX_NUM ) ; uint256 res = 0 ; uint256 x = _numerator * FIXED_1 / _denominator ; if ( x >= FIXED_2 ) { uint8 count = floorLog2 ( x / FIXED_1 ) ; x >>= count ; res = count * FIXED_1 ; } if ( x > FIXED_1 ) { for ( uint8 i = MAX_PRECISION ; i > 0 ; -- i ) { x = ( x * x ) / FIXED_1 ; if ( x >= FIXED_2 ) { x >>= 1 ; res += ONE << ( i - 1 ) ; } } } return ( ( ( res * LN2_MANTISSA ) >> LN2_EXPONENT ) * lnR * 1e18 ) ; }
","outputs ln ( ) FIXED_3lnr1e18
"
"function batchTransfer ( address [ ] _recipients , uint256 [ ] _amounts ) external erc20 whenNotPaused whenAccountNotFrozen ( msg . sender ) returns ( bool success ) { require ( _recipients . length == _amounts . length , ""The lengths of _recipients and _amounts should be the same."" ) ; for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { doSend ( msg . sender , msg . sender , _recipients [ i ] , _amounts [ i ] , """" , """" , false ) ; } return true ; }
","ERC20 backwards compatible batch transfer .
"
"function addressAndBalance ( ) constant returns ( address sender , address receiver , uint balance ) { sender = data . sender ; receiver = data . receiver ; balance = data . balance ; }
","Get the address and balance of both partners in a channel .
"
"function list ( ) public view returns ( address [ ] , uint256 [ ] ) { address [ ] memory addrs = new address [ ] ( accountCount ) ; uint256 [ ] memory tokens = new uint256 [ ] ( accountCount ) ; uint256 i = 0 ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { addrs [ i ] = current ; tokens [ i ] = balances [ current ] ; current = addressLinkedList [ current ] ; i ++ ; } return ( addrs , tokens ) ; }
","Return a list of addresses and their tokens
"
"function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }
","Token owner can approve for spender to transferFrom ( ... ) tokens from the token owner 's account
"
"function isPendingArbitration ( bytes32 question_id ) public view returns ( bool ) { }
","Returns whether the question is pending arbitration
"
"function paid ( address who ) public constant returns ( bool ) { return s_paid [ who ] . length > 0 ; }
","Returns whether the given address paid or not
"
"function appendEncryptedBid ( bytes32 _bid_hash , uint price_index ) public onlyOwner returns ( uint index ) { require ( status == state . active ) ; uint art_price ; uint art_price_blockHeight ; ( art_price , art_price_blockHeight ) = oracle . getHistoricalPrice ( price_index ) ; bids [ bids_count ] = Bid ( _bid_hash , art_price , price_index , true , false , false , false ) ; index = bids_count ; emit BidAdded ( bids_count ++ ) ; }
","Append an encrypted bid to the auction .
"
"function getTypes ( ) external view returns ( uint8 [ ] ) { uint8 [ ] memory res = new uint8 [ ] ( 1 ) ; res [ 0 ] = 4 ; return res ; }
","Type of the Module factory
"
"function _teamTransfer ( address _to , uint cst ) private { _transfer ( owner , _to , cst ) ; teamFreezed [ _to ] = teamFreezed [ _to ] . add ( cst ) ; }
","_freezeTranfer perform actual tokens transfer which will be freezed ( see also checkTransfer ( ) )
"
"function contractExists ( address channel ) private constant returns ( bool ) { uint size ; assembly { size := extcodesize ( channel ) } return size > 0 ; }
","Check if a contract exists
"
"function debtBalanceOf ( address issuer , bytes4 currencyKey ) public view returns ( uint ) { uint initialDebtOwnership ; uint debtEntryIndex ; ( initialDebtOwnership , debtEntryIndex ) = synthetixState . issuanceData ( issuer ) ; if ( initialDebtOwnership == 0 ) return 0 ; uint currentDebtOwnership = synthetixState . lastDebtLedgerEntry ( ) . divideDecimalRoundPrecise ( synthetixState . debtLedger ( debtEntryIndex ) ) . multiplyDecimalRoundPrecise ( initialDebtOwnership ) ; uint totalSystemValue = totalIssuedSynths ( currencyKey ) ; uint highPrecisionBalance = totalSystemValue . decimalToPreciseDecimal ( ) . multiplyDecimalRoundPrecise ( currentDebtOwnership ) ; return highPrecisionBalance . preciseDecimalToDecimal ( ) ; }
","If a user issues synths backed by SNX in their wallet , the SNX become locked .
"
"function batchRegularTransfer ( bytes32 [ ] swapIds , bytes32 [ ] secrets ) public { for ( uint i = 0 ; i < swapIds . length ; ++ i ) regularTransfer ( swapIds [ i ] , secrets [ i ] ) ; }
","Withdraw ether and delete the htlc swap .
"
"function calculateGrantClaim ( uint256 _grantId ) public view returns ( uint256 , uint256 ) { Grant storage tokenGrant = tokenGrants [ _grantId ] ; if ( currentTime ( ) < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint elapsedTime = currentTime ( ) . sub ( tokenGrant . startTime ) ; uint elapsedDays = elapsedTime . div ( SECONDS_PER_DAY ) ; if ( elapsedDays < tokenGrant . vestingCliff ) { return ( elapsedDays , 0 ) ; } if ( elapsedDays >= tokenGrant . vestingDuration ) { uint256 remainingGrant = tokenGrant . amount . sub ( tokenGrant . totalClaimed ) ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint256 daysVested = elapsedDays . sub ( tokenGrant . daysClaimed ) ; uint256 amountVestedPerDay = tokenGrant . amount . div ( uint256 ( tokenGrant . vestingDuration ) ) ; uint256 amountVested = uint256 ( daysVested . mul ( amountVestedPerDay ) ) ; return ( daysVested , amountVested ) ; } }
","Calculate the vested and unclaimed months and tokens available for ` _grantId ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached
"
"function contribute ( ) public notFinished payable { require ( now > delay ) ; uint tokenBought ; totalRaised = totalRaised . add ( msg . value ) ; if ( totalDistributed < 10000000 * ( 10 ** 18 ) ) { tokenBought = msg . value . mul ( tablePrices [ 0 ] ) ; } else { tokenBought = msg . value . mul ( tablePrices [ 1 ] ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; LogContributorsPayout ( msg . sender , tokenBought ) ; checkIfFundingCompleteOrExpired ( ) ; }
","contribution handler
"
"function grantPermission ( address _entity , address _app , bytes32 _role ) external { grantPermissionP ( _entity , _app , _role , new uint256 [ ] ( 0 ) ) ; }
","Grants ` _entity ` the ability to perform actions of role ` _role ` on ` _app `
"
"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer || operators [ loan . lender ] [ msg . sender ] ) ; require ( to != address ( 0 ) ) ; lendersBalance [ loan . lender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; return true ; }
","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .
"
"function modifyWhitelistMulti ( address [ ] _investors , bool [ ] _valids ) public withPerm ( WHITELIST ) { require ( _investors . length == _valids . length , ""Input array length mis-match"" ) ; for ( uint i = 0 ; i < _investors . length ; i ++ ) { modifyWhitelist ( _investors [ i ] , _valids [ i ] ) ; } }
","adds or removes addresses from the whitelist .
"
"function countOfDeedsByOwner ( address _owner ) public view returns ( uint256 _count ) ;
","Count all deeds assigned to an owner
"
"function getKYCApproval ( Data storage self , address account ) internal view returns ( bool status ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.kyc' , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getBool ( id ) ; }
","Get KYC approval status for the account holder
"
"function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { require ( _from != address ( 0 ) ) ; require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }
","Restriction : An account can only use this function to send to itself
"
"function transferByForce ( address _from , address _to , uint _value ) external onlyOwner { _transfer ( _from , _to , _value ) ; }
","Transfer anyone 's tokens to a different account can only be called by the smart contract owner
"
"function removeAdministrators ( address _adminAddress ) onlyOwner { delete administrators [ _adminAddress ] ; AdminstratorRemoved ( _adminAddress ) ; }
","Remove an administrator
"
"function getDescription ( ) public view returns ( string ) { return ""Capped STO"" ; }
","Get the description of the Module
"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return _allowed [ _owner ] [ _spender ] ; }
","Returns the amount which ` _spender ` is still allowed to withdraw from ` _owner ` .
"
"function price ( ) public constant returns ( uint256 ) { if ( stage == Stages . AuctionEnded || stage == Stages . TokensDistributed ) { return 0 ; } return calcTokenPrice ( ) ; }
","Get the GOT price in WEI during the auction , at the time of calling this function .
"
"function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; require ( block . number <= _validUntil ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned transfer
"
"function removeAllAttachmentsFromCollectible ( uint256 _tokenId ) external onlyManager whenNotPaused { require ( exists ( _tokenId ) ) ; delete nftCollectibleAttachments [ _tokenId ] ; emit AssetUpdated ( _tokenId ) ; }
","Removes all attachments from collectible .
"
"function whitelistAddress ( address _user , bool _flag ) onlyAdmin ( 1 ) public { whiteList [ _user ] = _flag ; }
","whiteList handler
"
"function unsetAddressAlias ( address addr ) public onlyRole ( roleAddressAliaser ( ) ) { setAddressAliasUnsafe ( 0 , addr ) ; }
","Change an address to no longer alias to anything else .
"
"function setRegisteredFirm ( string firmName , bool _authorized ) public onlyAuthority ( firmName , msg . sender ) returns ( bool success ) { require ( lib . setRegisteredFirm ( firmName , _authorized ) , ""Error: Failed to register firm with storage contract! Please check your arguments."" ) ; return true ; }
","Registers a firm as authorized true/false
"
"function withdraw ( uint256 amount ) onlyOwner public { require ( address ( this ) . balance >= amount ) ; owner . transfer ( amount ) ; }
","Withdraw ` amount ` to owner
"
"function getItemsByOwner ( address _owner ) external view returns ( uint256 [ ] ) { uint256 [ ] memory result = new uint256 [ ] ( addressInfo [ _owner ] . itemsCount ) ; uint256 counter = 0 ; for ( uint256 i = 0 ; i < items . length ; i ++ ) { if ( itemToOwner [ i ] == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }
","Gets items by address
"
"function depositStake ( uint256 _numRTC ) public stakingEnabled ( _numRTC ) returns ( bool ) { uint256 stakeCount = getStakeCount ( msg . sender ) ; ( uint256 blockLocked , uint256 blockReleased , uint256 releaseDate , uint256 totalCoinsMinted , uint256 rewardPerBlock ) = calculateStake ( _numRTC ) ; StakeStruct memory ss = StakeStruct ( { initialStake : _numRTC , blockLocked : blockLocked , blockUnlocked : blockReleased , releaseDate : releaseDate , totalCoinsToMint : totalCoinsMinted , coinsMinted : 0 , rewardPerBlock : rewardPerBlock , lastBlockWithdrawn : blockLocked , state : StakeStateEnum . staking } ) ; stakes [ msg . sender ] [ stakeCount ] = ss ; numberOfStakes [ msg . sender ] = numberOfStakes [ msg . sender ] . add ( 1 ) ; internalRTCBalances [ msg . sender ] = internalRTCBalances [ msg . sender ] . add ( _numRTC ) ; activeStakes = activeStakes . add ( 1 ) ; emit StakeDeposited ( msg . sender , stakeCount , totalCoinsMinted , releaseDate , blockReleased ) ; require ( RTI . transferFrom ( msg . sender , address ( this ) , _numRTC ) , ""transfer from failed, likely needs approval"" ) ; return true ; }
","This is used to deposit coins and start staking with at least one RTC
"
"function processPreSale ( address _caller ) private { var ( allowedContribution , refundAmount ) = processContribution ( ) ; require ( msg . value == allowedContribution . add ( refundAmount ) ) ; if ( allowedContribution > 0 ) { doBuy ( _caller , allowedContribution ) ; if ( refundAmount > 0 ) { msg . sender . transfer ( refundAmount ) ; } } else { revert ( ) ; } }
","Processes the presale if the allowed contribution is more than zero
"
"function acceptOwnership ( ) public returns ( bool ) { require ( msg . sender == newOwner ) ; ChangedOwner ( owner , msg . sender ) ; owner = newOwner ; delete newOwner ; return true ; }
","Finalise change of ownership to newOwner
"
"function sell ( uint256 amount ) canTransfer public { require ( this . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
","Sell ` amount ` tokens to contract
"
"function increaseApproval ( address _spender , uint256 _addedValue ) public userNotBlacklisted ( _spender ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { _increaseApproval ( _spender , _addedValue , msg . sender ) ; return true ; }
","increaseApproval should be used instead of approve when the user 's allowance is greater than 0 .
"
"function availableTokens ( ) public view returns ( uint ) { uint256 timeAfterMint = now . sub ( lastMintTime ) ; uint256 refillAmount = rate . mul ( timeAfterMint ) . add ( leftOnLastMint ) ; return size < refillAmount ? size : refillAmount ; }
","Function to calculate and get available in bucket tokens
"
"function markMilestoneComplete ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . milestoneLeadLink ) && ( msg . sender != recipient ) ) throw ; if ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) throw ; if ( now < milestone . minCompletionDate ) throw ; if ( now > milestone . maxCompletionDate ) throw ; milestone . status = MilestoneStatus . Completed ; milestone . doneTime = now ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }
","` onlyRecipientOrLeadLink ` Marks a milestone as DONE and ready for review
"
"function calculateWinners ( uint32 amount ) external onlyAdmin checkState ( pointsValidationState . LimitSet ) { require ( amount + lastCheckedToken <= tokens . length ) ; uint256 points = tokenToPointsMap [ pointsLimit ] ; for ( uint256 i = lastCheckedToken ; i < lastCheckedToken + amount ; i ++ ) { if ( tokenToPointsMap [ i ] > points || ( tokenToPointsMap [ i ] == points && i <= pointsLimit ) ) { winnerCounter ++ ; } } lastCheckedToken += amount ; if ( lastCheckedToken == tokens . length ) { require ( superiorQuota == winnerCounter ) ; pValidationState = pointsValidationState . LimitCalculated ; } }
","Sets the 10th percentile of the sorted array of points
"
"function name ( bytes32 _symbol ) public view returns ( string ) { return get ( store , assetName , _symbol ) ; }
","Returns asset name .
"
"function addExternalContributor ( address _contributor ) public onlyOwner { externalContributionAgents [ _contributor ] = true ; }
","update external contributor
"
"function setUrl ( string _url ) public onlyOwner returns ( bool ) { infoUrl = _url ; return true ; }
","Sets the URL where the oracleData can be retrieved
"
"function calculateHouseCutAmount ( uint gameId ) internal view returns ( uint ) { uint rawPoolAmount = calculateRawPoolAmount ( gameId ) ; return houseCutPercentage . mul ( rawPoolAmount . div ( 100 ) ) ; }
","Returns the amount the house will take
"
"function transfer ( address _to , uint _value , bytes _data ) public returns ( bool ) { if ( isContract ( _to ) ) { return transferToContract ( _to , _value , _data ) ; } else { return transferToAddress ( _to , _value , _data ) ; } }
","Transfer the specified amount of tokens to the specified address .
"
"function beneficiaryExists ( address _beneficiary ) internal view returns ( bool ) { return beneficiaryDistributionContracts [ _beneficiary ] . length > 0 ; }
","Checks if a beneficiary was added to the pool at least once .
"
"function withdrawAdamcoins ( ) public { require ( purchasingAllowed ) ; uint withdrawalAmount = pendingWithdrawals [ msg . sender ] ; pendingWithdrawals [ msg . sender ] = 0 ; _transfer ( address ( this ) , msg . sender , withdrawalAmount ) ; }
","Withdraw the amount of pendingWithdrawals from contract
"
"function isContractDeprecated ( Data storage self , address contractAddress ) internal view returns ( bool status ) { bytes32 id = keccak256 ( abi . encodePacked ( 'depcrecated' , contractAddress ) ) ; return self . Storage . getBool ( id ) ; }
","Return the deprecation status of a contract
"
"function getDarknodesFromEpochs ( address _start , uint256 _count , bool _usePreviousEpoch ) private view returns ( address [ ] ) { uint256 count = _count ; if ( count == 0 ) { count = numDarknodes ; } address [ ] memory nodes = new address [ ] ( count ) ; uint256 n = 0 ; address next = _start ; if ( next == 0x0 ) { next = store . begin ( ) ; } while ( n < count ) { if ( next == 0x0 ) { break ; } bool includeNext ; if ( _usePreviousEpoch ) { includeNext = isRegisteredInPreviousEpoch ( next ) ; } else { includeNext = isRegistered ( next ) ; } if ( ! includeNext ) { next = store . next ( next ) ; continue ; } nodes [ n ] = next ; next = store . next ( next ) ; n += 1 ; } return nodes ; }
","Returns a list of darknodes registered for either the current or the previous epoch .
"
"function unlistToken ( address _stablecoin ) public onlyOwner whenNotPaused { tokenStorage_CD . removeStablecoin ( _stablecoin ) ; }
","Remove existing stablecoin from whitelist .
"
"function changeGranularity ( uint256 _granularity ) external onlyOwner { require ( _granularity != 0 , ""Invalid granularity"" ) ; emit GranularityChanged ( granularity , _granularity ) ; granularity = _granularity ; }
","Allows owner to change token granularity
"
"function setFiatContractAddress ( address _fiat ) public onlyOwner { require ( _fiat != address ( 0 ) , ""zero address is not allowed"" ) ; fiat = FiatContract ( _fiat ) ; }
","Not for public use !
"
"function removeTrustedContracts ( address [ ] _trusted_contracts ) isOwner public { for ( uint256 i = 0 ; i < _trusted_contracts . length ; i ++ ) { if ( trusted_contracts [ _trusted_contracts [ i ] ] ) { trusted_contracts [ _trusted_contracts [ i ] ] = false ; TrustedContract ( _trusted_contracts [ i ] , false ) ; } } }
","Function for removing trusted contracts .
"
"function version ( ) public view returns ( string _version ) { return lib . getTokenVersion ( address ( this ) ) ; }
","Gets version of token
"
"function makeOrder ( uint exchangeNumber , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) external pre_cond ( isOwner ( ) ) pre_cond ( ! isShutDown ) { require ( buyAsset != address ( this ) ) ; require ( quantityHeldInCustodyOfExchange ( sellAsset ) == 0 ) ; require ( module . pricefeed . existsPriceOnAssetPair ( sellAsset , buyAsset ) ) ; var ( isRecent , referencePrice , ) = module . pricefeed . getReferencePrice ( sellAsset , buyAsset ) ; require ( isRecent ) ; require ( module . riskmgmt . isMakePermitted ( module . pricefeed . getOrderPrice ( sellAsset , buyAsset , sellQuantity , buyQuantity ) , referencePrice , sellAsset , buyAsset , sellQuantity , buyQuantity ) ) ; require ( isInAssetList [ buyAsset ] || ownedAssets . length < MAX_FUND_ASSETS ) ; require ( AssetInterface ( sellAsset ) . approve ( exchanges [ exchangeNumber ] . exchange , sellQuantity ) ) ; require ( address ( exchanges [ exchangeNumber ] . exchangeAdapter ) . delegatecall ( bytes4 ( keccak256 ( ""makeOrder(address,address,address,uint256,uint256)"" ) ) , exchanges [ exchangeNumber ] . exchange , sellAsset , buyAsset , sellQuantity , buyQuantity ) ) ; exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] = exchanges [ exchangeNumber ] . exchangeAdapter . getLastOrderId ( exchanges [ exchangeNumber ] . exchange ) ; require ( exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] != 0 ) ; isInOpenMakeOrder [ sellAsset ] = true ; if ( ! isInAssetList [ buyAsset ] ) { ownedAssets . push ( buyAsset ) ; isInAssetList [ buyAsset ] = true ; } orders . push ( Order ( { exchangeId : exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] , status : OrderStatus . active , orderType : OrderType . make , sellAsset : sellAsset , buyAsset : buyAsset , sellQuantity : sellQuantity , buyQuantity : buyQuantity , timestamp : now , fillQuantity : 0 } ) ) ; OrderUpdated ( exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] ) ; }
","Makes an order on the selected exchange
"
"function fundWithdrawal ( uint _amount ) public onlyOwner { require ( crowdsaleClosed == true ) ; beneficiary . transfer ( _amount ) ; FundsWithdrawal ( beneficiary , _amount ) ; }
","Withdraw funds to beneficiary .
"
"function _cancelItemSale ( Item storage item ) private { item . forSale = false ; itemsForSaleCount -- ; }
","Cancel sale .
"
"function getDank ( uint256 _tokenId ) public view returns ( string dankName , uint256 sellingPrice , address owner ) { Dank storage dank = danks [ _tokenId ] ; dankName = dank . name ; sellingPrice = dankIndexToPrice [ _tokenId ] ; owner = dankIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific dank .
"
"function _internalTransfer ( address from , address to , uint amount , uint fee , bytes data ) internal returns ( bool ) { require ( to != address ( 0 ) , ""Cannot transfer to the 0 address"" ) ; require ( to != address ( this ) , ""Cannot transfer to the underlying contract"" ) ; require ( to != address ( proxy ) , ""Cannot transfer to the proxy contract"" ) ; tokenState . setBalanceOf ( from , safeSub ( tokenState . balanceOf ( from ) , safeAdd ( amount , fee ) ) ) ; tokenState . setBalanceOf ( to , safeAdd ( tokenState . balanceOf ( to ) , amount ) ) ; tokenState . setBalanceOf ( FEE_ADDRESS , safeAdd ( tokenState . balanceOf ( FEE_ADDRESS ) , fee ) ) ; callTokenFallbackIfNeeded ( from , to , amount , data ) ; emitTransfer ( from , to , amount ) ; emitTransfer ( from , FEE_ADDRESS , fee ) ; return true ; }
","Base of transfer functions
"
"function getGroupMembers ( bytes32 _groupName ) public view returns ( address [ ] _members ) { if ( ! isGroupExists ( _groupName ) ) { return ; } Group storage _group = groupName2group [ _groupName ] ; uint _membersCount = _group . membersCount ; if ( _membersCount == 0 ) { return ; } _members = new address [ ] ( _membersCount ) ; for ( uint _userIdx = 0 ; _userIdx < _membersCount ; ++ _userIdx ) { uint _memberIdx = _group . index2globalIndex [ _userIdx + 1 ] ; _members [ _userIdx ] = index2memberAddress [ _memberIdx ] ; } }
","Gets group members
"
"function transferOwnership ( address newOwner ) public onlyOwner { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; }
","Allows the current owner to transfer control of the contract to a newOwner .
"
"function unfreezeTransfers ( ) external ;
","Un-freezes all the transfers
"
"function launchContract ( ) public onlyAdmin returns ( bool launched ) { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; EnableTokenMinting ( true ) ; return true ; }
","Used to launch start the contract
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( now > deadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } else if ( state == State . Stage3 && now > dateTimeContract . toTimestamp ( 2018 , 12 , 27 , 0 ) ) { state = State . Stage4 ; } else if ( state == State . Stage2 && now > dateTimeContract . toTimestamp ( 2018 , 9 , 28 , 0 ) ) { state = State . Stage3 ; } else if ( state == State . Stage1 && now > dateTimeContract . toTimestamp ( 2018 , 6 , 30 , 0 ) ) { state = State . Stage2 ; } }
","check status
"
"function updateDelayTime ( uint256 _newDelay ) public onlyGameManager whenNotPaused { BID_DELAY_TIME = _newDelay ; }
","Function helps to update the delay time for bidding
"
"function transferFrom ( address _from , address _to , uint256 _value ) public notFrozen returns ( bool success ) { require ( ! frozenAccounts [ _from ] && ! frozenAccounts [ _to ] ) ; require ( tradable ) ; if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && _value > 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ _from ] -= _value ; balances [ _to ] += _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }
","Allows allowed third party to transfer tokens from one address to another .
"
"function getDividendIndex ( uint256 _checkpointId ) public view returns ( uint256 [ ] ) { uint256 counter = 0 ; for ( uint256 i = 0 ; i < dividends . length ; i ++ ) { if ( dividends [ i ] . checkpointId == _checkpointId ) { counter ++ ; } } uint256 [ ] memory index = new uint256 [ ] ( counter ) ; counter = 0 ; for ( uint256 j = 0 ; j < dividends . length ; j ++ ) { if ( dividends [ j ] . checkpointId == _checkpointId ) { index [ counter ] = j ; counter ++ ; } } return index ; }
","Get the index according to the checkpoint id
"
"function supportsInterface ( bytes4 interfaceID ) external view returns ( bool ) { return supportedInterfaces [ interfaceID ] && ( interfaceID != 0xffffffff ) ; }
","Query if a contract implements an interface
"
"function setFeeBPS ( Data storage self , uint feeBPS ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.bps' , address ( this ) ) ) ; require ( self . Storage . setUint ( id , feeBPS ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set basis point fee for contract interface
"
"function canImplementInterfaceForAddress ( address addr , bytes32 interfaceHash ) public view returns ( bytes32 ) ;
","Indicates whether the contract implements the interface ` interfaceHash ` for the address ` addr ` or not .
"
"function changeManufacturerWallet ( address _new ) public onlyManufacturer returns ( bool ) { require ( _new != address ( 0 ) , ""new address cannot be 0x0"" ) ; NetworkMember memory old = network [ msg . sender ] ; require ( old . isManufacturer && old . memberId != 0 , ""must be a manufacturer"" ) ; require ( ! network [ _new ] . isIRNAdmin , ""already an irn admin"" ) ; require ( ! network [ _new ] . isManufacturer , ""already a manufacturer"" ) ; require ( ! network [ _new ] . isIRNNode , ""already an irn node"" ) ; require ( network [ _new ] . memberId == 0 , ""memberId already exists"" ) ; network [ _new ] = NetworkMember ( old . isIRNAdmin , old . isManufacturer , old . isIRNNode , old . memberId ) ; require ( pools [ _new ] . balance == 0 && pools [ _new ] . rewardAmount == 0 , ""new token pool already exists"" ) ; pools [ _new ] . balance = pools [ msg . sender ] . balance ; pools [ _new ] . rewardAmount = pools [ msg . sender ] . rewardAmount ; delete pools [ msg . sender ] ; manufacturerRewards [ old . memberId ] = _new ; delete network [ msg . sender ] ; emit ManufacturerRewardWalletChanged ( msg . sender , _new , old . memberId ) ; return true ; }
","changes the ethereum wallet for a manufacturer used in reputation rewards
"
"function isStarted ( ) public view returns ( bool ) { return ( startTime > 0 ) ; }
","Is vesting started flag .
"
"function setPreAmounts ( uint256 mtdPreAmountInWei , uint256 ethPreAmountInWei ) isOwner { require ( mtdPreAmountInWei > 0 ) ; require ( ethPreAmountInWei > 0 ) ; mtdPreAmount = mtdPreAmountInWei ; ethPreAmount = ethPreAmountInWei ; updatePrices ( ) ; }
","Set both ethPreAmount and mtdPreAmount at the same time
"
"function setFeeParams ( uint feeBps , uint feeMin , uint feeMax , uint feeFlat , bytes feeMsg ) public onlyOwner returns ( bool success ) { require ( lib . setFeeBPS ( feeBps ) , ""Error: Unable to set fee contract basis points."" ) ; require ( lib . setFeeMin ( feeMin ) , ""Error: Unable to set fee contract minimum fee."" ) ; require ( lib . setFeeMax ( feeMax ) , ""Error: Unable to set fee contract maximum fee."" ) ; require ( lib . setFeeFlat ( feeFlat ) , ""Error: Unable to set fee contract flat fee."" ) ; require ( lib . setFeeMsg ( feeMsg ) , ""Error: Unable to set fee contract default message."" ) ; return true ; }
","Set Fee Parameters for Fee Contract
"
"function canIssueAttributeType ( address validator , uint256 attributeTypeID ) external view returns ( bool ) ;
","Determine if a validator at account ` validator ` is able to issue attributes of the type with ID ` attributeTypeID ` .
"
"function licenseAttributes ( uint256 _licenseId ) public view returns ( uint256 ) { return licenses [ _licenseId ] . attributes ; }
","Get a license 's attributes
"
"function getModule ( address _module ) external view returns ( bytes32 , address , address , bool , uint8 [ ] ) { return ( modulesToData [ _module ] . name , modulesToData [ _module ] . module , modulesToData [ _module ] . moduleFactory , modulesToData [ _module ] . isArchived , modulesToData [ _module ] . moduleTypes ) ; }
","Returns the data associated to a module
"
"function withdraw ( address addr ) onlyOwner public { addr . transfer ( address ( this ) . balance ) ; }
","Withdraw any accumulated fees to the specified address
"
"function balanceOfAt ( address _investor , uint256 _checkpointId ) public view returns ( uint256 ) { require ( _checkpointId <= currentCheckpointId ) ; return TokenLib . getValueAt ( checkpointBalances [ _investor ] , _checkpointId , balanceOf ( _investor ) ) ; }
","Queries balances as of a defined checkpoint
"
"function claimTokens ( address _claimtoken ) onlyOwner public returns ( bool ) { if ( _claimtoken == 0x0 ) { owner . transfer ( this . balance ) ; return true ; } ERC20 claimtoken = ERC20 ( _claimtoken ) ; uint balance = claimtoken . balanceOf ( this ) ; claimtoken . transfer ( owner , balance ) ; ClaimedTokens ( _claimtoken , owner , balance ) ; return true ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function STARTMETADOLLAR ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1 * 1000 ether ; preICOprice = 1 * 1000 ether ; ICOprice = 1 * 1000 ether ; sellPrice = 1 * 950 ether ; updatePrices ( ) ; }
","Constructor of the contract
"
"function approveAndCall ( address spender , uint256 tokens , bytes data ) public returns ( bool success ) { requireTrade ( msg . sender ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokens , this , data ) ; return true ; }
","Token owner can approve for ` spender ` to transferFrom ( ... ) ` tokens ` from the token owner 's account .
"
"function requestVotingRights ( uint _numTokens ) public { require ( token . balanceOf ( msg . sender ) >= _numTokens ) ; voteTokenBalance [ msg . sender ] += _numTokens ; require ( token . transferFrom ( msg . sender , this , _numTokens ) ) ; emit _VotingRightsGranted ( _numTokens , msg . sender ) ; }
","Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights
"
"function supply ( address asset , uint amount ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . SUPPLY_CONTRACT_PAUSED ) ; } Market storage market = markets [ asset ] ; Balance storage balance = supplyBalances [ msg . sender ] [ asset ] ; SupplyLocalVars memory localResults ; Error err ; uint rateCalculationResultCode ; if ( ! market . isSupported ) { return fail ( Error . MARKET_NOT_SUPPORTED , FailureInfo . SUPPLY_MARKET_NOT_SUPPORTED ) ; } err = checkTransferIn ( asset , msg . sender , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_TRANSFER_IN_NOT_POSSIBLE ) ; } ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED ) ; } ( err , localResults . userSupplyCurrent ) = calculateBalance ( balance . principal , balance . interestIndex , localResults . newSupplyIndex ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . userSupplyUpdated ) = add ( localResults . userSupplyCurrent , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . newTotalSupply ) = addThenSub ( market . totalSupply , localResults . userSupplyUpdated , balance . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED ) ; } localResults . currentCash = getCash ( asset ) ; ( err , localResults . updatedCash ) = add ( localResults . currentCash , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa ) = market . interestRateModel . getSupplyRate ( asset , localResults . updatedCash , market . totalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa ) = market . interestRateModel . getBorrowRate ( asset , localResults . updatedCash , market . totalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } err = doTransferIn ( asset , msg . sender , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPLY_TRANSFER_IN_FAILED ) ; } market . blockNumber = getBlockNumber ( ) ; market . totalSupply = localResults . newTotalSupply ; market . supplyRateMantissa = localResults . newSupplyRateMantissa ; market . supplyIndex = localResults . newSupplyIndex ; market . borrowRateMantissa = localResults . newBorrowRateMantissa ; market . borrowIndex = localResults . newBorrowIndex ; localResults . startingBalance = balance . principal ; balance . principal = localResults . userSupplyUpdated ; balance . interestIndex = localResults . newSupplyIndex ; emit SupplyReceived ( msg . sender , asset , amount , localResults . startingBalance , localResults . userSupplyUpdated ) ; return uint ( Error . NO_ERROR ) ; }
","supply ` amount ` of ` asset ` ( which must be supported ) to ` msg.sender ` in the protocol
"
"function getOwner ( Campaign storage _campaign ) internal view returns ( address _owner ) { return _campaign . owner ; }
","Get campaign owner
"
"function blockPendingTx ( uint _txIdx ) returns ( bool ) ;
","Block a pending transaction with id ` _txIdx ` .
"
"function collectMilestonePayment ( uint _idMilestone ) onlyRecipient campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . Completed ) || ( now < milestone . doneTime + milestone . reviewTime ) ) throw ; doPayment ( _idMilestone ) ; }
","` onlyRecipient ` Sends the milestone payment as specified in ` payData ` ; the recipient can only call this after the ` reviewTime ` has elapsed
"
"function claimRefundFor ( address _beneficiary ) public afterSaleFail whenNotPaused { require ( _beneficiary != address ( 0 ) ) ; vault . refund ( _beneficiary ) ; }
","Refund an ethereum address
"
"function assignPreicoTokens ( ) public onlyOwnerAndDirector { require ( ! assignedPreico ) ; assignedPreico = true ; _freezeTransfer ( 0xb424958766e736827Be5A441bA2A54bEeF54fC7C , 10 * 19514560000000000000000 ) ; _freezeTransfer ( 0xF5dF9C2aAe5118b64Cda30eBb8d85EbE65A03990 , 10 * 36084880000000000000000 ) ; _freezeTransfer ( 0x5D8aCe48970dce4bcD7f985eDb24f5459Ef184Ec , 10 * 2492880000000000000000 ) ; _freezeTransfer ( 0xcD6d5b09a34562a1ED7857B19b32bED77417655b , 10 * 1660880000000000000000 ) ; _freezeTransfer ( 0x50f73AC8435E4e500e37FAb8802bcB840bf4b8B8 , 10 * 94896880000000000000000 ) ; _freezeTransfer ( 0x65Aa068590216cb088f4da28190d8815C31aB330 , 10 * 16075280000000000000000 ) ; _freezeTransfer ( 0x2046838D148196a5117C4026E21C165785bD3982 , 10 * 5893680000000000000000 ) ; _freezeTransfer ( 0x458e1f1050C34f5D125437fcEA0Df0aA9212EDa2 , 10 * 32772040882120167215360 ) ; _freezeTransfer ( 0x12B687E19Cef53b2A709e9b98C4d1973850cA53F , 10 * 70956080000000000000000 ) ; _freezeTransfer ( 0x1Cf5daAB09155aaC1716Aa92937eC1c6D45720c7 , 10 * 3948880000000000000000 ) ; _freezeTransfer ( 0x32fAAdFdC7938E7FbC7386CcF546c5fc382ed094 , 10 * 88188880000000000000000 ) ; _freezeTransfer ( 0xC4eA6C0e9d95d957e75D1EB1Fbe15694CD98336c , 10 * 81948880000000000000000 ) ; _freezeTransfer ( 0xB97D3d579d35a479c20D28988A459E3F35692B05 , 10 * 121680000000000000000 ) ; _freezeTransfer ( 0x65AD745047633C3402d4BC5382f72EA3A9eCFe47 , 10 * 5196880000000000000000 ) ; _freezeTransfer ( 0xd0BEF2Fb95193f429f0075e442938F5d829a33c8 , 10 * 223388880000000000000000 ) ; _freezeTransfer ( 0x9Fc87C3d44A6374D48b2786C46204F673b0Ae236 , 10 * 28284880000000000000000 ) ; _freezeTransfer ( 0x42C73b8945a82041B06428359a94403a2e882406 , 10 * 13080080000000000000000 ) ; _freezeTransfer ( 0xa4c9595b90BBa7B4d805e555E477200C61711F3a , 10 * 6590480000000000000000 ) ; _freezeTransfer ( 0xb93b8ceD7CD86a667E12104831b4d514365F9DF8 , 10 * 116358235759665569280 ) ; _freezeTransfer ( 0xa94F999b3f76EB7b2Ba7B17fC37E912Fa2538a87 , 10 * 10389600000000000000000 ) ; _freezeTransfer ( 0xD65B9b98ca08024C3c19868d42C88A3E47D67120 , 10 * 25892880000000000000000 ) ; _freezeTransfer ( 0x3a978a9Cc36f1FE5Aab6D31E41c08d8380ad0ACB , 10 * 548080000000000000000 ) ; _freezeTransfer ( 0xBD46d909D55d760E2f79C5838c5C42E45c0a853A , 10 * 7526480000000000000000 ) ; _freezeTransfer ( 0xdD9d289d4699fDa518cf91EaFA029710e3Cbb7AA , 10 * 3324880000000000000000 ) ; _freezeTransfer ( 0x8671B362902C3839ae9b4bc099fd24CdeFA026F4 , 10 * 21836880000000000000000 ) ; _freezeTransfer ( 0xf3C25Ee648031B28ADEBDD30c91056c2c5cd9C6b , 10 * 132284880000000000000000 ) ; _freezeTransfer ( 0x1A2392fB72255eAe19BB626678125A506a93E363 , 10 * 61772880000000000000000 ) ; _freezeTransfer ( 0xCE2cEa425f7635557CFC00E18bc338DdE5B16C9A , 10 * 105360320000000000000000 ) ; _freezeTransfer ( 0x952AD1a2891506AC442D95DA4C0F1AE70A27b677 , 10 * 100252880000000000000000 ) ; _freezeTransfer ( 0x5eE1fC4D251143Da96db2a5cD61507f2203bf7b7 , 10 * 80492880000000000000000 ) ; }
","assignPreicoTokens transfers 10x tokens to pre-ICO participants
"
"function claimTokens ( ) respectTimeFrame isValidState payable public { require ( msg . value > 0 ) ; uint256 tokens = msg . value . mul ( tokenExchangeRate ) ; require ( isWithinCap ( tokens ) ) ; uint256 checkedSupply = assignedSupply . add ( tokens ) ; require ( checkedSupply . add ( shitFund ) <= totalSupply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; purchases [ msg . sender ] = purchases [ msg . sender ] . add ( tokens ) ; assignedSupply = checkedSupply ; ClaimSHIT ( msg . sender , tokens ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }
","Create ` msg.value ` ETH worth of SHIT
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _value <= allowed [ _from ] [ msg . sender ] , ""requesting more token than allowed"" ) ; _transfer ( _from , _to , _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; return true ; }
","Transfer tokens from one address to another .
"
"function thawTransfers ( ) public onlyAdmin returns ( bool thawed ) { tokenTransfersFrozen = false ; ThawTransfers ( msg . sender , true ) ; return true ; }
","Used to thaw token transfers
"
"function getTokenFrozenBalance ( Data storage self , string currency , address account ) internal view returns ( uint frozenBalance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.frozen' , currency , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getUint ( id ) ; }
","Get the frozen token balance for a given account
"
"function icoBuy ( ) public icoPhase ( ) payable isActive { prizePool . transfer ( msg . value ) ; raisedIcoValue = raisedIcoValue . add ( msg . value ) ; uint256 tokenAmount = calculateTokenAmountICO ( msg . value ) ; require ( icoPool >= tokenAmount ) ; icoPool = icoPool . sub ( tokenAmount ) ; balanceOf [ msg . sender ] += tokenAmount ; TransferEvent ( prizePool , msg . sender , tokenAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; }
","Please make sure that ICO Pool is at least equal to your bid
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool ) ;
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function proxyPayment ( address _owner ) payable public returns ( bool ) { doPayment ( _owner ) ; return true ; }
","` proxyPayment ( ) ` allows the caller to send ether to the Token directly and have the tokens created in an address of their choosing
"
"function batchSend ( address [ ] _recipients , uint256 [ ] _amounts , bytes _userData ) external whenNotPaused whenAccountNotFrozen ( msg . sender ) { require ( _recipients . length == _amounts . length , ""The lengths of _recipients and _amounts should be the same."" ) ; for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { doSend ( msg . sender , msg . sender , _recipients [ i ] , _amounts [ i ] , _userData , """" , true ) ; } }
","Send tokens to multiple recipients .
"
"function transfer ( address destination , uint256 amount ) public tradable ( msg . sender ) returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; balances [ destination ] = balances [ destination ] . add ( amount ) ; emit Transfer ( msg . sender , destination , amount ) ; return true ; }
","Transfers ` amount ` from msg.sender to ` destination `
"
"function setCampaignEndPointById ( bytes32 _bidId , string _endPoint ) public onlyIfCampaignExists ( ""setCampaignEndPointById"" , _bidId ) onlyIfWhitelisted ( ""setCampaignEndPointById"" , msg . sender ) { campaignEndPoints [ _bidId ] = _endPoint ; emit ExtendedCampaignEndPointUpdated ( _bidId , _endPoint ) ; }
","Set campaign signing web service endpoint Sets the webservice 's endpoint to which the user should submit the proof of attention
"
"function transfer ( address _to , uint256 _tokenId ) external onlyOwnerOf ( _tokenId ) { _clearApprovalAndTransfer ( msg . sender , _to , _tokenId ) ; }
","Transfers the ownership of a given token ID to another address
"
"function getTopBidders ( ) external view returns ( address [ 100 ] ) { address [ 100 ] memory tempArray ; for ( uint i = 0 ; i < 100 ; ++ i ) { tempArray [ i ] = _topBids [ i ] . bidderAddress ; } return tempArray ; }
","Returns a sorted array of the top 100 bidders
"
"function transferAnyERC20Token ( address _tokenAddress , uint256 _amount ) onlyOwner public returns ( bool success ) { return AumonetERC223 ( _tokenAddress ) . transfer ( owner , _amount ) ; }
","Allows the owner to transfer out any accidentally sent ERC20 tokens .
"
"function _buyTokens ( address _beneficiary , uint256 _investmentValue , uint256 _rate , FundRaiseType _fundRaiseType ) internal nonReentrant whenNotPaused returns ( uint256 , uint256 ) { if ( ! allowBeneficialInvestments ) { require ( _beneficiary == msg . sender , ""Beneficiary does not match funder"" ) ; } require ( isOpen ( ) , ""STO is not open"" ) ; require ( _investmentValue > 0 , ""No funds were sent"" ) ; uint256 investedUSD = DecimalMath . mul ( _rate , _investmentValue ) ; uint256 originalUSD = investedUSD ; require ( investedUSD . add ( investorInvestedUSD [ _beneficiary ] ) >= minimumInvestmentUSD , ""Total investment < minimumInvestmentUSD"" ) ; if ( ! accredited [ _beneficiary ] ) { uint256 investorLimitUSD = ( nonAccreditedLimitUSDOverride [ _beneficiary ] == 0 ) ? nonAccreditedLimitUSD : nonAccreditedLimitUSDOverride [ _beneficiary ] ; require ( investorInvestedUSD [ _beneficiary ] < investorLimitUSD , ""Non-accredited investor has reached limit"" ) ; if ( investedUSD . add ( investorInvestedUSD [ _beneficiary ] ) > investorLimitUSD ) investedUSD = investorLimitUSD . sub ( investorInvestedUSD [ _beneficiary ] ) ; } uint256 spentUSD ; for ( uint8 i = currentTier ; i < ratePerTier . length ; i ++ ) { if ( currentTier != i ) currentTier = i ; if ( mintedPerTierTotal [ i ] < tokensPerTierTotal [ i ] ) spentUSD = spentUSD . add ( _calculateTier ( _beneficiary , i , investedUSD . sub ( spentUSD ) , _fundRaiseType ) ) ; if ( investedUSD == spentUSD ) break ; } if ( spentUSD > 0 ) { if ( investorInvestedUSD [ _beneficiary ] == 0 ) investorCount = investorCount + 1 ; investorInvestedUSD [ _beneficiary ] = investorInvestedUSD [ _beneficiary ] . add ( spentUSD ) ; fundsRaisedUSD = fundsRaisedUSD . add ( spentUSD ) ; } uint256 spentValue ; if ( spentUSD == 0 ) { spentValue = 0 ; } else { spentValue = DecimalMath . mul ( DecimalMath . div ( spentUSD , originalUSD ) , _investmentValue ) ; } return ( spentUSD , spentValue ) ; }
","Low level token purchase
"
"function setTokenURIBase ( string _tokenURI ) public anyOperator { _setTokenURIBase ( _tokenURI ) ; }
","The user/developper needs to add the tokenID , in the end of URL , to use the URI and get all details .
"
"function freezeTransfers ( ) public onlyAdmin returns ( bool frozen ) { tokenTransfersFrozen = true ; FreezeTransfers ( msg . sender , true ) ; return true ; }
","Used to freeze token transfers
"
"function pause ( ) external whenNotPaused onlyOwner { set ( PAUSED , true ) ; emit Pause ( now ) ; }
","Called by the owner to pause , triggers stopped state
"
"function price ( ) public view returns ( uint256 _price ) { return tokenPerEth ; }
","Calculates the price as tokens/ether based on the corresponding bonus bracket .
"
"function getTribalMask ( uint256 _tokenId ) public view returns ( string maskName , uint256 basePrice , uint256 currentPrice , address currentOwner ) { TribalMask storage mask = tribalMasks [ _tokenId ] ; maskName = mask . name ; basePrice = mask . basePrice ; currentPrice = priceOf ( _tokenId ) ; currentOwner = tokenIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific token .
"
"function isCompetitionAllowed ( address user ) view returns ( bool ) { return isWhitelisted [ user ] ; }
","Checks whether an address is whitelisted in the competition contract and competition is active
"
"function totalCollections ( ) public view returns ( uint256 ) { return collectionNames . length ; }
","Get the total number of collections
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = ponyIndexToOwner [ _tokenId ] ; }
","Returns the address currently assigned ownership of a given Pony .
"
"function canSafeTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) ;
","Check if a transfer of the NFT with ID ` tokenId ` on behalf of account ` from ` to a recipient at account ` to ` with ` msg.value ` of ` value ` is approved .
"
"function buyToken ( ) internal { uint256 value = msg . value ; address sender = msg . sender ; require ( ! icoIsClosed ) ; require ( ! frozenAccount [ sender ] ) ; require ( value > 0 ) ; require ( currentTokenPrice > 0 ) ; uint256 detracted = currentTokenPrice / ( commission1 * commission2 ) ; uint256 amount = value / detracted ; uint256 moneyBack = value - ( amount * detracted ) ; require ( tokenBalanceOf [ this ] >= amount ) ; amountOfInvestments = amountOfInvestments + ( value - moneyBack ) ; updatePrices ( ) ; _transfer ( this , sender , amount ) ; if ( ! minimalGoalReached ) { checkMinimalGoal ( ) ; } if ( moneyBack > 0 ) { sender . transfer ( moneyBack ) ; } }
","Processing each buying
"
"function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( ""configure(uint256,uint256,uint256,uint256,uint8,address)"" ) ) ; }
","This function returns the signature of configure function
"
"function enableTransfers ( ) public onlyWhitelisted { require ( icoEndDate > 0 ) ; require ( now >= icoEndDate ) ; require ( ! transfersEnabled ) ; transfersEnabled = true ; }
","This function enables token transfers for everyone .
"
"function forceTransfer ( address _from , address _to , uint256 _value , bytes _data , bytes _log ) external ;
","Used by a controller to execute a forced transfer
"
"function owner ( ) external view returns ( address ) ;
","Get the owner of the contract
"
"function setDelegateAndLockTokens ( uint tokensToLock , address delegate ) public onlyShareholders onlyUndelegated notSelf { lockedDelegatingTokens [ msg . sender ] = tokensToLock ; delegatedAmountsByDelegate [ delegate ] = SafeMath . add ( delegatedAmountsByDelegate [ delegate ] , tokensToLock ) ; totalLockedTokens = SafeMath . add ( totalLockedTokens , tokensToLock ) ; delegatesByDelegator [ msg . sender ] = delegate ; require ( sharesTokenAddress . transferFrom ( msg . sender , tokenLocker , tokensToLock ) ) ; require ( sharesTokenAddress . balanceOf ( tokenLocker ) == totalLockedTokens ) ; TokensDelegated ( msg . sender , tokensToLock , delegate ) ; }
","Set the delegate address for a specified number of tokens belonging to the sending address , locking the tokens .
"
"function blacklistEscapeToken ( address _token ) internal { escapeBlacklist [ _token ] = true ; EscapeHatchBlackistedToken ( _token ) ; }
","Creates the blacklist of tokens that are not able to be taken out of the contract ; can only be done at the deployment , and the logic to add to the blacklist will be in the constructor of a child contract
"
"function getTokensByOwner ( address _owner ) external view returns ( address [ ] ) ;
","Returns the list of tokens owned by the selected address
"
"function disableTokenMinting ( ) public onlyOwner returns ( bool disabled ) { tokenMintingEnabled = false ; TokenMintingDisabled ( msg . sender , true ) ; return true ; }
","Used to disable token minting
"
"function addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) external onlyOwner nonReentrant { IModuleRegistry ( moduleRegistry ) . useModule ( _moduleFactory ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; uint8 [ ] memory moduleTypes = moduleFactory . getTypes ( ) ; uint256 moduleCost = moduleFactory . getSetupCost ( ) ; require ( moduleCost <= _maxCost , ""Invalid cost"" ) ; ERC20 ( polyToken ) . approve ( _moduleFactory , moduleCost ) ; address module = moduleFactory . deploy ( _data ) ; require ( modulesToData [ module ] . module == address ( 0 ) , ""Module exists"" ) ; ERC20 ( polyToken ) . approve ( module , _budget ) ; bytes32 moduleName = moduleFactory . getName ( ) ; uint256 [ ] memory moduleIndexes = new uint256 [ ] ( moduleTypes . length ) ; uint256 i ; for ( i = 0 ; i < moduleTypes . length ; i ++ ) { moduleIndexes [ i ] = modules [ moduleTypes [ i ] ] . length ; modules [ moduleTypes [ i ] ] . push ( module ) ; } modulesToData [ module ] = TokenLib . ModuleData ( moduleName , module , _moduleFactory , false , moduleTypes , moduleIndexes , names [ moduleName ] . length ) ; names [ moduleName ] . push ( module ) ; emit ModuleAdded ( moduleTypes , moduleName , _moduleFactory , module , moduleCost , _budget , now ) ; }
","Attachs a module to the SecurityToken
"
"function symbol ( ) public pure returns ( string ) { return ""KCT"" ; }
","An abbreviated name for NFTs in this contract
"
"function deposit ( Data storage self , string currency , address account , uint amount , string issuerFirm ) internal returns ( bool success ) { bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , account ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.issued' , currency , issuerFirm ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.supply' , currency ) ) ; require ( self . Storage . setUint ( id_a , self . Storage . getUint ( id_a ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setUint ( id_b , self . Storage . getUint ( id_b ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setUint ( id_c , self . Storage . getUint ( id_c ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; emit Deposit ( currency , account , amount , issuerFirm ) ; return true ; }
","Deposit an amount of currency into the Ethereum account holder
"
"function mintMulti ( address [ ] _investors , uint256 [ ] _values ) external returns ( bool success ) ;
","Mints new tokens and assigns them to the target investors .
"
"function unitBattlePLATCost ( uint256 cardId ) external constant returns ( uint256 ) { return SafeMath . mul ( battlecardInfo [ cardId ] . ethCost , PLATPrice ) ; }
","get the battle card 's plat cost
"
"function powerUpContract ( ) external onlyOwner { require ( ! contractPoweredUp ) ; require ( parsecToken . balanceOf ( this ) >= PARSEC_CREDITS_MINIMAL_AMOUNT ) ; contractPoweredUp = true ; }
","Check if pre-sale contract has enough Parsec credits on its account balance to reward all possible participations within pre-sale period and max cap
"
"function changeAllowAllWhitelistIssuances ( bool _allowAllWhitelistIssuances ) public withPerm ( FLAGS ) { allowAllWhitelistIssuances = _allowAllWhitelistIssuances ; emit AllowAllWhitelistIssuances ( _allowAllWhitelistIssuances ) ; }
","Used to change the flag true - It refers that time lock is ignored for issuances ( address must still be on whitelist ) false - It refers transfers are restricted for all addresses .
"
"function isSubscriptionProduct ( uint256 _productId ) public view returns ( bool ) { return intervalOf ( _productId ) > 0 ; }
","returns if this product is a subscription or not
"
"function addProduct ( bytes32 _mappingID , uint _index , string _productID , string _quantity , string _attributes ) private { wineries [ _mappingID ] [ _index ] . prods . push ( Product ( _productID , _quantity , _attributes ) ) ; }
","TODO Commenti
"
"function mul ( uint256 x , uint256 y ) internal pure returns ( uint256 z ) { z = SafeMath . add ( SafeMath . mul ( x , y ) , ( 10 ** 18 ) / 2 ) / ( 10 ** 18 ) ; }
","This function multiplies two decimals represented as ( decimal 10DECIMALS )
"
"function canBeSet ( bytes32 _propID ) view public returns ( bool ) { ParamProposal memory prop = proposals [ _propID ] ; return ( now > prop . appExpiry && now < prop . processBy && prop . challengeID == 0 ) ; }
","Determines whether a proposal passed its application stage without a challenge
"
"function createCDPLeveragedAllDai ( ) public returns ( bytes32 id ) { return createCDPLeveragedDai ( dai . balanceOf ( msg . sender ) ) ; }
","create a CDP all the Dai in the sender 's balance ( needs approval ) , and then create Dai and reinvest it in the CDP until the target liquidation price is reached ( or the minimum investment amount )
"
"function thawTransfers ( ) onlyOwner returns ( bool thawed ) { tokenTransfersFrozen = false ; ThawTransfers ( msg . sender , true ) ; return true ; }
","Used to thaw token transfers
"
"function confirmProofOfWork ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender == job . evaluator ) ; job . proofOfLastWorkVerified = true ; emit ProofOfWorkConfirmed ( _JobID , job . evaluator , true ) ; }
","this function lets the evaluator confirm the proof of work provided by worker
"
"function execute ( bytes32 _buyID , bytes32 _sellID , address _buyer , address _seller , TokenPair memory _tokens ) private { SettlementDetails memory settlementDetails = ( orderDetails [ _buyID ] . settlementID == RENEX_ATOMIC_SETTLEMENT_ID ) ? settlementDetails = calculateAtomicFees ( _buyID , _sellID , _tokens ) : settlementDetails = calculateSettlementDetails ( _buyID , _sellID , _tokens ) ; renExBalancesContract . transferBalanceWithFee ( _buyer , _seller , settlementDetails . leftTokenAddress , settlementDetails . leftVolume , settlementDetails . leftTokenFee , orderSubmitter [ _buyID ] ) ; renExBalancesContract . transferBalanceWithFee ( _seller , _buyer , settlementDetails . rightTokenAddress , settlementDetails . rightVolume , settlementDetails . rightTokenFee , orderSubmitter [ _sellID ] ) ; }
","Called by ` settle ` , executes the settlement for a RenEx order or distributes the fees for a RenExAtomic swap .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { adjustInvestorCount ( msg . sender , _to , _value ) ; require ( verifyTransfer ( msg . sender , _to , _value ) , ""Transfer is not valid"" ) ; adjustBalanceCheckpoints ( msg . sender ) ; adjustBalanceCheckpoints ( _to ) ; require ( super . transfer ( _to , _value ) ) ; return true ; }
","Overloaded version of the transfer function
"
"function validPurchase ( ) internal constant returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value > 0 ; bool withinTokenLimit = tokensRaised < maxTokensRaised ; bool minimumPurchase = msg . value >= minPurchase ; bool hasBalanceAvailable = crowdsaleBalances [ msg . sender ] < maxPurchase ; bool limitGas = tx . gasprice <= limitGasPrice ; return withinPeriod && nonZeroPurchase && withinTokenLimit && minimumPurchase && hasBalanceAvailable && limitGas ; }
","Checks if a purchase is considered valid
"
"function revokeOperator ( address _operator ) external { require ( _operator != msg . sender ) ; require ( mAuthorized [ _operator ] [ msg . sender ] ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = true ; } else { mAuthorized [ _operator ] [ msg . sender ] = false ; } emit RevokedOperator ( _operator , msg . sender ) ; }
","Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalLoans = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 loanId ; for ( loanId = 0 ; loanId <= totalLoans ; loanId ++ ) { if ( loans [ loanId ] . lender == _owner && loans [ loanId ] . status == Status . lent ) { result [ resultIndex ] = loanId ; resultIndex ++ ; } } return result ; } }
","Returns all the loans that a lender possess
"
"function doInclusionChecks ( bytes prevTxBytes , bytes exitingTxBytes , bytes prevTxInclusionProof , bytes exitingTxInclusionProof , bytes signature , uint256 [ 2 ] blocks ) private view { if ( blocks [ 1 ] % childBlockInterval != 0 ) { checkIncludedAndSigned ( exitingTxBytes , exitingTxInclusionProof , signature , blocks [ 1 ] ) ; } else { checkBothIncludedAndSigned ( prevTxBytes , exitingTxBytes , prevTxInclusionProof , exitingTxInclusionProof , signature , blocks ) ; } }
","If exitingTxBytes corresponds to a deposit transaction , prevTxBytes can not have a meaningul value and thus it is ignored .
"
"function setTokenURI ( uint256 _tokenId , string _uri ) auth ( MINT_ROLE ) public { _setTokenURI ( _tokenId , _uri ) ; }
","Set ` _uri ` for ` _tokenId ` ,
"
"function freezeMultiAccounts ( address [ ] addresses , bool freeze ) onlyOwner public { for ( uint i = 0 ; i < addresses . length ; i ++ ) { frozenAccount [ addresses [ i ] ] = freeze ; FrozenFunds ( addresses [ i ] , freeze ) ; } }
","freeze multiple addresses
"
"function getPow ( uint256 _tokenId ) public view returns ( uint256 Id , string powName , uint256 sellingPrice , address owner , uint gameId , uint gameItemId ) { Pow storage pow = pows [ _tokenId ] ; Id = _tokenId ; powName = pow . name ; sellingPrice = powIndexToPrice [ _tokenId ] ; owner = powIndexToOwner [ _tokenId ] ; gameId = pow . gameId ; gameItemId = pow . gameItemId ; }
","Returns all the relevant information about a specific pow .
"
"function enableTransfers ( bool _transfersEnabled ) onlyController { transfersEnabled = _transfersEnabled ; }
","Enables token holders to transfer their tokens freely if true
"
"function findEndpointByAddress ( address eth_address ) public view returns ( string endpoint ) { return address_to_endpoint [ eth_address ] ; }
","Finds the endpoint if given a registered Ethereum address .
"
"function setFeeToken ( address _feeToken ) external validAddress ( _feeToken ) onlyOwner { feeToken = Fee ( _feeToken ) ; }
","To set the FEE token address
"
"function mint ( address _address , uint _value ) onlyAccountAddressForSponsee { balances [ _address ] = balances [ _address ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; if ( totalSupply > cap ) { revert ( ) ; } LogMint ( _address , _value ) ; Transfer ( address ( 0x0 ) , _address , _value ) ; }
","Mint new token amount .
"
"function getSig ( bytes _data ) internal pure returns ( bytes4 sig ) { uint len = _data . length < 4 ? _data . length : 4 ; for ( uint i = 0 ; i < len ; i ++ ) { sig = bytes4 ( uint ( sig ) + uint ( _data [ i ] ) * ( 2 ** ( 8 * ( len - 1 - i ) ) ) ) ; } }
","Gets function signature from _data
"
"function newPayment ( address _token , address _receiver , uint256 _amount , uint64 _initialPaymentTime , uint64 _interval , uint64 _maxRepeats , string _reference ) external authP ( CREATE_PAYMENTS_ROLE , arr ( _token , _receiver , _amount , _interval , _maxRepeats ) ) transitionsPeriod returns ( uint256 paymentId ) { require ( _amount > 0 , ERROR_NEW_PAYMENT_AMOUNT_ZERO ) ; if ( _initialPaymentTime <= getTimestamp64 ( ) && _maxRepeats == 1 ) { _makePaymentTransaction ( _token , _receiver , _amount , NO_PAYMENT , 0 , _reference ) ; return ; } require ( settings . budgets [ _token ] >= _amount || ! settings . hasBudget [ _token ] , ERROR_BUDGET ) ; paymentId = paymentsNextIndex ++ ; emit NewPayment ( paymentId , _receiver , _maxRepeats , _reference ) ; Payment storage payment = payments [ paymentId ] ; payment . token = _token ; payment . receiver = _receiver ; payment . amount = _amount ; payment . initialPaymentTime = _initialPaymentTime ; payment . interval = _interval ; payment . maxRepeats = _maxRepeats ; payment . createdBy = msg . sender ; if ( nextPaymentTime ( paymentId ) <= getTimestamp64 ( ) ) { _executePayment ( paymentId ) ; } }
","Create a new payment of ` @ tokenAmount ( _token , _amount ) ` to ` _receiver `` _maxRepeats > 0 ?
"
"function enableMigration ( IMigrationTarget migration ) public ;
","should enable migration to migration target
"
"function buy ( uint _imageId ) public payable { require ( isImageOnSale ( _imageId ) ) ; require ( msg . value >= sellAds [ _imageId ] . price ) ; removeOrder ( _imageId ) ; address _creator ; address _imageOwner = digitalPrintImageContract . ownerOf ( _imageId ) ; ( , , _creator , , ) = digitalPrintImageContract . imageMetadata ( _imageId ) ; balances [ _creator ] += msg . value * 2 / 100 ; balances [ owner ] += msg . value * 3 / 100 ; balances [ _imageOwner ] += msg . value * 95 / 100 ; digitalPrintImageContract . transferFromMarketplace ( sellAds [ _imageId ] . exchanger , msg . sender , _imageId ) ; emit ImageBought ( _imageId , msg . sender , msg . value ) ; }
","Function to buy image from Marketplace
"
"function setEthAmount ( uint256 ethAmountInWei ) isOwner { require ( ethAmountInWei > 0 ) ; require ( ethAmount != ethAmountInWei ) ; ethAmount = ethAmountInWei ; updatePrices ( ) ; }
","Set current ethAmount price in wei for one token
"
"function fundingCap ( ) public constant returns ( uint256 amount ) { }
","the maximum funding amount for this campaign
"
"function totalSupply ( ) public view returns ( uint256 ) { return elements . length ; }
","Returns the total number of tokens currently in existence .
"
"function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( synthesizingAuction != address ( 0 ) ) ; require ( geneSynthesis != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
","This should be public rather than external .
"
"function mintTokens ( uint256 _amount ) external onlyOwner returns ( bool ) { return _mintTokens ( _amount ) ; }
","Mint more tokens
"
"function exchangeSynthsForSynthetix ( uint synthAmount ) public pricesNotStale notPaused returns ( uint ) { uint synthetixToSend = synthetixReceivedForSynths ( synthAmount ) ; synth . transferFrom ( msg . sender , fundsWallet , synthAmount ) ; synthetix . transfer ( msg . sender , synthetixToSend ) ; emit Exchange ( ""sUSD"" , synthAmount , ""SNX"" , synthetixToSend ) ; return synthetixToSend ; }
","Exchange sUSD for SNX
"
"function transferFromPreSigned ( bytes _signature , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = transferFromPreSignedHashing ( address ( this ) , _from , _to , _value , _fee , _nonce ) ; address spender = recover ( hashedTx , _signature ) ; require ( spender != address ( 0 ) ) ; nonces [ _signature ] = true ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ spender ] = allowed [ _from ] [ spender ] . sub ( _value ) ; balances [ spender ] = balances [ spender ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; nonces [ _signature ] = true ; emit Transfer ( _from , _to , _value ) ; emit Transfer ( spender , msg . sender , _fee ) ; return true ; }
","Transfer tokens from one address to another
"
"function changeCountryLimit ( uint _countryCode , uint _limit ) onlyOracleOrOwner external returns ( uint ) { uint _countryIndex = countryIndex [ _countryCode ] ; require ( _countryIndex != 0 ) ; uint _currentTokenHolderNumber = countryLimitsList [ _countryIndex ] . currentTokenHolderNumber ; if ( _currentTokenHolderNumber > _limit ) { return DATA_CONTROLLER_CURRENT_WRONG_LIMIT ; } countryLimitsList [ _countryIndex ] . maxTokenHolderNumber = _limit ; _emitCountryCodeChanged ( _countryIndex , _countryCode , _limit ) ; return OK ; }
","Change country limits .
"
"function getValueAt ( Checkpoint [ ] storage checkpoints , uint256 _checkpointId , uint256 _currentValue ) internal view returns ( uint256 ) { require ( _checkpointId <= currentCheckpointId ) ; if ( _checkpointId == 0 ) { return 0 ; } if ( checkpoints . length == 0 ) { return _currentValue ; } if ( checkpoints [ 0 ] . checkpointId >= _checkpointId ) { return checkpoints [ 0 ] . value ; } if ( checkpoints [ checkpoints . length - 1 ] . checkpointId < _checkpointId ) { return _currentValue ; } if ( checkpoints [ checkpoints . length - 1 ] . checkpointId == _checkpointId ) { return checkpoints [ checkpoints . length - 1 ] . value ; } uint256 min = 0 ; uint256 max = checkpoints . length - 1 ; while ( max > min ) { uint256 mid = ( max + min ) / 2 ; if ( checkpoints [ mid ] . checkpointId == _checkpointId ) { max = mid ; break ; } if ( checkpoints [ mid ] . checkpointId < _checkpointId ) { min = mid + 1 ; } else { max = mid ; } } return checkpoints [ max ] . value ; }
","Queries value at a defined checkpoint
"
"function _pause ( ) internal { require ( ! paused ) ; paused = true ; emit Pause ( now ) ; }
","called by the owner to pause , triggers stopped state
"
"function destroyAndSend ( address _recipient ) public onlyOwner { selfdestruct ( _recipient ) ; }
","Destructs this contract ( removes it from the blockchain ) and sends all funds in it to the specified recipient address .
"
"function equals ( string a , string b ) internal pure returns ( bool result ) { if ( keccak256 ( abi . encodePacked ( a ) ) == keccak256 ( abi . encodePacked ( b ) ) ) { return true ; } return false ; }
","Checks if two strings are equal or not .
"
"function transferToAddress ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
","Handles transfer to an ECA ( Externally Controlled Account ) , a normal account ~ ERC-223 Proposed Standard
"
"function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceSignature_ERC721Enumerable ) || ( _interfaceID == InterfaceSignature_ERC721Metadata ) ) ; }
","Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
"
"function getPendingReward ( ERC20 _token , address _holder ) public constant returns ( uint ) { uint acc = 0 ; for ( uint i = nextDepositToPayout [ msg . sender ] ; i < deposits . length ; i ++ ) { Deposit storage d = deposits [ i ] ; if ( ( d . token == _token ) && ( ! d . canceled ) && ( ! isDepositSkiped ( _holder , i ) ) ) { acc += d . amount * rewardToken . balanceOfAt ( _holder , d . block ) / rewardToken . totalSupplyAt ( d . block ) ; } } return acc ; }
","Calculates the amount of a given token ( or ether ) the holder can receive
"
"function deregisterToken ( uint32 _tokenCode ) external onlyOwner { require ( tokens [ _tokenCode ] . registered , ""not registered"" ) ; tokens [ _tokenCode ] . registered = false ; emit LogTokenDeregistered ( _tokenCode ) ; }
","Sets a token as being deregistered .
"
"function removeSigner ( address _signer ) public onlyOwner { signers [ _signer ] = false ; }
","update signer
"
"function getStageByBlockNumber ( uint256 _blockNumber ) public view returns ( uint8 ) { if ( ! isDuringSalePeriod ( _blockNumber ) ) revert ( ) ; uint256 totalBlocks = safeSub ( endBlock , startBlock ) ; uint256 numOfBlockPassed = safeSub ( _blockNumber , startBlock ) ; return uint8 ( safeDiv ( safeMul ( totalStages , numOfBlockPassed ) , totalBlocks ) + 1 ) ; }
","get crowd fund stage by block number
"
"function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { amountToGive = data . amountToGive ; }
","Gets the amount that TotlePrimary needs to give for this order
"
"function mint ( address _to , uint256 _amount ) public returns ( bool ) { require ( totalSupply ( ) . add ( _amount ) <= cap ) ; return super . mint ( _to , _amount ) ; }
","Overrides original mint function from MintableToken to limit minting over cap
"
"function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 6700000000 ; }
","minimum amount of funding to consider the sale as successful ( in euro-cents )
"
"function updateBrokerVerifierContract ( RenExBrokerVerifier _newBrokerVerifierContract ) external onlyOwner { emit LogBrokerVerifierContractUpdated ( brokerVerifierContract , _newBrokerVerifierContract ) ; brokerVerifierContract = _newBrokerVerifierContract ; }
","Allows the owner of the contract to update the address of the RenExBrokerVerifier contract .
"
"function reclaimToken ( address _token ) external onlyAdmin { ERC20 erc20 = ERC20 ( _token ) ; uint256 balance = erc20 . balanceOf ( this ) ; erc20 . safeTransfer ( msg . sender , balance ) ; }
","Transfers all ERC20 tokens held by the contract to the owner .
"
"function unpause ( ) public onlyAdmin whenPaused { require ( address ( saleAuction ) != address ( 0 ) ) ; require ( address ( sanctuary ) != address ( 0 ) ) ; require ( address ( battleProvider ) != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function addAddressToAccountFor ( address _newAddress , bytes _newAddressSig , bytes _senderSig , address _sender , bytes32 _nonce ) public onlyRegistryAdmin { addAddressToAccountForUser ( _newAddress , _newAddressSig , _senderSig , _sender , _nonce ) ; }
","Add an address to an existing id on behalf of a user to pay the gas costs
"
"function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( _getOwner ( ) ) ; _setOwner ( address ( 0 ) ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return erc20Store . balances ( _owner ) ; }
","Core logic of the ERC20 ` balanceOf ` function .
"
"function getPlayerRemainingTime ( uint boardId , PlayerColor color ) view external returns ( uint , uint , uint ) { GoBoard storage board = allBoards [ boardId ] ; require ( board . status == BoardStatus . InProgress ) ; uint timePeriods = getPlayerTimePeriods ( board , color ) ; uint totalTimeRemaining = timePeriods * PLAYER_TURN_SINGLE_PERIOD ; if ( color == board . nextTurnColor ) { uint timePeriodsUsed = getTimePeriodsUsed ( board . lastUpdate ) ; if ( timePeriods > timePeriodsUsed ) { timePeriods -= timePeriodsUsed ; } else { timePeriods = 0 ; } uint timeUsed = ( now - board . lastUpdate ) ; if ( totalTimeRemaining > timeUsed ) { totalTimeRemaining -= timeUsed ; } else { totalTimeRemaining = 0 ; } } return ( timePeriods , PLAYER_TURN_SINGLE_PERIOD , totalTimeRemaining ) ; }
","Convinience function to help present how much time a player has .
"
"function requestArbitration ( bytes32 question_id ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitycheck . notifyOfArbitrationRequest ( question_id , msg . sender ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! realitycheck . isFinalized ( question_id ) ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }
","Request arbitration , freezing the question until we send submitAnswerByArbitrator
"
"function setFinancialOfficer ( address _financialOfficerAddress ) external onlyExecutiveOfficer { require ( _financialOfficerAddress != address ( 0 ) ) ; financialOfficerAddress = _financialOfficerAddress ; }
","Reassign the financial officer role
"
"function getToken ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; Token storage token = collectibleIdx [ _tokenId ] ; sellingPrice = token . price ; if ( sellingPrice == 0 ) sellingPrice = getInitialPriceOfToken ( _tokenId ) ; owner = token . owner ; nextSellingPrice = getNextPrice ( sellingPrice , _tokenId ) ; }
","Returns all the relevant information about a specific collectible .
"
"function addValidator ( address _validator ) public onlyOwner { validators [ _validator ] = true ; emit ValidatorAdded ( _validator ) ; }
","add a Validator
"
"function claimWinnings ( bytes32 question_id , bytes32 [ ] history_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) public { }
","Assigns the winnings ( bounty and bonds ) to everyone who gave the accepted answer Caller must provide the answer history , in reverse order
"
"function createChannelDelegate ( address _sender_address , address _receiver_address , uint192 _deposit ) isTrustedContract external { createChannelPrivate ( _sender_address , _receiver_address , _deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _deposit ) ) ; }
","Function that allows a delegate contract to create a new channel between ` _sender_address ` and ` _receiver_address ` and transfers the token deposit to this contract .
"
"function verifyDeed ( string document ) public constant returns ( bool ) { uint256 documentHash = uint256 ( keccak256 ( document ) ) ; return documentRegistry [ documentHash ] > 0 ; }
","Proves an existence of the document by checking if it exists in a proof of existence mapping
"
"function mint ( address _to , uint256 _amount ) public requiresWhitelistedToken whenNotPaused { _mint ( _to , _amount ) ; }
","Mints CUSD on behalf of a user .
"
"function setWhitelistedOnly ( bool _isWhitelistOnly ) onlyOwner public { if ( isTransferWhitelistOnly != _isWhitelistOnly ) { isTransferWhitelistOnly = _isWhitelistOnly ; TransferWhitelistOnly ( _isWhitelistOnly ) ; } }
","Enabling / Disabling transfers of non whitelisted users
"
"function finalizeCampaign ( ) public { require ( ( campaignState == 1 ) || ( ( campaignState != 0 ) && ( now > tCampaignEnd + ( 2880 minutes ) ) ) ) ; campaignState = 0 ; trusteeVaultAddr . transfer ( this . balance ) ; uint256 bountyTokens = ( tokensGenerated . mul ( PRCT_BOUNTY ) ) . div ( 100 ) ; uint256 teamTokens = ( tokensGenerated . mul ( PRCT_TEAM ) ) . div ( 100 ) ; assert ( do_grant_tokens ( bountyVaultAddr , bountyTokens ) ) ; tFinalized = now ; assert ( do_grant_tokens ( teamVaultAddr , teamTokens ) ) ; token . finalize ( ) ; Finalized ( tFinalized ) ; }
","Finalizes the campaign Get funds out , generates team , bounty and reserve tokens
"
"function realitycheck ( ) external view returns ( Realitio ) { return realitio ; }
","Returns the Realitio contract address - deprecated in favour of realitio ( )
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool ) { var avail = allowances [ _from ] [ msg . sender ] > balances [ _from ] ? balances [ _from ] : allowances [ _from ] [ msg . sender ] ; if ( avail >= _value ) { allowances [ _from ] [ msg . sender ] -= _value ; balances [ _from ] -= _value ; balances [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; } return false ; }
","from ` _from ` will be sended ` _value ` tokens to ` _to `
"
"function _getTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { return _weiAmount . mul ( etherPriceInCents ) . div ( tokenPriceInCents ) ; }
","Calculates the number of VRH tokens for the supplied wei value .
"
"function setBidId ( Campaign storage _campaign , bytes32 _bidId ) internal { _campaign . bidId = _bidId ; }
","Set campaign id
"
"function externalTokensRecovery ( ERC20TokenInterface _address ) onlyAdmin ( 2 ) public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
","Function to move any token stuck on contract
"
"function setPrices ( uint256 newRate ) onlyOwner public { tokensPerEther = newRate ; }
","Allow users to buy tokens for ` newRate ` x eth
"
"function createCanvas ( ) external returns ( uint canvasId ) { return _createCanvasInternal ( 0x0 ) ; }
","Creates new canvas .
"
"function redeemVoucher ( uint256 voucherCode , address voucherOwner , address [ ] sellers , uint256 lastQuantity ) public onlyOwner payable { uint256 totalVouchers = multiExecute ( sellers , lastQuantity ) ; address seller = sellers . length == 1 ? sellers [ 0 ] : 0 ; emit VoucherRedeemed ( voucherCode , voucherOwner , seller , totalVouchers ) ; }
","A user has redeemed a top-up voucher for phone credit .
"
"function approve ( address _recipient , uint256 _amount ) public returns ( bool ) { return __approve_impl ( msg . sender , _recipient , _amount ) ; }
","Approve amount ` _amount ` of tokens to send from transaction creator to ` _recipient `
"
"function cancelTransfer ( bytes32 sha ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; biometricCompleted [ sha ] = true ; return true ; }
","Cancel pending transfer , can only be called by msg.sender == biometricFrom [ sha ]
"
"function forceBurn ( address _from , uint256 _value , bytes _data , bytes _log ) external ;
","Used by a controller to execute a foced burn
"
"function Bhinnekamint ( address _client , uint _value , uint _type ) onlyowner public { uint numBTI ; require ( totalToken <= totalBhinneka ) ; if ( _type == 1 ) { numBTI = _value * 6000 * ( 10 ** decimals ) ; } else if ( _type == 2 ) { numBTI = _value * 5000 * ( 10 ** decimals ) ; } balances [ owner ] = safeSub ( balances [ owner ] , numBTI ) ; balances [ _client ] = safeAdd ( balances [ _client ] , numBTI ) ; totalToken = safeAdd ( totalToken , numBTI ) ; Transfer ( owner , _client , numBTI ) ; }
","Transfer tokens based on type
"
"function setupInitialState ( ) external onlyOwner { setupInitialSupply ( ) ; }
","Sets up the initial balances
"
"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ _from ] >= _amount && allowed [ _from ] [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ _from ] -= _amount ; allowed [ _from ] [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( _from , _to , _amount ) ; return true ; } else { return false ; } }
","Transfer tokens on behalf of _from
"
"function _getNewEstateId ( ) internal view returns ( uint256 ) { return totalSupply ( ) . add ( 1 ) ; }
","Return a new unique id
"
"function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; checkValue ( from , _value . add ( _fee ) ) ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned transfer
"
"function transfer ( address _to , uint256 _amount ) public notTimeLocked stopInEmergency returns ( bool success ) { if ( balances [ msg . sender ] < _amount ) { error ( 'transfer: the amount to transfer is higher than your token balance' ) ; return false ; } if ( ! SCComplianceService . validate ( msg . sender , _to , _amount ) ) { error ( 'transfer: not allowed by the compliance service' ) ; return false ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit Transfer ( msg . sender , _to , _amount ) ; return true ; }
","Send _amount amount of tokens to address _to
"
"function burn ( uint256 _value ) public ;
","Burn function used to burn the securityToken
"
"function _createHolderId ( address _holder ) internal returns ( uint ) { uint holderId = holderIndex [ _holder ] ; if ( holderId == 0 ) { holderId = ++ holdersCount ; holders [ holderId ] . addr = _holder ; holderIndex [ _holder ] = holderId ; } return holderId ; }
","Returns holder id for the specified address , creates it if needed .
"
"function costForProductCycles ( uint256 _productId , uint256 _numCycles ) public view returns ( uint256 ) { return priceOf ( _productId ) . mul ( _numCycles ) ; }
","returns the total cost to renew a product for a number of cycles
"
"function transferFromMarketplace ( address _from , address _to , uint256 _imageId ) public onlyMarketplaceContract { require ( isApprovedOrOwner ( _from , _imageId ) ) ; clearApproval ( _from , _imageId ) ; removeTokenFrom ( _from , _imageId ) ; addTokenTo ( _to , _imageId ) ; emit Transfer ( _from , _to , _imageId ) ; }
","approving image to be taken from specific address
"
"function computeIndexId ( address owner , bytes32 indexName ) constant returns ( bytes32 ) { return GroveLib . computeIndexId ( owner , indexName ) ; }
","Computes the id for a Grove index which is sha3 ( owner , indexName )
"
"function clearAll ( ) public onlyOwner { token . transfer ( owner , token . balanceOf ( this ) ) ; for ( uint i = 0 ; i < addresses . length ; i ++ ) { Beneficiary storage beneficiary = beneficiaries [ addresses [ i ] ] ; beneficiary . isBeneficiary = false ; beneficiary . released = 0 ; beneficiary . vested = 0 ; beneficiary . start = 0 ; beneficiary . cliff = 0 ; beneficiary . duration = 0 ; beneficiary . revoked = false ; beneficiary . revocable = false ; beneficiary . description = """" ; } addresses . length = 0 ; }
","Allows the owner to clear the contract .
"
"function submitTransactionWithVRS ( address destination , uint value , bytes data , bytes pass , bytes32 [ 3 ] signerParams ) public payable returns ( uint transactionId ) { transactionId = addTransaction ( destination , value , data ) ; confirmTransactionWithVRS ( transactionId , pass , uint8 ( signerParams [ 0 ] ) , signerParams [ 1 ] , signerParams [ 2 ] ) ; }
","Allows anyone with correctly signed message to submit a transaction .
"
"function approve ( address spender , uint amount ) public notDeprecated returns ( bool success ) { require ( lib . approveAllowance ( spender , amount ) , ""Error: Unable to approve allowance for spender. Please ensure spender is not null and does not have a frozen balance."" ) ; return true ; }
","approves spender a given amount
"
"function calculateBonus ( uint256 _tokenAmount , uint256 _percentage ) public pure returns ( uint256 ) { return _tokenAmount . mul ( _percentage ) . div ( 100 ) ; }
","Calculates bonus .
"
"function setLevToken ( address _levToken ) external validAddress ( _levToken ) onlyOwner { levToken = Token ( _levToken ) ; }
","To set the the address of the LEV token
"
"function ( ) public payable { purchase ( ) ; }
","Token purchase function .
"
"function audit ( address auditor ) onlyManager { data . audit ( auditor ) ; ChannelAudited ( data . audited ) ; }
","Settle the transfers and balances of the channel and pay out to each participant .
"
"function getModuleByName ( uint8 _moduleType , bytes32 _name ) public view returns ( bytes32 , address ) { if ( modules [ _moduleType ] . length > 0 ) { for ( uint256 i = 0 ; i < modules [ _moduleType ] . length ; i ++ ) { if ( modules [ _moduleType ] [ i ] . name == _name ) { return ( modules [ _moduleType ] [ i ] . name , modules [ _moduleType ] [ i ] . moduleAddress ) ; } } return ( """" , address ( 0 ) ) ; } else { return ( """" , address ( 0 ) ) ; } }
","returns module list for a module name - will return first match
"
"function updateTextForHolder ( bytes32 _externalHolderId , bytes _text ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; holders [ _holderIndex ] . text = _text ; return OK ; }
","Changes text for holder .
"
"function createProduct ( uint256 _productId , uint256 _initialPrice , uint256 _initialInventoryQuantity , uint256 _supply , uint256 _interval ) external onlyCEOOrCOO { _createProduct ( _productId , _initialPrice , _initialInventoryQuantity , _supply , _interval ) ; }
","createProduct creates a new product in the system
"
"function getChannelsAddresses ( ) constant returns ( address [ ] ) { return data . all_channels ; }
","Get all channels
"
"function isThirdPartyManagingProxy ( address _thirdpartyOwner , address _accountProxy ) public view returns ( bool ) { address _userRouter = Owned ( _accountProxy ) . contractOwner ( ) ; return UserInterface ( _userRouter ) . isThirdPartyOwner ( _thirdpartyOwner ) ; }
","Gets if provided ` _thirdpartyOwner ` is actually a third-party address that manages ` _accountProxy ` proxy address .
"
"function ownerClawback ( ) external onlyOwner { if ( now < OWNER_CLAWBACK_DATE ) throw ; if ( ! owner . send ( this . balance ) ) throw ; }
","The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract .
"
"function submitOrder ( bytes _prefix , uint64 _settlementID , uint64 _tokens , uint256 _price , uint256 _volume , uint256 _minimumVolume ) external withGasPriceLimit ( submissionGasPriceLimit ) { SettlementUtils . OrderDetails memory order = SettlementUtils . OrderDetails ( { settlementID : _settlementID , tokens : _tokens , price : _price , volume : _volume , minimumVolume : _minimumVolume } ) ; bytes32 orderID = SettlementUtils . hashOrder ( _prefix , order ) ; require ( orderStatus [ orderID ] == OrderStatus . None , ""order already submitted"" ) ; require ( orderbookContract . orderState ( orderID ) == Orderbook . OrderState . Confirmed , ""unconfirmed order"" ) ; orderSubmitter [ orderID ] = msg . sender ; orderStatus [ orderID ] = OrderStatus . Submitted ; orderDetails [ orderID ] = order ; }
","Stores the details of an order .
"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( transferLimits [ msg . sender ] == 0 || transferLimits [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","send ` _value ` token to ` _to `
"
"function transferFromAndCall ( address from , address to , uint256 value , bytes data ) public returns ( bool ) ;
","Transfer tokens from one address to another and then call ` onTransferReceived ` on receiver
"
"function claimTokensByAdmin ( address _target ) onlyAdmin ( 1 ) public { require ( KYCValid [ _target ] == true ) ; uint256 tokens = balance [ _target ] ; balance [ _target ] = 0 ; require ( tokenReward . transfer ( _target , tokens ) ) ; tokensSent [ _target ] = tokensSent [ _target ] . add ( tokens ) ; emit LogContributorsPayout ( _target , tokens ) ; }
","function to let admin claim tokens on behalf users
"
"function addWhitelistMember ( address [ ] _mem , uint [ ] _tokens ) public onlyAdmin { require ( _mem . length == _tokens . length ) ; for ( uint i = 0 ; i < _mem . length ; i ++ ) { whitelistTokens = whitelistTokens . sub ( whitemap [ _mem [ i ] ] ) . add ( _tokens [ i ] ) ; whitemap [ _mem [ i ] ] = _tokens [ i ] ; } }
","addWhitelistMember is used to whitelist participant .
"
"function _preValidatePurchase ( address _beneficiary , uint256 _investedAmount ) internal view { require ( _beneficiary != address ( 0 ) , ""Beneficiary address should not be 0x"" ) ; require ( _investedAmount != 0 , ""Amount invested should not be equal to 0"" ) ; require ( tokensSold . add ( _getTokenAmount ( _investedAmount ) ) <= cap , ""Investment more than cap is not allowed"" ) ; require ( now >= startTime && now <= endTime , ""Offering is closed/Not yet started"" ) ; }
","Validation of an incoming purchase .
"
"function arbitrateCancelCampaign ( ) onlyArbitrator campaignNotCanceled { campaignCanceled = true ; CampaignCanceled ( ) ; }
","` onlyArbitrator ` Cancels the entire campaign voiding all milestones vo
"
"function getMobster ( uint256 _tokenId ) public view returns ( uint256 id , string name , uint256 boss , uint256 sellingPrice , address owner , uint256 state , uint256 dazedExipryTime , uint256 buyPrice , uint256 nextPrice ) { id = _tokenId ; Mobster storage mobster = mobsters [ _tokenId ] ; name = mobster . name ; boss = mobster . boss ; sellingPrice = mobsterIndexToPrice [ _tokenId ] ; owner = mobsterIndexToOwner [ _tokenId ] ; state = mobster . state ; if ( mobster . state == 1 && now > mobster . dazedExipryTime ) { state = 0 ; } dazedExipryTime = mobster . dazedExipryTime ; buyPrice = mobster . buyPrice ; nextPrice = calculateNewPrice ( _tokenId ) ; }
","Returns all the relevant information about a specific mobster .
"
"function distributeAirdrop ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( airdrop . countDown <= now ) { for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( ""Distribution Failed: Count Down not gone yet"" ) ; }
","Distirbutes a differen quantity of tokens to all the specified addresses .
"
"function calculateWithdrawable ( ) constant returns ( uint withdrawable ) { uint timePassed = now . sub ( vestingStartTime ) ; if ( timePassed < vestingPeriod ) { uint vested = totalVestedAmount . mul ( timePassed ) . div ( vestingPeriod ) ; withdrawable = vested . sub ( withdrawnMelon ( ) ) ; } else { withdrawable = totalVestedAmount . sub ( withdrawnMelon ( ) ) ; } }
","Calculates the quantity of Melon asset that 's currently withdrawable
"
"function mDestroyTokens ( address owner , uint256 amount ) internal { require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= amount ) ; uint256 previousBalanceFrom = balanceOf ( owner ) ; require ( previousBalanceFrom >= amount ) ; uint256 newTotalSupply = curTotalSupply - amount ; uint256 newBalanceFrom = previousBalanceFrom - amount ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceFrom ) ; emit Transfer ( owner , 0 , amount ) ; }
","Burns ` amount ` tokens from ` owner `
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) onlyNonZeroAddress ( _to ) canTransfer ( _tokenId ) ownerExists ( _tokenId ) external { address tokenOwner = nft [ _tokenId ] . owner ; require ( tokenOwner == _from , ""from address must be owner of tokenId"" ) ; _transfer ( _to , _tokenId ) ; }
","The caller is responsible to confirm that ` _to ` is capable of receiving NFTs or else they maybe be permanently lost .
"
"function getVersion ( ) external view returns ( uint8 [ ] ) { uint8 [ ] memory _version = new uint8 [ ] ( 3 ) ; _version [ 0 ] = securityTokenVersion . major ; _version [ 1 ] = securityTokenVersion . minor ; _version [ 2 ] = securityTokenVersion . patch ; return _version ; }
","Returns the version of the SecurityToken
"
"function claimEther ( ) public onlyOwner { require ( tokensSold >= goal ) ; if ( address ( this ) . balance > 0 ) { owner . transfer ( address ( this ) . balance ) ; } }
","Claim collected ether without closing crowdsale
"
"function execScript ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { require ( _blacklist . length == 0 ) ; bytes32 id = keccak256 ( _script ) ; address deployed = cache [ id ] ; if ( deployed == address ( 0 ) ) { deployed = deploy ( _script ) ; cache [ id ] = deployed ; } return DelegateScript . delegate ( deployed , _input ) ; }
","Executes script by delegatecall into a deployed contract ( exec ( ) function )
"
"function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return erc20Impl . balanceOf ( _owner ) ; }
","Returns the account balance of another account with address ` _owner ` .
"
"function setQuestionFee ( uint256 fee ) stateAny ( ) external { arbitrator_question_fees [ msg . sender ] = fee ; LogSetQuestionFee ( msg . sender , fee ) ; }
","Function for arbitrator to set an optional per-question fee .
"
"function claimTokens ( address _token , address _to ) public onlyDonationAddress { require ( _to != address ( 0 ) , ""Wallet format error"" ) ; if ( _token == address ( 0 ) ) { _to . transfer ( address ( this ) . balance ) ; return ; } ERC20Basic token = ERC20Basic ( _token ) ; uint256 balance = token . balanceOf ( this ) ; require ( token . transfer ( _to , balance ) , ""Token transfer unsuccessful"" ) ; }
","The ` claimTokens ( ) ` should only be called after donation ends or if a security issue is found .
"
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { }
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; require ( block . number <= _validUntil ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned transfer
"
"function setTradeEventEnabled ( bool enabled ) external onlyOwner { tradeEventEnabled = enabled ; }
","set tradeEventEnabled , only owner
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( totalDistributed == hardCap && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else if ( state == State . PreSale && PreSaleDistributed >= PreSaleLimit ) { state = State . MainSale ; } }
","check status
"
"function proxyMintTokens ( address _owner , uint _amount , bytes32 _paidTxID ) public returns ( bool ) ;
","Called when ` _owner ` sends ether to the MiniMe Token contract
"
"function ( ) external payable { FundsReceived ( msg . sender , msg . value ) ; }
","Fallback fn for receiving ether
"
"function transferWithData ( address _to , uint256 _value , bytes _data ) external returns ( bool success ) ;
","Overloaded version of the transfer function
"
"function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { return true ; }
","Perform exchange-specific checks on the given order
"
"function migrateByAdmin_DQV ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 2 ] ; address token = tokenId2Address [ ( data & WITHDRAW_TOKEN_MASK ) >> 32 ] ; address newContract = address ( inputs [ 0 ] ) ; for ( uint256 i = 1 ; i < inputs . length ; i += 4 ) { uint256 gasFee = inputs [ i ] ; data = inputs [ i + 1 ] ; address user = userId2Address [ data & USER_MASK ] ; bytes32 hash = keccak256 ( this , gasFee , data & SIGN_MASK | uint256 ( token ) , newContract ) ; require ( verify ( hash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ i + 2 ] ) , bytes32 ( inputs [ i + 3 ] ) ) ) ; if ( gasFee > 0 ) { uint256 paymentMethod = data & PAYMENT_METHOD_MASK ; if ( paymentMethod == PAY_BY_JOY ) { balances [ joyToken ] [ user ] = balances [ joyToken ] [ user ] . sub ( gasFee ) ; balances [ joyToken ] [ joysoWallet ] = balances [ joyToken ] [ joysoWallet ] . add ( gasFee ) ; } else if ( paymentMethod == PAY_BY_TOKEN ) { balances [ token ] [ user ] = balances [ token ] [ user ] . sub ( gasFee ) ; balances [ token ] [ joysoWallet ] = balances [ token ] [ joysoWallet ] . add ( gasFee ) ; } else { balances [ 0 ] [ user ] = balances [ 0 ] [ user ] . sub ( gasFee ) ; balances [ 0 ] [ joysoWallet ] = balances [ 0 ] [ joysoWallet ] . add ( gasFee ) ; } } uint256 amount = balances [ token ] [ user ] ; balances [ token ] [ user ] = 0 ; if ( token == 0 ) { Migratable ( newContract ) . migrate . value ( amount ) ( user , amount , token ) ; } else { ERC20 ( token ) . approve ( newContract , amount ) ; Migratable ( newContract ) . migrate ( user , amount , token ) ; } } }
","batch send the current balance to the new version contract
"
"function calculateTimeout ( ) public view returns ( uint256 ) { if ( wagerIndex >= numberOfWagersToFinalTimeout || numberOfWagersToFinalTimeout == 0 ) { return finalTimeout ; } else { if ( finalTimeout <= timeout ) { uint256 difference = timeout - finalTimeout ; uint256 decrease = difference . mul ( wagerIndex ) . div ( numberOfWagersToFinalTimeout ) ; return ( timeout - decrease ) ; } else { difference = finalTimeout - timeout ; uint256 increase = difference . mul ( wagerIndex ) . div ( numberOfWagersToFinalTimeout ) ; return ( timeout + increase ) ; } } }
","Calculate the current game 's timeout .
"
"function getVoteAtTxForUser ( bytes32 _txKey , address _user ) public view returns ( bytes32 _groupName , bool _accepted ) { if ( txKey2index [ _txKey ] == 0 ) { return ; } Guard storage _guard = txKey2guard [ _txKey ] ; Vote memory _vote = _guard . votes [ _user ] ; ( _groupName , _accepted ) = ( _vote . groupName , _vote . accepted ) ; }
","Get singe decision vote of a user for a tx
"
"function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; sellCommission = msg . value / 1000 ; require ( address ( this ) . send ( buyCommission ) ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; require ( this . balance >= revenue ) ; msg . sender . transfer ( revenue ) ; }
","Sell tokens and receive ether from contract
"
"function approveShutdown ( uint ofVersionId ) { confirm ( versionIdToShutdownIds [ ofVersionId ] ) ; }
","Approve shutdown of Melon version
"
"function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) { return competitionAddress == ofParticipant ; }
","Checks whether investment is permitted for a participant
"
"function _supportMarket ( address asset , InterestRateModel interestRateModel ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SUPPORT_MARKET_OWNER_CHECK ) ; } ( Error err , Exp memory assetPrice ) = fetchAssetPrice ( asset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . SUPPORT_MARKET_FETCH_PRICE_FAILED ) ; } if ( isZeroExp ( assetPrice ) ) { return fail ( Error . ASSET_NOT_PRICED , FailureInfo . SUPPORT_MARKET_PRICE_CHECK ) ; } markets [ asset ] . interestRateModel = interestRateModel ; addCollateralMarket ( asset ) ; markets [ asset ] . isSupported = true ; if ( markets [ asset ] . supplyIndex == 0 ) { markets [ asset ] . supplyIndex = initialInterestIndex ; } if ( markets [ asset ] . borrowIndex == 0 ) { markets [ asset ] . borrowIndex = initialInterestIndex ; } emit SupportedMarket ( asset , interestRateModel ) ; return uint ( Error . NO_ERROR ) ; }
","Supports a given market ( asset ) for use with Compound
"
"function proxyPayment ( address _owner ) payable public returns ( bool ) { revert ( ) ; }
","No eth payment to the token contract
"
"function initialize ( Vault _vault , uint64 _periodDuration ) external onlyInit { initialized ( ) ; require ( isContract ( _vault ) , ERROR_VAULT_NOT_CONTRACT ) ; vault = _vault ; require ( _periodDuration >= 1 days , ERROR_INIT_PERIOD_TOO_SHORT ) ; settings . periodDuration = _periodDuration ; payments [ 0 ] . inactive = true ; paymentsNextIndex = 1 ; transactionsNextIndex = 1 ; _newPeriod ( getTimestamp64 ( ) ) ; }
","Initialize Finance app for Vault at ` _vault ` with period length of ` @ transformTime ( _periodDuration ) `
"
"function setLoyaltyRewardAmount ( uint256 newLoyaltyRewardAmount ) public onlyOwner { require ( newLoyaltyRewardAmount >= 0 && newLoyaltyRewardAmount <= 100 , ""Loyalty reward amount must be between 0 and 100."" ) ; uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days ; for ( uint256 i = 0 ; i < membersArray . length ; i ++ ) { Member storage thisMember = members [ membersArray [ i ] ] ; uint256 elapsedTimeSinceEligible = block . timestamp - thisMember . startOfLoyaltyRewardEligibility ; if ( elapsedTimeSinceEligible >= loyaltyPeriodSeconds ) { uint256 numWholePeriods = SafeMath . div ( elapsedTimeSinceEligible , loyaltyPeriodSeconds ) ; uint256 rewardForEachPeriod = thisMember . stakeBalance * loyaltyRewardAmount / 100 ; thisMember . previouslyAppliedLoyaltyBalance += rewardForEachPeriod * numWholePeriods ; thisMember . startOfLoyaltyRewardEligibility += numWholePeriods * loyaltyPeriodSeconds ; } } loyaltyRewardAmount = newLoyaltyRewardAmount ; emit LoyaltyRewardChanged ( newLoyaltyRewardAmount ) ; }
","The loyalty reward amount is actually a rate from 0 to 100 that is used to calculate the proportion of stake balance that should be rewarded .
"
"function getPrice ( address ofAsset ) view returns ( uint price , uint timestamp ) { Data data = assetsToPrices [ ofAsset ] ; return ( data . price , data . timestamp ) ; }
","Gets price of an asset multiplied by ten to the power of assetDecimals
"
"function placeNewBet ( uint gameId , GameResults result ) public whenGameIsOpen ( gameId ) payable { if ( msg . value >= minimumBetAmount ) { uint betId = bets . push ( Bet ( gameId , result , msg . value , false ) ) - 1 ; betToAddress [ betId ] = msg . sender ; addressToBets [ msg . sender ] . push ( betId ) ; games [ gameId ] . bettorsCount = games [ gameId ] . bettorsCount . add ( 1 ) ; if ( result == GameResults . TeamA ) { games [ gameId ] . amountToTeamA = games [ gameId ] . amountToTeamA . add ( msg . value ) ; } else if ( result == GameResults . Draw ) { games [ gameId ] . amountToDraw = games [ gameId ] . amountToDraw . add ( msg . value ) ; } else if ( result == GameResults . TeamB ) { games [ gameId ] . amountToTeamB = games [ gameId ] . amountToTeamB . add ( msg . value ) ; } emit NewBetPlaced ( gameId , result , msg . value ) ; } }
","Place a new bet
"
"function validateAttestForSig ( address _subject , address _attester , address _requester , uint256 _reward , bytes32 _dataHash , bytes32 _requestNonce , bytes _delegationSig ) private { bytes32 _delegationDigest = generateAttestForDelegationSchemaHash ( _subject , _requester , _reward , _dataHash , _requestNonce ) ; require ( _attester == recoverSigner ( _delegationDigest , _delegationSig ) , 'Invalid AttestFor Signature' ) ; burnSignatureDigest ( _delegationDigest , _attester ) ; }
","Verify attester delegation signature is valid
"
"function initialiseMultisig ( address authority , uint unlockTime ) public payable returns ( bytes32 msigId ) { require ( msg . sender != authority ) ; require ( msg . value > 0 ) ; msigId = keccak256 ( msg . sender , authority , msg . value , unlockTime ) ; emit MultisigInitialised ( msigId ) ; Multisig storage multisig = multisigs [ msigId ] ; if ( multisig . deposit == 0 ) { multisig . owner = msg . sender ; multisig . authority = authority ; } reparametrizeMultisig ( msigId , unlockTime ) ; }
","Initialise and reparametrize Multisig
"
"function processProposal ( bytes32 _propID ) public { ParamProposal storage prop = proposals [ _propID ] ; address propOwner = prop . owner ; uint propDeposit = prop . deposit ; if ( canBeSet ( _propID ) ) { set ( prop . name , prop . value ) ; emit _ProposalAccepted ( _propID , prop . name , prop . value ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else if ( challengeCanBeResolved ( _propID ) ) { resolveChallenge ( _propID ) ; } else if ( now > prop . processBy ) { emit _ProposalExpired ( _propID ) ; delete proposals [ _propID ] ; require ( token . transfer ( propOwner , propDeposit ) ) ; } else { revert ( ) ; } assert ( get ( ""dispensationPct"" ) <= 100 ) ; assert ( get ( ""pDispensationPct"" ) <= 100 ) ; now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) ; delete proposals [ _propID ] ; }
","for the provided proposal ID , set it , resolve its challenge , or delete it depending on whether it can be set , has a challenge which can be resolved , or if its `` process by '' date has passed
"
"function multiExecute ( address [ ] sellers , uint256 lastQuantity ) public payable returns ( uint256 totalVouchers ) { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; totalVouchers = 0 ; for ( uint i = 0 ; i < sellers . length ; i ++ ) { TradeOrder memory to = orderBook [ sellers [ i ] ] ; if ( i == sellers . length - 1 ) { execute ( sellers [ i ] , lastQuantity , to . price ) ; totalVouchers += lastQuantity ; } else { execute ( sellers [ i ] , to . quantity , to . price ) ; totalVouchers += to . quantity ; } } return totalVouchers ; }
","Buy from multiple sellers at once to fill a single large order .
"
"function sponsorDAI ( uint _JobID , uint _amount ) public { require ( _JobID >= 0 ) ; require ( _amount > 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( job . sponsors [ msg . sender ] == 0 ) { job . sponsorList . push ( msg . sender ) ; } job . sponsors [ msg . sender ] = job . sponsors [ msg . sender ] + _amount ; job . sponsoredTokens = job . sponsoredTokens + _amount ; emit DAISponsored ( _JobID , _amount , msg . sender ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _amount ) ; DAI . transferFrom ( msg . sender , address ( this ) , _amount ) ; }
","this function lets any registered address send DAI tokens to any Job as sponsored tokens
"
"function removeContract ( string _contractName ) external onlyContractOwner ( ""ContractManager"" , msg . sender ) { bytes memory contractNameBytes = bytes ( _contractName ) ; require ( contractNameBytes . length != 0 ) ; require ( keccak256 ( _contractName ) != keccak256 ( ""ContractManager"" ) ) ; require ( contracts [ _contractName ] != address ( 0 ) ) ; delete contracts [ _contractName ] ; emit ContractRemoved ( _contractName ) ; }
","Remove an existing contract
"
"function deposit ( uint256 amount ) returns ( bool ) { bool success ; uint256 balance ; ( success , balance ) = data . deposit ( amount ) ; if ( success == true ) { ChannelNewBalance ( data . manager . token ( ) , msg . sender , balance , 0 ) ; } return success ; }
","Caller makes a deposit into their channel balance .
"
"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public { require ( isOperatorFor ( msg . sender , _from ) ) ; doSend ( msg . sender , _from , _to , _amount , _userData , _operatorData , true ) ; }
","Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
"
"function setReferral ( address _target , address _broker , uint256 _amount ) onlyOwner public { require ( _target != 0x0 ) ; require ( _broker != 0x0 ) ; referrals [ _target ] = _broker ; emit SetReferral ( _target , _broker ) ; if ( _amount > 0x0 ) { uint256 brokerBonus = safeDiv ( safeMul ( _amount , referralBonus ) , hundredPercent ) ; bonus [ _broker ] = safeAdd ( bonus [ _broker ] , brokerBonus ) ; emit ReferralBonus ( _target , _broker , brokerBonus ) ; } }
","set Broker for Investor
"
"function setDefaultFee ( uint256 _newFee ) public onlyOwner whenNotPaused { tokenStorage_CD . setDefaultFee ( _newFee ) ; }
","Change the default fee associated with going from CarbonUSD to a WhitelistedToken .
"
"function setCoordinator ( address _coordinator ) external onlyOwner { _validateAddress ( _coordinator ) ; coordinator = _coordinator ; }
","Sets the coordinator address .
"
"function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public { _extraData ; require ( _token == holdingToken ) ; ERC20 ( holdingToken ) . transferFrom ( _from , address ( this ) , _value ) ; totalReceived = totalReceived . add ( _value ) ; }
","Method what should be called with external contract to receive tokens
"
"function setDefaultFee ( uint256 _fee ) public onlyOwner { uint256 oldFee = defaultFee ; defaultFee = _fee ; if ( oldFee != defaultFee ) emit DefaultFeeChanged ( oldFee , _fee ) ; }
","Sets the default fee for burning CarbonDollar into a whitelisted stablecoin .
"
"function _supportsERC165 ( address account ) internal view returns ( bool ) { return _supportsERC165Interface ( account , _InterfaceId_ERC165 ) && ! _supportsERC165Interface ( account , _InterfaceId_Invalid ) ; }
","Query if a contract supports ERC165
"
"function tokenURI ( uint256 _tokenId ) external view returns ( string ) { require ( _exists ( _tokenId ) ) ; return _tokenURIs [ _tokenId ] ; }
","A distinct Uniform Resource Identifier ( URI ) for a given asset .
"
"function countOfDeeds ( ) public view returns ( uint256 ) { return identifiers . length ; }
","Returns the total number of deeds currently in existence .
"
"function iterateInvestors ( uint256 _start , uint256 _end ) external view returns ( address [ ] ) { require ( _end <= investorData . investors . length , ""Invalid end"" ) ; address [ ] memory investors = new address [ ] ( _end . sub ( _start ) ) ; uint256 index = 0 ; for ( uint256 i = _start ; i < _end ; i ++ ) { investors [ index ] = investorData . investors [ i ] ; index ++ ; } return investors ; }
","generates subset of investors NB - can be used in batches if investor list is large
"
"function destroy ( address [ ] _tokens ) public onlyOwner { for ( uint256 i = 0 ; i < _tokens . length ; i ++ ) { ERC20Basic token = ERC20Basic ( _tokens [ i ] ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }
","The called token contracts could try to re-enter this contract .
"
"function ( ) public payable whenNotPaused { uint256 size ; address sender = msg . sender ; assembly { size := extcodesize ( sender ) } if ( size == 0 ) { errorReporter . revertTx ( ""EOA cannot send ether to primary fallback"" ) ; } }
","payable fallback to allow handler or exchange contracts to return ether
"
"function exchangeEtherForSynths ( ) public payable pricesNotStale notPaused returns ( uint ) { uint ethToSend ; uint requestedToPurchase = msg . value . multiplyDecimal ( usdToEthPrice ) ; uint remainingToFulfill = requestedToPurchase ; for ( uint i = depositStartIndex ; remainingToFulfill > 0 && i < depositEndIndex ; i ++ ) { synthDeposit memory deposit = deposits [ i ] ; if ( deposit . user == address ( 0 ) ) { depositStartIndex = depositStartIndex . add ( 1 ) ; } else { if ( deposit . amount > remainingToFulfill ) { deposit . amount = deposit . amount . sub ( remainingToFulfill ) ; totalSellableDeposits = totalSellableDeposits . sub ( remainingToFulfill ) ; ethToSend = remainingToFulfill . divideDecimal ( usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } else { emit ClearedDeposit ( msg . sender , deposit . user , ethToSend , remainingToFulfill , i ) ; } synth . transfer ( msg . sender , remainingToFulfill ) ; remainingToFulfill = 0 ; } else if ( deposit . amount <= remainingToFulfill ) { delete deposits [ i ] ; depositStartIndex = depositStartIndex . add ( 1 ) ; totalSellableDeposits = totalSellableDeposits . sub ( deposit . amount ) ; ethToSend = deposit . amount . divideDecimal ( usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } else { emit ClearedDeposit ( msg . sender , deposit . user , ethToSend , deposit . amount , i ) ; } synth . transfer ( msg . sender , deposit . amount ) ; remainingToFulfill = remainingToFulfill . sub ( deposit . amount ) ; } } } if ( remainingToFulfill > 0 ) { msg . sender . transfer ( remainingToFulfill . divideDecimal ( usdToEthPrice ) ) ; } uint fulfilled = requestedToPurchase . sub ( remainingToFulfill ) ; if ( fulfilled > 0 ) { emit Exchange ( ""ETH"" , msg . value , ""sUSD"" , fulfilled ) ; } return fulfilled ; }
","Exchange ETH to sUSD .
"
"function proxyTransferFromWithReference ( address _from , address _to , uint _value , bytes32 _symbol , string _reference , address _sender ) public onlyProxy ( _symbol ) onlyAfterBlock ( _symbol ) returns ( uint ) { TransactionContext memory txContext ; txContext . sender = _sender ; txContext . to = _to ; txContext . from = _from ; txContext . toHolderId = _createHolderId ( _to ) ; txContext . fromHolderId = getHolderId ( _from ) ; txContext . senderHolderId = _to == _sender ? txContext . toHolderId : getHolderId ( _sender ) ; return _transfer ( _value , _symbol , _reference , txContext ) ; }
","Performs allowance transfer of asset balance between holders wallets .
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { require ( ! tokenFrozen ) ; tokenRecipient spender = tokenRecipient ( _spender ) ; approve ( _spender , _value ) ; spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; }
","` msg.sender ` approves ` _spender ` to send ` _value ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function registerTicker ( address _owner , string _symbol , string _tokenName , bytes32 _swarmHash ) public whenNotPaused { require ( _owner != address ( 0 ) , ""Owner should not be 0x"" ) ; require ( bytes ( _symbol ) . length > 0 && bytes ( _symbol ) . length <= 10 , ""Ticker length should always between 0 & 10"" ) ; if ( registrationFee > 0 ) require ( ERC20 ( polyToken ) . transferFrom ( msg . sender , this , registrationFee ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; string memory symbol = upper ( _symbol ) ; require ( expiryCheck ( symbol ) , ""Ticker is already reserved"" ) ; registeredSymbols [ symbol ] = SymbolDetails ( _owner , now , _tokenName , _swarmHash , false ) ; emit LogRegisterTicker ( _owner , symbol , _tokenName , _swarmHash , now ) ; }
","its ownership .
"
"function ( ) payable { uint amount ; amount = msg . value ; require ( beneficiary . proxyPayment . value ( amount ) ( msg . sender ) ) ; FundsSent ( msg . sender , amount ) ; }
","Directly forward Eth to ` beneficiary ` .
"
"function releaseTprFund ( ) public { require ( now >= tprFundReleaseTime ) ; require ( ! tprFundUnlocked ) ; balances [ tprFundDeposit ] = tprFund ; Transfer ( 0 , tprFundDeposit , tprFund ) ; tprFundUnlocked = true ; }
","Transfers tokens held by timelock to beneficiary .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) public { require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _to != address ( 0 ) ) ; _transfer ( _from , _to , _tokenId ) ; }
","Transfer a narco owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function createGroup ( bytes32 _groupName , uint _priority ) external onlyContractOwner returns ( uint ) { require ( _groupName != bytes32 ( 0 ) ) ; if ( isGroupExists ( _groupName ) ) { return _emitError ( USER_MANAGER_GROUP_ALREADY_EXIST ) ; } uint _groupsCount = groupsCount . add ( 1 ) ; groupName2index [ _groupName ] = _groupsCount ; index2groupName [ _groupsCount ] = _groupName ; groupName2group [ _groupName ] = Group ( _groupName , _priority , 0 ) ; groupsCount = _groupsCount ; GroupCreated ( _groupName ) ; return OK ; }
","Create group Can be called only by contract owner
"
"function isRefundable ( address _darknodeID ) public view returns ( bool ) { return isDeregistered ( _darknodeID ) && store . darknodeDeregisteredAt ( _darknodeID ) <= previousEpoch . blocknumber ; }
","Returns if a darknode is refundable .
"
"function getInstructions ( ) external view returns ( string ) { return ""Allows an issuer to restrict the total number of non-zero token holders"" ; }
","Returns the instructions associated with the module
"
"function depositERC20 ( address _user , address _token , uint256 _amount ) external onlyCoordinator onlyActiveState { require ( _amount > 0 , 'Invalid value' ) ; balances [ _user ] [ _token ] = balances [ _user ] [ _token ] . add ( _amount ) ; _validateIsContract ( _token ) ; require ( _token . call ( bytes4 ( keccak256 ( ""transferFrom(address,address,uint256)"" ) ) , _user , address ( this ) , _amount ) , ""transferFrom call failed"" ) ; require ( _getSanitizedReturnValue ( ) , ""transferFrom failed."" ) ; emit BalanceIncrease ( _user , _token , _amount , ReasonDeposit ) ; }
","Deposits ERC20 tokens under the ` _user ` 's balance
"
"function getDate ( uint32 _timestamp ) internal pure returns ( uint32 ) { return _timestamp . sub ( _timestamp % DAY ) ; }
","Does n't change state
"
"function getStakeCount ( address _staker ) internal view returns ( uint256 ) { return numberOfStakes [ _staker ] ; }
","This is a helper function used to get the total number of stakes a
"
"function totalSupplyAt ( uint _blockNumber ) public view returns ( uint ) ;
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function depositAndTransfer ( address depositTo , address transferTo , uint256 depositAmount , uint256 transferAmount , bytes data , bytes32 reference ) public returns ( bool success ) { deposit ( depositTo , depositAmount , reference ) ; return ierc223TransferInternal ( depositTo , transferTo , transferAmount , data ) ; }
","convenience function to deposit and immediately transfer amount
"
"function spendFromMultisig ( bytes32 msigId , uint amount , address recipient ) internal { require ( amount <= hashIdToMultisig [ msigId ] . deposit ) ; hashIdToMultisig [ msigId ] . deposit -= amount ; if ( hashIdToMultisig [ msigId ] . deposit == 0 ) { delete hashIdToMultisig [ msigId ] ; assert ( hashIdToMultisig [ msigId ] . deposit == 0 ) ; } recipient . transfer ( amount ) ; }
","Send ether out of this contract to multisig owner and update or delete entry in multisig mapping
"
"function getCampaignBudgetById ( bytes32 bidId ) public view returns ( uint budget ) { return campaigns [ bidId ] . getBudget ( ) ; }
","Get the budget avaliable of a campaign Based on the Campaign id , return the total value avaliable to pay for proofs of attention .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( frozen [ msg . sender ] == false ) ; require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","transfer _value tokens to address _to
"
"function hasStarted ( ) public constant returns ( bool ) { return now > startTime ; }
","Public function to check if the crowdsale has started or not
"
"function _freezeAccount ( address target , bool freeze ) internal { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }
","` freeze ?
"
"function validateContentHash ( address _student , uint _docIndx , bytes32 _contentHash ) public view returns ( bool ) { Certification storage certification = studentCertifications [ _student ] ; return ( certification . documents [ _docIndx ] ) . validateContentHash ( _contentHash ) ; }
","Validate Content Hash alone of a student
"
"function transferFrom ( address from , address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; uint fees = calculateFees ( amount ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( from ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( to ) ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( feeContract ) ) ) ; require ( lib . Storage . setUint ( id_a , lib . Storage . getUint ( id_a ) . sub ( amount . add ( fees ) ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( lib . Storage . setUint ( id_b , lib . Storage . getUint ( id_b ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( lib . Storage . setUint ( id_c , lib . Storage . getUint ( id_c ) . add ( fees ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( lib . updateAllowance ( lib . getTokenSymbol ( address ( this ) ) , from , amount . add ( fees ) ) , ""Error: Unable to update allowance for spender."" ) ; emit Transfer ( from , to , amount ) ; return true ; }
","spender transfers from approvers account to the reciving account
"
"function setRequiredTotal ( uint256 _requiredTotal ) external onlyOwner returns ( bool ) { emit SetRequiredTotal ( requiredTotal , _requiredTotal ) ; requiredTotal = _requiredTotal ; return true ; }
","Sets required total of the mortgage
"
"function collectTokens ( ) public onlyOwner { uint256 balance = wrp . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) >= finalizedTime . add ( months ( 3 ) ) ) ; uint256 canExtract = total . mul ( getTime ( ) . sub ( finalizedTime ) ) . div ( months ( 36 ) ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; assert ( wrp . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }
","The Dev ( Owner ) will call this method to extract the tokens
"
"function getAmountToGive_ ( OrderData data ) public view onlySelf returns ( uint256 amountToGive ) { LibOrder . OrderInfo memory orderInfo = exchange . getOrderInfo ( getZeroExOrder ( data ) ) ; uint makerAssetAvailable = getAssetDataAvailable ( data . makerAssetData , data . makerAddress ) ; uint feeAssetAvailable = getAssetDataAvailable ( ZRX_ASSET_DATA , data . makerAddress ) ; uint maxFromMakerFee = data . makerFee == 0 ? Utils . max_uint ( ) : getPartialAmount ( feeAssetAvailable , data . makerFee , data . takerAssetAmount ) ; amountToGive = Math . min ( Math . min ( getPartialAmount ( makerAssetAvailable , data . makerAssetAmount , data . takerAssetAmount ) , maxFromMakerFee ) , SafeMath . sub ( data . takerAssetAmount , orderInfo . orderTakerAssetFilledAmount ) ) ; }
","Gets the amount that Totle needs to give for this order
"
"function unlock ( ) external { if ( getTime ( ) < unlockedAtTime ) throw ; if ( ! decentBetToken . transfer ( decentBetMultisig , decentBetToken . balanceOf ( this ) ) ) throw ; }
","Transfer locked tokens to Decent.bet 's multisig wallet
"
"function destroyTokens ( address _user , uint _amount ) onlyOwner public returns ( bool ) { balanceOf [ owner ] += _amount ; balanceOf [ _user ] -= _amount ; Transfer ( _user , 0 , _amount ) ; Burn ( _user , _amount ) ; return true ; }
","Burns ` _amount ` tokens from ` _owner `
"
"function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 7911000000 ; }
","maximum investments to be accepted during the sale ( in euro-cents )
"
"function _release ( address beneficiary ) internal { Info storage info = _info [ beneficiary ] ; if ( block . timestamp >= info . releaseTime ) { uint256 remainingTokens = info . totalAmount . sub ( info . receivedAmount ) ; require ( remainingTokens > 0 , ""No tokens left to take out."" ) ; info . receivedAmount = info . totalAmount ; _token . safeTransfer ( beneficiary , remainingTokens ) ; } else if ( block . timestamp > info . startTime ) { uint256 diff = info . releaseTime . sub ( info . startTime ) ; uint256 tokensPerTick = info . totalAmount . div ( diff ) ; uint256 ticks = block . timestamp . sub ( info . startTime ) ; uint256 tokens = tokensPerTick . mul ( ticks ) ; uint256 receivableTokens = tokens . sub ( info . receivedAmount ) ; require ( receivableTokens > 0 , ""No tokens to take out right now."" ) ; info . receivedAmount = info . receivedAmount . add ( receivableTokens ) ; _token . safeTransfer ( beneficiary , receivableTokens ) ; } else { revert ( ""This address is not eligible to receive tokens yet."" ) ; } }
","Internal function to release tokens to a beneficiary .
"
"function initialize ( AttributeRegistryInterface registry , uint256 validAttributeTypeID ) public initializer { _registry = AttributeRegistryInterface ( registry ) ; _validAttributeTypeID = validAttributeTypeID ; }
","The initializer function , with an associated attribute registry at ` registry ` and an assignable attribute type with ID ` validAttributeTypeID ` .
"
"function unpause ( ) public onlyCEO whenPaused { paused = false ; emit Unpaused ( ) ; }
","called by the CEO to unpause , returns to normal state
"
"function buyTokens ( address _beneficiary ) public payable { }
","Function calls other functions to calculate tokenamount to send to beneficiary .
"
"function setMigrationAgent ( address _agent ) external { if ( funding ) throw ; if ( migrationAgent != 0 ) throw ; if ( msg . sender != migrationMaster ) throw ; migrationAgent = _agent ; }
","Set address of migration target contract and enable migration process .
"
"function redeem ( uint256 baseUnits , address [ ] tokensToSkip ) external requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( baseUnits <= totalSupply_ ) ; require ( baseUnits <= balances [ msg . sender ] ) ; require ( tokensToSkip . length <= tokens . length ) ; burn ( msg . sender , baseUnits ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 index ; bool ok ; ( index , ok ) = tokensToSkip . index ( token . addr ) ; if ( ok ) { continue ; } uint256 amount = baseUnits . div ( creationUnit ) . mul ( token . quantity ) ; require ( erc20 . transfer ( msg . sender , amount ) ) ; } emit Redeem ( msg . sender , baseUnits , tokensToSkip ) ; }
","Redeems Bskt tokens in exchange for underlying tokens
"
"function transfer ( address _to , uint256 _value ) public payloadSizeIs ( 2 * 32 ) returns ( bool ) { thawSomeTokens ( msg . sender , _value ) ; return super . transfer ( _to , _value ) ; }
","Standard transfer ( ) overridden to have a chance to thaw sender 's tokens .
"
"function creationUnit ( ) external view returns ( uint256 ) { return creationUnit_ ; }
","Returns the creationUnit
"
"function setPOLYUSD ( uint256 _price ) onlyOwner public { emit LogPriceUpdated ( _price , POLYUSD , now ) ; POLYUSD = _price ; latestUpdate = now ; }
","Allows owner to manually set POLYUSD price
"
"function listPairForReserve ( address reserve , ERC20 token , bool ethToToken , bool tokenToEth , bool add ) public onlyAdmin { require ( isReserve [ reserve ] ) ; if ( ethToToken ) { listPairs ( reserve , token , false , add ) ; ListReservePairs ( reserve , ETH_TOKEN_ADDRESS , token , add ) ; } if ( tokenToEth ) { listPairs ( reserve , token , true , add ) ; if ( add ) { token . approve ( reserve , 2 ** 255 ) ; } else { token . approve ( reserve , 0 ) ; } ListReservePairs ( reserve , token , ETH_TOKEN_ADDRESS , add ) ; } setDecimals ( token ) ; }
","can be called only by admin
"
"function setInvestorMigrationWallet ( address destinationWallet ) public { Destination [ ] storage destinations = _destinations [ msg . sender ] ; if ( destinations . length > 0 ) { delete _destinations [ msg . sender ] ; } addDestination ( destinations , destinationWallet , 0 ) ; }
","changes migration destination for msg.sender
"
"function roundMoneyDownNicely ( uint _rawValueWei ) constant internal returns ( uint nicerValueWei ) { if ( _rawValueWei < 1 finney ) { return _rawValueWei ; } else if ( _rawValueWei < 10 finney ) { return 10 szabo * ( _rawValueWei / 10 szabo ) ; } else if ( _rawValueWei < 100 finney ) { return 100 szabo * ( _rawValueWei / 100 szabo ) ; } else if ( _rawValueWei < 1 ether ) { return 1 finney * ( _rawValueWei / 1 finney ) ; } else if ( _rawValueWei < 10 ether ) { return 10 finney * ( _rawValueWei / 10 finney ) ; } else if ( _rawValueWei < 100 ether ) { return 100 finney * ( _rawValueWei / 100 finney ) ; } else if ( _rawValueWei < 1000 ether ) { return 1 ether * ( _rawValueWei / 1 ether ) ; } else if ( _rawValueWei < 10000 ether ) { return 10 ether * ( _rawValueWei / 10 ether ) ; } else { return _rawValueWei ; } }
","Make ` _rawValueWei ` into a nicer , rounder number .
"
"function redeem ( uint256 baseUnitsToRedeem , address [ ] tokensToSkip ) external whenNotPaused ( ) requireNonZero ( baseUnitsToRedeem ) requireMultiple ( baseUnitsToRedeem ) { require ( ( totalSupply_ >= baseUnitsToRedeem ) ) ; require ( ( balances [ msg . sender ] >= baseUnitsToRedeem ) ) ; burn ( msg . sender , baseUnitsToRedeem ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; uint index ; bool ok ; ( index , ok ) = tokensToSkip . index ( tokenInfo . addr ) ; if ( ok ) { continue ; } transferUnderlyingTokensWhenRedeem ( erc20 , tokenInfo . tokenUnits , baseUnitsToRedeem ) ; } }
","Redeems ETF Token in return for underlying tokens
"
"function allowance ( address _owner , address _spender ) view public returns ( uint256 remaining ) { return approved [ _owner ] [ _spender ] ; }
","Check ` _value ` tokens allowed to ` _spender ` by ` _owner `
"
"function startTokenVotes ( address [ ] _tokens , uint _duration , uint _criteria , uint _extraData , address [ ] _previousWinners ) public onlyAdmins { require ( _tokens . length <= MAX_CANDIDATES ) ; for ( uint i = 0 ; i < _previousWinners . length ; i ++ ) { isWinner [ _previousWinners [ i ] ] = true ; } if ( _criteria == 1 ) { require ( _extraData < consideredTokens . length ) ; } uint _proposalId = tokenBatches . length ; if ( _proposalId > 0 ) { TokenProposal memory op = tokenBatches [ _proposalId - 1 ] ; DestructibleMiniMeToken ( op . votingToken ) . recycle ( ) ; } tokenBatches . length ++ ; TokenProposal storage p = tokenBatches [ _proposalId ] ; p . duration = _duration * ( 1 days ) ; for ( i = 0 ; i < _tokens . length ; i ++ ) { require ( ! tokenExists [ _tokens [ i ] ] ) ; consideredTokens . push ( _tokens [ i ] ) ; yesVotes . push ( 0 ) ; lastVote [ _tokens [ i ] ] = _proposalId ; tokenExists [ _tokens [ i ] ] = true ; } p . votingToken = tokenFactory . createDestructibleCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( ""EfxTokenVotes-"" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( ""EVT-"" , _proposalId ) , true ) ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; p . criteria = _criteria ; p . extraData = _extraData ; emit NewTokens ( _proposalId ) ; }
","Admins are able to approve proposal that someone submitted
"
"function updateWhitelist ( address _account , uint8 _phase ) external onlyOps returns ( bool ) { require ( _account != address ( 0 ) , ""zero address is not allowed"" ) ; require ( _phase == uint8 ( Rating . Unlisted ) || _phase == uint8 ( Rating . Whitelisted ) , ""invalid rating"" ) ; Rating rating = Rating ( _phase ) ; customer [ _account ] . rating = rating ; emit WhitelistUpdated ( _account , _phase ) ; if ( rating > Rating . Unlisted && ! customer [ _account ] . hasReceivedBounty && tokenLeftForBounty > 0 ) { customer [ _account ] . hasReceivedBounty = true ; customer [ _account ] . amountReceivedWhiskyToken = customer [ _account ] . amountReceivedWhiskyToken . add ( bountyTokenPerPerson ) ; tokenLeftForBounty = tokenLeftForBounty . sub ( bountyTokenPerPerson ) ; require ( tokenReward . transfer ( _account , bountyTokenPerPerson ) , ""token transfer failed"" ) ; emit BountyTransfer ( _account , bountyTokenPerPerson ) ; } return true ; }
","Not for public use !
"
"function calculateCommissionToWithdraw ( uint32 _canvasId ) public view stateOwned ( _canvasId ) returns ( uint ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _lastIndex = _history . commissionCumulative . length - 1 ; uint _lastPaidIndex = _history . paidCommissionIndex ; if ( _lastIndex < 0 ) { return 0 ; } uint _commissionSum = _history . commissionCumulative [ _lastIndex ] ; uint _lastWithdrawn = _history . commissionCumulative [ _lastPaidIndex ] ; uint _toWithdraw = _commissionSum - _lastWithdrawn ; require ( _toWithdraw <= _commissionSum ) ; return _toWithdraw ; }
","Calculates how much of commission there is to be paid .
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < ownerToCaptainArray [ _owner ] . length ) ; if ( _owner != address ( 0 ) ) { uint256 tokenId = ownerToCaptainArray [ _owner ] [ _index ] ; return tokenId ; } }
","Enumerate NFTs assigned to an owner
"
"function ordersCount ( ) external view returns ( uint256 ) { return orderbook . length ; }
","returns the number of orders in the orderbook
"
"function nextPrice ( uint256 currentPrice ) public pure returns ( uint256 ) { if ( currentPrice < 1 ether ) { return currentPrice . mul ( 200 ) . div ( 100 ) ; } else if ( currentPrice < 5 ether ) { return currentPrice . mul ( 150 ) . div ( 100 ) ; } else { return currentPrice . mul ( 135 ) . div ( 100 ) ; } }
","Calculate the next price given the current price .
"
"function burn ( uint _value ) { if ( balances [ msg . sender ] >= _value ) { balances [ msg . sender ] -= _value ; totalSupply -= _value ; } }
","sender balance will be decreased by ` _value `
"
"function getTokensSoldFor ( FundRaiseType _fundRaiseType ) public view returns ( uint256 ) { uint256 tokensSold ; for ( uint8 i = 0 ; i < mintedPerTier [ uint8 ( _fundRaiseType ) ] . length ; i ++ ) { tokensSold = tokensSold . add ( mintedPerTier [ uint8 ( _fundRaiseType ) ] [ i ] ) ; } return tokensSold ; }
","Return the total no .
"
"function emitApprove ( address _from , address _spender , uint _value ) onlyChronoBankPlatform public { emit Approval ( _from , _spender , _value ) ; }
","Emits ERC20 Approval event on this contract .
"
"function getFightingAmounts ( Fish _fish , bool _is_attacker ) internal view returns ( uint256 ) { return ( getFishPower ( _fish ) * ( _is_attacker ? 60 : 40 ) + getFishAgility ( _fish ) * ( _is_attacker ? 40 : 60 ) ) * _fish . weight ; }
","get attack and defence from fish
"
"function pay ( uint index , uint256 _amount , address _from , bytes oracleData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent ) ; addInterest ( index ) ; uint256 toPay = min ( getPendingAmount ( index ) , _amount ) ; PartialPayment ( index , msg . sender , _from , toPay ) ; loan . paid = safeAdd ( loan . paid , toPay ) ; if ( getRawPendingAmount ( index ) == 0 ) { TotalPayment ( index ) ; loan . status = Status . paid ; lendersBalance [ loan . lender ] -= 1 ; activeLoans -= 1 ; Transfer ( loan . lender , 0x0 , index ) ; } uint256 rate = getRate ( loan , oracleData ) ; uint256 transferValue = safeMult ( toPay , rate ) ; lockTokens ( rcn , transferValue ) ; require ( rcn . transferFrom ( msg . sender , this , transferValue ) ) ; loan . lenderBalance = safeAdd ( transferValue , loan . lenderBalance ) ; return true ; }
","Pay loan Does a payment of a given Loan , before performing the payment the accumulated interest is computed and added to the total pending amount .
"
"function addWhitelist ( address _account ) external whenNotPaused onlyAdmin returns ( bool ) { require ( _account != address ( 0 ) , ""Account cannot be zero address"" ) ; if ( ! whitelist [ _account ] ) { whitelist [ _account ] = true ; emit WhitelistAdded ( _account ) ; } return true ; }
","Adds an account to the whitelist .
"
"function quitFromAirdrops ( ) public ifNotPaused { require ( signups [ msg . sender ] . userAddress == msg . sender ) ; delete signups [ msg . sender ] ; userSignupCount -- ; }
","WARNING : Quiting from the airdrop central will make you lose tokens not yet withdrawn .
"
"function selfDestruct ( ) external onlyOwner { require ( selfDestructInitiated && initiationTime + SELFDESTRUCT_DELAY < now ) ; address beneficiary = selfDestructBeneficiary ; emit SelfDestructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; }
","If the self-destruction delay has elapsed , destroy this contract and remit any ether it owns to the beneficiary address .
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _tokenId ) { require ( _index < balanceOf ( _owner ) , ""invalid index"" ) ; return ownedTokens [ _owner ] [ _index ] ; }
","Enumerate NFTs assigned to an owner
"
"function burn ( uint256 neumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public only ( ROLE_NEUMARK_BURNER ) { burnPrivate ( neumarkUlps , minEurUlps , maxEurUlps ) ; }
","executes as function above but allows to provide search range for low gas burning
"
"function setSelfClaim ( bytes32 key , bytes32 value ) public { revert ( ) ; }
","Provided for compatibility with ERC780 .
"
"function transferFromPreSignedHashing ( address _token , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xb7656dc5 ) , _token , _from , _to , _value , _fee , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by transferFromPreSigned
"
"function pausePresale ( ) onlyOwner public returns ( bool ) { paused = true ; Paused ( owner , now ) ; return true ; }
","Pauses the presale if there is an issue
"
"function confirmCeilingRaise ( bytes32 _lockId ) public onlyCustodian { PendingCeilingRaise storage pendingRaise = pendingRaiseMap [ _lockId ] ; uint256 raiseBy = pendingRaise . raiseBy ; require ( raiseBy != 0 ) ; delete pendingRaiseMap [ _lockId ] ; uint256 newCeiling = totalSupplyCeiling + raiseBy ; if ( newCeiling >= totalSupplyCeiling ) { totalSupplyCeiling = newCeiling ; emit CeilingRaiseConfirmed ( _lockId , raiseBy , newCeiling ) ; } }
","Confirms a pending increase in the token supply .
"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 allowed ) { return allowance [ _owner ] [ _spender ] ; }
","Used to look up allowance of a user
"
"function setEndDate ( uint256 _endDate ) external onlyDonationAddress returns ( bool ) { endDate = _endDate ; return true ; }
","The ` setEndDate ( ) ` changes unit timestamp on wich de donations ends .
"
"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return _isApprovedForAll ( _owner , _operator ) ; }
","Query if an address is an authorized operator for another address
"
"function newProposal ( address _creator , uint _amount , string _description , bytes32 _hashOfTheDocument ) external returns ( uint ) { if ( msg . sender == Client ( ) && _creator != recipient && _creator != creator ) throw ; if ( msg . sender != Client ( ) && msg . sender != recipient && msg . sender != creator ) throw ; if ( _amount == 0 ) throw ; uint _proposalID = proposals . length ++ ; proposal c = proposals [ _proposalID ] ; c . amount = _amount ; c . description = _description ; c . hashOfTheDocument = _hashOfTheDocument ; c . dateOfProposal = now ; ProposalAdded ( msg . sender , _proposalID , c . amount , c . description , c . hashOfTheDocument ) ; return _proposalID ; }
","Function to make a proposal to work for the client
"
"function shutDownVersion ( uint id ) pre_cond ( msg . sender == address ( this ) ) pre_cond ( isActive ( id ) ) { require ( msg . sender == address ( this ) ) ; VersionInterface Version = VersionInterface ( versions [ id ] . version ) ; Version . shutDown ( ) ; delete versions [ id ] ; emit VersionUpdated ( id ) ; }
","Remove and shut down version of Melon
"
"function buysXid ( uint256 _gameID , uint256 [ ] memory _teamEth , uint256 _affCode , string memory _comment ) public payable isActivated ( _gameID ) isOngoing ( _gameID ) isNotPaused ( _gameID ) isNotClosed ( _gameID ) isHuman ( ) isWithinLimits ( msg . value ) { uint256 _pID = FSBook . getPlayerID ( msg . sender ) ; uint256 _affID ; if ( _affCode != 0 && _affCode != _pID ) { FSBook . setPlayerLAff ( _pID , _affCode ) ; _affID = _affCode ; } else { _affID = FSBook . getPlayerLAff ( _pID ) ; } buysCore ( _gameID , _pID , _teamEth , _affID ) ; handleComment ( _gameID , _pID , _comment ) ; }
","Buy keys for each team .
"
"function checkWin ( uint [ ] decryptKeys ) public { require ( ! grace ) ; require ( decryptKeys . length == locations . length ) ; uint lastBlock = 0 ; bool won = true ; for ( uint i ; i < locations . length ; i ++ ) { require ( hunters [ msg . sender ] [ i ] . block > lastBlock ) ; lastBlock = hunters [ msg . sender ] [ i ] . block ; if ( locations [ i ] != 0 ) { uint storedVal = uint ( keccak256 ( abi . encodePacked ( hunters [ msg . sender ] [ i ] . encryptKey ^ decryptKeys [ i ] ) ) ) ; won = won && ( locations [ i ] == storedVal ) ; } } require ( won ) ; if ( won ) { timeOfWin = now ; winner = msg . sender ; grace = true ; emit WonEvent ( winner ) ; } }
","Sets the message sender as the winner if they have completed the hunt
"
"function activate ( ) external onlyOwner onlyState ( State . Ready ) { require ( numLocks == numBeneficiaries ) ; initialBalance = token . balanceOf ( this ) ; require ( initialBalance > 0 ) ; activeTime = now ; state = State . Active ; emit StateChanged ( state ) ; }
","beneficiary can release their tokens after activated
"
"function ( ) payable { revert ( ) ; }
","this is default function called when ETH is send to this contract we use the campaign contract for selling tokens
"
"function unlock ( ) public constant returns ( bool success ) { uint256 amount = lockedBalance [ msg . sender ] ; require ( amount > 0 ) ; require ( now >= timeRelease [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; lockedBalance [ msg . sender ] = 0 ; timeRelease [ msg . sender ] = 0 ; Transfer ( 0x0 , msg . sender , amount ) ; UnLock ( msg . sender , amount ) ; return true ; }
","Transfers tokens held by lock .
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowances [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens on its behalf .
"
"function newDeliverable ( uint256 _reward ) internal pure returns ( Deliverable _deliverable ) { require ( _reward > 0 ) ; return Deliverable ( _reward , false ) ; }
","return new deliverable struct if reward greater than 0
"
"function _internalTransfer ( address from , address to , uint amount , uint fee ) internal returns ( bool ) { require ( to != address ( 0 ) ) ; require ( to != address ( this ) ) ; require ( to != address ( proxy ) ) ; tokenState . setBalanceOf ( from , safeSub ( tokenState . balanceOf ( from ) , safeAdd ( amount , fee ) ) ) ; tokenState . setBalanceOf ( to , safeAdd ( tokenState . balanceOf ( to ) , amount ) ) ; tokenState . setBalanceOf ( FEE_ADDRESS , safeAdd ( tokenState . balanceOf ( FEE_ADDRESS ) , fee ) ) ; emitTransfer ( from , to , amount ) ; emitTransfer ( from , FEE_ADDRESS , fee ) ; return true ; }
","Base of transfer functions
"
"function getMinimumFunds ( ) internal constant returns ( uint ) { return 0 ; }
","minimum amount of funding to consider crowdsale as successful
"
"function balanceOf ( address _who ) public view returns ( uint256 ) { return balances [ _who ] ; }
","Get the balance of an _who address .
"
"function getForOwner ( address _owner ) public view validAddress ( _owner ) returns ( uint64 [ ] ) { return ownedTokens [ _owner ] ; }
","Get the indexes of all PixelCons owned by ` ( _owner ) `
"
"function _transferFrom ( address _from , address _to , uint256 _tokenId ) internal { require ( _isApprovedOrOwner ( msg . sender , _tokenId ) ) ; require ( _to != address ( 0 ) ) ; _clearApproval ( _from , _tokenId ) ; _removeTokenFrom ( _from , _tokenId ) ; _addTokenTo ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }
","Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
"
"function massNotify ( address [ ] _owners ) public onlyOwner { for ( uint256 i = 0 ; i < _owners . length ; i ++ ) { Transfer ( address ( 0 ) , _owners [ i ] , VIRTUAL_COUNT ) ; } }
","Notify owners about their virtual balances .
"
"function licenseAffiliate ( uint256 _licenseId ) public view returns ( address ) { return licenses [ _licenseId ] . affiliate ; }
","Get a the affiliate credited for the sale of this license
"
"function modifyWhitelist ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit LogModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }
","adds or removes addresses from the whitelist .
"
"function feePaid ( bytes4 currencyKey , uint amount ) external onlySynthetix { uint xdrAmount = synthetix . effectiveValue ( currencyKey , amount , ""XDR"" ) ; recentFeePeriods [ 0 ] . feesToDistribute = recentFeePeriods [ 0 ] . feesToDistribute . add ( xdrAmount ) ; }
","The Synthetix contract informs us when fees are paid .
"
"function getRate ( Loan loan , bytes data ) internal returns ( uint256 ) { if ( loan . oracle == address ( 0 ) ) { return 1 ; } else { return loan . oracle . getRate ( loan . currency , data ) ; } }
","Retrieves the rate corresponding of the loan oracle
"
"function getEdition ( uint256 _editionId ) public view returns ( uint256 id , string editionName , uint256 worldQuantity , uint256 [ ] preciousIds ) { Edition storage edition = allEditions [ _editionId - 1 ] ; id = edition . id ; editionName = edition . name ; worldQuantity = edition . worldQuantity ; preciousIds = edition . preciousIds ; }
","Returns all the relevant information about a specific edition .
"
"function getDelegateDetails ( address _delegate ) public view returns ( bytes32 ) { return delegateDetails [ _delegate ] ; }
","Use to get the details of the delegate
"
"function mintAndSetData ( address _to , uint256 _data ) public returns ( uint256 ) { require ( approvedContractAddresses [ msg . sender ] , ""not an approved sender"" ) ; uint256 tokenId = nextTokenId ; nextTokenId ++ ; _mint ( _to , tokenId ) ; _setData ( tokenId , 0 , _data ) ; return tokenId ; }
","Mint token function
"
"function sell ( uint amount ) public returns ( uint revenue ) { require ( initialSaleComplete ) ; require ( balances [ msg . sender ] >= bid ) ; balances [ reserveAddress ] += amount ; balances [ msg . sender ] -= amount ; revenue = amount * bid ; require ( msg . sender . send ( revenue ) ) ; emit Transfer ( msg . sender , reserveAddress , amount ) ; return revenue ; }
","Sells aToken in exchnage for wei at the current bid price , reduces resreve
"
"function generateTargetTokens ( address _beneficiary , uint256 _targetTotalSupply , uint256 _ratio ) internal { uint256 tokens = _targetTotalSupply . mul ( _ratio ) . div ( coeff ) ; generateTokens ( _beneficiary , tokens ) ; }
","helper function to generate tokens with ratio
"
"function create ( ) payable external { if ( ! funding ) throw ; if ( block . number < fundingStartBlock ) throw ; if ( block . number > fundingEndBlock ) throw ; if ( msg . value == 0 ) throw ; bool isEarlyBacker = false ; for ( uint i = 0 ; i < earlyBackers . length ; i ++ ) { if ( earlyBackers [ i ] . backerAddress == msg . sender ) { earlyBackers [ i ] . deposited += msg . value ; isEarlyBacker = true ; EarlyBackerDeposit ( msg . sender , msg . value ) ; } } if ( ! isEarlyBacker ) { if ( msg . value > ( tokenCreationCap - totalTokens ) / tokenCreationRate ) throw ; var numTokens = msg . value * tokenCreationRate ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; } }
","Create tokens when funding is active .
"
"function convertRegularToRewardTokens ( address _user , uint256 _amount ) external onlyOwner validAmount ( _amount ) senderHasEnoughTokens ( _amount , 0 ) isWhitelisted ( _user ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; rewardBalances [ _user ] = rewardBalances [ _user ] . add ( _amount ) ; emit TransferReward ( msg . sender , _user , _amount ) ; }
","Convert a specific amount of regular TRVL tokens from the owner , into reward tokens for a user .
"
"function proxyPayment ( address _owner ) payable public returns ( bool ) ;
","Called when ` _owner ` sends ether to the MiniMe Token contract
"
"function checkIn ( ) onlySecurityGuard external { securityGuardLastCheckin = _getTime ( ) ; }
","To reduce the risk of a front-running attack on payments , it is important that this is called with a resonable gasPrice set for the current network congestion .
"
"function addOracles ( address [ ] _whitelist ) external onlyContractOwner returns ( uint ) { for ( uint _idx = 0 ; _idx < _whitelist . length ; ++ _idx ) { address _oracle = _whitelist [ _idx ] ; if ( ! oracles [ _oracle ] ) { oracles [ _oracle ] = true ; _emitOracleAdded ( _oracle ) ; } } return OK ; }
","Add oracles to whitelist .
"
"function totalSupply ( ) public view returns ( uint256 ) { return totalTokens ; }
","Gets the total amount of tokens stored by the contract
"
"function setSellRate ( uint256 priceInWei ) isOwner { require ( priceInWei >= 0 ) ; sellRate = priceInWei ; }
","Set the current sell price in wei for one token
"
"function allowance ( address _owner , address _spender ) external constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }
","Query the amount of tokens the spender address can withdraw from the owner address ~ ERC-20 Standard
"
"function halfPercent ( uint _value ) private pure returns ( uint amount ) { if ( _value > 0 ) { uint temp = SafeMath . mul ( _value , 5 ) ; amount = SafeMath . div ( temp , 1000 ) ; if ( amount == 0 ) { amount = 1 ; } } else { amount = 0 ; } return ; }
","returns uint representing 0.5 % of _value
"
"function ( ) external payable { exchangeEtherForSynths ( ) ; }
","Fallback function ( exchanges ETH to sUSD )
"
"function isTokenXContract ( address asset , string currency ) public view returns ( bool isX ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tokenx' , asset , currency ) ) ; return lib . Storage . getBool ( id ) ; }
","Return boolean if the asset is a registered Token X asset for the corresponding currency
"
"function withdraw ( ERC20 token , uint amount , address destination ) returns ( bool ) { if ( msg . sender != reserveOwner ) { ErrorReport ( tx . origin , 0x860000000 , uint ( msg . sender ) ) ; return false ; } if ( token == ETH_TOKEN_ADDRESS ) { if ( ! destination . send ( amount ) ) throw ; } else if ( ! token . transfer ( destination , amount ) ) { ErrorReport ( tx . origin , 0x860000001 , uint ( token ) ) ; return false ; } ErrorReport ( tx . origin , 0 , 0 ) ; Withdraw ( token , amount , destination ) ; }
","can only be called by owner .
"
"function setRealitio ( address addr ) onlyOwner public { realitio = Realitio ( addr ) ; emit LogSetRealitio ( addr ) ; }
","Set the Reality Check contract address
"
"function release ( uint256 _amount ) public { require ( _amount > 0 ) ; require ( releasedTokens >= _amount ) ; releasedTokens = releasedTokens . sub ( _amount ) ; uint256 balance = token . balanceOf ( this ) ; require ( balance >= _amount ) ; token . safeTransfer ( advisor , _amount ) ; }
","release tokens held by the contract to advisor .
"
"function mint ( address _holder , uint256 _tokens ) public onlyMintingAgents ( ) { require ( allowedMinting == true && totalSupply_ . add ( _tokens ) <= maxSupply ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ _holder ] = balanceOf ( _holder ) . add ( _tokens ) ; if ( totalSupply_ == maxSupply ) { allowedMinting = false ; } emit MintERC20 ( _holder , _tokens ) ; emit Transfer ( 0x0 , _holder , _tokens ) ; }
","allow to mint tokens
"
"function transfer ( address to , uint256 value ) returns ( bool ) { if ( safeSub ( balances [ msg . sender ] , value ) < shouldHadBalance ( msg . sender ) ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } else { throw ; } }
","This function is disabled during the funding .
"
"function buildIdentifier ( Oracle oracle , address borrower , address creator , bytes32 currency , uint256 amount , uint256 interestRate , uint256 interestRatePunitory , uint256 duesIn , uint256 cancelableAt , uint256 expirationRequest , string metadata ) view returns ( bytes32 ) { return keccak256 ( this , oracle , borrower , creator , currency , amount , interestRate , interestRatePunitory , duesIn , cancelableAt , expirationRequest , metadata ) ; }
","Used to reference a loan that is not yet created , and by that does not have an index
"
"function destroyTokens ( address _owner , uint _amount ) onlyController public returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; emit Transfer ( _owner , 0 , _amount ) ; return true ; }
","Burns ` _amount ` tokens from ` _owner `
"
"function activate ( uint256 _gameID , uint256 _startTime ) external isHuman ( ) isOwner ( ) { require ( _gameID < gameIDIndex_ , ""incorrect game id"" ) ; require ( game_ [ _gameID ] . gameStartTime == 0 , ""already activated"" ) ; game_ [ _gameID ] . gameStartTime = _startTime ; emit onGameActivated ( _gameID , _startTime , now ) ; }
","Activate a game .
"
"function getKeysfromETH ( uint256 _gameID , uint256 _team , uint256 _eth ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { return ( teams_ [ _gameID ] [ _team ] . eth ) . keysRec ( _eth ) ; }
","Get the number of keys can be bought with an amount of ETH .
"
"function changeOwnership ( address _newOwner ) public onlyOwner { require ( _newOwner != 0x0 ) ; address oldOwner = owner ; owner = _newOwner ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }
","` owner ` can step down and assign some other address to this role
"
"function _addToDebtRegister ( bytes4 currencyKey , uint amount ) internal optionalProxy { uint xdrValue = effectiveValue ( currencyKey , amount , ""XDR"" ) ; uint totalDebtIssued = totalIssuedSynths ( ""XDR"" ) ; uint newTotalDebtIssued = xdrValue . add ( totalDebtIssued ) ; uint debtPercentage = xdrValue . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . sub ( debtPercentage ) ; uint existingDebt = debtBalanceOf ( messageSender , ""XDR"" ) ; if ( existingDebt > 0 ) { debtPercentage = xdrValue . add ( existingDebt ) . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; } if ( ! synthetixState . hasIssued ( messageSender ) ) { synthetixState . incrementTotalIssuerCount ( ) ; } synthetixState . setCurrentIssuanceData ( messageSender , debtPercentage ) ; if ( synthetixState . debtLedgerLength ( ) > 0 ) { synthetixState . appendDebtLedgerValue ( synthetixState . lastDebtLedgerEntry ( ) . multiplyDecimalRoundPrecise ( delta ) ) ; } else { synthetixState . appendDebtLedgerValue ( SafeDecimalMath . preciseUnit ( ) ) ; } }
","Function that registers new synth as they are isseud .
"
"function fillOffer ( address _filler , bytes32 _offerHash , uint256 _amountToTake , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { bytes32 msgHash = keccak256 ( abi . encodePacked ( ""fillOffer"" , _filler , _offerHash , _amountToTake , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( msgHash , _v , _r , _s ) == _filler , ""Invalid signature"" ) ; _validateAndAddHash ( msgHash ) ; _fill ( _filler , _offerHash , _amountToTake , _feeAsset , _feeAmount ) ; }
","Fills a offer that has been previously made using ` makeOffer ` .
"
"function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F40 ) , _newCOO , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by setCOO
"
"function updateDarknodeBond ( address darknodeID , uint256 bond ) external onlyOwner { uint256 previousBond = darknodeRegistry [ darknodeID ] . bond ; darknodeRegistry [ darknodeID ] . bond = bond ; if ( previousBond > bond ) { require ( ren . transfer ( owner , previousBond - bond ) , ""cannot transfer bond"" ) ; } }
","Updates the bond of the darknode .
"
"function approve ( address _approved , uint256 _tokenId ) external payable ;
","Set or reaffirm the approved address for an NFT
"
"function setAuthorizedContract ( string _contractName , address _authorizedAddress , bool _authorized ) external ;
","Change whether an address is authorized to use a specific contract or not
"
"function transfer ( address _to , uint _value , bytes _data ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ msg . sender ] && balances [ _to ] + _value >= balances [ _to ] ) ; if ( isContract ( _to ) ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit ERC223Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
","Instead of sending byte string for the transaction data , string type is used for more detailed description .
"
"function setRates ( uint256 buyRateInWei , uint256 sellRateInWei ) isOwner { require ( buyRateInWei > 0 ) ; require ( sellRateInWei > 0 ) ; buyRate = buyRateInWei ; sellRate = buyRateInWei ; updatePrices ( ) ; }
","Set both commissions at the same time
"
"function initialize ( MiniMeToken _token , bool _transferable , uint256 _maxAccountTokens ) external onlyInit { initialized ( ) ; require ( _token . controller ( ) == address ( this ) , ERROR_TOKEN_CONTROLLER ) ; token = _token ; maxAccountTokens = _maxAccountTokens == 0 ? uint256 ( - 1 ) : _maxAccountTokens ; if ( token . transfersEnabled ( ) != _transferable ) { token . enableTransfers ( _transferable ) ; } }
","Initialize Token Manager for ` _token.symbol ( ) : string ` , whose tokens are ` transferable ?
"
"function transferToSelf ( uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ selfAddress ] = balances [ selfAddress ] + _value ; Transfer ( msg . sender , selfAddress , _value ) ; allowed [ selfAddress ] [ msg . sender ] = _value + allowed [ selfAddress ] [ msg . sender ] ; Approval ( selfAddress , msg . sender , allowed [ selfAddress ] [ msg . sender ] ) ; return true ; }
","Handles Casino deposits ~ Custom ERC-223 Proposed Standard Addition
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Assign allowance _value to _spender address to use the msg.sender balance
"
"function iterateInvestors ( uint256 _start , uint256 _end ) external view returns ( address [ ] ) ;
","generates subset of investors NB - can be used in batches if investor list is large
"
"function withdraw ( address _from , address _to , uint _value , uint _fee , address _collector ) onlyOwner public { require ( getState ( ) == State . Success ) ; require ( applications [ _from ] != 0x0 ) ; address app = applications [ _from ] ; require ( _collector != 0x0 ) ; require ( _to != 0x0 ) ; require ( balanceOf [ app ] >= safeAdd ( _value , _fee ) ) ; require ( safeAdd ( balanceOf [ _to ] , _value ) > balanceOf [ _to ] ) ; require ( ! frozenAccount [ app ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( _from != lockedTokenHolder ) ; balanceOf [ app ] = safeSub ( balanceOf [ app ] , safeAdd ( _value , _fee ) ) ; balanceOf [ _to ] = safeAdd ( balanceOf [ _to ] , _value ) ; balanceOf [ _collector ] = safeAdd ( balanceOf [ _collector ] , _fee ) ; emit Fee ( app , _collector , _fee ) ; emit Transfer ( app , _collector , _fee ) ; emit Transfer ( app , _to , _value ) ; }
","Application withdraw , only can be called by owner
"
"function depositAndTransfer ( address transferTo , uint256 amount , bytes data ) public payable { depositPrivate ( ) ; transfer ( transferTo , amount , data ) ; }
","convenience function to deposit and immediately transfer amount
"
"function calculateFee ( uint256 ethers ) public view returns ( uint256 fee ) { fee = ethers . wmul ( etherFeePercent / 100 ) ; if ( fee < etherFeeMin ) fee = etherFeeMin ; return fee ; }
","Calculate the company 's fee for facilitating the transfer of tokens .
"
"function addToAdmin ( address admin , bool isAdd ) external onlyOwner { isAdmin [ admin ] = isAdd ; }
","add/remove a address to admin list , only owner
"
"function withdrawExcessToken ( address token ) external onlyOwner { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 tokenUnits ; bool ok ; ( tokenUnits , ok ) = getTokenUnits ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( granularity_ ) . mul ( tokenUnits ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }
","Owner : Withdraw excess funds which do n't belong to ETF Token holders
"
"function setTokenAvailable ( bool _available ) public onlyOwner { tokenAvailable = _available ; }
","Not for public use !
"
"function getArbitrator ( bytes32 question_id ) public view returns ( address ) { }
","Returns the arbitrator address for the question
"
"function setIssuer ( address account , bool value ) external optionalProxy_onlyOwner { isIssuer [ account ] = value ; emitIssuersUpdated ( account , value ) ; }
","Set whether the specified can issue nomins or not .
"
"function getInvertedPrice ( address ofAsset ) view returns ( bool isRecent , uint invertedPrice , uint decimal ) { var ( isInvertedRecent , inputPrice , assetDecimal ) = getPrice ( ofAsset ) ; uint quoteDecimal = getDecimals ( QUOTE_ASSET ) ; return ( isInvertedRecent , mul ( 10 ** uint ( quoteDecimal ) , 10 ** uint ( assetDecimal ) ) / inputPrice , quoteDecimal ) ; }
","Gets inverted price of an asset
"
"function transferredAmountToReceive ( uint value ) external view returns ( uint ) { return value . add ( transferFeeIncurred ( value ) ) ; }
","The value that you would need to send so that the recipient receives a specified value .
"
"function currentRoundNum ( ) view public returns ( uint8 ) { for ( uint8 i = 0 ; i < rounds . length ; i ++ ) { if ( ( now > rounds [ i ] . start ) && ( now <= rounds [ i ] . end ) ) return i + 1 ; } return 0 ; }
","Fetches current Round number
"
"function getNextVestingQuantity ( address account ) external view returns ( uint ) { return getNextVestingEntry ( account ) [ QUANTITY_INDEX ] ; }
","Obtain the quantity which the next schedule entry will vest for a given user .
"
"function ( ) payable { uint256 amount ; if ( this . balance >= msg . value * 2 ) { amount = msg . value * 2 ; require ( beneficiary . send ( amount ) ) ; DonationMatched ( msg . sender , amount ) ; } else { amount = this . balance ; require ( beneficiary . send ( amount ) ) ; DonationSentButNotMatched ( msg . sender , amount ) ; } }
","Donate ETH to the ` beneficiary ` , and if there is enough in the contract double it .
"
"function initiateSelfDestruct ( ) external onlyOwner { require ( ! selfDestructInitiated , ""Self-destruct already initiated."" ) ; selfDestructInitiationTime = now ; selfDestructInitiated = true ; emit SelfDestructInitiated ( SELFDESTRUCT_DELAY ) ; }
","Begin the self-destruction counter of this contract .
"
"function getBorrowRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory _utilizationRate , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory borrowRate ) = divScalar ( annualBorrowRate , blocksPerYear ) ; assert ( err1 == Error . NO_ERROR ) ; _utilizationRate ; return ( uint ( IRError . NO_ERROR ) , borrowRate . mantissa ) ; }
","Gets the current borrow interest rate based on the given asset , total cash and total borrows
"
"function hasEnded ( ) public constant returns ( bool ) { return now > endTime || tokensRaised >= maxTokensRaised ; }
","Public function to check if the crowdsale has ended or not
"
"function changeOraclizeGas ( uint newGas ) public onlyOwner { require ( newGas > 0 && newGas <= 4000000 ) ; ORACLIZE_GAS_LIMIT = newGas ; }
","To be used in case the default gas cost is too low
"
"function setValidity ( Campaign storage _campaign , bool _valid ) internal { _campaign . valid = _valid ; }
","Set campaign validity
"
"function acceptOwnership ( ) public returns ( bool ) ;
","Finalise change of ownership to newOwner
"
"function getApproved ( uint256 _tokenId ) external view returns ( address ) { return _getApproved ( _tokenId ) ; }
","Get the approved address for a single NFT
"
"function tokenFallback ( address _sender , uint256 _value , bytes _data ) public { }
","Empty tokenFallback method to ensure ERC-223 compatibility
"
"function removeAttribute ( uint256 attributeTypeID ) external ;
","Remove an attribute of the type with ID ` attributeTypeID ` from account of ` msg.sender ` .
"
"function removeHandlerFromWhitelist ( address handler ) public onlyOwner handlerWhitelisted ( handler ) { delete handlerWhitelistMap [ handler ] ; for ( uint i = 0 ; i < handlerWhitelistArray . length ; i ++ ) { if ( handlerWhitelistArray [ i ] == handler ) { handlerWhitelistArray [ i ] = handlerWhitelistArray [ handlerWhitelistArray . length - 1 ] ; handlerWhitelistArray . length -= 1 ; break ; } } }
","Remove an exchangeHandler address from the whitelist
"
"function verifyAccounts ( Data storage self , address accountA , address accountB ) internal view returns ( bool verified ) { require ( verifyAccount ( self , accountA ) , ""Error: Account is not verified for operation. Please ensure account has been KYC approved."" ) ; require ( verifyAccount ( self , accountB ) , ""Error: Account is not verified for operation. Please ensure account has been KYC approved."" ) ; return true ; }
","Verified KYC and global status for two accounts and return true or throw if either account is not verified
"
"function vote ( uint _tokenIndex , uint _amount ) public { require ( myDelegate [ msg . sender ] == address ( 0 ) ) ; require ( ! isWinner [ consideredTokens [ _tokenIndex ] ] ) ; require ( tokenBatches . length > 0 ) ; uint _proposalId = tokenBatches . length - 1 ; require ( isActive ( _proposalId ) ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; if ( lastVote [ consideredTokens [ _tokenIndex ] ] < _proposalId ) { yesVotes [ _tokenIndex ] /= 2 * ( _proposalId - lastVote [ consideredTokens [ _tokenIndex ] ] ) ; lastVote [ consideredTokens [ _tokenIndex ] ] = _proposalId ; } uint balance = DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) ; if ( isDelegate [ msg . sender ] ) { for ( uint i = 0 ; i < myVotes [ msg . sender ] . length ; i ++ ) { address user = myVotes [ msg . sender ] [ i ] ; balance += DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( user ) ; } } require ( _amount <= balance ) ; require ( votesSpentThisRound [ _proposalId ] [ msg . sender ] + _amount <= balance ) ; yesVotes [ _tokenIndex ] += _amount ; votesSpentThisRound [ _proposalId ] [ msg . sender ] += _amount ; emit Vote ( _proposalId , msg . sender , consideredTokens [ _tokenIndex ] , _amount ) ; }
","Vote for specific token with yes
"
"function channelManagerAddresses ( ) constant returns ( address [ ] ) { uint i ; address token_address ; address [ ] memory result ; result = new address [ ] ( tokens . length ) ; for ( i = 0 ; i < tokens . length ; i ++ ) { token_address = tokens [ i ] ; result [ i ] = registry [ token_address ] ; } return result ; }
","Get the addresses of all channel managers for all registered tokens
"
"function setBtcTokenBoughtAddress ( address _address ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _address != address ( 0 ) ) ; require ( _address != btcTokenBoughtAddress ) ; address oldAddress = btcTokenBoughtAddress ; btcTokenBoughtAddress = _address ; emit BtcTokenBoughtAddressChanged ( oldAddress , _address ) ; }
","Change the address which is authorized to send bought tokens with BTC
"
"function transfer ( address _to , uint256 _value ) onlyAllowed ( ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","transfer _value tokens to address _to
"
"function placeToken ( address tokenAddress , uint amount ) external nonReentrant { require ( amount > 0 ) ; require ( tokenAddress != address ( 0 ) ) ; require ( getApprovedToken ( tokenAddress , msg . sender ) . tokenAddress == tokenAddress ) ; require ( getApprovedToken ( tokenAddress , msg . sender ) . approvedOwners [ msg . sender ] ) ; DetailedERC20 token = DetailedERC20 ( tokenAddress ) ; require ( token . allowance ( msg . sender , address ( this ) ) >= amount ) ; ListedToken storage listedToken = getApprovedToken ( tokenAddress , msg . sender ) ; require ( token . decimals ( ) == listedToken . decimals ) ; uint fee = listedToken . feePercent > 0 ? amount . percent ( listedToken . feePercent ) : 0 ; uint amountWithoutFee = amount . sub ( fee ) ; _secureTokenTransfer ( token , exchanger , amountWithoutFee ) ; _secureTokenTransfer ( token , serviceWallet , fee ) ; listedToken . tokensForSaleAmount = listedToken . tokensForSaleAmount . add ( amountWithoutFee ) ; if ( exchanger . getWTokenByToken ( tokenAddress ) == address ( 0 ) ) { WToken wToken = new WToken ( listedToken . name , listedToken . symbol , listedToken . decimals ) ; exchanger . addTokenToListing ( ERC20 ( tokenAddress ) , wToken ) ; } emit TokenPlaced ( tokenAddress , msg . sender , amountWithoutFee , exchanger . getWTokenByToken ( tokenAddress ) ) ; }
","Place token for sale
"
"function pauseContribution ( bool _paused ) onlyController { paused = _paused ; }
","Pauses the contribution if there is any issue
"
"function withdraw ( address transferTo ) onlyOwner external { require ( transferTo == owner ) ; uint256 currentBalance = address ( this ) . balance ; owner . transfer ( currentBalance ) ; }
","Withdraws the fees which have been collected back to the contract owner , who is the only person that can call this
"
"function contribute ( address _target , uint256 _value ) public notFinished payable { require ( now > MAINSALEStart ) ; address user ; uint remaining ; uint256 tokenBought ; uint256 temp ; if ( _target != address ( 0 ) && level [ msg . sender ] >= 1 ) { user = _target ; remaining = _value . mul ( 1e18 ) ; } else { user = msg . sender ; remaining = msg . value . mul ( 1e18 ) ; } totalRaised = totalRaised . add ( remaining . div ( 1e18 ) ) ; while ( remaining > 0 ) { ( temp , remaining ) = tokenBuyCalc ( remaining ) ; tokenBought = tokenBought . add ( temp ) ; } temp = 0 ; totalDistributed = totalDistributed . add ( tokenBought ) ; WGRholder . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( WGRholder ) ; tokenReward . transfer ( user , tokenBought ) ; emit LogFundingReceived ( user , msg . value , totalRaised ) ; checkIfFundingCompleteOrExpired ( ) ; }
","contribution handler
"
"function checkVictoryByScore ( uint boardId ) external boardWaitingToResolve ( boardId ) { uint8 blackScore ; uint8 whiteScore ; ( blackScore , whiteScore ) = calculateBoardScore ( boardId ) ; BoardStatus status = BoardStatus . Draw ; if ( blackScore > whiteScore ) { status = BoardStatus . BlackWin ; } else if ( whiteScore > blackScore ) { status = BoardStatus . WhiteWin ; } updateBoardStatus ( boardId , status ) ; }
","Updates the board status according to the players score .
"
"function tokenBurn ( uint256 _amount ) onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( _amount < totalSupply ) ; require ( balances [ owner ] > _amount ) ; require ( sub ( balances [ owner ] , _amount ) > 0 ) ; require ( sub ( totalSupply , _amount ) > 0 ) ; balances [ owner ] = sub ( balances [ owner ] , _amount ) ; totalSupply = sub ( totalSupply , _amount ) ; TokenBurn ( msg . sender , _amount , true ) ; return true ; }
","Used to burn tokens
"
"function refundFor ( address [ ] _addrs ) public returns ( bool ) ;
","Push refund for ` _addr ` from failed ICO
"
"function removeCZRLock ( address addr , uint index ) onlyOwner public { LockedCZR [ ] storage lockArr = lockedCZRMap [ addr ] ; require ( lockArr . length > 0 && index < lockArr . length ) ; delete lockArr [ index ] ; RemoveLock ( addr , index ) ; }
","remove CZR lock ( only set all field to 0 )
"
"function transfer ( address to , uint256 value ) public payloadSizeIs ( 2 * 32 ) onlyowner returns ( bool ) { return m_SMR . frozenTransfer ( to , value , m_thawTS , false ) ; }
","Looks like transfer of this token , but actually frozenTransfers SMR .
"
"function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes _data ) public returns ( bytes4 ) { require ( systemLock == LOCK_NONE , ""Market is currently locked"" ) ; require ( msg . sender == address ( pixelconsContract ) , ""Market only accepts transfers from the PixelCons contract"" ) ; require ( _tokenId != uint256 ( 0 ) , ""Invalid token ID"" ) ; require ( _operator != address ( 0 ) , ""Invalid operator address"" ) ; require ( _from != address ( 0 ) , ""Invalid from address"" ) ; require ( _data . length == 32 * 3 , ""Incorrectly formatted data"" ) ; uint256 startPrice ; uint256 endPrice ; uint256 duration ; assembly { startPrice := mload ( add ( _data , 0x20 ) ) endPrice := mload ( add ( _data , 0x40 ) ) duration := mload ( add ( _data , 0x60 ) ) } makeListing ( _from , _tokenId , startPrice , endPrice , duration ) ; return ERC721_RECEIVED ; }
","Handle ERC721 token transfers
"
"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; itemIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function calculateSha3 ( string memory _hashinput ) public pure returns ( bytes32 ) { return keccak256 ( bytes ( _hashinput ) ) ; }
","Calculate hash
"
"function burnUserTokens ( address _owner ) public validate_address ( _owner ) onlyAdmin { if ( balances [ _owner ] == 0 ) revert ( ) ; if ( balances [ _owner ] > totalSupply ) revert ( ) ; totalSupply -= balances [ _owner ] ; balances [ _owner ] = 0 ; }
","only the admin is allowed to burn tokens - in case if the user have n't verified identity or performed fraud
"
"function reducePledgedFees ( uint _value ) public onlyController returns ( bool ) { uint curTotalFees = totalPledgedFees ( ) ; require ( curTotalFees >= _value ) ; updateValueAtNow ( totalPledgedFeesHistory , curTotalFees - _value ) ; return true ; }
","Reduces pledged fees to the token holders , i.e .
"
"function withdrawCollateral ( address token , uint amount ) public { require ( token != 0 , ""No token specified"" ) ; require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; uint amountToWithdraw = amount ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] - amount ; emit Withdraw ( token , msg . sender , amountToWithdraw , amountToWithdraw ) ; require ( StandardToken ( token ) . transfer ( msg . sender , amountToWithdraw ) , ""error with transfer"" ) ; IRemoteFunctions ( _contract_masternode ( ) ) . _externalStopMasternode ( msg . sender ) ; }
","Public function that allows any user to withdraw deposited tokens and stop as masternode
"
"function changeCountryLimit ( uint _countryCode , uint _limit ) onlyOracleOrOwner external returns ( uint ) { uint _countryIndex = countryIndex [ _countryCode ] ; require ( _countryIndex != 0 ) ; uint _currentTokenHolderNumber = countryLimitsList [ _countryIndex ] . currentTokenHolderNumber ; if ( _currentTokenHolderNumber > _limit ) { return _emitError ( DATA_CONTROLLER_CURRENT_WRONG_LIMIT ) ; } countryLimitsList [ _countryIndex ] . maxTokenHolderNumber = _limit ; _emitCountryCodeChanged ( _countryIndex , _countryCode , _limit ) ; return OK ; }
","Change country limits .
"
"function fillOffers ( address _filler , bytes32 [ ] _offerHashes , uint256 [ ] _amountsToTake , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { require ( _offerHashes . length > 0 , 'Invalid input' ) ; require ( _offerHashes . length == _amountsToTake . length , 'Invalid inputs' ) ; bytes32 msgHash = keccak256 ( abi . encodePacked ( ""fillOffers"" , _filler , _offerHashes , _amountsToTake , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( msgHash , _v , _r , _s ) == _filler , ""Invalid signature"" ) ; _validateAndAddHash ( msgHash ) ; for ( uint32 i = 0 ; i < _offerHashes . length ; i ++ ) { _fill ( _filler , _offerHashes [ i ] , _amountsToTake [ i ] , etherAddr , 0 ) ; } _paySeparateFees ( _filler , _feeAsset , _feeAmount , ReasonFillerFeeGive , ReasonFillerFeeReceive ) ; }
","Fills multiple offers that have been previously made using ` makeOffer ` .
"
"function getTot ( uint256 _tokenId ) public view returns ( string totName , uint256 sellingPrice , address owner ) { Tot storage tot = tots [ _tokenId ] ; totName = tot . name ; sellingPrice = totIndexToPrice [ _tokenId ] ; owner = totIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific tot .
"
"function ( ) public payable { if ( now < PRESALE_START_DATE ) revert ( ) ; if ( now > PRESALE_END_DATE ) revert ( ) ; if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) revert ( ) ; if ( msg . value > MAXIMUM_PARTICIPATION_AMOUNT ) revert ( ) ; if ( safeIncrement ( totalFunding , msg . value ) > PRESALE_MAXIMUM_FUNDING ) revert ( ) ; addBalance ( msg . sender , msg . value ) ; }
","A participant 's contribution will be rejected if the pre sale has been funded to the maximum amount
"
"function _getHeroGenesOrClaimFirstHero ( uint _heroId ) internal returns ( uint heroId , uint heroGenes ) { heroId = _heroId ; if ( heroTokenContract . balanceOf ( msg . sender ) == 0 ) { heroId = claimHero ( ) ; } ( , , , heroGenes ) = heroTokenContract . heroes ( heroId ) ; }
","Used in transport , challenge and train , to get the genes of a specific hero , a claim a hero if did n't have any .
"
"function ownerWithdraw ( uint256 value ) external onlyOwner { if ( totalFunding < PRESALE_MINIMUM_FUNDING ) throw ; if ( ! owner . send ( value ) ) throw ; }
","The owner can withdraw ethers already during presale , only if the minimum funding level has been reached
"
"function getBlockNumber ( ) constant internal returns ( uint ) { return block . number ; }
","returns block.number
"
"function bulkTransfer ( address [ ] _destinations , uint256 [ ] _amounts ) public onlyWhitelisted { require ( _destinations . length == _amounts . length ) ; uint256 requiredBalance = sumOf ( _amounts ) ; require ( balances [ msg . sender ] >= requiredBalance ) ; for ( uint256 i = 0 ; i < _destinations . length ; i ++ ) { transfer ( _destinations [ i ] , _amounts [ i ] ) ; } emit BulkTransferPerformed ( _destinations , _amounts ) ; }
","Allows only the admins and/or whitelisted applications to perform bulk transfer operation .
"
"function refund ( address _investor ) onlyICOContract public returns ( bool ) { if ( state != State . Refunding ) { error ( 'refund: state != State.Refunding' ) ; return false ; } if ( deposited [ _investor ] == 0 ) { error ( 'refund: no deposit to refund' ) ; return false ; } uint256 depositedValue = deposited [ _investor ] ; deposited [ _investor ] = 0 ; tokensAcquired [ _investor ] = 0 ; _investor . transfer ( depositedValue ) ; emit Refunded ( _investor , depositedValue ) ; return true ; }
","ICO Smart Contract can call this function for the investor to refund
"
"function mintTokens ( uint256 _tokens , address _destination ) onlyOwner { shp . generateTokens ( _destination , _tokens ) ; NewSale ( _destination , 0 , _tokens ) ; }
","Allows the owner to manually mint some SHP to an address if something goes wrong
"
"function getInstructions ( ) external view returns ( string ) { return ""Initialises a capped STO. Init parameters are _startTime (time STO starts), _endTime (time STO ends), _cap (cap in tokens for STO), _rate (POLY/ETH to token rate), _fundRaiseType (whether you are raising in POLY or ETH), _polyToken (address of POLY token), _fundsReceiver (address which will receive funds)"" ; }
","Returns the instructions associated with the module
"
"function getTxs ( uint _fromIdx , uint _maxLen ) public view returns ( bytes32 [ ] _txKeys , bytes32 [ ] _policyHashes , uint [ ] _alreadyAccepted , uint [ ] _alreadyDeclined , uint [ ] _states ) { uint _count = txCount ; require ( _fromIdx < _count ) ; _maxLen = ( _fromIdx + _maxLen <= _count ) ? _maxLen : ( _count - _fromIdx ) ; _txKeys = new bytes32 [ ] ( _maxLen ) ; _policyHashes = new bytes32 [ ] ( _maxLen ) ; _alreadyAccepted = new uint [ ] ( _maxLen ) ; _alreadyDeclined = new uint [ ] ( _maxLen ) ; _states = new uint [ ] ( _maxLen ) ; uint _pointer = 0 ; for ( uint _txIdx = _fromIdx ; _txIdx < _fromIdx + _maxLen ; ++ _fromIdx ) { bytes32 _txKey = index2txKey [ _txIdx + 1 ] ; _txKeys [ _pointer ] = _txKey ; Guard storage _guard = txKey2guard [ _txKey ] ; _policyHashes [ _pointer ] = index2PolicyId [ _guard . basePolicyIndex ] ; _alreadyAccepted [ _pointer ] = _guard . alreadyAccepted ; _alreadyDeclined [ _pointer ] = _guard . alreadyDeclined ; _states [ _pointer ] = uint ( _guard . state ) ; _pointer += 1 ; } }
","Gets list of txs ( paginated )
"
"function unlockCZR ( address addr , uint limit ) public { require ( msg . sender == owner || msg . sender == unlocker ) ; LockedCZR [ ] storage lockArr = lockedCZRMap [ addr ] ; require ( lockArr . length > 0 ) ; token t = token ( tokenAddr ) ; uint num = 0 ; for ( uint i = 0 ; i < lockArr . length ; i ++ ) { var lock = lockArr [ i ] ; if ( lock . lockedAmount > 0 ) { uint time = now - lock . startLockTime ; uint month = time / 30 days ; if ( month == 0 ) continue ; uint unlockAmount ; if ( month >= lock . lockMonth ) unlockAmount = lock . lockedAmount ; else unlockAmount = ( lock . lockedAmount + lock . unlockedAmount ) * month / lock . lockMonth - lock . unlockedAmount ; if ( unlockAmount == 0 ) continue ; lock . unlockedAmount += unlockAmount ; lock . lockedAmount -= unlockAmount ; t . transferFrom ( owner , addr , unlockAmount ) ; Unlock ( addr , i , unlockAmount ) ; num ++ ; if ( limit > 0 && num == limit ) break ; } } require ( num > 0 ) ; }
","unlock CZR
"
"function fundDaoFor ( uint _from , uint _to ) returns ( bool ) ;
","Function for the funding of the Dao by a group of partners
"
"function startAuction ( ) public onlyOwner { require ( status == state . pending ) ; status = state . active ; emit Started ( block . number ) ; }
","Starts the auction
"
"function claimTokens ( IERC20Token _address , address _to ) public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }
","Function to claim ANY token stuck on contract accidentally In case of claim of stuck tokens please contact contract owners
"
"function withdrawFees ( ) external optionalProxy { address sender = messageSender ; rolloverFeePeriodIfElapsed ( ) ; require ( ! nomin . frozen ( sender ) , ""Cannot deposit fees into frozen accounts"" ) ; updateIssuanceData ( sender , nominsIssued [ sender ] , nomin . totalSupply ( ) ) ; require ( ! hasWithdrawnFees [ sender ] , ""Fees have already been withdrawn in this period"" ) ; uint feesOwed ; uint lastTotalIssued = totalIssuanceData . lastAverageBalance ; if ( lastTotalIssued > 0 ) { feesOwed = safeDiv_dec ( safeMul_dec ( issuanceData [ sender ] . lastAverageBalance , lastFeesCollected ) , lastTotalIssued ) ; } hasWithdrawnFees [ sender ] = true ; if ( feesOwed != 0 ) { nomin . withdrawFees ( sender , feesOwed ) ; } emitFeesWithdrawn ( messageSender , feesOwed ) ; }
","Compute the last period 's fee entitlement for the message sender and then deposit it into their nomin account .
"
"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { if ( ! transfersEnabled ) throw ; if ( allowed [ _from ] [ msg . sender ] < _amount ) throw ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function adjustCommission ( uint256 numerator , uint256 denominator ) external onlyCLevel { require ( numerator <= denominator ) ; distributionNumerator = numerator ; distributionDenominator = denominator ; }
","Fn for adjusting commission rate
"
"function _createToken ( uint160 matches , uint32 bonusMatches , uint96 extraStats , string userMessage ) internal returns ( uint256 ) { Token memory token = Token ( { matches : matches , bonusMatches : bonusMatches , extraStats : extraStats , timeStamp : uint64 ( now ) , message : userMessage } ) ; uint256 tokenId = tokens . push ( token ) - 1 ; require ( tokenId == uint256 ( uint32 ( tokenId ) ) , ""Failed to convert tokenId to uint256."" ) ; return tokenId ; }
","Builds ERC721 token with the predictions provided by the user .
"
"function increaseCap ( uint _value ) onlyOwner { cap = cap . add ( _value ) ; LogIncreaseCap ( _value ) ; }
","Increase cap .
"
"function withdrawAllEth ( address _to ) onlyContractOwner external returns ( uint ) { uint _balance = address ( this ) . balance ; if ( _balance == 0 ) { return 0 ; } _to . transfer ( _balance ) ; return OK ; }
","Withdraws all Ether from buyback contract to specified address .
"
"function deleteBool ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete boolStorage [ _key ] ; return true ; }
","Delete value for Bool associated with bytes32 id key
"
"function ierc223TransferInternal ( address from , address to , uint256 amount , bytes data ) private returns ( bool success ) { BasicToken . mTransfer ( from , to , amount ) ; if ( isContract ( to ) ) { IERC223Callback ( to ) . tokenFallback ( from , amount , data ) ; } return true ; }
","internal transfer function that checks permissions and calls the tokenFallback
"
"function setBaselineRate ( uint256 _newRate ) onlyOwner public { require ( _newRate <= hardCodedMaximumRate ) ; baselineRate = _newRate ; RateChanged ( 0 , _newRate ) ; }
","set the rate for non-whitelisted affiliates
"
"function refund ( bytes32 _swapID ) external onlyOpenSwaps ( _swapID ) onlyExpirableSwaps ( _swapID ) { Swap memory swap = swaps [ _swapID ] ; swapStates [ _swapID ] = States . EXPIRED ; swap . ethTrader . transfer ( swap . value ) ; emit LogExpire ( _swapID ) ; }
","Refunds an atomic swap .
"
"function registerBroker ( address _broker ) external onlyOwner { require ( ! brokers [ _broker ] , ""already registered"" ) ; brokers [ _broker ] = true ; emit LogBrokerRegistered ( _broker ) ; }
","Approved an address to sign order-opening and withdrawals .
"
"function sendEther ( address to , uint value ) external validAddress ( to ) onlymanyowners ( sha3 ( msg . data ) ) requiresState ( State . SUCCEEDED ) { require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }
","owners : send ` value ` of ether to address ` to ` , can be called if crowdsale succeeded
"
"function newEtherDeposit ( uint _block ) public onlyOwner payable returns ( uint _idDeposit ) { require ( msg . value > 0 ) ; require ( _block < block . number ) ; _idDeposit = deposits . length ++ ; Deposit storage d = deposits [ _idDeposit ] ; d . block = _block == 0 ? block . number - 1 : _block ; d . token = ERC20 ( 0 ) ; d . amount = msg . value ; NewDeposit ( _idDeposit , ERC20 ( 0 ) , msg . value ) ; }
","Adds an ether deposit to ` deposits [ ] ` ; only the ` owner ` can deposit into this contract
"
"function transactionReplay ( address _receiver , uint256 _amount ) public onlyOwner returns ( bool replayed ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; return true ; }
","Can also be used for general bulk transfers via the associated python script
"
"function cumulative ( uint256 euroUlps ) public pure returns ( uint256 neumarkUlps ) { if ( euroUlps >= ISSUANCE_LIMIT_EUR_ULPS ) { return NEUMARK_CAP ; } if ( euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS ) { return NEUMARKS_AT_LINEAR_LIMIT_ULPS + ( TOT_LINEAR_NEUMARKS_ULPS * ( euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS ) ) / TOT_LINEAR_EUR_ULPS ; } uint256 d = 230769230769230769230769231 ; uint256 term = NEUMARK_CAP ; uint256 sum = 0 ; uint256 denom = d ; do assembly { term := div ( mul ( term , euroUlps ) , denom ) sum := add ( sum , term ) denom := add ( denom , d ) term := div ( mul ( term , euroUlps ) , denom ) sum := sub ( sum , term ) denom := add ( denom , d ) } while ( term != 0 ) ; return sum ; }
","finds total amount of neumarks issued for given amount of Euro
"
"function issueSoftcapToken ( address _token , address _for , uint _value ) onlyOracle onlyAllowed ( _for ) onlySale notSoftcapReached public returns ( uint ) { require ( _token == token ) ; require ( _value != 0 ) ; uint _tokenSoftcap = tokenSoftcap ; uint _issued = tokenSoftcapIssued ; if ( _issued . add ( _value ) > _tokenSoftcap ) { _value = _tokenSoftcap . sub ( _issued ) ; } tokenSoftcapIssued = _issued . add ( _value ) ; if ( ! Token ( _token ) . transfer ( _for , _value ) ) { revert ( ) ; } _emitEmission ( Token ( _token ) . smbl ( ) , _for , _value ) ; return OK ; }
","Issue tokens for user .
"
"function burnTokens ( uint256 _tokens ) external ;
","Called when tokens have to be burned
"
"function transfer ( address _to , uint256 _amount ) public erc20 returns ( bool success ) { doSend ( msg . sender , msg . sender , _to , _amount , """" , """" , false ) ; return true ; }
","ERC20 backwards compatible transfer .
"
"function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || ( ! mIsUserNotAcceptingAllOfficialOperators [ _tokenHolder ] && mIsOfficialOperator [ _operator ] ) || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }
","Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address .
"
"function withdrawMyDepositedNomins ( ) external { uint nominsToSend = 0 ; for ( uint i = depositStartIndex ; i < depositEndIndex ; i ++ ) { nominDeposit memory deposit = deposits [ i ] ; if ( deposit . user == msg . sender ) { nominsToSend = safeAdd ( nominsToSend , deposit . amount ) ; delete deposits [ i ] ; } } totalSellableDeposits = safeSub ( totalSellableDeposits , nominsToSend ) ; nominsToSend = safeAdd ( nominsToSend , smallDeposits [ msg . sender ] ) ; smallDeposits [ msg . sender ] = 0 ; require ( nominsToSend > 0 , ""You have no deposits to withdraw."" ) ; nomin . transfer ( msg . sender , nominsToSend ) ; emit NominWithdrawal ( msg . sender , nominsToSend ) ; }
","Allows a user to withdraw all of their previously deposited nomins from this contract if needed .
"
"function canTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) ;
","Check if a transfer of the NFT with ID ` tokenId ` on behalf of account ` from ` to a recipient at account ` to ` with ` msg.value ` of ` value ` is approved .
"
"function acceptBuyOffer ( uint32 _canvasId , uint _minPrice ) external stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; require ( canvas . owner == msg . sender ) ; BuyOffer memory offer = buyOffers [ _canvasId ] ; require ( offer . hasOffer ) ; require ( offer . amount > 0 ) ; require ( offer . buyer != 0x0 ) ; require ( offer . amount >= _minPrice ) ; uint fee = _calculateCommission ( offer . amount ) ; uint toTransfer = offer . amount - fee ; addressToCount [ canvas . owner ] -- ; addressToCount [ offer . buyer ] ++ ; canvas . owner = offer . buyer ; addPendingWithdrawal ( msg . sender , toTransfer ) ; addPendingWithdrawal ( owner , fee ) ; buyOffers [ _canvasId ] = BuyOffer ( false , 0x0 , 0 ) ; canvasForSale [ _canvasId ] = SellOffer ( false , 0x0 , 0 , 0x0 ) ; emit CanvasSold ( _canvasId , offer . amount , msg . sender , offer . buyer ) ; emit CommissionAddedToWithdrawals ( _canvasId , fee , ACTION_BUY_OFFER_ACCEPTED ) ; }
","Accepts buy offer for the canvas .
"
"function start ( ) isNotStartedOnly only ( owner ) { totalInCirculation = totalSupply ; isStarted = true ; }
","start normal operation of the token .
"
"function viewToken ( uint256 _tokenId ) external view returns ( uint256 tokenType_ , string tokenTitle_ , string tokenDescription_ ) { tokenType_ = tokenTypes [ _tokenId ] ; tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescription [ _tokenId ] ; }
","Returns all the relevant information about a specific token
"
"function getBalance ( address _acct ) external view returns ( uint256 ) { return balances [ _acct ] ; }
","Get ` _acct ` balance
"
"function getPrice ( ) external view returns ( uint256 ) { require ( latestUpdate >= now - staleTime ) ; return POLYUSD ; }
","Returns price - should throw if not valid
"
"function totalSupply ( ) public view returns ( uint _totalSupply ) { _totalSupply = activeLoans ; }
","Returns the number of active loans in total , active loans are the loans with `` lent '' status .
"
"function setAccountSpendingAmount ( Data storage self , address account , uint amount ) internal returns ( bool success ) { require ( updateAccountSpendingPeriod ( self , account ) , ""Error: Unable to update account spending period."" ) ; uint updatedAmount = getAccountSpendingAmount ( self , account ) . add ( amount ) ; require ( getAccountSpendingLimit ( self , account ) >= updatedAmount , ""Error: Account cannot exceed its daily spend limit."" ) ; bytes32 id = keccak256 ( abi . encodePacked ( 'account.spending.amount' , account , getAccountSpendingPeriod ( self , account ) ) ) ; require ( self . Storage . setUint ( id , updatedAmount ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set the account spending amount for the daily period
"
"function getToken ( uint256 _tokenId ) public view returns ( string tokenName , uint256 parentId , uint256 sellingPrice , address owner ) { Token storage token = tokenIndexToToken [ _tokenId ] ; tokenName = token . name ; parentId = token . parentId ; sellingPrice = tokenIndexToPrice [ _tokenId ] ; owner = tokenIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific token .
"
"function issueHardcapToken ( address _token , address _for , uint _value ) onlyOracle onlyAllowed ( _for ) onlySale notHardcapReached public returns ( uint ) { require ( _token == token ) ; require ( _value != 0 ) ; uint _tokenHardcap = tokenHardcapValue ; uint _issued = tokenHardcapIssuedValue ; if ( _issued . add ( _value ) > _tokenHardcap ) { _value = _tokenHardcap . sub ( _issued ) ; } tokenHardcapIssuedValue = _issued . add ( _value ) ; bytes32 _symbol = Token ( _token ) . smbl ( ) ; if ( OK != Platform ( Token ( _token ) . platform ( ) ) . reissueAsset ( _symbol , _value ) ) { revert ( ) ; } if ( ! Token ( _token ) . transfer ( _for , _value ) ) { revert ( ) ; } _emitEmission ( _symbol , _for , _value ) ; return OK ; }
","Issue tokens for user .
"
"function ( ) external payable { exchangeEtherForNomins ( ) ; }
","Fallback function ( exchanges ETH to nUSD )
"
"function invokeTop ( ) public returns ( uint ) ;
","Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { return erc20Impl . transferWithSender ( msg . sender , _to , _value ) ; }
","Transfers ` _value ` amount of tokens to address ` _to ` .
"
"function isSecurityToken ( address _securityToken ) external view returns ( bool ) { return ( keccak256 ( bytes ( getString ( Encoder . getKey ( ""securityTokens_ticker"" , _securityToken ) ) ) ) != keccak256 ( """" ) ) ; }
","Checks that Security Token is registered
"
"function getkEthPhiRate ( ) public constant returns ( uint ) { return ethUsd . mul ( 1000 ) . div ( phiRate ) ; }
","It divides ( ETH/USD rate ) / ( PHI/USD rate )
"
"function getAuction ( uint256 _deedId ) external view returns ( address seller , uint256 startPrice , uint256 endPrice , uint256 duration , uint256 startedAt ) { Auction storage auction = identifierToAuction [ _deedId ] ; require ( _activeAuction ( auction ) ) ; return ( auction . seller , auction . startPrice , auction . endPrice , auction . duration , auction . startedAt ) ; }
","Get the auction for the given deed .
"
"function getVillain ( uint256 _tokenId ) public view returns ( uint256 id , string villainName , uint256 sellingPrice , address owner , uint256 class , uint256 level , uint256 numSkillActive , uint256 state , uint256 zappedExipryTime , uint256 buyPrice , uint256 nextPrice , uint256 affectedByToken ) { id = _tokenId ; Villain storage villain = villains [ _tokenId ] ; villainName = villain . name ; sellingPrice = villainIndexToPrice [ _tokenId ] ; owner = villainIndexToOwner [ _tokenId ] ; class = villain . class ; level = villain . level ; numSkillActive = villain . numSkillActive ; state = villain . state ; if ( villain . state == 1 && now > villain . zappedExipryTime ) { state = 0 ; } zappedExipryTime = villain . zappedExipryTime ; buyPrice = villain . buyPrice ; nextPrice = calculateNewPrice ( _tokenId ) ; affectedByToken = villain . affectedByToken ; }
","Returns all the relevant information about a specific villain .
"
"function migrateLink ( address _currentAddress , address _newAddress ) external onlyDuringInitialization { require ( linkIds [ _newAddress ] == 0 ) ; if ( linkIds [ _currentAddress ] == 0 ) { linkIds [ _currentAddress ] = ++ linkCounter ; } linkIds [ _newAddress ] = linkIds [ _currentAddress ] ; emit AddressLinked ( _currentAddress , _newAddress , linkIds [ _currentAddress ] ) ; }
","Submit link completed prior to deployment of this contract
"
"function totalSupply ( ) public view returns ( uint256 ) { return erc20Store . totalSupply ( ) ; }
","Core logic of the ERC20 ` totalSupply ` function .
"
"function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) ;
","minimum amount of funding to consider the sale as successful ( in euro-cents )
"
"function getGameAmounts ( uint gameId ) public view returns ( uint , uint , uint , uint , uint ) { return ( games [ gameId ] . amountToTeamA , games [ gameId ] . amountToDraw , games [ gameId ] . amountToTeamB , games [ gameId ] . bettorsCount , games [ gameId ] . frozenTimestamp ) ; }
","Returns all the info related to the bets
"
"function buy ( ) payable public { require ( ! frozenAccount [ msg . sender ] ) ; require ( msg . value > 0 ) ; uint commission = msg . value / buyRate ; require ( address ( this ) . send ( commission ) ) ; buyToken ( ) ; }
","Buy metadollars from contract by sending ether
"
"function enableTransfers ( bool _transfersEnabled ) public onlyControllerorOwner { transfersEnabled = _transfersEnabled ; }
","Enables token holders to transfer their tokens freely if true
"
"function doBuyerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return false ; } uint128 _gasFees = _escrow . totalGasFeesSpentByRelayer + ( msg . sender == relayer ? ( GAS_doBuyerCancel + _additionalGas ) * uint128 ( tx . gasprice ) : 0 ) ; delete escrows [ _tradeHash ] ; emit CancelledByBuyer ( _tradeHash ) ; transferMinusFees ( _seller , _value , _gasFees , 0 ) ; return true ; }
","Cancels the trade and returns the ether to the seller .
"
"function setTokenNameSpace ( Data storage self , string currency ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.namespace' , currency ) ) ; require ( self . Storage . setAddress ( id , address ( this ) ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set contract interface associated with a given TokenIO currency symbol ( e.g .
"
"function setTransfersAllowed ( bool _allow ) onlyOwner public { transfersAllowed = _allow ; }
","` onlyOwner ` changes the setting to allow transfer tokens
"
"function multiTransfer ( uint [ 2 ] [ ] _t ) returns ( bool success ) { }
","send a set of token to different address
"
"function getTokenIndex ( uint256 _tokenId ) validId ( _tokenId ) public view returns ( uint64 ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return lookupData . tokenIndex ; }
","Get the index of PixelCon ` ( _tokenId ) `
"
"function distribute ( uint256 rounds ) external { for ( uint256 i = 0 ; i < rounds ; i ++ ) { if ( address ( this ) . balance < 0.001 ether ) { break ; } MOBContract . buy . value ( address ( this ) . balance ) ( 0x0 ) ; MOBContract . exit ( ) ; } }
","Distribute dividends to the MOB contract .
"
"function verifyTransfer ( address _from , address _to , uint256 _amount , bytes , bool ) public returns ( Result ) { if ( ! paused ) { if ( _from == address ( 0 ) && allowPrimaryIssuance ) { return Result . NA ; } if ( whitelist [ _to ] ) { return Result . NA ; } uint256 newBalance = ISecurityToken ( securityToken ) . balanceOf ( _to ) . add ( _amount ) ; if ( newBalance . mul ( uint256 ( 10 ) ** 18 ) . div ( ISecurityToken ( securityToken ) . totalSupply ( ) ) > maxHolderPercentage ) { return Result . INVALID ; } return Result . NA ; } return Result . NA ; }
","Used to verify the transfer transaction and prevent a given account to end up with more tokens than allowed
"
"function togglePlotBlockedTag ( uint256 plotIndex , bool plotBlocked ) onlyOwner external { require ( plotIndex >= 0 ) ; require ( plotIndex < ownership . length ) ; plotBlockedTags [ plotIndex ] = plotBlocked ; }
","Sets whether or not the image data in a plot should be blocked from the EthPlot UI .
"
"function mint ( address _to , string _tokenURI ) external onlyOwner { uint currentId = tokenId ++ ; _mint ( _to , currentId ) ; _setTokenURI ( currentId , _tokenURI ) ; }
","Mint a single instance of the token only the current contract owner can do that
"
"function changeGroupActiveStatus ( bytes32 _groupName , bool _blocked ) external onlyContractOwner returns ( uint ) { require ( isGroupExists ( _groupName ) ) ; groupsBlocked [ _groupName ] = _blocked ; return OK ; }
","Change group status Can be called only by contract owner
"
"function generateSecurityToken ( string _name , string _symbol , string _tokenDetails , bool _divisible ) public whenNotPaused { require ( bytes ( _name ) . length > 0 && bytes ( _symbol ) . length > 0 , ""Name and Symbol string length should be greater than 0"" ) ; require ( ITickerRegistry ( tickerRegistry ) . checkValidity ( _symbol , msg . sender , _name ) , ""Trying to use non-valid symbol"" ) ; if ( registrationFee > 0 ) require ( ERC20 ( polyToken ) . transferFrom ( msg . sender , this , registrationFee ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; string memory symbol = upper ( _symbol ) ; address newSecurityTokenAddress = ISTProxy ( protocolVersionST [ protocolVersion ] ) . deployToken ( _name , symbol , 18 , _tokenDetails , msg . sender , _divisible , polymathRegistry ) ; securityTokens [ newSecurityTokenAddress ] = SecurityTokenData ( symbol , _tokenDetails ) ; symbols [ symbol ] = newSecurityTokenAddress ; emit LogNewSecurityToken ( symbol , newSecurityTokenAddress , msg . sender ) ; }
","Creates a new Security Token and saves it to the registry
"
"function setRBACAddress ( address rbacAddr ) public onlyOwnerOrAdmin { rbac = RBACInterface ( rbacAddr ) ; }
","Change the address of the deployed RBAC contract which controls access .
"
"function performBuyOrder ( OrderData data , uint256 amountToGiveForOrder ) public payable whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = BancorConverter ( data . converterAddress ) . quickConvert . value ( msg . value ) ( trimAddressArray ( data . conversionPath ) , amountToGiveForOrder , data . minReturn ) ; if ( ! ERC20SafeTransfer . safeTransfer ( data . destinationToken , totlePrimary , amountReceivedFromOrder ) ) { errorReporter . revertTx ( ""Failed to transfer tokens to totle primary"" ) ; } }
","Perform a buy order at the exchange
"
"function finishTokenMinting ( ) onlyOwner public { token . finishMinting ( ) ; }
","Finish token minting .
"
"function get_rate ( ) constant returns ( uint256 ) { if ( now < tCampaignStart ) return 0 ; if ( now > tCampaignEnd ) return 0 ; if ( now <= tBonusStageEnd ) return scale * ( baseRate + bonusAdd ) ; if ( now <= t_1st_StageEnd ) return scale * ( baseRate + stage_1_add ) ; else if ( now <= t_2nd_StageEnd ) return scale * ( baseRate + stage_2_add ) ; else if ( now <= t_3rd_StageEnd ) return scale * ( baseRate + stage_3_add ) ; else return baseRate * scale ; }
","computes the current rate according to time passed since the start
"
"function collateral ( address account ) public view returns ( uint ) { uint bal = tokenState . balanceOf ( account ) ; if ( escrow != address ( 0 ) ) { bal = safeAdd ( bal , escrow . balanceOf ( account ) ) ; } return bal ; }
","The total havvens owned by this account , both escrowed and unescrowed , against which nomins can be issued .
"
"function approveAndCall ( address spender , uint256 amount , bytes extraData ) public returns ( bool success ) { require ( approve ( spender , amount ) ) ; success = IERC677Callback ( spender ) . receiveApproval ( msg . sender , amount , this , extraData ) ; require ( success ) ; return true ; }
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function buyTokens ( ) public payable whenNotPaused { require ( validPurchase ( ) ) ; uint256 tokens = 0 ; uint256 amountPaid = calculateExcessBalance ( ) ; if ( tokensRaised < limitTier1 ) { tokens = amountPaid . mul ( rate ) ; if ( tokensRaised . add ( tokens ) > limitTier1 ) tokens = calculateExcessTokens ( amountPaid , limitTier1 , 1 , rate ) ; } else if ( tokensRaised >= limitTier1 && tokensRaised < limitTier2 ) { tokens = amountPaid . mul ( rateTier2 ) ; if ( tokensRaised . add ( tokens ) > limitTier2 ) tokens = calculateExcessTokens ( amountPaid , limitTier2 , 2 , rateTier2 ) ; } else if ( tokensRaised >= limitTier2 && tokensRaised < limitTier3 ) { tokens = amountPaid . mul ( rateTier3 ) ; if ( tokensRaised . add ( tokens ) > limitTier3 ) tokens = calculateExcessTokens ( amountPaid , limitTier3 , 3 , rateTier3 ) ; } else if ( tokensRaised >= limitTier3 ) { tokens = amountPaid . mul ( rateTier4 ) ; } weiRaised = weiRaised . add ( amountPaid ) ; uint256 tokensRaisedBeforeThisTransaction = tokensRaised ; tokensRaised = tokensRaised . add ( tokens ) ; token . distributeICOTokens ( msg . sender , tokens ) ; tokensBought [ msg . sender ] = tokensBought [ msg . sender ] . add ( tokens ) ; TokenPurchase ( msg . sender , amountPaid , tokens ) ; numberOfTransactions = numberOfTransactions . add ( 1 ) ; if ( tokensRaisedBeforeThisTransaction > minimumGoal ) { walletB . transfer ( amountPaid ) ; } else { vault . deposit . value ( amountPaid ) ( msg . sender ) ; if ( goalReached ( ) ) { vault . close ( ) ; } } checkCompletedCrowdsale ( ) ; }
","To buy tokens given an address
"
"function getCompletedGamesStatistics ( ) public view returns ( uint , uint ) { uint completed = 0 ; uint ethPaid = 0 ; for ( uint i = 1 ; i <= allBoards . length ; i ++ ) { GoBoard storage board = allBoards [ i - 1 ] ; if ( ( board . status == BoardStatus . BlackWin ) || ( board . status == BoardStatus . WhiteWin ) ) { ++ completed ; ethPaid += board . tableStakes . mul ( 2 ) ; } } return ( completed , ethPaid ) ; }
","We would like to easily and transparantly share the game 's statistics with anyone and present on the web-app
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool ) ;
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf
"
"function burn ( uint256 _tokenId ) auth ( BURN_ROLE ) public { require ( msg . sender == _ownerOf ( _tokenId ) ) ; _burn ( _ownerOf ( _tokenId ) , _tokenId ) ; }
","Burn tokenId : ` _tokenId `
"
"function createQuest ( bytes32 _quest , uint _reward ) public onlyMinter returns ( bool ) { require ( _reward <= maxQuestReward ) ; require ( block . number . sub ( questTimer ) > questPeriodicity ) ; _reward = _reward * ( 10 ** uint256 ( decimals ) ) ; require ( _reward . add ( totalSupply ( ) ) < MAX_SUPPLY ) ; questTimer = block . number ; questReward [ _quest ] = _reward ; emit NewQuestEvent ( _reward , block . number - startblock ) ; return true ; }
","_reward is exact number of whole tokens
"
"function getRaised ( FundRaiseType _fundRaiseType ) public view returns ( uint256 ) { return fundsRaised [ uint8 ( _fundRaiseType ) ] ; }
","Returns funds raised by the STO
"
"function setTokenPriceProposal ( uint _initialPriceMultiplier , uint _inflationRate , uint _closingTime ) ;
","Function that allow the contractor to propose a token price
"
"function getFinalAnswerIfMatches ( bytes32 question_id , bytes32 content_hash , address arbitrator , uint32 min_timeout , uint256 min_bond ) stateFinalized ( question_id ) external constant returns ( bytes32 ) { require ( content_hash == questions [ question_id ] . content_hash ) ; require ( arbitrator == questions [ question_id ] . arbitrator ) ; require ( min_timeout <= questions [ question_id ] . timeout ) ; require ( min_bond <= questions [ question_id ] . bond ) ; return questions [ question_id ] . best_answer ; }
","Return the final answer to the specified question , provided it matches the specified criteria .
"
"function transferCheck ( address _sender , address _receiver , uint256 _amount ) private constant returns ( bool success ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] . sub ( _amount ) >= 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > balances [ _receiver ] ) ; return true ; }
","Reusable code to do sanity check of transfer variables
"
"function requestDetachment ( uint256 _tokenId ) public { require ( isApprovedOrOwner ( msg . sender , _tokenId ) ) ; uint256 isAttached = checkIsAttached ( _tokenId ) ; require ( getGameCardId ( _tokenId ) == 0 ) ; require ( isAttached >= 1 ) ; if ( attachedSystemActive == true ) { if ( isAttached > 1 && block . timestamp - isAttached > detachmentTime ) { isAttached = 0 ; } else if ( isAttached > 1 ) { require ( isAttached == 1 ) ; } else { isAttached = block . timestamp ; } } else { isAttached = 0 ; } updateIsAttached ( _tokenId , isAttached ) ; }
","a wallet can request to detach it collectible , so , that it can be used in other third-party contracts .
"
"function initialize ( address _polymathRegistry , address _STFactory , uint256 _stLaunchFee , uint256 _tickerRegFee , address _polyToken , address _owner ) external payable { require ( ! getBool ( INITIALIZE ) , ""already initialized"" ) ; require ( _STFactory != address ( 0 ) && _polyToken != address ( 0 ) && _owner != address ( 0 ) && _polymathRegistry != address ( 0 ) , ""Invalid address"" ) ; require ( _stLaunchFee != 0 && _tickerRegFee != 0 , ""Fees should not be 0"" ) ; set ( POLYTOKEN , _polyToken ) ; set ( STLAUNCHFEE , _stLaunchFee ) ; set ( TICKERREGFEE , _tickerRegFee ) ; set ( EXPIRYLIMIT , uint256 ( 60 * 1 days ) ) ; set ( PAUSED , false ) ; set ( OWNER , _owner ) ; set ( POLYMATHREGISTRY , _polymathRegistry ) ; _setProtocolVersion ( _STFactory , uint8 ( 2 ) , uint8 ( 0 ) , uint8 ( 0 ) ) ; set ( INITIALIZE , true ) ; }
","Initializes instance of STR
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalKydys = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 kydyId ; for ( kydyId = 1 ; kydyId <= totalKydys ; kydyId ++ ) { if ( kydyIndexToOwner [ kydyId ] == _owner ) { result [ resultIndex ] = kydyId ; resultIndex ++ ; } } return result ; } }
","Returns a list of all Kydy IDs assigned to an address .
"
"function getIpfsForAssets ( uint [ ] _ids ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory hashes = new bytes32 [ ] ( _ids . length ) ; for ( uint i = 0 ; i < _ids . length ; i ++ ) { Asset memory asset = assets [ _ids [ i ] ] ; hashes [ i ] = asset . ipfsHash ; } return hashes ; }
","Function to get array of ipfsHashes for specific assets
"
"function reissueAssetToRecepient ( bytes32 _symbol , uint _value , address _to ) public onlyDesignatedManager ( _symbol ) onlyAfterBlock ( _symbol ) returns ( uint ) { return _reissueAsset ( _symbol , _value , _to ) ; }
","Issues additional asset tokens ` _symbol ` if the asset have dynamic supply and sends them to recepient address ` _to ` .
"
"function trade ( TradeInput tradeInput ) internal returns ( uint ) { require ( isEnabled ) ; require ( tx . gasprice <= maxGasPriceValue ) ; require ( validateTradeInput ( tradeInput . src , tradeInput . srcAmount , tradeInput . dest , tradeInput . destAddress ) ) ; BestRateResult memory rateResult = findBestRateTokenToToken ( tradeInput . src , tradeInput . dest , tradeInput . srcAmount , tradeInput . hint ) ; require ( rateResult . rate > 0 ) ; require ( rateResult . rate < MAX_RATE ) ; require ( rateResult . rate >= tradeInput . minConversionRate ) ; uint actualDestAmount ; uint weiAmount ; uint actualSrcAmount ; ( actualSrcAmount , weiAmount , actualDestAmount ) = calcActualAmounts ( tradeInput . src , tradeInput . dest , tradeInput . srcAmount , tradeInput . maxDestAmount , rateResult ) ; require ( getUserCapInWei ( tradeInput . trader ) >= weiAmount ) ; require ( handleChange ( tradeInput . src , tradeInput . srcAmount , actualSrcAmount , tradeInput . trader ) ) ; require ( doReserveTrade ( tradeInput . src , actualSrcAmount , ETH_TOKEN_ADDRESS , this , weiAmount , KyberReserveInterface ( rateResult . reserve1 ) , rateResult . rateSrcToEth , true ) ) ; require ( doReserveTrade ( ETH_TOKEN_ADDRESS , weiAmount , tradeInput . dest , tradeInput . destAddress , actualDestAmount , KyberReserveInterface ( rateResult . reserve2 ) , rateResult . rateEthToDest , true ) ) ; if ( tradeInput . src != ETH_TOKEN_ADDRESS ) require ( feeBurnerContract . handleFees ( weiAmount , rateResult . reserve1 , tradeInput . walletId ) ) ; if ( tradeInput . dest != ETH_TOKEN_ADDRESS ) require ( feeBurnerContract . handleFees ( weiAmount , rateResult . reserve2 , tradeInput . walletId ) ) ; KyberTrade ( { trader : tradeInput . trader , src : tradeInput . src , dest : tradeInput . dest , srcAmount : actualSrcAmount , dstAmount : actualDestAmount , destAddress : tradeInput . destAddress , ethWeiValue : weiAmount , reserve1 : ( tradeInput . src == ETH_TOKEN_ADDRESS ) ? address ( 0 ) : rateResult . reserve1 , reserve2 : ( tradeInput . dest == ETH_TOKEN_ADDRESS ) ? address ( 0 ) : rateResult . reserve2 , hint : tradeInput . hint } ) ; return actualDestAmount ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function getPlayerId ( uint256 _tokenId ) external view returns ( uint256 playerId ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; playerId = ( ( obj . attributes . div ( 100000000000000000 ) ) % 1000 ) ; }
","Gets the MLB player Id from the player attributes
"
"function generateTokens ( address _user , uint _amount ) onlyController public returns ( bool ) { require ( balanceOf [ owner ] >= _amount ) ; balanceOf [ _user ] += _amount ; balanceOf [ owner ] -= _amount ; Transfer ( 0 , _user , _amount ) ; return true ; }
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public whenNotPaused { require ( isOperatorFor ( msg . sender , _from ) , ""Only an approved operator can use operatorSend"" ) ; doSend ( _from , _to , _amount , _userData , msg . sender , _operatorData , true ) ; }
","Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
"
"function isValidSignatureAndData ( address _address , bytes _sig ) internal view returns ( bool ) { require ( msg . data . length > SIGNATURE_SIZE ) ; bytes memory data = new bytes ( msg . data . length - SIGNATURE_SIZE ) ; for ( uint i = 0 ; i < data . length ; i ++ ) { data [ i ] = msg . data [ i ] ; } return isValidDataHash ( keccak256 ( abi . encodePacked ( address ( this ) , _address , data ) ) , _sig ) ; }
","the _sig parameter of the method being validated must be the `` last '' parameter
"
"function _removeToken ( address _from , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _from , ""wrong owner"" ) ; uint256 tokenIndex = tokenOwnerAndTokensIndex [ _tokenId ] . tokenIndex ; uint256 lastTokenIndex = ownedTokens [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownedTokens [ _from ] [ lastTokenIndex ] ; ownedTokens [ _from ] [ tokenIndex ] = lastToken ; ownedTokens [ _from ] . length -- ; tokenOwnerAndTokensIndex [ lastToken ] = AddressAndTokenIndex ( { owner : _from , tokenIndex : uint32 ( tokenIndex ) } ) ; }
","Internal function to remove a token ID from the list of a given address
"
"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function getBasicData ( uint64 [ ] _indexes ) public view returns ( uint64 [ ] , address [ ] , uint256 [ ] , uint64 [ ] ) { uint64 [ ] memory tokenIndexes = new uint64 [ ] ( _indexes . length ) ; address [ ] memory sellers = new address [ ] ( _indexes . length ) ; uint256 [ ] memory currPrices = new uint256 [ ] ( _indexes . length ) ; uint64 [ ] memory timeLeft = new uint64 [ ] ( _indexes . length ) ; for ( uint i = 0 ; i < _indexes . length ; i ++ ) { Listing storage listing = marketPixelconListings [ _indexes [ i ] ] ; if ( listing . seller != address ( 0 ) ) { tokenIndexes [ i ] = _indexes [ i ] ; sellers [ i ] = listing . seller ; currPrices [ i ] = calcCurrentPrice ( uint256 ( listing . startAmount ) , uint256 ( listing . endAmount ) , uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; timeLeft [ i ] = calcTimeLeft ( uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; } else { tokenIndexes [ i ] = 0 ; sellers [ i ] = 0 ; currPrices [ i ] = 0 ; timeLeft [ i ] = 0 ; } } return ( tokenIndexes , sellers , currPrices , timeLeft ) ; }
","Get market listing data for the given indexes
"
"function ( ) payable { buyTokens ( ) ; }
","Fallback function to buy tokens
"
"function addNotaryToOrder ( address orderAddr , address notary , uint256 responsesPercentage , uint256 notarizationFee , string notarizationTermsOfService , bytes notarySignature ) public whenNotPaused isOrderLegit ( orderAddr ) validAddress ( notary ) returns ( bool ) { DataOrder order = DataOrder ( orderAddr ) ; address buyer = order . buyer ( ) ; require ( msg . sender == buyer ) ; require ( ! order . hasNotaryBeenAdded ( notary ) ) ; require ( allowedNotaries . exist ( notary ) ) ; require ( CryptoUtils . isNotaryAdditionValid ( orderAddr , notary , responsesPercentage , notarizationFee , notarizationTermsOfService , notarySignature ) ) ; bool okay = order . addNotary ( notary , responsesPercentage , notarizationFee , notarizationTermsOfService ) ; if ( okay ) { openOrders . insert ( orderAddr ) ; ordersByNotary [ notary ] . push ( orderAddr ) ; emit NotaryAddedToOrder ( order , notary ) ; } return okay ; }
","Adds a notary to the Data Order .
"
"function triggerRecovery ( uint ein , address newAssociatedAddress , uint8 v , bytes32 r , bytes32 s , uint timestamp ) public _identityExists ( ein ) _hasIdentity ( newAssociatedAddress , false ) ensureSignatureTimeValid ( timestamp ) { require ( canRecover ( ein ) , ""Cannot trigger recovery yet."" ) ; Identity storage _identity = identityDirectory [ ein ] ; if ( canChangeRecoveryAddress ( ein ) ) { require ( msg . sender == _identity . recoveryAddress , ""Only the current recovery address can trigger recovery."" ) ; } else { require ( msg . sender == recoveryAddressChangeLogs [ ein ] . oldRecoveryAddress , ""Only the recently removed recovery address can trigger recovery."" ) ; } require ( isSigned ( newAssociatedAddress , keccak256 ( abi . encodePacked ( byte ( 0x19 ) , byte ( 0 ) , address ( this ) , ""I authorize being added to this Identity via recovery."" , ein , newAssociatedAddress , timestamp ) ) , v , r , s ) , ""Permission denied."" ) ; recoveryLogs [ ein ] = Recovery ( block . timestamp , keccak256 ( abi . encodePacked ( _identity . associatedAddresses . members ) ) ) ; emit RecoveryTriggered ( msg . sender , ein , _identity . associatedAddresses . members , newAssociatedAddress ) ; resetIdentityData ( _identity , msg . sender , false ) ; addAssociatedAddress ( ein , newAssociatedAddress ) ; }
","Allows recovery addresses to trigger the recovery process for an Identity .
"
"function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) external returns ( address ) { address newSecurityTokenAddress = new SecurityToken ( _name , _symbol , _decimals , _divisible ? 1 : uint256 ( 10 ) ** _decimals , _tokenDetails , _polymathRegistry ) ; SecurityToken ( newSecurityTokenAddress ) . addModule ( transferManagerFactory , """" , 0 , 0 ) ; SecurityToken ( newSecurityTokenAddress ) . transferOwnership ( _issuer ) ; return newSecurityTokenAddress ; }
","deploys the token and adds default modules like the GeneralTransferManager .
"
"function setSecurityGuard ( address _newSecurityGuard ) onlyContractOwner { securityGuard = _newSecurityGuard ; }
","` onlyOwner ` Sets the address of ` securityGuard `
"
"function getTitle ( ) public view returns ( string ) { return ""Capped STO"" ; }
","Get the title of the Module
"
"function isAbsent ( bytes32 channelId ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; return channel . sender == 0 ; }
","Check if the channel is not present .
"
"function rewardBounty ( address _beneficiary , uint256 _amount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , ""Beneficiary is not whitelisted"" ) ; uint256 amount = _amount . mul ( E18 ) ; require ( totalSupply_ . add ( amount ) < TOTAL_SUPPLY_LIMIT ) ; require ( amount <= TOKEN_SUPPLY_BOUNTY_LIMIT ) ; uint256 remainingTokens = TOKEN_SUPPLY_BOUNTY_LIMIT . sub ( bountyTokenIssuedTotal ) ; if ( amount > remainingTokens ) { amount = remainingTokens ; } balances [ _beneficiary ] = balances [ _beneficiary ] . add ( amount ) ; bountyTokenIssuedTotal = bountyTokenIssuedTotal . add ( amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; emit Transfer ( address ( BOUNTY_EVENT ) , _beneficiary , amount ) ; }
","Reward Bounty Participant .
"
"function onTransfer ( address broker , address from , address to , uint256 amount ) public constant returns ( bool allow ) ;
","see MTokenTransferController
"
"function burnFrom ( address _from , uint256 _value ) onlyOwner public returns ( bool success ) { bool bAccountFrozen = frozenAccount ( _from ) ; if ( bAccountFrozen ) { freezeAccount ( _from , false ) ; } _transfer ( _from , _owner , _value ) ; if ( bAccountFrozen ) { freezeAccount ( _from , bAccountFrozen ) ; } burn ( _value ) ; return true ; }
","Destroy tokens from other account , can be run only by owner Remove ` _value ` tokens from the system irreversibly on behalf of ` _from ` .
"
"function setCEO ( address _newCEO ) external onlyCEO { require ( _newCEO != address ( 0 ) ) ; ceoAddress = _newCEO ; }
","Sets a new CEO
"
"function setBalanceOf ( address account , uint value ) external onlyAssociatedContract { balanceOf [ account ] = value ; }
","Set the balance in a given account
"
"function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { if ( isRegistered ( _to ) && isRegistered ( _from ) ) { return true ; } else { return false ; } }
","Notifies the controller about a transfer .
"
"function getSellerInfo ( address seller ) public view validAddress ( seller ) returns ( address , address , string , uint32 , uint32 , bytes32 ) { require ( hasSellerBeenAccepted ( seller ) ) ; SellerInfo memory info = sellerInfo [ seller ] ; return ( seller , info . notary , info . dataHash , uint32 ( info . createdAt ) , uint32 ( info . closedAt ) , getDataResponseStatusAsString ( info . status ) ) ; }
","Gets the seller information .
"
"function removeTokenGrant ( uint256 _grantId ) external onlyV12MultiSig { Grant storage tokenGrant = tokenGrants [ _grantId ] ; require ( tokenGrant . isActive , ""is not active"" ) ; address recipient = tokenGrant . recipient ; uint256 daysVested ; uint256 amountVested ; ( daysVested , amountVested ) = calculateGrantClaim ( _grantId ) ; uint256 amountNotVested = ( tokenGrant . amount . sub ( tokenGrant . totalClaimed ) ) . sub ( amountVested ) ; require ( token . transfer ( recipient , amountVested ) ) ; require ( token . transfer ( v12MultiSig , amountNotVested ) ) ; tokenGrant . startTime = 0 ; tokenGrant . amount = 0 ; tokenGrant . vestingDuration = 0 ; tokenGrant . vestingCliff = 0 ; tokenGrant . daysClaimed = 0 ; tokenGrant . totalClaimed = 0 ; tokenGrant . recipient = address ( 0 ) ; tokenGrant . isActive = false ; emit GrantRemoved ( recipient , amountVested , amountNotVested ) ; }
","Terminate token grant transferring all vested tokens to the ` _grantId ` and returning all non-vested tokens to the V12 MultiSig Secured to the V12 MultiSig only
"
"function changeController ( address _newController ) public onlyControllerorOwner { controller = _newController ; }
","Changes the controller of the contract
"
"function blacklistUserForTransfers ( address _user ) onlyOwner public { require ( isUserAllowedToTransfer ( _user ) ) ; transfersWhitelist [ _user ] = false ; UserAllowedToTransfer ( _user ) ; }
","Remove a user from the whitelist
"
"function burn ( uint256 _amount , bytes _holderData ) public onlyOwner { require ( msg . sender == mBurnOperator ) ; super . burn ( _amount , _holderData ) ; }
","Burns ` _amount ` tokens from ` _tokenHolder ` Silly example of overriding the ` burn ` function to only let the owner burn its tokens .
"
"function removePolicyRule ( bytes4 _sig , address _contract , bytes32 _groupName ) onlyContractOwner external returns ( uint ) { require ( _sig != bytes4 ( 0 ) ) ; require ( _contract != 0x0 ) ; require ( GroupsAccessManager ( accessManager ) . isGroupExists ( _groupName ) ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupNameIndex = _policy . groupName2index [ _groupName ] ; if ( _policyGroupNameIndex == 0 ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } uint _policyGroupsCount = _policy . groupsCount ; if ( _policyGroupNameIndex != _policyGroupsCount ) { Requirements storage _requirements = _policy . participatedGroups [ _policyGroupsCount ] ; _policy . participatedGroups [ _policyGroupNameIndex ] = _requirements ; _policy . groupName2index [ _requirements . groupName ] = _policyGroupNameIndex ; } _policy . totalAcceptedLimit = _policy . totalAcceptedLimit . sub ( _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit ) ; _policy . totalDeclinedLimit = _policy . totalDeclinedLimit . sub ( _policy . participatedGroups [ _policyGroupsCount ] . declineLimit ) ; delete _policy . groupName2index [ _groupName ] ; delete _policy . participatedGroups [ _policyGroupsCount ] ; _policy . groupsCount = _policyGroupsCount . sub ( 1 ) ; PolicyRuleRemoved ( _sig , _contract , _policyHash , _groupName ) ; return OK ; }
","Remove policy rule Can be called only by contract owner
"
"function withdrawERC20Token ( address tokenAddress , uint256 tokenAmount ) public onlyOwner returns ( bool success ) { return ERC20 ( tokenAddress ) . transfer ( owner , tokenAmount ) ; }
","Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract
"
"function getTitle ( ) public view returns ( string ) { return ""Percentage Transfer Manager"" ; }
","Get the title of the Module
"
"function isMinter ( address _who ) public view returns ( bool ) { return minters [ _who ] ; }
","Look up for the minter role on providen address
"
"function ( ) public { require ( false ) ; }
","If anybody sends Ether directly to this contract , consider the sender will be rejected .
"
"function unpause ( ) public onlyOwner { _unpause ( ) ; }
","pause registration function
"
"function checkFrozenAccounts ( address account ) constant returns ( bool accountIsFrozen ) { accountIsFrozen = frozenAccount [ account ] ; }
","Shows if account is frozen
"
"function addAddressesToAdmins ( address [ ] _admins ) external onlyOwner { require ( _admins . length > 0 , ""Cannot add an empty list to admins!"" ) ; for ( uint256 i = 0 ; i < _admins . length ; ++ i ) { address user = _admins [ i ] ; require ( user != address ( 0 ) , ""Cannot add the zero address to admins!"" ) ; if ( ! admins [ user ] ) { admins [ user ] = true ; emit AdminAdded ( user ) ; } } }
","Adds a list of addresses to the admins list .
"
"function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) ;
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function buyItem ( uint256 _id ) external payable whenNotPaused onlyNotOwnerOfItem ( _id ) itemIsForSale ( _id ) isPaid ( items [ _id ] . price ) distributeSaleInput ( itemToOwner [ _id ] ) { transferItem ( itemToOwner [ _id ] , msg . sender , _id ) ; }
","Buys item
"
"function getMintedActFromCurrentLockPeriod ( address _address ) private view returns ( uint256 ) { return lockedBbkPerUser [ _address ] . mul ( totalMintedActPerLockedBbkToken . sub ( mintedActPerUser [ _address ] ) ) . div ( 1e18 ) ; }
","Calculates minted ACT from `` Current Lock Period '' for a given address
"
"function migrate ( uint256 _value ) external nonReentrant isUpgrading { require ( _value > 0 ) ; require ( _value <= balances [ msg . sender ] ) ; require ( agent . isMigrationAgent ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; supply = supply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; if ( ! agent . migrateFrom ( msg . sender , _value ) ) { revert ( ) ; } Migrate ( msg . sender , agent , _value ) ; }
","Migrate tokens to the new token contract .
"
"function adjustInvestorCount ( address _from , address _to , uint256 _value ) internal { if ( ( _value == 0 ) || ( _from == _to ) ) { return ; } if ( ( balanceOf ( _to ) == 0 ) && ( _to != address ( 0 ) ) ) { investorCount = investorCount . add ( 1 ) ; } if ( _value == balanceOf ( _from ) ) { investorCount = investorCount . sub ( 1 ) ; } if ( ! investorListed [ _to ] && ( _to != address ( 0 ) ) ) { investors . push ( _to ) ; investorListed [ _to ] = true ; } }
","keeps track of the number of non-zero token holders
"
"function abort ( ) external withTimedTransitions ( ) onlyState ( State . Before ) only ( ROLE_WHITELIST_ADMIN ) { NEUMARK . burn ( NEUMARK . balanceOf ( this ) ) ; selfdestruct ( msg . sender ) ; }
","used by WHITELIST_ADMIN to kill commitment process before it starts
"
"function withdrawWithholding ( uint256 _dividendIndex ) external withPerm ( MANAGE ) { require ( _dividendIndex < dividends . length , ""Incorrect dividend index"" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 remainingWithheld = dividend . dividendWithheld . sub ( dividend . dividendWithheldReclaimed ) ; dividend . dividendWithheldReclaimed = dividend . dividendWithheld ; address owner = IOwnable ( securityToken ) . owner ( ) ; owner . transfer ( remainingWithheld ) ; emit EtherDividendWithholdingWithdrawn ( owner , _dividendIndex , remainingWithheld ) ; }
","Allows issuer to withdraw withheld tax
"
"function ownerClawbackCredits ( ) external onlyOwner { require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; require ( now >= OWNER_CLAWBACK_DATE ) ; require ( ! creditsClawbacked ) ; creditsClawbacked = true ; parsecToken . transfer ( owner , parsecToken . balanceOf ( this ) ) ; }
","The owner can clawback any unspent Parsec credits after a date in the future , so no Parsec credits remain trapped in this contract .
"
"function cancelGame ( uint256 _gameID , string _comment , uint256 _deadline ) external isActivated ( _gameID ) isOngoing ( _gameID ) onlyDevOrOwner ( ) { require ( _deadline >= now + 86400 , ""deadline must be more than one day later."" ) ; game_ [ _gameID ] . ended = true ; game_ [ _gameID ] . canceled = true ; game_ [ _gameID ] . gameEndComment = _comment ; game_ [ _gameID ] . withdrawDeadline = _deadline ; emit BMEvents . onGameCancelled ( _gameID , _comment , now ) ; }
","Cancel a game .
"
"function getUserGroups ( address _user ) public view returns ( bytes32 [ ] _groups ) { if ( ! isRegisteredUser ( _user ) ) { return ; } Member storage _member = address2member [ _user ] ; uint _groupsCount = _member . groupsCount ; if ( _groupsCount == 0 ) { return ; } _groups = new bytes32 [ ] ( _groupsCount ) ; for ( uint _groupIdx = 0 ; _groupIdx < _groupsCount ; ++ _groupIdx ) { uint _groupNameIdx = _member . index2globalIndex [ _groupIdx + 1 ] ; _groups [ _groupIdx ] = index2groupName [ _groupNameIdx ] ; } }
","Gets a list of groups where passed user is a member
"
"function countOfDeeds ( ) external view returns ( uint256 ) { return parts . length ; }
","Returns the total number of deeds currently in existence .
"
"function destroy ( address [ ] tokens ) onlyOwner { for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { ERC20Basic token = ERC20Basic ( tokens [ i ] ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }
","The called token contracts could try to re-enter this contract .
"
"function addReserve ( KyberReserve reserve , bool add ) public onlyAdmin { if ( add ) { require ( ! isReserve [ reserve ] ) ; reserves . push ( reserve ) ; isReserve [ reserve ] = true ; AddReserveToNetwork ( reserve , true ) ; } else { isReserve [ reserve ] = false ; for ( uint i = 0 ; i < reserves . length ; i ++ ) { if ( reserves [ i ] == reserve ) { reserves [ i ] = reserves [ reserves . length - 1 ] ; reserves . length -- ; AddReserveToNetwork ( reserve , false ) ; break ; } } } }
","can be called only by admin
"
"function release ( ) external nonReentrant onlyBeneficiary { uint256 unreleased = releasableAmount ( ) ; require ( unreleased > 0 ) ; released = released . add ( unreleased ) ; token . transfer ( beneficiary , unreleased ) ; emit Released ( unreleased ) ; }
","Transfers vested tokens to beneficiary .
"
"function setMinDai ( uint wad ) public auth { minDai = wad ; }
","set the minimal Dai for trades ( depends on otc )
"
"function getSupplyRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory utilizationRate0 , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory utilizationRate1 ) = mulScalar ( utilizationRate0 , oneMinusSpreadBasisPoints ) ; assert ( err1 == Error . NO_ERROR ) ; ( Error err2 , Exp memory supplyRate0 ) = mulExp ( utilizationRate1 , annualBorrowRate ) ; assert ( err2 == Error . NO_ERROR ) ; ( Error err3 , Exp memory supplyRate1 ) = divScalar ( supplyRate0 , 10000 * blocksPerYear ) ; assert ( err3 == Error . NO_ERROR ) ; return ( uint ( IRError . NO_ERROR ) , supplyRate1 . mantissa ) ; }
","Gets the current supply interest rate based on the given asset , total cash and total borrows
"
"function finalize ( ) onlyOwner { require ( stage ( ) == Stage . Closed ) ; uint256 unsold = publicSupply . sub ( soldOut . official ) . sub ( soldOut . channels ) ; if ( unsold > 0 ) { ven . offerBonus ( unsold ) ; } ven . seal ( ) ; finalized = true ; onFinalized ( ) ; }
","finalize
"
"function getBorrowRate ( address asset , uint cash , uint borrows ) public returns ( uint , uint ) { require ( isAllowed ( asset , cash ) ) ; ( IRError err0 , Exp memory _utilizationRate , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory borrowRate ) = divScalar ( annualBorrowRate , blocksPerYear ) ; assert ( err1 == Error . NO_ERROR ) ; _utilizationRate ; return ( uint ( IRError . NO_ERROR ) , borrowRate . mantissa ) ; }
","Gets the current borrow interest rate based on the given asset , total cash and total borrows
"
"function askQuestion ( uint256 template_id , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { require ( templates [ template_id ] > 0 , ""template must exist"" ) ; bytes32 content_hash = keccak256 ( abi . encodePacked ( template_id , opening_ts , question ) ) ; bytes32 question_id = keccak256 ( abi . encodePacked ( content_hash , arbitrator , timeout , msg . sender , nonce ) ) ; _askQuestion ( question_id , content_hash , arbitrator , timeout , opening_ts ) ; emit LogNewQuestion ( question_id , msg . sender , template_id , question , content_hash , arbitrator , timeout , opening_ts , nonce , now ) ; return question_id ; }
","Ask a new question and return the ID
"
"function settleWithdraw ( address from , uint256 amount , uint256 originalAmount , bytes32 withdrawTxHash , bytes32 reference ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) { emit LogWithdrawSettled ( from , msg . sender , amount , originalAmount , withdrawTxHash , reference ) ; }
","issued by deposit manager when withdraw request was settled .
"
"function getRewardsWithdrawn ( uint32 _canvasId , address _address ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _index = _history . addressToPaidRewardIndex [ _address ] ; uint _pixelsOwned = getPaintedPixelsCountByAddress ( _address , _canvasId ) ; if ( _history . rewardsCumulative . length == 0 || _index == 0 ) { return 0 ; } return ( _history . rewardsCumulative [ _index ] / PIXEL_COUNT ) * _pixelsOwned ; }
","Returns total amount of rewards that has been already paid ( added to pending withdrawals ) by a given address .
"
"function transfer ( address _to , uint _value , bytes _data ) public returns ( bool success ) { uint codeLength ; assembly { codeLength := extcodesize ( _to ) } require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract
"
"function distributeVariable ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { if ( timeGone ( index ) == true && getTokensBalance ( index ) >= airdrop . tokenAmount ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( ""Airdrop was NOT added"" ) ; }
","Distirbutes a differen quantity of tokens to all the specified addresses .
"
"function ( ) payable { require ( isPayableEnabled && rbInformationStore . isPayableEnabledForAll ( ) ) ; if ( msg . value <= 0 ) { revert ( ) ; } uint supportedAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) . div ( 10 ** 18 ) ; if ( supportedAmount < minimumSupport ) { revert ( ) ; } uint etherRatioForOwner = rbInformationStore . etherRatioForOwner ( ) ; uint etherRatioForSponsee = uint ( 100 ) . sub ( etherRatioForOwner ) . sub ( etherRatioForInvestor ) ; uint etherForOwner = msg . value . mul ( etherRatioForOwner ) . div ( 100 ) ; uint etherForInvestor = msg . value . mul ( etherRatioForInvestor ) . div ( 100 ) ; uint etherForSponsee = msg . value . mul ( etherRatioForSponsee ) . div ( 100 ) ; address profitContainerAddress = rbInformationStore . profitContainerAddress ( ) ; address companyWalletAddress = rbInformationStore . companyWalletAddress ( ) ; if ( ! profitContainerAddress . send ( etherForInvestor ) ) { revert ( ) ; } if ( ! companyWalletAddress . send ( etherForOwner ) ) { revert ( ) ; } if ( ! sponseeAddress . send ( etherForSponsee ) ) { revert ( ) ; } uint tokenAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) . div ( 10 ** 18 ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokenAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; if ( totalSupply > cap ) { revert ( ) ; } LogExchange ( msg . sender , this , tokenAmount ) ; LogReceivedEther ( msg . sender , this , msg . value , name ) ; Transfer ( address ( 0x0 ) , msg . sender , tokenAmount ) ; }
","Receive ether from any EOA accounts .
"
"function removeAddressFromAccountFor ( address _addressToRemove ) public onlyRegistryAdmin { uint256 _accountId = registry . accountIdForAddress ( _addressToRemove ) ; registry . removeAddressFromAccount ( _addressToRemove ) ; emit AddressRemoved ( _accountId , _addressToRemove ) ; }
","Remove an address from an account for a user
"
"function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }
","Get the token balance for a specified address
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { }
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function validate ( Document storage self , bytes _ipfsHash , bytes32 _contentHash , bytes32 _transcriptHash ) public view returns ( bool ) { bytes storage ipfsHash = self . ipfsHash ; bytes32 contentHash = self . contentHash ; bytes32 transcriptHash = self . transcriptHash ; return contentHash == _contentHash && keccak256 ( ipfsHash ) == keccak256 ( _ipfsHash ) && transcriptHash == _transcriptHash ; }
","Validate Certification to a student
"
"function investorAmountTokensToBuy ( address _investor ) public constant returns ( uint256 ) { WhitelistedInvestor memory investor = investors [ _investor ] ; Tier tier = tiers [ tierCount ] ; uint256 leftToBuy = tier . maxInvestorCap ( ) . sub ( investor . contributedAmount ) . mul ( tier . exchangeRate ( ) ) ; return leftToBuy ; }
","Amount of tokens an investor can purchase
"
"function balanceOf ( address _person ) public view returns ( uint256 _balanceOf ) { return balances [ _person ] ; }
","Used to retrieve balance of a user
"
"function getDivCard ( uint _divCardId ) public view returns ( string divCardName , uint sellingPrice , address owner ) { Card storage divCard = divCards [ _divCardId ] ; divCardName = divCard . name ; sellingPrice = divCardIndexToPrice [ _divCardId ] ; owner = divCardIndexToOwner [ _divCardId ] ; }
","Returns all the relevant information about a specific div card
"
"function transferOwnershipTo ( address _to ) public ;
","calls ` Ownable.transferOwnership ( ) ` or ` Controlled.changeController ( ) `
"
"function addVestingUser ( address user , uint256 amount ) public onlyOwner preInitState { uint256 oldAmount = ownersMap [ user ] ; ownersMap [ user ] = amount ; ownersMapFirstPeriod [ user ] = amount / 3 ; ownersMapSecondPeriod [ user ] = amount / 3 ; ownersMapThirdPeriod [ user ] = amount - ownersMapFirstPeriod [ user ] - ownersMapSecondPeriod [ user ] ; originalAddressTraker [ user ] = user ; changeAddressAttempts [ user ] = 0 ; totalCommitted += ( amount - oldAmount ) ; AddUser ( user , amount ) ; }
","Can be called only before initialization Equal vesting in three periods
"
"function signalBackupWithdraw ( address _token ) external { traderWithdrawalSignals [ msg . sender ] [ _token ] = now ; }
","A trader can withdraw without needing a broker signature if they first call ` signalBackupWithdraw ` for the token they want to withdraw .
"
"function mint ( address _to , uint _value ) public { require ( msg . sender == owner ) ; mintToken ( _to , _value ) ; }
","Will cause a certain ` _value ` of coins minted for ` _to ` .
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) public ;
","Transfers the ownership of an NFT from one address to another address
"
"function getPony ( uint256 _id ) external view returns ( bool isGestating , bool isReady , uint256 cooldownIndex , uint256 nextActionAt , uint256 siringWithId , uint256 birthTime , uint256 matronId , uint256 sireId , uint256 generation , uint256 genes , uint16 upgradeIndex , uint8 unicornation ) { Pony storage pon = ponies [ _id ] ; isGestating = ( pon . matingWithId != 0 ) ; isReady = ( pon . cooldownEndBlock <= block . number ) ; cooldownIndex = uint256 ( pon . cooldownIndex ) ; nextActionAt = uint256 ( pon . cooldownEndBlock ) ; siringWithId = uint256 ( pon . matingWithId ) ; birthTime = uint256 ( pon . birthTime ) ; matronId = uint256 ( pon . matronId ) ; sireId = uint256 ( pon . sireId ) ; generation = uint256 ( pon . generation ) ; genes = pon . genes ; upgradeIndex = pon . txCount ; unicornation = pon . unicornation ; }
","Returns all the relevant information about a specific Pony .
"
"function setStaleTime ( uint256 _staleTime ) onlyOwner public { staleTime = _staleTime ; }
","Allows owner to set time after which price is considered stale
"
"function doSend ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( mBalances [ _from ] >= _amount ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; }
","Helper function actually performing the sending of tokens .
"
"function transfer ( address to , uint256 value , bytes data ) public returns ( bool _success ) { require ( to != address ( 0 ) ) ; require ( value != 0 ) ; require ( data . length != 0 ) ; if ( isContract ( to ) ) { return transferToContract ( to , value , data ) ; } else { return transferToAddress ( to , value , data ) ; } }
","To make token transfers to a user or a contract with additional data
"
"function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; require ( finalizedTime == 0 ) ; require ( getBlockTimestamp ( ) >= startTime ) ; require ( msg . sender == owner || getBlockTimestamp ( ) > endTime || weiToCollect ( ) == 0 ) ; uint CROWDSALE_PCT = 62 ; uint TEAMHOLDER_PCT = 20 ; uint COMMUNITYHOLDER_PCT = 15 ; uint FUTUREHOLDER_PCT = 3 ; assert ( CROWDSALE_PCT + TEAMHOLDER_PCT + COMMUNITYHOLDER_PCT + FUTUREHOLDER_PCT == 100 ) ; uint256 tokenCap = wpr . totalSupply ( ) . mul ( 100 ) . div ( CROWDSALE_PCT ) ; wpr . mint ( teamHolder , tokenCap . mul ( TEAMHOLDER_PCT ) . div ( 100 ) ) ; wpr . mint ( communityHolder , tokenCap . mul ( COMMUNITYHOLDER_PCT ) . div ( 100 ) ) ; wpr . mint ( futureHolder , tokenCap . mul ( FUTUREHOLDER_PCT ) . div ( 100 ) ) ; require ( wpr . finishMinting ( ) ) ; wpr . transferOwnership ( owner ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = getBlockTimestamp ( ) ; Finalized ( finalizedBlock ) ; }
","This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .
"
"function changeHolderCount ( uint256 _maxHolderCount ) public withPerm ( ADMIN ) { emit LogModifyHolderCount ( maxHolderCount , _maxHolderCount ) ; maxHolderCount = _maxHolderCount ; }
","sets the maximum percentage that an individual token holder can hold
"
"function destroyTokens ( address _owner , uint256 _amount ) onlyController returns ( bool ) { uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint256 previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }
","Burns ` _amount ` tokens from ` _owner `
"
"function getCaptainInfo ( uint256 _tokenId ) external view returns ( uint32 captainId , uint32 color , uint32 atk , uint32 defense , uint32 level , uint256 exp , uint256 price , address owner , bool selled ) { Captain storage captain = captains [ _tokenId ] ; captainId = captain . captainId ; color = captain . color ; atk = captain . atk ; defense = captain . defense ; level = captain . level ; exp = captain . exp ; price = captainTokenIdToPrice [ _tokenId ] ; owner = captainTokenIdToOwner [ _tokenId ] ; selled = tokenToSell [ _tokenId ] ; }
","Returns all the relevant information about a specific tokenId .
"
"function setArbitrator ( address _newArbitrator ) external onlyOwner { arbitrator = _newArbitrator ; }
","Sets a new arbitrator .
"
"function validateIpfsDoc ( Document storage self , bytes _ipfsHash ) public view returns ( bool ) { bytes storage ipfsHash = self . ipfsHash ; return keccak256 ( ipfsHash ) == keccak256 ( _ipfsHash ) ; }
","Validate IPFS Hash alone of a student
"
"function totalSupply ( ) public view returns ( uint256 supply ) { return _totalSupply ; }
","Get the total token supply
"
"function migrateAttestation ( address _requester , address _attester , address _subject , bytes32 _dataHash ) public onlyDuringInitialization { emit TraitAttested ( _subject , _attester , _requester , _dataHash ) ; }
","Submit attestation completed prior to deployment of this contract
"
"function getModuleByName ( uint8 _moduleType , bytes32 _name ) public view returns ( bytes32 , address ) ;
","returns module list for a module name - will return first match
"
"function transfer ( address to , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ sender ] == 0 || value <= transferableHavvens ( sender ) ) ; _transfer_byProxy ( sender , to , value ) ; return true ; }
","ERC20 transfer function .
"
"function getPlayerId ( bytes32 boardHash , bytes32 playerName , address playerAddress ) constant internal returns ( uint8 ) { Board storage g = boards [ boardHash ] ; for ( uint8 i = 0 ; i <= g . numPlayers ; i ++ ) { if ( ( keccak256 ( abi . encodePacked ( g . players [ i ] . playerName ) ) == keccak256 ( abi . encodePacked ( playerName ) ) || playerAddress == g . players [ i ] . playerAddress ) && g . players [ i ] . isActive == 1 ) { return i ; break ; } } return 255 ; }
","Get the player id either by player Name or address
"
"function getNextVestingTime ( address account ) external view returns ( uint ) { return getNextVestingEntry ( account ) [ TIME_INDEX ] ; }
","Obtain the time at which the next schedule entry will vest for a given user .
"
"function setOperator ( address _operator ) external onlyOwner { _validateAddress ( operator ) ; operator = _operator ; }
","Sets the operator address .
"
"function transferFrom ( address from , address to , uint value , bytes data ) public optionalProxy notFeeAddress ( from ) returns ( bool ) { uint amountReceived = feePool . amountReceivedFromTransfer ( value ) ; uint fee = value . sub ( amountReceived ) ; tokenState . setAllowance ( from , messageSender , tokenState . allowance ( from , messageSender ) . sub ( value ) ) ; synthetix . synthInitiatedFeePayment ( from , currencyKey , fee ) ; return _internalTransfer ( from , to , amountReceived , data ) ; }
","Override ERC223 transferFrom function in order to subtract the transaction fee and send it to the fee pool for SNX holders to claim .
"
"function resetDemo ( ) external onlyOwner { voteCountTotal = 0 ; currentVoteResults [ 0 ] = 0 ; currentVoteResults [ 1 ] = 0 ; currentVoteResults [ 2 ] = 0 ; currentVoteResults [ 3 ] = 0 ; emit DemoResetted ( ) ; }
","As this is just a DEMO contract , allow the onwer to reset the state of the Demo conract .
"
"function issueAsset ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable , uint _blockNumber ) public returns ( uint ) { return issueAssetWithInitialReceiver ( _symbol , _value , _name , _description , _baseUnit , _isReissuable , _blockNumber , msg . sender ) ; }
","Issues new asset token on the platform .
"
"function getGrey ( uint256 _tokenId ) public view returns ( string greyName , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Grey storage grey = greys [ _tokenId ] ; greyName = grey . name ; sellingPrice = greyIndexToPrice [ _tokenId ] ; owner = greyIndexToOwner [ _tokenId ] ; previousPrice = greyIndexToPreviousPrice [ _tokenId ] ; previousOwners = greyIndexToPreviousOwners [ _tokenId ] ; }
","Returns all the relevant information about a specific grey .
"
"function canReceive ( address receiver ) external view returns ( bool ) { return _registry . hasAttribute ( receiver , _validAttributeTypeID ) ; }
","Check if an account is approved to receive token transfers at account ` receiver ` .
"
"function getMeme ( uint256 _tokenId ) public view returns ( uint256 Id , string memeName , uint256 sellingPrice , address owner ) { Meme storage meme = memes [ _tokenId ] ; Id = _tokenId ; memeName = meme . name ; sellingPrice = memeIndexToPrice [ _tokenId ] ; owner = memeIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific meme .
"
"function callOperator ( address _operator , address _from , address _to , uint256 _value , bytes _userData , bytes _operatorData , bool _preventLocking ) private { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensOperator"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensOperator ( recipientImplementation ) . madeOperatorForTokens ( _operator , _from , _to , _value , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) , ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"" ) ; } }
","Helper function that checks for IEIP777TokensOperator on the recipient and calls it .
"
"function unlockSecondPrivate ( ) public locked onlyOwner { require ( block . timestamp >= secondPrivateReleaseTime ) ; require ( secondPrivateLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= secondPrivateLockedAmount ) ; token . transfer ( privateLockAddress , secondPrivateLockedAmount ) ; secondPrivateLockedAmount = 0 ; }
","Transfers tokens held by timelock to private .
"
"function takeSnapshot ( uint256 _year , uint256 _nextPE ) onlyOwner public { require ( _year > yearsPast [ yearsPast . length - 1 ] ) ; uint256 reward = peBalance / totalSupply ; for ( uint256 k = 1 ; k <= pos ; k ++ ) { snapShot [ _year ] [ addressList [ k ] ] = balanceOf [ addressList [ k ] ] * reward ; } yearsPast . push ( _year ) ; peLastPeriod += peBalance ; peBalance = 0 ; nextPE = _nextPE ; }
","Contract owner can take snapshot of current balances and issue PE to each balance
"
"function release ( ) public { require ( block . timestamp >= releaseTime ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; }
","Transfers tokens held by JZMLock to beneficiary .
"
"function lend ( uint index , bytes oracleData , Cosigner cosigner , bytes cosignerData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; require ( isApproved ( index ) ) ; require ( block . timestamp <= loan . expirationRequest ) ; loan . lender = msg . sender ; loan . dueTime = safeAdd ( block . timestamp , loan . duesIn ) ; loan . interestTimestamp = block . timestamp ; loan . status = Status . lent ; if ( loan . cancelableAt > 0 ) internalAddInterest ( loan , safeAdd ( block . timestamp , loan . cancelableAt ) ) ; uint256 rate = getRate ( loan , oracleData ) ; if ( cosigner != address ( 0 ) ) { loan . cosigner = address ( uint256 ( cosigner ) + 2 ) ; require ( cosigner . requestCosign ( this , index , cosignerData , oracleData ) ) ; require ( loan . cosigner == address ( cosigner ) ) ; } require ( rcn . transferFrom ( msg . sender , loan . borrower , safeMult ( loan . amount , rate ) ) ) ; Transfer ( 0x0 , loan . lender , index ) ; activeLoans += 1 ; lendersBalance [ loan . lender ] += 1 ; Lent ( index , loan . lender , cosigner ) ; return true ; }
","Performs the lend of the RCN equivalent to the requested amount , and transforms the msg.sender in the new lender .
"
"function splitProfits ( ) external { require ( splitInService ) ; uint i ; if ( ! isFrozen ) { require ( now >= relativeDateSave ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 30000000000000 ) ; relativeDateSave = now + 30 days ; currentProfits = ( ( balances [ selfAddress ] - 30000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 300000000000000 , balances [ selfAddress ] ) ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { monthlyLimit [ users [ i ] ] = 5000000000000 ; if ( msg . gas < 240000 ) { currentIteration = i ; break ; } if ( allowed [ selfAddress ] [ users [ i ] ] == 0 ) { checkSplitEnd ( i ) ; continue ; } else if ( ( balances [ users [ i ] ] / allowed [ selfAddress ] [ users [ i ] ] ) < 19 ) { checkSplitEnd ( i ) ; continue ; } actualProfitSplit += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; balances [ users [ i ] ] += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; checkSplitEnd ( i ) ; Transfer ( selfAddress , users [ i ] , ( balances [ users [ i ] ] / amountInCirculation ) * currentProfits ) ; } } }
","Split the monthly profits of the Casino to the users
"
"function setBonuses ( uint [ ] _bonusLimits , uint [ ] _bonusPercentages ) public onlyAdmin { require ( _bonusLimits . length == _bonusPercentages . length ) ; require ( _bonusPercentages . length == 3 ) ; for ( uint8 i = 0 ; i < _bonusLimits . length ; i ++ ) { bonusLimits [ i ] = _bonusLimits [ i ] ; bonusPercentages [ i ] = _bonusPercentages [ i ] ; } }
","Sets the bonus structure.The bonus limits must be in decreasing order .
"
"function createContractor ( address _creator , address _recipient , bool _metaProject , PassProject _passProject , string _projectName , string _projectDescription , bool _restore ) returns ( PassContractor ) { PassProject _project ; if ( _creator == 0 ) _creator = msg . sender ; if ( _metaProject ) _project = PassProject ( passDao . MetaProject ( ) ) ; else if ( address ( _passProject ) == 0 ) _project = projectCreator . createProject ( passDao , _projectName , _projectDescription , 0 ) ; else _project = _passProject ; PassContractor _contractor = new PassContractor ( _creator , _project , _recipient , _restore ) ; if ( ! _metaProject && address ( _passProject ) == 0 && ! _restore ) _project . setProjectManager ( address ( _contractor ) ) ; uint _contractorID = contractors . length ++ ; contractor c = contractors [ _contractorID ] ; c . creator = _creator ; c . contractor = _contractor ; c . recipient = _recipient ; c . metaProject = _metaProject ; c . passProject = _passProject ; c . projectName = _projectName ; c . projectDescription = _projectDescription ; c . creationDate = now ; NewPassContractor ( _creator , _recipient , _project , _contractor ) ; return _contractor ; }
","Function to create a contractor smart contract
"
"function closeDataResponse ( address orderAddr , address seller , bool wasAudited , bool isDataValid , bytes notarySignature ) public whenNotPaused isOrderLegit ( orderAddr ) returns ( bool ) { DataOrder order = DataOrder ( orderAddr ) ; address buyer = order . buyer ( ) ; require ( order . hasSellerBeenAccepted ( seller ) ) ; address notary = order . getNotaryForSeller ( seller ) ; require ( msg . sender == buyer || msg . sender == notary ) ; require ( CryptoUtils . isNotaryVeredictValid ( orderAddr , seller , notary , wasAudited , isDataValid , notarySignature ) ) ; bool transactionCompleted = ! wasAudited || isDataValid ; require ( order . closeDataResponse ( seller , transactionCompleted ) ) ; payPlayers ( order , buyer , seller , notary , wasAudited , isDataValid ) ; if ( transactionCompleted ) { emit TransactionCompleted ( order , seller ) ; } else { emit RefundedToBuyer ( order , buyer ) ; } return true ; }
","Closes a DataResponse .
"
"function burnTokens ( uint _value ) public notZero ( _value ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = SafeMath . sub ( balances [ msg . sender ] , _value ) ; totalSupply = SafeMath . sub ( totalSupply , _value ) ; Burn ( msg . sender , _value ) ; }
","To eliminate tokens and adjust the price of the FEE tokens
"
"function hurifymint ( address _client , uint _value , uint _type ) onlyowner public { uint numHur ; require ( totalToken <= totalHurify ) ; if ( _type == 1 ) { numHur = _value * 6000 * ( 10 ** decimals ) ; } else if ( _type == 2 ) { numHur = _value * 5000 * ( 10 ** decimals ) ; } balances [ owner ] = safeSub ( balances [ owner ] , numHur ) ; balances [ _client ] = safeAdd ( balances [ _client ] , numHur ) ; totalToken = safeAdd ( totalToken , numHur ) ; Transfer ( owner , _client , numHur ) ; }
","Transfer tokens based on type
"
"function batchRedeemChannel ( bytes32 [ ] channelIds , bytes32 [ ] secrets ) public { require ( channelIds . length <= MAX_BATCH_ITERATIONS , ""TOO_MANY_CHANNELS"" ) ; for ( uint i = 0 ; i < channelIds . length ; ++ i ) redeemChannel ( channelIds [ i ] , secrets [ i ] ) ; }
","Redeems a batch of channels .
"
"function takeOwnership ( uint256 _tokenId ) external { require ( isSenderApprovedFor ( _tokenId ) , ""not approved"" ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , msg . sender , _tokenId ) ; }
","Claims the ownership of a given token ID
"
"function viewTokenMeta ( uint256 _tokenId ) external view returns ( uint256 tokenType_ , string specialQuality_ , string tokenTitle_ , string tokenDescription_ , string iptcKeyword_ , string tokenClass_ ) { tokenType_ = tokenTypes [ _tokenId ] ; tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescriptions [ _tokenId ] ; specialQuality_ = specialQualities [ _tokenId ] ; iptcKeyword_ = iptcKeywords [ _tokenId ] ; tokenClass_ = tokenClasses [ _tokenId ] ; }
","Returns all the relevant information about a specific token
"
"function setExchangeRates ( IERC223Token [ ] numeratorTokens , IERC223Token [ ] denominatorTokens , uint256 [ ] rateFractions ) public ;
","see above .
"
"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) external { require ( isOperatorFor ( msg . sender , _from ) ) ; doSend ( msg . sender , _from , _to , _amount , _userData , _operatorData , true ) ; }
","Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
"
"function isRegisteredToFirm ( string firmName , address authority ) public view returns ( bool registered ) { return lib . isRegisteredToFirm ( firmName , authority ) ; }
","Checks if an authority account is registered to a given firm
"
"function isDeprecated ( ) public view returns ( bool deprecated ) { return ( deprecatedSince != 0 ) ; }
","check if the contract is deprecated
"
"function capReached ( ) public view returns ( bool ) { if ( isFinalized ) { return ( finalAmountReturned == 0 ) ; } return ( mintedPerTierTotal [ mintedPerTierTotal . length - 1 ] == tokensPerTierTotal [ tokensPerTierTotal . length - 1 ] ) ; }
","Checks whether the cap has been reached .
"
"function tokenByIndex ( uint256 _tokenIndex ) public view returns ( uint256 ) ;
","Get the ID of PixelCon # ` ( _tokenIndex ) `
"
"function getValidatorDescription ( address validator ) external view returns ( string description ) ;
","Get a description of the validator at account ` validator ` .
"
"function findOrCreatePledge ( uint64 owner , uint64 [ ] delegationChain , uint64 intendedProject , uint64 commitTime , uint64 oldPledge , PledgeState state ) internal returns ( uint64 ) { bytes32 hPledge = sha3 ( owner , delegationChain , intendedProject , commitTime , oldPledge , state ) ; uint64 idx = hPledge2idx [ hPledge ] ; if ( idx > 0 ) return idx ; idx = uint64 ( pledges . length ) ; hPledge2idx [ hPledge ] = idx ; pledges . push ( Pledge ( 0 , owner , delegationChain , intendedProject , commitTime , oldPledge , state ) ) ; return idx ; }
","This creates a Pledge with an initial amount of 0 if one is not created already ; otherwise it finds the pledge with the specified attributes ; all pledges technically exist , if the pledge has n't been created in this system yet it simply is n't in the hash array hPledge2idx [ ] yet
"
"function transferFromWithSender ( address _sender , address _from , address _to , uint256 _value ) public onlyProxy returns ( bool success ) { require ( _to != address ( 0 ) ) ; uint256 balanceOfFrom = erc20Store . balances ( _from ) ; require ( _value <= balanceOfFrom ) ; uint256 senderAllowance = erc20Store . allowed ( _from , _sender ) ; require ( _value <= senderAllowance ) ; erc20Store . setBalance ( _from , balanceOfFrom - _value ) ; erc20Store . addBalance ( _to , _value ) ; erc20Store . setAllowance ( _from , _sender , senderAllowance - _value ) ; erc20Proxy . emitTransfer ( _from , _to , _value ) ; return true ; }
","Core logic of the ERC20 ` transferFrom ` function .
"
"function rewardAirdrop ( address _beneficiary , uint256 _amount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , ""Beneficiary is not whitelisted"" ) ; uint256 amount = _amount . mul ( E18 ) ; require ( totalSupply_ . add ( amount ) < TOTAL_SUPPLY_LIMIT ) ; require ( amount <= TOKEN_SUPPLY_AIRDROP_LIMIT ) ; require ( airDropTokenIssuedTotal < TOKEN_SUPPLY_AIRDROP_LIMIT ) ; uint256 remainingTokens = TOKEN_SUPPLY_AIRDROP_LIMIT . sub ( airDropTokenIssuedTotal ) ; if ( amount > remainingTokens ) { amount = remainingTokens ; } balances [ _beneficiary ] = balances [ _beneficiary ] . add ( amount ) ; airDropTokenIssuedTotal = airDropTokenIssuedTotal . add ( amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; emit Transfer ( address ( AIRDROP_EVENT ) , _beneficiary , amount ) ; }
","Reward Airdrop Participant .
"
"function unitExists ( uint x , uint y ) public view returns ( bool ) { return ( soldUnits [ x ] [ y ] != 0 ) ; }
","Check whether exist Unit with same x any y coordinates and it was sold already in order to prevent over writing
"
"function disableTransfers ( ) external onlyAdmin whenNotPaused returns ( bool ) { require ( released , ""Invalid operation. The transfer state is already restricted."" ) ; released = false ; emit TokenReleased ( released ) ; return true ; }
","This function disables token transfers for everyone .
"
"function acceptOwnership ( ) external { require ( msg . sender == nominatedOwner , ""Not nominated."" ) ; emit OwnerChanged ( owner , nominatedOwner ) ; owner = nominatedOwner ; nominatedOwner = address ( 0 ) ; }
","Accept the nomination to be owner .
"
"function startVoting ( uint startBlockNr , uint durationHrs ) onlyOwner onlyState ( State . BEFORE_START ) { VOTING_START_BLOCKNR = max ( block . number , startBlockNr ) ; VOTING_END_TIME = now + max ( durationHrs , 1 ) * 1 hours ; }
","start voting at ` startBlockNr ` for ` durationHrs ` .
"
"function isCurrentTierCapReached ( ) public constant returns ( bool ) { Tier tier = tiers [ tierCount ] ; return tier . isCapReached ( ) ; }
","check if tier cap has reached
"
"function buy ( ) public payable { buyInternal ( msg . sender , msg . value ) ; }
","crowdsale participation
"
"function endGame ( ) external { require ( _processGameEnd ( ) ) ; }
","End the game .
"
"function autoBuyERC20 ( address _from , address _to , uint _value ) public ;
","This method called by ERC20 smart contract
"
"function resumeSale ( ) public onlyController { require ( campaignState == 2 ) ; paused = false ; CampaignResumed ( now ) ; }
","Resume sale
"
"function validatePaymentSig ( address _payer , address _receiver , uint256 _amount , bytes32 _nonce , bytes _paymentSig ) private { bytes32 _signatureDigest = generatePayTokensSchemaHash ( _payer , _receiver , _amount , _nonce ) ; require ( _payer == recoverSigner ( _signatureDigest , _paymentSig ) , 'Invalid Payment Signature' ) ; burnSignatureDigest ( _signatureDigest , _payer ) ; }
","Verify payment signature is valid
"
"function attest ( address _subject , address _requester , uint256 _reward , bytes _requesterSig , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig ) external { attestForUser ( _subject , msg . sender , _requester , _reward , _requesterSig , _dataHash , _requestNonce , _subjectSig ) ; }
","Function for attester to submit attestation from their own account )
"
"function validateTranscriptHash ( Document storage self , bytes32 _transcriptHash ) public view returns ( bool ) { bytes32 transcriptHash = self . transcriptHash ; return transcriptHash == _transcriptHash ; }
","Validate Content Hash alone of a student
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function getCurrentPrice ( ) external view returns ( uint256 price ) { price = currentPrice ; }
","Returns the currentPrice for each token
"
"function mediate ( uint256 _transactionId ) public { require ( escrows [ msg . sender ] [ _transactionId ] . paid ) ; require ( escrows [ msg . sender ] [ _transactionId ] . expiration != 0 ) ; require ( escrows [ msg . sender ] [ _transactionId ] . expiration != 1 ) ; escrows [ msg . sender ] [ _transactionId ] . expiration = 0 ; Dispute ( msg . sender , _transactionId ) ; }
","Only authorized address
"
"function verifyOpenSignature ( address _trader , bytes _signature , bytes32 _orderID ) external view returns ( bool ) { bytes memory data = abi . encodePacked ( ""Republic Protocol: open: "" , _trader , _orderID ) ; address signer = Utils . addr ( data , _signature ) ; return ( brokers [ signer ] == true ) ; }
","Verifies a broker 's signature for an order opening .
"
"function destroy ( ) public ;
","Will selfdestruct the contract
"
"function transferFrom ( address _from , address _to , uint256 _value ) external requireThaw userNotPlaying ( _to ) { require ( cooldown [ _from ] [ _to ] <= now ) ; var _allowance = allowed [ _from ] [ _to ] ; if ( _from == selfAddress ) { monthlyLimit [ _to ] = safeSub ( monthlyLimit [ _to ] , _value ) ; } balances [ _to ] = balances [ _to ] + _value ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; allowed [ _from ] [ _to ] = safeSub ( _allowance , _value ) ; addUser ( _to ) ; Transfer ( _from , _to , _value ) ; }
","Transfer tokens from an address to another ~ ERC-20 Standard
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = memeIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a meme
"
"function newDaoRulesProposal ( uint _minQuorumDivisor , uint _minBoardMeetingFees , uint _minutesSetProposalPeriod , uint _minMinutesDebatePeriod , uint _feesRewardInflationRate , bool _transferable , address _newdao , uint _minutesForTokensCloning , uint _minutesDebatingPeriod ) payable returns ( uint ) ;
","Function to make a proposal to change the Dao rules
"
"function rejectAllOfficialOperators ( ) external { require ( ! mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] , ""Official operators are already rejected by msg.sender."" ) ; mIsUserNotAcceptingAllOfficialOperators [ msg . sender ] = true ; emit OfficialOperatorsRejectedByUser ( msg . sender ) ; }
","Unauthorize all official operators to manage ` msg.sender ` 's tokens .
"
"function approveAddress ( address _addr ) public onlyOwner { approvedAddresses [ _addr ] = true ; }
","Adds an approved address for the sale
"
"function changeOwner ( address _newOwner ) public onlyOwner { require ( _newOwner != 0x0 ) ; owner = _newOwner ; }
","change the owner of the contract
"
"function getDarknodeBond ( address _darknodeID ) external view returns ( uint256 ) { return store . darknodeBond ( _darknodeID ) ; }
","Retrieves the bond amount of a darknode in 10^-18 REN .
"
"function newOrder ( string filters , string dataRequest , uint256 price , uint256 initialBudgetForAudits , string termsAndConditions , string buyerURL , string publicKey ) public whenNotPaused returns ( address ) { require ( initialBudgetForAudits >= minimumInitialBudgetForAudits ) ; require ( token . allowance ( msg . sender , this ) >= initialBudgetForAudits ) ; address newOrderAddr = new DataOrder ( msg . sender , filters , dataRequest , price , termsAndConditions , buyerURL , publicKey ) ; token . transferFrom ( msg . sender , this , initialBudgetForAudits ) ; buyerRemainingBudgetForAudits [ msg . sender ] [ newOrderAddr ] = initialBudgetForAudits ; ordersByBuyer [ msg . sender ] . push ( newOrderAddr ) ; orders [ newOrderAddr ] = true ; emit NewOrder ( newOrderAddr ) ; return newOrderAddr ; }
","Creates a new DataOrder .
"
"function approve ( address _to , uint256 _tokenId ) public validId ( _tokenId ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( _to != owner , ""Cannot approve PixelCon owner"" ) ; require ( msg . sender == owner || operatorApprovals [ owner ] [ msg . sender ] , ""Sender does not have permission to approve address"" ) ; tokenApprovals [ _tokenId ] = _to ; emit Approval ( owner , _to , _tokenId ) ; }
","Approve ` ( _to ) ` to transfer PixelCon ` ( _tokenId ) ` ( zero indicates no approved address )
"
"function confirmPayment ( uint64 idPledge , uint amount ) onlyVault { Pledge storage p = findPledge ( idPledge ) ; require ( p . pledgeState == PledgeState . Paying ) ; uint64 idNewPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Paid ) ; doTransfer ( idPledge , idNewPledge , amount ) ; }
","Method called by the vault to confirm a payment .
"
"function setVerifier ( address _newVerifier ) external requireGod { require ( _newVerifier != address ( 0 ) ) ; verifierAddress = _newVerifier ; }
","The Verifier address is used to confirm the authenticity of the claim signature .
"
"function changeDepositAddress ( address _depositAddress ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _depositAddress != address ( 0 ) ) ; require ( _depositAddress != depositAddress ) ; address oldDepositAddress = depositAddress ; depositAddress = _depositAddress ; emit DepositAddressChanged ( oldDepositAddress , _depositAddress ) ; }
","Called when deposit address needs to change
"
"function mintTokens ( address beneficiary , uint256 amount ) internal { tokensMinted = tokensMinted . add ( amount ) ; require ( tokensMinted <= hardCap ) ; assert ( token . mint ( beneficiary , amount ) ) ; AddHOLDer ( beneficiary ) ; }
","mint tokens and apply PoolParty method ( Alber Erre )
"
"function spendFromSwap ( bytes32 swapId , uint amount , address recipient ) internal { require ( amount <= hashIdToSwap [ swapId ] . amount ) ; hashIdToSwap [ swapId ] . amount -= amount ; if ( hashIdToSwap [ swapId ] . amount == 0 ) { delete hashIdToSwap [ swapId ] ; assert ( hashIdToSwap [ swapId ] . amount == 0 ) ; } recipient . transfer ( amount ) ; }
","Send ether out of this contract to swap beneficiary and update or delete entry in swap mapping
"
"function validatePurchase ( ) internal { require ( msg . value >= minPurchase ) ; require ( block . timestamp >= startTime && block . timestamp <= endTime ) ; require ( ! isFinalized ) ; require ( whitelist . whitelist ( msg . sender ) ) ; }
","cap is checked in buyTokens function
"
"function deedUri ( uint256 _deedId ) external view returns ( string _uri ) { return _metadata ( _deedId ) ; }
","A distinct URI ( RFC 3986 ) for a given token .
"
"function getCanvasCount ( ) public view returns ( uint ) { return canvases . length ; }
","Returns amount of created canvases .
"
"function upgrade ( uint256 value ) external { require ( upgradeableTarget != address ( 0 ) ) ; burn ( value ) ; totalUpgraded = totalUpgraded . add ( value ) ; UpgradeableTarget ( upgradeableTarget ) . upgradeFrom ( msg . sender , value ) ; Upgraded ( msg . sender , upgradeableTarget , value ) ; }
","Update token to the new upgraded token
"
"function totalSupplyAt ( uint256 _checkpointId ) external view returns ( uint256 ) ;
","Queries totalSupply at a specified checkpoint
"
"function setCurrentIssuanceData ( address account , uint initialDebtOwnership ) external onlyAssociatedContract { issuanceData [ account ] . initialDebtOwnership = initialDebtOwnership ; issuanceData [ account ] . debtEntryIndex = debtLedger . length ; }
","Set issuance data for an address
"
"function getAccountSpendingAmount ( Data storage self , address account ) internal view returns ( uint amount ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.spending.amount' , account , getAccountSpendingPeriod ( self , account ) ) ) ; return self . Storage . getUint ( id ) ; }
","Return the amount spent during the current period
"
"function disableInvestment ( address [ ] ofAssets ) external pre_cond ( isOwner ( ) ) { for ( uint i = 0 ; i < ofAssets . length ; ++ i ) { isInvestAllowed [ ofAssets [ i ] ] = false ; } }
","Disable investment in specified assets
"
"function currentRate ( uint256 amount ) view public returns ( uint256 ) { uint8 roundNum = currentRoundNum ( ) ; if ( roundNum == 0 ) { return 0 ; } else { uint8 round = roundNum - 1 ; if ( amount < rounds [ round ] . bulkThreshold ) { return rounds [ round ] . rate ; } else { return rounds [ round ] . rateBulk ; } } }
","Fetches current rate ( how many tokens you get for 1 ETH )
"
"function release ( address _sender , address _recipient , uint256 _transactionId , uint256 _exchangeRate ) public { Lock memory lock = escrows [ msg . sender ] [ _transactionId ] ; require ( lock . sender == _sender ) ; require ( lock . recipient == _recipient || lock . sender == _recipient ) ; require ( lock . paid ) ; token . transfer ( _recipient , lock . value ) ; if ( lock . fee > 0 ) { token . transfer ( msg . sender , lock . fee ) ; } delete escrows [ msg . sender ] [ _transactionId ] ; token . issueExchangeRate ( _sender , _recipient , msg . sender , lock . value , _transactionId , _exchangeRate ) ; Released ( msg . sender , _recipient , _transactionId ) ; }
","Exchange rate has 18 decimal places
"
"function hasRecentPrice ( address ofAsset ) view pre_cond ( assetIsRegistered ( ofAsset ) ) returns ( bool isRecent ) { var ( , timestamp ) = getPrice ( ofAsset ) ; return ( sub ( now , timestamp ) <= VALIDITY ) ; }
","Whether price of asset has been updated less than VALIDITY seconds ago
"
"function open ( ) onlyOwner public { opened = true ; }
","Open the Registry so that anyone can register .
"
"function epoch ( ) external { if ( previousEpoch . blocknumber == 0 ) { require ( msg . sender == owner , ""not authorized (first epochs)"" ) ; } require ( block . number >= currentEpoch . blocknumber + minimumEpochInterval , ""epoch interval has not passed"" ) ; uint256 epochhash = uint256 ( blockhash ( block . number - 1 ) ) ; previousEpoch = currentEpoch ; currentEpoch = Epoch ( { epochhash : epochhash , blocknumber : block . number } ) ; numDarknodesPreviousEpoch = numDarknodes ; numDarknodes = numDarknodesNextEpoch ; if ( nextMinimumBond != minimumBond ) { minimumBond = nextMinimumBond ; emit LogMinimumBondUpdated ( minimumBond , nextMinimumBond ) ; } if ( nextMinimumPodSize != minimumPodSize ) { minimumPodSize = nextMinimumPodSize ; emit LogMinimumPodSizeUpdated ( minimumPodSize , nextMinimumPodSize ) ; } if ( nextMinimumEpochInterval != minimumEpochInterval ) { minimumEpochInterval = nextMinimumEpochInterval ; emit LogMinimumEpochIntervalUpdated ( minimumEpochInterval , nextMinimumEpochInterval ) ; } if ( nextSlasher != slasher ) { slasher = nextSlasher ; emit LogSlasherUpdated ( slasher , nextSlasher ) ; } emit LogNewEpoch ( ) ; }
","Progress the epoch if it is possible to do so .
"
"function destroyTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , getBlockNumber ( ) ) ; if ( curTotalSupply < _amount ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; var previousBalanceFrom = balanceOf ( _owner ) ; if ( previousBalanceFrom < _amount ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }
","Burns ` _amount ` tokens from ` _owner `
"
"function setPriceInCents ( uint256 newBuyPrice ) onlyOwner public { buyPriceInCent = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth
"
"function callPlugin ( bool before , uint64 adminId , uint64 fromPledge , uint64 toPledge , uint64 context , uint amount ) internal returns ( uint allowedAmount ) { uint newAmount ; allowedAmount = amount ; PledgeAdmin storage admin = findAdmin ( adminId ) ; if ( ( address ( admin . plugin ) != 0 ) && ( allowedAmount > 0 ) ) { if ( before ) { newAmount = admin . plugin . beforeTransfer ( adminId , fromPledge , toPledge , context , amount ) ; require ( newAmount <= allowedAmount ) ; allowedAmount = newAmount ; } else { admin . plugin . afterTransfer ( adminId , fromPledge , toPledge , context , amount ) ; } } }
","` callPlugin ` is used to trigger the general functions in the plugin for any actions needed before and after a transfer happens .
"
"function finalize ( bytes _result , bool _success , bytes _signature ) external returns ( bool ) ;
","It can be called by assigned lighthouse only
"
"function approve ( address spender , uint256 tokens ) public returns ( bool success ) { requireTrade ( msg . sender ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }
","Token owner can approve for ` spender ` to transferFrom ( ... ) ` tokens ` from the token owner 's account
"
"function updateNonClosingBalanceProof ( uint256 channel_identifier , address closing_participant , address non_closing_participant , bytes32 balance_hash , uint256 nonce , bytes32 additional_hash , bytes closing_signature , bytes non_closing_signature ) external { require ( channel_identifier == getChannelIdentifier ( closing_participant , non_closing_participant ) ) ; require ( balance_hash != bytes32 ( 0x0 ) ) ; require ( nonce > 0 ) ; address recovered_non_closing_participant ; address recovered_closing_participant ; Channel storage channel = channels [ channel_identifier ] ; require ( channel . state == ChannelState . Closed ) ; require ( channel . settle_block_number >= block . number ) ; recovered_non_closing_participant = recoverAddressFromBalanceProofUpdateMessage ( channel_identifier , balance_hash , nonce , additional_hash , closing_signature , non_closing_signature ) ; require ( non_closing_participant == recovered_non_closing_participant ) ; recovered_closing_participant = recoverAddressFromBalanceProof ( channel_identifier , balance_hash , nonce , additional_hash , closing_signature ) ; require ( closing_participant == recovered_closing_participant ) ; Participant storage closing_participant_state = channel . participants [ closing_participant ] ; require ( closing_participant_state . is_the_closer ) ; updateBalanceProofData ( channel , closing_participant , nonce , balance_hash ) ; emit NonClosingBalanceProofUpdated ( channel_identifier , closing_participant , nonce ) ; }
","Called on a closed channel , the function allows the non-closing participant to provide the last balance proof , which modifies the closing participant 's state .
"
"function broadcastSignedRequestAsPayerAction ( bytes _requestData , bytes _payeesPaymentAddress , bytes _payerRefundAddress , uint256 [ ] _additionals , uint256 _expirationDate , bytes _signature ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( _expirationDate >= block . timestamp , ""expiration should be after current time"" ) ; require ( Signature . checkBtcRequestSignature ( _requestData , _payeesPaymentAddress , _expirationDate , _signature ) , ""signature should be correct"" ) ; return createAcceptAndAdditionalsFromBytes ( _requestData , _payeesPaymentAddress , _payerRefundAddress , _additionals ) ; }
","Function to broadcast and accept an offchain signed request ( the broadcaster can also pays and makes additionals ) .
"
"function addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) external onlyOwner nonReentrant { _addModule ( _moduleFactory , _data , _maxCost , _budget ) ; }
","Function used to attach the module in security token
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( isTransferEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _value ) revert ( ) ; allowed [ _from ] [ msg . sender ] -= _value ; return doTransfer ( _from , _to , _value ) ; }
","send _value amount of tokens to _to address from _from address , on the condition it is approved by _from
"
"function terminateSelfDestruct ( ) external onlyOwner { initiationTime = 0 ; selfDestructInitiated = false ; emit SelfDestructTerminated ( ) ; }
","Terminate and reset the self-destruction timer .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public validAddress ( _to ) transfersAllowed ( _from ) returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }
","This function is disabled during the crowdfunding .
"
"function setWithholdingFixed ( address [ ] _investors , uint256 _withholding ) public withPerm ( MANAGE ) { require ( _withholding <= 10 ** 18 , ""Incorrect withholding tax"" ) ; emit SetWithholdingFixed ( _investors , _withholding , now ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { withholdingTax [ _investors [ i ] ] = _withholding ; } }
","Function to set withholding tax rates for investors
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { assert ( msg . sender != address ( 0 ) ) ; assert ( _from != address ( 0 ) ) ; assert ( _to != address ( 0 ) ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( ! frozenAccount [ _from ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( tokenBalanceOf [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( tokenBalanceOf [ _from ] - _value < tokenBalanceOf [ _from ] ) ; require ( tokenBalanceOf [ _to ] + _value > tokenBalanceOf [ _to ] ) ; require ( _value > 0 ) ; orderToTransfer ( msg . sender , _from , _to , _value , ""Order to transfer tokens from allowed account"" ) ; _transfer ( _from , _to , _value ) ; allowed [ _from ] [ msg . sender ] -= _value ; return true ; }
","deliberately authorized the sender of the message via some mechanism ;
"
"function _verifyInput ( bytes32 question_id , bytes32 last_history_hash , bytes32 last_answer_or_commitment_id , uint256 last_bond , address last_answerer , bool is_commitment ) internal view returns ( bool , bytes32 ) { require ( realitio . isPendingArbitration ( question_id ) , ""The question must be pending arbitration in realitio"" ) ; bytes32 history_hash = realitio . getHistoryHash ( question_id ) ; require ( history_hash == keccak256 ( last_history_hash , last_answer_or_commitment_id , last_bond , last_answerer , is_commitment ) , ""The history parameters supplied must match the history hash in the realitio contract"" ) ; }
","Return data needed to verify the last history item
"
"function freezeTokenTransfers ( ) public onlyOwner returns ( bool frozen ) { tokenTransfersFrozen = true ; FreezeTokenTransfers ( msg . sender , true ) ; return true ; }
","Used to freeze token transfers
"
"function depositEther ( ) external payable { require ( msg . value > 0 ) ; addUser ( msg . sender ) ; balances [ 0 ] [ msg . sender ] = balances [ 0 ] [ msg . sender ] . add ( msg . value ) ; Deposit ( 0 , msg . sender , msg . value , balances [ 0 ] [ msg . sender ] ) ; }
","deposit Ether into the contract
"
"function activate ( uint256 _gameID , uint256 _startTime ) external isHuman ( ) onlyDevOrOwner ( ) { require ( _gameID < gameIDIndex_ , ""incorrect game id"" ) ; require ( game_ [ _gameID ] . gameStartTime == 0 , ""already activated"" ) ; game_ [ _gameID ] . gameStartTime = _startTime ; emit onGameActivated ( _gameID , _startTime , now ) ; }
","Activate a game .
"
"function pauseSale ( bool _flag ) onlyAdmin ( 2 ) public { require ( state != State . Successful ) ; if ( _flag == true ) { require ( state != State . Paused ) ; laststate = state ; remainingActualState = SaleDeadline . sub ( now ) ; state = State . Paused ; emit LogSalePaused ( true ) ; } else { require ( state == State . Paused ) ; state = laststate ; SaleDeadline = now . add ( remainingActualState ) ; emit LogSalePaused ( false ) ; } }
","Pause function
"
"function setPricingStartegy ( address _pricingStrategyAddress ) whenNotPaused onlyOwner external { pricingStrategy = PricingStrategy ( _pricingStrategyAddress ) ; }
","Set PricingStrategy address .
"
"function setPrepaid ( address _backer , uint _tokenPrice , uint _tokenAmount , string _privatePhrase , uint _backerRank ) external founderCall returns ( uint ) { if ( _tokenPrice == 0 || _tokenAmount == 0 || claimedPrepaidUnits > 0 || _tokenAmount + prepaidUnits + claimedUnits > promissoryUnits ) throw ; if ( earlyBackerList . length == numOfBackers && backers [ _backer ] . length == 0 ) throw ; if ( backers [ _backer ] . length == 0 ) { earlyBackerList . push ( _backer ) ; backersAddresses . push ( _backer ) ; } backers [ _backer ] . push ( backerData ( _tokenPrice , _tokenAmount , sha3 ( _privatePhrase , _backer ) , true , false , _backerRank ) ) ; prepaidUnits += _tokenAmount ; lastPrice = _tokenPrice ; AddedPrepaidTokensEvent ( _backer , backers [ _backer ] . length - 1 , _tokenPrice , _tokenAmount ) ; return backers [ _backer ] . length - 1 ; }
","Adding ` _backer.address ( ) ` as an early backer
"
"function withdrawExcessToken ( address token ) external onlyOwner { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 quantity ; bool ok ; ( quantity , ok ) = getQuantity ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( creationUnit_ ) . mul ( quantity ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }
","Owner : Withdraw excess funds which do n't belong to Bskt Token holders
"
"function transfer ( address to , uint value , bytes data ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ sender ] == 0 || value <= transferableHavvens ( sender ) , ""Value to transfer exceeds available havvens"" ) ; _transfer_byProxy ( messageSender , to , value , data ) ; return true ; }
","ERC223 transfer function .
"
"function fracExp ( uint256 _k , uint256 _q , uint256 _n , uint256 _p ) internal pure returns ( uint256 ) { uint256 s = 0 ; uint256 N = 1 ; uint256 B = 1 ; for ( uint256 i = 0 ; i < _p ; ++ i ) { s += _k * N / B / ( _q ** i ) ; N = N * ( _n - i ) ; B = B * ( i + 1 ) ; } return s ; }
","Compute '_k ( 1+1/_q ) ^ _n ' , with precision '_p '
"
"function pause ( bytes32 _hash ) external pollApproved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) notBeforeGenesis { if ( ! paused ) { paused = true ; LogPause ( _hash ) ; } }
","Pause the contract operations
"
"function transfer ( address _to , uint256 _value ) public validAddress ( _to ) transfersAllowed ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }
","This function is disabled during the crowdfunding .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused afterCrowdsale returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }
","Override the functions to not allow token transfers until the end of the ICO
"
"function setMinMaxContribution ( uint256 _min , uint256 _max ) public isAdmin isOpenOrClosed { require ( _max <= maxAllocation ) ; require ( _min <= _max ) ; minContribution = _min ; maxContribution = _max ; }
","Sets the min and the max contribution configurations .
"
"function getBook ( ) public constant returns ( uint [ ] ) ;
","Returns an array of all prices and their volumes .
"
"function removeMember ( address _member ) external ;
","Remove a member from this contract
"
"function getCollectionData ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bytes8 , uint64 [ ] ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; return ( collectionNames [ _collectionIndex ] , collectionTokens [ _collectionIndex ] ) ; }
","Get details of collection # ` ( _collectionIndex ) `
"
"function burn ( uint256 value ) onlyOwner returns ( bool success ) { require ( balances [ msg . sender ] > value && value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; currentSupply = currentSupply . sub ( value ) ; Burn ( msg . sender , value ) ; return true ; }
","Remove tokens from the system irreversibly
"
"function registerModule ( address _moduleFactory ) external ;
","Called by the ModuleFactory owner to register new modules for SecurityToken to use
"
"function claimByProof ( address _claimer , bytes32 [ ] data , bytes32 [ ] proofs , uint256 number ) onlyToken returns ( bool success ) { return false ; }
","Only one of claimByProof ( ) or claim ( ) will potentially be activated in the future .
"
"function setRBInformationStoreAddress ( address _address ) { require ( multiSigAddress == msg . sender ) ; rbInformationStore = RBInformationStore ( _address ) ; LogSetRBInformationStoreAddress ( _address ) ; }
","Change rbInformationStoreAddress .
"
"function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 4 ) ; availableTags [ 0 ] = ""Capped"" ; availableTags [ 1 ] = ""Non-refundable"" ; availableTags [ 2 ] = ""POLY"" ; availableTags [ 3 ] = ""ETH"" ; return availableTags ; }
","Get the tags related to the module factory
"
"function setRoles2Library ( Roles2LibraryInterface _roles2Library ) auth external returns ( uint ) { roles2Library = _roles2Library ; return OK ; }
","Updates link to roles2Library contract .
"
"function settlementContract ( uint64 _settlementID ) external view returns ( Settlement ) { return settlementDetails [ _settlementID ] . settlementContract ; }
","Returns the settlement contract of a settlement layer .
"
"function balanceOf ( address account ) public view returns ( uint ) { return tokenState . balanceOf ( account ) ; }
","Returns the ERC20 token balance of a given account .
"
"function isFinalized ( bytes32 question_id ) constant public returns ( bool ) { uint32 finalize_ts = questions [ question_id ] . finalize_ts ; return ( ! questions [ question_id ] . is_pending_arbitration && ( finalize_ts > UNANSWERED ) && ( finalize_ts <= uint32 ( now ) ) ) ; }
","Report whether the answer to the specified question is finalized
"
"function activateDestruction ( ) public onlyContractOwner onlySaleFinished notDestructed returns ( uint ) { destructed = true ; _emitDestruction ( ) ; return OK ; }
","Activates distruction .
"
"function getManager ( address _addr ) public view returns ( address ) { if ( managers [ _addr ] == 0 ) { return _addr ; } else { return managers [ _addr ] ; } }
","Get the manager of an address .
"
"function setUint ( bytes32 _key , uint _value ) public onlyOwner returns ( bool success ) { uIntStorage [ _key ] = _value ; return true ; }
","Set value for Uint associated with bytes32 id key
"
"function addManyWhitelist ( address [ ] _accounts ) external whenNotPaused onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { if ( _accounts [ i ] != address ( 0 ) && ! whitelist [ _accounts [ i ] ] ) { whitelist [ _accounts [ i ] ] = true ; emit WhitelistAdded ( _accounts [ i ] ) ; } } return true ; }
","Adds multiple accounts to the whitelist .
"
"function _tickerAvailable ( string _ticker ) internal view returns ( bool ) { if ( _tickerOwner ( _ticker ) != address ( 0 ) ) { if ( ( now > getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , _ticker ) ) ) && ! _tickerStatus ( _ticker ) ) { return true ; } else return false ; } return true ; }
","Internal - Checks if the entered ticker is registered and has not expired
"
"function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) ;
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function STARTMETADOLLAR ( ) { mtdAmount = 1000000000000000000 ; ethAmount = 1000000000000000 ; mtdPreAmount = 1000000000000000000 ; ethPreAmount = 1000000000000000 ; preIcoIsRunning = true ; minimalGoalReached = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = mtdAmount * ethAmount ; preICOprice = mtdPreAmount * ethPreAmount ; ICOprice = mtdAmount * ethAmount ; sellPrice = 900000000000000 ; updatePrices ( ) ; }
","Constructor of the contract
"
"function setKyberNetwork ( address _KyberNetwork ) public ;
","Can only be called by operators
"
"function setTokenExchange ( address _songTokenExchange ) public onlyAdmin notFrozen returns ( bool set ) { songTokenExchange = _songTokenExchange ; SongTokenExchangeContractSet ( msg . sender , _songTokenExchange , true ) ; return true ; }
","used to set the song token exchange
"
"function addCertification ( address _student , bytes32 _contentHash , bytes _ipfsHash , bytes32 _transcriptHash ) public onlyOwner { uint currIndx = studentCertifications [ _student ] . indx ; ( studentCertifications [ _student ] . documents [ currIndx ] ) . addCertification ( _contentHash , _ipfsHash , _transcriptHash ) ; studentCertifications [ _student ] . indx ++ ; emit CertificationAdded ( _student , currIndx ) ; }
","Add Certification to a student
"
"function setETHPriceLowerBound ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { m_ETHPriceLowerBound = _price ; }
","set the limit of ETH in cents , oraclize data smaller than this is not accepted
"
"function transferChamp ( address _from , address _to , uint256 _champId ) internal ifChampForSaleThenCancelSale ( _champId ) { Champ storage champ = champs [ _champId ] ; addressInfo [ _to ] . champsCount ++ ; addressInfo [ _from ] . champsCount -- ; champToOwner [ _champId ] = _to ; if ( champ . eq_sword != 0 ) { transferItem ( _from , _to , champ . eq_sword ) ; } if ( champ . eq_shield != 0 ) { transferItem ( _from , _to , champ . eq_shield ) ; } if ( champ . eq_helmet != 0 ) { transferItem ( _from , _to , champ . eq_helmet ) ; } emit TransferChamp ( _from , _to , _champId ) ; }
","Transfer champ
"
"function increaseApproval ( address _spender , uint256 _addedValue ) public returns ( bool success ) { return erc20Impl . increaseApprovalWithSender ( msg . sender , _spender , _addedValue ) ; }
","Increases the amount ` _spender ` is allowed to withdraw from your account .
"
"function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( multisigs [ msigId ] . owner == msg . sender ) ; require ( multisigs [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= min ( now + 1 days , multisigs [ msigId ] . unlockTime ) ) ; require ( amount > 0 ) ; require ( ! isAntecedentHashedSecret [ hashedSecret ] ) ; isAntecedentHashedSecret [ hashedSecret ] = true ; multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , add ( amount , fee ) ) ; swapId = keccak256 ( msigId , msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; AtomicSwap storage swap = atomicswaps [ swapId ] ; swap . msigId = msigId ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; FEE_RECIPIENT . transfer ( fee ) ; }
","First or second stage of atomic swap .
"
"function depositCollateral ( address token , uint amount ) public { require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( isValid ( token ) ) ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] . add ( amount ) ; emit Deposit ( token , msg . sender , amount , tokens [ token ] [ msg . sender ] ) ; require ( StandardToken ( token ) . transferFrom ( msg . sender , this , amount ) , ""error with transfer"" ) ; IRemoteFunctions ( _contract_masternode ( ) ) . _externalAddMasternode ( msg . sender ) ; }
","Public function that allows any user to deposit accepted tokens as collateral to become a masternode .
"
"function convertSafe ( TokenConverter converter , Token from , Token to , uint256 amount ) internal returns ( uint256 bought ) { require ( from . approve ( converter , amount ) ) ; uint256 prevBalance = to . balanceOf ( this ) ; bought = converter . convert ( from , to , amount , 1 ) ; require ( to . balanceOf ( this ) . sub ( prevBalance ) >= bought , ""Bought amount incorrect"" ) ; require ( from . approve ( converter , 0 ) ) ; }
","Converts tokens using a token converter
"
"function doTransfer ( address _from , address _to , uint256 _value ) validate_address ( _to ) is_not_locked ( _from ) internal returns ( bool success ) { if ( _value <= 0 || balances [ _from ] < _value || balances [ _to ] + _value < balances [ _to ] ) { return false ; } balances [ _from ] -= _value ; balances [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; }
","send _value amount of tokens to _to address from _from address
"
"function proposal ( uint _proposalId ) public view returns ( uint _startBlock , uint _startTime , uint _duration , bool _active , bool _finalized , uint [ ] _votes , address [ ] _tokens , address _votingToken , bool _hasBalance ) { require ( _proposalId < tokenBatches . length ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; _startBlock = p . startBlock ; _startTime = p . startTime ; _duration = p . duration ; _finalized = ( _startTime + _duration < now ) ; _active = isActive ( _proposalId ) ; _votes = getVotes ( ) ; _tokens = getConsideredTokens ( ) ; _votingToken = p . votingToken ; _hasBalance = ( p . votingToken == 0x0 ) ? false : ( DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) > 0 ) ; }
","Get data about specific proposal
"
"function updateDescriptiveInformation ( address ofAsset , string name , string symbol , string url , string ipfsHash ) pre_cond ( isOwner ( ) ) pre_cond ( information [ ofAsset ] . exists ) { Asset asset = information [ ofAsset ] ; asset . name = name ; asset . symbol = symbol ; asset . url = url ; asset . ipfsHash = ipfsHash ; }
","Updates description information of a registered Asset
"
"function getAllNames ( ) public view returns ( bytes8 [ ] ) { return pixelconNames ; }
","Get the names of all PixelCons
"
"function setAutopay ( bool _automatic ) public onlyOwner { autoPay = _automatic ; AutoPaySet ( ) ; }
","Used to decentralize , toggles whether the LPVault will automatically confirm a payment after the payment has been authorized
"
"function issueSynths ( bytes4 currencyKey , uint amount ) public optionalProxy nonZeroAmount ( amount ) { require ( amount <= remainingIssuableSynths ( messageSender , currencyKey ) , ""Amount too large"" ) ; _addToDebtRegister ( currencyKey , amount ) ; synths [ currencyKey ] . issue ( messageSender , amount ) ; }
","Issue synths against the sender 's SNX .
"
"function getAllowedContribution ( ) private returns ( uint256 , uint256 ) { uint256 allowedContribution = msg . value ; uint256 tillCap = remainingCap ( ) ; uint256 refundAmount = 0 ; if ( msg . value > tillCap ) { allowedContribution = tillCap ; refundAmount = msg . value . sub ( allowedContribution ) ; ContributionRefund ( refundAmount , msg . sender ) ; } return ( allowedContribution , refundAmount ) ; }
","Calculates the allowed contribution based on the transaction value and amount remaining till cap .
"
"function _transfer ( address _owner , address _receiver , uint256 _tokenId ) internal { nonFungibleContract . transferFrom ( _owner , _receiver , _tokenId ) ; }
","Transfers an ERC721 Token owned by this contract to another address .
"
"function multisend ( address [ ] recipients , uint256 value ) onlyOwner public { for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { mintToken ( recipients [ i ] , value ) ; } }
","send minting tokens for array of adresses
"
"function addModerator ( address _newMod ) public onlyAdmin notFrozen returns ( bool success ) { moderators [ _newMod ] = true ; ModeratorAdded ( msg . sender , _newMod , true ) ; return true ; }
","used to add a moderator
"
"function setWithholding ( address [ ] _investors , uint256 [ ] _withholding ) public withPerm ( MANAGE ) { require ( _investors . length == _withholding . length , ""Mismatched input lengths"" ) ; emit SetWithholding ( _investors , _withholding , now ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { require ( _withholding [ i ] <= 10 ** 18 , ""Incorrect withholding tax"" ) ; withholdingTax [ _investors [ i ] ] = _withholding [ i ] ; } }
","Function to set withholding tax rates for investors
"
"function removeBurningMan ( address _burningMan , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _burningMan ) , _block ) ; if ( OK != _code ) { return _code ; } uint _idx = burningMan2index [ _burningMan ] ; uint _lastIdx = burningMansCount ; if ( _idx != 0 ) { if ( _idx != _lastIdx ) { address _lastBurningMan = index2burningMan [ _lastIdx ] ; index2burningMan [ _idx ] = _lastBurningMan ; burningMan2index [ _lastBurningMan ] = _idx ; } delete burningMan2index [ _burningMan ] ; delete index2burningMan [ _lastIdx ] ; delete burningMans [ _burningMan ] ; burningMansCount = _lastIdx - 1 ; } return OK ; }
","Remove burning man
"
"function append ( Data storage _data , address _item , address _to ) { if ( _data . isContain [ _item ] ) throw ; if ( _data . head == 0 ) { _data . head = _data . tail = _item ; } else { if ( ! _data . isContain [ _to ] ) throw ; var nextTo = _data . nextOf [ _to ] ; if ( nextTo != 0 ) { _data . prevOf [ nextTo ] = _item ; } else { _data . tail = _item ; } _data . nextOf [ _to ] = _item ; _data . prevOf [ _item ] = _to ; _data . nextOf [ _item ] = nextTo ; } _data . isContain [ _item ] = true ; ++ _data . length ; }
","gas usage < 100000
"
"function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { if ( _to != 0x0 ) { return _getAsset ( ) . __transferFromWithReference ( _from , _to , _value , """" , msg . sender ) ; } }
","Performs allowance transfer of asset balance between holders .
"
"function approve ( address _spender , uint _value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to spend no more than ` _value ` tokens
"
"function getSecurityTokenData ( address _securityToken ) public view returns ( string , address , string ) ;
","Get security token data by its address
"
"function setMinimumDepositAmount ( uint _amount ) external onlyOwner { require ( _amount > SafeDecimalMath . unit ( ) , ""Minimum deposit amount must be greater than UNIT"" ) ; minimumDepositAmount = _amount ; emit MinimumDepositAmountUpdated ( minimumDepositAmount ) ; }
","Set the minimum deposit amount required to depoist sUSD into the FIFO queue
"
"function release ( ERC20 token ) public { for ( uint i = 0 ; i < _beneficiary . length ; i ++ ) { if ( block . timestamp >= _unlocktime ) { token . transfer ( _beneficiary [ i ] , _amount [ i ] . mul ( 10 ** 18 ) ) ; emit Released ( _amount [ i ] ) ; _amount [ i ] = 0 ; } } }
","Transfers vested tokens to beneficiary .
"
"function setIssuanceRatio ( uint _issuanceRatio ) external optionalProxy_onlyOwner { require ( _issuanceRatio <= MAX_ISSUANCE_RATIO ) ; issuanceRatio = _issuanceRatio ; emitIssuanceRatioUpdated ( _issuanceRatio ) ; }
","Set the issuanceRatio for issuance calculations .
"
"function increaseTokenSaleAllocation ( ) public whenNotPaused onlyAdmin { uint256 allowance = token . allowance ( msg . sender , this ) ; uint256 current = totalSaleAllocation ; totalSaleAllocation = totalSaleAllocation . add ( allowance ) ; require ( token . transferFrom ( msg . sender , this , allowance ) ) ; emit TokensAllocatedForSale ( totalSaleAllocation , current ) ; }
","Recalculates and/or reassigns the total tokens allocated for the private sale .
"
"function _transferDirect ( uint _fromId , uint _toId , uint _value , bytes32 _symbol ) internal { assets [ _symbol ] . wallets [ _fromId ] . balance = assets [ _symbol ] . wallets [ _fromId ] . balance . sub ( _value ) ; assets [ _symbol ] . wallets [ _toId ] . balance = assets [ _symbol ] . wallets [ _toId ] . balance . add ( _value ) ; }
","Transfers asset balance between holders wallets .
"
"function collectFor ( address recipient ) private { uint tokensOwned = balances [ recipient ] ; if ( tokensOwned == 0 ) return ; delete balances [ recipient ] ; tokenContract . safeTransfer ( recipient , tokensOwned ) ; emit Collection ( recipient , tokensOwned ) ; }
","Allows users to collect purchased tokens after the sale .
"
"function registerPlayerToBoard ( uint tableStakes ) external payable allowedValuesOnly ( msg . value ) whenNotPaused returns ( uint ) { require ( msg . value == tableStakes ) ; GoBoard storage boardToJoin ; uint boardIDToJoin ; ( boardIDToJoin , boardToJoin ) = getOrCreateWaitingBoard ( tableStakes ) ; bool shouldStartGame = addPlayerToBoard ( boardToJoin , tableStakes ) ; PlayerAddedToBoard ( boardIDToJoin , msg . sender ) ; if ( shouldStartGame ) { startBoardGame ( boardToJoin , boardIDToJoin ) ; } return boardIDToJoin ; }
","This is the first function a player will be using in order to start playing .
"
"function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description ) ;
","Get a description of the attribute type with ID ` attributeTypeID ` .
"
"function referralsOf ( uint8 _level ) public view returns ( uint256 [ ] ) { return users [ addressToUser [ msg . sender ] ] . referralsByLevel [ uint8 ( _level ) ] ; }
","getter for referrals of user by level
"
"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x0a0fb66b ) , _token , _to , _value , _fee , _nonce , _validUntil ) ) ; }
","Hash ( keccak256 ) of the payload used by transferPreSigned
"
"function setAddress ( bytes32 _key , address _value ) public onlyOwner returns ( bool success ) { addressStorage [ _key ] = _value ; return true ; }
","Set value for Address associated with bytes32 id key
"
"function withdrawExcessToken ( address token ) external onlyOwner nonReentrant { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 quantity ; bool ok ; ( quantity , ok ) = getQuantity ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( creationUnit ) . mul ( quantity ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }
","Owner : Withdraw excess funds which do n't belong to Bskt token holders
"
"function __transferWithReference ( address _to , uint _value , string _reference , address _sender ) onlyProxy public returns ( bool ) { var ( _fromRole , _toRole ) = _getParticipantRoles ( _sender , _to ) ; if ( ! _checkTransferAllowance ( _to , _toRole , _value , _sender , _fromRole ) ) { return false ; } if ( ! _isValidCountryLimits ( _to , _toRole , _value , _sender , _fromRole ) ) { return false ; } if ( ! super . __transferWithReference ( _to , _value , _reference , _sender ) ) { return false ; } _updateTransferLimits ( _to , _toRole , _value , _sender , _fromRole ) ; _contractFallbackERC223 ( _sender , _to , _value ) ; return true ; }
","Performs transfer call on the platform by the name of specified sender .
"
"function addTokenGrant ( address _recipient , uint256 _startTime , uint128 _amount , uint16 _vestingDuration , uint16 _vestingCliff ) public onlyColonyMultiSig noGrantExistsForUser ( _recipient ) { require ( _vestingCliff > 0 ) ; require ( _vestingDuration > _vestingCliff ) ; uint amountVestedPerMonth = _amount / _vestingDuration ; require ( amountVestedPerMonth > 0 ) ; token . transferFrom ( colonyMultiSig , address ( this ) , _amount ) ; Grant memory grant = Grant ( { startTime : _startTime == 0 ? now : _startTime , amount : _amount , vestingDuration : _vestingDuration , vestingCliff : _vestingCliff , monthsClaimed : 0 , totalClaimed : 0 } ) ; tokenGrants [ _recipient ] = grant ; emit GrantAdded ( _recipient , grant . startTime , _amount , _vestingDuration , _vestingCliff ) ; }
","Add a new token grant for user ` _recipient ` .
"
"function requireValidTerms ( PlatformTerms platformTerms ) public constant returns ( bool ) { if ( ALLOW_RETAIL_INVESTORS ) { require ( ! ENABLE_TRANSFERS_ON_SUCCESS , ""NF_MUST_DISABLE_TRANSFERS"" ) ; } else { require ( MIN_TICKET_EUR_ULPS >= MIN_QUALIFIED_INVESTOR_TICKET_EUR_ULPS , ""NF_MIN_QUALIFIED_INVESTOR_TICKET"" ) ; } require ( MIN_TICKET_EUR_ULPS >= TOKEN_TERMS . TOKEN_PRICE_EUR_ULPS ( ) , ""NF_MIN_TICKET_LT_TOKEN_PRICE"" ) ; require ( ESTIMATED_MAX_CAP_EUR_ULPS ( ) >= MIN_TICKET_EUR_ULPS , ""NF_MAX_FUNDS_LT_MIN_TICKET"" ) ; require ( MIN_TICKET_EUR_ULPS >= platformTerms . MIN_TICKET_EUR_ULPS ( ) , ""NF_ETO_TERMS_MIN_TICKET_EUR_ULPS"" ) ; require ( DURATION_TERMS . WHITELIST_DURATION ( ) >= platformTerms . MIN_WHITELIST_DURATION ( ) , ""NF_ETO_TERMS_WL_D_MIN"" ) ; require ( DURATION_TERMS . WHITELIST_DURATION ( ) <= platformTerms . MAX_WHITELIST_DURATION ( ) , ""NF_ETO_TERMS_WL_D_MAX"" ) ; require ( DURATION_TERMS . PUBLIC_DURATION ( ) >= platformTerms . MIN_PUBLIC_DURATION ( ) , ""NF_ETO_TERMS_PUB_D_MIN"" ) ; require ( DURATION_TERMS . PUBLIC_DURATION ( ) <= platformTerms . MAX_PUBLIC_DURATION ( ) , ""NF_ETO_TERMS_PUB_D_MAX"" ) ; uint256 totalDuration = DURATION_TERMS . WHITELIST_DURATION ( ) + DURATION_TERMS . PUBLIC_DURATION ( ) ; require ( totalDuration >= platformTerms . MIN_OFFER_DURATION ( ) , ""NF_ETO_TERMS_TOT_O_MIN"" ) ; require ( totalDuration <= platformTerms . MAX_OFFER_DURATION ( ) , ""NF_ETO_TERMS_TOT_O_MAX"" ) ; require ( DURATION_TERMS . SIGNING_DURATION ( ) >= platformTerms . MIN_SIGNING_DURATION ( ) , ""NF_ETO_TERMS_SIG_MIN"" ) ; require ( DURATION_TERMS . SIGNING_DURATION ( ) <= platformTerms . MAX_SIGNING_DURATION ( ) , ""NF_ETO_TERMS_SIG_MAX"" ) ; require ( DURATION_TERMS . CLAIM_DURATION ( ) >= platformTerms . MIN_CLAIM_DURATION ( ) , ""NF_ETO_TERMS_CLAIM_MIN"" ) ; require ( DURATION_TERMS . CLAIM_DURATION ( ) <= platformTerms . MAX_CLAIM_DURATION ( ) , ""NF_ETO_TERMS_CLAIM_MAX"" ) ; return true ; }
","checks terms against platform terms , reverts on invalid
"
"function createNew ( bytes32 _regName , address _owner ) public payable feePaid returns ( address kAddr_ ) { kAddr_ = address ( new Forwarder ( msg . sender , _regName , _owner ) ) ; Created ( msg . sender , _regName , kAddr_ ) ; }
","Create a new product contract
"
"function setFailOverStakeContract ( address _contractAddress ) external onlyOwner nonAdminAddress ( _contractAddress ) returns ( bool ) { if ( stakeFailOverRestrictionLifted == false ) { stakeFailOverRestrictionLifted = true ; return true ; } else { minters [ _contractAddress ] = true ; stakeFailOverRestrictionLifted = false ; emit FailOverStakeContractSet ( _contractAddress ) ; return true ; } }
","Emergency use function designed to prevent stake deadlocks , allowing a fail-over stake contract to be implemented Requires 2 transaction , the first lifts the restriction , the second enables the restriction and sets the contract
"
"function bulkTokenSend ( address [ ] beneficiaries , uint256 amount , string ) onlyOwner external { require ( amount > 0 ) ; for ( uint32 i = 0 ; i < beneficiaries . length ; i ++ ) { mintTokens ( beneficiaries [ i ] , amount ) ; } }
","Bulk mint tokens ( same amounts )
"
"function newVote ( bytes _executionScript , string _metadata , bool _castVote , bool _executesIfDecided ) external auth ( CREATE_VOTES_ROLE ) returns ( uint256 voteId ) { return _newVote ( _executionScript , _metadata , _castVote , _executesIfDecided ) ; }
","Create a new vote about `` ` _metadata ` ``
"
"function giveItem ( address _to , uint256 _itemID ) public onlyOwnerOfItem ( _itemID ) { transferItem ( msg . sender , _to , _itemID ) ; }
","Address _from is msg.sender .
"
"function _proxyTransferEvent ( uint _fromId , uint _toId , uint _value , bytes32 _symbol ) internal { if ( proxies [ _symbol ] != 0x0 ) { ProxyEventsEmitter ( proxies [ _symbol ] ) . emitTransfer ( _address ( _fromId ) , _address ( _toId ) , _value ) ; } }
","Ask asset Proxy contract to emit ERC20 compliant Transfer event .
"
"function _approve ( uint _spenderId , uint _value , bytes32 _symbol , uint _senderId ) internal returns ( uint ) { if ( ! isCreated ( _symbol ) ) { return _error ( ATX_PLATFORM_ASSET_IS_NOT_ISSUED ) ; } if ( _senderId == _spenderId ) { return _error ( ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( assets [ _symbol ] . wallets [ _senderId ] . allowance [ _spenderId ] != 0 && _value != 0 ) { return _error ( ATX_PLATFORM_INVALID_INVOCATION ) ; } assets [ _symbol ] . wallets [ _senderId ] . allowance [ _spenderId ] = _value ; Emitter ( eventsHistory ) . emitApprove ( _address ( _senderId ) , _address ( _spenderId ) , _symbol , _value ) ; if ( proxies [ _symbol ] != 0x0 ) { ProxyEventsEmitter ( proxies [ _symbol ] ) . emitApprove ( _address ( _senderId ) , _address ( _spenderId ) , _value ) ; } return OK ; }
","Sets asset spending allowance for a specified spender .
"
"function useModule ( address _moduleFactory ) external { if ( ISecurityTokenRegistry ( getAddress ( Encoder . getKey ( ""securityTokenRegistry"" ) ) ) . isSecurityToken ( msg . sender ) ) { if ( IFeatureRegistry ( getAddress ( Encoder . getKey ( ""featureRegistry"" ) ) ) . getFeatureStatus ( ""customModulesAllowed"" ) ) { require ( getBool ( Encoder . getKey ( ""verified"" , _moduleFactory ) ) || IOwnable ( _moduleFactory ) . owner ( ) == IOwnable ( msg . sender ) . owner ( ) , ""ModuleFactory must be verified or SecurityToken owner must be ModuleFactory owner"" ) ; } else { require ( getBool ( Encoder . getKey ( ""verified"" , _moduleFactory ) ) , ""ModuleFactory must be verified"" ) ; } require ( _isCompatibleModule ( _moduleFactory , msg . sender ) , ""Version should within the compatible range of ST"" ) ; pushArray ( Encoder . getKey ( ""reputation"" , _moduleFactory ) , msg . sender ) ; emit ModuleUsed ( _moduleFactory , msg . sender ) ; } }
","Called by a SecurityToken to check if the ModuleFactory is verified or appropriate custom module
"
"function isPendingArbitration ( bytes32 question_id ) public view returns ( bool ) { return questions [ question_id ] . is_pending_arbitration ; }
","Returns whether the question is pending arbitration
"
"function remainigTokens ( ) public view returns ( uint256 ) { return tokenReward . balanceOf ( this ) ; }
","Function to know how many tokens left on contract
"
"function unarchiveModule ( address _module ) external ;
","Unarchives a module attached to the SecurityToken
"
"function addPolicyRule ( bytes4 _sig , address _contract , bytes32 _groupName , uint _acceptLimit , uint _declineLimit ) onlyContractOwner external returns ( uint ) { require ( _sig != 0x0 ) ; require ( _contract != 0x0 ) ; require ( GroupsAccessManager ( accessManager ) . isGroupExists ( _groupName ) ) ; require ( _acceptLimit != 0 ) ; require ( _declineLimit != 0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; if ( policyId2Index [ _policyHash ] == 0 ) { uint _policiesCount = policiesCount . add ( 1 ) ; index2PolicyId [ _policiesCount ] = _policyHash ; policyId2Index [ _policyHash ] = _policiesCount ; policiesCount = _policiesCount ; } Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupsCount = _policy . groupsCount ; if ( _policy . groupName2index [ _groupName ] == 0 ) { _policyGroupsCount += 1 ; _policy . groupName2index [ _groupName ] = _policyGroupsCount ; _policy . participatedGroups [ _policyGroupsCount ] . groupName = _groupName ; _policy . groupsCount = _policyGroupsCount ; } uint _previousAcceptLimit = _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit ; uint _previousDeclineLimit = _policy . participatedGroups [ _policyGroupsCount ] . declineLimit ; _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit = _acceptLimit ; _policy . participatedGroups [ _policyGroupsCount ] . declineLimit = _declineLimit ; _policy . totalAcceptedLimit = _policy . totalAcceptedLimit . sub ( _previousAcceptLimit ) . add ( _acceptLimit ) ; _policy . totalDeclinedLimit = _policy . totalDeclinedLimit . sub ( _previousDeclineLimit ) . add ( _declineLimit ) ; PolicyRuleAdded ( _sig , _contract , _policyHash , _groupName , _acceptLimit , _declineLimit ) ; return OK ; }
","Register new policy rule Can be called only by contract owner
"
"function changeBoardMetadata ( bytes32 boardHash , bytes32 name , string boardDescription ) public returns ( bool ) { require ( boards [ boardHash ] . boardOwner == msg . sender ) ; boards [ boardHash ] . boardName = name ; boards [ boardHash ] . boardDescription = boardDescription ; }
","Overwrite leaderboard name and desctiption as owner only
"
"function makeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { revert ( ) ; }
","Make order not implemented for smart contracts in this exchange version
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId , bytes _data ) public { transferFrom ( _from , _to , _tokenId ) ; require ( checkAndCallSafeTransfer ( _from , _to , _tokenId , _data ) , ""Transfer was not safe"" ) ; }
","Safely transfer the ownership of PixelCon ` ( _tokenId ) ` to ` ( _to ) `
"
"function getCompetitionStatusOfRegistrants ( ) view returns ( address [ ] , address [ ] , bool [ ] ) { address [ ] memory fundAddrs = new address [ ] ( registrants . length ) ; address [ ] memory fundRegistrants = new address [ ] ( registrants . length ) ; bool [ ] memory isRewarded = new bool [ ] ( registrants . length ) ; for ( uint i = 0 ; i < registrants . length ; i ++ ) { fundAddrs [ i ] = registrants [ i ] . fund ; fundRegistrants [ i ] = registrants [ i ] . registrant ; isRewarded [ i ] = registrants [ i ] . isRewarded ; } return ( fundAddrs , fundRegistrants , isRewarded ) ; }
","Returns an array of fund addresses and an associated array of whether competing and whether disqualified
"
"function tokenFallback ( address _from , uint _value , bytes _data ) external { require ( _from == abioToken . owner ( ) || _from == owner ) ; volume = _value ; paused = false ; deadline = now + length ; emit ICOStart ( _value , weiPerABIO , minInvestment ) ; }
","We implement tokenFallback in case someone decides to send us tokens or we want to increase ICO Volume .
"
"function decTotalSupply ( uint _val ) external onlyOwner returns ( bool ) { totalSupply = totalSupply . sub ( _val ) ; return true ; }
","Decrease total supply by ` _val `
"
"function ( ) payable internal { uint amount = msg . value * buyPrice ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value <= 10 ** 17 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; emit Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
","Buy tokens from contract by sending ether
"
"function _safeCall ( address _to , uint _amount ) internal { require ( _to != 0 ) ; require ( _to . call . value ( _amount ) ( ) ) ; }
","` _safeCall ` is used internally when call a contract safely .
"
"function registerProducer ( address aproducer ) onlyOwner external { emit producerRegistered ( aproducer ) ; producers [ aproducer ] = true ; }
","Allow the owner of address ` aproducer.address ( ) ` to act as a producer ( by offering energy ) .
"
"function ( ) public payable { require ( allowWhitelisted || allowAnonymous ) ; if ( ! allowAnonymous ) { if ( allowWhitelisted ) { require ( whitelisted [ msg . sender ] ) ; } } internalContribution ( msg . sender , msg . value ) ; }
","default payable function
"
"function createTemplate ( string content ) stateAny ( ) public returns ( uint256 ) { uint256 id = nextTemplateID ; templates [ id ] = block . number ; LogNewTemplate ( id , msg . sender , content ) ; nextTemplateID = id . add ( 1 ) ; return id ; }
","Create a reusable template , which should be a JSON document .
"
"function revoke ( ERC20Basic _token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ _token ] ) ; uint256 balance = _token . balanceOf ( address ( this ) ) ; uint256 unreleased = releasableAmount ( _token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ _token ] = true ; _token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }
","Allows the owner to revoke the vesting .
"
"function getSupplyBalance ( address account , address asset ) view public returns ( uint ) { Error err ; uint newSupplyIndex ; uint userSupplyCurrent ; Market storage market = markets [ asset ] ; Balance storage supplyBalance = supplyBalances [ account ] [ asset ] ; ( err , newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; require ( err == Error . NO_ERROR ) ; ( err , userSupplyCurrent ) = calculateBalance ( supplyBalance . principal , supplyBalance . interestIndex , newSupplyIndex ) ; require ( err == Error . NO_ERROR ) ; return userSupplyCurrent ; }
","return supply balance with any accumulated interest for ` asset ` belonging to ` account `
"
"function claim ( bytes32 channelId , uint256 payment , bytes signature ) public { require ( canClaim ( channelId , payment , msg . sender , signature ) ) ; PaymentChannel memory channel = channels [ channelId ] ; if ( payment >= channel . value ) { channel . receiver . transfer ( channel . value ) ; } else { channel . receiver . transfer ( payment ) ; channel . sender . transfer ( channel . value . sub ( payment ) ) ; } delete channels [ channelId ] ; DidClaim ( channelId ) ; }
","Claim the funds , and close the channel .
"
"function approve ( address _spender , uint256 _value ) public whenNotPaused returns ( bool success ) { require ( _value > 0 ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","function approve gives an address power to spend specified amount
"
"function cofounderSwitchAddress ( address _newCofounderAddr ) external returns ( bool success ) { if ( msg . sender != cofounder ) throw ; cofounder = _newCofounderAddr ; CofounderSwitchedEvent ( _newCofounderAddr ) ; return true ; }
","` msg.sender.address ( ) ` updating cofounder address to ` _newFounderAddr.address ( ) `
"
"function collectAuthorizedPayment ( uint _idPayment ) { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( msg . sender != p . recipient ) throw ; if ( ! allowedSpenders [ p . spender ] ) throw ; if ( now < p . earliestPayTime ) throw ; if ( p . canceled ) throw ; if ( p . paid ) throw ; if ( this . balance < p . amount ) throw ; p . paid = true ; if ( ! p . recipient . send ( p . amount ) ) { throw ; } PaymentExecuted ( _idPayment , p . recipient , p . amount ) ; }
","only ` allowedSpenders [ ] ` The recipient of a payment calls this function to send themselves the ether after the ` earliestPayTime ` has expired
"
"function withdrawHavvens ( uint amount ) external onlyOwner { havven . transfer ( owner , amount ) ; }
","Allows the owner to withdraw havvens from this contract if needed .
"
"function totalSupply ( ) public view returns ( uint Supply ) { return totalHurify ; }
","Returns the Total Number of HUR Tokens .
"
"function buyChamp ( uint256 _id ) external payable whenNotPaused onlyNotOwnerOfChamp ( _id ) champIsForSale ( _id ) isPaid ( champs [ _id ] . price ) distributeSaleInput ( champToOwner [ _id ] ) { transferChamp ( champToOwner [ _id ] , msg . sender , _id ) ; }
","Buys champ
"
"function withdraw ( bytes locked_encoded , bytes merkle_proof , bytes32 secret ) { data . withdraw ( locked_encoded , merkle_proof , secret ) ; ChannelSecretRevealed ( secret , msg . sender ) ; }
","Unlock a locked transfer .
"
"function distribute ( address to , uint256 tokenAmount ) public onlyOwner { require ( tokenAmount > 0 ) ; require ( tokenAmount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( owner , to , tokenAmount ) ; }
","distribute tokens to an address
"
"function initialize ( ) initializeOnceOnly public { }
","Initialize any state variables that would normally be set in the contructor .
"
"function finalize ( ) public onlyDonationAddress returns ( bool ) { require ( getSencBalance ( ) >= sencHardCap || now >= endDate , ""SENC hard cap rached OR End date reached"" ) ; require ( ! finalized , ""Donation not already finalized"" ) ; totalSencCollected = getSencBalance ( ) ; if ( totalSencCollected >= sencHardCap ) { donationWallet . transfer ( address ( this ) . balance ) ; } else { uint256 totalDonatedEthers = convertToEther ( totalSencCollected ) + INFOCORP_DONATION ; donationWallet . transfer ( totalDonatedEthers ) ; claimTokens ( address ( 0 ) , foundationWallet ) ; } claimTokens ( SENC_CONTRACT_ADDRESS , foundationWallet ) ; finalized = true ; return finalized ; }
","The ` finalize ( ) ` should only be called after donation hard cap reached or the campaign reached the final day .
"
"function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; require ( this . balance >= revenue ) ; msg . sender . transfer ( revenue ) ; }
","Sell tokens and receive ether from contract
"
"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) , ""Spender address is not provided"" ) ; require ( signatures [ _signature ] == false , ""No Signature"" ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) , ""From address is not provided"" ) ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
","Increase the amount of tokens that an owner allowed to a spender .
"
"function tokenPriceInEuroCents ( ) public constant returns ( uint ) { return 1000 ; }
","price of one token ( 1e18 wei-tokens ) in euro cents
"
"function setMaxSecurityGuardDelay ( uint _maxSecurityGuardDelay ) onlyContractOwner { maxSecurityGuardDelay = _maxSecurityGuardDelay ; }
","` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment
"
"function getFinalAnswerIfMatches ( bytes32 question_id , bytes32 content_hash , address arbitrator , uint32 min_timeout , uint256 min_bond ) external view returns ( bytes32 ) { }
","Return the final answer to the specified question , provided it matches the specified criteria .
"
"function contribute ( uint8 _v , bytes32 _r , bytes32 _s ) public payable { address recoveredAddress = verify ( msg . sender , _v , _r , _s ) ; require ( signers [ recoveredAddress ] ) ; internalContribution ( msg . sender , msg . value ) ; }
","allows to do signed contributions
"
"function createRegulatorProxy ( address regulatorImplementation ) public { address proxy = address ( new RegulatorProxy ( regulatorImplementation ) ) ; Regulator newRegulator = Regulator ( proxy ) ; newRegulator . addValidator ( msg . sender ) ; addAllPermissions ( newRegulator ) ; RegulatorProxy ( proxy ) . transferOwnership ( msg . sender ) ; regulators . push ( proxy ) ; emit CreatedRegulatorProxy ( proxy , getCount ( ) - 1 ) ; }
","the method caller will have to claim ownership of regulators since regulators are claimable
"
"function approveBlacklistedAddressSpender ( address _blacklistedAccount ) public userBlacklisted ( _blacklistedAccount ) whenNotPaused requiresPermission { tokenStorage . setAllowance ( _blacklistedAccount , msg . sender , balanceOf ( _blacklistedAccount ) ) ; emit ApprovedBlacklistedAddressSpender ( _blacklistedAccount , msg . sender , balanceOf ( _blacklistedAccount ) ) ; }
","Allows a central authority to approve themselves as a spender on a blacklisted account .
"
"function balanceOfAt ( address _investor , uint256 _checkpointId ) public view returns ( uint256 ) ;
","Queries balances as of a defined checkpoint
"
"function balance ( ) constant returns ( uint ) { if ( ! between [ msg . sender ] ) { return 0 ; } uint share = totalInput / count ; uint withdrew = amountsWithdrew [ msg . sender ] ; uint available = share - withdrew ; assert ( available >= 0 && available <= share ) ; return available ; }
","Gets the amount of funds in Wei available to the sender .
"
"function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 30636000000 ; }
","minimum amount of funding to consider the sale as successful ( in euro-cents )
"
"function get ( string _name ) public view returns ( uint value ) { return params [ keccak256 ( _name ) ] ; }
","gets the parameter keyed by the provided name value from the params mapping
"
"function launchContract ( ) onlyOwner { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; LaunchContract ( msg . sender , true ) ; }
","Used to launch the contract , and enabled token minting
"
"function collect ( ) isOwner { require ( this . balance > 0 ) ; withdraw ( this . balance ) ; }
","Transfer all ether from smartcontract to owner
"
"function issueAttribute ( address account , uint256 attributeTypeID , uint256 value ) external payable whenNotPaused { require ( canValidate ( msg . sender , attributeTypeID ) , ""only approved validators may assign attributes of this type"" ) ; require ( ! _issuedAttributes [ account ] [ attributeTypeID ] . exists , ""duplicate attributes are not supported, remove existing attribute first"" ) ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; uint256 stake = msg . value . sub ( jurisdictionFee ) ; require ( stake >= minimumStake , ""attribute requires a greater value than is currently provided"" ) ; _issuedAttributes [ account ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , setPersonally : false , operator : address ( 0 ) , validator : msg . sender , value : value , stake : stake } ) ; emit AttributeAdded ( msg . sender , account , attributeTypeID , value ) ; if ( stake > 0 ) { emit StakeAllocated ( msg . sender , attributeTypeID , stake ) ; } if ( jurisdictionFee > 0 ) { if ( owner ( ) . send ( jurisdictionFee ) ) { emit FeePaid ( owner ( ) , msg . sender , attributeTypeID , jurisdictionFee ) ; } } }
","Issue an attribute of the type with ID ` attributeTypeID ` and a value of ` value ` to ` account ` if ` message.caller.address ( ) ` is approved validator .
"
"function addItemWithClassAndData ( string _name , uint16 _rarity , uint16 _weapon , uint [ ] _statsMin , uint [ ] _statsMax , uint16 _amount , string _hostfile , uint16 _minLevel , string _desc , uint _price ) public onlyModerators { ItemClass storage _itemClass = classIdToClass [ totalItemClass ] ; _itemClass . classId = totalItemClass ; _itemClass . name = _name ; _itemClass . amount = _amount ; _itemClass . rarity = _rarity ; _itemClass . weapon = _weapon ; _itemClass . statsMin = _statsMin ; _itemClass . statsMax = _statsMax ; _itemClass . hostfile = _hostfile ; _itemClass . minLevel = _minLevel ; _itemClass . desc = _desc ; _itemClass . total = 0 ; _itemClass . price = _price ; _itemClass . active = true ; totalItemClass = globalClasses . push ( _itemClass ) ; totalItems ++ ; }
","All links inside the _hostfile string has to be seperated by commas .
"
"function setLocks ( address [ ] _holders , uint256 [ ] _lockups ) public onlyController { require ( _holders . length == _lockups . length ) ; require ( _holders . length < 256 ) ; require ( transfersEnabled == false ) ; for ( uint8 i = 0 ; i < _holders . length ; i ++ ) { address holder = _holders [ i ] ; uint256 lockup = _lockups [ i ] ; require ( lockups [ holder ] == 0 ) ; lockups [ holder ] = lockup ; emit LockedTokens ( holder , lockup ) ; } }
","Sets the locks of an array of addresses .
"
"function getTickerDetails ( string _ticker ) external view returns ( address , uint256 , uint256 , string , bool ) ;
","Returns the owner and timestamp for a given ticker
"
"function distributeToken ( address [ ] addresses , uint256 _value ) onlyOwner public { require ( balanceOf [ owner ] >= _value * addresses . length ) ; for ( uint i = 0 ; i < addresses . length ; i ++ ) { require ( addresses [ i ] != 0x0 ) ; require ( balanceOf [ addresses [ i ] ] + _value > balanceOf [ addresses [ i ] ] ) ; require ( ! frozenAccount [ owner ] ) ; require ( ! frozenAccount [ addresses [ i ] ] ) ; balanceOf [ owner ] -= _value ; balanceOf [ addresses [ i ] ] += _value ; Transfer ( owner , addresses [ i ] , _value ) ; } }
","distribute tokens to multiple addresses
"
"function setPrices ( uint256 _newSellPrice , uint256 _newBuyPrice ) onlyDoftManager { sellPrice = _newSellPrice ; buyPrice = _newBuyPrice ; }
","Allow users to buy tokens for ` _newBuyPrice ` eth and sell tokens for ` _newSellPrice ` eth
"
"function makeBuyOffer ( uint32 _canvasId ) external payable stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; BuyOffer storage existing = buyOffers [ _canvasId ] ; require ( canvas . owner != msg . sender ) ; require ( canvas . owner != 0x0 ) ; require ( msg . value > existing . amount ) ; if ( existing . amount > 0 ) { addPendingWithdrawal ( existing . buyer , existing . amount ) ; } buyOffers [ _canvasId ] = BuyOffer ( true , msg . sender , msg . value ) ; emit BuyOfferMade ( _canvasId , msg . sender , msg . value ) ; }
","Places buy offer for the canvas .
"
"function multiERC20Transfer ( ERC20 _token , address [ ] _addresses , uint [ ] _amounts ) public { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { _safeERC20Transfer ( _token , _addresses [ i ] , _amounts [ i ] ) ; MultiERC20Transfer ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] , _token ) ; } }
","Send ERC20 tokens to multiple contracts using two arrays which includes the address and the amount .
"
"function ( ) external payable { require ( msg . value > 0 ) ; address ( heroes ) . transfer ( msg . value ) ; }
","The fallback function payable
"
"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyOwner public { delete arbitration_bounties [ question_id ] ; realitio . submitAnswerByArbitrator ( question_id , answer , answerer ) ; }
","Submit the arbitrator 's answer to a question .
"
"function doBuy ( address _caller , uint256 etherAmount ) internal { Contribution ( etherAmount , _caller ) ; uint256 callerExchangeRate = shpExchangeRate . mul ( CALLER_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 reserveExchangeRate = shpExchangeRate . mul ( RESERVE_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 founderExchangeRate = shpExchangeRate . mul ( FOUNDER_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 bountyExchangeRate = shpExchangeRate . mul ( BOUNTY_EXCHANGE_SHARE ) . div ( 100 ) ; uint256 callerTokens = etherAmount . mul ( callerExchangeRate ) ; uint256 callerTokensWithDiscount = applyDiscount ( etherAmount , callerTokens ) ; uint256 reserveTokens = etherAmount . mul ( reserveExchangeRate ) ; uint256 founderTokens = etherAmount . mul ( founderExchangeRate ) ; uint256 bountyTokens = etherAmount . mul ( bountyExchangeRate ) ; uint256 vestingTokens = founderTokens . add ( reserveTokens ) ; founderTokenCount = founderTokenCount . add ( founderTokens ) ; reserveTokenCount = reserveTokenCount . add ( reserveTokens ) ; shp . generateTokens ( _caller , callerTokensWithDiscount ) ; shp . generateTokens ( bountyAddress , bountyTokens ) ; shp . generateTokens ( trusteeAddress , vestingTokens ) ; NewSale ( _caller , etherAmount , callerTokensWithDiscount ) ; NewSale ( trusteeAddress , etherAmount , vestingTokens ) ; NewSale ( bountyAddress , etherAmount , bountyTokens ) ; etherEscrowAddress . transfer ( etherAmount ) ; updateCounters ( etherAmount ) ; }
","This method sends the Ether received to the Ether escrow address and generates the calculated number of SHP tokens , sending them to the caller 's address .
"
"function checkLogin ( address _toCheck ) view external returns ( bool ) { uint256 check = 0 ; check -= 1 ; return ( cooldown [ _toCheck ] == check ) ; }
","Check if user is logged internal
"
"function transferOwnership ( address _tokenController , address _trusteeOwner ) public onlyOwner { require ( closed ) ; require ( _tokenController != 0x0 ) ; require ( _trusteeOwner != 0x0 ) ; shp . changeController ( _tokenController ) ; trustee . changeOwner ( _trusteeOwner ) ; }
","Transfers ownership of the token smart contract and trustee
"
"function setAttributeTypeOnlyPersonal ( uint256 ID , bool onlyPersonal ) external { require ( isAttributeType ( ID ) , ""unable to set to only personal, no attribute type with the provided ID"" ) ; _attributeTypes [ ID ] . onlyPersonal = onlyPersonal ; }
","Enable or disable a restriction for a given attribute type ID ` ID ` that prevents attributes of the given type from being set by operators based on the provided value for ` onlyPersonal ` .
"
"function changeExpiryLimit ( uint256 _newExpiry ) external onlyOwner { require ( _newExpiry >= 1 days , ""Expiry should >= 1 day"" ) ; emit ChangeExpiryLimit ( getUint ( EXPIRYLIMIT ) , _newExpiry ) ; set ( EXPIRYLIMIT , _newExpiry ) ; }
","Changes the expiry time for the token ticker .
"
"function isUserAllowedToTransfer ( address _user ) public constant returns ( bool ) { require ( _user != 0x0 ) ; return transfersWhitelist [ _user ] ; }
","Is the address allowed to transfer
"
"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) private { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) , ""When '_preventLocking' is true, you cannot invoke 'callOperator' to a contract address that does not support the 'ERC777TokensOperator' interface"" ) ; } }
","Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
"
"function alterBankBalance ( address _toAlter , uint256 _amount ) internal { if ( _amount > allowed [ selfAddress ] [ _toAlter ] ) { IOUSupply += ( _amount - allowed [ selfAddress ] [ _toAlter ] ) ; moneySpent [ _toAlter ] += ( _amount - allowed [ selfAddress ] [ _toAlter ] ) ; allowed [ selfAddress ] [ _toAlter ] = _amount ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } else { IOUSupply -= ( allowed [ selfAddress ] [ _toAlter ] - _amount ) ; moneySpent [ _toAlter ] += ( allowed [ selfAddress ] [ _toAlter ] - _amount ) ; allowed [ selfAddress ] [ _toAlter ] = _amount ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } }
","Rise or lower user bank balance - Backend Function
"
"function getVersionFor ( address _sender ) public view returns ( address ) { return userOptOutVersion [ _sender ] == 0 ? latestVersion : userOptOutVersion [ _sender ] ; }
","Returns asset implementation contract address assigned to sender .
"
"function setIgnoreRequestIds ( bytes32 [ ] _requestIds , bool [ ] _ignore ) onlyOwner public { require ( _requestIds . length == _ignore . length , ""Incorrect parameter lengths"" ) ; for ( uint256 i = 0 ; i < _requestIds . length ; i ++ ) { ignoreRequestIds [ _requestIds [ i ] ] = _ignore [ i ] ; } }
","Allows owner to ignore specific requestId results from Oraclize
"
"function release ( ) public { require ( block . timestamp >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; }
","Transfers tokens held by timelock to beneficiary .
"
"function pause ( ) public onlyCLevel whenNotPaused { paused = true ; Paused ( ) ; }
","called by any C-level to pause , triggers stopped state
"
"function burnFrom ( address _from , uint256 _value ) public onlyOwner returns ( bool success ) { require ( balanceOf [ _from ] >= _value ) ; balanceOf [ _from ] -= _value ; totalSupply -= _value ; emit Burn ( _from , _value ) ; return true ; }
","Destroy tokens from other account
"
"function proxyPayment ( address _account ) public payable initialized contributionOpen returns ( bool ) { require ( _account != 0x0 ) ; require ( msg . value >= MIN_FUND ) ; uint256 tokenSaling ; uint256 rValue ; uint256 t_totalContributedEth = totalContributedETH + msg . value ; uint256 reFund = 0 ; if ( t_totalContributedEth > MaxEth ) { reFund = t_totalContributedEth - MaxEth ; } rValue = msg . value - reFund ; tokenSaling = rValue . mul ( ratio ) ; if ( reFund > 0 ) msg . sender . transfer ( reFund ) ; assert ( PFC . generateTokens ( _account , tokenSaling ) ) ; destEthFoundation . transfer ( rValue ) ; totalContributedETH += rValue ; totalTokenSaled += tokenSaling ; NewSale ( msg . sender , rValue , tokenSaling ) ; }
","This method will generally be called by the PFC token contract to acquire PFCs .
"
"function activatePurchase ( uint256 _tokenId ) external whenNotPaused { var group = tokenIndexToGroup [ _tokenId ] ; require ( group . addressToContribution [ msg . sender ] > 0 || msg . sender == ceoAddress || msg . sender == cooAddress1 || msg . sender == cooAddress2 || msg . sender == cooAddress3 || msg . sender == cfoAddress ) ; var price = linkedContract . priceOf ( _tokenId ) ; require ( group . contributedBalance >= price ) ; require ( group . purchasePrice == 0 ) ; _purchase ( _tokenId , price ) ; }
","Backup function for activating token purchase requires sender to be a member of the group or CLevel
"
"function createAuction ( uint256 _deedId , uint256 _startPrice , uint256 _endPrice , uint256 _duration ) public fitsIn128Bits ( _startPrice ) fitsIn128Bits ( _endPrice ) fitsIn64Bits ( _duration ) whenNotPaused { address deedOwner = deedContract . ownerOf ( _deedId ) ; require ( msg . sender == address ( deedContract ) || msg . sender == deedOwner ) ; require ( _duration >= 60 ) ; _escrow ( _deedId ) ; Auction memory auction = Auction ( deedOwner , uint128 ( _startPrice ) , uint128 ( _endPrice ) , uint64 ( _duration ) , uint64 ( now ) ) ; _createAuction ( _deedId , auction ) ; }
","Create an auction for a given deed .
"
"function multiTransfer ( address [ ] _addresses , uint [ ] _amounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addresses . length ; i ++ ) { _safeTransfer ( _addresses [ i ] , _amounts [ i ] ) ; MultiTransfer ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }
","Send to multiple addresses using two arrays which includes the address and the amount .
"
"function freezeAccount ( address _from , uint256 _till ) onlyOwner public { require ( frozenAccount [ _from ] == 0 ) ; frozenAccount [ _from ] = _till ; }
","Freezes from sending & receiving tokens .
"
"function ( ) payable { require ( isPayableEnabled ) ; if ( msg . value <= 0 ) { revert ( ) ; } uint supportedAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) . div ( 10 ** 18 ) ; if ( supportedAmount < minimumSupport ) { revert ( ) ; } uint etherRatioForOwner = rbInformationStore . etherRatioForOwner ( ) ; uint etherRatioForSponsee = uint ( 100 ) . sub ( etherRatioForOwner ) . sub ( etherRatioForInvestor ) ; uint etherForOwner = msg . value . mul ( etherRatioForOwner ) . div ( 100 ) ; uint etherForInvestor = msg . value . mul ( etherRatioForInvestor ) . div ( 100 ) ; uint etherForSponsee = msg . value . mul ( etherRatioForSponsee ) . div ( 100 ) ; address profitContainerAddress = rbInformationStore . profitContainerAddress ( ) ; address companyWalletAddress = rbInformationStore . companyWalletAddress ( ) ; if ( ! profitContainerAddress . send ( etherForInvestor ) ) { revert ( ) ; } if ( ! companyWalletAddress . send ( etherForOwner ) ) { revert ( ) ; } if ( ! sponseeAddress . send ( etherForSponsee ) ) { revert ( ) ; } uint tokenAmount = msg . value . mul ( rate . ETH_USD_rate ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokenAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; if ( totalSupply > cap ) { revert ( ) ; } LogExchange ( msg . sender , this , tokenAmount ) ; LogReceivedEther ( msg . sender , this , msg . value , name ) ; Transfer ( address ( 0x0 ) , msg . sender , tokenAmount ) ; }
","Receive ether from any EOA accounts .
"
"function totalSupply ( ) public view returns ( uint256 ) { return warriors . length ; }
","Returns the total number of Warriors currently in existence .
"
"function setUpgradeAgent ( address agent ) external onlyOwner { require ( agent != 0x0 && msg . sender == upgradeMaster ) ; upgradeAgent = UpgradeAgent ( agent ) ; require ( upgradeAgent . isUpgradeAgent ( ) ) ; upgradeAgentStatus = true ; upgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( upgradeAgent ) ; }
","Set address of upgrade target contract and enable upgrade process .
"
"function unlockTokens ( address marketContractAddress , uint qtyToUnlock ) external { uint256 balanceAfterUnLock = contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] . sub ( qtyToUnlock ) ; contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] = balanceAfterUnLock ; transferLockedTokensBackToUser ( qtyToUnlock ) ; UpdatedUserLockedBalance ( marketContractAddress , msg . sender , balanceAfterUnLock ) ; }
","allows user to unlock tokens previously allocated to trading a MarketContract
"
"function getAttributeTypeID ( uint256 index ) external view returns ( uint256 ) { return _attributeIDs [ index ] ; }
","Get the ID of the attribute type at index ` index ` .
"
"function claimRewards ( ) public whenNotPaused ( ) staking ( msg . sender ) { uint256 rewardClaimed = claimRewardsInternal ( msg . sender ) ; emit RewardClaimed ( msg . sender , rewardClaimed ) ; }
","This function will return all eligible reward balance back to the user
"
"function pauseContribution ( ) onlyController { paused = true ; }
","Pauses the contribution if there is any issue
"
"function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , block . number ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; var previousBalanceTo = balanceOf ( _owner ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function mintToken ( address _to , uint256 _amount ) onlyOwner public { uint256 amount = _amount * 10 ** uint256 ( decimals ) ; totalSupply = totalSupply . add ( amount ) ; balances [ _to ] = balances [ _to ] . add ( amount ) ; emit Transfer ( this , _to , amount ) ; }
","Create ` _amount ` tokens and send it to ` _to `
"
"function mNormalizePledge ( uint64 [ ] pledges ) { for ( uint i = 0 ; i < pledges . length ; i ++ ) { normalizePledge ( pledges [ i ] ) ; } }
","` mNormalizePledge ` allows for multiple pledges to be normalized efficiently
"
"function addAmountBoughtAsMember ( address _member , uint256 _amountBought ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _amountBought != 0 ) ; if ( ! members [ _member ] ) { _addMember ( _member ) ; } bought [ _member ] = bought [ _member ] . add ( _amountBought ) ; emit TokensBought ( _member , _amountBought , bought [ _member ] ) ; }
","Add to the amount this member has bought
"
"function updateClientOfContractorManagers ( uint _from , uint _to ) ;
","Function to update the client of the contractor managers in case of upgrade
"
"function validPurchase ( ) internal constant returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value > 0 ; bool withinTokenLimit = tokensRaised < maxTokensRaised ; bool minimumPurchase = msg . value >= minPurchase ; bool hasBalanceAvailable = crowdsaleBalances [ msg . sender ] < maxPurchase ; return withinPeriod && nonZeroPurchase && withinTokenLimit && minimumPurchase && hasBalanceAvailable ; }
","Checks if a purchase is considered valid
"
"function getGameStatus ( uint256 _gameID ) public view isActivated ( _gameID ) returns ( uint256 , bytes32 [ ] memory , uint256 [ ] memory , uint256 [ ] memory , uint256 [ ] memory ) { uint256 _nt = game_ [ _gameID ] . numberOfTeams ; bytes32 [ ] memory _names = new bytes32 [ ] ( _nt ) ; uint256 [ ] memory _keys = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _eth = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _keyPrice = new uint256 [ ] ( _nt ) ; uint256 i ; for ( i = 0 ; i < _nt ; i ++ ) { _names [ i ] = teams_ [ _gameID ] [ i ] . name ; _keys [ i ] = teams_ [ _gameID ] [ i ] . keys ; _eth [ i ] = teams_ [ _gameID ] [ i ] . eth ; _keyPrice [ i ] = getBuyPrice ( _gameID , i , 1000000000000000000 ) ; } return ( _nt , _names , _keys , _eth , _keyPrice ) ; }
","Get current game status .
"
"function setTotle ( address _totlePrimary ) external onlyOwner { require ( _totlePrimary != address ( 0x0 ) ) ; totlePrimary = _totlePrimary ; }
","A function which allows only the owner to change the address of totlePrimary
"
"function order ( uint _clientProposalID , uint _proposalID , uint _amount ) external returns ( bool ) ;
","Function used by the client to order according to the contractor proposal
"
"function makeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { require ( Fund ( address ( this ) ) . owner ( ) == msg . sender ) ; require ( ! Fund ( address ( this ) ) . isShutDown ( ) ) ; ERC20 makerAsset = ERC20 ( orderAddresses [ 2 ] ) ; ERC20 takerAsset = ERC20 ( orderAddresses [ 3 ] ) ; uint makerQuantity = orderValues [ 0 ] ; uint takerQuantity = orderValues [ 1 ] ; require ( makeOrderPermitted ( makerQuantity , makerAsset , takerQuantity , takerAsset ) ) ; require ( makerAsset . approve ( targetExchange , makerQuantity ) ) ; uint orderId = MatchingMarket ( targetExchange ) . offer ( makerQuantity , makerAsset , takerQuantity , takerAsset ) ; require ( orderId != 0 ) ; require ( Fund ( address ( this ) ) . isInAssetList ( takerAsset ) || Fund ( address ( this ) ) . getOwnedAssetsLength ( ) < Fund ( address ( this ) ) . MAX_FUND_ASSETS ( ) ) ; Fund ( address ( this ) ) . addOpenMakeOrder ( targetExchange , makerAsset , orderId ) ; Fund ( address ( this ) ) . addAssetToOwnedAssets ( takerAsset ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( orderId ) , Fund . UpdateType . make , [ address ( makerAsset ) , address ( takerAsset ) ] , [ makerQuantity , takerQuantity , uint ( 0 ) ] ) ; }
","Makes an order on the selected exchange
"
"function ( ) payable stopInEmergency onlyAfterStart onlyBeforeEnd public { require ( crowdsaleClosed == false ) ; require ( tokensAvailableForSale > tokensSoldOnPublicRound ) ; require ( msg . value > 500000000000000 ) ; if ( ( balanceOf [ msg . sender ] + msg . value ) > maxPurchaseNonWhiteListed && whiteList [ msg . sender ] == false ) { nonWLBalanceOf [ msg . sender ] += msg . value ; } else { sendTokens ( msg . sender , msg . value ) ; } }
","Main Payable function .
"
"function approve ( address _spender , uint256 _value ) public whenNotPaused afterCrowdsale returns ( bool ) { return super . approve ( _spender , _value ) ; }
","Override the functions to not allow token transfers until the end of the ICO
"
"function transfer ( address _to , uint256 _value ) public whenNotPaused returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balanceOf ( msg . sender ) ) ; spentAct [ msg . sender ] = spentAct [ msg . sender ] . add ( _value ) ; receivedAct [ _to ] = receivedAct [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","Same as the default ERC20 transfer ( ) with two differences : 1 .
"
"function hasNotaryBeenAdded ( address notary ) public view validAddress ( notary ) returns ( bool ) { return notaryInfo [ notary ] . addedAt != 0 ; }
","Checks if the given notary was added to notarize this DataOrder .
"
"function transfer ( address to , uint amount ) public notDeprecated returns ( bool success ) { require ( lib . transfer ( lib . getTokenSymbol ( address ( this ) ) , to , amount , ""0x0"" ) , ""Error: Unable to transfer funds. Please check your parameters."" ) ; return true ; }
","transfers 'amount ' from msg.sender to a receiving account 'to '
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }
","Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
"
"function removeODEMClaim ( address subject , bytes32 key ) public { require ( hasRole ( msg . sender , ROLE_ISSUER ) || msg . sender == subject , ""Access denied: missing role"" ) ; address resolved = resolveAddress ( subject ) ; delete claims [ resolved ] [ key ] ; emit ClaimRemoved ( msg . sender , subject , key , now ) ; }
","Remove an ODEM claim .
"
"function setStage2Start ( uint256 _startStage2Time ) public onlyCreator { require ( _startStage2Time > now && _startStage2Time > startTime && _startStage2Time < deadline ) ; startStage2Time = _startStage2Time ; }
","Set timestamp of Stage2 start
"
"function claimTokens ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } MinimalTokenInterface token = MinimalTokenInterface ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function claimReward ( uint256 _blockNumber ) internal isCoinbase ( _blockNumber ) submittedBlock ( _blockNumber ) returns ( uint256 ) { blocks [ _blockNumber ] . state = BlockStateEnum . claimed ; return BLOCKREWARD ; }
","Used by a miner to claim their merged mined RTC
"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balances [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function transferAllFunds ( address _destination ) public onlyAllowed { uint256 balance = appc . balanceOf ( address ( this ) ) ; appc . transfer ( _destination , balance ) ; }
","Transfers all funds of the contract to a single address This function is used for finance contract upgrades in order to be more cost efficient .
"
"function tokenURI ( uint256 _tokenId ) external view returns ( string infoUrl ) { return concat ( toSlice ( metadataUrlPrefix ) , toSlice ( concat ( toSlice ( uintToString ( _tokenId ) ) , toSlice ( metadataUrlSuffix ) ) ) ) ; }
","A distinct Uniform Resource Identifier ( URI ) for a given asset .
"
"function setManager ( address _addr , address _newManager ) external { address addr = _addr == 0 ? msg . sender : _addr ; require ( getManager ( addr ) == msg . sender , ""Not the manager"" ) ; managers [ addr ] = _newManager == addr ? 0 : _newManager ; emit ManagerChanged ( addr , _newManager ) ; }
","Sets the ` _newManager ` as manager for the ` _addr ` address .
"
"function getNewsContractAddress ( ) external view returns ( address ) { return currentApp . NewsContractEntity ( ) ; }
","Get current News Contract address
"
"function lastRateUpdateTimesForCurrencies ( bytes4 [ ] currencyKeys ) public view returns ( uint [ ] ) { uint [ ] memory lastUpdateTimes = new uint [ ] ( currencyKeys . length ) ; for ( uint8 i = 0 ; i < currencyKeys . length ; i ++ ) { lastUpdateTimes [ i ] = lastRateUpdateTimes [ currencyKeys [ i ] ] ; } return lastUpdateTimes ; }
","Retrieve the last update time for a specific currency
"
"function withdrawPayments ( ) external ;
","withdraw accumulated balance , called by payee in case crowdsale failed
"
"function terminateSelfDestruct ( ) external onlyOwner { require ( selfDestructInitiated , ""Self-destruct not yet initiated."" ) ; selfDestructInitiationTime = 0 ; selfDestructInitiated = false ; emit SelfDestructTerminated ( ) ; }
","Terminate and reset the self-destruction timer .
"
"function setController ( address _controller ) external ;
","Used by the issuer to set the controller addresses
"
"function pauseSale ( bool _flag ) public onlyOwner { paused = _flag ; }
","Funtion to pause the sale
"
"function capReached ( ) public view returns ( bool ) { return tokensRaised >= tokenCap ; }
","Checks whether the tokenCap has been reached .
"
"function freezeAccount ( address _from ) onlyOwner public { require ( now < 1542326400 ) ; require ( frozenAccount [ _from ] == 0 ) ; frozenAccount [ _from ] = 1542326399 ; }
","Freezes from sending & receiving tokens .
"
"function changeTokenOwnerWalletAddress ( address _tokenOwnerWallet ) public validate_address ( _tokenOwnerWallet ) onlyOwner { tokenOwnerWallet = _tokenOwnerWallet ; }
","Function to change the token fund owner wallet address
"
"function setPriceStalePeriod ( uint _time ) external onlyOwner { priceStalePeriod = _time ; emit PriceStalePeriodUpdated ( priceStalePeriod ) ; }
","Set the stale period on the updated price variables
"
"function changeBeneficiary ( address _newBeneficiary ) public onlyOwner { if ( _newBeneficiary != address ( 0 ) ) { beneficiary = _newBeneficiary ; } }
","Changes beneficiary address .
"
"function sendBoughtTokens ( address _beneficiary , uint256 _tokens ) external ;
","Called when tokens are bought in token sale
"
"function transfer ( Data storage self , string currency , address to , uint amount , bytes data ) internal returns ( bool success ) { require ( address ( to ) != 0x0 , ""Error: `to` address cannot be null."" ) ; require ( amount > 0 , ""Error: `amount` must be greater than zero"" ) ; address feeContract = getFeeContract ( self , address ( this ) ) ; uint fees = calculateFees ( self , feeContract , amount ) ; require ( setAccountSpendingAmount ( self , msg . sender , getFxUSDAmount ( self , currency , amount ) ) , ""Error: Unable to set spending amount for account."" ) ; require ( forceTransfer ( self , currency , msg . sender , to , amount , data ) , ""Error: Unable to transfer funds to account."" ) ; require ( forceTransfer ( self , currency , msg . sender , feeContract , fees , getFeeMsg ( self , feeContract ) ) , ""Error: Unable to transfer fees to fee contract."" ) ; return true ; }
","Transfer an amount of currency token from msg.sender account to another specified account
"
"function updateRenExTokens ( RenExTokens _newRenExTokensContract ) external onlyOwner { emit LogRenExTokensUpdated ( renExTokensContract , _newRenExTokensContract ) ; renExTokensContract = _newRenExTokensContract ; }
","The owner of the contract can update the RenExTokens address .
"
"function decreaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F43 ) , _token , _spender , _subtractedValue , _fee , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by decreaseApprovalPreSigned
"
"function destroyTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupplyAt ( block . number ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOfAt ( _owner , block . number ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; emit Transfer ( _owner , 0 , _amount ) ; return true ; }
","Burns ` _amount ` tokens from ` _owner `
"
"function setAttributeTypeSecondarySource ( uint256 ID , address attributeRegistry , uint256 sourceAttributeTypeID ) external ;
","Set a secondary source for a given attribute type ID ` ID ` , with an address ` registry ` of the secondary source in question and a given ` sourceAttributeTypeID ` for attribute type ID to check on the secondary source .
"
"function _allowance ( uint _fromId , uint _toId , bytes32 _symbol ) internal view returns ( uint ) { return assets [ _symbol ] . wallets [ _fromId ] . allowance [ _toId ] ; }
","Returns asset allowance from one holder to another .
"
"function approveSiring ( address _addr , uint256 _sireId ) external whenNotPaused { require ( _owns ( msg . sender , _sireId ) ) ; matingAllowedToAddress [ _sireId ] = _addr ; }
","Grants approval to another user to sire with one of your Ponies .
"
"function orderMatch ( bytes32 _orderID ) external view returns ( bytes32 ) ;
","returns a list of matched orders to the given orderID .
"
"function validateUnlinkSignature ( address _addressToRemove , bytes32 _nonce , bytes _unlinkSignature ) private { require ( linkIds [ _addressToRemove ] != 0 , ""Address does not have active link"" ) ; bytes32 _signatureDigest = generateRemoveAddressSchemaHash ( _addressToRemove , _nonce ) ; require ( _addressToRemove == recoverSigner ( _signatureDigest , _unlinkSignature ) ) ; burnSignatureDigest ( _signatureDigest , _addressToRemove ) ; }
","Verify unlink signature is valid and unused
"
"function setTokenXCurrency ( address asset , string currency ) public onlyOwner notDeprecated returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tokenx' , asset , currency ) ) ; require ( lib . Storage . setBool ( id , true ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; require ( setAssetCurrency ( asset , currency ) ) ; return true ; }
","This method may be deprecated or refactored to allow for multiple interfaces
"
"function withdraw ( uint _amount ) ;
","Function to allow contractors to withdraw ethers
"
"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; if ( ( _amount != 0 ) && ( allowed [ msg . sender ] [ _spender ] != 0 ) ) throw ; if ( ( controller != 0 ) && ( isContract ( controller ) ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) throw ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf
"
"function createPermission ( address _entity , address _app , bytes32 _role , address _manager ) external { require ( hasPermission ( msg . sender , address ( this ) , CREATE_PERMISSIONS_ROLE ) ) ; _createPermission ( _entity , _app , _role , _manager ) ; }
","Create a new permission granting ` _entity ` the ability to perform actions of role ` _role ` on ` _app ` ( setting ` _manager ` as the permission manager )
"
"function floorLog2 ( uint256 _n ) internal pure returns ( uint8 ) { uint8 res = 0 ; if ( _n < 256 ) { while ( _n > 1 ) { _n >>= 1 ; res += 1 ; } } else { for ( uint8 s = 128 ; s > 0 ; s >>= 1 ) { if ( _n >= ( ONE << s ) ) { _n >>= s ; res |= s ; } } } return res ; }
","Compute the largest integer smaller than or equal to the binary logarithm of the input
"
"function _clearApproval ( address _owner , uint256 _tokenId ) private { require ( ownerOf ( _tokenId ) == _owner ) ; tokenApprovals [ _tokenId ] = 0 ; Approval ( _owner , 0 , _tokenId ) ; }
","Internal function to clear current approval of a given token ID
"
"function _preValidatePurchase ( address _beneficiary , uint256 _investedAmount ) internal view { require ( _beneficiary != address ( 0 ) , ""Beneficiary address should not be 0x"" ) ; require ( _investedAmount != 0 , ""Amount invested should not be equal to 0"" ) ; require ( totalTokensSold . add ( _getTokenAmount ( _investedAmount ) ) <= cap , ""Investment more than cap is not allowed"" ) ; require ( now >= startTime && now <= endTime , ""Offering is closed/Not yet started"" ) ; }
","Validation of an incoming purchase .
"
"function getDetails ( string _symbol ) public view returns ( address , uint256 , string , bytes32 , bool ) ;
","Returns the owner and timestamp for a given symbol
"
"function unpause ( ) public onlyCEO whenPaused { paused = false ; }
","This is public rather than external so it can be called by derived contracts .
"
"function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) { uint256 discount = 0 ; if ( _etherAmount <= firstTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( FIRST_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > firstTierDiscountUpperLimitEther && _etherAmount <= secondTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( SECOND_TIER_DISCOUNT ) . div ( 100 ) ; } else { discount = _contributorTokens . mul ( THIRD_TIER_DISCOUNT ) . div ( 100 ) ; } DiscountApplied ( _etherAmount , _contributorTokens , discount ) ; return discount . add ( _contributorTokens ) ; }
","Applies the discount based on the discount tiers
"
"function getNextDate ( uint32 _timestamp ) internal pure returns ( uint32 ) { return getDate ( _timestamp . add ( DAY ) ) ; }
","Does n't change state
"
"function totalSupply ( bytes32 _symbol ) public view returns ( uint ) { return get ( store , assetTotalSupply , _symbol ) ; }
","Returns asset total supply .
"
"function collectTokens ( ) public onlyOwner { uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 4 years ) ) ; uint256 balance = wrp . balanceOf ( address ( this ) ) ; require ( wrp . transfer ( owner , balance ) ) ; TokensWithdrawn ( owner , balance ) ; }
","The Dev ( Owner ) will call this method to extract the tokens
"
"function implementsERC165Interface ( address _contract , bytes4 _interfaceId ) public view returns ( bool ) { if ( ! erc165Cached [ _contract ] [ _interfaceId ] ) { updateERC165Cache ( _contract , _interfaceId ) ; } return interfaces [ _contract ] [ _interfaceId ] != 0 ; }
","Checks whether a contract implements an ERC165 interface or not .
"
"function renounceOwnership ( ) public onlyOwner { emit OwnershipTransferred ( _owner , address ( 0 ) ) ; _owner = address ( 0 ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function deposit ( uint256 _value ) private { reserveAddress . transfer ( _value ) ; balances [ reserveAddress ] += _value ; }
","Deposits '_value ' in wei to the reserve address
"
"function listPairForSupplier ( address supplier , ERC20 src , ERC20 dest , bool add ) public onlyAdmin { ( perSupplierListedPairs [ supplier ] ) [ keccak256 ( src , dest ) ] = add ; if ( src != ETH_TOKEN_ADDRESS ) { if ( add ) { src . approve ( supplier , 2 ** 255 ) ; } else { src . approve ( supplier , 0 ) ; } } setDecimals ( src ) ; setDecimals ( dest ) ; emit ListSupplierPairs ( supplier , src , dest , add ) ; }
","can be called only by admin
"
"function getPrices ( ) public view returns ( uint256 , uint256 ) { return ( sellPrice , buyPrice ) ; }
","Get the current buy and sell prices
"
"function allowance ( address _owner , address _spender ) public erc20 constant returns ( uint256 remaining ) { return mAllowed [ _owner ] [ _spender ] ; }
","ERC20 backwards compatible allowance .
"
"function getOwner ( ) public view returns ( address ) { return owners [ 0 ] ; }
","Gets owner 's address that is used to confirm txs .
"
"function performBuyOrder ( OrderData data , uint256 amountToSpend ) public payable whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { if ( msg . value != amountToSpend ) { totlePrimary . transfer ( msg . value ) ; return ( 0 , 0 ) ; } weth . deposit . value ( amountToSpend ) ( ) ; approveAddress ( address ( oasis ) , address ( weth ) ) ; uint256 maxPayGem ; address payGem ; uint256 maxBuyGem ; address buyGem ; ( maxPayGem , payGem , maxBuyGem , buyGem ) = oasis . getOffer ( data . offerId ) ; if ( buyGem != address ( weth ) ) { errorReporter . revertTx ( ""buyGem != address(weth)"" ) ; } uint256 amountToBuy = SafeMath . div ( SafeMath . mul ( amountToSpend , maxPayGem ) , maxBuyGem ) ; if ( ! oasis . buy ( data . offerId , amountToBuy ) ) { errorReporter . revertTx ( ""Oasis buy failed"" ) ; } uint256 newMaxPayGem ; uint256 newMaxBuyGem ; ( newMaxPayGem , , newMaxBuyGem , ) = oasis . getOffer ( data . offerId ) ; amountReceivedFromOrder = maxPayGem - newMaxPayGem ; amountSpentOnOrder = maxBuyGem - newMaxBuyGem ; if ( amountSpentOnOrder < amountToSpend ) { weth . withdraw ( amountToSpend - amountSpentOnOrder ) ; totlePrimary . transfer ( amountToSpend - amountSpentOnOrder ) ; } if ( ! ERC20 ( payGem ) . transfer ( totlePrimary , amountReceivedFromOrder ) ) { errorReporter . revertTx ( ""Unable to transfer bought tokens to totlePrimary"" ) ; } }
","Perform a buy order at the exchange
"
"function totalSupplyAt ( uint _blockNumber ) public constant returns ( uint256 ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function _isValidSignatureAndData ( address _address , bytes _signature ) internal view returns ( bool ) { require ( msg . data . length > SIGNATURE_SIZE ) ; bytes memory data = new bytes ( msg . data . length - SIGNATURE_SIZE ) ; for ( uint i = 0 ; i < data . length ; i ++ ) { data [ i ] = msg . data [ i ] ; } return _isValidDataHash ( keccak256 ( abi . encodePacked ( address ( this ) , _address , data ) ) , _signature ) ; }
","the _signature parameter of the method being validated must be the `` last '' parameter
"
"function isSignedBy ( bytes32 hash , address signer , bytes signature ) private pure returns ( bool ) { require ( signer != address ( 0 ) ) ; bytes32 prefixedHash = ECRecovery . toEthSignedMessageHash ( hash ) ; address recovered = ECRecovery . recover ( prefixedHash , signature ) ; return recovered == signer ; }
","Checks if the signature was created by the signer .
"
"function checkValidityOfBalance ( ) private view { assert ( this . balance >= m_myDebtInWei ) ; }
","It is always must be true , for correct withdrawals and receivers ETH .
"
"function updateEarnedBy ( uint256 _tokenId , uint256 _earnedBy ) public onlyManager whenNotPaused { require ( exists ( _tokenId ) ) ; _updateEarnedBy ( _tokenId , _earnedBy ) ; }
","Helps in updating the earned _by property of an asset/token .
"
"function extendRequestTimeLock ( bytes32 _requestMsgHash ) public onlyPrimary { Request storage request = requestMap [ _requestMsgHash ] ; require ( request . callbackAddress != address ( 0 ) ) ; require ( request . extended != true ) ; request . extended = true ; emit TimeLockExtended ( request . timestamp + extendedTimeLock , _requestMsgHash ) ; }
","Extend the time lock of a pending request .
"
"function mint ( address target , uint256 mintedAmount ) public onlyManager whenNotPaused { require ( target != 0 ) ; require ( mintedAmount > 0 ) ; require ( balanceOf [ target ] + mintedAmount >= balanceOf [ target ] ) ; require ( totalSupply + mintedAmount >= totalSupply ) ; balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
","function mint to be executed by Manager of token
"
"function isCreatorAndOwner ( address _address , uint256 _tokenId ) internal view returns ( bool ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; address owner = lookupData . owner ; address creator = pixelcons [ lookupData . tokenIndex ] . creator ; return ( _address == owner && _address == creator ) ; }
","Check whether the given editor is the current owner and original creator of a given token ID
"
"function getAdmin ( ) public view returns ( address ) { return admin ; }
","Get the current admin
"
"function disapproveAll ( address _to ) public whenNotPaused { require ( _to != msg . sender ) ; delete operatorApprovals [ msg . sender ] [ _to ] ; ApprovalForAll ( msg . sender , _to , false ) ; }
","Removes approval for another address to claim for the ownership of any tokens owned by this account .
"
"function offerCanvasForSale ( uint32 _canvasId , uint _minPrice ) external { _offerCanvasForSaleInternal ( _canvasId , _minPrice , 0x0 ) ; }
","Offer canvas for sale for a minimal price .
"
"function distributeTokens ( address beneficiary , uint256 tokenAmount ) internal { token . mint ( beneficiary , tokenAmount ) ; }
","Override to create custom distribution mechanisms
"
"function do_grant_tokens ( address _to , uint256 _nTokens ) internal returns ( bool ) { require ( token . generate_token_for ( _to , _nTokens ) ) ; tokensGenerated = tokensGenerated . add ( _nTokens ) ; return true ; }
","triggers token generaton for the recipient can be called only from the token sale contract itself side effect : increases the generated tokens counter CAUTION : we do not check campaign state and parameters assuming that 's callee 's task
"
"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner { doMint ( _tokenHolder , _amount , _operatorData ) ; }
","Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .
"
"function appendDebtLedgerValue ( uint value ) external onlyAssociatedContract { debtLedger . push ( value ) ; }
","Append a value to the debt ledger
"
"function tokenExists ( uint256 _tokenId ) public view returns ( bool ) { address owner = tokenOwner [ _tokenId ] ; return owner != address ( 0 ) ; }
","Check whether token is minted
"
"function buy ( ) public payable whenNotPaused isWhitelisted ( msg . sender ) { uint256 amount = msg . value . mul ( 1e18 ) ; amount = amount . div ( sellPrice ) ; require ( amount >= MINIMUM_BUY_AMOUNT , ""Buy amount too small"" ) ; _transfer ( this , msg . sender , amount ) ; }
","buy function has minimum allowed amount one can buy
"
"function _recordFeePayment ( uint xdrAmount ) internal { uint remainingToAllocate = xdrAmount ; for ( uint i = FEE_PERIOD_LENGTH - 1 ; i < FEE_PERIOD_LENGTH ; i -- ) { uint delta = recentFeePeriods [ i ] . feesToDistribute . sub ( recentFeePeriods [ i ] . feesClaimed ) ; if ( delta > 0 ) { uint amountInPeriod = delta < remainingToAllocate ? delta : remainingToAllocate ; recentFeePeriods [ i ] . feesClaimed = recentFeePeriods [ i ] . feesClaimed . add ( amountInPeriod ) ; remainingToAllocate = remainingToAllocate . sub ( amountInPeriod ) ; if ( remainingToAllocate == 0 ) return ; } } assert ( remainingToAllocate == 0 ) ; }
","Record the fee payment in our recentFeePeriods .
"
"function _deliverTokens ( address _beneficiary , uint256 _tokenAmount ) internal { token . transfer ( _beneficiary , _tokenAmount ) ; }
","Function transfers tokens from contract to beneficiary address .
"
"function redeemCoinsToICO ( uint256 amountOfCoinsToRedeem ) public returns ( bool success ) { uint amount = amountOfCoinsToRedeem ; msgSndr [ msg . sender ] = amount ; bool isPreview = false ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool icosuccess ; uint redeemPaymentValue ; ( icosuccess , redeemPaymentValue ) = ico . redeemCoin ( amount , msg . sender , isPreview ) ; require ( icosuccess == true ) ; require ( _getIcoAddr ( ) . balance >= safeAdd ( ico . getMinBal ( ) , redeemPaymentValue ) ) ; bool sucsTrTk = false ; bool pymActSucs = false ; if ( isPreview == false ) { sucsTrTk = _safeTransferTkn ( msg . sender , owner , amount ) ; require ( sucsTrTk == true ) ; msgSndr [ msg . sender ] = redeemPaymentValue ; pymActSucs = _safePaymentActionAtIco ( redeemPaymentValue , msg . sender , 1 ) ; require ( pymActSucs == true ) ; } msgSndr [ msg . sender ] = 0 ; return ( true ) ; }
","Allows Token owners to Redeem Tokens to this Contract for its value promised
"
"function confirmCustodianChange ( bytes32 _lockId ) public onlyCustodian { custodian = getCustodianChangeReq ( _lockId ) ; delete custodianChangeReqs [ _lockId ] ; emit CustodianChangeConfirmed ( _lockId , custodian ) ; }
","Confirms a pending change of the custodian associated with this contract .
"
"function getContributors ( bool _pending , bool _claimed ) view public returns ( address [ ] contributors ) { uint256 i = 0 ; uint256 results = 0 ; address [ ] memory _contributors = new address [ ] ( contributorsKeys . length ) ; if ( goalReached ( ) ) { for ( i = 0 ; i < contributorsKeys . length ; i ++ ) { if ( _pending && stakes [ contributorsKeys [ i ] ] > 0 || _claimed && stakes [ contributorsKeys [ i ] ] == 0 ) { _contributors [ results ] = contributorsKeys [ i ] ; results ++ ; } } } else { for ( i = 0 ; i < contributorsKeys . length ; i ++ ) { if ( _pending && vault . deposited ( contributorsKeys [ i ] ) > 0 || _claimed && vault . deposited ( contributorsKeys [ i ] ) == 0 ) { _contributors [ results ] = contributorsKeys [ i ] ; results ++ ; } } } contributors = new address [ ] ( results ) ; for ( i = 0 ; i < results ; i ++ ) { contributors [ i ] = _contributors [ i ] ; } return contributors ; }
","Get contributor addresses to manage refunds or token claims .
"
"function getKittyInfo ( uint256 _tokenId ) external view returns ( uint32 kittyId , uint256 price , address owner , bool selled ) { Kitty storage kitty = kitties [ _tokenId ] ; kittyId = kitty . kittyId ; price = TokenIdToPrice [ _tokenId ] ; owner = TokenIdToOwner [ _tokenId ] ; selled = tokenToSell [ _tokenId ] ; }
","Returns all the relevant information about a specific tokenId .
"
"function name ( ) public view returns ( string ) ;
","A descriptive name for a collection of NFTs in this contract
"
"function addDataResponseToOrder ( address orderAddr , address seller , address notary , string dataHash , bytes signature ) public whenNotPaused isOrderLegit ( orderAddr ) returns ( bool ) { DataOrder order = DataOrder ( orderAddr ) ; address buyer = order . buyer ( ) ; require ( msg . sender == buyer ) ; allDistinct ( [ orderAddr , buyer , seller , notary , address ( this ) ] ) ; require ( order . hasNotaryBeenAdded ( notary ) ) ; require ( CryptoUtils . isDataResponseValid ( orderAddr , seller , notary , dataHash , signature ) ) ; bool okay = order . addDataResponse ( seller , notary , dataHash ) ; require ( okay ) ; chargeBuyer ( order , seller ) ; ordersBySeller [ seller ] . push ( orderAddr ) ; emit DataAdded ( order , seller ) ; return true ; }
","Adds a new DataResponse to the given order .
"
"function allowNewStakes ( ) public onlyAdmin returns ( bool ) { newStakesAllowed = true ; require ( RTI . stakeContractAddress ( ) == address ( this ) , ""rtc token contract is not set to use this contract as the staking contract"" ) ; return true ; }
","Used to allow new stakes to be made
"
"function sqrt ( uint64 x ) pure internal returns ( uint64 y ) { uint64 z = ( x + 1 ) / 2 ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / 2 ; } }
","square root function used for weight gain/loss
"
"function createRequest ( address _creator , address [ ] _payees , int256 [ ] _expectedAmounts , address _payer , string _data ) external whenNotPaused returns ( bytes32 requestId ) { require ( _creator != 0 , ""creator should not be 0"" ) ; require ( isTrustedContract ( msg . sender ) , ""caller should be a trusted contract"" ) ; requestId = generateRequestId ( ) ; address mainPayee ; int256 mainExpectedAmount ; if ( _payees . length != 0 ) { mainPayee = _payees [ 0 ] ; mainExpectedAmount = _expectedAmounts [ 0 ] ; } requests [ requestId ] = Request ( _payer , msg . sender , State . Created , Payee ( mainPayee , mainExpectedAmount , 0 ) ) ; emit Created ( requestId , mainPayee , _payer , _creator , _data ) ; initSubPayees ( requestId , _payees , _expectedAmounts ) ; return requestId ; }
","Function used by currency contracts to create a request in the Core .
"
"function setSizeAndRate ( uint256 _size , uint256 _rate ) public onlyOwner returns ( bool ) { return setSize ( _size ) && setRate ( _rate ) ; }
","Change size and refill rate of bucket
"
"function areAllBalanceNull ( bytes32 _requestId ) public view returns ( bool isNull ) { isNull = requests [ _requestId ] . payee . balance == 0 ; for ( uint8 i = 0 ; isNull && subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { isNull = subPayees [ _requestId ] [ i ] . balance == 0 ; } return isNull ; }
","Checks if all the payees balances are null .
"
"function proposal ( uint _proposalId ) public view returns ( uint _startBlock , uint _startTime , uint _duration , bool _active , bool _finalized , uint [ 15 ] _votes , address [ 15 ] _tokens , address _votingToken , bool _hasBalance ) { require ( _proposalId < tokenBatches . length ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; _startBlock = p . startBlock ; _startTime = p . startTime ; _duration = p . duration ; _finalized = ( _startTime + _duration < now ) ; _active = ! _finalized && ( p . startBlock < getBlockNumber ( ) ) ; _votes = p . yesVotes ; _tokens = p . consideredTokens ; _votingToken = p . votingToken ; _hasBalance = ( p . votingToken == 0x0 ) ? false : ( DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) > 0 ) ; }
","Get data about specific proposal
"
"function setTokenTLA ( Data storage self , string tokenTLA ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.tla' , address ( this ) ) ) ; require ( self . Storage . setString ( id , tokenTLA ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set the token three letter abreviation ( TLA ) for Token interfaces
"
"function changeAllowAllWhitelistTransfers ( bool _allowAllWhitelistTransfers ) public withPerm ( FLAGS ) { allowAllWhitelistTransfers = _allowAllWhitelistTransfers ; emit LogAllowAllWhitelistTransfers ( _allowAllWhitelistTransfers ) ; }
","Used to change the flag true - It refers that time lock is ignored for transfers ( address must still be on whitelist ) false - It refers transfers are restricted for all addresses .
"
"function cooperativeClose ( address _receiver_address , uint32 _open_block_number , uint192 _balance , bytes _balance_msg_sig , bytes _closing_sig ) external { address sender = extractBalanceProofSignature ( _receiver_address , _open_block_number , _balance , _balance_msg_sig ) ; address receiver = extractClosingSignature ( sender , _open_block_number , _balance , _closing_sig ) ; require ( receiver == _receiver_address ) ; settleChannel ( sender , receiver , _open_block_number , _balance ) ; }
","Function called by the sender , receiver or a delegate , with all the needed signatures to close the channel and settle immediately .
"
"function bulkMint ( address _to , string _tokenURI , uint number ) external onlyOwner { uint currentId = tokenId ; for ( uint i = 0 ; i < number ; i ++ ) { _mint ( _to , currentId ) ; _setTokenURI ( currentId , _tokenURI ) ; currentId ++ ; } tokenId = currentId ; }
","Same as mint ( ) , but mints multiple identical tokens at once only the current contract owner can do that
"
"function reclaim ( IBasicToken token ) public { require ( token != RECLAIM_ETHER ) ; Reclaimable . reclaim ( token ) ; }
","allows EtherToken to reclaim tokens wrongly sent to its address
"
"function moveTokensToEscrowLockupFor ( address _sender , uint256 _amount , bytes32 _nonce , bytes _delegationSig ) external { validateLockupTokensSig ( _sender , _amount , _nonce , _delegationSig ) ; moveTokensToEscrowLockupForUser ( _sender , _amount ) ; }
","Lockup tokens for set time period on behalf of user .
"
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ _to ] + _amount <= balances [ _to ] ) return false ; if ( balances [ msg . sender ] < _amount ) return false ; balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; }
","Transfer Spork tokens from ` msg.sender ` to another account .
"
"function getPrice ( ) external view returns ( uint256 ) { if ( manualOverride ) { return manualPrice ; } ( bytes32 price , bool valid ) = Medianizer ( makerDAO ) . peek ( ) ; require ( valid , ""MakerDAO Oracle returning invalid value"" ) ; return uint256 ( price ) ; }
","Returns price - should throw if not valid
"
"function successful ( ) public { require ( state == State . Successful ) ; if ( now > completedAt . add ( 14 days ) ) { uint256 remanent = tokenReward . balanceOf ( this ) ; tokenReward . transfer ( creator , remanent ) ; emit LogContributorsPayout ( creator , remanent ) ; } creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
","successful closure handler
"
"function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens = challenges [ _challengeID ] . winningTokens . sub ( voterTokens ) ; challenges [ _challengeID ] . rewardPool = challenges [ _challengeID ] . rewardPool . sub ( reward ) ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; emit _RewardClaimed ( _challengeID , reward ) ; require ( token . transfer ( msg . sender , reward ) ) ; }
","claim the tokens owed for the msg.sender in the provided challenge
"
"function buy ( ) public payable { buyInternal ( msg . sender , msg . value , 0 ) ; }
","crowdsale participation
"
"function hasIdentity ( address _address ) public view returns ( bool ) { return identityExists ( associatedAddressDirectory [ _address ] ) ; }
","Checks if the passed address is associated with an Identity .
"
"function darknodeDeregisteredAt ( address darknodeID ) external view onlyOwner returns ( uint256 ) { return darknodeRegistry [ darknodeID ] . deregisteredAt ; }
","Returns the deregistration time of a given darknode .
"
"function getState ( bytes32 _requestId ) public view returns ( State ) { return requests [ _requestId ] . state ; }
","Gets state of a request .
"
"function topUp ( ) external payable { }
","add more ether to use in oraclize queries
"
"function setMainSaleStart ( uint256 _startTime ) public onlyAdmin ( 2 ) { require ( state == State . OnHold ) ; require ( _startTime > now ) ; MainSaleStart = _startTime ; MainSaleDeadline = MainSaleStart . add ( 12 weeks ) ; state = State . MainSale ; emit LogMainSaleDateSet ( MainSaleStart ) ; }
","Main Sale Start function
"
"function setHiddenCeilings ( bytes32 [ ] _ceilingHashes ) public onlyOwner { require ( ceilings . length == 0 ) ; ceilings . length = _ceilingHashes . length ; for ( uint256 i = 0 ; i < _ceilingHashes . length ; i = i . add ( 1 ) ) { ceilings [ i ] . hash = _ceilingHashes [ i ] ; } }
","This should be called by the creator of the contract to commit all the ceilings .
"
"function setConverterRamp ( ConverterRamp _converterRamp ) external onlyOwner returns ( bool ) { require ( _isContract ( _converterRamp ) , ""Should be a contract"" ) ; emit SetConverterRamp ( converterRamp , _converterRamp ) ; converterRamp = _converterRamp ; return true ; }
","Sets a new converter ramp to delegate the pay of the loan
"
"function setMergedMinerValidator ( address _mergedMinerValidator ) external onlyOwner nonAdminAddress ( _mergedMinerValidator ) returns ( bool ) { mergedMinerValidatorAddress = _mergedMinerValidator ; minters [ _mergedMinerValidator ] = true ; emit MergedMinerValidatorSet ( _mergedMinerValidator ) ; return true ; }
","This is used to set the merged miner validator contract
"
"function getReserves ( ) constant returns ( KyberReserve [ ] ) { return reserves ; }
","should be called off chain with as much gas as needed
"
"function schedulePriceUpdatesRolling ( uint256 _startTime , uint256 _interval , uint256 _iters ) payable isAdminOrOwner public { bytes32 requestId ; require ( _interval > 0 , ""Interval between scheduled time should be greater than zero"" ) ; require ( _iters > 0 , ""No iterations specified"" ) ; require ( _startTime >= now , ""Past scheduling is not allowed and scheduled time should be absolute timestamp"" ) ; require ( oraclize_getPrice ( oracleQueryType , gasLimit ) * _iters <= address ( this ) . balance , ""Insufficient Funds"" ) ; for ( uint256 i = 0 ; i < _iters ; i ++ ) { uint256 scheduledTime = _startTime + ( i * _interval ) ; requestId = oraclize_query ( scheduledTime , oracleQueryType , oracleURL , gasLimit ) ; requestIds [ requestId ] = scheduledTime ; emit LogNewOraclizeQuery ( scheduledTime , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } }
","Allows owner to schedule future Oraclize calls on a rolling schedule
"
"function disableERC20 ( ) public onlyOwner { mErc20compatible = false ; setInterfaceImplementation ( ""ERC20Token"" , 0x0 ) ; }
","Disables the ERC20 interface .
"
"function getCaptainInfo ( uint256 _tokenId ) external view returns ( uint32 captainId , uint32 color , uint32 atk , uint32 atk_min , uint32 atk_max , uint32 defense , uint256 price , address owner , bool selled ) { Captain storage captain = captains [ _tokenId ] ; captainId = captain . captainId ; color = captain . color ; atk = captain . atk ; atk_min = captain . atk_min ; atk_max = captain . atk_max ; defense = captain . defense ; price = captainTokenIdToPrice [ _tokenId ] ; owner = captainTokenIdToOwner [ _tokenId ] ; selled = tokenToSell [ _tokenId ] ; }
","Returns all the relevant information about a specific tokenId .
"
"function tokenFactory ( uint256 _amount ) public onlyOwner returns ( bool success ) { require ( tokenMinter ( _amount ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; emit Transfer ( 0 , msg . sender , _amount ) ; return true ; }
","Used to create new tokens and increase total supply
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { adjustInvestorCount ( _from , _to , _value ) ; require ( verifyTransfer ( _from , _to , _value ) , ""Transfer is not valid"" ) ; adjustBalanceCheckpoints ( _from ) ; adjustBalanceCheckpoints ( _to ) ; require ( super . transferFrom ( _from , _to , _value ) ) ; return true ; }
","Overloaded version of the transferFrom function
"
"function _mintFromDeposit ( address owner , uint amount ) public onlyTrusted { balances [ owner ] += amount ; totalOnDeposit -= amount ; totalInCirculation += amount ; }
","used by subscription module to re-create token from returning deposit .
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock > block . number ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function getRemainingBonus ( ) public view returns ( uint256 ) { return bonusProvided . sub ( bonusWithdrawn ) ; }
","Returns the remaining bonus held on behalf of the crowdsale contributors by this contract .
"
"function finalize ( ) onlyOwner afterDeadline public { require ( ! crowdsaleClosed ) ; emit Finalized ( ) ; withdrawTokens ( ) ; crowdsaleClosed = true ; isFinalized = true ; }
","Function to indicate the end of ICO .
"
"function parentOf ( uint256 identifier ) external view returns ( uint256 parentIdentifier ) { parentIdentifier = identifierToParentIdentifier [ identifier ] ; }
","Returns the identifier of the parent of an identifier .
"
"function getMinerHashRateCurrentHalving ( ) public constant returns ( bool , uint256 ) { return getHashRateOf ( msg . sender , currentHalving ( ) ) ; }
","Calculate the halving hash rate of a miner
"
"function metaApproveHash ( address _spender , uint256 _addedValue , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , ""metaIncreaseApproval"" , _spender , _addedValue , _nonce , _reward ) ) ; }
","Return hash containing all of the information about the increaseApproval ( ) metatransaction
"
"function validContribution ( ) private returns ( bool ) { bool isContributionValid = msg . value >= minPresaleContributionEther && msg . value <= maxPresaleContributionEther ; ValidContributionCheck ( msg . value , isContributionValid ) ; return isContributionValid ; }
","Ensure the contribution is valid
"
"function _getFeeHistory ( uint32 _canvasId ) private view returns ( FeeHistory storage ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; return _history ; }
","Gets a fee history of a canvas .
"
"function _suspendMarket ( address asset ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SUSPEND_MARKET_OWNER_CHECK ) ; } if ( ! markets [ asset ] . isSupported ) { return uint ( Error . NO_ERROR ) ; } markets [ asset ] . isSupported = false ; emit SuspendedMarket ( asset ) ; return uint ( Error . NO_ERROR ) ; }
","Suspends a given supported market ( asset ) from use with Compound .
"
"function calculateRewardTokens ( uint256 amount , uint8 stageNumber ) public view returns ( uint256 rewardAmount ) { if ( stageNumber < 1 || stageNumber > totalStages ) revert ( ) ; uint8 stageIndex = stageNumber - 1 ; return safeDiv ( safeMul ( amount , stageBonusPercentage [ stageIndex ] ) , 100 ) ; }
","calculate reward based on amount of tokens that will be issued to the purchaser
"
"function _internalTransfer ( address from , address to , uint amount , uint fee ) internal returns ( bool ) { require ( to != address ( 0 ) , ""Cannot transfer to the 0 address"" ) ; require ( to != address ( this ) , ""Cannot transfer to the underlying contract"" ) ; require ( to != address ( proxy ) , ""Cannot transfer to the proxy contract"" ) ; tokenState . setBalanceOf ( from , safeSub ( tokenState . balanceOf ( from ) , safeAdd ( amount , fee ) ) ) ; tokenState . setBalanceOf ( to , safeAdd ( tokenState . balanceOf ( to ) , amount ) ) ; tokenState . setBalanceOf ( FEE_ADDRESS , safeAdd ( tokenState . balanceOf ( FEE_ADDRESS ) , fee ) ) ; emitTransfer ( from , to , amount ) ; emitTransfer ( from , FEE_ADDRESS , fee ) ; return true ; }
","Base of transfer functions
"
"function _mint ( address _to , uint256 _tokenId ) internal { super . _mint ( _to , _tokenId ) ; tokens . push ( _tokenId ) ; }
","This is a private function which should be called from user-implemented external mint function .
"
"function transfer ( address _to , uint256 tokens ) whenNotPaused public returns ( bool success ) { return super . transfer ( _to , tokens ) ; }
","The transfer function
"
"function computeFee ( uint256 _amount , uint256 _fee ) public pure returns ( uint256 ) { return _amount . mul ( _fee ) . div ( 1000 ) ; }
","Compute the fee that will be charged on a `` burn '' operation .
"
"function stage ( ) constant returns ( Stage ) { if ( finalized ) { return Stage . Finalized ; } if ( ! initialized ) { return Stage . Created ; } if ( blockTime ( ) < startTime ) { return Stage . Initialized ; } if ( officialSold_ . get ( ) . add ( channelsSold ) >= publicSupply ) { return Stage . Closed ; } if ( blockTime ( ) < endTime ) { if ( blockTime ( ) < startTime . add ( earlyStageLasts ) ) { return Stage . Early ; } return Stage . Normal ; } return Stage . Closed ; }
","estimate stage
"
"function approve ( address _spender , uint256 _value ) public is_not_locked ( _spender ) returns ( bool success ) { require ( isTransferEnabled ) ; if ( _value != 0 && allowed [ msg . sender ] [ _spender ] != 0 ) revert ( ) ; if ( balances [ msg . sender ] < _value ) { return false ; } allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","msg.sender approves _spender to spend _value tokens
"
"function remainingIssuableSynths ( address issuer , bytes4 currencyKey ) public view returns ( uint ) { uint alreadyIssued = debtBalanceOf ( issuer , currencyKey ) ; uint max = maxIssuableSynths ( issuer , currencyKey ) ; if ( alreadyIssued >= max ) { return 0 ; } else { return max . sub ( alreadyIssued ) ; } }
","The remaining synths an issuer can issue against their total synthetix balance .
"
"function createRentAuction ( uint256 _deedId , uint256 _startPrice , uint256 _endPrice , uint256 _duration , uint256 _rentPeriod ) external whenNotPaused { require ( _owns ( msg . sender , _deedId ) ) ; require ( address ( rentAuctionContract ) != address ( 0 ) ) ; _approve ( msg . sender , address ( rentAuctionContract ) , _deedId ) ; rentAuctionContract . createAuction ( _deedId , _startPrice , _endPrice , _duration , _rentPeriod ) ; }
","Create a rent auction .
"
"function tokenByIndex ( uint _index ) external view returns ( uint ) { uint tokenIndexesLength = this . totalSupply ( ) ; require ( _index < tokenIndexesLength ) ; return _index ; }
","Enumerate valid NFTs
"
"function tradeWithHint ( ERC20 src , uint srcAmount , ERC20 dest , address destAddress , uint maxDestAmount , uint minConversionRate , address walletId , bytes hint ) public payable returns ( uint ) { require ( src == ETH_TOKEN_ADDRESS || msg . value == 0 ) ; UserBalance memory userBalanceBefore ; userBalanceBefore . srcBalance = getBalance ( src , msg . sender ) ; userBalanceBefore . destBalance = getBalance ( dest , destAddress ) ; if ( src == ETH_TOKEN_ADDRESS ) { userBalanceBefore . srcBalance += msg . value ; } else { require ( src . transferFrom ( msg . sender , kyberNetworkContract , srcAmount ) ) ; } uint reportedDestAmount = kyberNetworkContract . tradeWithHint . value ( msg . value ) ( msg . sender , src , srcAmount , dest , destAddress , maxDestAmount , minConversionRate , walletId , hint ) ; TradeOutcome memory tradeOutcome = calculateTradeOutcome ( userBalanceBefore . srcBalance , userBalanceBefore . destBalance , src , dest , destAddress ) ; require ( reportedDestAmount == tradeOutcome . userDeltaDestAmount ) ; require ( tradeOutcome . userDeltaDestAmount <= maxDestAmount ) ; require ( tradeOutcome . actualRate >= minConversionRate ) ; ExecuteTrade ( msg . sender , src , dest , tradeOutcome . userDeltaSrcAmount , tradeOutcome . userDeltaDestAmount ) ; return tradeOutcome . userDeltaDestAmount ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function lastDebtLedgerEntry ( ) external view returns ( uint ) { return debtLedger [ debtLedger . length - 1 ] ; }
","Retrieve the most recent entry from the debt ledger
"
"function convertRate ( Oracle oracle , bytes32 currency , bytes data , uint256 amount ) public view returns ( uint256 ) { if ( oracle == address ( 0 ) ) { return amount ; } else { uint256 rate ; uint256 decimals ; ( rate , decimals ) = oracle . getRate ( currency , data ) ; require ( decimals <= RCN_DECIMALS ) ; return ( safeMult ( safeMult ( amount , rate ) , ( 10 ** ( RCN_DECIMALS - decimals ) ) ) ) / PRECISION ; } }
","Converts an amount to RCN using the loan oracle .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( warriors [ _tokenId ] . action == IDLE ) ; _transfer ( _from , _to , _tokenId ) ; }
","Transfer a Warrior owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function tokenFactory ( uint256 _amount ) public onlyOwner returns ( bool minted ) { require ( tokenMinter ( _amount , msg . sender ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; Transfer ( 0 , msg . sender , _amount ) ; return true ; }
","Used to mint new tokens
"
"function getExchangeRate ( address numeratorToken , address denominatorToken ) public constant returns ( uint256 rateFraction , uint256 timestamp ) ;
","provides actual price of 'numeratorToken ' in 'denominatorToken ' returns timestamp at which price was obtained in oracle
"
"function authorizePayment ( string _name , bytes32 _reference , address _recipient , address _token , uint _amount , uint _paymentDelay ) whenNotPaused external returns ( uint ) { require ( allowedSpenders [ msg . sender ] ) ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment storage p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; require ( _paymentDelay <= 10 ** 18 ) ; p . earliestPayTime = _paymentDelay >= timeLock ? _getTime ( ) + _paymentDelay : _getTime ( ) + timeLock ; p . recipient = _recipient ; p . amount = _amount ; p . name = _name ; p . reference = _reference ; p . token = _token ; emit PaymentAuthorized ( idPayment , p . recipient , p . amount , p . token , p . reference ) ; return idPayment ; }
","only ` allowedSpenders [ ] ` Creates a new ` Payment `
"
"function getRanking ( ) external view returns ( address [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint counter = 0 ; for ( uint k = 0 ; k < len ; k ++ ) { arr [ counter ] = getJadeProduction ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; counter ++ ; } for ( uint i = 0 ; i < len - 1 ; i ++ ) { for ( uint j = 0 ; j < len - i - 1 ; j ++ ) { if ( arr [ j ] < arr [ j + 1 ] ) { uint256 temp = arr [ j ] ; address temp_addr = arr_addr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; arr_addr [ j ] = arr_addr [ j + 1 ] ; arr_addr [ j + 1 ] = temp_addr ; } } } return ( arr_addr , arr ) ; }
","ranking of production
"
"function totalSupply ( ) public view returns ( uint ) { return WIDTH * HEIGHT ; }
","Returns the total number of pixels currently in existence .
"
"function balanceOf ( address _owner ) public view returns ( uint _balance ) { _balance = lendersBalance [ _owner ] ; }
","Returns the number of active loans that a lender possess ; active loans are the loans with `` lent '' status .
"
"function buyWoodFactory ( ) public payable returns ( uint256 ) { return buyFactory ( FactoryType . Wood ) ; }
","buy wood factory
"
"function swapID ( address _withdrawTrader , bytes32 _secretLock , uint256 _timelock ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _withdrawTrader , _secretLock , _timelock ) ) ; }
","Generates a deterministic swap id using initiate swap details .
"
"function releaseTokens ( ) public { Allocations memory allocation ; allocation = allocations [ msg . sender ] ; require ( allocation . released == false ) ; require ( allocation . allocated > 0 ) ; require ( allocation . unlockedAt > 0 ) ; require ( now >= allocation . unlockedAt ) ; uint256 allocated = allocation . allocated ; ovc . transfer ( msg . sender , allocated ) ; allocation . allocated = 0 ; allocation . unlockedAt = 0 ; allocation . released = true ; allocations [ msg . sender ] = allocation ; }
","called by allocated address to release the token
"
"function pullDividendPayment ( uint256 _dividendIndex ) public validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; require ( ! dividend . claimed [ msg . sender ] , ""Dividend already reclaimed"" ) ; _payDividend ( msg . sender , dividend , _dividendIndex ) ; }
","Investors can pull their own dividends
"
"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { bool onApprove = TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ; require ( onApprove ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function getemoji ( uint256 _tokenId ) public view returns ( string emojiName , uint256 sellingPrice , address owner ) { Emoji storage emoji = emojis [ _tokenId ] ; emojiName = emoji . name ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific emoji .
"
"function _trimQuestion ( string q ) internal pure returns ( string ) { return q . toSlice ( ) . split ( REALITIO_DELIMITER . toSlice ( ) ) . toString ( ) ; }
","Trim the realitio question content to the part before the initial delimiter .
"
"function getLockedBalanceForUser ( address marketContractAddress , address userAddress ) external view returns ( uint ) { return contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ userAddress ] ; }
","get the currently locked balance for a user given the specific contract address
"
"function cancelApprove ( bytes32 sha ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; biometricCompleted [ sha ] = true ; return true ; }
","Cancel pending Approval , can only be called by msg.sender == biometricFrom [ sha ]
"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowance [ _owner ] [ _spender ] ; }
","function allowance : displays address allow to transfer tokens from owner
"
"function mGenerateTokens ( address owner , uint256 amount ) internal { require ( owner != address ( 0 ) ) ; require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; uint256 newTotalSupply = curTotalSupply + amount ; require ( newTotalSupply >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( owner ) ; uint256 newBalanceTo = previousBalanceTo + amount ; assert ( newBalanceTo >= previousBalanceTo ) ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceTo ) ; Transfer ( 0 , owner , amount ) ; }
","Generates ` amount ` tokens that are assigned to ` owner `
"
"function setNextGame ( uint256 _price , uint256 _timeout , uint256 _finalTimeout , uint256 _numberOfWagersToFinalTimeout ) external onlyCFO { nextPrice = _price ; nextTimeout = _timeout ; nextFinalTimeout = _finalTimeout ; nextNumberOfWagersToFinalTimeout = _numberOfWagersToFinalTimeout ; NextGame ( nextPrice , nextTimeout , nextFinalTimeout , nextNumberOfWagersToFinalTimeout ) ; }
","Set the parameters for the next game .
"
"function requestMembership ( ) public payable { Member storage sender = members [ msg . sender ] ; require ( msg . value >= memberFee && sender . membershipType == 0 ) ; membersAccts . push ( msg . sender ) ; sender . memberId = membersAccts . length ; sender . membershipType = 1 ; emit NewMember ( msg . sender , sender . memberId , sender . membershipType ) ; }
","Allows a user to become DDA members if they pay the fee .
"
"function proxyPayment ( address _account ) public payable initialized contributionOpen returns ( bool ) { require ( _account != 0x0 ) ; uint256 day = today ( ) ; require ( msg . value >= MIN_FUND ) ; uint256 toDev ; if ( proportion < 100 ) { toDev = msg . value * 100 / proportion ; destEthFoundationDev . transfer ( toDev ) ; destEthFoundation . transfer ( msg . value - toDev ) ; } else { destEthFoundationDev . transfer ( msg . value ) ; } uint256 r = ratio [ day ] ; require ( r > 0 ) ; uint256 tokenSaling = r . mul ( msg . value ) ; assert ( FCC . generateTokens ( _account , tokenSaling ) ) ; totalContributedETH += msg . value ; totalTokenSaled += tokenSaling ; NewSale ( day , msg . sender , msg . value ) ; }
","This method will generally be called by the FCC token contract to acquire FCCs .
"
"function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = recoverPreSignedHash ( address ( this ) , decreaseApprovalSig , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; require ( _nonce == nonces [ from ] . add ( 1 ) ) ; require ( _fee <= balances [ from ] ) ; nonces [ from ] = _nonce ; signatures [ _signature ] = true ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
","Decrease the amount of tokens that an owner allowed to a spender .
"
"function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) ;
","Applies the discount based on the discount tiers
"
"function _setRiskParameters ( uint collateralRatioMantissa , uint liquidationDiscountMantissa ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_RISK_PARAMETERS_OWNER_CHECK ) ; } Exp memory newCollateralRatio = Exp ( { mantissa : collateralRatioMantissa } ) ; Exp memory newLiquidationDiscount = Exp ( { mantissa : liquidationDiscountMantissa } ) ; Exp memory minimumCollateralRatio = Exp ( { mantissa : minimumCollateralRatioMantissa } ) ; Exp memory maximumLiquidationDiscount = Exp ( { mantissa : maximumLiquidationDiscountMantissa } ) ; Error err ; Exp memory newLiquidationDiscountPlusOne ; if ( lessThanExp ( newCollateralRatio , minimumCollateralRatio ) ) { return fail ( Error . INVALID_COLLATERAL_RATIO , FailureInfo . SET_RISK_PARAMETERS_VALIDATION ) ; } if ( lessThanExp ( maximumLiquidationDiscount , newLiquidationDiscount ) ) { return fail ( Error . INVALID_LIQUIDATION_DISCOUNT , FailureInfo . SET_RISK_PARAMETERS_VALIDATION ) ; } ( err , newLiquidationDiscountPlusOne ) = addExp ( newLiquidationDiscount , Exp ( { mantissa : mantissaOne } ) ) ; assert ( err == Error . NO_ERROR ) ; if ( lessThanOrEqualExp ( newCollateralRatio , newLiquidationDiscountPlusOne ) ) { return fail ( Error . INVALID_COMBINED_RISK_PARAMETERS , FailureInfo . SET_RISK_PARAMETERS_VALIDATION ) ; } Exp memory oldCollateralRatio = collateralRatio ; Exp memory oldLiquidationDiscount = liquidationDiscount ; collateralRatio = newCollateralRatio ; liquidationDiscount = newLiquidationDiscount ; emit NewRiskParameters ( oldCollateralRatio . mantissa , collateralRatioMantissa , oldLiquidationDiscount . mantissa , liquidationDiscountMantissa ) ; return uint ( Error . NO_ERROR ) ; }
","Sets the risk parameters : collateral ratio and liquidation discount
"
"function interfaceHash ( string _interfaceName ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _interfaceName ) ) ; }
","Compute the keccak256 hash of an interface given its name .
"
"function getTokensByOwner ( address _owner ) external view returns ( address [ ] ) { address [ ] memory activeUsers = getArrayAddress ( Encoder . getKey ( ""activeUsers"" ) ) ; bytes32 [ ] memory tickers ; address token ; uint256 count = 0 ; uint256 i = 0 ; uint256 j = 0 ; for ( i = 0 ; i < activeUsers . length ; i ++ ) { tickers = getArrayBytes32 ( Encoder . getKey ( ""userToTickers"" , activeUsers [ i ] ) ) ; for ( j = 0 ; j < tickers . length ; j ++ ) { token = getAddress ( Encoder . getKey ( ""tickerToSecurityToken"" , Util . bytes32ToString ( tickers [ j ] ) ) ) ; if ( token != address ( 0 ) ) { if ( IOwnable ( token ) . owner ( ) == _owner ) { count = count + 1 ; } } } } uint256 index = 0 ; address [ ] memory result = new address [ ] ( count ) ; for ( i = 0 ; i < activeUsers . length ; i ++ ) { tickers = getArrayBytes32 ( Encoder . getKey ( ""userToTickers"" , activeUsers [ i ] ) ) ; for ( j = 0 ; j < tickers . length ; j ++ ) { token = getAddress ( Encoder . getKey ( ""tickerToSecurityToken"" , Util . bytes32ToString ( tickers [ j ] ) ) ) ; if ( token != address ( 0 ) ) { if ( IOwnable ( token ) . owner ( ) == _owner ) { result [ index ] = token ; index = index + 1 ; } } } } return result ; }
","Returns the list of tokens owned by the selected address
"
"function unregisterUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; uint _memberIndex = memberAddress2index [ _user ] ; if ( _memberIndex == 0 || address2member [ _user ] . groupsCount != 0 ) { return USER_MANAGER_INVALID_INVOCATION ; } uint _membersCount = membersCount ; delete memberAddress2index [ _user ] ; if ( _memberIndex != _membersCount ) { address _lastUser = index2memberAddress [ _membersCount ] ; index2memberAddress [ _memberIndex ] = _lastUser ; memberAddress2index [ _lastUser ] = _memberIndex ; } delete address2member [ _user ] ; delete index2memberAddress [ _membersCount ] ; delete memberAddress2index [ _user ] ; membersCount = _membersCount . sub ( 1 ) ; UserDeleted ( _user ) ; return OK ; }
","Discard user registration Can be called only by contract owner
"
"function unfreezeTokenTransfer ( bool _freeze ) public onlyController { tokenFrozen = ! _freeze ; }
","unfreeze token transfer
"
"function price ( ) public view returns ( uint256 ) { return tokenPerEth . mul ( BONUS ) . div ( 1e2 ) ; }
","Calculates the price as tokens/ether based on the corresponding bonus .
"
"function withdrawFees ( address account , uint value ) external onlyFeeAuthority returns ( bool ) { require ( account != address ( 0 ) ) ; if ( value == 0 ) { return false ; } tokenState . setBalanceOf ( FEE_ADDRESS , safeSub ( tokenState . balanceOf ( FEE_ADDRESS ) , value ) ) ; tokenState . setBalanceOf ( account , safeAdd ( tokenState . balanceOf ( account ) , value ) ) ; emitFeesWithdrawn ( account , value ) ; emitTransfer ( FEE_ADDRESS , account , value ) ; return true ; }
","Withdraw tokens from the fee pool into a given account .
"
"function requestInvestment ( uint giveQuantity , uint shareQuantity , bool isNativeAsset ) external pre_cond ( ! isShutDown ) pre_cond ( isInvestAllowed ) pre_cond ( module . compliance . isInvestmentPermitted ( msg . sender , giveQuantity , shareQuantity ) ) { requests . push ( Request ( { participant : msg . sender , status : RequestStatus . active , requestType : RequestType . invest , requestAsset : isNativeAsset ? address ( NATIVE_ASSET ) : address ( QUOTE_ASSET ) , shareQuantity : shareQuantity , giveQuantity : giveQuantity , receiveQuantity : shareQuantity , timestamp : now , atUpdateId : module . pricefeed . getLastUpdateId ( ) } ) ) ; RequestUpdated ( getLastRequestId ( ) ) ; }
","Give melon tokens to receive shares of this fund
"
"function calculateAccountValuesInternal ( address userAddress ) internal view returns ( Error , uint , uint ) { AccountValueLocalVars memory localResults ; localResults . sumSupplies = Exp ( { mantissa : 0 } ) ; localResults . sumBorrows = Exp ( { mantissa : 0 } ) ; Error err ; localResults . collateralMarketsLength = collateralMarkets . length ; for ( uint i = 0 ; i < localResults . collateralMarketsLength ; i ++ ) { localResults . assetAddress = collateralMarkets [ i ] ; Market storage currentMarket = markets [ localResults . assetAddress ] ; Balance storage supplyBalance = supplyBalances [ userAddress ] [ localResults . assetAddress ] ; Balance storage borrowBalance = borrowBalances [ userAddress ] [ localResults . assetAddress ] ; if ( supplyBalance . principal > 0 ) { ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( currentMarket . supplyIndex , currentMarket . supplyRateMantissa , currentMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . userSupplyCurrent ) = calculateBalance ( supplyBalance . principal , supplyBalance . interestIndex , localResults . newSupplyIndex ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . supplyTotalValue ) = getPriceForAssetAmount ( localResults . assetAddress , localResults . userSupplyCurrent ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . sumSupplies ) = addExp ( localResults . supplyTotalValue , localResults . sumSupplies ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } } if ( borrowBalance . principal > 0 ) { ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( currentMarket . borrowIndex , currentMarket . borrowRateMantissa , currentMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , localResults . newBorrowIndex ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . borrowTotalValue ) = getPriceForAssetAmount ( localResults . assetAddress , localResults . userBorrowCurrent ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } ( err , localResults . sumBorrows ) = addExp ( localResults . borrowTotalValue , localResults . sumBorrows ) ; if ( err != Error . NO_ERROR ) { return ( err , 0 , 0 ) ; } } } return ( Error . NO_ERROR , localResults . sumSupplies . mantissa , localResults . sumBorrows . mantissa ) ; }
","Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .
"
"function updatePrice ( uint newPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT , ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"" ) ; price = newPrice ; lastPriceUpdateTime = timeSent ; emitPriceUpdated ( newPrice , timeSent ) ; rolloverFeePeriodIfElapsed ( ) ; }
","Access point for the oracle to update the price of havvens .
"
"function changeController ( TokenController _newController ) public onlyControllerOrOwner { if ( address ( _newController ) != address ( 0 ) ) { require ( _newController . INTERFACE ( ) == TOKEN_CONTROLLER_INTERFACE ) ; } controller = _newController ; }
","Changes the controller of the contract
"
"function executeRequest ( uint id ) external pre_cond ( ! isShutDown ) pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( _totalSupply == 0 || ( now >= add ( requests [ id ] . timestamp , modules . pricefeed . getInterval ( ) ) && modules . pricefeed . getLastUpdateId ( ) >= add ( requests [ id ] . atUpdateId , 2 ) ) ) { Request request = requests [ id ] ; var ( isRecent , , ) = modules . pricefeed . getPriceInfo ( address ( request . requestAsset ) ) ; require ( isRecent ) ; uint costQuantity = toWholeShareUnit ( mul ( request . shareQuantity , calcSharePriceAndAllocateFees ( ) ) ) ; if ( request . requestAsset != address ( QUOTE_ASSET ) ) { var ( isPriceRecent , invertedRequestAssetPrice , requestAssetDecimal ) = modules . pricefeed . getInvertedPriceInfo ( request . requestAsset ) ; if ( ! isPriceRecent ) { revert ( ) ; } costQuantity = mul ( costQuantity , invertedRequestAssetPrice ) / 10 ** requestAssetDecimal ; } if ( isInvestAllowed [ request . requestAsset ] && costQuantity <= request . giveQuantity ) { request . status = RequestStatus . executed ; require ( AssetInterface ( request . requestAsset ) . transferFrom ( request . participant , address ( this ) , costQuantity ) ) ; createShares ( request . participant , request . shareQuantity ) ; if ( ! isInAssetList [ request . requestAsset ] ) { ownedAssets . push ( request . requestAsset ) ; isInAssetList [ request . requestAsset ] = true ; } } else { revert ( ) ; } }
","Executes active investment and redemption requests , in a way that minimises information advantages of investor
"
"function setHodlerTime ( uint256 _time ) public onlyOwner beforeHodlStart { require ( _time >= now ) ; hodlerTimeStart = _time ; hodlerTime3M = _time . add ( 90 days ) ; hodlerTime6M = _time . add ( 180 days ) ; hodlerTime9M = _time . add ( 270 days ) ; LogHodlStartSet ( msg . sender , _time ) ; }
","Setting hodler start period .
"
"function addRestrictedAttributeType ( uint256 ID , string description ) external ;
","Add a restricted attribute type with ID ` ID ` and description ` description ` to the jurisdiction .
"
"function balanceOf ( address tokenOwner ) public constant returns ( uint256 balance ) { return balances [ tokenOwner ] ; }
","Get the token balance for account ` tokenOwner `
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = colorIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function play ( bool startNewGameIfIdle ) external payable { _processGameEnd ( ) ; if ( ! gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; price = nextPrice ; timeout = nextTimeout ; minimumTimeout = nextMinimumTimeout ; numberOfWagersToMinimumTimeout = nextNumberOfWagersToMinimumTimeout ; gameStarted = true ; gameStarter = msg . sender ; Start ( msg . sender , block . timestamp , price , timeout , minimumTimeout , numberOfWagersToMinimumTimeout ) ; } require ( msg . value >= price ) ; uint256 fee = price . mul ( feePercentage ) . div ( 100000 ) ; uint256 dividend = price . mul ( gameStarterDividendPercentage ) . div ( 100000 ) ; uint256 wagerPoolPart = price . mul ( 2 ) . div ( 7 ) ; uint256 currentTimeout = calculateTimeout ( ) ; lastPlayer = msg . sender ; lastWagerTimeoutTimestamp = block . timestamp + currentTimeout ; prizePool = prizePool . add ( price . sub ( fee ) . sub ( dividend ) . sub ( wagerPoolPart ) ) ; Play ( msg . sender , block . timestamp , lastWagerTimeoutTimestamp , wagerIndex , prizePool ) ; _sendFunds ( gameStarter , dividend ) ; if ( wagerIndex > 0 && ( wagerIndex % 7 ) == 0 ) { msg . sender . transfer ( wagerPool ) ; wagerPool = 0 ; } wagerPool = wagerPool . add ( wagerPoolPart ) ; wagerIndex = wagerIndex . add ( 1 ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Participate in the game .
"
"function fundAnswerBounty ( bytes32 question_id ) external payable { }
","Add funds to the bounty for a question
"
"function setPermissionManager ( address _newManager , address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermissionManager ( _newManager , _app , _role ) ; }
","Set ` _newManager ` as the manager of ` _role ` in ` _app `
"
"function buy ( address _to , uint _value , uint _paymentId ) { transfer ( _to , _value ) ; LogBuy ( msg . sender , _to , _value , _paymentId ) ; }
","Transfer from msg.sender for downloading of content .
"
"function setAllowedTransferFrom ( address from , bool allowed ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) { _allowedTransferFrom [ from ] = allowed ; LogAllowedFromAddress ( from , allowed ) ; }
","enables or disables address to be sender of EUR-T
"
"function sellBkgAtExchg ( uint amountOfCoinsOffer , uint priceOfOneCoinInWEI ) public returns ( bool success ) { uint amntTkns = amountOfCoinsOffer ; uint tknPrice = priceOfOneCoinInWEI ; bool successSlrl ; ( successSlrl ) = _chkSellerLmts ( msg . sender , amntTkns ) ; require ( successSlrl == true ) ; msgSndr [ msg . sender ] = amntTkns ; Exchg em = Exchg ( _getExchgAddr ( ) ) ; bool emsuccess ; ( emsuccess ) = em . sell_Exchg_Reg ( amntTkns , tknPrice , msg . sender ) ; require ( emsuccess == true ) ; msgSndr [ msg . sender ] = 0 ; return true ; }
","allows a seller to formally register his sell offer at ExchangeMacroansy
"
"function redeem ( uint256 baseUnits , address [ ] tokensToSkip ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ >= baseUnits ) ) ; require ( ( balances [ msg . sender ] >= baseUnits ) ) ; require ( tokensToSkip . length <= tokens . length ) ; burn ( msg . sender , baseUnits ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; uint256 index ; bool ok ; ( index , ok ) = tokensToSkip . index ( tokenInfo . addr ) ; if ( ok ) { continue ; } uint256 amount = baseUnits . div ( creationQuantity_ ) . mul ( tokenInfo . tokenUnits ) ; require ( erc20 . transfer ( msg . sender , amount ) ) ; } }
","Redeems Basket Token in return for underlying tokens
"
"function closeSale ( ) public onlyOwner { closed = true ; SaleClosed ( now ) ; }
","Public function enables closing of the crowdsale manually if necessary
"
"function stopSale ( ) onlyBy ( owner ) external { isStopped = true ; }
","Stop sale in case of emergency ( i.e .
"
"function list_bytesarray ( uint256 _count , function ( ) external constant returns ( bytes32 ) _function_first , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _bytes_items ) { if ( _from_start ) { _bytes_items = private_list_bytes_from_bytes ( _function_first ( ) , _count , true , _function_last , _function_next ) ; } else { _bytes_items = private_list_bytes_from_bytes ( _function_last ( ) , _count , true , _function_first , _function_previous ) ; } }
","Lists a Bytes collection from start or end
"
"function onERC721Received ( address , uint256 _tokenId , bytes ) external returns ( bytes4 ) { if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) { flagReceiveLand = 0 ; return bytes4 ( keccak256 ( ""onERC721Received(address,uint256,bytes)"" ) ) ; } }
","Callback used to accept the ERC721 parcel tokens
"
"function unfreezeTransfers ( ) external onlyOwner { require ( transfersFrozen , ""Not frozen"" ) ; transfersFrozen = false ; emit FreezeTransfers ( false , now ) ; }
","Unfreeze transfers
"
"function hasClosed ( ) public view returns ( bool ) { return super . hasClosed ( ) || super . capReached ( ) ; }
","Checks if the crowdsale has closed .
"
"function withdraw ( uint _ether ) external returns ( bool success_ ) ;
","Will withdraw ` _ether ` to your account .
"
"function getOrderHash ( OrderData data ) internal pure returns ( bytes32 orderHash , bytes32 prefixedHash ) { orderHash = keccak256 ( data . makerAddress , data . makerAmount , data . makerToken , data . takerAddress , data . takerAmount , data . takerToken , data . expiration , data . nonce ) ; bytes memory prefix = ""\x19Ethereum Signed Message:\n32"" ; prefixedHash = keccak256 ( prefix , orderHash ) ; }
","Get both hash ( data ) and hash ( prefix , hash ( data ) )
"
"function modifyWhitelistSigned ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO , uint256 _validFrom , uint256 _validTo , uint256 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) public { require ( _validFrom <= now , ""ValidFrom is too early"" ) ; require ( _validTo >= now , ""ValidTo is too late"" ) ; require ( ! nonceMap [ _investor ] [ _nonce ] , ""Already used signature"" ) ; nonceMap [ _investor ] [ _nonce ] = true ; bytes32 hash = keccak256 ( abi . encodePacked ( this , _investor , _fromTime , _toTime , _expiryTime , _canBuyFromSTO , _validFrom , _validTo , _nonce ) ) ; _checkSig ( hash , _v , _r , _s ) ; whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit ModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }
","Adds or removes addresses from the whitelist - can be called by anyone with a valid signature
"
"function totalSupply ( ) external view returns ( uint256 ) { return captains . length - destroyCaptainCount - 1 ; }
","Count NFTs tracked by this contract
"
"function transferFrom ( address _from , address _to , uint256 _tokenId , uint256 _price , uint256 _x , uint256 _y ) public auctionNotOngoing ( _x , _y ) { _subFromValueHeld ( msg . sender , _price , false ) ; _addToValueHeld ( _to , _price ) ; require ( _to == msg . sender ) ; Pixel memory pixel = pixelByCoordinate [ _x ] [ _y ] ; super . transferFrom ( _from , _to , _tokenId ) ; }
","This transfer has to be approved and then triggered by the _to address in order to avoid sending unwanted pixels
"
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }
","Owner can transfer out any accidentally sent ERC20 tokens .
"
"function withdraw ( uint256 amount ) onlyOwner public { uint256 minimumAmount = address ( this ) . balance ; require ( minimumAmount >= amount ) ; msg . sender . transfer ( amount ) ; totalEth = totalEth . sub ( amount ) ; }
","withDraw ` amount ` ETH to contract
"
"function schedulePriceUpdatesFixed ( uint256 [ ] _times ) payable isAdminOrOwner public { bytes32 requestId ; if ( _times . length == 0 ) { require ( oraclize_getPrice ( ""URL"" ) <= address ( this ) . balance , ""Insufficient Funds"" ) ; requestId = oraclize_query ( ""URL"" , oracleURL , gasLimit ) ; requestIds [ requestId ] = now ; if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } emit LogNewOraclizeQuery ( now , requestId , oracleURL ) ; } else { require ( oraclize_getPrice ( ""URL"" ) * _times . length <= address ( this ) . balance , ""Insufficient Funds"" ) ; for ( uint256 i = 0 ; i < _times . length ; i ++ ) { requestId = oraclize_query ( _times [ i ] , ""URL"" , oracleURL , gasLimit ) ; requestIds [ requestId ] = _times [ i ] ; emit LogNewOraclizeQuery ( _times [ i ] , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } } }
","Allows owner to schedule future Oraclize calls
"
"function _unpause ( ) internal { require ( paused ) ; paused = false ; emit Unpause ( now ) ; }
","called by the owner to unpause , returns to normal state
"
"function _transfer ( address _to , uint256 _tokenId ) private { address from = idToOwner [ _tokenId ] ; clearApproval ( from , _tokenId ) ; removeNFToken ( from , _tokenId ) ; addNFToken ( _to , _tokenId ) ; emit Transfer ( from , _to , _tokenId ) ; }
","Does NO checks .
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { latinotokenrecipiente spender = latinotokenrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ( _value == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","Assign allowance _value to _spender address to use the msg.sender balance
"
"function CreateToken ( address owner , uint i ) public { require ( msg . sender == _auctionContract ) ; require ( ! _initialized [ i - 1 ] ) ; _initialized [ i - 1 ] = true ; _mint ( owner , i ) ; }
","Creates a RareCoin token .
"
"function unproposeMilestones ( ) onlyRecipient campaignNotCanceled { delete proposedMilestones ; changingMilestones = false ; NewMilestoneListUnproposed ( ) ; }
","` onlyRecipient ` Cancels the proposed milestones and reactivates the previous set of milestones
"
"function getAllStar ( uint256 _tokenId ) public view returns ( string allStarName , uint allStarGen , uint256 sellingPrice , address owner ) { AllStar storage allStar = allStars [ _tokenId ] ; allStarName = allStar . name ; allStarGen = allStar . gen ; sellingPrice = allStarIndexToPrice [ _tokenId ] ; owner = allStarIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific AllStar .
"
"function transfer ( address _to , uint256 _value ) notPendingWithdrawal { if ( balanceOf [ msg . sender ] < _value ) throw ; if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) throw ; balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; }
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function transfer ( address _to , uint256 _tokenId ) public { require ( ! jackpotCompleted ) ; require ( _owns ( msg . sender , _tokenId ) ) ; require ( _addressNotNull ( _to ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","Owner initates the transfer of the token to another account
"
"function finalize ( ) public initialized { Tier tier = tiers [ tierCount ] ; assert ( tier . finalizedTime ( ) == 0 ) ; assert ( getBlockTimestamp ( ) >= tier . startTime ( ) ) ; assert ( msg . sender == controller || getBlockTimestamp ( ) > tier . endTime ( ) || isCurrentTierCapReached ( ) ) ; tier . finalize ( ) ; tierCount ++ ; FinalizedTier ( tierCount , tier . finalizedTime ( ) ) ; }
","This method will can be called by the controller after the contribution period end or by anybody after the ` endTime ` .
"
"function canSafeTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) { if ( value > 0 ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( ! _isApprovedOrOwner ( msg . sender , tokenId ) ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( to == address ( 0 ) ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( ! _checkOnERC721Received ( from , to , tokenId , """" ) ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( ! _registry . hasAttribute ( to , _validAttributeTypeID ) ) { return ( false , bytes1 ( hex""10"" ) ) ; } return ( true , bytes1 ( hex""01"" ) ) ; }
","Check if a transfer of the NFT with ID ` tokenId ` on behalf of account ` from ` to a recipient at account ` to ` with ` msg.value ` of ` value ` is approved .
"
"function deregisterProducer ( address aproducer ) onlyOwner external { emit producerDeregistered ( aproducer ) ; producers [ aproducer ] = false ; }
","Cease allowing the owner of address ` aproducer.address ( ) ` to act as a producer ( by offering energy ) .
"
"function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( ""pDispensationPct"" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; ( uint commitEndDate , uint revealEndDate , , , ) = voting . pollMap ( pollID ) ; emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate , msg . sender ) ; return pollID ; }
","challenge the provided proposal ID , and put tokens at stake to do so .
"
"function setTokenEscrowMarketplace ( TokenEscrowMarketplace _newTokenEscrowMarketplace ) external onlyDuringInitialization { address oldTokenEscrowMarketplace = tokenEscrowMarketplace ; tokenEscrowMarketplace = _newTokenEscrowMarketplace ; emit TokenEscrowMarketplaceChanged ( oldTokenEscrowMarketplace , tokenEscrowMarketplace ) ; }
","Set the implementation of the TokenEscrowMarketplace contract by setting a new address
"
"function withdraw ( Data storage self , bytes locked_encoded , bytes merkle_proof , bytes32 secret ) notSettledButClosed ( self ) { uint amount ; uint8 index ; uint64 expiration ; bytes32 h ; bytes32 hashlock ; index = 1 - index_or_throw ( self , msg . sender ) ; Participant storage counterparty = self . participants [ index ] ; require ( counterparty . locksroot != 0 ) ; ( expiration , amount , hashlock ) = decodeLock ( locked_encoded ) ; require ( ! counterparty . withdrawn_locks [ hashlock ] ) ; counterparty . withdrawn_locks [ hashlock ] = true ; require ( expiration >= block . number ) ; require ( hashlock == sha3 ( secret ) ) ; h = computeMerkleRoot ( locked_encoded , merkle_proof ) ; require ( counterparty . locksroot == h ) ; counterparty . transferred_amount += amount ; }
","Unlock a locked transfer
"
"function withdraw ( address _token ) public onlyOwner { require ( _token != address ( 0 ) , ""Token address cannot be zero address"" ) ; uint256 balance = ERC20 ( _token ) . balanceOf ( address ( this ) ) ; require ( balance > 0 , ""Cannot withdraw from a balance of zero"" ) ; ERC20 ( _token ) . transfer ( owner , balance ) ; }
","Generic withdraw function in the case of having leftover tokens to withdraw
"
"function approveAndCall ( address _spender , uint256 _value , bytes _data ) public returns ( bool ) { require ( approve ( _spender , _value ) ) ; ERC20RecipientInterface ( _spender ) . receiveApproval ( msg . sender , _value , this , _data ) ; return true ; }
","Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount .
"
"function collectEther ( uint256 amount ) onlyOwner public { owner . transfer ( amount ) ; }
","Collect ether received for token purshases This is possible both during Collection and Distribution phases
"
"function refill ( uint256 _value ) external returns ( bool ) ;
","XRT should be approved before call this
"
"function getFeeParams ( ) public view returns ( uint bps , uint min , uint max , uint flat , bytes feeMsg , address feeContract ) { return ( lib . getFeeBPS ( address ( this ) ) , lib . getFeeMin ( address ( this ) ) , lib . getFeeMax ( address ( this ) ) , lib . getFeeFlat ( address ( this ) ) , lib . getFeeMsg ( address ( this ) ) , address ( this ) ) ; }
","Gets fee parameters
"
"function mintFish ( address [ ] _owner , uint32 [ ] _weight , uint8 [ ] _power , uint8 [ ] _agility , uint8 [ ] _speed , bytes16 [ ] _color ) onlyMinter public { for ( uint i = 0 ; i < _owner . length ; i ++ ) { _mintFish ( _owner [ i ] , _weight [ i ] , _power [ i ] , _agility [ i ] , _speed [ i ] , _color [ i ] ) ; } }
","Mints fishes according to params can only be called by the owner
"
"function burn ( uint256 _amount , bytes _holderData ) public canBurn { super . burn ( _amount , _holderData ) ; }
","Burns ` _amount ` tokens from ` _tokenHolder ` Sample burn function to showcase the use of the ` Burned ` event .
"
"function transfer ( address _to , uint _value ) returns ( bool ) { if ( balanceOf [ msg . sender ] >= _value ) { balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
","` _value ` tokens will be sended to ` _to `
"
"function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( ""configure(uint256)"" ) ) ; }
","This function returns the signature of configure function
"
"function withdrawWithholding ( uint256 _dividendIndex ) external ;
","Allows issuer to withdraw withheld tax
"
"function approveWithdraw ( uint _withdrawalID ) external backerCheck ( _withdrawalID ) { withdrawalsVotes [ msg . sender ] [ _withdrawalID ] = true ; uint backerStake = 0 ; for ( uint i = 0 ; i < backers [ msg . sender ] . length ; i ++ ) { backerStake += backers [ msg . sender ] [ i ] . tokenAmount ; } withdrawals [ _withdrawalID ] . backerApprovals . push ( msg . sender ) ; withdrawals [ _withdrawalID ] . totalStake += backerStake ; WithdrawalVotedEvent ( _withdrawalID , msg . sender , backerStake , withdrawals [ _withdrawalID ] . totalStake ) ; if ( withdrawals [ _withdrawalID ] . totalStake >= ( claimedPrepaidUnits + claimedUnits ) / 3 ) { uint amountPerAddr ; bool isMultiPayment = withdrawals [ _withdrawalID ] . destination . length > 1 ; if ( isMultiPayment == false ) { amountPerAddr = withdrawals [ _withdrawalID ] . Amount ; } else { amountPerAddr = withdrawals [ _withdrawalID ] . Amount / withdrawals [ _withdrawalID ] . destination . length ; } withdrawals [ _withdrawalID ] . approved = true ; withdrawals [ _withdrawalID ] . spent = true ; for ( i = 0 ; i < withdrawals [ _withdrawalID ] . destination . length ; i ++ ) { if ( ! withdrawals [ _withdrawalID ] . destination [ i ] . send ( amountPerAddr ) ) throw ; } WithdrawalApproved ( _withdrawalID , withdrawals [ _withdrawalID ] . totalStake , isMultiPayment , withdrawals [ _withdrawalID ] . Amount , withdrawals [ _withdrawalID ] . reason ) ; } }
","Approving withdrawal ` _withdrawalID `
"
"function __callback ( bytes32 _requestId , string _result ) public { require ( msg . sender == oraclize_cbAddress ( ) , ""Only Oraclize can access this method"" ) ; require ( ! freezeOracle , ""Oracle is frozen"" ) ; require ( ! ignoreRequestIds [ _requestId ] , ""Ignoring requestId"" ) ; require ( requestIds [ _requestId ] >= latestUpdate , ""Result is stale"" ) ; require ( requestIds [ _requestId ] <= now + oraclizeTimeTolerance , ""Result is early"" ) ; uint256 newPOLYUSD = parseInt ( _result , 18 ) ; uint256 bound = POLYUSD . mul ( sanityBounds ) . div ( 10 ** 18 ) ; if ( latestUpdate != 0 ) { require ( newPOLYUSD <= POLYUSD . add ( bound ) , ""Result is too large"" ) ; require ( newPOLYUSD >= POLYUSD . sub ( bound ) , ""Result is too small"" ) ; } latestUpdate = requestIds [ _requestId ] ; delete requestIds [ _requestId ] ; emit LogPriceUpdated ( newPOLYUSD , POLYUSD , latestUpdate ) ; POLYUSD = newPOLYUSD ; }
","Oraclize callback ( triggered by Oraclize )
"
"function getValidators ( ) external view returns ( address [ ] ) ;
","Get the accounts of all available validators on the jurisdiction .
"
"function getName ( ) public view returns ( bytes32 ) { return ""PercentageTransferManager"" ; }
","Get the name of the Module
"
"function updateAllowance ( Data storage self , string currency , address account , uint amount ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.allowance' , currency , getForwardedAccount ( self , account ) , getForwardedAccount ( self , msg . sender ) ) ) ; require ( self . Storage . setUint ( id , self . Storage . getUint ( id ) . sub ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; return true ; }
","Low-level method to update spender allowance for account
"
"function addDelegate ( address _delegate , bytes32 _details ) external withPerm ( CHANGE_PERMISSION ) { require ( _delegate != address ( 0 ) , ""Invalid address"" ) ; require ( _details != bytes32 ( 0 ) , ""0 value not allowed"" ) ; require ( delegateDetails [ _delegate ] == bytes32 ( 0 ) , ""Already present"" ) ; delegateDetails [ _delegate ] = _details ; allDelegates . push ( _delegate ) ; emit AddDelegate ( _delegate , _details , now ) ; }
","Used to add a delegate
"
"function setTokenSaleHardCap ( uint256 newTokenSaleHardCap ) onlyAuthorized public { tokenSaleHardCap = newTokenSaleHardCap ; }
","Allow users to buy tokens for ` newTokenSaleHardCap ` XCR
"
"function getInvitationRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return members [ memberAddress ] . invitationRewards ; }
","Called to obtain the invitation reward balance of any given member
"
"function burnTokens ( ) external onlyCrowdsale whenNotPaused { uint256 remainingICOToken = limitCrowdsale . sub ( tokensDistributedCrowdsale ) ; if ( remainingICOToken > 0 && ! remainingTokenBurnt ) { remainingTokenBurnt = true ; limitCrowdsale = limitCrowdsale . sub ( remainingICOToken ) ; totalSupply = totalSupply . sub ( remainingICOToken ) ; } }
","Burn the amount of tokens remaining after ICO ends
"
"function collectionExists ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bool ) { return _collectionIndex < totalCollections ( ) ; }
","Check if collection # ` ( _collectionIndex ) ` exists
"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 _allowance ) { return allowed [ _owner ] [ _spender ] ; }
","Used to retrieve the allowed balance of someone
"
"function buyToken ( ) internal { uint256 value = msg . value ; address sender = msg . sender ; address bank = 0xC51B05696Db965cE6C8efD69Aa1c6BA5540a92d7 ; require ( ! icoIsClosed ) ; require ( ! frozenAccount [ sender ] ) ; require ( value > 0 ) ; require ( currentTokenPrice > 0 ) ; uint256 amount = value * currentTokenPrice ; uint256 detract = amount / commRate ; uint256 detract2 = value / commRate ; uint256 finalvalue = value - detract2 ; require ( tokenBalanceOf [ this ] >= amount ) ; amountOfInvestments = amountOfInvestments + ( value ) ; updatePrices ( ) ; _transfer ( this , sender , amount - detract ) ; require ( this . balance >= finalvalue ) ; bank . transfer ( finalvalue ) ; if ( ! minimalGoalReached ) { checkMinimalGoal ( ) ; } }
","Processing each buying
"
"function getPrecious ( uint256 _tokenId ) public view returns ( string preciousName , uint256 number , uint256 editionId , uint256 collectionId , address owner ) { Precious storage precious = allPreciouses [ _tokenId ] ; preciousName = precious . name ; number = precious . number ; editionId = precious . editionId ; collectionId = precious . collectionId ; owner = preciousIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific precious .
"
"function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) private whenNotPaused { requireMultiple ( _amount ) ; uint balanceAvailable = getAmountOfUnlockedTokens ( _from ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) , ""You cannot invoke doSend with a the burn address (0x0) as the recipient 'to' address"" ) ; require ( balanceAvailable >= _amount , ""You can only invoke doSend when the 'from' address has an unlocked balance >= the '_amount' sent"" ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( _from , _to , _amount ) ; } }
","Helper function actually performing the sending of tokens .
"
"function fundingGoal ( ) public constant returns ( uint256 amount ) { }
","the goal the campaign must reach in order for it to succeed
"
"function releaseUnlocked ( address _sender , address _recipient , uint256 _transactionId , uint256 _exchangeRate ) public { Lock memory lock = escrows [ msg . sender ] [ _transactionId ] ; require ( lock . expiration == 1 ) ; require ( lock . sender == _sender ) ; require ( lock . paid ) ; if ( lock . fee > 0 && lock . sender != _recipient ) { token . transfer ( _recipient , lock . value ) ; token . transfer ( msg . sender , lock . fee ) ; } else { token . transfer ( _recipient , lock . value . add ( lock . fee ) ) ; } delete escrows [ msg . sender ] [ _transactionId ] ; token . issueExchangeRate ( _sender , _recipient , msg . sender , lock . value , _transactionId , _exchangeRate ) ; Released ( msg . sender , _recipient , _transactionId ) ; }
","Exchange rate has 18 decimal places
"
"function buyBkgAtExchg ( address seller , uint sellersCoinAmountOffer , uint sellersPriceOfOneCoinInWEI , uint myProposedPaymentInWEI ) public returns ( bool success ) { uint amountTkns = sellersCoinAmountOffer ; uint priceOfr = sellersPriceOfOneCoinInWEI ; uint payment = myProposedPaymentInWEI ; msgSndr [ msg . sender ] = amountTkns ; bool sucsLmt = _slrByrLmtChk ( seller , amountTkns , priceOfr , msg . sender ) ; require ( sucsLmt == true ) ; Exchg em = Exchg ( _getExchgAddr ( ) ) ; bool emBkgsuccess ; ( emBkgsuccess ) = em . buy_Exchg_booking ( seller , amountTkns , priceOfr , msg . sender , payment ) ; require ( emBkgsuccess == true ) ; msgSndr [ msg . sender ] = 0 ; return true ; }
","payment booking value and actual payment value should be exact
"
"function reclaimDividend ( uint256 _dividendIndex ) external ;
","Issuer can reclaim remaining unclaimed dividend amounts , for expired dividends
"
"function refundFor ( uint _partnerID ) internal returns ( bool ) ;
","Function to refund for a partner
"
"function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( ( p . securityGuardDelay + _delay > maxSecurityGuardDelay ) || ( p . paid ) || ( p . canceled ) ) throw ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }
","` onlySecurityGuard ` Delays a payment for a set number of seconds
"
"function withdrawMILs ( uint256 _MILs ) public postEnd funded { uint256 daysSinceEnd = ( now - lockUpEnd ) / 1 days ; uint256 maxPct = min ( ( ( daysSinceEnd / 30 + 1 ) * 10 ) , 100 ) ; uint256 allowed = award [ msg . sender ] ; allowed = allowed * maxPct / 100 ; allowed -= withdrawn [ msg . sender ] ; require ( _MILs <= allowed ) ; militaryToken . transfer ( msg . sender , _MILs ) ; withdrawn [ msg . sender ] += _MILs ; currentAwards -= _MILs ; }
","Transfers awarded MILs to the caller 's account .
"
"function getCrowdsaleStatus ( ) constant public returns ( Status ) { return currentStatus ; }
","Get current crowdsale status .
"
"function transfer ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { _transfer ( _to , msg . sender , _amount ) ; return true ; }
","Initiates a `` send '' operation towards another user .
"
"function setReputationIRNNodeShare ( uint256 _reputationIRNNodeShare ) public onlyOwner returns ( bool ) { require ( _reputationIRNNodeShare > 0 , ""new share must be larger than zero"" ) ; require ( _reputationIRNNodeShare < 100 , ""new share must be less than to 100"" ) ; require ( reputationIRNNodeShare != _reputationIRNNodeShare , ""new share must be different"" ) ; reputationIRNNodeShare = _reputationIRNNodeShare ; emit ReputationIRNNodeShareUpdated ( msg . sender , _reputationIRNNodeShare ) ; return true ; }
","sets the global reputation reward share allotted to the authors and manufacturers
"
"function setAttributeTypeJurisdictionFee ( uint256 ID , uint256 fee ) external ;
","Set a required fee for a given attribute type ID ` ID ` and an amount of ` fee ` , to be paid to the owner of the jurisdiction upon assignment of attributes of the given type .
"
"function updateProject ( uint64 idProject , address newAddr , string newName , string newUrl , uint64 newCommitTime ) { PledgeAdmin storage project = findAdmin ( idProject ) ; require ( project . adminType == PledgeAdminType . Project ) ; require ( project . addr == msg . sender ) ; project . addr = newAddr ; project . name = newName ; project . url = newUrl ; project . commitTime = newCommitTime ; ProjectUpdated ( idProject ) ; }
","Updates a Project 's info to change the address , name , url , or commitTime , it can not be used to change a plugin or a parentProject , and it must be called by the current address of the Project
"
"function withdraw ( uint256 summeInWei ) isOwner { uint256 contractbalance = this . balance ; address sender = msg . sender ; require ( contractbalance >= summeInWei ) ; require ( minimalGoalReached ) ; withdrawed ( sender , summeInWei , ""wei withdrawed"" ) ; sender . transfer ( summeInWei ) ; }
","Withdraw an amount of ether
"
"function deposit ( bytes32 _userKey , uint _value , uint _feeAmount , address _feeAddress , uint _lockupDate ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; ERC20 _token = ERC20 ( token ) ; if ( _token . allowance ( msg . sender , address ( this ) ) < _value ) { return TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE ; } uint _depositedAmount = _value - _feeAmount ; _makeDepositForPeriod ( _userKey , _depositedAmount , _lockupDate ) ; uint _periodsCount = periodsCount ; user2lastPeriodParticipated [ _userKey ] = _periodsCount ; delete periods [ _periodsCount ] . startDate ; if ( ! _token . transferFrom ( msg . sender , address ( this ) , _value ) ) { revert ( ) ; } if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || _token . transfer ( _feeAddress , _feeAmount ) ) ) { revert ( ) ; } TreasuryDeposited ( _userKey , _depositedAmount , _lockupDate ) ; return OK ; }
","Deposits tokens on behalf of users Allowed only for oracle .
"
"function contribute ( ) public notFinished payable { require ( msg . value >= 100 finney ) ; uint256 tokenBought ; totalRaised = totalRaised . add ( msg . value ) ; if ( state == State . EarlyPreSale ) { tokenBought = msg . value . mul ( price [ 0 ] ) ; tokenBought = tokenBought . mul ( 12 ) ; tokenBought = tokenBought . div ( 10 ) ; require ( stageDistributed . add ( tokenBought ) <= 60000000 * ( 10 ** 18 ) ) ; } else if ( state == State . PreSale ) { tokenBought = msg . value . mul ( price [ 0 ] ) ; tokenBought = tokenBought . mul ( 11 ) ; tokenBought = tokenBought . div ( 10 ) ; require ( stageDistributed . add ( tokenBought ) <= 60000000 * ( 10 ** 18 ) ) ; } else if ( state == State . Crowdsale ) { tokenBought = msg . value . mul ( price [ 1 ] ) ; require ( stageDistributed . add ( tokenBought ) <= 80000000 * ( 10 ** 18 ) ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; stageDistributed = stageDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; LogContributorsPayout ( msg . sender , tokenBought ) ; checkIfFundingCompleteOrExpired ( ) ; }
","contribution handler
"
"function confirmPayment ( uint _idPayment ) public onlyOwner { doConfirmPayment ( _idPayment ) ; }
","Allows the owner to confirm payments ; since ` authorizePayment ` is the only way to populate the ` payments [ ] ` array this is generally used when ` autopay ` is ` false ` after a payment has has been authorized
"
"function requireTrade ( address from ) public view { require ( ! readOnly , ""Read only mode engaged"" ) ; uint256 i = 0 ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { if ( current == from ) { uint256 timestamp = freezeUntil [ current ] ; require ( timestamp < block . timestamp , ""Trades from your account are temporarily not possible. This is due to ICO rules."" ) ; break ; } current = addressLinkedList [ current ] ; i ++ ; } }
","Ensure that account is allowed to trade
"
"function getPlayerStatus ( uint256 _gameID , uint256 _pID ) public view isActivated ( _gameID ) returns ( bytes32 , uint256 [ ] memory , uint256 [ ] memory , uint256 [ ] memory , uint256 [ ] memory ) { uint256 _nt = game_ [ _gameID ] . numberOfTeams ; uint256 [ ] memory _eth = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _keys = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _instWin = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _potWin = new uint256 [ ] ( _nt ) ; uint256 i ; for ( i = 0 ; i < _nt ; i ++ ) { _eth [ i ] = playerTeams_ [ _pID ] [ _gameID ] [ i ] . eth ; _keys [ i ] = playerTeams_ [ _pID ] [ _gameID ] [ i ] . keys ; _instWin [ i ] = getPlayerInstWinning ( _gameID , _pID , i ) ; _potWin [ i ] = getPlayerPotWinning ( _gameID , _pID , i ) ; } return ( BMBook . getPlayerName ( _pID ) , _eth , _keys , _instWin , _potWin ) ; }
","Get player status of a game .
"
"function transferToContract ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; WeBetCrypto rec = WeBetCrypto ( _to ) ; rec . tokenFallback ( msg . sender , _value , _data ) ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
","Handles transfer to a contract ~ ERC-223 Proposed Standard
"
"function claimMultipleAndWithdrawBalance ( bytes32 [ ] question_ids , uint256 [ ] lengths , bytes32 [ ] hist_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) stateAny ( ) public { uint256 qi ; uint256 i ; for ( qi = 0 ; qi < question_ids . length ; qi ++ ) { bytes32 qid = question_ids [ qi ] ; uint256 ln = lengths [ qi ] ; bytes32 [ ] memory hh = new bytes32 [ ] ( ln ) ; address [ ] memory ad = new address [ ] ( ln ) ; uint256 [ ] memory bo = new uint256 [ ] ( ln ) ; bytes32 [ ] memory an = new bytes32 [ ] ( ln ) ; uint256 j ; for ( j = 0 ; j < ln ; j ++ ) { hh [ j ] = hist_hashes [ i ] ; ad [ j ] = addrs [ i ] ; bo [ j ] = bonds [ i ] ; an [ j ] = answers [ i ] ; i ++ ; } claimWinnings ( qid , hh , ad , bo , an ) ; } withdraw ( ) ; }
","Convenience function to assign bounties/bonds for multiple questions in one go , then withdraw all your funds .
"
"function tokensOf ( address _owner ) public view returns ( uint256 [ ] ) { return ownedTokens [ _owner ] ; }
","Gets the list of tokens owned by a given address
"
"function getUserBalance ( bytes32 _userKey ) public view returns ( uint ) { uint _lastPeriodForUser = user2lastPeriodParticipated [ _userKey ] ; if ( _lastPeriodForUser == 0 ) { return 0 ; } if ( _lastPeriodForUser <= periodsCount . sub ( 1 ) ) { return periods [ _lastPeriodForUser ] . user2balance [ _userKey ] ; } return periods [ periodsCount ] . user2balance [ _userKey ] ; }
","Gets user balance that is deposited
"
"function deposit ( ERC20 _token , uint256 _value ) external payable { address trader = msg . sender ; if ( address ( _token ) == ETHEREUM ) { require ( msg . value == _value , ""mismatched value parameter and tx value"" ) ; } else { require ( msg . value == 0 , ""unexpected ether transfer"" ) ; CompatibleERC20 ( _token ) . safeTransferFromWithFees ( trader , this , _value ) ; } privateIncrementBalance ( trader , _token , _value ) ; }
","Deposits ETH or an ERC20 token into the contract .
"
"function cancelGame ( uint256 _gameID , string _comment , uint256 _deadline ) external isActivated ( _gameID ) isOngoing ( _gameID ) isOwner ( ) { require ( _deadline >= now + 86400 , ""deadline must be more than one day later."" ) ; game_ [ _gameID ] . ended = true ; game_ [ _gameID ] . canceled = true ; game_ [ _gameID ] . gameEndComment = _comment ; game_ [ _gameID ] . withdrawDeadline = _deadline ; emit FSEvents . onGameCancelled ( _gameID , _comment , now ) ; }
","Cancel a game .
"
"function approve ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender ) ; loan . approvedTransfer = to ; Approval ( msg . sender , to , index ) ; return true ; }
","Approves the transfer of a given loan in the name of the lender , the behavior of this function is similar to `` approve '' in the ERC20 standard , but only one approved address is allowed at a time .
"
"function verifiedTransferFrom ( address _from , address _to , uint256 _value , uint256 _referenceId , uint256 _exchangeRate , uint256 _fee ) public verifiedResticted { require ( _exchangeRate > 0 ) ; transferFrom ( _from , _to , _value ) ; transferFrom ( _from , msg . sender , _fee ) ; VerifiedTransfer ( _from , _to , msg . sender , _value , _referenceId , _exchangeRate ) ; }
","Value + fee < = allowance
"
"function addressAndBalance ( ) constant returns ( address participant1 , uint balance1 , address participant2 , uint balance2 ) { NettingChannelLibrary . Participant storage node1 = data . participants [ 0 ] ; NettingChannelLibrary . Participant storage node2 = data . participants [ 1 ] ; participant1 = node1 . node_address ; balance1 = node1 . balance ; participant2 = node2 . node_address ; balance2 = node2 . balance ; }
","Get the address and balance of both partners in a channel .
"
"function getValidatorInformation ( address validator ) external view returns ( string description ) { return _validators [ validator ] . description ; }
","Get a description of the validator at account ` validator ` .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( ( _to == address ( this ) ) || ( _to == 0 ) ) { var _allowance = allowed [ _from ] [ msg . sender ] ; require ( _value <= _allowance ) ; allowed [ _from ] [ msg . sender ] = _allowance . sub ( _value ) ; return sell ( _from , _value ) ; } else { return super . transferFrom ( _from , _to , _value ) ; } }
","Transfer tokens from one address to another or sell them if _to is this contract or zero address
"
"function multisend ( address [ ] addrs , uint256 _value ) public returns ( bool res ) { uint length = addrs . length ; require ( _value * length <= balanceOf [ msg . sender ] ) ; uint i = 0 ; while ( i < length ) { transfer ( addrs [ i ] , _value ) ; i ++ ; } return true ; }
","multisend token to many address
"
"function onApprove ( address _owner , address _spender , uint _amount_old , uint _amount_new ) public returns ( bool ) ;
","Notifies the controller about an approval allowing the controller to react if desired
"
"function addNewReservContract ( address newRcAddr ) public onlyOwner { require ( isContract ( newRcAddr ) == true ) ; require ( newRcAddr != 0x0 && newRcAddr != address ( this ) && newRcAddr != address ( token ) ) ; require ( reservationContracts [ newRcAddr ] == false ) ; reservationContracts [ newRcAddr ] = true ; }
","Call this before the startTime to avoid delays
"
"function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E96 ) , _newCOO , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by setCOO
"
"function burn ( uint256 _value ) public onlyIfLockTimePassed { require ( _value > 0 ) ; require ( balances [ msg . sender ] >= _value ) ; require ( totalSupply >= _value ) ; uint pre_balance = balances [ msg . sender ] ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Burn ( burner , _value ) ; Transfer ( burner , 0x0 , _value ) ; assert ( balances [ burner ] == pre_balance . sub ( _value ) ) ; }
","Allows ` msg.sender ` to simply destroy ` _value ` token units ( sphi ) .
"
"function staticExchangeChecks ( OrderData order ) public view onlySelf returns ( bool checksPassed ) { bool correctMaker = order . addresses [ 0 ] == ecrecover ( keccak256 ( abi . encodePacked ( ""\x19Ethereum Signed Message:\n32"" , createHash ( order ) ) ) , order . v , order . r , order . s ) ; bool hasAvailableVolume = exchange . filledAmounts ( createHash ( order ) ) < order . values [ 1 ] ; bool oneOfTokensIsEth = order . addresses [ 1 ] == address ( 0x0 ) || order . addresses [ 2 ] == address ( 0x0 ) ; return correctMaker && hasAvailableVolume && oneOfTokensIsEth ; }
","Perform exchange-specific checks on the given order
"
"function getTotalDonations ( ) public view returns ( uint256 ) { return convertToEther ( finalized ? totalSencCollected : getSencBalance ( ) ) ; }
","The ` getTotalDonations ( ) ` retrieve the Ether balance collected so far in Wei .
"
"function tokenFallback ( address _from , uint _value , bytes ) external { require ( msg . sender == address ( abioToken ) ) ; require ( _from == abioToken . owner ( ) || _from == owner ) ; volume = _value ; paused = false ; deadline = now + length ; emit ICOStart ( _value , weiPerABIO , minInvestment ) ; }
","We implement tokenFallback in case someone decides to send us tokens or we want to increase ICO Volume .
"
"function distributeReward ( uint intelIndex ) public returns ( bool success ) { require ( intelIndex > 0 ) ; IntelState storage intel = intelDB [ intelIndex ] ; require ( ! intel . rewarded ) ; require ( now >= intel . rewardAfter ) ; intel . rewarded = true ; uint distributed_amount = 0 ; if ( intel . balance > intel . desiredReward ) { distributed_amount = intel . desiredReward ; } else { distributed_amount = intel . balance ; } uint fee = distributed_amount . div ( 10 ) ; distributed_amount = distributed_amount . sub ( fee ) ; token . transfer ( intel . intelProvider , distributed_amount ) ; token . transfer ( msg . sender , fee ) ; emit RewardDistributed ( intelIndex , distributed_amount , intel . intelProvider , msg . sender , fee ) ; return true ; }
","this function distributes rewards to the Intel provider
"
"function totalSupply ( ) public view returns ( uint ) { return dungeons . length ; }
","Returns the total number of tokens currently in existence .
"
"function removeBudget ( address _token ) external authP ( CHANGE_BUDGETS_ROLE , arr ( _token , uint256 ( 0 ) , settings . budgets [ _token ] , settings . hasBudget [ _token ] ? 1 : 0 ) ) transitionsPeriod { settings . budgets [ _token ] = 0 ; settings . hasBudget [ _token ] = false ; emit SetBudget ( _token , 0 , false ) ; }
","Remove spending limit for ` _token.symbol ( ) : string ` , effective immediately
"
"function removeAttributeType ( uint256 ID ) external onlyOwner whenNotPaused { require ( isAttributeType ( ID ) , ""unable to remove, no attribute type with the provided ID"" ) ; uint256 lastAttributeID = _attributeIDs [ _attributeIDs . length . sub ( 1 ) ] ; _attributeIDs [ _attributeTypes [ ID ] . index ] = lastAttributeID ; _attributeTypes [ lastAttributeID ] . index = _attributeTypes [ ID ] . index ; _attributeIDs . length -- ; delete _attributeTypes [ ID ] ; emit AttributeTypeRemoved ( ID ) ; }
","Remove the attribute type with ID ` ID ` from the jurisdiction .
"
"function closeSetup ( ) returns ( bool ) { if ( smartContractStartDate != 0 || ( msg . sender != creator && msg . sender != Client ( ) ) ) return ; smartContractStartDate = now ; return true ; }
","Function to close the setting procedure and start to use this smart contract
"
"function saleAirdrop ( address beneficiary , uint256 amount ) onlyOwner external { mintTokens ( beneficiary , amount ) ; }
","Mint tokens for Airdrops ( only external ) by Alber Erre
"
"function submitChallengeOrder ( bytes details , uint64 settlementID , uint64 tokens , uint256 price , uint256 volume , uint256 minimumVolume ) external onlyDarknode { SettlementUtils . OrderDetails memory order = SettlementUtils . OrderDetails ( { settlementID : settlementID , tokens : tokens , price : price , volume : volume , minimumVolume : minimumVolume } ) ; bytes32 orderID = SettlementUtils . hashOrder ( details , order ) ; require ( ! orderSubmitted [ orderID ] , ""already submitted"" ) ; orderDetails [ orderID ] = order ; challengers [ orderID ] = msg . sender ; orderSubmitted [ orderID ] = true ; }
","Submits the details for one of the two orders of a challenge .
"
"function issueAssetToAddress ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable , address _account ) public onlyOneOfContractOwners returns ( uint ) { if ( _value == 0 && ! _isReissuable ) { return _error ( ATX_PLATFORM_CANNOT_ISSUE_FIXED_ASSET_WITH_INVALID_VALUE ) ; } if ( isCreated ( _symbol ) ) { return _error ( ATX_PLATFORM_ASSET_ALREADY_ISSUED ) ; } uint holderId = _createHolderId ( _account ) ; uint creatorId = _account == msg . sender ? holderId : _createHolderId ( msg . sender ) ; symbols . push ( _symbol ) ; assets [ _symbol ] = Asset ( creatorId , _value , _name , _description , _isReissuable , _baseUnit ) ; assets [ _symbol ] . wallets [ holderId ] . balance = _value ; Emitter ( eventsHistory ) . emitIssue ( _symbol , _value , _address ( holderId ) ) ; return OK ; }
","Issues new asset token on the platform .
"
"function getPlayerByBoard ( bytes32 boardHash , uint8 playerID ) constant public returns ( bytes32 , uint , uint ) { Player storage p = boards [ boardHash ] . players [ playerID ] ; require ( p . isActive == 1 ) ; return ( p . playerName , p . score , p . score_unconfirmed ) ; }
","Get player data by leaderboard hash and player id/index
"
"function requestArbitration ( bytes32 question_id , uint256 max_previous ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitycheck . notifyOfArbitrationRequest ( question_id , msg . sender , max_previous ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! realitycheck . isFinalized ( question_id ) ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }
","Request arbitration , freezing the question until we send submitAnswerByArbitrator
"
"function setAttributeTypeMinimumRequiredStake ( uint256 ID , uint256 minimumRequiredStake ) external { require ( isAttributeType ( ID ) , ""unable to set minimum stake, no attribute type with the provided ID"" ) ; _attributeTypes [ ID ] . minimumStake = minimumRequiredStake ; }
","Set a minimum required stake for a given attribute type ID ` ID ` and an amount of ` stake ` , to be locked in the jurisdiction upon assignment of attributes of the given type .
"
"function isDuringSalePeriod ( uint256 _blockNumber ) view internal returns ( bool ) { return ( _blockNumber >= startBlock && _blockNumber < endBlock ) ; }
","check if the block number is during the sale period
"
"function unbanUser ( address _user ) external isAdmin { bannedUser [ _user ] = false ; }
","Unban a user
"
"function changeOwner ( address _owner ) public onlyOwner returns ( bool ) { ChangedOwner ( owner , _owner ) ; owner = _owner ; return true ; }
","Change the owner to ` _owner `
"
"function exchange ( bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey , address destinationAddress ) external optionalProxy returns ( bool ) { require ( sourceCurrencyKey != destinationCurrencyKey , ""Exchange must use different synths"" ) ; require ( sourceAmount > 0 , ""Zero amount"" ) ; return _internalExchange ( messageSender , sourceCurrencyKey , sourceAmount , destinationCurrencyKey , destinationAddress == address ( 0 ) ? messageSender : destinationAddress , true ) ; }
","Function that allows you to exchange synths you hold in one flavour for another .
"
"function getEscrowDeposit ( string _id ) external view returns ( address bidder , bytes data , uint256 amount ) { require ( escrows [ _id ] . exists ) ; EscrowDeposit storage escrowDeposit = escrows [ _id ] ; bidder = escrowDeposit . bidder ; data = escrowDeposit . data ; amount = escrowDeposit . amount ; }
","Gets the EscrowDeposit based on the input id .
"
"function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < ( captains . length - destroyCaptainCount ) ) ; return _index ; }
","Enumerate valid NFTs
"
"function emergencySplitToggle ( ) isAdmin external { uint temp = 0 ; temp -= 1 ; if ( relativeDateSave == temp ) { relativeDateSave = now ; } else { relativeDateSave = temp ; } }
","Disable the splitting function
"
"function setStartDate ( Campaign storage _campaign , uint _startDate ) internal { _campaign . startDate = _startDate ; }
","Set campaign start date
"
"function buyTokensForSelf ( ) external payable { totalFunds = totalFunds + msg . value ; address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de ; require ( msg . value > 0 ) ; require ( msg . sender != etherTransfer ) ; require ( ( totalFunds / 1 ether ) * pricePerEther < 6000000000 ) ; addUser ( msg . sender ) ; uint tokenAmount = calculateTokenAmount ( msg . value ) ; balances [ selfAddress ] = balances [ selfAddress ] - tokenAmount ; assert ( balances [ selfAddress ] >= 50000000000000 ) ; balances [ msg . sender ] = balances [ msg . sender ] + tokenAmount ; Transfer ( selfAddress , msg . sender , tokenAmount ) ; etherTransfer . transfer ( msg . value ) ; }
","Purchase WBC Tokens for Self - ICO
"
"function redeem ( uint _amount , address _backerAddr ) returns ( bool ) { if ( backersRedeemed [ _backerAddr ] == true ) { return false ; } uint totalTokens = 0 ; for ( uint i = 0 ; i < backers [ _backerAddr ] . length ; i ++ ) { if ( backers [ _backerAddr ] [ i ] . claimed == false ) { return false ; } totalTokens += backers [ _backerAddr ] [ i ] . tokenAmount ; } if ( totalTokens == _amount ) { backersRedeemed [ _backerAddr ] = true ; RedeemEvent ( _backerAddr , totalTokens ) ; return true ; } else { return false ; } }
","Backer ` _bacherAddr.address ( ) ` is redeeming ` _amount ` superDAO Tokens
"
"function darknodePublicKey ( address darknodeID ) external view onlyOwner returns ( bytes ) { return darknodeRegistry [ darknodeID ] . publicKey ; }
","Returns the encryption public key of a given darknode .
"
"function ( ) public payable { require ( crowdsaleOpen ( ) ) ; require ( msg . value > 0 ) ; collectedEther = collectedEther . add ( msg . value ) ; contributions [ msg . sender ] = contributions [ msg . sender ] . add ( msg . value ) ; uint256 amount = getTokensForValue ( msg . value ) ; tokensSold = tokensSold . add ( amount ) ; mintTokens ( msg . sender , amount ) ; }
","Sell tokens directly , without referral bonuses
"
"function updateXDRRate ( uint timeSent ) internal { uint total = 0 ; for ( uint i = 0 ; i < xdrParticipants . length ; i ++ ) { total = rates [ xdrParticipants [ i ] ] . add ( total ) ; } rates [ ""XDR"" ] = total ; lastRateUpdateTimes [ ""XDR"" ] = timeSent ; bytes4 [ ] memory eventCurrencyCode = new bytes4 [ ] ( 1 ) ; eventCurrencyCode [ 0 ] = ""XDR"" ; uint [ ] memory eventRate = new uint [ ] ( 1 ) ; eventRate [ 0 ] = rates [ ""XDR"" ] ; emit RatesUpdated ( eventCurrencyCode , eventRate ) ; }
","Update the Synthetix Drawing Rights exchange rate based on other rates already updated .
"
"function getFeeMsg ( Data storage self , address contractAddress ) internal view returns ( bytes feeMsg ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.msg' , contractAddress ) ) ; return self . Storage . getBytes ( id ) ; }
","Get the flat message of the contract address ; typically TokenIOFeeContract
"
"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; if ( ( _amount != 0 ) && ( allowed [ msg . sender ] [ _spender ] != 0 ) ) throw ; if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) throw ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function approve ( address _to , uint _tokenId ) public isNotContract { require ( _owns ( msg . sender , _tokenId ) ) ; divCardIndexToApproved [ _tokenId ] = _to ; emit Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function viewTokenMeta ( uint256 _tokenId ) external view returns ( string tokenTitle_ , string tokenDescription_ ) { tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescriptions [ _tokenId ] ; }
","Returns all the relevant information about a specific token
"
"function enableInterface ( string _interface , address _impl ) public onlyOwner { setInterfaceImplementation ( _interface , _impl ) ; }
","Enables an interface .
"
"function getTickerDetails ( string _ticker ) external view returns ( address , uint256 , uint256 , string , bool ) { string memory ticker = Util . upper ( _ticker ) ; bool tickerStatus = _tickerStatus ( ticker ) ; uint256 expiryDate = getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , ticker ) ) ; if ( ( tickerStatus == true ) || ( expiryDate > now ) ) { return ( _tickerOwner ( ticker ) , getUint ( Encoder . getKey ( ""registeredTickers_registrationDate"" , ticker ) ) , expiryDate , getString ( Encoder . getKey ( ""registeredTickers_tokenName"" , ticker ) ) , tickerStatus ) ; } else return ( address ( 0 ) , uint256 ( 0 ) , uint256 ( 0 ) , """" , false ) ; }
","Returns the owner and timestamp for a given ticker
"
"function createAndBookCanvas ( address _bookFor ) external onlyOwner returns ( uint canvasId ) { return _createCanvasInternal ( _bookFor ) ; }
","Similar to createCanvas ( ) .
"
"function setPrices ( uint256 _tokenPrice ) onlyOwner public { tokenPrice = _tokenPrice ; }
","Allow users to buy tokens for eth
"
"function tokenByIndex ( uint256 _tokenIndex ) public view returns ( uint256 ) { require ( _tokenIndex < totalSupply ( ) , ""PixelCon index is out of bounds"" ) ; return pixelcons [ _tokenIndex ] . tokenId ; }
","Get the ID of PixelCon # ` ( _tokenIndex ) `
"
"function getSell ( ) returns ( uint256 ) { return sellPrice ; }
","Get current sell price without ether
"
"function updateRate ( uint256 _rate ) public onlyOwner { rate = _rate ; }
","Funtion to update exchange rate
"
"function approve ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
","Required for ERC-20 and ERC-721 compliance .
"
"function changeAllowAllBurnTransfers ( bool _allowAllBurnTransfers ) public withPerm ( FLAGS ) { allowAllBurnTransfers = _allowAllBurnTransfers ; emit LogAllowAllBurnTransfers ( _allowAllBurnTransfers ) ; }
","Used to change the flag true - It allow to burn the tokens false - It deactivate the burning mechanism .
"
"function resolveChallenge ( uint challengeId , bool decision ) external gameIsNotOver { Challenge storage challenge = challenges [ challengeId ] ; require ( challenge . resolved == false , ""Challenge already resolved."" ) ; if ( block . timestamp < ( challenge . startDate + challenge . time + daysToResolve ) ) require ( challenge . mentor == msg . sender , ""You are not the mentor for this challenge."" ) ; else require ( ( challenge . user == msg . sender ) || ( challenge . mentor == msg . sender ) , ""You are not the user or mentor for this challenge."" ) ; uint mentorFee ; uint serviceFee ; address user = challengeToUser [ challengeId ] ; address mentor = challengeToMentor [ challengeId ] ; challenge . successed = decision ; challenge . resolved = true ; uint remainingValue = challenge . value ; if ( challenge . mentorFee > 0 ) { serviceFee = challenge . mentorFee . div ( 100 ) . mul ( serviceFeePercentage ) ; mentorFee = challenge . mentorFee . div ( 100 ) . mul ( 100 - serviceFeePercentage ) ; } if ( challenge . mentorFee > 0 ) remainingValue = challenge . value . sub ( challenge . mentorFee ) ; uint valueToPay ; if ( decision ) { valueToPay = remainingValue ; uint currentBonus = bonusFund [ user ] ; if ( currentBonus > 0 ) { uint bonusValue = bonusFund [ user ] . div ( 100 ) . mul ( bonusPercentage ) ; if ( currentBonus <= minBonus ) bonusValue = currentBonus ; bonusFund [ user ] -= bonusValue ; emit BonusFundChanged ( user , bonusFund [ user ] ) ; valueToPay += bonusValue ; } } else { bonusFund [ user ] += remainingValue ; emit BonusFundChanged ( user , bonusFund [ user ] ) ; } if ( valueToPay > 0 ) user . transfer ( valueToPay ) ; if ( mentorFee > 0 ) mentor . transfer ( mentorFee ) ; if ( serviceFee > 0 ) owner ( ) . transfer ( serviceFee ) ; emit ChallengeResolved ( challengeId , user , mentor , decision ) ; }
","Resolves Challenge
"
"function changeOperational ( bytes32 _externalHolderId , bool _operational ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; holders [ _holderIndex ] . operational = _operational ; _emitHolderOperationalChanged ( _externalHolderId , _operational ) ; return OK ; }
","Change operational status for holder .
"
"function setMaxRate ( uint ethMax , uint btcMax ) public onlyOwnerAndDirector { ethRateMax = ethMax ; btcRateMax = btcMax ; }
","setMaxRate sets max rate for both BTC/ETH to soften negative consequences in case our backend gots hacked .
"
"function buy ( address seller , uint256 quantity , uint256 price ) public payable { TradeOrder memory order = orderBook [ seller ] ; require ( order . price == price , ""Buy price does not match the listed sell price."" ) ; require ( block . timestamp < order . expiry , ""Sell order has expired."" ) ; uint256 tradeQuantity = order . quantity > quantity ? quantity : order . quantity ; uint256 cost = multiplyAtPrecision ( tradeQuantity , order . price , 9 ) ; require ( msg . value >= cost , ""You did not send enough Ether to purchase the tokens."" ) ; uint256 tokenFee ; uint256 etherFee ; ( tokenFee , etherFee ) = calculateFee ( tradeQuantity , cost ) ; if ( ! ERC20Interface ( tokenContract ) . transferFrom ( seller , msg . sender , tradeQuantity . sub ( tokenFee ) ) ) { revert ( ""Unable to transfer tokens from seller to buyer."" ) ; } if ( tokenFee > 0 && ! ERC20Interface ( tokenContract ) . transferFrom ( seller , owner , tokenFee ) ) { revert ( ""Unable to transfer tokens from seller to buyer."" ) ; } order . quantity = order . quantity . sub ( tradeQuantity ) ; orderBook [ seller ] = order ; seller . transfer ( cost . sub ( etherFee ) ) ; if ( etherFee > 0 ) owner . transfer ( etherFee ) ; lastSellPrice = price ; emit TokensPurchased ( msg . sender , seller , tradeQuantity , price ) ; }
","Buy tokens from an existing sell order .
"
"function getInvestors ( ) external view returns ( address [ ] ) ;
","Gets length of investors array NB - this length may differ from investorCount if the list has not been pruned of zero-balance investors
"
"function nominateNewOwner ( address _owner ) external onlyOwner { nominatedOwner = _owner ; emit OwnerNominated ( _owner ) ; }
","Nominate a new owner of this contract .
"
"function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { require ( b <= a , ""Error: Unsafe subtraction operation!"" ) ; return a - b ; }
","Subtracts two numbers , throws on underflow .
"
"function releaseForeignToken ( ERC20 _token , uint256 amount ) onlyOwner { require ( _token != token ) ; _token . transfer ( owner , amount ) ; }
","Allow withdrawing any token other than the relevant one
"
"function MultiplesaleAirdrop ( address [ ] beneficiaries , uint256 [ ] amounts ) onlyOwner external { for ( uint256 r = 0 ; r < beneficiaries . length ; r ++ ) { mintTokens ( address ( beneficiaries [ r ] ) , uint256 ( amounts [ r ] ) ) ; } }
","Mint tokens for multiple addresses for Airdrops ( only external ) - Alber Erre
"
"function newPinnedAppInstance ( bytes32 _appId , address _appBase , bytes _initializePayload , bool _setDefault ) public auth ( APP_MANAGER_ROLE , arr ( KERNEL_APP_BASES_NAMESPACE , _appId ) ) returns ( ERCProxy appProxy ) { _setAppIfNew ( KERNEL_APP_BASES_NAMESPACE , _appId , _appBase ) ; appProxy = newAppProxyPinned ( this , _appId , _initializePayload ) ; if ( _setDefault ) { setApp ( KERNEL_APP_ADDR_NAMESPACE , _appId , appProxy ) ; } }
","Create a new non-upgradeable instance of ` _appId ` app linked to the Kernel , setting its code to ` _appBase ` .
"
"function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard { if ( _idPayment >= authorizedPayments . length ) throw ; if ( _delay > 10 ** 18 ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( ( p . securityGuardDelay + _delay > maxSecurityGuardDelay ) || ( p . paid ) || ( p . canceled ) ) throw ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }
","` onlySecurityGuard ` Delays a payment for a set number of seconds
"
"function registerExchange ( address ofExchange , address ofExchangeAdapter , bool inputTakesCustody , bytes4 [ ] inputFunctionSignatures ) auth pre_cond ( ! exchangeInformation [ ofExchange ] . exists ) { exchangeInformation [ ofExchange ] . exists = true ; registeredExchanges . push ( ofExchange ) ; updateExchange ( ofExchange , ofExchangeAdapter , inputTakesCustody , inputFunctionSignatures ) ; assert ( exchangeInformation [ ofExchange ] . exists ) ; }
","Register an exchange information entry
"
"function upgrade ( ) external isHuman ( ) { address _agent = msg . sender ; require ( player [ _agent ] . isAgent ) ; require ( player [ _agent ] . level < maxLevel ) ; if ( player [ _agent ] . accumulatedAff >= requirement [ player [ _agent ] . level ] ) { player [ _agent ] . level = ( 1 ) . add ( player [ _agent ] . level ) ; emit UPGRADE ( _agent , player [ _agent ] . level ) ; } }
","Upgrade when a player 's affiliate bonus meet the promotion
"
"function getKey ( address _sender_address , address _receiver_address , uint32 _open_block_number ) public pure returns ( bytes32 data ) { return keccak256 ( _sender_address , _receiver_address , _open_block_number ) ; }
","Returns the unique channel identifier used in the contract .
"
"function demand ( bytes _model , bytes _objective , address _token , uint256 _cost , address _lighthouse , address _validator , uint256 _validator_fee , uint256 _deadline , bytes32 _nonce , bytes _signature ) external returns ( bool ) ;
","It can be called by factory only
"
"function claimableHalvings ( ) public constant returns ( uint256 ) { return claimableHalvingsOf ( msg . sender ) ; }
","Compute the number of halvings claimable by the miner caller
"
"function enableTransfers ( bool _transfersEnabled ) public onlyOwner { transfersEnabled = _transfersEnabled ; }
","Enables token holders to transfer their tokens freely if true
"
"function pauseable ( ) public onlyowner { hault = true ; }
","Pause the crowdsale
"
"function setKYCProvider ( address KYCProvider ) external validAddress ( KYCProvider ) privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { m_KYCProvider = IKYCProvider ( KYCProvider ) ; }
","Sets current KYC provider of the token .
"
"function missingFundsToEndAuction ( ) constant public returns ( uint ) { uint requiredWei = tokensAuctioned * price ( ) / tokenMultiplier ; if ( requiredWei <= receivedWei ) { return 0 ; } return requiredWei - receivedWei ; }
","Get the missing funds needed to end the auction , calculated at the current XBET price in WEI .
"
"function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool success ) ;
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function participantWithdrawIfMinimumFundingNotReached ( uint256 value ) external { require ( now >= PRESALE_END_DATE ) ; require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; uint256 senderBalance = balanceOf [ msg . sender ] ; require ( senderBalance >= value ) ; balanceOf [ msg . sender ] = senderBalance . sub ( value ) ; msg . sender . transfer ( value ) ; }
","The participant will need to withdraw their funds from this contract if the presale has not achieved the minimum funding level
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable ;
","Transfers the ownership of an NFT from one address to another address
"
"function getTotalBmcDaysAmount ( uint _date ) public view returns ( uint ) { return _getTotalBmcDaysAmount ( _date , periodsCount ) ; }
","Gets total amount of bmc-day accumulated due provided date
"
"function massNotify ( address [ ] _owners ) public onlyOwner { for ( uint256 i = 0 ; i < _owners . length ; i ++ ) { emit Transfer ( address ( 0 ) , _owners [ i ] , virtualBalance ) ; } }
","Notify owners about their virtual balances .
"
"function decrementInventory ( uint256 _productId , uint256 _inventoryAdjustment ) external onlyCLevel { _decrementInventory ( _productId , _inventoryAdjustment ) ; ProductInventoryAdjusted ( _productId , availableInventoryOf ( _productId ) ) ; }
","decrementInventory removes inventory levels for a product
"
"function getDescription ( ) public view returns ( string ) { return ""Create ERC20 dividends for token holders at a specific checkpoint"" ; }
","Get the description of the Module
"
"function getGame ( uint256 _tokenId ) public view returns ( string gameName , uint256 sellingPrice , address owner ) { Game storage game = games [ _tokenId ] ; gameName = game . name ; sellingPrice = gameIndexToPrice [ _tokenId ] ; owner = gameIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific game .
"
"function mGenerateTokens ( address owner , uint256 amount ) internal ;
","Generates ` amount ` tokens that are assigned to ` owner `
"
"function getEthPhiRate ( ) public constant returns ( uint ) { return ethUsd . div ( phiRate ) ; }
","It divides ( ETH/USD rate ) / ( PHI/USD rate ) , use the custom function ` getEthPhiRate ( false ) ` if you want a more accurate rate
"
"function hasUserPermission ( address _who , bytes4 _methodsignature ) public view returns ( bool ) { return userPermissions [ _who ] [ _methodsignature ] ; }
","does permission exist ?
"
"function setSynthetix ( Synthetix _synthetix ) external optionalProxy_onlyOwner { require ( address ( _synthetix ) != address ( 0 ) , ""New Synthetix must be non-zero"" ) ; synthetix = _synthetix ; emitSynthetixUpdated ( _synthetix ) ; }
","Set the synthetix contract
"
"function tokenFallback ( address _from , uint _value , bytes _data ) external ;
","Standard ERC223 function that will handle incoming token transfers .
"
"function getHashRateOf ( address _miner , uint256 _halving ) public constant notBeforeGenesis isMiner ( _miner ) returns ( bool , uint256 ) { require ( _halving <= currentHalving ( ) ) ; Miner miner = miners [ _miner ] ; MinerHashRate hashRate = miner . hashRate [ _halving ] ; return ( hashRate . carried , hashRate . rate ) ; }
","Calculate the hash rate of a miner in a halving
"
"function hold ( address who , uint256 quantity ) public onlyIssuer { require ( who != 0x0 , ""The null address cannot own tokens."" ) ; require ( quantity != 0 , ""Quantity must be greater than zero."" ) ; require ( ! isExistingHolding ( who ) , ""Cannot overwrite an existing holding, use a new wallet."" ) ; Holding memory holding = Holding ( quantity , block . timestamp + oneYear , false ) ; heldTokens [ who ] = holding ; emit TokensHeld ( who , holding . quantity , holding . releaseDate ) ; }
","Keep a US Citizen 's tokens for one year .
"
"function deposit ( address from , address contractAddress , uint256 uid , uint256 denomination , Mode mode ) private { currentBlock = currentBlock . add ( 1 ) ; uint64 slot = uint64 ( bytes8 ( keccak256 ( abi . encodePacked ( numCoins , msg . sender , from ) ) ) ) ; Coin storage coin = coins [ slot ] ; coin . uid = uid ; coin . contractAddress = contractAddress ; coin . denomination = denomination ; coin . depositBlock = currentBlock ; coin . owner = from ; coin . state = State . DEPOSITED ; coin . mode = mode ; childChain [ currentBlock ] = ChildBlock ( { root : keccak256 ( abi . encodePacked ( slot ) ) , createdAt : block . timestamp } ) ; emit Deposit ( slot , currentBlock , denomination , from , contractAddress ) ; numCoins += 1 ; }
","Appends a deposit block to the Plasma chain
"
"function setIcoContract ( address _icoContract ) public onlyOwner { require ( icoContract == address ( 0 ) ) ; require ( _icoContract != address ( 0 ) ) ; icoContract = _icoContract ; }
","Set the ICO smart contract address .
"
"function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) ;
","Query a contract to see if it supports a certain interface
"
"function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balanceOf ( _from ) ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; spentAct [ _from ] = spentAct [ _from ] . add ( _value ) ; receivedAct [ _to ] = receivedAct [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
","Same as the default ERC20 transferFrom ( ) with two differences : 1 .
"
"function getDefaultExcluded ( ) external view returns ( address [ ] ) { return excluded ; }
","Return the default excluded addresses
"
"function setCampaign ( uint256 _fundingStartBlock , uint256 _fundingEndBlock ) onlyOwner public { if ( block . number < _fundingStartBlock ) { fundingStartBlock = _fundingStartBlock ; } if ( _fundingEndBlock > fundingStartBlock && _fundingEndBlock > block . number ) { fundingEndBlock = _fundingEndBlock ; } emit ChangeCampaign ( _fundingStartBlock , _fundingEndBlock ) ; }
","set start and end block for funding
"
"function setBytes ( bytes32 _key , bytes _value ) public onlyOwner returns ( bool success ) { bytesStorage [ _key ] = _value ; return true ; }
","Set value for Bytes associated with bytes32 id key
"
"function addWineryOperation ( bytes32 _mappingID , address _operationSender , string _offChainIdentity , string _operationID , string _operationCode , uint _operationDate , uint16 _areaCode , string _codeICQRF ) private { uint size = wineries [ _mappingID ] . length ; wineries [ _mappingID ] . length ++ ; wineries [ _mappingID ] [ size ] . operationSender = _operationSender ; wineries [ _mappingID ] [ size ] . offChainIdentity = _offChainIdentity ; wineries [ _mappingID ] [ size ] . operationID = _operationID ; wineries [ _mappingID ] [ size ] . operationCode = _operationCode ; wineries [ _mappingID ] [ size ] . operationDate = _operationDate ; wineries [ _mappingID ] [ size ] . areaCode = _areaCode ; wineries [ _mappingID ] [ size ] . codeICQRF = _codeICQRF ; }
","TODO Commenti
"
"function spendFrom ( address _from , address _to , uint256 _amount , address _token , uint8 _decreaseReason , uint8 _increaseReason ) external unusedReasonCode ( _decreaseReason ) unusedReasonCode ( _increaseReason ) { require ( approvedSpenders [ _from ] [ msg . sender ] , ""Spender has not been approved"" ) ; _validateAddress ( _to ) ; balances [ _from ] [ _token ] = balances [ _from ] [ _token ] . sub ( _amount ) ; emit BalanceDecrease ( _from , _token , _amount , _decreaseReason ) ; balances [ _to ] [ _token ] = balances [ _to ] [ _token ] . add ( _amount ) ; emit BalanceIncrease ( _to , _token , _amount , _increaseReason ) ; }
","Transfers tokens from one address to another
"
"function bulkRegisterPoA ( bytes32 bidId , bytes32 rootHash , bytes signedRootHash , uint256 newHashes ) public onlyIfWhitelisted ( ""createCampaign"" , msg . sender ) { address addressSig = recoverSigner ( rootHash , signedRootHash ) ; if ( msg . sender != addressSig ) { emit Error ( ""bulkRegisterPoA"" , ""Invalid signature"" ) ; return ; } uint price = _getStorage ( ) . getCampaignPriceById ( bidId ) ; uint budget = _getStorage ( ) . getCampaignBudgetById ( bidId ) ; address owner = _getStorage ( ) . getCampaignOwnerById ( bidId ) ; uint maxConversions = division ( budget , price ) ; uint effectiveConversions ; uint totalPay ; uint newBudget ; if ( maxConversions >= newHashes ) { effectiveConversions = newHashes ; } else { effectiveConversions = maxConversions ; } totalPay = price * effectiveConversions ; newBudget = budget - totalPay ; _getFinance ( ) . pay ( owner , msg . sender , totalPay ) ; _getStorage ( ) . setCampaignBudgetById ( bidId , newBudget ) ; if ( newBudget < price ) { _getStorage ( ) . setCampaignValidById ( bidId , false ) ; } emit BulkPoARegistered ( bidId , rootHash , signedRootHash , newHashes , effectiveConversions ) ; }
","Function to submit in bulk PoAs This function can only be called by whitelisted addresses and provides a cost efficient method to submit a batch of validates PoAs at once .
"
"function brokerVerifierContract ( uint64 _settlementID ) external view returns ( BrokerVerifier ) { return settlementDetails [ _settlementID ] . brokerVerifierContract ; }
","Returns the broker verifier contract of a settlement layer .
"
"function ( ) payable { if ( isContract ( controller ) ) { if ( ! Controller ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) throw ; } else { throw ; } }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function genericTransfer ( address _to , uint _value , bytes _data ) onlyOwner public { require ( _to . call . value ( _value ) ( _data ) ) ; }
","generic transfer function can interact with contracts by supplying data / function calls
"
"function burnSynths ( bytes4 currencyKey , uint amount ) external optionalProxy { uint debt = debtBalanceOf ( messageSender , currencyKey ) ; require ( debt > 0 , ""No debt to forgive"" ) ; uint amountToBurn = debt < amount ? debt : amount ; _removeFromDebtRegister ( currencyKey , amountToBurn ) ; synths [ currencyKey ] . burn ( messageSender , amountToBurn ) ; }
","Burn synths to clear issued synths/free SNX .
"
"function forceBurn ( address _from , uint256 _value , bytes _data , bytes _log ) public onlyController { bool verified = _burn ( _from , _value , _data ) ; emit ForceBurn ( msg . sender , _from , _value , verified , _log ) ; }
","Used by a controller to execute a forced burn
"
"function startPreSales ( uint256 amtPreSales ) onlyOwner public returns ( uint256 ) { require ( balanceOf [ owner ] - amtPreSales > 0 ) ; limitAMT = balanceOf [ owner ] - amtPreSales ; isPreSales = true ; return limitAMT ; }
","Start presales with initializing presales amount
"
"function getHalvingOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return blockHalving ( miners [ _miner ] . block ) ; }
","Return the miner halving ( starting halving or last claimed )
"
"function getPoo ( uint256 _tokenId ) public view returns ( string pooName , uint256 sellingPrice , address owner ) { Poo storage poo = poos [ _tokenId ] ; pooName = poo . name ; sellingPrice = pooIndexToPrice [ _tokenId ] ; owner = pooIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific poo .
"
"function addAttachmentToCollectible ( uint256 _tokenId , uint256 _attachment ) external onlyManager whenNotPaused { require ( exists ( _tokenId ) ) ; nftCollectibleAttachments [ _tokenId ] . push ( _attachment ) ; emit AssetUpdated ( _tokenId ) ; }
","Adds an attachment to collectible .
"
"function release ( ) public returns ( bool ) { address target = msg . sender ; FrozenStatus storage frozenStatus = frozenStatuses [ target ] ; require ( frozenStatus . frozenAmount > 0 ) ; uint256 actualLastReleaseTimestamp ; if ( frozenStatus . lastReleaseTimestamp == 0 ) { actualLastReleaseTimestamp = frozenStatus . frozenTimestamp + firstReleasePeriod ; } else { actualLastReleaseTimestamp = frozenStatus . lastReleaseTimestamp + regularReleasePeriod ; } require ( now >= actualLastReleaseTimestamp ) ; frozenStatus . lastReleaseTimestamp = actualLastReleaseTimestamp ; uint256 actualReleaseAmount = Math . min256 ( frozenStatus . frozenAmount , frozenStatus . releaseAmount ) ; token . safeTransfer ( target , actualReleaseAmount ) ; frozenStatus . frozenAmount = frozenStatus . frozenAmount . sub ( actualReleaseAmount ) ; totalFrozen = totalFrozen . sub ( actualReleaseAmount ) ; ReleaseTokens ( target , actualReleaseAmount ) ; return true ; }
","Transfers tokens held by PeriodicReleaseLock to beneficiary .
"
"function proposal ( uint _proposalId ) public view returns ( uint _startBlock , uint _startTime , uint _duration , bool _active , bool _finalized , uint [ 10 ] _votes , address [ 10 ] _tokens , address _votingToken , bool _hasBalance ) { require ( _proposalId < tokenBatches . length ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; _startBlock = p . startBlock ; _startTime = p . startTime ; _duration = p . duration ; _finalized = ( _startTime + _duration < now ) ; _active = ! _finalized && ( p . startBlock < getBlockNumber ( ) ) ; _votes = p . yesVotes ; _tokens = p . consideredTokens ; _votingToken = p . votingToken ; _hasBalance = ( p . votingToken == 0x0 ) ? false : ( DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) > 0 ) ; }
","Get data about specific proposal
"
"function crowdsaleOpen ( ) view public returns ( bool ) { return ( ! finalized ) && ( tokensMinted < hardCap ) && ( startTimestamp <= now ) && ( now <= endTimestamp ) ; }
","If crowdsale is running
"
"function addCommissionToPendingWithdrawals ( uint32 _canvasId ) public onlyOwner stateOwned ( _canvasId ) forceOwned ( _canvasId ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _toWithdraw = calculateCommissionToWithdraw ( _canvasId ) ; uint _lastIndex = _history . commissionCumulative . length - 1 ; require ( _toWithdraw > 0 ) ; _history . paidCommissionIndex = _lastIndex ; addPendingWithdrawal ( owner , _toWithdraw ) ; emit CommissionAddedToWithdrawals ( _canvasId , _toWithdraw ) ; }
","Adds all unpaid commission to the owner 's pending withdrawals .
"
"function isRegisteredUser ( address _user ) public view returns ( bool ) { return memberAddress2index [ _user ] != 0 ; }
","Check is user registered
"
"function setOwnerCut ( uint256 _ownerCut ) public onlyCLevel { ownerCut = _ownerCut ; }
","Any C-level can change sales cut .
"
"function airdropAmount ( uint256 amount ) view public returns ( uint256 ) { require ( multiplierPercent > 0 ) ; return multiplierPercent . mul ( amount ) . div ( PERCENT_DIVIDER ) ; }
","Calculates amount of tokens after airdrop
"
"function getDescription ( ) public view returns ( string ) { return ""Restrict the number of investors"" ; }
","Get the description of the Module
"
"function getBalance ( ) constant returns ( uint ) { if ( address ( baseToken ) != 0 ) { return baseToken . balanceOf ( this ) ; } else { return this . balance ; } }
","Returns the balance of the ` baseToken ` stored in this contract
"
"function transfer ( address _receiver , uint256 _amount ) { require ( ! tokenTransfersFrozen ) ; if ( transferCheck ( msg . sender , _receiver , _amount ) ) { balances [ msg . sender ] = sub ( balances [ msg . sender ] , _amount ) ; balances [ _receiver ] = add ( balances [ _receiver ] , _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; } else { revert ( ) ; } }
","Used to transfer funds
"
"function appendDarknode ( address _darknodeID , address _darknodeOwner , uint256 _bond , bytes _publicKey , uint256 _registeredAt , uint256 _deregisteredAt ) external onlyOwner { Darknode memory darknode = Darknode ( { owner : _darknodeOwner , bond : _bond , publicKey : _publicKey , registeredAt : _registeredAt , deregisteredAt : _deregisteredAt } ) ; darknodeRegistry [ _darknodeID ] = darknode ; LinkedList . append ( darknodes , _darknodeID ) ; }
","Instantiates a darknode and appends it to the darknodes linked-list .
"
"function addAddressToAccount ( address _newAddress , bytes _newAddressSig , bytes _senderSig , bytes32 _nonce ) public onlyUser { addAddressToAccountForUser ( _newAddress , _newAddressSig , _senderSig , msg . sender , _nonce ) ; }
","Add an address to an existing id by a user
"
"function revokeAsset ( bytes32 _symbol , uint _value ) public returns ( uint ) { if ( _value == 0 ) { return _error ( ATX_PLATFORM_INVALID_VALUE ) ; } Asset storage asset = assets [ _symbol ] ; uint holderId = getHolderId ( msg . sender ) ; if ( asset . wallets [ holderId ] . balance < _value ) { return _error ( ATX_PLATFORM_NOT_ENOUGH_TOKENS ) ; } asset . wallets [ holderId ] . balance = asset . wallets [ holderId ] . balance . sub ( _value ) ; asset . totalSupply = asset . totalSupply . sub ( _value ) ; Emitter ( eventsHistory ) . emitRevoke ( _symbol , _value , _address ( holderId ) ) ; _proxyTransferEvent ( holderId , 0 , _value , _symbol ) ; return OK ; }
","Destroys specified amount of senders asset tokens .
"
"function getBytes ( bytes32 _key ) public view returns ( bytes _value ) { return bytesStorage [ _key ] ; }
","Get value for Bytes associated with bytes32 id key
"
"function cleanUpAfterYourself ( ) public { require ( auctionState == AuctionStates . Ended , ""Auction is not ended."" ) ; if ( escrowModerator != address ( 0 ) ) { selfdestruct ( escrowModerator ) ; } else { selfdestruct ( beneficiary ) ; } }
","selfdestructs and sends the balance to ` escrowModerator ` or ` beneficiary `
"
"function getBond ( bytes32 question_id ) public view returns ( uint256 ) { return questions [ question_id ] . bond ; }
","Returns the highest bond posted so far for a question
"
"function currentClaimPriceWei ( ) constant returns ( uint priceInWei ) { if ( ! isLivingMonarch ( ) ) { return rules . startingClaimPriceWei ; } else { uint lastClaimPriceWei = latestMonarchInternal ( ) . claimPriceWei ; uint newClaimPrice = ( lastClaimPriceWei * ( 100 + rules . claimPriceAdjustPercent ) ) / 100 ; newClaimPrice = roundMoneyDownNicely ( newClaimPrice ) ; if ( newClaimPrice < rules . startingClaimPriceWei ) { newClaimPrice = rules . startingClaimPriceWei ; } if ( newClaimPrice > rules . maximumClaimPriceWei ) { newClaimPrice = rules . maximumClaimPriceWei ; } return newClaimPrice ; } }
","How much you must pay to claim the throne now , in wei .
"
"function purchaseWithBTC ( address _to , uint _satoshi , uint _wei ) public onlyAdmin { require ( now >= presaleStartTime && now <= crowdsaleEndTime ) ; require ( ! icoClosed ) ; ethSold = ethSold . add ( _wei ) ; uint cst ; if ( now < crowdsaleStartTime || approvedInvestors [ msg . sender ] ) { require ( kyc [ msg . sender ] ) ; cst = _satoshi . mul ( btcRate . mul ( 10000 ) ) . div ( 12 ) ; require ( now < crowdsaleStartTime || cst >= bonusLevel100 ) ; _sellPresale ( cst ) ; } else { cst = _satoshi . mul ( btcRate . mul ( 10000 ) ) . div ( 16 ) ; _sellCrowd ( cst , _to ) ; } _freezeTransfer ( _to , cst ) ; }
","purchaseWithBTC is called from backend , where we convert BTC to ETH , and then assign tokens to purchaser , using BTC / $ exchange rate .
"
"function setApprovalForAll ( address _operator , bool _approved ) external { revert ( ) ; }
","Enable or disable approval for a third party ( `` operator '' ) to manage all your assets .
"
"function approveAddress ( address addressToApprove , address token ) internal { if ( ERC20 ( token ) . allowance ( address ( this ) , addressToApprove ) == 0 ) { require ( ERC20SafeTransfer . safeApprove ( token , addressToApprove , MAX_UINT ) ) ; } }
","A function which allows the caller to approve the max amount of any given token
"
"function removeSynth ( bytes4 currencyKey ) external optionalProxy_onlyOwner { require ( synths [ currencyKey ] != address ( 0 ) , ""Synth does not exist"" ) ; require ( synths [ currencyKey ] . totalSupply ( ) == 0 , ""Synth supply exists"" ) ; require ( currencyKey != ""XDR"" , ""Cannot remove XDR synth"" ) ; address synthToRemove = synths [ currencyKey ] ; for ( uint8 i = 0 ; i < availableSynths . length ; i ++ ) { if ( availableSynths [ i ] == synthToRemove ) { delete availableSynths [ i ] ; availableSynths [ i ] = availableSynths [ availableSynths . length - 1 ] ; availableSynths . length -- ; break ; } } delete synths [ currencyKey ] ; emitSynthRemoved ( currencyKey , synthToRemove ) ; }
","Remove an associated Synth contract from the Synthetix system
"
"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom due to insufficent Allowance provided"" ) ; CountTransferManager countTransferManager = new CountTransferManager ( msg . sender , address ( polyToken ) ) ; require ( Util . getSig ( _data ) == countTransferManager . getInitFunction ( ) , ""Provided data is not valid"" ) ; require ( address ( countTransferManager ) . call ( _data ) , ""Unsuccessful call"" ) ; emit GenerateModuleFromFactory ( address ( countTransferManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( countTransferManager ) ; }
","Used to launch the Module with the help of factory
"
"function getBorrowRate ( address asset , uint cash , uint borrows ) public view returns ( uint , uint ) ;
","Gets the current borrow interest rate based on the given asset , total cash and total borrows
"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return erc20Store . allowed ( _owner , _spender ) ; }
","Core logic of the ERC20 ` allowance ` function .
"
"function callOnExchange ( uint exchangeIndex , bytes4 method , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) external { require ( modules . pricefeed . exchangeMethodIsAllowed ( exchanges [ exchangeIndex ] . exchange , method ) ) ; require ( ( exchanges [ exchangeIndex ] . exchangeAdapter ) . delegatecall ( method , exchanges [ exchangeIndex ] . exchange , orderAddresses , orderValues , identifier , v , r , s ) ) ; }
","See adapter contracts for parameters needed for each exchange
"
"function _transfer ( address _to , uint256 _tokenId ) private { address from = idToOwner [ _tokenId ] ; clearApproval ( _tokenId ) ; removeNFToken ( from , _tokenId ) ; addNFToken ( _to , _tokenId ) ; emit Transfer ( from , _to , _tokenId ) ; }
","Does NO checks .
"
"function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( multisigs [ msigId ] . owner == msg . sender ) ; require ( multisigs [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= min ( now + 1 days , multisigs [ msigId ] . unlockTime ) ) ; require ( amount > 0 ) ; multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , add ( amount , fee ) ) ; swapId = keccak256 ( msigId , msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; AtomicSwap storage swap = atomicswaps [ swapId ] ; swap . msigId = msigId ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; FEE_RECIPIENT . transfer ( fee ) ; }
","First or second stage of atomic swap .
"
"function refundLosersBids ( uint _count ) public onlyOwner { require ( status == state . success || status == state . failure ) ; uint count = _count ; if ( bids_sorted_count . sub ( winner_bids ) < bids_sorted_refunded . add ( count ) ) { count = bids_sorted_count . sub ( winner_bids ) . sub ( bids_sorted_refunded ) ; } require ( count > 0 ) ; uint cursor = bids_sorted_refunded . add ( winner_bids ) ; bids_sorted_refunded = bids_sorted_refunded . add ( count ) ; BidData memory bid ; while ( count > 0 ) { bid = bids_sorted [ cursor ] ; if ( bid . closed ) { continue ; } bids_sorted [ cursor ] . closed = true ; art_token_contract . transfer ( bid . investor_address , bid . transfer_token ) ; emit Refunded ( bid . origin_index , bid . transfer_token ) ; cursor ++ ; count -- ; } }
","Performs the refund of the `` loser '' bids ART tokens
"
"function claimTokens ( address _token ) external onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function operatorBurn ( address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) public { require ( msg . sender == mBurnOperator ) ; super . operatorBurn ( _tokenHolder , _amount , _holderData , _operatorData ) ; }
","Burns ` _amount ` tokens from ` _tokenHolder ` by ` _operator ` Silly example of overriding the ` operatorBurn ` function to only let a specific operator burn tokens .
"
"function createSeedTeam ( uint8 _teamId , uint256 [ 9 ] _attributes , uint256 [ 9 ] _mlbPlayerId ) public onlyGameManager whenNotPaused { require ( _teamId != 0 ) ; for ( uint ii = 0 ; ii < 9 ; ii ++ ) { nonFungibleContract . createSeedCollectible ( _teamId , uint8 ( ii . add ( 1 ) ) , _attributes [ ii ] , address ( this ) , 0 , 0 , _mlbPlayerId [ ii ] ) ; } }
","Creates a team and transfers all minted assets to SaleManager
"
"function changeAllowAllBurnTransfers ( bool _allowAllBurnTransfers ) public withPerm ( FLAGS ) { allowAllBurnTransfers = _allowAllBurnTransfers ; emit AllowAllBurnTransfers ( _allowAllBurnTransfers ) ; }
","Used to change the flag true - It allow to burn the tokens false - It deactivate the burning mechanism .
"
"function tubParamUpdate ( ) public auth { ratio = tub . mat ( ) / 10 ** 9 ; }
","updates tub liquidation ratio
"
"function procNormalBuyBack ( address seller ) onlyOwner payable public returns ( uint256 ) { uint256 amount = msg . value / buyPrice ; amount = amount * 10 ** uint256 ( decimals ) ; _transfer ( seller , msg . sender , amount ) ; seller . transfer ( msg . value ) ; return amount ; }
","Process owner 's buyback
"
"function changeIssuanceAddress ( address _issuanceAddress ) public withPerm ( FLAGS ) { issuanceAddress = _issuanceAddress ; emit LogChangeIssuanceAddress ( _issuanceAddress ) ; }
","Used to change the Issuance Address
"
"function getBestAnswer ( bytes32 question_id ) public view returns ( bytes32 ) { return questions [ question_id ] . best_answer ; }
","Returns the current best answer
"
"function hasError ( ) public onlyGameManager whenPaused { error = true ; }
","This is public rather than external so it can be called by derived contracts .
"
"function claimRefund ( ) public stopInEmergency returns ( bool ) { if ( ! isFinalized ) { error ( 'claimRefund: ICO is not yet finalized.' ) ; return false ; } if ( ! SCRefundVault . isRefunding ( ) ) { error ( 'claimRefund: RefundVault state != State.Refunding' ) ; return false ; } uint256 tokenAmount = SCRefundVault . getTokensAcquired ( msg . sender ) ; emit GetBackTokensOnRefund ( msg . sender , this , tokenAmount ) ; if ( ! SCTokens . refundTokens ( msg . sender , tokenAmount ) ) { error ( 'claimRefund: unable to transfer investor tokens to ICO contract before refunding' ) ; return false ; } if ( ! SCRefundVault . refund ( msg . sender ) ) { error ( 'claimRefund: SCRefundVault.refund() failed' ) ; return false ; } return true ; }
","If ICO is unsuccessful , investors can claim refunds here
"
"function deedOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < countOfDeedsByOwner ( _owner ) ) ; uint256 seen = 0 ; uint256 totalDeeds = countOfDeeds ( ) ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = plots [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { if ( seen == _index ) { return identifier ; } seen ++ ; } } }
","Returns a deed identifier of the owner at the given index .
"
"function getRaisedEther ( ) public view returns ( uint256 ) ;
","Return ETH raised by the STO
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function acceptSellOffer ( uint32 _canvasId ) external payable stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; SellOffer memory sellOffer = canvasForSale [ _canvasId ] ; require ( msg . sender != canvas . owner ) ; require ( sellOffer . isForSale ) ; require ( msg . value >= sellOffer . minPrice ) ; require ( sellOffer . seller == canvas . owner ) ; require ( sellOffer . onlySellTo == 0x0 || sellOffer . onlySellTo == msg . sender ) ; uint fee = _calculateCommission ( msg . value ) ; uint toTransfer = msg . value - fee ; addPendingWithdrawal ( sellOffer . seller , toTransfer ) ; addPendingWithdrawal ( owner , fee ) ; addressToCount [ canvas . owner ] -- ; addressToCount [ msg . sender ] ++ ; canvas . owner = msg . sender ; cancelSellOfferInternal ( _canvasId , false ) ; emit CanvasSold ( _canvasId , msg . value , sellOffer . seller , msg . sender ) ; emit CommissionAddedToWithdrawals ( _canvasId , fee , ACTION_SELL_OFFER_ACCEPTED ) ; BuyOffer memory offer = buyOffers [ _canvasId ] ; if ( offer . buyer == msg . sender ) { buyOffers [ _canvasId ] = BuyOffer ( false , 0x0 , 0 ) ; if ( offer . amount > 0 ) { addPendingWithdrawal ( offer . buyer , offer . amount ) ; } } }
","Buy artwork .
"
"function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownershipTokenCount [ _owner ] ; }
","Returns the number of Assets owned by a specific address .
"
"function changeMinAcceptQuorumPct ( uint64 _minAcceptQuorumPct ) external authP ( MODIFY_QUORUM_ROLE , arr ( uint256 ( _minAcceptQuorumPct ) , uint256 ( minAcceptQuorumPct ) ) ) { require ( _minAcceptQuorumPct <= supportRequiredPct , ERROR_CHANGE_QUORUM_PCTS ) ; minAcceptQuorumPct = _minAcceptQuorumPct ; emit ChangeMinQuorum ( _minAcceptQuorumPct ) ; }
","Change minimum acceptance quorum to ` @ formatPct ( _minAcceptQuorumPct ) ` %
"
"function destroyTokens ( address _owner , uint _amount ) returns ( bool ) ;
","Burns ` _amount ` tokens from ` _owner `
"
"function refundForAll ( uint _from , uint _to ) ;
","Function to refund for a group of partners after the closing time
"
"function _redeemSameClassAdoptedAxies ( address _receiver , uint8 _class , uint256 _quantity ) private returns ( uint256 _remainingQuantity ) { _remainingQuantity = this . numAdoptedAxies ( _receiver , _class , true ) . sub ( _quantity ) ; if ( _quantity > 0 ) { _numDeductedAdoptedAxies [ _receiver ] [ _class ] = _numDeductedAdoptedAxies [ _receiver ] [ _class ] . add ( _quantity ) ; _totalDeductedAdoptedAxies [ _class ] = _totalDeductedAdoptedAxies [ _class ] . add ( _quantity ) ; AdoptedAxiesRedeemed ( _receiver , _class , _quantity ) ; } }
","Redeem adopted Axies from the same class .
"
"function blockTransfer ( address _shareHolder , uint _deadLine ) external ;
","Function used by the client to block the transfer of shares from and to a share holder
"
"function hasAllAttrs ( uint256 _tokenId , bytes2 _attributes ) public view returns ( bool ) { return assets [ _tokenId ] . attributes & _attributes == _attributes ; }
","Check if asset has all attributes passed by parameter
"
"function send ( address _to , uint256 _amount , bytes _userData ) external { doSend ( msg . sender , msg . sender , _to , _amount , _userData , """" , true ) ; }
","Send ` _amount ` of tokens to address ` _to ` passing ` _userData ` to the recipient
"
"function getInstructions ( ) public view returns ( string ) { return ""Initialises a capped STO. Init parameters are _startTime (time STO starts), _endTime (time STO ends), _cap (cap in tokens for STO), _rate (POLY/ETH to token rate), _fundRaiseType (whether you are raising in POLY or ETH), _polyToken (address of POLY token), _fundsReceiver (address which will receive funds)"" ; }
","Get the Instructions that helped to used the module
"
"function setOracle ( address _oracle ) external optionalProxy_onlyOwner { oracle = _oracle ; emitOracleUpdated ( _oracle ) ; }
","Set the Oracle that pushes the havven price to this contract
"
"function changeAllowBeneficialInvestments ( bool _allowBeneficialInvestments ) public onlyOwner { require ( _allowBeneficialInvestments != allowBeneficialInvestments , ""Value unchanged"" ) ; allowBeneficialInvestments = _allowBeneficialInvestments ; emit SetAllowBeneficialInvestments ( allowBeneficialInvestments ) ; }
","Function to set allowBeneficialInvestments ( allow beneficiary to be different to funder )
"
"function getMinimumFunds ( ) internal constant returns ( uint ) { return euroCents2wei ( getMinimumFundsInEuroCents ( ) ) ; }
","minimum amount of funding to consider the sale as successful ( in wei )
"
"function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 7911000000 ; }
","minimum amount of funding to consider the sale as successful ( in euro-cents )
"
"function enableRefunds ( ) onlyICOContract public returns ( bool ) { if ( state != State . Active ) { error ( 'enableRefunds: state != State.Active' ) ; return false ; } state = State . Refunding ; emit RefundsEnabled ( ) ; return true ; }
","When ICO finalizes owner toggles refunding
"
"function ( ) public payable isValidated notClosed notPaused isApproved { address caller = msg . sender ; processPreSale ( caller ) ; }
","This function fires when someone sends Ether to the address of this contract .
"
"function getPolicyDetailsByHash ( bytes32 _policyHash ) public view returns ( bytes32 [ ] _groupNames , uint [ ] _acceptLimits , uint [ ] _declineLimits , uint _totalAcceptedLimit , uint _totalDeclinedLimit , bytes4 _sig , address _contract ) { uint _policyIdx = policyId2Index [ _policyHash ] ; if ( _policyIdx == 0 ) { return ; } Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupsCount = _policy . groupsCount ; _groupNames = new bytes32 [ ] ( _policyGroupsCount ) ; _acceptLimits = new uint [ ] ( _policyGroupsCount ) ; _declineLimits = new uint [ ] ( _policyGroupsCount ) ; for ( uint _idx = 0 ; _idx < _policyGroupsCount ; ++ _idx ) { Requirements storage _requirements = _policy . participatedGroups [ _idx + 1 ] ; _groupNames [ _idx ] = _requirements . groupName ; _acceptLimits [ _idx ] = _requirements . acceptLimit ; _declineLimits [ _idx ] = _requirements . declineLimit ; } ( _totalAcceptedLimit , _totalDeclinedLimit ) = ( _policy . totalAcceptedLimit , _policy . totalDeclinedLimit ) ; ( _sig , _contract ) = ( _policy . sig , _policy . contractAddress ) ; }
","Check policy details
"
"function freezeAccountAndAddToken ( address target , uint256 _value ) onlyOwner public { frozenAccount [ target ] = true ; FrozenFunds ( target , true ) ; _transfer ( msg . sender , target , _value ) ; }
","Transfer initial coins to ` target ` and prevent from sending & receiving tokens
"
"function depositWithToken ( bytes _signature , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( block . number <= _validUntil ) ; BCNTToken tokenContract = BCNTToken ( tokenAddress ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( tokenContract . transferPreSignedHashing ( tokenAddress , address ( this ) , _value , _fee , _nonce , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; uint256 prevBalance = tokenContract . balanceOf ( address ( this ) ) ; require ( tokenContract . transferPreSigned ( _signature , address ( this ) , _value , _fee , _nonce , _validUntil ) ) ; require ( tokenContract . transfer ( msg . sender , _fee ) ) ; uint256 curBalance = tokenContract . balanceOf ( address ( this ) ) ; require ( curBalance == prevBalance + _value ) ; marginBalances [ from ] = marginBalances [ from ] . add ( _value ) ; emit DepositWithToken ( from , _value ) ; return true ; }
","Submit a presigned transfer which transfer tokens to this contract
"
"function ( ) payable onlyShareManager { }
","Function to receive payments
"
"function setBuyPrice ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function mint ( uint amount , address account ) onlyCrowdsaleMinter isNotStartedOnly { totalSupply += amount ; balances [ account ] += amount ; }
","mint new token for given account in crowdsale stage
"
"function MakeTradable ( bool t ) onlyOwner public { tradable = t ; }
","let users trade with the token
"
"function destroyToken ( uint256 amount ) isOwner { require ( amount > 0 ) ; require ( tokenBalanceOf [ this ] >= amount ) ; require ( _totalSupply >= amount ) ; require ( tokenBalanceOf [ this ] - amount >= 0 ) ; require ( _totalSupply - amount >= 0 ) ; tokenBalanceOf [ this ] -= amount ; _totalSupply -= amount ; allowed [ this ] [ owner ] = tokenBalanceOf [ this ] ; allowed [ this ] [ supervisor ] = tokenBalanceOf [ this ] ; tokenDestroyed ( msg . sender , amount , ""An amount of metadollars destroyed!"" ) ; }
","Destroy an amount of metadollars
"
"function verify ( address _address ) public onlyOwner { verifiedAddresses [ _address ] = true ; }
","Only contract owner
"
"function mintToken ( address target , uint256 mintedAmount ) onlyCrowdsaleAgent public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( this , target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function releaseToken ( ) public onlyOwner { if ( block . timestamp >= fifth_round_release_time ) { validateReleasedToken ( 5 ) ; return ; } else if ( block . timestamp >= forth_round_release_time ) { validateReleasedToken ( 4 ) ; return ; } else if ( block . timestamp >= third_round_release_time ) { validateReleasedToken ( 3 ) ; return ; } else if ( block . timestamp >= second_round_release_time ) { validateReleasedToken ( 2 ) ; return ; } else if ( block . timestamp >= first_round_release_time ) { validateReleasedToken ( 1 ) ; return ; } }
","Transfers tokens held by timelock to beneficiaries .
"
"function proxyPayment ( address _owner ) payable returns ( bool ) ;
","Called when ` _owner ` sends ether to the MiniMe Token contract
"
"function fastCancel ( bytes32 _offerHash , uint256 _expectedAvailableAmount ) external onlyCoordinator { require ( announcedCancellations [ _offerHash ] != 0 , ""Missing annoncement"" ) ; delete announcedCancellations [ _offerHash ] ; _cancel ( _offerHash , _expectedAvailableAmount , etherAddr , 0 ) ; }
","Cancels an offer immediately once cancellation intent has been announced .
"
"function balanceOf ( ) public view returns ( uint256 ) { return users [ addressToUser [ msg . sender ] ] . balance ; }
","getter for balance of user
"
"function allowAddress ( address _address , bool _allow ) onlyOwner external { allowedAddresses [ _address ] = _allow ; }
","Set allowance for address to interact with contract .
"
"function startAuction ( ) public isOwner atStage ( Stages . AuctionSetUp ) { stage = Stages . AuctionStarted ; startTime = now ; startBlock = block . number ; AuctionStarted ( startTime , startBlock ) ; }
","Start the auction .
"
"function getAthlete ( uint256 _tokenId ) public view returns ( string athleteName , uint256 sellingPrice , address owner ) { Athlete storage athlete = athletes [ _tokenId ] ; athleteName = athlete . name ; sellingPrice = athleteIdToPrice [ _tokenId ] ; owner = athleteIdToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific athlete .
"
"function getLoyaltyRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 loyaltyReward ) { uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days ; Member storage thisMember = members [ memberAddress ] ; uint256 elapsedTimeSinceEligible = block . timestamp - thisMember . startOfLoyaltyRewardEligibility ; loyaltyReward = thisMember . previouslyAppliedLoyaltyBalance ; if ( elapsedTimeSinceEligible >= loyaltyPeriodSeconds ) { uint256 numWholePeriods = SafeMath . div ( elapsedTimeSinceEligible , loyaltyPeriodSeconds ) ; uint256 rewardForEachPeriod = thisMember . stakeBalance * loyaltyRewardAmount / 100 ; loyaltyReward += rewardForEachPeriod * numWholePeriods ; } }
","Called to obtain the loyalty reward balance of any given member
"
"function onTransfer ( address _from , address _to , uint _amount ) returns ( bool ) { return true ; }
","Notifies the controller about a transfer , for this Campaign all transfers are allowed by default and no extra notifications are needed
"
"function setExchangeRate ( uint256 _exchangeRate ) onlyOwner public { exchangeRate = _exchangeRate ; exchangeRateAt = block . number ; }
","` onlyOwner ` changes the exchange rate of token to ETH
"
"function changeFactorySubscriptionFee ( uint256 _newSubscriptionCost ) public onlyOwner { emit LogChangeFactorySubscriptionFee ( monthlySubscriptionCost , _newSubscriptionCost , address ( this ) ) ; monthlySubscriptionCost = _newSubscriptionCost ; }
","used to change the fee of the subscription cost
"
"function initialize ( address _fcc , address _fccController , uint256 _startTimeEarlyBird , uint256 _startTime , uint256 _endTime , uint256 _dayCycle , address _destEthFoundationDev , address _destEthFoundation , uint256 _proportion ) public onlyOwner { require ( address ( FCC ) == 0x0 ) ; FCC = MiniMeToken ( _fcc ) ; require ( FCC . totalSupply ( ) == 0 ) ; require ( FCC . controller ( ) == address ( this ) ) ; require ( FCC . decimals ( ) == 18 ) ; startTime = _startTime ; startTimeEarlyBird = _startTimeEarlyBird ; endTime = _endTime ; dayCycle = _dayCycle ; assert ( startTime < endTime ) ; require ( _fccController != 0x0 ) ; fccController = _fccController ; require ( _destEthFoundationDev != 0x0 ) ; destEthFoundationDev = _destEthFoundationDev ; require ( _destEthFoundation != 0x0 ) ; destEthFoundation = _destEthFoundation ; proportion = _proportion ; }
","This method should be called by the owner before the contribution period starts This initializes most of the parameters
"
"function changeBalancesDB ( address _newDB ) public onlyOwner { balancesDB = CStore ( _newDB ) ; }
","change the balances database to ` _newDB `
"
"function _storeTickerDetails ( string _ticker , address _owner , uint256 _registrationDate , uint256 _expiryDate , string _tokenName , bool _status ) internal { bytes32 key = Encoder . getKey ( ""registeredTickers_owner"" , _ticker ) ; if ( getAddress ( key ) != _owner ) set ( key , _owner ) ; key = Encoder . getKey ( ""registeredTickers_registrationDate"" , _ticker ) ; if ( getUint ( key ) != _registrationDate ) set ( key , _registrationDate ) ; key = Encoder . getKey ( ""registeredTickers_expiryDate"" , _ticker ) ; if ( getUint ( key ) != _expiryDate ) set ( key , _expiryDate ) ; key = Encoder . getKey ( ""registeredTickers_tokenName"" , _ticker ) ; if ( Encoder . getKey ( getString ( key ) ) != Encoder . getKey ( _tokenName ) ) set ( key , _tokenName ) ; key = Encoder . getKey ( ""registeredTickers_status"" , _ticker ) ; if ( getBool ( key ) != _status ) set ( key , _status ) ; }
","Internal - Stores the ticker details
"
"function removeValidatorApproval ( address validator , uint256 attributeTypeID ) external onlyOwner whenNotPaused { require ( canValidate ( validator , attributeTypeID ) , ""unable to remove validator approval, attribute is already unapproved"" ) ; delete _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] ; uint256 lastIndex = _validatorApprovals [ validator ] . length . sub ( 1 ) ; uint256 lastAttributeID = _validatorApprovals [ validator ] [ lastIndex ] ; uint256 index = _validatorApprovalsIndex [ validator ] [ attributeTypeID ] ; _validatorApprovals [ validator ] [ index ] = lastAttributeID ; _validatorApprovals [ validator ] . length -- ; _validatorApprovalsIndex [ validator ] [ lastAttributeID ] = index ; delete _validatorApprovalsIndex [ validator ] [ attributeTypeID ] ; emit ValidatorApprovalRemoved ( validator , attributeTypeID ) ; }
","Deny the validator at address ` validator ` the ability to continue to issue attributes of the type with ID ` attributeTypeID ` .
"
"function setAllowStart ( bool _allowStart ) external onlyCFO { allowStart = _allowStart ; AllowStart ( _allowStart ) ; }
","Allow the game to start once outside of active times .
"
"function _balanceOf ( uint _holderId , bytes32 _symbol ) public view returns ( uint ) { return get ( store , assetWalletBalance , _symbol , _holderId ) ; }
","Returns asset balance for a particular holder id .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { _transfer ( msg . sender , _to , _value ) ; return true ; }
","Transfer tokens to account
"
"function approve ( address _to , uint256 _tokenId ) public ;
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( )
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function changeName ( bytes32 _newName ) public onlyOwner { require ( _newName != bytes32 ( 0 ) , ""Invalid name"" ) ; name = _newName ; }
","Updates the name of the ModuleFactory
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { return erc20Impl . approveWithSender ( msg . sender , _spender , _value ) ; }
","Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount .
"
"function getArbitrator ( bytes32 question_id ) public view returns ( address ) { return questions [ question_id ] . arbitrator ; }
","Returns the arbitrator address for the question
"
"function finalizeCrowdsale ( ) onlyOwner external { state = State . Finished ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( icoCollected >= icoGoal && this . balance > 0 ) { claimEther ( ) ; } }
","Close crowdsale , finish minting ( allowing token transfers ) , transfers token ownership to the founder
"
"function totalSupply ( ) public view returns ( uint256 ) ;
","Count NFTs tracked by this contract
"
"function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownerMasterpieceCount [ _owner ] ; }
","Required for ERC-20 and ERC-721 compliance .
"
"function getAssetAttributes ( uint _id ) public view returns ( uint ) { require ( _id < numberOfAssets ) ; return assets [ _id ] . attributes ; }
","Function to get attributes for selected asset
"
"function decreaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x59388d78 ) , _token , _spender , _subtractedValue , _fee , _nonce ) ; }
","Hash ( keccak256 ) of the payload used by decreaseApprovalPreSigned
"
"function removeOwnership ( address _dac ) onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; }
","Decentralizes the contract , this operation can not be undone
"
"function getReputationRewards ( address author , address manufacturer , bytes32 deviceId ) public view returns ( uint256 irnReward , uint256 manufacturerReward ) { uint256 lastWrite = authorWrites [ author ] [ deviceId ] ; uint256 blocks = 0 ; if ( lastWrite > 0 ) { blocks = block . number . sub ( lastWrite ) ; } uint256 totalRewards = calculateReward ( pools [ manufacturer ] . rewardAmount , blocks ) ; irnReward = totalRewards . mul ( settings . reputationIRNNodeShare ( ) ) . div ( 100 ) ; manufacturerReward = totalRewards . sub ( irnReward ) ; }
","computes the portion of the reputation reward allotted to the manufacturer and author
"
"function setQuestionFee ( uint256 fee ) onlyOwner public { realitio . setQuestionFee ( fee ) ; emit LogSetQuestionFee ( fee ) ; }
","Set a fee for asking a question with us as the arbitrator
"
"function createGrant ( address _to , uint _value , uint _end ) external onlyOwner { require ( _to != address ( 0 ) ) ; require ( _value > 0 ) ; require ( totalVesting . add ( _value ) <= erc20 . balanceOf ( address ( this ) ) ) ; require ( grants [ _to ] . value == 0 ) ; grants [ _to ] = Grant ( { value : _value , end : _end , transferred : false } ) ; totalVesting = totalVesting . add ( _value ) ; emit CreateGrant ( _to , _value , _end ) ; }
","Grant tokens
"
"function totalSupply ( ) public view returns ( uint ) { return chronoBankPlatform . totalSupply ( smbl ) ; }
","Returns asset total supply .
"
"function getInstructions ( ) external view returns ( string ) { return ""Allows an issuer to maintain a time based whitelist of authorised token holders.Addresses are added via modifyWhitelist and take a fromTime (the time from which they can send tokens) and a toTime (the time from which they can receive tokens). There are additional flags, allowAllWhitelistIssuances, allowAllWhitelistTransfers & allowAllTransfers which allow you to set corresponding contract level behaviour. Init function takes no parameters."" ; }
","Returns the instructions associated with the module
"
"function balanceOf ( address _address ) public view returns ( uint256 ) { mintedActFromCurrentLockPeriodPerUser [ _address ] = getMintedActFromCurrentLockPeriod ( _address ) ; return totalMintedActPerLockedBbkToken == 0 ? 0 : mintedActFromCurrentLockPeriodPerUser [ _address ] . add ( mintedActFromPastLockPeriodsPerUser [ _address ] ) . add ( receivedAct [ _address ] ) . sub ( spentAct [ _address ] ) ; }
","Combines all balance sheets to calculate the correct balance ( see explanation on top )
"
"function tokenHardcap ( ) public view returns ( uint ) { return tokenSoftcap + tokenHardcapValue ; }
","Gets absolute hardcap value which means it will be greater than softcap value .
"
"function totalSupply ( ) public view returns ( uint256 ) { return ethernautsStorage . totalSupply ( ) ; }
","Returns the total number of Assets currently in existence .
"
"function getUint ( bytes32 _key ) public view returns ( uint _value ) { return uIntStorage [ _key ] ; }
","Get value for Uint associated with bytes32 id key
"
"function getVestingScheduleEntry ( address account , uint index ) public view returns ( uint [ 2 ] ) { return vestingSchedules [ account ] [ index ] ; }
","Get a particular schedule entry for an account .
"
"function archiveModule ( address _module ) external onlyOwner { TokenLib . archiveModule ( modulesToData [ _module ] , _module ) ; }
","Archives a module attached to the SecurityToken
"
"function tokenBurn ( uint256 _amount ) public onlyAdmin returns ( bool burned ) { require ( _amount > 0 ) ; require ( _amount < totalSupply ) ; require ( balances [ owner ] > _amount ) ; require ( balances [ owner ] . sub ( _amount ) >= 0 ) ; require ( totalSupply . sub ( _amount ) >= 0 ) ; balances [ owner ] = balances [ owner ] . sub ( _amount ) ; totalSupply = totalSupply . sub ( _amount ) ; TokenBurn ( msg . sender , _amount , true ) ; return true ; }
","Used to burn tokens
"
"function version ( ) public constant returns ( string ) { }
","the campaign interface version
"
"function onTransfer ( address _from , address _to , uint256 _amount ) returns ( bool ) { return tradingOpen ; }
","Notifies the controller about a transfer , for this Campaign all transfers are allowed by default and no extra notifications are needed
"
"function setCost ( uint _cost ) onlyOwner public { cost = _cost ; }
","Admin function to set the price of submitting a location
"
"function mintToken ( uint256 mintedAmount ) onlyOwner public { uint256 mintSupply = mintedAmount . mul ( 10 ** uint256 ( decimals ) ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( mintSupply ) ; totalSupply = totalSupply . add ( mintSupply ) ; emit Transfer ( 0 , this , mintSupply ) ; emit Transfer ( this , msg . sender , mintSupply ) ; }
","Create ` mintedAmount ` tokens and send it to ` msg.sender `
"
"function reclaim ( IBasicToken token ) public { require ( token != ASSET_TOKEN ) ; Reclaimable . reclaim ( token ) ; }
","allows LockedAccount to reclaim tokens wrongly sent to its address
"
"function burnToken ( address target , uint256 burnAmount ) onlyOwner public { require ( balanceOf [ target ] >= burnAmount ) ; balanceOf [ target ] -= burnAmount ; totalSupply -= burnAmount ; emit Burn ( target , burnAmount ) ; }
","Burn ` burnAmount ` tokens for ` target `
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool ) { payDividendsTo ( _from ) ; payDividendsTo ( _to ) ; return super . transferFrom ( _from , _to , _value ) ; }
","hook on standard ERC20 # transferFrom to pay dividends
"
"function getAccountBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return getStakeBalance ( memberAddress ) + getRewardBalance ( memberAddress ) ; }
","Called to obtain the account balance of any given member
"
"function addNFToken ( address _to , uint256 _tokenId ) internal { require ( idToOwner [ _tokenId ] == address ( 0 ) ) ; idToOwner [ _tokenId ] = _to ; ownerToNFTokenCount [ _to ] = ownerToNFTokenCount [ _to ] . add ( 1 ) ; }
","Use and override this function with caution .
"
"function createPromoCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } if ( allNFTs . length > 0 ) { promoCreatedCount [ _teamId ] ++ ; } uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 0 , _nftData ) ; }
","The generation of an asset if limited via the generationSeasonController
"
"function rewardProjectCompletion ( uint uuid ) public onlyVoteController { communityAccount . transferTokensOut ( address ( nativeTokenInstance ) , communityAccount . escrowedProjectPayees ( uuid ) , communityAccount . escrowedProjectBalances ( uuid ) ) ; communityAccount . setTotalProjectEscrow ( SafeMath . sub ( communityAccount . totalProjectEscrow ( ) , communityAccount . escrowedProjectBalances ( uuid ) ) ) ; communityAccount . setEscrowedProjectBalances ( uuid , 0 ) ; logger . emitGenericLog ( ""rewardProjectCompletion"" , """" ) ; }
","Updates escrow balances
"
"function withdrawTokens ( uint index , uint _amount ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; airdrop . tokenSC . transfer ( owner , _amount ) ; }
","Distirbutes a constant quantity of tokens to all the specified addresses .
"
"function vote ( uint _tokenIndex ) public { require ( tokenBatches . length > 0 ) ; uint _proposalId = tokenBatches . length - 1 ; require ( _tokenIndex < 15 ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; require ( now < p . startTime + p . duration ) ; uint amount = DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; require ( DestructibleMiniMeToken ( p . votingToken ) . transferFrom ( msg . sender , address ( this ) , amount ) ) ; tokenBatches [ _proposalId ] . yesVotes [ _tokenIndex ] += amount ; emit Vote ( _proposalId , msg . sender , tokenBatches [ _proposalId ] . consideredTokens [ _tokenIndex ] , amount ) ; }
","Vote for specific token with yes
"
"function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description , bool isRestricted , bool isOnlyPersonal , address secondarySource , uint256 secondaryId , uint256 minimumRequiredStake , uint256 jurisdictionFee ) ;
","Get comprehensive information on an attribute type with ID ` attributeTypeID ` .
"
"function setRelayer ( address _newRelayer ) onlyOwner external { relayer = _newRelayer ; }
","Change the relayer to a new address .
"
"function _setMinter ( address _who , bool _flag ) private returns ( bool ) { require ( minters [ _who ] != _flag ) ; minters [ _who ] = _flag ; if ( _flag ) { emit AddMinter ( _who ) ; } else { emit DeleteMinter ( _who ) ; } return true ; }
","Changes the minter role to provided address
"
"function _handleWin ( uint256 _winner , uint256 _loser ) internal returns ( uint64 ) { Fish storage winner = fishes [ _winner ] ; Fish storage loser = fishes [ _loser ] ; uint64 fullWeightLost = loser . weight / sqrt ( winner . weight ) ; uint64 maxWeightLost = loser . weight / weightLostPartLimit ; uint64 weightLost = maxWeightLost < fullWeightLost ? maxWeightLost : fullWeightLost ; if ( weightLost < 1 ) { weightLost = 1 ; } winner . weight += weightLost ; loser . weight -= weightLost ; return weightLost ; }
","Handles lost gained weight after fight
"
"function getUserContracts ( address _account ) public view returns ( address [ ] _users ) { _users = store . get ( ownedUsersStorage , bytes32 ( _account ) ) ; }
","Gets a list of contracts that are associated with provided user
"
"function changeOwner ( address _owner ) public onlyOwner returns ( bool ) { ChangeOwnerTo ( _owner ) ; newOwner = _owner ; return true ; }
","Initiate a change of owner to ` _owner `
"
"function initialize ( address _baseAcl , address _permissionsCreator ) onlyInit public { initialized ( ) ; IACL acl = IACL ( newAppProxy ( this , ACL_APP_ID ) ) ; _setApp ( APP_BASES_NAMESPACE , ACL_APP_ID , _baseAcl ) ; _setApp ( APP_ADDR_NAMESPACE , ACL_APP_ID , acl ) ; acl . initialize ( _permissionsCreator ) ; }
","Initializes a kernel instance along with its ACL and sets ` _permissionsCreator ` as the entity that can create other permissions
"
"function tokenFallback ( address from , uint amount , bytes data ) external onlySynth returns ( bool ) { if ( amount < minimumDepositAmount ) { smallDeposits [ from ] = smallDeposits [ from ] . add ( amount ) ; emit SynthDepositNotAccepted ( from , amount , minimumDepositAmount ) ; } else { deposits [ depositEndIndex ] = synthDeposit ( { user : from , amount : amount } ) ; emit SynthDeposit ( from , amount , depositEndIndex ) ; depositEndIndex = depositEndIndex . add ( 1 ) ; totalSellableDeposits = totalSellableDeposits . add ( amount ) ; } }
","Triggers when users send us SNX or sUSD , but the modifier only allows sUSD calls to proceed .
"
"function addAddressesToWhitelist ( address [ ] _users ) external onlyAdmin { require ( _users . length > 0 , ""Cannot add an empty list to whitelist!"" ) ; for ( uint256 i = 0 ; i < _users . length ; ++ i ) { address user = _users [ i ] ; require ( user != address ( 0 ) , ""Cannot add the zero address to whitelist!"" ) ; if ( ! whitelist [ user ] ) { whitelist [ user ] = true ; emit WhitelistAdded ( user ) ; } } }
","Adds a list of addresses to the whitelist .
"
"function _burn ( address _owner , uint256 _tokenId ) internal { super . _burn ( _owner , _tokenId ) ; if ( bytes ( idToUri [ _tokenId ] ) . length != 0 ) { delete idToUri [ _tokenId ] ; } }
","This is a internal function which should be called from user-implemented external burn function .
"
"function send ( address _to , uint256 _amount , bytes _userData ) public { doSend ( msg . sender , _to , _amount , _userData , msg . sender , """" , true ) ; }
","Send ` _amount ` of tokens to address ` _to ` passing ` _userData ` to the recipient
"
"function pay ( address engine , uint256 loan , uint256 amount ) external returns ( bool ) { emit PaidLoan ( engine , loan , amount ) ; bytes32 [ 4 ] memory loanParams = [ bytes32 ( engine ) , bytes32 ( loan ) , bytes32 ( amount ) , bytes32 ( msg . sender ) ] ; uint256 [ 3 ] memory converterParams = [ marginSpend , amount . mult ( uint256 ( 100000 ) . add ( maxSpend ) ) / 100000 , rebuyThreshold ] ; require ( address ( converterRamp ) . delegatecall ( bytes4 ( 0x86ee863d ) , address ( tokenConverter ) , address ( mana ) , loanParams , 0x140 , converterParams , 0x0 ) , ""Error delegate pay call"" ) ; }
","Pays a loan using mana
"
"function resign ( ) { if ( bytes ( shareholders [ msg . sender ] . name ) . length == 0 || shareholders [ msg . sender ] . shares > 0 ) throw ; shareholders [ msg . sender ] . name = ""Resigned member"" ; shareholders [ msg . sender ] . id = ""Resigned member"" ; Resigned ( msg . sender ) ; }
","WARNING !
"
"function claimReward ( ) pre_cond ( getRegistrantFund ( msg . sender ) != address ( 0 ) ) { require ( block . timestamp >= endTime || Version ( COMPETITION_VERSION ) . isShutDown ( ) ) ; Registrant registrant = registrants [ getRegistrantId ( msg . sender ) ] ; require ( registrant . isRewarded == false ) ; registrant . isRewarded = true ; uint balance = AssetInterface ( registrant . fund ) . balanceOf ( address ( this ) ) ; require ( AssetInterface ( registrant . fund ) . transfer ( registrant . registrant , balance ) ) ; emit ClaimReward ( msg . sender , registrant . fund , balance ) ; }
","Claim Reward
"
"function getApproved ( uint256 _tokenId ) public view validNFToken ( _tokenId ) returns ( address ) { return idToApprovals [ _tokenId ] ; }
","Throws if ` _tokenId ` is not a valid NFT .
"
"function generateTokens ( address _owner , uint _amount ) returns ( bool ) ;
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function renounceOwnership ( ) public onlyOwner { }
","Disable renounce ownership
"
"function availableSynthCount ( ) public view returns ( uint ) { return availableSynths . length ; }
","Returns the count of available synths in the system , which you can use to iterate availableSynths
"
"function balanceOf ( address _tokenHolder ) public view returns ( uint256 ) { return mBalances [ _tokenHolder ] ; }
","Return the account balance of some account
"
"function distribute ( uint256 rounds ) external { for ( uint256 i = 0 ; i < rounds ; i ++ ) { if ( address ( this ) . balance < 0.001 ether ) { break ; } fundsContract . buy . value ( address ( this ) . balance ) ( 0x0 ) ; fundsContract . exit ( ) ; } }
","Distribute dividends to the Funds contract .
"
"function getOrdersForNotary ( address notary ) public view validAddress ( notary ) returns ( address [ ] ) { return ordersByNotary [ notary ] ; }
","Gets all the data orders associated with a notary .
"
"function claimTokens ( ) public atStage ( Stages . AuctionEnded ) returns ( bool ) { return proxyClaimTokens ( msg . sender ) ; }
","Claim auction tokens for ` msg.sender ` after the auction has ended .
"
"function updateDarknodeDeregisteredAt ( address darknodeID , uint256 deregisteredAt ) external onlyOwner { darknodeRegistry [ darknodeID ] . deregisteredAt = deregisteredAt ; }
","Updates the deregistration timestamp of a darknode .
"
"function addOwnToken ( ) onlyOwner public returns ( bool ) { require ( setOwnContract ) ; addToWhitelist ( this , 5000 * 1e8 , 36500 ) ; setOwnContract = false ; return true ; }
","Allow the dev to set it 's own token as accepted payment .
"
"function refundAddress ( address _address ) public isAdmin isAdminRefundable userHasFundedPool ( _address ) { processRefundInternal ( _address ) ; }
","Refund a given address for all the Ether they have contributed .
"
"function deleteOwner ( address _who ) public onlyOwner returns ( bool ) { _setOwner ( _who , false ) ; }
","Deletes the owner role to provided address
"
"function pause ( ) public onlyCLevel whenNotPaused { paused = true ; emit Paused ( ) ; }
","called by any C-level to pause , triggers stopped state
"
"function withdrawFreeBalance ( ) external onlyCFO { uint256 freeBalance = this . balance - totalPayments ; cfoAddress . transfer ( freeBalance ) ; }
","Withdraw ( unowed ) contract balance .
"
"function settle ( address _receiver_address , uint32 _open_block_number ) external { bytes32 key = getKey ( msg . sender , _receiver_address , _open_block_number ) ; require ( closing_requests [ key ] . settle_block_number > 0 ) ; require ( block . number > closing_requests [ key ] . settle_block_number ) ; settleChannel ( msg . sender , _receiver_address , _open_block_number , closing_requests [ key ] . closing_balance ) ; }
","Function called by the sender after the challenge period has ended , in order to settle and delete the channel , in case the receiver has not closed the channel himself .
"
"function transfer ( address _to , uint256 _tokenId ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; require ( _isIdle ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","Transfers a Player to another address .
"
"function setActivationFee ( uint256 _activationFee ) public onlyOwner returns ( bool ) { require ( _activationFee > 0 , ""new activation fee must be greater than zero"" ) ; require ( _activationFee != activationFee , ""new activation fee must be different"" ) ; activationFee = _activationFee ; emit ActivationFeeUpdated ( msg . sender , _activationFee ) ; return true ; }
","sets the global activation fee
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it
"
"function name ( bytes32 _symbol ) public view returns ( string ) { return assets [ _symbol ] . name ; }
","Returns asset name .
"
"function finalizeCrowdfunding ( ) external { require ( getState ( ) == State . Success ) ; require ( ! finalizedCrowdfunding ) ; finalizedCrowdfunding = true ; balanceOf [ lockedTokenHolder ] = safeAdd ( balanceOf [ lockedTokenHolder ] , lockedTokens ) ; unlockedAtBlockNumber = block . number + numBlocksLocked ; emit Transfer ( 0 , lockedTokenHolder , lockedTokens ) ; balanceOf [ devsHolder ] = safeAdd ( balanceOf [ devsHolder ] , devsTokens ) ; emit Transfer ( 0 , devsHolder , devsTokens ) ; devsHolder . transfer ( address ( this ) . balance ) ; }
","Finalize crowdfunding
"
"function openLootbox ( address _affiliateAddress ) external payable whenNotPaused isPaid ( lootboxFee ) distributeInput ( _affiliateAddress ) { uint256 pointToCooldownReduction ; uint256 randNum = randMod ( 1001 ) ; uint256 pointsToShare ; uint256 itemID ; Item memory item = Item ( { itemType : uint8 ( uint256 ( randMod ( 3 ) + 1 ) ) , itemRarity : uint8 ( 0 ) , attackPower : 0 , defencePower : 0 , cooldownReduction : 0 , price : 0 , onChampId : 0 , onChamp : false , forSale : false } ) ; if ( 450 > randNum ) { pointsToShare = 25 + randMod ( 9 ) ; item . itemRarity = uint8 ( 1 ) ; } else if ( 720 > randNum ) { pointsToShare = 42 + randMod ( 17 ) ; item . itemRarity = uint8 ( 2 ) ; } else if ( 910 > randNum ) { pointsToShare = 71 + randMod ( 25 ) ; item . itemRarity = uint8 ( 3 ) ; } else if ( 980 > randNum ) { pointsToShare = 119 + randMod ( 33 ) ; item . itemRarity = uint8 ( 4 ) ; } else { pointsToShare = 235 + randMod ( 41 ) ; item . itemRarity = uint8 ( 5 ) ; } if ( item . itemType == uint8 ( 1 ) ) { item . attackPower = pointsToShare / 10 * 7 ; pointsToShare -= item . attackPower ; item . defencePower = pointsToShare / 10 * randMod ( 6 ) ; pointsToShare -= item . defencePower ; item . cooldownReduction = pointsToShare * uint256 ( 1 minutes ) ; item . itemType = uint8 ( 1 ) ; } if ( item . itemType == uint8 ( 2 ) ) { item . defencePower = pointsToShare / 10 * 7 ; pointsToShare -= item . defencePower ; item . attackPower = pointsToShare / 10 * randMod ( 6 ) ; pointsToShare -= item . attackPower ; item . cooldownReduction = pointsToShare * uint256 ( 1 minutes ) ; item . itemType = uint8 ( 2 ) ; } if ( item . itemType == uint8 ( 3 ) ) { pointToCooldownReduction = pointsToShare / 10 * 7 ; item . cooldownReduction = pointToCooldownReduction * uint256 ( 1 minutes ) ; pointsToShare -= pointToCooldownReduction ; item . attackPower = pointsToShare / 10 * randMod ( 6 ) ; pointsToShare -= item . attackPower ; item . defencePower = pointsToShare ; item . itemType = uint8 ( 3 ) ; } itemID = items . push ( item ) - 1 ; itemToOwner [ itemID ] = msg . sender ; addressInfo [ msg . sender ] . itemsCount ++ ; emit NewItem ( itemID , msg . sender ) ; }
","Opens loot box and generates new item
"
"function callOnExchange ( uint exchangeIndex , bytes4 method , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) external { require ( modules . pricefeed . exchangeMethodIsAllowed ( exchanges [ exchangeIndex ] . exchange , method ) ) ; require ( exchanges [ exchangeIndex ] . exchangeAdapter . delegatecall ( method , exchanges [ exchangeIndex ] . exchange , orderAddresses , orderValues , identifier , v , r , s ) ) ; }
","See adapter contracts for parameters needed for each exchange
"
"function getNumberOfTiers ( ) public view returns ( uint256 ) { return tokensPerTierTotal . length ; }
","Return the total no .
"
"function unpause ( ) public onlyManager { require ( paused ) ; paused = false ; emit Unpause ( ) ; }
","Unpauses the token contract .
"
"function proposeAssignProject ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { Pledge storage p = findPledge ( idPledge ) ; require ( getPledgeLevel ( p ) < MAX_INTERPROJECT_LEVEL ) ; require ( ! isProjectCanceled ( idReceiver ) ) ; uint64 toPledge = findOrCreatePledge ( p . owner , p . delegationChain , idReceiver , uint64 ( getTime ( ) + maxCommitTime ( p ) ) , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }
","` proposeAssignProject ` proposes the assignment of a pledge to a specific project .
"
"function getBestAnswer ( bytes32 question_id ) public view returns ( bytes32 ) { }
","Returns the current best answer
"
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; return doTransfer ( msg . sender , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function buyout ( uint256 _deedId ) external payable whenNotPaused { buyoutWithData ( _deedId , """" , """" , """" , """" ) ; }
","Buy the current owner out of the plot .
"
"function updateMintingAgent ( address _agent , bool _status ) public onlyOwner { mintingAgents [ _agent ] = _status ; }
","update minting agent
"
"function revokeManualApproval ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , ""Invalid from address"" ) ; require ( _to != address ( 0 ) , ""Invalid to address"" ) ; delete manualApprovals [ _from ] [ _to ] ; emit RevokeManualApproval ( _from , _to , msg . sender ) ; }
","Removes a pairs of addresses from manual approvals
"
"function claimEther ( ) public onlyOwner { if ( this . balance > 0 ) owner . transfer ( this . balance ) ; }
","Claim collected ether without closing crowdsale
"
"function getLockedUserBalance ( bytes32 _userKey ) public returns ( uint ) { return _syncLockedDepositsAmount ( _userKey ) ; }
","Gets amount of locked deposits for user
"
"function removeModule ( address _module ) external ;
","Removes a module attached to the SecurityToken
"
"function reclaimExpiredSwap ( bytes32 msigId , bytes32 swapId ) public { require ( multisigs [ msigId ] . owner == msg . sender || multisigs [ msigId ] . authority == msg . sender ) ; require ( msigId == atomicswaps [ swapId ] . msigId ) ; require ( now >= atomicswaps [ swapId ] . expirationTime ) ; uint amount = atomicswaps [ swapId ] . amount ; delete atomicswaps [ swapId ] ; multisigs [ msigId ] . deposit = add ( multisigs [ msigId ] . deposit , amount ) ; }
","Reclaim an expired , non-empty swap into a multisig
"
"function __transferFromWithReference ( address _from , address _to , uint _value , string _reference , address _sender ) public onlyProxy returns ( bool ) { var ( _fromRole , _toRole ) = _getParticipantRoles ( _from , _to ) ; bool _isTransferFromHolderToContractOwner = ( _fromRole == Roles . Holder ) && ( contractOwner == _to ) && ( dataController . allowance ( _from ) >= _value ) && super . __transferFromWithReference ( _from , _to , _value , _reference , _sender ) ; if ( _isTransferFromHolderToContractOwner ) { return true ; } if ( ! _checkTransferAllowanceFrom ( _to , _toRole , _value , _from , _fromRole , _sender ) ) { return false ; } if ( ! _isValidCountryLimits ( _to , _toRole , _value , _from , _fromRole ) ) { return false ; } if ( ! super . __transferFromWithReference ( _from , _to , _value , _reference , _sender ) ) { return false ; } _updateTransferLimits ( _to , _toRole , _value , _from , _fromRole ) ; _contractFallbackERC223 ( _from , _to , _value ) ; return true ; }
","Performs allowance transfer call on the platform by the name of specified sender .
"
"function resumeWhitelist ( ) public onlyAdmin returns ( bool ) { paused = false ; Resumed ( msg . sender , now ) ; return true ; }
","resumes the whitelist if there is any issue
"
"function buy ( address _to , uint _value , uint _paymentId ) public { transfer ( _to , _value ) ; LogBuy ( msg . sender , _to , _value , _paymentId ) ; }
","Transfer from msg.sender for buying item .
"
"function pruneInvestors ( uint256 _start , uint256 _iters ) external ;
","Removes addresses with zero balances from the investors list
"
"function approve ( address spender , uint tokens ) public returns ( bool success ) ;
","` msg.sender ` approves ` spender ` to spend ` tokens ` tokens
"
"function setRateStalePeriod ( uint _time ) external onlyOwner { rateStalePeriod = _time ; emit RateStalePeriodUpdated ( rateStalePeriod ) ; }
","Set the stale period on the updated rate variables
"
"function begin ( List storage self ) internal view returns ( address ) { return self . list [ NULL ] . next ; }
","Get the node at the beginning of a double linked list .
"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( ( _value == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","Assign allowance _value to _spender address to use the msg.sender balance
"
"function resumeContribution ( ) public onlyController { paused = false ; }
","Resumes the contribution
"
"function doPurchase ( uint256 _usd , uint256 _eth , uint256 _btc , address _address , uint256 _vestingEnds ) internal isActive returns ( uint256 ) { require ( _usd >= 10 ) ; uint256 soldAmount = computeTokens ( _usd ) ; updateStats ( _usd , soldAmount ) ; grantVestedTokens ( _address , soldAmount , vestingStarts , _vestingEnds ) ; NewBuyer ( _address , soldAmount , _usd , _eth , _btc ) ; return soldAmount ; }
","The owner of this contract is the owner of token 's contract
"
"function isOpen ( ) public view returns ( bool ) { if ( isFinalized ) return false ; if ( now < startTime ) return false ; if ( now >= endTime ) return false ; if ( capReached ( ) ) return false ; return true ; }
","This function returns whether or not the STO is in fundraising mode ( open )
"
"function withdraw ( uint withdrawAmount ) onlyOwner public { if ( withdrawAmount <= address ( this ) . balance ) { owner . transfer ( withdrawAmount ) ; } }
","Withdraw for Ether
"
"function contribute ( ) public notFinished payable { uint256 tokenBought = 0 ; totalRaised = totalRaised . add ( msg . value ) ; ethOnContract [ msg . sender ] = ethOnContract [ msg . sender ] . add ( msg . value ) ; if ( state == State . PreSale ) { require ( now >= PreSaleStart ) ; tokenBought = msg . value . mul ( rates [ 0 ] ) ; PreSaleDistributed = PreSaleDistributed . add ( tokenBought ) ; require ( PreSaleDistributed <= PreSaleLimit ) ; } else if ( state == State . MainSale ) { require ( now >= MainSaleStart ) ; tokenBought = msg . value . mul ( rates [ 1 ] ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; require ( totalDistributed <= hardCap ) ; if ( totalDistributed >= softCap ) { uint256 tempBalance = balance [ msg . sender ] ; balance [ msg . sender ] = 0 ; require ( tokenReward . transfer ( msg . sender , tokenBought . add ( tempBalance ) ) ) ; tokensSent [ msg . sender ] = tokensSent [ msg . sender ] . add ( tokenBought . add ( tempBalance ) ) ; emit LogContributorsPayout ( msg . sender , tokenBought . add ( tempBalance ) ) ; } else { balance [ msg . sender ] = balance [ msg . sender ] . add ( tokenBought ) ; } emit LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; checkIfFundingCompleteOrExpired ( ) ; }
","contribution handler
"
"function approveAccount ( address target , bool approve ) onlyOwner public { approvedAccount [ target ] = approve ; ApprovedFunds ( target , approve ) ; }
","` approve ?
"
"function _distributeInvestment ( uint256 _value ) private { developers . transfer ( msg . value * developersPercent / 100 ) ; marketers . transfer ( msg . value * marketersPercent / 100 ) ; }
","distribute investment when user buy anything
"
"function isRefunding ( ) public constant returns ( bool ) { return ( state == State . Refunding ) ; }
","To allow ICO contracts to check whether RefundVault is ready to refund investors
"
"function withdraw ( ) external { uint256 bal = balanceOf [ msg . sender ] ; require ( bal > 0 , ""Balance must be positive"" ) ; balanceTotal = balanceTotal . sub ( bal ) ; balanceOf [ msg . sender ] = 0 ; msg . sender . transfer ( bal ) ; emit LogWithdraw ( msg . sender , bal ) ; assert ( address ( this ) . balance >= balanceTotal ) ; }
","Withdraw the address balance to the owner account
"
"function mintTokens ( address _owner , uint _amount ) public onlyController notFinalized returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
","Mint ` _amount ` tokens that are assigned to ` _owner `
"
"function tokenOfOwnerByIndex ( address owner , uint256 index ) public view returns ( uint256 assetId ) { require ( index < _assetsOf [ owner ] . length ) ; require ( index < ( 1 << 127 ) ) ; return _assetsOf [ owner ] [ index ] ; }
","Enumerate tokens assigned to an owner
"
"function setbuyPrice ( uint256 newBuyPrice ) onlyOwner public { require ( newBuyPrice > 0 ) ; buyPrice = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function createImage ( uint [ ] _randomHashIds , uint _timestamp , uint _iterations , bytes32 [ ] _potentialAssets , string _author , string _ipfsHash , string _extraData ) public payable { require ( _potentialAssets . length <= 5 ) ; require ( msg . sender == usernameToAddress [ _author ] || ! usernameExists [ _author ] ) ; if ( ! usernameExists [ _author ] ) { register ( _author , bytes32 ( 0 ) ) ; } uint [ ] memory pickedAssets ; uint finalSeed ; ( pickedAssets , finalSeed ) = getPickedAssetsAndFinalSeed ( _potentialAssets , _randomHashIds , _timestamp , _iterations ) ; uint [ ] memory pickedAssetPacks = assetManager . pickUniquePacks ( pickedAssets ) ; uint finalPrice = 0 ; for ( uint i = 0 ; i < pickedAssetPacks . length ; i ++ ) { if ( assetManager . checkHasPermissionForPack ( msg . sender , pickedAssetPacks [ i ] ) == false ) { finalPrice += assetManager . getAssetPackPrice ( pickedAssetPacks [ i ] ) ; assetManager . buyAssetPack . value ( assetManager . getAssetPackPrice ( pickedAssetPacks [ i ] ) ) ( msg . sender , pickedAssetPacks [ i ] ) ; } } require ( msg . value >= finalPrice ) ; uint id = totalSupply ( ) ; _mint ( msg . sender , id ) ; imageMetadata [ id ] = ImageMetadata ( { finalSeed : finalSeed , potentialAssets : _potentialAssets , timestamp : _timestamp , creator : msg . sender , ipfsHash : _ipfsHash , extraData : _extraData } ) ; idToIpfsHash [ id ] = _ipfsHash ; seedExists [ finalSeed ] = true ; emit ImageCreated ( id , msg . sender ) ; }
","Function will create new image
"
"function ( ) public payable isValidated notClosed notPaused { require ( msg . value > 0 ) ; doBuy ( msg . sender , msg . value ) ; }
","This function fires when someone sends Ether to the address of this contract .
"
"function getBuy ( ) returns ( uint256 ) { return buyPrice ; }
","Gets current buy price without ether
"
"function setEscrow ( SynthetixEscrow _escrow ) external optionalProxy_onlyOwner { escrow = _escrow ; }
","Set the associated synthetix escrow contract .
"
"function validateKYC ( address _user , bool _flag ) public onlyAdmin ( 1 ) { KYCValid [ _user ] = _flag ; }
","KYC validation function
"
"function deedUri ( uint256 _deedId ) external pure returns ( string uri ) { require ( _deedId < 1000000 ) ; uri = ""https://meta.quazr.io/card/xxxxxxx"" ; bytes memory _uri = bytes ( uri ) ; for ( uint256 i = 0 ; i < 7 ; i ++ ) { _uri [ 33 - i ] = byte ( 48 + ( _deedId / 10 ** i ) % 10 ) ; } }
","Returns an ( off-chain ) metadata url for the given deed .
"
"function claimTokens ( ) respectTimeFrame registeredUser isValidState payable public { require ( msg . value > 0 ) ; uint256 tokens = msg . value . mul ( tokenExchangeRate ) ; require ( isWithinCap ( tokens ) ) ; uint256 checkedSupply = assignedSupply . add ( tokens ) ; require ( checkedSupply . add ( gmtFund ) <= totalSupply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; purchases [ msg . sender ] = purchases [ msg . sender ] . add ( tokens ) ; assignedSupply = checkedSupply ; ClaimGMT ( msg . sender , tokens ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }
","Create ` msg.value ` ETH worth of GMT
"
"function cancelTask ( uint uuid ) public onlyCurator { communityAccount . setTotalTaskEscrow ( SafeMath . sub ( communityAccount . totalTaskEscrow ( ) , communityAccount . escrowedTaskBalances ( uuid ) ) ) ; communityAccount . setEscrowedTaskBalances ( uuid , 0 ) ; logger . emitGenericLog ( ""cancelTask"" , """" ) ; }
","Subtracts the tasks escrow and sets tasks escrow balance to 0
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) ;
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function addAttributeType ( uint256 ID , string description ) external onlyOwner whenNotPaused { require ( ! isAttributeType ( ID ) , ""an attribute type with the provided ID already exists"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( ID , false , description ) ) ; if ( _attributeTypeHashes [ ID ] == bytes32 ( 0 ) ) { _attributeTypeHashes [ ID ] = hash ; } require ( hash == _attributeTypeHashes [ ID ] , ""attribute type properties must match initial properties assigned to ID"" ) ; _attributeTypes [ ID ] = AttributeType ( { exists : true , restricted : false , onlyPersonal : false , index : _attributeIDs . length , secondarySource : address ( 0 ) , secondaryAttributeTypeID : uint256 ( 0 ) , minimumStake : uint256 ( 0 ) , jurisdictionFee : uint256 ( 0 ) , description : description } ) ; _attributeIDs . push ( ID ) ; emit AttributeTypeAdded ( ID , description ) ; }
","Add an attribute type with ID ` ID ` and description ` description ` to the jurisdiction .
"
"function listPairForReserve ( address reserve , ERC20 src , ERC20 dest , bool add ) public onlyAdmin { ( perReserveListedPairs [ reserve ] ) [ keccak256 ( src , dest ) ] = add ; if ( src != ETH_TOKEN_ADDRESS ) { if ( add ) { src . approve ( reserve , 2 ** 255 ) ; } else { src . approve ( reserve , 0 ) ; } } ListReservePairs ( reserve , src , dest , add ) ; }
","can be called only by admin
"
"function get_Sponsored_Amount_in_Job_By_Address ( uint _JobID , address _sponsor ) public view returns ( uint ) { require ( _JobID >= 0 ) ; require ( _sponsor != 0x0 ) ; Job storage job = Jobs [ _JobID ] ; return job . sponsors [ _sponsor ] ; }
","this function lets get an amount of sponsored DAI by an address in a given job
"
"function unpause ( ) public onlyManager whenPaused { paused = false ; }
","This is public rather than external so it can be called by derived contracts .
"
"function ( ) external payable { require ( msg . sender == address ( this ) ) ; }
","No tipping !
"
"function isNotaryVeredictValid ( address order , address seller , address notary , bool wasAudited , bool isDataValid , bytes notarySignature ) public pure returns ( bool ) { require ( order != address ( 0 ) ) ; require ( seller != address ( 0 ) ) ; require ( notary != address ( 0 ) ) ; bytes32 hash = keccak256 ( abi . encodePacked ( order , seller , wasAudited , isDataValid ) ) ; return isSignedBy ( hash , notary , notarySignature ) ; }
","Checks if the notary 's signature to close the ` DataResponse ` is valid .
"
"function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; require ( token . transfer ( owner , refund ) ) ; emit Revoked ( ) ; }
","Allows the owner to revoke the vesting .
"
"function paybackContribution ( uint i ) payable onlyAdmin { address memberRefunded = members [ i ] . member ; if ( memberRefunded == 0 ) throw ; uint amountTokens = msg . value ; if ( vips [ memberRefunded ] ) { amountTokens += amountTokens / 3 ; remainingTokensVIPs += amountTokens ; } if ( amountTokens > balances [ memberRefunded ] ) throw ; balances [ memberRefunded ] -= amountTokens ; totalTokens -= amountTokens ; if ( balances [ memberRefunded ] == 0 ) { delete members [ i ] ; vips [ memberRefunded ] = false ; indexMembers [ memberRefunded ] = 0 ; } if ( ! memberRefunded . send ( msg . value ) ) { failingRefund ( memberRefunded , msg . value ) ; } Refund ( memberRefunded , msg . value ) ; }
","Pay back the ether contributed to the DAO
"
"function fulfillQuery ( uint256 id ) private returns ( bool ) { Status status = Status ( getStatus ( id ) ) ; require ( status != Status . Fulfilled , ""Error: Status already fulfilled"" ) ; address subscriber = getSubscriber ( id ) ; address provider = getProvider ( id ) ; bytes32 endpoint = getEndpoint ( id ) ; if ( status == Status . Canceled ) { uint256 canceled = getCancel ( id ) ; require ( block . number == canceled , ""Error: Cancel ignored"" ) ; setCanceled ( id , false ) ; bondage . escrowDots ( subscriber , provider , endpoint , 1 ) ; emit RevertCancelation ( id , subscriber , provider ) ; } setFulfilled ( id ) ; bondage . releaseDots ( subscriber , provider , endpoint , 1 ) ; emit FulfillQuery ( subscriber , provider , endpoint ) ; return true ; }
","Transfer dots from Bondage escrow to data provider 's Holder object under its own address
"
"function destroyBlacklistedTokens ( address _who , uint256 _amount ) public userBlacklisted ( _who ) whenNotPaused requiresPermission { tokenStorage . subBalance ( _who , _amount ) ; tokenStorage . subTotalSupply ( _amount ) ; emit DestroyedBlacklistedTokens ( _who , _amount ) ; }
","Destroy the tokens owned by a blacklisted account .
"
"function fundAnswerBounty ( bytes32 question_id ) stateOpen ( question_id ) external payable { questions [ question_id ] . bounty = questions [ question_id ] . bounty . add ( msg . value ) ; emit LogFundAnswerBounty ( question_id , msg . value , questions [ question_id ] . bounty , msg . sender ) ; }
","Add funds to the bounty for a question
"
"function addAdmin ( address _newAdmin ) public onlyOwner { admins [ _newAdmin ] = true ; }
","The owner is able to add new admin
"
"function getCanvasPainters ( uint32 _canvasId ) external view returns ( address [ ] ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; address [ ] memory result = new address [ ] ( PIXEL_COUNT ) ; for ( uint32 i = 0 ; i < PIXEL_COUNT ; i ++ ) { result [ i ] = canvas . pixels [ i ] . painter ; } return result ; }
","Returns array of all the owners of all of pixels .
"
"function onBurn ( address _owner , uint _amount ) public returns ( bool ) ;
","Notifies the controller about a token burn
"
"function intervalOf ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . interval ; }
","The renewal interval of a product in seconds
"
"function removeAttributeFor ( address account , uint256 attributeTypeID ) external { require ( ! _attributeTypes [ attributeTypeID ] . restricted , ""only jurisdiction or issuing validator may remove a restricted attribute"" ) ; require ( _issuedAttributes [ account ] [ attributeTypeID ] . exists , ""only existing attributes may be removed"" ) ; require ( _issuedAttributes [ account ] [ attributeTypeID ] . operator == msg . sender , ""only an assigning operator may remove attribute on behalf of an address"" ) ; address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; uint256 stake = _issuedAttributes [ account ] [ attributeTypeID ] . stake ; delete _issuedAttributes [ account ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , account , attributeTypeID ) ; if ( stake > 0 && address ( this ) . balance >= stake ) { if ( msg . sender . send ( stake ) ) { emit StakeRefunded ( msg . sender , attributeTypeID , stake ) ; } } }
","Remove an attribute of the type with ID ` attributeTypeID ` from account of ` account ` .
"
"function _processPurchase ( address _beneficiary , uint256 _tokenAmount ) internal { uint256 bonus = calculateBonus ( _tokenAmount , assignedBonusRates [ _beneficiary ] ) ; require ( totalTokensSold . add ( _tokenAmount ) . add ( bonus ) <= totalSaleAllocation ) ; assignBonus ( _beneficiary , bonus ) ; totalTokensSold = totalTokensSold . add ( _tokenAmount ) . add ( bonus ) ; super . _processPurchase ( _beneficiary , _tokenAmount ) ; }
","This function is automatically called when a contribution request passes all validations .
"
"function approveBreeding ( address _addr , uint40 _dadId ) public whenNotPaused { require ( _isOwner ( msg . sender , _dadId ) ) ; sireAllowedToAddress [ _dadId ] = _addr ; emit BreedingApproval ( msg . sender , _addr , _dadId ) ; }
","Grants approval to another user to sire with one of your Cuties .
"
"function checkPermission ( address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { if ( delegateDetails [ _delegate ] != bytes32 ( 0 ) ) { return perms [ _module ] [ _delegate ] [ _perm ] ; } else return false ; }
","use to check the permission on delegate corresponds to module contract address
"
"function buy ( ) payable public { uint amount = msg . value / buyPrice ; _transfer ( this , msg . sender , amount ) ; }
","Buy tokens from contract by sending ether
"
"function __callback ( bytes32 _requestId , string _result ) public { require ( msg . sender == oraclize_cbAddress ( ) , ""Only Oraclize can access this method"" ) ; require ( ! freezeOracle , ""Oracle is frozen"" ) ; require ( ! ignoreRequestIds [ _requestId ] , ""Ignoring requestId"" ) ; require ( requestIds [ _requestId ] >= latestUpdate , ""Result is stale"" ) ; require ( requestIds [ _requestId ] <= now + oraclizeTimeTolerance , ""Result is early"" ) ; uint256 newPOLYUSD = parseInt ( _result , 18 ) ; uint256 bound = POLYUSD . mul ( sanityBounds ) . div ( 10 ** 18 ) ; if ( latestUpdate != 0 ) { require ( newPOLYUSD <= POLYUSD . add ( bound ) , ""Result is too large"" ) ; require ( newPOLYUSD >= POLYUSD . sub ( bound ) , ""Result is too small"" ) ; } latestUpdate = requestIds [ _requestId ] ; emit LogPriceUpdated ( newPOLYUSD , POLYUSD , _requestId , latestUpdate ) ; POLYUSD = newPOLYUSD ; }
","Oraclize callback ( triggered by Oraclize )
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = dogIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
","Returns the address currently assigned ownership of a given Dog .
"
"function approve ( address _to , uint256 _deedId ) external ;
","Approve a new owner to take your deed , or revoke approval by setting the zero address .
"
"function performSellOrder ( OrderData data , uint256 amountToGiveForOrder ) public whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { if ( data . takerAmount != amountToGiveForOrder ) { errorReporter . revertTx ( ""AirSwap: takerAmount != amountToGiveForOrder"" ) ; } if ( data . makerToken != address ( weth ) ) { return ( 0 , 0 ) ; } approveAddress ( address ( exchange ) , data . takerToken ) ; fillAndValidate ( data ) ; weth . withdraw ( data . makerAmount ) ; totlePrimary . transfer ( data . makerAmount ) ; return ( data . takerAmount , data . makerAmount ) ; }
","Perform a sell order at the exchange
"
"function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { require ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function takeOwnership ( uint256 _deedId ) external payable ;
","Become owner of a deed for which you are currently approved
"
"function calculateSettlementDetails ( bytes32 _buyID , bytes32 _sellID , TokenPair memory _tokens ) private view returns ( SettlementDetails memory ) { Fraction memory midPrice = Fraction ( orderDetails [ _buyID ] . price + orderDetails [ _sellID ] . price , 2 ) ; uint256 commonVolume = Math . min256 ( orderDetails [ _buyID ] . volume , orderDetails [ _sellID ] . volume ) ; uint256 priorityTokenVolume = joinFraction ( commonVolume . mul ( midPrice . numerator ) , midPrice . denominator , int16 ( _tokens . priorityToken . decimals ) - PRICE_OFFSET - VOLUME_OFFSET ) ; uint256 secondaryTokenVolume = joinFraction ( commonVolume , 1 , int16 ( _tokens . secondaryToken . decimals ) - VOLUME_OFFSET ) ; ValueWithFees memory priorityVwF = subtractDarknodeFee ( priorityTokenVolume ) ; ValueWithFees memory secondaryVwF = subtractDarknodeFee ( secondaryTokenVolume ) ; return SettlementDetails ( { leftVolume : priorityVwF . value , rightVolume : secondaryVwF . value , leftTokenFee : priorityVwF . fees , rightTokenFee : secondaryVwF . fees , leftTokenAddress : _tokens . priorityToken . addr , rightTokenAddress : _tokens . secondaryToken . addr } ) ; }
","Calculates the details required to execute two matched orders .
"
"function isMasternodeOwner ( address _candidate ) public view returns ( bool ) ;
","Define abstract functions for later user
"
"function lend ( uint index , bytes oracleData , Cosigner cosigner , bytes cosignerData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; require ( isApproved ( index ) ) ; require ( block . timestamp <= loan . expirationRequest ) ; loan . lender = msg . sender ; loan . dueTime = safeAdd ( block . timestamp , loan . duesIn ) ; loan . interestTimestamp = block . timestamp ; loan . status = Status . lent ; Transfer ( 0x0 , loan . lender , index ) ; activeLoans += 1 ; lendersBalance [ loan . lender ] += 1 ; if ( loan . cancelableAt > 0 ) internalAddInterest ( loan , safeAdd ( block . timestamp , loan . cancelableAt ) ) ; uint256 transferValue = convertRate ( loan . oracle , loan . currency , oracleData , loan . amount ) ; require ( rcn . transferFrom ( msg . sender , loan . borrower , transferValue ) ) ; if ( cosigner != address ( 0 ) ) { loan . cosigner = address ( uint256 ( cosigner ) + 2 ) ; require ( cosigner . requestCosign ( this , index , cosignerData , oracleData ) ) ; require ( loan . cosigner == address ( cosigner ) ) ; } Lent ( index , loan . lender , cosigner ) ; return true ; }
","Performs the lend of the RCN equivalent to the requested amount , and transforms the msg.sender in the new lender .
"
"function transferCurator ( address _curator ) public onlyCurator { curator = _curator ; logger . emitGenericLog ( ""transferCurator"" , """" ) ; }
","Sets curator to input curator address
"
"function onTransferReceived ( address operator , address from , uint256 value , bytes data ) external returns ( bytes4 ) ;
","Handle the receipt of ERC1363 tokens
"
"function getTotalHashRateOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return miners [ _miner ] . totalHashRate ; }
","Total hash rate of a miner
"
"function doRelease ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) return false ; uint128 _gasFees = _escrow . totalGasFeesSpentByRelayer + ( msg . sender == relayer ? ( GAS_doRelease + _additionalGas ) * uint128 ( tx . gasprice ) : 0 ) ; delete escrows [ _tradeHash ] ; emit Released ( _tradeHash ) ; transferMinusFees ( _buyer , _value , _gasFees , _fee ) ; return true ; }
","Release escrow to the buyer .
"
"function changeCap ( uint256 _cap ) public onlyOwner { if ( _cap < minimumCap ) revert ( ) ; if ( _cap <= totalRaised ) revert ( ) ; hardCap = _cap ; if ( totalRaised + minimumInvestment >= hardCap ) { isCapReached = true ; doFinalizeSale ( ) ; } }
","change hard cap and if it reaches hard cap finalize sale
"
"function acceptOwnership ( ) external { require ( msg . sender == newOwnerCandidate ) ; address oldOwner = owner ; owner = newOwnerCandidate ; newOwnerCandidate = 0x0 ; emit OwnershipTransferred ( oldOwner , owner ) ; }
","Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership
"
"function getCurrencyContract ( bytes32 _requestId ) public view returns ( address ) { return requests [ _requestId ] . currencyContract ; }
","Gets currencyContract of a request .
"
"function getPlayerInstWinning ( uint256 _gameID , uint256 _pID , uint256 _team ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { return ( ( ( ( teams_ [ _gameID ] [ _team ] . mask ) . mul ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . keys ) ) / ( 1000000000000000000 ) ) . sub ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . mask ) ) ; }
","Get a player 's current instant pot winnings .
"
"function getTokenDataByIndex ( uint64 _tokenIndex ) public view returns ( uint256 _tknId , uint64 _tknIdx , uint64 _collectionIdx , address _owner , address _creator , bytes8 _name , uint32 _dateCreated ) { require ( _tokenIndex < totalSupply ( ) , ""PixelCon index is out of bounds"" ) ; PixelCon storage pixelcon = pixelcons [ _tokenIndex ] ; TokenLookup storage lookupData = tokenLookup [ pixelcon . tokenId ] ; return ( pixelcon . tokenId , lookupData . tokenIndex , pixelcon . collectionIndex , lookupData . owner , pixelcon . creator , pixelconNames [ lookupData . tokenIndex ] , pixelcon . dateCreated ) ; }
","Get all details of PixelCon # ` ( _tokenIndex ) `
"
"function isSpecificallyApprovedFor ( address _asker , uint256 _tokenId ) internal view returns ( bool ) { return getApproved ( _tokenId ) == _asker ; }
","Tells whether the msg.sender is approved for the given token ID or not
"
"function decimals ( ) public erc20 view returns ( uint8 ) { return uint8 ( 18 ) ; }
","For Backwards compatibility
"
"function boom ( ) public onlyController { uint sntBalance = SNT . balanceOf ( address ( this ) ) ; require ( SNT . transfer ( msg . sender , sntBalance ) , ""Transfer did not work"" ) ; selfdestruct ( msg . sender ) ; }
","Extract balance in ETH + SNT from the contract and destroy the contract
"
"function setHodlerTime ( uint256 _time ) public onlyCrowdsale { hodlerReward . setHodlerTime ( _time ) ; }
","Proxy call for setting hodler start time
"
"function deposit ( bytes32 channelId ) public payable { require ( canDeposit ( channelId , msg . sender ) ) ; channels [ channelId ] . value += msg . value ; DidDeposit ( channelId , msg . value ) ; }
","Add more money to the contract .
"
"function withdraw ( uint256 _amount , address _destination ) public onlyOwner { require ( _destination != address ( 0 ) ) ; require ( _amount <= this . balance ) ; _destination . transfer ( _amount == 0 ? this . balance : _amount ) ; }
","Proceeds are paid out right away , but the contract might receive unexpected funds
"
"function approve ( address _approved , uint256 _tokenId ) canOperate ( _tokenId ) ownerExists ( _tokenId ) external { address tokenOwner = nft [ _tokenId ] . owner ; require ( _approved != tokenOwner , ""approved address cannot be owner of the token"" ) ; nft [ _tokenId ] . approval = _approved ; emit Approval ( tokenOwner , _approved , _tokenId ) ; }
","The zero address indicates there is no approved address .
"
"function name ( ) external view returns ( string ) { return _name ; }
","A descriptive name for a collection of NFTs in this contract
"
"function transferFromPreSignedHashing ( address _token , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0xb7656dc5 ) , _token , _from , _to , _value , _fee , _nonce ) ; }
","Hash ( keccak256 ) of the payload used by transferFromPreSigned
"
"function adjustBalanceCheckpoints ( address _investor ) internal { adjustCheckpoints ( checkpointBalances [ _investor ] , balanceOf ( _investor ) ) ; }
","adjust token holder balance at checkpoint after a token transfer
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }
","Required for ERC-20 and ERC-721 compliance .
"
"function claim ( address engine , uint256 loanId , bytes ) external returns ( bool ) { uint256 mortgageId = loanToLiability [ engine ] [ loanId ] ; Mortgage storage mortgage = mortgages [ mortgageId ] ; require ( mortgage . status == Status . Ongoing , ""Mortgage not ongoing"" ) ; require ( mortgage . loanId == loanId , ""Mortgage don't match loan id"" ) ; if ( mortgage . engine . getStatus ( loanId ) == Engine . Status . paid || mortgage . engine . getStatus ( loanId ) == Engine . Status . destroyed ) { require ( _isAuthorized ( msg . sender , mortgageId ) , ""Sender not authorized"" ) ; mortgage . status = Status . Paid ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit PaidMortgage ( msg . sender , mortgageId ) ; } else if ( isDefaulted ( mortgage . engine , loanId ) ) { require ( msg . sender == mortgage . engine . ownerOf ( loanId ) , ""Sender not lender"" ) ; mortgage . status = Status . Defaulted ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit DefaultedMortgage ( mortgageId ) ; } else { revert ( ""Mortgage not defaulted/paid"" ) ; } delete mortgageByLandId [ mortgage . landId ] ; return true ; }
","Claims the mortgage when the loan status is resolved and transfers the ownership of the parcel to which corresponds .
"
"function depositNomins ( uint amount ) external { nomin . transferFrom ( msg . sender , this , amount ) ; }
","depositNomins : Allows users to deposit nomins via the approve / transferFrom workflow if they 'd like .
"
"function liabilityFinalized ( ILiability _liability , uint256 _start_gas ) external returns ( bool ) ;
","This method is for lighthouse contract use only
"
"function sell ( uint256 amount ) public returns ( uint256 revenue ) { uint256 a = 0 ; require ( initialSaleComplete ) ; require ( balances [ msg . sender ] >= amount ) ; a = _totalSupply - amount ; uint256 p = 0 ; uint8 ps = 0 ; ( p , ps ) = power ( 1000008 , 1000000 , ( uint32 ) ( 1e5 + 1e5 * _totalSupply / SU ) , 1e5 ) ; p = ( S * p ) >> ps ; uint256 p2 = 0 ; uint8 ps2 = 0 ; ( p2 , ps2 ) = power ( 1000008 , 1000000 , ( uint32 ) ( 1e5 + 1e5 * a / SU ) , 1e5 ) ; p2 = ( S * p2 ) >> ps2 ; revenue = ( SU * p - SU * p2 ) * R / S ; _totalSupply -= amount ; require ( balances [ reserveAddress ] >= revenue ) ; balances [ reserveAddress ] -= revenue ; balances [ msg . sender ] -= amount ; Contract reserve = Contract ( reserveAddress ) ; reserve . sendFunds ( msg . sender , revenue ) ; emit Transfer ( msg . sender , reserveAddress , amount ) ; quoteAsk ( ) ; quoteBid ( ) ; return revenue ; }
","Sells aToken in exchnage for wei at the current bid price , reduces resreve
"
"function getAssetIpfs ( uint _id ) public view returns ( bytes32 ) { require ( _id < numberOfAssets ) ; return assets [ _id ] . ipfsHash ; }
","Function to get ipfsHash for selected asset
"
"function setConverterRamp ( address _converterRamp ) external onlyOwner returns ( bool ) { emit SetConverterRamp ( converterRamp , _converterRamp ) ; converterRamp = _converterRamp ; return true ; }
","Sets a new converter ramp to delegate the pay of the loan
"
"function getPrice ( address asset ) public view returns ( uint ) { return assetPrices ( asset ) ; }
","retrieves price of an asset
"
"function claimTokens ( address _token ) onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function setTokenPrice ( uint week , uint price , uint price5 , uint price10 ) public onlyOwner { require ( crowdsaleClosed == false ) ; require ( week >= 1 && week <= 3 ) ; if ( week == 1 ) price1stWeek = [ price , price5 , price10 ] ; else if ( week == 2 ) price2ndWeek = [ price , price5 , price10 ] ; else if ( week == 3 ) price3rdWeek = [ price , price5 , price10 ] ; }
","Function to define prices for some particular week .
"
"function release ( ERC20Basic token ) public { uint256 unreleased = releasableAmount ( token ) ; require ( unreleased > 0 ) ; released [ token ] = released [ token ] . add ( unreleased ) ; require ( token . transfer ( beneficiary , unreleased ) ) ; emit Released ( unreleased ) ; }
","Transfers vested tokens to beneficiary .
"
"function buy ( uint256 identifier ) external payable whenNotPaused { require ( identifierToOwner [ identifier ] != 0x0 ) ; address oldOwner = identifierToOwner [ identifier ] ; uint256 price = identifierToPrice [ identifier ] ; require ( oldOwner != msg . sender ) ; require ( msg . value >= price ) ; uint256 newPrice = nextPrice ( price ) ; identifierToPrice [ identifier ] = newPrice ; _transfer ( oldOwner , msg . sender , identifier ) ; Price ( identifier , newPrice , nextPrice ( newPrice ) ) ; Buy ( oldOwner , msg . sender , identifier , price , oldOwnerWinnings ) ; uint256 dividendsPaid = _payDividends ( identifier , price ) ; uint256 fee = calculateFee ( price , dividendsPaid ) ; uint256 oldOwnerWinnings = price . sub ( dividendsPaid ) . sub ( fee ) ; _shiftRecentBuyers ( msg . sender ) ; if ( oldOwner != address ( this ) ) { _sendFunds ( oldOwner , oldOwnerWinnings ) ; } uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Buy a collectible .
"
"function getMaximumFunds ( ) internal constant returns ( uint ) ;
","maximum investments to be accepted during pre-ICO
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( totalDistributed == hardCap && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else if ( state == State . PreSale && now > PreSaleDeadline ) { state = State . MainSale ; } else if ( state == State . MainSale && now > MainSaleDeadline ) { if ( totalDistributed >= softCap ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else { state = State . Failed ; completedAt = now ; emit LogFundingFailed ( totalRaised ) ; } } }
","check status
"
"function getFeeMax ( Data storage self , address contractAddress ) internal view returns ( uint feeMax ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.max' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }
","Get the maximum fee of the contract address ; typically TokenIOFeeContract
"
"function getAmount ( uint _price , address _trader ) public constant returns ( uint ) ;
","Returns the order amount for trader ` _trader ` at '_price '
"
"function collectAuthorizedPayment ( uint _idPayment ) { if ( _idPayment >= authorizedPayments . length ) return ; Payment p = authorizedPayments [ _idPayment ] ; if ( msg . sender != p . recipient ) return ; if ( now < p . earliestPayTime ) return ; if ( p . canceled ) return ; if ( p . paid ) return ; if ( this . balance < p . amount ) return ; p . paid = true ; if ( ! p . recipient . send ( p . amount ) ) { return ; } PaymentExecuted ( _idPayment , p . recipient , p . amount ) ; }
","only ` allowedSpenders [ ] ` The recipient of a payment calls this function to send themselves the ether after the ` earliestPayTime ` has expired
"
"function restartSale ( ) public only_during_sale_period only_sale_stopped onlyOwner { if ( saleFinalized ) revert ( ) ; saleStopped = false ; }
","Function to restart stopped sale .
"
"function setComment ( string newComment ) onlyOwner public { comment = newComment ; }
","Allow users to read comments
"
"function setAdmin ( address _newAdmin ) external onlyOwner { admin = _newAdmin ; }
","Change the address of the admin , who has the privilege to create new accounts
"
"function getTokenTLA ( Data storage self , address contractAddress ) internal view returns ( string tokenTLA ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.tla' , contractAddress ) ) ; return self . Storage . getString ( id ) ; }
","Get the token Three letter abbreviation ( TLA ) for Token interfaces
"
"function created ( ) public constant returns ( uint256 timestamp ) { }
","the block number that the campaign was created
"
"function isTrustedContract ( address _contractAddress ) public view returns ( bool ) { return trustedCurrencyContracts [ _contractAddress ] == 1 ; }
","Checks if a currencyContract is trusted .
"
"function getInstructions ( ) external view returns ( string ) { return ""Allows an issuer to set manual approvals or blocks for specific pairs of addresses and amounts. Init function takes no parameters."" ; }
","Returns the instructions associated with the module
"
"function tokenURI ( uint256 _tokenId ) external view returns ( string _tokenURI ) { _tokenURI = ""https://corsarium.playdarkwinds.com/cards/00000.json"" ; bytes memory tokenUriBytes = bytes ( _tokenURI ) ; tokenUriBytes [ 33 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 10000 ) % 10 ) ; tokenUriBytes [ 34 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 1000 ) % 10 ) ; tokenUriBytes [ 35 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 100 ) % 10 ) ; tokenUriBytes [ 36 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 10 ) % 10 ) ; tokenUriBytes [ 37 ] = byte ( 48 + ( tokenToCardIndex [ _tokenId ] / 1 ) % 10 ) ; }
","A distinct Uniform Resource Identifier ( URI ) for a given asset .
"
"function isService ( address _address ) public view returns ( bool ) ;
","Check target address is service
"
"function setRewardBlockThreshold ( uint _newBlockThreshold ) public onlyOwner returns ( bool ) { require ( _newBlockThreshold != blockThreshold , ""must be different"" ) ; blockThreshold = _newBlockThreshold ; emit RewardBlockThresholdChanged ( msg . sender , _newBlockThreshold ) ; return true ; }
","sets the global block threshold for rewards
"
"function _burn ( address _owner , uint256 _tokenId ) internal { assert ( tokens . length > 0 ) ; super . _burn ( _owner , _tokenId ) ; uint256 tokenIndex = idToIndex [ _tokenId ] ; uint256 lastTokenIndex = tokens . length . sub ( 1 ) ; uint256 lastToken = tokens [ lastTokenIndex ] ; tokens [ tokenIndex ] = lastToken ; tokens [ lastTokenIndex ] = 0 ; tokens . length -- ; idToIndex [ _tokenId ] = 0 ; idToIndex [ lastToken ] = tokenIndex ; }
","This is a private function which should be called from user-implemented external burn function .
"
"function claimToken ( ) public afterSaleSuccess { claimTokenFor ( msg . sender ) ; }
","Claim token for msg.sender after token sale based on stake .
"
"function getModulesByTypeAndToken ( uint8 _moduleType , address _securityToken ) public view returns ( address [ ] ) { uint256 _len = getArrayAddress ( Encoder . getKey ( ""moduleList"" , uint256 ( _moduleType ) ) ) . length ; address [ ] memory _addressList = getArrayAddress ( Encoder . getKey ( ""moduleList"" , uint256 ( _moduleType ) ) ) ; bool _isCustomModuleAllowed = IFeatureRegistry ( getAddress ( Encoder . getKey ( ""featureRegistry"" ) ) ) . getFeatureStatus ( ""customModulesAllowed"" ) ; uint256 counter = 0 ; for ( uint256 i = 0 ; i < _len ; i ++ ) { if ( _isCustomModuleAllowed ) { if ( IOwnable ( _addressList [ i ] ) . owner ( ) == IOwnable ( _securityToken ) . owner ( ) || getBool ( Encoder . getKey ( ""verified"" , _addressList [ i ] ) ) ) if ( _isCompatibleModule ( _addressList [ i ] , _securityToken ) ) counter ++ ; } else if ( getBool ( Encoder . getKey ( ""verified"" , _addressList [ i ] ) ) ) { if ( _isCompatibleModule ( _addressList [ i ] , _securityToken ) ) counter ++ ; } } address [ ] memory _tempArray = new address [ ] ( counter ) ; counter = 0 ; for ( uint256 j = 0 ; j < _len ; j ++ ) { if ( _isCustomModuleAllowed ) { if ( IOwnable ( _addressList [ j ] ) . owner ( ) == IOwnable ( _securityToken ) . owner ( ) || getBool ( Encoder . getKey ( ""verified"" , _addressList [ j ] ) ) ) { if ( _isCompatibleModule ( _addressList [ j ] , _securityToken ) ) { _tempArray [ counter ] = _addressList [ j ] ; counter ++ ; } } } else if ( getBool ( Encoder . getKey ( ""verified"" , _addressList [ j ] ) ) ) { if ( _isCompatibleModule ( _addressList [ j ] , _securityToken ) ) { _tempArray [ counter ] = _addressList [ j ] ; counter ++ ; } } } return _tempArray ; }
","Returns the list of available Module factory addresses of a particular type for a given token .
"
"function getAllPlots ( ) external view returns ( uint32 [ ] ) { return plots ; }
","Get all minted plots .
"
"function getBidDetails ( address _addr ) external view returns ( uint , uint ) { return ( _bidders [ _addr ] . value , _bidders [ _addr ] . lastTime ) ; }
","Returns the value of ` ( _addr ) ` 's bid and the time it occurred
"
"function endAuction ( ) public onlyHighestBidderOrEscrow { require ( now >= auctionEnd , ""Auction not yet ended."" ) ; require ( auctionState != AuctionStates . Ended , ""Auction has already ended."" ) ; auctionState = AuctionStates . Ended ; emit AuctionEnded ( highestBidder , bids [ highestBidder ] ) ; if ( ! beneficiary . send ( bids [ highestBidder ] ) ) { } }
","Ends the auction and sends the ` bids [ highestBidder ] ` to ` beneficiary `
"
"function getHistoryHash ( bytes32 question_id ) public view returns ( bytes32 ) { return questions [ question_id ] . history_hash ; }
","Returns the history hash of the question
"
"function validateProposedMonarchName ( string _monarchName ) constant returns ( bool allowed ) { return validateNameInternal ( _monarchName ) ; }
","Check if a name can be used as a monarch name .
"
"function removeAttributeType ( uint256 ID ) external ;
","Remove the attribute type with ID ` ID ` from the jurisdiction .
"
"function unpack ( uint24 _packedVersion ) internal pure returns ( uint8 [ ] ) { uint8 [ ] memory _unpackVersion = new uint8 [ ] ( 3 ) ; _unpackVersion [ 0 ] = uint8 ( _packedVersion >> 16 ) ; _unpackVersion [ 1 ] = uint8 ( _packedVersion >> 8 ) ; _unpackVersion [ 2 ] = uint8 ( _packedVersion ) ; return _unpackVersion ; }
","Used to convert packed data into uint8 array
"
"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyArbitrator ( question_id ) statePendingArbitration ( question_id ) bondMustBeZero external { require ( answerer != NULL_ADDRESS , ""answerer must be provided"" ) ; emit LogFinalize ( question_id , answer ) ; questions [ question_id ] . is_pending_arbitration = false ; _addAnswerToHistory ( question_id , answer , answerer , 0 , false ) ; _updateCurrentAnswer ( question_id , answer , 0 ) ; }
","Submit the answer for a question , for use by the arbitrator .
"
"function processProposal ( bytes32 _propID ) public { ParamProposal storage prop = proposals [ _propID ] ; if ( canBeSet ( _propID ) ) { set ( prop . name , prop . value ) ; } else if ( challengeCanBeResolved ( _propID ) ) { resolveChallenge ( _propID ) ; } else if ( now > prop . processBy ) { require ( token . transfer ( prop . owner , prop . deposit ) ) ; } else { revert ( ) ; } delete proposals [ _propID ] ; }
","for the provided proposal ID , set it , resolve its challenge , or delete it depending on whether it can be set , has a challenge which can be resolved , or if its `` process by '' date has passed
"
"function replaceSelf ( address new_addr ) external { uint256 idx = _firstRecipientIndex ( msg . sender ) ; assert ( recipients [ idx ] == msg . sender ) ; recipients [ idx ] = new_addr ; }
","Replace your own address with a different one
"
"function getTickersByOwner ( address _owner ) external view returns ( bytes32 [ ] ) { uint counter = 0 ; bytes32 [ ] memory tickers = getArrayBytes32 ( Encoder . getKey ( ""userToTickers"" , _owner ) ) ; for ( uint i = 0 ; i < tickers . length ; i ++ ) { string memory ticker = Util . bytes32ToString ( tickers [ i ] ) ; if ( getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , ticker ) ) >= now || _tickerStatus ( ticker ) ) { counter ++ ; } } bytes32 [ ] memory tempList = new bytes32 [ ] ( counter ) ; counter = 0 ; for ( i = 0 ; i < tickers . length ; i ++ ) { ticker = Util . bytes32ToString ( tickers [ i ] ) ; if ( getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , ticker ) ) >= now || _tickerStatus ( ticker ) ) { tempList [ counter ] = tickers [ i ] ; counter ++ ; } } return tempList ; }
","Returns the list of tickers owned by the selected address
"
"function createJob ( string _description , uint _salary , uint _noOfTotalPayments , address _evaluator ) public { require ( _salary > 0 ) ; require ( _noOfTotalPayments > 0 ) ; address [ ] memory empty ; uint finalSalary = _salary . sub ( _salary . mul ( 1 ) . div ( 10 ) ) ; Job memory newJob = Job ( _description , msg . sender , finalSalary , 0x0 , JobStatus . Open , _noOfTotalPayments , 0 , 0 , 0 , _evaluator , false , 0 , empty , 0 ) ; Jobs . push ( newJob ) ; JobsByManager [ msg . sender ] . push ( jobCount ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _salary ) ; emit JobCreated ( msg . sender , finalSalary , _noOfTotalPayments , jobCount , _description , _evaluator ) ; jobCount ++ ; DAI . transferFrom ( msg . sender , address ( this ) , _salary ) ; }
","this function creates a job
"
"function transferFrom ( address from , address to , uint value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; if ( to == 0x0 ) throw ; if ( to == address ( upgradeAgent ) ) throw ; if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { return false ; } }
","This function is disabled during the funding .
"
"function mintToken ( address _target , uint256 _mintedAmount ) onlyOwner { require ( _target != 0x0 ) ; balanceOf [ _target ] += _mintedAmount ; totalSupply += _mintedAmount ; Transfer ( 0 , this , _mintedAmount ) ; Transfer ( this , _target , _mintedAmount ) ; }
","Create ` _mintedAmount ` tokens and send it to ` _target `
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }
","Required for ERC-20 and ERC-721 compliance .
"
"function _addTeamSale ( uint256 [ 9 ] _tokenIds , Sale _sale ) internal { require ( _sale . duration >= 1 minutes ) ; for ( uint ii = 0 ; ii < 9 ; ii ++ ) { require ( _tokenIds [ ii ] != 0 ) ; require ( nonFungibleContract . exists ( _tokenIds [ ii ] ) ) ; tokenIdToSale [ _tokenIds [ ii ] ] = _sale ; } emit TeamSaleCreated ( _tokenIds , uint256 ( _sale . startingPrice ) , uint256 ( _sale . endingPrice ) , uint256 ( _sale . duration ) , uint256 ( _sale . startedAt ) ) ; }
","Adds an sale to the list of open sales .
"
"function burnFrom ( address _from , uint256 _value ) public returns ( bool ) { allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; emit Burn ( _from , _value ) ; return true ; }
","Destroy tokens from other account
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","Send `` _value '' tokens to `` _to '' from `` msg.sender '' .
"
"function setEndDate ( uint256 _endTime ) external onlyOwner whenNotPaused { require ( now <= _endTime ) ; require ( startTime < _endTime ) ; endTime = _endTime ; }
","Allow to extend ICO end date
"
"function getContract ( string _contractName ) external view returns ( address _contractAddress ) { require ( contracts [ _contractName ] != address ( 0 ) ) ; _contractAddress = contracts [ _contractName ] ; return _contractAddress ; }
","Get a contract by its name
"
"function transfer ( address _to , uint256 _cutieId ) external whenNotPaused canBeStoredIn40Bits ( _cutieId ) { require ( _isOwner ( msg . sender , uint40 ( _cutieId ) ) ) ; _transfer ( msg . sender , _to , uint40 ( _cutieId ) ) ; }
","Transfers a Cutie to another address .
"
"function getBounty ( bytes32 question_id ) public view returns ( uint256 ) { }
","Returns the current total unclaimed bounty
"
"function addCustomSecurityToken ( string _name , string _symbol , address _owner , address _securityToken , string _tokenDetails , bytes32 _swarmHash ) public onlyOwner whenNotPaused { require ( bytes ( _name ) . length > 0 && bytes ( _symbol ) . length > 0 , ""Name and Symbol string length should be greater than 0"" ) ; string memory symbol = upper ( _symbol ) ; require ( _securityToken != address ( 0 ) && symbols [ symbol ] == address ( 0 ) , ""Symbol is already at the polymath network or entered security token address is 0x"" ) ; require ( _owner != address ( 0 ) ) ; require ( ! ( ITickerRegistry ( tickerRegistry ) . isReserved ( symbol , _owner , _name , _swarmHash ) ) , ""Trying to use non-valid symbol"" ) ; symbols [ symbol ] = _securityToken ; securityTokens [ _securityToken ] = SecurityTokenData ( symbol , _tokenDetails ) ; emit LogAddCustomSecurityToken ( _name , symbol , _securityToken , now ) ; }
","Add a new custom ( Token should follow the ISecurityToken interface ) Security Token and saves it to the registry
"
"function finalizeAuction ( ) public atStage ( Stages . AuctionStarted ) { uint missing_funds = missingFundsToEndAuction ( ) ; require ( missing_funds == 0 ) ; final_price = token_multiplier * received_wei / num_tokens_auctioned ; end_time = now ; stage = Stages . AuctionEnded ; AuctionEnded ( final_price ) ; assert ( final_price > 0 ) ; }
","Finalize the auction - sets the final RDN token price and changes the auction stage after no bids are allowed anymore .
"
"function removeAt ( MapStorage storage self , uint index ) public returns ( bool ) { return remove ( self , self . addresses [ index ] ) ; }
","Removes the given index from the storage .
"
"function takeOwnership ( uint256 _tokenId ) external whenNotPaused { require ( isSenderApprovedFor ( _tokenId ) ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , msg . sender , _tokenId ) ; }
","Claims the ownership of a given token ID
"
"function createDividend ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , bytes32 _name ) external withPerm ( MANAGE ) { createDividendWithExclusions ( _maturity , _expiry , _token , _amount , excluded , _name ) ; }
","Creates a dividend and checkpoint for the dividend
"
"function breedWith ( uint40 _momId , uint40 _dadId ) public whenNotPaused payable returns ( uint40 ) { require ( _isOwner ( msg . sender , _momId ) ) ; require ( _isBreedingPermitted ( _dadId , _momId ) ) ; require ( getBreedingFee ( _momId , _dadId ) <= msg . value ) ; Cutie storage mom = cuties [ _momId ] ; require ( _canBreed ( mom ) ) ; Cutie storage dad = cuties [ _dadId ] ; require ( _canBreed ( dad ) ) ; require ( _canPairMate ( mom , _momId , dad , _dadId ) ) ; return _breedWith ( _momId , _dadId ) ; }
","Breed cuties that you own , or for which you have previously been given Breeding approval .
"
"function updateBalance ( bytes32 _requestId , uint8 _payeeIndex , int256 _deltaAmount ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , ""caller should be the currency contract of the request"" ) ; if ( _payeeIndex == 0 ) { r . payee . balance = r . payee . balance . add ( _deltaAmount ) ; } else { Payee storage sp = subPayees [ _requestId ] [ _payeeIndex - 1 ] ; sp . balance = sp . balance . add ( _deltaAmount ) ; } emit UpdateBalance ( _requestId , _payeeIndex , _deltaAmount ) ; }
","Function used to update the balance .
"
"function exchangeNominsForHavvens ( uint nominAmount ) public pricesNotStale notPaused returns ( uint ) { uint havvensToSend = havvensReceivedForNomins ( nominAmount ) ; nomin . transferFrom ( msg . sender , this , nominAmount ) ; havven . transfer ( msg . sender , havvensToSend ) ; emit Exchange ( ""nUSD"" , nominAmount , ""HAV"" , havvensToSend ) ; return havvensToSend ; }
","Exchange nUSD for Havvens
"
"function increaseBalance ( address _user , uint256 _value ) public onlyAllowed { if ( userExists [ _user ] == false ) { users . push ( _user ) ; userExists [ _user ] = true ; } balanceUsers [ _user ] += _value ; }
","Increases balance of a user This function can only be called by the registered Advertisement contract and increases the balance of a specific user on this contract .
"
"function modifyWhitelistSigned ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO , uint256 _validFrom , uint256 _validTo , uint8 _v , bytes32 _r , bytes32 _s ) public { require ( _validFrom <= now , ""ValidFrom is too early"" ) ; require ( _validTo >= now , ""ValidTo is too late"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( this , _investor , _fromTime , _toTime , _expiryTime , _canBuyFromSTO , _validFrom , _validTo ) ) ; checkSig ( hash , _v , _r , _s ) ; whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit LogModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }
","adds or removes addresses from the whitelist - can be called by anyone with a valid signature
"
"function addManualApproval ( address _from , address _to , uint256 _allowance , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , ""Invalid to address"" ) ; require ( _expiryTime > now , ""Invalid expiry time"" ) ; require ( manualApprovals [ _from ] [ _to ] . allowance == 0 , ""Approval already exists"" ) ; manualApprovals [ _from ] [ _to ] = ManualApproval ( _allowance , _expiryTime ) ; emit AddManualApproval ( _from , _to , _allowance , _expiryTime , msg . sender ) ; }
","Adds a pair of addresses to manual approvals
"
"function assetPrices ( address asset ) public view returns ( uint ) { if ( paused ) { return 0 ; } else { if ( readers [ asset ] != address ( 0 ) ) { ( bytes32 readValue , bool foundValue ) = readers [ asset ] . peek ( ) ; if ( foundValue ) { ( Error error , Exp memory invertedVal ) = getExp ( mantissaOne , uint256 ( readValue ) ) ; if ( error != Error . NO_ERROR ) { return 0 ; } return invertedVal . mantissa ; } else { return 0 ; } } else { return _assetPrices [ asset ] . mantissa ; } } }
","retrieves price of an asset
"
"function gasExchange ( address gasRecipient , uint256 amountEurUlps , uint256 exchangeFeeFraction ) public ;
","will exchange amountEurUlps of gasRecipient balance into ether
"
"function changeWhitelister ( address _newWhitelister ) public onlyWhitelister { require ( _newWhitelister != address ( 0 ) ) ; emit WhitelisterChanged ( whitelister , _newWhitelister ) ; whitelister = _newWhitelister ; }
","Changes the current whitelister .
"
"function calculateDividend ( uint256 _dividendIndex , address _payee ) public view returns ( uint256 ) { Dividend storage dividend = dividends [ _dividendIndex ] ; if ( dividend . claimed [ _payee ] ) { return 0 ; } uint256 balance = ISecurityToken ( securityToken ) . balanceOfAt ( _payee , dividend . checkpointId ) ; return balance . mul ( dividend . amount ) . div ( dividend . totalSupply ) ; }
","Calculate amount of dividends claimable
"
"function calculateTheEndPrice ( uint256 howManyTokenToBuy ) constant returns ( uint256 summarizedPriceInWeis ) { if ( howManyTokenToBuy > 0 ) { summarizedPriceInWeis = howManyTokenToBuy * currentTokenPrice ; } else { summarizedPriceInWeis = 0 ; } }
","Calculates amount of weis needed to buy more than one token
"
"function transferGIM ( address _from , address _to , uint256 _amount ) returns ( bool success ) { require ( msg . sender == streamerContract ) ; require ( tx . origin == _from ) ; require ( _amount <= streamerContractMaxAmount ) ; if ( balances [ _from ] < _amount || _amount <= 0 ) return false ; balances [ _from ] = safeSub ( balances [ _from ] , _amount ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _amount ) ; Transfer ( _from , _to , _amount ) ; return true ; }
","Called by a Gimli contract to transfer GIM
"
"function approve ( address _spender , uint _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = TRANSFER_APPROVAL ; return allPermissions ; }
","Returns the permissions flag that are associated with ManualApproval transfer manager
"
"function totalSupplyAt ( uint _blockNumber ) public constant returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function playerEndGame ( uint32 _roundId , uint8 _gameType , uint16 _num , uint _value , int _balance , bytes32 _serverHash , bytes32 _playerHash , uint _gameId , address _contractAddress , bytes _serverSig ) public { verifySig ( _roundId , _gameType , _num , _value , _balance , _serverHash , _playerHash , _gameId , _contractAddress , _serverSig , serverAddress ) ; regularEndGame ( msg . sender , _roundId , _gameType , _num , _value , _balance , _gameId , _contractAddress ) ; }
","Regular end game session .
"
"function incremental ( uint256 totalEuroUlps , uint256 euroUlps ) public constant returns ( uint256 neumarkUlps ) { require ( totalEuroUlps + euroUlps >= totalEuroUlps ) ; uint256 from = cumulative ( totalEuroUlps ) ; uint256 to = cumulative ( totalEuroUlps + euroUlps ) ; assert ( to >= from ) ; return to - from ; }
","returns additional amount of neumarks issued for euroUlps at totalEuroUlps
"
"function resignFromMatch ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; require ( board . status == BoardStatus . InProgress ) ; PlayerColor activeColor = getPlayerColor ( board , msg . sender ) ; board . isHonorableLoss = true ; playerLost ( board , boardId , activeColor ) ; }
","Resigns a player from a specific board , can get called by either player on the board .
"
"function addDesignatedAssetManager ( bytes32 _symbol , address _manager ) public onlyOneOfContractOwners returns ( uint ) { uint holderId = _createHolderId ( _manager ) ; set ( store , assetPartowners , _symbol , holderId , true ) ; _emitter ( ) . emitOwnershipChange ( 0x0 , _manager , _symbol ) ; return OK ; }
","Adds a asset manager for an asset with provided symbol .
"
"function enableSelling ( ) onlyOwner public { require ( msg . sender == owner ) ; sellingAllowed = true ; }
","allows to sell to the contract
"
"function pause ( ) external timedStateChange requiresState ( IcoState . ICO ) onlyowner { changeState ( IcoState . PAUSED ) ; }
","pauses ICO
"
"function deposit ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . deposit ( currency , account , amount , issuerFirm ) , ""Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered"" ) ; return true ; }
","Issues a specified account to recipient account of a given currency
"
"function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = recoverPreSignedHash ( address ( this ) , transferSig , _to , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; require ( _nonce == nonces [ from ] . add ( 1 ) ) ; require ( _value . add ( _fee ) <= balances [ from ] ) ; nonces [ from ] = _nonce ; signatures [ _signature ] = true ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned transfer
"
"function getTxVoteDetails ( bytes32 _txKey ) public view returns ( bytes32 [ ] _groupNames , uint [ ] _acceptedCount , uint [ ] _acceptLimit , uint [ ] _declinedCount , uint [ ] _declineLimit , uint _state ) { if ( txKey2index [ _txKey ] == 0 ) { return ; } Guard storage _guard = txKey2guard [ _txKey ] ; Policy storage _policy = policyId2policy [ index2PolicyId [ _guard . basePolicyIndex ] ] ; uint _groupsCount = _policy . groupsCount ; _groupNames = new bytes32 [ ] ( _groupsCount ) ; _acceptedCount = new uint [ ] ( _groupsCount ) ; _acceptLimit = new uint [ ] ( _groupsCount ) ; _declinedCount = new uint [ ] ( _groupsCount ) ; _declineLimit = new uint [ ] ( _groupsCount ) ; for ( uint _groupIdx = 0 ; _groupIdx < _groupsCount ; ++ _groupIdx ) { Requirements storage _requirement = _policy . participatedGroups [ _groupIdx ] ; bytes32 _groupName = _requirement . groupName ; _groupNames [ _groupIdx ] = _groupName ; _acceptedCount [ _groupIdx ] = _guard . acceptedCount [ _groupName ] ; _acceptLimit [ _groupIdx ] = _requirement . acceptLimit ; _declinedCount [ _groupIdx ] = _guard . declinedCount [ _groupName ] ; _declineLimit [ _groupIdx ] = _requirement . declineLimit ; } _state = uint ( _guard . state ) ; }
","Gets details about voting for a tx
"
"function _deliverTokens ( address _beneficiary , uint256 _tokenAmount ) internal { require ( ISecurityToken ( securityToken ) . mint ( _beneficiary , _tokenAmount ) , ""Error in minting the tokens"" ) ; }
","Source of tokens .
"
"function getCanvasState ( uint32 _canvasId ) public view returns ( uint8 ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; if ( canvas . state != STATE_INITIAL_BIDDING ) { return canvas . state ; } uint finishTime = canvas . initialBiddingFinishTime ; if ( finishTime == 0 || finishTime > getTime ( ) ) { return STATE_INITIAL_BIDDING ; } else { return STATE_OWNED ; } }
","Returns current canvas state .
"
"function registerHolder ( bytes32 _externalHolderId , address _holderAddress , uint _countryCode ) onlyOracleOrOwner external returns ( uint ) { require ( _holderAddress != 0x0 ) ; uint _holderIndex = holderIndex [ holderAddress2Id [ _holderAddress ] ] ; require ( _holderIndex == 0 ) ; _createCountryId ( _countryCode ) ; _holderIndex = holdersCount . add ( 1 ) ; holdersCount = _holderIndex ; HoldersData storage _holderData = holders [ _holderIndex ] ; _holderData . countryCode = _countryCode ; _holderData . operational = true ; _holderData . sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER ; _holderData . sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER ; uint _firstAddressIndex = 1 ; _holderData . holderAddressCount = _firstAddressIndex ; _holderData . address2Index [ _holderAddress ] = _firstAddressIndex ; _holderData . index2Address [ _firstAddressIndex ] = _holderAddress ; holderIndex [ _externalHolderId ] = _holderIndex ; holderAddress2Id [ _holderAddress ] = _externalHolderId ; _emitHolderRegistered ( _externalHolderId , _holderIndex , _countryCode ) ; return OK ; }
","Returns holder id for the specified address , creates it if needed .
"
"function calcReleaseToken ( address _user , uint256 _time , uint256 _lockTypeIndex ) internal view returns ( uint256 ) { uint256 _timeDifference = _time . sub ( releaseStartTime ) ; uint256 _whichPeriod = getPeriod ( _lockTypeIndex , _timeDifference ) ; if ( _lockTypeIndex == 1 ) { return ( percent ( userReleaseToken [ _user ] . UST , 25 ) + percent ( userReleaseToken [ _user ] . UST , _whichPeriod . mul ( 25 ) ) ) ; } if ( _lockTypeIndex == 2 ) { return ( percent ( userReleaseToken [ _user ] . UST , 25 ) + percent ( userReleaseToken [ _user ] . UST , _whichPeriod . mul ( 25 ) ) ) ; } if ( _lockTypeIndex == 3 ) { return ( percent ( userReleaseToken [ _user ] . UST , 10 ) + percent ( userReleaseToken [ _user ] . UST , _whichPeriod . mul ( 15 ) ) ) ; } revert ( ) ; }
","get ` _user ` transferable token amount
"
"function ( ) payable external { if ( ! funding ) revert ( ) ; if ( msg . value == 0 ) revert ( ) ; var numTokens = msg . value ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
","Create tokens when funding is active .
"
"function getValidatorSigningKey ( address validator ) external view returns ( address signingKey ) { return _validators [ validator ] . signingKey ; }
","Get the signing key of the validator at account ` validator ` .
"
"function validateContestForSig ( address _attester , address _requester , uint256 _reward , bytes32 _requestNonce , bytes _delegationSig ) private { bytes32 _delegationDigest = generateContestForDelegationSchemaHash ( _requester , _reward , _requestNonce ) ; require ( _attester == recoverSigner ( _delegationDigest , _delegationSig ) , 'Invalid ContestFor Signature' ) ; burnSignatureDigest ( _delegationDigest , _attester ) ; }
","Verify attester delegation signature is valid
"
"function getModulesByType ( uint8 _moduleType ) public view returns ( address [ ] ) { return getArrayAddress ( Encoder . getKey ( ""moduleList"" , uint256 ( _moduleType ) ) ) ; }
","Returns the list of addresses of Module Factory of a particular type
"
"function getNextVestingEntry ( address account ) public view returns ( uint [ 2 ] ) { uint index = getNextVestingIndex ( account ) ; if ( index == numVestingEntries ( account ) ) { return [ uint ( 0 ) , 0 ] ; } return getVestingScheduleEntry ( account , index ) ; }
","Obtain the next schedule entry that will vest for a given user .
"
"function currentPrice ( uint256 _deedId ) public view returns ( uint256 price ) { address currentOwner = gameStates [ gameIndex ] . identifierToOwner [ _deedId ] ; if ( currentOwner == 0x0 ) { price = gameSettings . unclaimedTilePrice ; } else { price = gameStates [ gameIndex ] . identifierToBuyoutPrice [ _deedId ] ; } }
","Get the price for the given tile .
"
"function setUserPermission ( address _who , bytes4 _methodsignature ) public onlyValidator { require ( permissions [ _methodsignature ] . active , ""Permission being set must be for a valid method signature"" ) ; userPermissions [ _who ] [ _methodsignature ] = true ; }
","Sets a permission in the list of permissions that a user has .
"
"function configure ( uint256 _startTime , uint256 _endTime , uint256 [ ] _ratePerTier , uint256 [ ] _ratePerTierDiscountPoly , uint256 [ ] _tokensPerTierTotal , uint256 [ ] _tokensPerTierDiscountPoly , uint256 _nonAccreditedLimitUSD , uint256 _minimumInvestmentUSD , FundRaiseType [ ] _fundRaiseTypes , address _wallet , address _reserveWallet , address _usdToken ) public onlyFactory { modifyTimes ( _startTime , _endTime ) ; modifyTiers ( _ratePerTier , _ratePerTierDiscountPoly , _tokensPerTierTotal , _tokensPerTierDiscountPoly ) ; modifyFunding ( _fundRaiseTypes ) ; modifyAddresses ( _wallet , _reserveWallet , _usdToken ) ; modifyLimits ( _nonAccreditedLimitUSD , _minimumInvestmentUSD ) ; }
","Function used to intialize the contract variables
"
"function getIntel ( uint intelIndex ) public view returns ( address intelProvider , uint depositAmount , uint desiredReward , uint balance , uint intelID , uint rewardAfter , bool rewarded ) { IntelState storage intel = intelDB [ intelIndex ] ; intelProvider = intel . intelProvider ; depositAmount = intel . depositAmount ; desiredReward = intel . desiredReward ; balance = intel . balance ; rewardAfter = intel . rewardAfter ; intelID = intel . intelID ; rewarded = intel . rewarded ; }
","this function provide the Intel based on its index
"
"function _issueAttribute ( address account ) internal returns ( bool ) { _jurisdiction . issueAttribute ( account , _validAttributeTypeID , 0 ) ; return true ; }
","Issue an attribute of the type with the default ID to account ` account ` on the jurisdiction .
"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { token . mint ( target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function registerPreSignedHashing ( address _investContract , bytes32 _strategyID , uint256 _registerFee , uint256 _periodLength , uint256 _maxMarginDeposit , uint256 _minMarginDeposit , uint256 _rewardPercentage , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x7fa5aa9d ) , _investContract , _strategyID , _registerFee , _periodLength , _maxMarginDeposit , _minMarginDeposit , _rewardPercentage , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by registerTradeProfile
"
"function setDisputeFee ( uint256 fee ) onlyOwner public { dispute_fee = fee ; emit LogSetDisputeFee ( fee ) ; }
","Set the default fee
"
"function votingEndsInHHMM ( ) constant returns ( uint16 , uint16 ) { var tsec = VOTING_END_TIME - now ; return VOTING_END_TIME == 0 ? ( 0 , 0 ) : ( uint16 ( tsec / 1 hours ) , uint16 ( tsec % 1 hours / 1 minutes ) ) ; }
","return voting remaining time ( hours , minutes ) .
"
"function getModulesByType ( uint8 _type ) external view returns ( address [ ] ) { return modules [ _type ] ; }
","Returns a list of modules that match the provided module type
"
"function escapeHatch ( ) onlyEscapeCallerOrOwner { uint total = this . balance ; if ( ! escapeDestination . send ( total ) ) { throw ; } EscapeCalled ( total ) ; }
","The ` escapeHatch ( ) ` should only be called as a last resort if a security issue is uncovered or something unexpected happened
"
"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) external { }
","Submit the answer for a question , for use by the arbitrator .
"
"function setNonEtherController ( address _controller ) external validAddress ( _controller ) timedStateChange ( address ( 0 ) , 0 , true ) onlymanyowners ( keccak256 ( msg . data ) ) { m_nonEtherController = _controller ; }
","set non ether investment controller
"
"function getVersion ( ) external view returns ( uint8 [ ] ) ;
","Used to get the version of the securityToken
"
"function name ( ) external pure returns ( string ) { return NAME ; }
","token 's name
"
"function matchByAdmin_TwH36 ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 3 ] ; address user = userId2Address [ data & USER_MASK ] ; require ( data >> 224 > userNonce [ user ] ) ; address token ; bool isBuy ; ( token , isBuy ) = decodeOrderTokenAndIsBuy ( data ) ; bytes32 orderHash = keccak256 ( this , inputs [ 0 ] , inputs [ 1 ] , inputs [ 2 ] , data & MATCH_SIGN_MASK | ( isBuy ? ORDER_ISBUY : 0 ) | uint256 ( token ) ) ; require ( verify ( orderHash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ 4 ] ) , bytes32 ( inputs [ 5 ] ) ) ) ; uint256 tokenExecute = isBuy ? inputs [ 1 ] : inputs [ 0 ] ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; require ( tokenExecute != 0 ) ; uint256 etherExecute = 0 ; isBuy = ! isBuy ; for ( uint256 i = 6 ; i < inputs . length ; i += 6 ) { require ( tokenExecute > 0 && inputs [ 1 ] . mul ( inputs [ i + 1 ] ) <= inputs [ 0 ] . mul ( inputs [ i ] ) ) ; data = inputs [ i + 3 ] ; user = userId2Address [ data & USER_MASK ] ; require ( data >> 224 > userNonce [ user ] ) ; bytes32 makerOrderHash = keccak256 ( this , inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , data & MATCH_SIGN_MASK | ( isBuy ? ORDER_ISBUY : 0 ) | uint256 ( token ) ) ; require ( verify ( makerOrderHash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ i + 4 ] ) , bytes32 ( inputs [ i + 5 ] ) ) ) ; ( tokenExecute , etherExecute ) = internalTrade ( inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , data , tokenExecute , etherExecute , isBuy , token , 0 , makerOrderHash ) ; } isBuy = ! isBuy ; tokenExecute = isBuy ? inputs [ 1 ] . sub ( tokenExecute ) : inputs [ 0 ] . sub ( tokenExecute ) ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; processTakerOrder ( inputs [ 2 ] , inputs [ 3 ] , tokenExecute , etherExecute , isBuy , token , 0 , orderHash ) ; }
","match orders with admins involved , only admin
"
"function updatePendingManager ( address _pendingManager , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _pendingManager ) , _block ) ; if ( OK != _code ) { return _code ; } pendingManager = _pendingManager ; return OK ; }
","Update pending manager address
"
"function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; buyNormal ( _th ) ; return true ; }
","This method will generally be called by the ATT token contract to acquire ATTs .
"
"function supportsInterface ( bytes4 interfaceID ) external view returns ( bool ) { return ( ( interfaceID == ERC165InterfaceId ) || ( interfaceID == ERC721InterfaceId ) || ( interfaceID == ERC721EnumerableInterfaceId ) || ( interfaceID == ERC721MetadataInterfaceId ) || ( interfaceID == ERC721TokenReceiverInterfaceId ) ) ; }
","Query if a contract implements an interface
"
"function isValidSignature ( address signer , bytes32 hash , uint8 v , bytes32 r , bytes32 s ) private pure returns ( bool ) { return signer == ecrecover ( keccak256 ( abi . encodePacked ( ""\x19Ethereum Signed Message:\n32"" , hash ) ) , v , r , s ) ; }
","Verifies that a hash signature is valid .
"
"function release ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _seller , ""Must be seller"" ) ; return doRelease ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }
","Release ether in escrow to the buyer .
"
"function onApprove ( address _owner , address _spender , uint _amount ) external returns ( bool ) ;
","Notifies the controller about an approval allowing the controller to react if desired
"
"function incApprove ( address _from , address _spender , uint _value ) external onlyModule returns ( bool ) { allowed [ _from ] [ _spender ] = allowed [ _from ] [ _spender ] . add ( _value ) ; return true ; }
","Increase allowance of ` _spender ` in behalf of ` _from ` at ` _value `
"
"function ownerClawback ( ) external onlyOwner { require ( now >= OWNER_CLAWBACK_DATE ) ; owner . transfer ( this . balance ) ; }
","The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract .
"
"function approve ( address _to , uint256 _tokenId ) public whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer a specific Property via transferFrom ( ) .
"
"function exchangeNominsForHavvensAtRate ( uint nominAmount , uint guaranteedRate ) public pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToHavPrice ) ; return exchangeNominsForHavvens ( nominAmount ) ; }
","Exchange nUSD for Havvens while insisting on a particular rate .
"
"function generateSecurityToken ( string _name , string _ticker , string _tokenDetails , bool _divisible ) external whenNotPausedOrOwner { require ( bytes ( _name ) . length > 0 && bytes ( _ticker ) . length > 0 , ""Ticker length > 0"" ) ; string memory ticker = Util . upper ( _ticker ) ; bytes32 statusKey = Encoder . getKey ( ""registeredTickers_status"" , ticker ) ; require ( ! getBool ( statusKey ) , ""Already deployed"" ) ; set ( statusKey , true ) ; require ( _tickerOwner ( ticker ) == msg . sender , ""Not authorised"" ) ; require ( getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , ticker ) ) >= now , ""Ticker gets expired"" ) ; uint256 launchFee = getSecurityTokenLaunchFee ( ) ; if ( launchFee > 0 ) require ( IERC20 ( getAddress ( POLYTOKEN ) ) . transferFrom ( msg . sender , address ( this ) , launchFee ) , ""Insufficient allowance"" ) ; address newSecurityTokenAddress = ISTFactory ( getSTFactoryAddress ( ) ) . deployToken ( _name , ticker , 18 , _tokenDetails , msg . sender , _divisible , getAddress ( POLYMATHREGISTRY ) ) ; _storeSecurityTokenData ( newSecurityTokenAddress , ticker , _tokenDetails , now ) ; set ( Encoder . getKey ( ""tickerToSecurityToken"" , ticker ) , newSecurityTokenAddress ) ; emit NewSecurityToken ( ticker , _name , newSecurityTokenAddress , msg . sender , now , msg . sender , false , launchFee ) ; }
","Deploys an instance of a new Security Token and records it to the registry
"
"function getCurrencyDenominated ( ) external view returns ( bytes32 ) ;
","Returns denomination of price
"
"function init ( bytes32 [ ] args ) public ;
","interface to initialize crowdsale parameters .
"
"function verifyTokens ( uint64 _buyTokens , uint64 _sellToken ) internal pure returns ( bool ) { return ( ( uint32 ( _buyTokens ) == uint32 ( _sellToken >> 32 ) ) && ( uint32 ( _sellToken ) == uint32 ( _buyTokens >> 32 ) ) && ( uint32 ( _buyTokens >> 32 ) <= uint32 ( _buyTokens ) ) ) ; }
","Verifies that two token requirements can be matched and that the tokens are formatted correctly .
"
"function setPayoutDistributionId ( ) internal { uint24 [ 21 ] memory auxArr = PayoutDistribution . getDistribution ( tokens . length ) ; for ( uint256 i = 0 ; i < auxArr . length ; i ++ ) { payoutDistribution [ i ] = auxArr [ i ] ; } superiorQuota = PayoutDistribution . getSuperiorQuota ( tokens . length ) ; }
","Sets the structures for payout distribution , last position and superior quota .
"
"function exists ( uint64 _pixelconIndex ) public view returns ( bool ) { return ( marketPixelconListings [ _pixelconIndex ] . seller != address ( 0 ) ) ; }
","Check if a market listing exists for PixelCon # ` ( _pixelconIndex ) `
"
"function fail ( ) external timedStateChange requiresState ( IcoState . PAUSED ) onlymanyowners ( sha3 ( msg . data ) ) { changeState ( IcoState . FAILED ) ; }
","consider paused ICO as failed
"
"function __callback ( bytes32 myid , string result , bytes proof ) public { require ( msg . sender == oraclize_cbAddress ( ) ) ; setPrices ( result ) ; updatePrice ( ) ; }
","Called on price update by Oraclize
"
"function addFiveParticipants ( address participant1 , address participant2 , address participant3 , address participant4 , address participant5 ) public onlyAdmin returns ( bool ) { require ( addParticipant ( participant1 ) ) ; require ( addParticipant ( participant2 ) ) ; require ( addParticipant ( participant3 ) ) ; require ( addParticipant ( participant4 ) ) ; require ( addParticipant ( participant5 ) ) ; return true ; }
","used to save gas .
"
"function cancelPledge ( uint64 idPledge , uint amount ) { idPledge = normalizePledge ( idPledge ) ; Pledge storage p = findPledge ( idPledge ) ; require ( p . oldPledge != 0 ) ; PledgeAdmin storage m = findAdmin ( p . owner ) ; checkAdminOwner ( m ) ; uint64 oldPledge = getOldestPledgeNotCanceled ( p . oldPledge ) ; doTransfer ( idPledge , oldPledge , amount ) ; }
","Method called to cancel specific pledge .
"
"function requestVotingRights ( uint _numTokens ) external { require ( token . balanceOf ( msg . sender ) >= _numTokens ) ; voteTokenBalance [ msg . sender ] += _numTokens ; require ( token . transferFrom ( msg . sender , this , _numTokens ) ) ; _VotingRightsGranted ( _numTokens , msg . sender ) ; }
","Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights
"
"function freezeTransfers ( ) public onlyOwner { require ( ! freeze ) ; freeze = true ; emit LogFreezeTransfers ( freeze , now ) ; }
","freeze all the transfers
"
"function checkPermission ( address _delegate , address _module , bytes32 _perm ) external view returns ( bool ) { if ( delegateDetails [ _delegate ] != bytes32 ( 0 ) ) { return perms [ _module ] [ _delegate ] [ _perm ] ; } else return false ; }
","Used to check the permission on delegate corresponds to module contract address
"
"function finalize ( ) external { if ( ! funding ) throw ; if ( ( block . number <= fundingEndBlock || totalTokens < tokenCreationMin ) && totalTokens < tokenCreationCap ) throw ; funding = false ; }
","Finalize crowdfunding
"
"function withdraw ( ) external returns ( bool ) { require ( _ended ) ; for ( uint i = 0 ; i < 100 ; ++ i ) { require ( _topBids [ i ] . bidderAddress != msg . sender ) ; } uint amount = _bidders [ msg . sender ] . value ; if ( amount > 0 ) { _bidders [ msg . sender ] . value = 0 ; msg . sender . transfer ( amount ) ; } return true ; }
","Withdraw your deposit at the end of the auction
"
"function distributeFixed ( uint index , address [ ] _addrs , uint _amoutToEach ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _amoutToEach ) ; } } else revert ( ""Distribution Failed: Coun Down not gone yet"" ) ; }
","Distributes a constant quantity of tokens to all the specified addresses .
"
"function deposit ( address _darknode , ERC20 _token , uint256 _value ) public payable { uint256 receivedValue = _value ; if ( address ( _token ) == ETHEREUM ) { require ( msg . value == _value , ""mismatched ether value"" ) ; } else { require ( msg . value == 0 , ""unexpected ether value"" ) ; receivedValue = CompatibleERC20 ( _token ) . safeTransferFromWithFees ( msg . sender , address ( this ) , _value ) ; } darknodeBalances [ _darknode ] [ _token ] = darknodeBalances [ _darknode ] [ _token ] . add ( receivedValue ) ; }
","Deposit fees into the vault for a Darknode .
"
"function transferFrom ( address from , address to , uint256 tokenAmount ) public tradable ( from ) returns ( bool success ) { require ( tokenAmount > 0 ) ; require ( tokenAmount <= balances [ from ] ) ; require ( tokenAmount <= allowed [ from ] [ msg . sender ] ) ; balances [ from ] = balances [ from ] . sub ( tokenAmount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( from , to , tokenAmount ) ; return true ; }
","Transfer tokens from an address to another one through an allowance made before
"
"function _mintItem ( uint256 _classId , address _address ) internal { ItemClass storage class = classIdToClass [ _classId ] ; uint [ ] memory stats = new uint [ ] ( 6 ) ; for ( uint j = 0 ; j < class . statsMin . length ; j ++ ) { if ( class . statsMax [ j ] > 0 ) { if ( stats . length == class . statsMin . length ) { stats [ j ] = getRandom ( class . statsMin [ j ] , class . statsMax [ j ] , uint8 ( j + _classId + class . total ) , lastMinter ) ; } } else { if ( stats . length == class . statsMin . length ) { stats [ j ] = 0 ; } } } ItemData storage _itemData = tokenToData [ totalTokens + 1 ] ; _itemData . tokenId = totalTokens + 1 ; _itemData . classId = _classId ; _itemData . stats = stats ; _itemData . gen = currentGen ; class . total += 1 ; totalTokens += 1 ; _mint ( _address , totalTokens ) ; _setTokenURI ( totalTokens , addToString ( _baseURI , uint2str ( totalTokens ) ) ) ; lastMinter = _address ; emit ItemMinted ( class . classId , class . price , class . total , totalTokens ) ; }
","All stats of the item are randomly generated by using the getRandom ( ) function using min and max values
"
"function importIssuerData ( address [ ] accounts , uint [ ] sUSDAmounts ) external onlyOwner onlyDuringSetup { require ( accounts . length == sUSDAmounts . length , ""Length mismatch"" ) ; for ( uint8 i = 0 ; i < accounts . length ; i ++ ) { _addToDebtRegister ( accounts [ i ] , sUSDAmounts [ i ] ) ; } }
","Import issuer data from the old Synthetix contract before multicurrency
"
"function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData ) internal { address senderImplementation = interfaceAddr ( _from , ""ERC777TokensSender"" ) ; if ( senderImplementation == 0 ) { return ; } ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _data , _operatorData ) ; }
","Helper function that checks for ERC777TokensSender on the sender and calls it .
"
"function tokenHardcapIssued ( ) public view returns ( uint ) { return tokenSoftcap + tokenHardcapIssuedValue ; }
","Gets absolute issued hardcap volume which means it will be greater than softcap value .
"
"function calculateMint ( uint256 _stakeNumber ) internal view returns ( uint256 reward ) { uint256 currentBlock = calculateCurrentBlock ( _stakeNumber ) ; uint256 lastBlockWithdrawn = stakes [ msg . sender ] [ _stakeNumber ] . lastBlockWithdrawn ; uint256 blocksToReward = currentBlock . sub ( lastBlockWithdrawn ) ; reward = blocksToReward . mul ( stakes [ msg . sender ] [ _stakeNumber ] . rewardPerBlock ) ; uint256 totalToMint = stakes [ msg . sender ] [ _stakeNumber ] . totalCoinsToMint ; uint256 currentCoinsMinted = stakes [ msg . sender ] [ _stakeNumber ] . coinsMinted ; uint256 newCoinsMinted = currentCoinsMinted . add ( reward ) ; if ( newCoinsMinted > totalToMint ) { reward = newCoinsMinted . sub ( totalToMint ) ; } }
","This is a helper function used to calculate how many coins will be awarded in a given internal
"
"function symbol ( ) external view returns ( string _symbol ) ;
","An abbreviated name for NFTs in this contract
"
"function _payDividend ( address _payee , Dividend storage _dividend , uint256 _dividendIndex ) internal { ( uint256 claim , uint256 withheld ) = calculateDividend ( _dividendIndex , _payee ) ; _dividend . claimed [ _payee ] = true ; _dividend . claimedAmount = claim . add ( _dividend . claimedAmount ) ; uint256 claimAfterWithheld = claim . sub ( withheld ) ; if ( claimAfterWithheld > 0 ) { require ( IERC20 ( dividendTokens [ _dividendIndex ] ) . transfer ( _payee , claimAfterWithheld ) , ""transfer failed"" ) ; _dividend . dividendWithheld = _dividend . dividendWithheld . add ( withheld ) ; investorWithheld [ _payee ] = investorWithheld [ _payee ] . add ( withheld ) ; emit ERC20DividendClaimed ( _payee , _dividendIndex , dividendTokens [ _dividendIndex ] , claim , withheld ) ; } }
","Internal function for paying dividends
"
"function broadcastSignedRequestAsPayerAction ( bytes _requestData , address [ ] _payeesPaymentAddress , uint256 [ ] _payeeAmounts , uint256 [ ] _additionals , uint256 _expirationDate , bytes _signature ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( _expirationDate >= block . timestamp , ""expiration should be after current time"" ) ; require ( Signature . checkRequestSignature ( _requestData , _payeesPaymentAddress , _expirationDate , _signature ) , ""signature should be correct"" ) ; return createAcceptAndPayFromBytes ( _requestData , _payeesPaymentAddress , _payeeAmounts , _additionals ) ; }
","Function to broadcast and accept an offchain signed request ( the broadcaster can also pays and makes additionals ) .
"
"function buyPriceAt ( uint256 _tokenAllocWithoutDiscount ) internal returns ( uint ) { if ( stageNow ( ) == stageAt . publicSale ) { publicAllocatingToken = publicAllocatingToken . add ( _tokenAllocWithoutDiscount ) ; require ( publicAllocatingToken <= publicSaleSupply ) ; return _tokenAllocWithoutDiscount ; } if ( stageNow ( ) == stageAt . privatePresale ) { uint _privatePresaleAlloc = _tokenAllocWithoutDiscount + percent ( _tokenAllocWithoutDiscount , 5 ) ; privatePresaleAllocatingToken = privatePresaleAllocatingToken . add ( _privatePresaleAlloc ) ; require ( privatePresaleAllocatingToken <= privatePresaleSupply ) ; return _privatePresaleAlloc ; } if ( stageNow ( ) == stageAt . privatePlacement ) { uint _privatePlacementAlloc = _tokenAllocWithoutDiscount + percent ( _tokenAllocWithoutDiscount , 10 ) ; privatePlacementAllocatingToken = privatePlacementAllocatingToken . add ( _privatePlacementAlloc ) ; require ( privatePlacementAllocatingToken <= privatePlacementSupply ) ; return _privatePlacementAlloc ; } if ( stageNow ( ) == stageAt . notStart ) { return 0 ; } if ( stageNow ( ) == stageAt . finalState ) { return 0 ; } }
","Calculate exchange : private Placement Stage : 10 % OFF private Presale Stage : 5 % OFF
"
"function getTagsByTypeAndToken ( uint8 _moduleType , address _securityToken ) external view returns ( bytes32 [ ] , address [ ] ) ;
","Returns all the tags related to the a module type which are valid for the given token
"
"function levelUp ( uint256 _factoryId ) public payable onlyExistingUser { Factory storage factory = factories [ _factoryId ] ; uint256 price = getPrice ( factory . ftype , factory . level + 1 ) ; uint256 userId = addressToUser [ msg . sender ] ; User storage user = users [ userId ] ; require ( _checkPayment ( user , factory . ftype , factory . level + 1 ) ) ; user . balance = user . balance . add ( msg . value ) ; user . balance = user . balance . sub ( price ) ; user . totalPay = user . totalPay . add ( price ) ; totalDeposit += msg . value ; _distributeInvestment ( msg . value ) ; _distributeReferrers ( userId , price ) ; _collectResource ( factory , user ) ; factory . level ++ ; _updateLeaders ( msg . sender , msg . value ) ; emit LevelUp ( _factoryId , factory . level , userId , price ) ; }
","level up for factory
"
"function vacate ( address _addr ) returns ( bool ) ;
","Vacate holder ` _addr `
"
"function checkBalance ( address _backerAddress , uint index ) constant returns ( uint , uint , bytes32 , bool , bool ) { return ( backers [ _backerAddress ] [ index ] . tokenPrice , backers [ _backerAddress ] [ index ] . tokenAmount , backers [ _backerAddress ] [ index ] . privateHash , backers [ _backerAddress ] [ index ] . prepaid , backers [ _backerAddress ] [ index ] . claimed ) ; }
","checking ` _backerAddress.address ( ) ` superDAO Token balance : ` index `
"
"function batchTransferFrom ( address [ ] spenders , address [ ] recipients , uint [ ] quantities ) external pausableIfNotSelfDestructing requireSameLength ( spenders . length , recipients . length ) requireSameLength ( recipients . length , quantities . length ) returns ( bool ) { uint length = spenders . length ; for ( uint i = 0 ; i < length ; i ++ ) { transferFrom ( spenders [ i ] , recipients [ i ] , quantities [ i ] ) ; } return true ; }
","Performs ERC20 transferFroms in batches ; for each ` i ` , transfers ` quantities [ i ] ` tokens from ` spenders [ i ] ` to ` recipients [ i ] ` if the sender is approved .
"
"function trimAddressArray ( address [ 11 ] addresses ) internal pure returns ( address [ ] ) { uint256 length = 0 ; for ( uint256 index = 0 ; index < 11 ; index ++ ) { if ( addresses [ index ] == 0x0 ) { continue ; } length ++ ; } address [ ] memory trimmedArray = new address [ ] ( length ) ; for ( index = 0 ; index < length ; index ++ ) { trimmedArray [ index ] = addresses [ index ] ; } return trimmedArray ; }
","Takes the static array , trims the excess and returns a dynamic array
"
"function round ( uint256 _n , uint256 _m ) internal pure returns ( uint256 ) { uint256 res = 0 ; uint256 p = _n / _m ; res = _n - ( _m * p ) ; if ( res >= 1 ) { res = p + 1 ; } else { res = p ; } return res ; }
","Round the operand to one decimal place
"
"function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) external returns ( address ) ;
","Deploys the token and adds default modules like permission manager and transfer manager .
"
"function canRelease ( address who ) public view returns ( bool ) { Holding memory holding = heldTokens [ who ] ; if ( holding . releaseDate == 0 || holding . quantity == 0 ) return false ; return block . timestamp > holding . releaseDate ; }
","Check if a user 's holding are eligible for release .
"
"function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens -= voterTokens ; challenges [ _challengeID ] . rewardPool -= reward ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; emit _RewardClaimed ( _challengeID , reward , msg . sender ) ; require ( token . transfer ( msg . sender , reward ) ) ; }
","Claim the tokens owed for the msg.sender in the provided challenge
"
"function votedPerCent ( address voter ) constant public returns ( uint ) { var rawVote = rawVotes [ voter ] ; if ( rawVote < MAX_AMOUNT_EQU_0_PERCENT ) return 0 ; else if ( rawVote >= MIN_AMOUNT_EQU_100_PERCENT ) return 100 ; else return rawVote * 100 / 1 ether ; }
","returns current voting result for given address in percent .
"
"function freezeAdministrationContract ( ) public onlyAdmin notFrozen returns ( bool frozen ) { administrationContractFrozen = true ; return true ; }
","used to freeze the administration contract
"
"function createAccountForUser ( address _newUser ) internal nonZero ( _newUser ) { registry . createNewAccount ( _newUser ) ; uint256 _accountId = registry . accountIdForAddress ( _newUser ) ; emit AccountCreated ( _accountId , _newUser ) ; }
","Create an account for a user and emit an event
"
"function burn ( uint256 _value ) checkGranularity ( _value ) public { adjustInvestorCount ( msg . sender , address ( 0 ) , _value ) ; require ( tokenBurner != address ( 0 ) , ""Token Burner contract address is not set yet"" ) ; require ( verifyTransfer ( msg . sender , address ( 0 ) , _value ) , ""Transfer is not valid"" ) ; require ( _value <= balances [ msg . sender ] , ""Value should no be greater than the balance of msg.sender"" ) ; adjustBalanceCheckpoints ( msg . sender ) ; adjustTotalSupplyCheckpoints ( ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; require ( tokenBurner . burn ( msg . sender , _value ) , ""Token burner process is not validated"" ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; emit Burnt ( msg . sender , _value ) ; emit Transfer ( msg . sender , address ( 0 ) , _value ) ; }
","Burn function used to burn the securityToken
"
"function register ( address _newAddress ) { keys [ msg . sender ] = _newAddress ; RegisterNewKey ( msg . sender , _newAddress ) ; }
","this is register a new address
"
"function claimTokens ( address _token ) external onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } SNKToken token = SNKToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function ownerWithdraw ( uint256 value ) external onlyOwner { if ( ! owner . send ( value ) ) revert ( ) ; }
","The owner can withdraw ethers already during Private Sale ,
"
"function withdraw ( address _address , uint256 _amount ) public onlyOwner returns ( bool ) { if ( deposited [ _address ] < _amount ) { error ( 'Escrow: not enough balance' ) ; return false ; } deposited [ _address ] = deposited [ _address ] . sub ( _amount ) ; return SCTokens . transfer ( _address , _amount ) ; }
","Withdraw funds from the tokens contract
"
"function setProtocolVersion ( address _STFactoryAddress , uint8 _major , uint8 _minor , uint8 _patch ) external ;
","Changing versions does not affect existing tokens .
"
"function getAttributeTypeIDs ( ) external view returns ( uint256 [ ] ) { return _attributeIDs ; }
","Get the IDs of all available attribute types on the jurisdiction .
"
"function initialiseMultisig ( address authority , uint unlockTime ) public payable returns ( bytes32 msigId ) { require ( msg . sender != authority ) ; require ( msg . value > 0 ) ; msigId = keccak256 ( msg . sender , authority , msg . value , unlockTime ) ; Multisig storage multisig = hashIdToMultisig [ msigId ] ; if ( multisig . deposit == 0 ) { multisig . owner = msg . sender ; multisig . authority = authority ; } reparametrizeMultisig ( msigId , unlockTime ) ; }
","Initialise and reparametrize Multisig
"
"function executeRequest ( uint id ) external pre_cond ( ! isShutDown ) pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( requests [ id ] . requestType != RequestType . redeem || requests [ id ] . shareQuantity <= balances [ requests [ id ] . participant ] ) pre_cond ( totalSupply == 0 || ( now >= add ( requests [ id ] . timestamp , module . pricefeed . getInterval ( ) ) && module . pricefeed . getLastUpdateId ( ) >= add ( requests [ id ] . atUpdateId , 2 ) ) ) { Request request = requests [ id ] ; require ( module . pricefeed . hasRecentPrice ( address ( request . requestAsset ) ) ) ; uint costQuantity = toWholeShareUnit ( mul ( request . shareQuantity , calcSharePriceAndAllocateFees ( ) ) ) ; if ( request . requestAsset == address ( NATIVE_ASSET ) ) { var ( isPriceRecent , invertedNativeAssetPrice , nativeAssetDecimal ) = module . pricefeed . getInvertedPrice ( address ( NATIVE_ASSET ) ) ; if ( ! isPriceRecent ) { revert ( ) ; } costQuantity = mul ( costQuantity , invertedNativeAssetPrice ) / 10 ** nativeAssetDecimal ; } if ( isInvestAllowed && request . requestType == RequestType . invest && costQuantity <= request . giveQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transferFrom ( request . participant , this , costQuantity ) ) ; createShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . redeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . tokenFallbackRedeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( this , request . shareQuantity ) ; } else { revert ( ) ; } }
","Executes active investment and redemption requests , in a way that minimises information advantages of investor
"
"function totalSupply ( ) external view returns ( uint256 ) { return rareArray . length - 1 ; }
","Count rare items tracked by this contract
"
"function inject ( address who , address origin ) external only_owner { s_paid [ who ] . push ( origin ) ; Paid ( who , origin ) ; }
","This method can only be called by the contract owner , and can be used to virtually create a new payment , by ` origin ` for ` who ` .
"
"function deposit ( address _user ) public payable isOpen depositIsConfigCompliant canDeposit ( _user ) { if ( ! invested [ _user ] ) { swimmersList . push ( _user ) ; invested [ _user ] = true ; } weiRaised = weiRaised . add ( msg . value ) ; swimmers [ _user ] = swimmers [ _user ] . add ( msg . value ) ; emit Deposit ( msg . sender , msg . value ) ; }
","Deposit Ether where the contribution is credited to the address specified in the parameter .
"
"function removeHandlerFromWhitelist ( address handler ) public onlyOwner handlerWhitelisted ( handler ) { delete handlerWhitelistMap [ handler ] ; for ( uint i = 0 ; i < handlerWhitelistArray . length ; i ++ ) { if ( handlerWhitelistArray [ i ] == handler ) { handlerWhitelistArray [ i ] = handlerWhitelistArray [ handlerWhitelistArray . length - 1 ] ; handlerWhitelistArray . length -= 1 ; break ; } } emit GenericEvent ( 2 ) ; }
","Remove an exchangeHandler address from the whitelist
"
"function setTokenMetadata ( uint256 _tokenId , string meta ) public onlyPlatform exists ( _tokenId ) { metadata [ _tokenId ] = MetaData ( meta ) ; }
","update metadata for token
"
"function performCalculations ( ) view returns ( uint gav , uint managementFee , uint performanceFee , uint unclaimedFees , uint feesShareQuantity , uint nav , uint sharePrice ) { gav = calcGav ( ) ; ( managementFee , performanceFee , unclaimedFees ) = calcUnclaimedFees ( gav ) ; nav = calcNav ( gav , unclaimedFees ) ; feesShareQuantity = ( gav == 0 ) ? 0 : mul ( totalSupply , unclaimedFees ) / gav ; uint totalSupplyAccountingForFees = add ( totalSupply , feesShareQuantity ) ; sharePrice = nav > 0 ? calcValuePerShare ( gav , totalSupplyAccountingForFees ) : toSmallestShareUnit ( 1 ) ; }
","Calculates essential fund metrics
"
"function balanceOf ( address _from ) public view returns ( uint balance ) { return balances [ _from ] ; }
","Returns balance of BTI Tokens .
"
"function withdraw ( address token , uint256 amount ) external { require ( amount > 0 ) ; require ( getTime ( ) > userLock [ msg . sender ] && userLock [ msg . sender ] != 0 ) ; balances [ token ] [ msg . sender ] = balances [ token ] [ msg . sender ] . sub ( amount ) ; if ( token == 0 ) { msg . sender . transfer ( amount ) ; } else { require ( ERC20 ( token ) . transfer ( msg . sender , amount ) ) ; } Withdraw ( token , msg . sender , amount , balances [ token ] [ msg . sender ] ) ; }
","must claim by lockme first , after a period of time it would be valid
"
"function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }
","Get the remaining allowance for a spender on a given address
"
"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
","Increase the amount of tokens that an owner allowed to a spender .
"
"function multiTransferTightlyPacked ( bytes32 [ ] _addressesAndAmounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addressesAndAmounts . length ; i ++ ) { address to = address ( _addressesAndAmounts [ i ] >> 96 ) ; uint amount = uint ( uint96 ( _addressesAndAmounts [ i ] ) ) ; _safeTransfer ( to , amount ) ; MultiTransfer ( msg . sender , msg . value , to , amount ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }
","Send to multiple addresses using a byte32 array which includes the address and the amount .
"
"function withdrawEth ( address to , uint256 value ) onlyOwner public { to . transfer ( value ) ; }
","withdraw eth
"
"function writeSha3 ( string calldata _permlink , bytes32 _hashSha ) external returns ( bool ) { bytes32 hash = calculateSha3 ( _permlink ) ; require ( ! permlinkSaved [ hash ] , ""Permalink already exist!"" ) ; permlinkSaved [ hash ] = true ; emit SynpatRecord ( _permlink , _hashSha ) ; return true ; }
","Make event record in Ethereumblockchain
"
"function burn ( uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function revealPeriodActive ( uint _pollID ) constant public returns ( bool active ) { require ( pollExists ( _pollID ) ) ; return ! isExpired ( pollMap [ _pollID ] . revealEndDate ) && ! commitPeriodActive ( _pollID ) ; }
","Checks if the reveal period is still active for the specified poll
"
"function balanceOf ( address _owner ) public view returns ( uint256 ) { uint256 balance = balances [ _owner ] ; for ( uint cellIndex = 0 ; cellIndex < frozenBalances [ _owner ] . length ; ++ cellIndex ) { balance = balance . add ( frozenBalances [ _owner ] [ cellIndex ] . amount ) ; } return balance ; }
","Version of balanceOf ( ) which includes all frozen tokens .
"
"function selfDestruct ( ) external onlyOwner { require ( selfDestructInitiated , ""Self-destruct not yet initiated."" ) ; require ( selfDestructInitiationTime + SELFDESTRUCT_DELAY < now , ""Self-destruct delay has not yet elapsed."" ) ; address beneficiary = selfDestructBeneficiary ; emit SelfDestructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; }
","If the self-destruction delay has elapsed , destroy this contract and remit any ether it owns to the beneficiary address .
"
"function transferAdminship ( address _newAdmin ) onlyAdmin public { admin = _newAdmin ; TransferAdminship ( admin ) ; }
","This function transfer the adminship of the contract to _newAdmin
"
"function proposal ( uint _proposalId ) public view returns ( address _proposer , uint _startBlock , uint _startTime , uint _duration , bytes32 _storageHash , bool _active , bool _finalized , uint _totalYes , uint _totalNo , address _token , bool _approved , bool _denied , bool _hasBalance ) { require ( _proposalId < proposals . length ) ; Proposal memory p = proposals [ _proposalId ] ; _proposer = p . proposer ; _startBlock = p . startBlock ; _startTime = p . startTime ; _duration = p . duration ; _storageHash = p . storageHash ; _finalized = ( _startTime + _duration < now ) ; _active = ! _finalized && ( p . startBlock < getBlockNumber ( ) ) && p . approved ; _totalYes = p . yesVotes ; _totalNo = p . noVotes ; _token = p . token ; _approved = p . approved ; _denied = p . denied ; _hasBalance = ( p . token == 0x0 ) ? false : ( MiniMeToken ( p . token ) . balanceOf ( msg . sender ) > 0 ) ; }
","Get data about specific proposal
"
"function getAttackRanking ( ) external view returns ( address [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint counter = 0 ; for ( uint k = 0 ; k < len ; k ++ ) { ( , , , arr [ counter ] ) = getPlayersBattleStats ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; counter ++ ; } for ( uint i = 0 ; i < len - 1 ; i ++ ) { for ( uint j = 0 ; j < len - i - 1 ; j ++ ) { if ( arr [ j ] < arr [ j + 1 ] ) { uint256 temp = arr [ j ] ; address temp_addr = arr_addr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; arr_addr [ j ] = arr_addr [ j + 1 ] ; arr_addr [ j + 1 ] = temp_addr ; } } } return ( arr_addr , arr ) ; }
","battle power ranking
"
"function changeMinter ( address newMinter ) public validate_address ( newMinter ) onlyAdmin { if ( minter == newMinter ) revert ( ) ; MinterOwnershipTransferred ( minter , newMinter ) ; minter = newMinter ; }
","only the admin is allowed to change the minter .
"
"function onBurn ( address _owner , uint _tokensToBurn ) public returns ( bool ) { require ( msg . sender == address ( tokenContract ) ) ; uint256 feeTotal = tokenContract . totalPledgedFees ( ) ; uint256 totalTokens = tokenContract . totalSupply ( ) ; uint256 feeValueOfTokens = ( feeTotal . mul ( _tokensToBurn ) ) . div ( totalTokens ) ; require ( tokenContract . destroyTokens ( _owner , _tokensToBurn ) ) ; require ( this . balance >= feeValueOfTokens ) ; require ( _owner . send ( feeValueOfTokens ) ) ; LogClaim ( _owner , feeValueOfTokens ) ; return true ; }
","Notifies the controller about a burn attempt .
"
"function reissueAsset ( bytes32 _symbol , uint _value ) public returns ( uint ) { return reissueAssetToRecepient ( _symbol , _value , msg . sender ) ; }
","Issues additional asset tokens if the asset have dynamic supply .
"
"function getModulesByType ( uint8 _moduleType ) external view returns ( address [ ] ) ;
","Returns the list of addresses of Module Factory of a particular type
"
"function unlock ( ) public { unlockInvestor ( msg . sender ) ; }
","unlocks investors funds , see unlockInvestor for details
"
"function tokenByIndex ( uint256 _index ) external pure returns ( uint256 ) { return _index ; }
","Enumerate valid NFTs
"
"function sell ( uint256 quantity , uint256 price , uint256 expiry ) public { require ( quantity > 0 , ""You must supply a quantity."" ) ; require ( price > 0 , ""The sale price cannot be zero."" ) ; require ( expiry > block . timestamp , ""Cannot have an expiry date in the past."" ) ; require ( price >= sellFloor , ""The ask is below the minimum allowed."" ) ; require ( sellCeiling == 0 || price <= sellCeiling , ""The ask is above the maximum allowed."" ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , ""You must approve the transfer of tokens before offering them for sale."" ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , ""Not enough tokens owned to complete the order."" ) ; orderBook [ msg . sender ] = TradeOrder ( quantity , price , expiry ) ; emit TokensOffered ( msg . sender , quantity , price , expiry ) ; }
","Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .
"
"function burnAllTokens ( ) public onlyOwner mustBeAtStage ( Stage . Finalized ) { uint thisTokenBalance = token . balanceOf ( address ( this ) ) ; if ( thisTokenBalance > 0 ) { token . burn ( thisTokenBalance ) ; } }
","Get the token balance of this contract and burns all tokens
"
"function setMyICOContract ( address _SCICO ) public onlyOwner { addressSCICO = _SCICO ; }
","The owner can specify which ICO contract is allowed to transfer tokens while timelock is on
"
"function approve ( address _spender , uint256 _amount ) stopOnPause public returns ( bool success ) { require ( _spender != 0x0 ) ; allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
","gives ` _spender ` allowance to spend ` amount ` from sender 's balance .
"
"function burn ( uint256 _value ) onlyowner public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; totalHurify = safeSub ( totalHurify , _value ) ; Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == INTERFACE_SIGNATURE_ERC165 ) || ( _interfaceID == INTERFACE_SIGNATURE_ERC721 ) ) ; }
","Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
"
"function bookCanvasFor ( uint32 _canvasId , address _bookFor ) external onlyOwner { Canvas storage _canvas = _getCanvas ( _canvasId ) ; _canvas . bookedFor = _bookFor ; }
","Changes canvas.bookFor variable .
"
"function sell ( uint256 amount ) public { require ( balanceOf [ msg . sender ] >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
","Sell ` amount ` tokens to contract
"
"function notifyOfArbitrationRequest ( bytes32 question_id , address requester , uint256 max_previous ) onlyArbitrator ( question_id ) stateOpen ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external { require ( questions [ question_id ] . bond > 0 , ""Question must already have an answer when arbitration is requested"" ) ; questions [ question_id ] . is_pending_arbitration = true ; emit LogNotifyOfArbitrationRequest ( question_id , requester ) ; }
","Notify the contract that the arbitrator has been paid for a question , freezing it pending their decision .
"
"function burn ( uint256 _value ) public onlyOwner returns ( bool success ) { require ( ! _frozenAccount [ _owner ] ) ; require ( _balanceOf [ _owner ] >= _value ) ; _balanceOf [ _owner ] -= _value ; _totalSupply -= _value ; Burn ( _owner , _value ) ; return true ; }
","Destroy tokens from owener account , can be run only by owner Remove ` _value ` tokens from the system irreversibly
"
"function getForwardedAccount ( Data storage self , address account ) internal view returns ( address registeredAccount ) { bytes32 id = keccak256 ( abi . encodePacked ( 'master.account' , account ) ) ; address originalAccount = self . Storage . getAddress ( id ) ; if ( originalAccount != 0x0 ) { return originalAccount ; } else { return account ; } }
","Get the original address for a forwarded account
"
"function changeFactorySetupFee ( uint256 _newSetupCost ) public onlyOwner { emit LogChangeFactorySetupFee ( setupCost , _newSetupCost , address ( this ) ) ; setupCost = _newSetupCost ; }
","used to change the fee of the setup cost
"
"function distribute ( uint256 _amount ) external onlyContract ( ""FeeManager"" ) returns ( bool ) { totalMintedActPerLockedBbkToken = totalMintedActPerLockedBbkToken . add ( _amount . mul ( 1e18 ) . div ( totalLockedBBK ) ) ; uint256 _delta = ( _amount . mul ( 1e18 ) % totalLockedBBK ) . div ( 1e18 ) ; mintedActFromPastLockPeriodsPerUser [ owner ] = mintedActFromPastLockPeriodsPerUser [ owner ] . add ( _delta ) ; totalSupply_ = totalSupply_ . add ( _amount ) ; emit Mint ( _amount ) ; return true ; }
","Distribute ACT tokens to all BBK token holders , that have currently locked their BBK tokens into this contract .
"
"function isRegisteredFirm ( Data storage self , string issuerFirm ) internal view returns ( bool registered ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.firm' , issuerFirm ) ) ; return self . Storage . getBool ( id ) ; }
","Return the boolean ( true/false ) registration status for an issuer firm
"
"function buy_energy ( address aproducer , uint32 aday , uint32 aprice , uint64 aenergy ) onlyRegisteredConsumers external { buy_energy_core ( aproducer , aday , aprice , aenergy , consumers [ msg . sender ] , 0 ) ; }
","Buy ` ( aenergy / 1.0e6 ) .toFixed ( 6 ) ` kWh of energy on for day ` aday ` at a surcharge ` ( aprice / 1.0e3 ) .toFixed ( 3 ) ` ct/kWh from the energy producer using the address ` aproducer.address ( ) ` .
"
"function giftAsset ( address _to , uint256 _tokenId ) public whenNotPaused { safeTransferFrom ( msg . sender , _to , _tokenId ) ; }
","Transfers the ownership of NFT from one address to another address
"
"function getTitle ( ) public view returns ( string ) { return ""Ether Dividend Checkpoint"" ; }
","Get the title of the Module
"
"function totalSupply ( ) constant public returns ( uint256 _total_supply ) { _total_supply = TokenInfoController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_INFO ) ) . get_total_supply ( ) ; }
","show the total supply of gold tokens
"
"function setIcosMinLimit ( uint256 newIcoMin , uint256 newPreIcoLimit ) isOwner { require ( newIcoMin > 0 ) ; require ( newPreIcoLimit > 0 ) ; icoMin = newIcoMin ; preIcoLimit = newPreIcoLimit ; updatePrices ( ) ; }
","Set both ico min at the same time
"
"function enableScriptExecutor ( uint256 _executorId ) external authP ( REGISTRY_MANAGER_ROLE , arr ( _executorId ) ) executorExists ( _executorId ) { ExecutorEntry storage executorEntry = executors [ _executorId ] ; require ( ! executorEntry . enabled , ERROR_EXECUTOR_ENABLED ) ; executorEntry . enabled = true ; emit EnableExecutor ( _executorId , executorEntry . executor ) ; }
","Enable script executor with ID ` _executorId `
"
"function mint ( address _holder , uint256 _tokens ) public onlyMintingAgents ( ) { require ( allowedMinting == true && totalSupply_ . add ( _tokens ) <= maxSupply ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ _holder ] = balances [ _holder ] . add ( _tokens ) ; if ( totalSupply_ == maxSupply ) { allowedMinting = false ; } emit Transfer ( address ( 0 ) , _holder , _tokens ) ; emit Mint ( _holder , _tokens ) ; }
","allow to mint tokens
"
"function tokenFallback ( address from , uint amount , bytes data ) external onlyNomin returns ( bool ) { if ( amount < minimumDepositAmount ) { smallDeposits [ from ] = safeAdd ( smallDeposits [ from ] , amount ) ; emit NominDepositNotAccepted ( from , amount , minimumDepositAmount ) ; } else { deposits [ depositEndIndex ] = nominDeposit ( { user : from , amount : amount } ) ; depositEndIndex = safeAdd ( depositEndIndex , 1 ) ; totalSellableDeposits = safeAdd ( totalSellableDeposits , amount ) ; emit NominDeposit ( from , amount ) ; } }
","Triggers when users send us HAV or nUSD , but the modifier only allows nUSD calls to proceed .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( _getApproved ( _tokenId ) == msg . sender ) ; require ( _ownerOf ( _tokenId ) == _from ) ; require ( _to != address ( 0 ) ) ; _clearApprovalAndTransfer ( _from , _to , _tokenId ) ; Approval ( _from , 0 , _tokenId ) ; Transfer ( _from , _to , _tokenId ) ; }
","Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
"
"function transfer ( address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; uint fees = calculateFees ( amount ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( msg . sender ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( to ) ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.balance' , currency , lib . getForwardedAccount ( feeContract ) ) ) ; require ( lib . Storage . setUint ( id_a , lib . Storage . getUint ( id_a ) . sub ( amount . add ( fees ) ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( lib . Storage . setUint ( id_b , lib . Storage . getUint ( id_b ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( lib . Storage . setUint ( id_c , lib . Storage . getUint ( id_c ) . add ( fees ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; emit Transfer ( msg . sender , to , amount ) ; return true ; }
","transfers 'amount ' from msg.sender to a receiving account 'to '
"
"function holdersCount ( ) public view returns ( uint256 ) { return holders . length ; }
","Get the count of holders
"
"function deregisterToken ( uint32 _tokenCode ) external onlyOwner ;
","Sets a token as being deregistered .
"
"function sendPendingAmounts ( uint _from , uint _to , address _buyer ) returns ( bool ) ;
","Function to send tokens or refund after the closing time of the funding proposals
"
"function getBool ( bytes32 _key ) public view returns ( bool _value ) { return boolStorage [ _key ] ; }
","Get value for Bool associated with bytes32 id key
"
"function acceptTermsAndJoinDXF ( ) payable external { if ( now > startingDateFunding + 365 days ) throw ; if ( ! dxfOpen ) throw ; if ( vips [ msg . sender ] ) throw ; if ( msg . value < 10 ether ) throw ; if ( msg . value > ( tokensCreationCap - totalTokens ) ) throw ; if ( msg . value > ( 10000 ether - balances [ msg . sender ] ) ) throw ; if ( balances [ msg . sender ] == 0 ) { newMember ( msg . sender ) ; indexMembers [ msg . sender ] = members . length ; members . push ( Member ( msg . sender , now , msg . value ) ) ; } else { members [ indexMembers [ msg . sender ] ] . initial_value += msg . value ; } if ( members . length > maxNumberMembers ) throw ; if ( multisigDXF == 0 ) throw ; if ( ! multisigDXF . send ( msg . value ) ) throw ; uint numTokens = msg . value ; totalTokens += numTokens ; if ( ( tokensCreationCap - totalTokens ) < remainingTokensVIPs ) throw ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
","By using this function you accept the terms of DXF
"
"function createAndJoinCDPDai ( uint amount ) public auth stoppable returns ( bytes32 id ) { require ( amount >= minDai ) ; uint price = uint ( feed . read ( ) ) ; require ( dai . transferFrom ( msg . sender , this , amount ) ) ; uint bought = otc . sellAllAmount ( dai , amount , gem , wmul ( WAD - slippage , wdiv ( amount , price ) ) ) ; id = _openAndJoinCDPWETH ( bought ) ; tub . give ( id , msg . sender ) ; }
","create a CDP from the given amount of Dai in the sender 's balance - needs Dai transfer approval
"
"function deedsOfOwner ( address _owner ) external view returns ( uint256 [ ] ) { uint256 deedCount = countOfDeedsByOwner ( _owner ) ; if ( deedCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( deedCount ) ; uint256 totalDeeds = countOfDeeds ( ) ; uint256 resultIndex = 0 ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = plots [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { result [ resultIndex ] = identifier ; resultIndex ++ ; } } return result ; } }
","Returns a list of all deed identifiers assigned to an address .
"
"function newRepo ( string _name , address _dev ) auth ( CREATE_REPO_ROLE ) public returns ( Repo ) { return _newRepo ( _name , _dev ) ; }
","Create new repo in registry with ` _name `
"
"function changeVersion ( string _newVersion ) public onlyOwner { require ( bytes ( _newVersion ) . length > 0 , ""Invalid version"" ) ; version = _newVersion ; }
","Updates the version of the ModuleFactory
"
"function initialiseMultisig ( address authority , uint unlockTime ) public payable returns ( bytes32 msigId ) { require ( msg . sender != authority ) ; require ( msg . value > 0 ) ; msigId = keccak256 ( msg . sender , authority , msg . value , unlockTime ) ; Multisig storage multisig = multisigs [ msigId ] ; if ( multisig . deposit == 0 ) { multisig . owner = msg . sender ; multisig . authority = authority ; } reparametrizeMultisig ( msigId , unlockTime ) ; }
","Initialise and reparametrize Multisig
"
"function removeTicker ( string _ticker ) external onlyOwner { string memory ticker = Util . upper ( _ticker ) ; address owner = _tickerOwner ( ticker ) ; require ( owner != address ( 0 ) , ""Ticker doesn't exist"" ) ; _deleteTickerOwnership ( owner , ticker ) ; set ( Encoder . getKey ( ""tickerToSecurityToken"" , ticker ) , address ( 0 ) ) ; _storeTickerDetails ( ticker , address ( 0 ) , 0 , 0 , """" , false ) ; emit TickerRemoved ( ticker , now , msg . sender ) ; }
","Removes the ticker details , associated ownership & security token mapping
"
"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""insufficent allowance"" ) ; address erc20DividendCheckpoint = new ERC20DividendCheckpoint ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( erc20DividendCheckpoint , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return erc20DividendCheckpoint ; }
","Used to launch the Module with the help of factory
"
"function getItem ( uint256 _tokenId ) public view returns ( string itemName , uint256 sellingPrice , address owner , bytes32 itemMessage ) { Item storage item = items [ _tokenId ] ; itemName = item . name ; itemMessage = item . message ; sellingPrice = itemIndexToPrice [ _tokenId ] ; owner = itemIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific item .
"
"function matchTokenOrderByAdmin_k44j ( uint256 [ ] inputs ) external onlyAdmin { address user = userId2Address [ decodeOrderUserId ( inputs [ 3 ] ) ] ; require ( inputs [ 3 ] >> 224 > userNonce [ user ] ) ; address token ; address base ; bool isBuy ; ( token , base , isBuy ) = decodeTokenOrderTokenAndIsBuy ( inputs [ 3 ] ) ; bytes32 orderHash = getTokenOrderDataHash ( inputs , 0 , inputs [ 3 ] , token , base ) ; require ( verify ( orderHash , user , uint8 ( retrieveV ( inputs [ 3 ] ) ) , bytes32 ( inputs [ 4 ] ) , bytes32 ( inputs [ 5 ] ) ) ) ; uint256 tokenExecute = isBuy ? inputs [ 1 ] : inputs [ 0 ] ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; require ( tokenExecute != 0 ) ; uint256 baseExecute = 0 ; isBuy = ! isBuy ; for ( uint256 i = 6 ; i < inputs . length ; i += 6 ) { require ( tokenExecute > 0 && inputs [ 1 ] . mul ( inputs [ i + 1 ] ) <= inputs [ 0 ] . mul ( inputs [ i ] ) ) ; user = userId2Address [ decodeOrderUserId ( inputs [ i + 3 ] ) ] ; require ( inputs [ i + 3 ] >> 224 > userNonce [ user ] ) ; bytes32 makerOrderHash = getTokenOrderDataHash ( inputs , i , inputs [ i + 3 ] , token , base ) ; require ( verify ( makerOrderHash , user , uint8 ( retrieveV ( inputs [ i + 3 ] ) ) , bytes32 ( inputs [ i + 4 ] ) , bytes32 ( inputs [ i + 5 ] ) ) ) ; ( tokenExecute , baseExecute ) = internalTrade ( inputs [ i ] , inputs [ i + 1 ] , inputs [ i + 2 ] , inputs [ i + 3 ] , tokenExecute , baseExecute , isBuy , token , base , makerOrderHash ) ; } isBuy = ! isBuy ; tokenExecute = isBuy ? inputs [ 1 ] . sub ( tokenExecute ) : inputs [ 0 ] . sub ( tokenExecute ) ; tokenExecute = tokenExecute . sub ( orderFills [ orderHash ] ) ; processTakerOrder ( inputs [ 2 ] , inputs [ 3 ] , tokenExecute , baseExecute , isBuy , token , base , orderHash ) ; }
","match token orders with admins involved , only admin
"
"function performCalculations ( ) view returns ( uint gav , uint managementFee , uint performanceFee , uint unclaimedFees , uint feesShareQuantity , uint nav , uint sharePrice ) { gav = calcGav ( ) ; ( managementFee , performanceFee , unclaimedFees ) = calcUnclaimedFees ( gav ) ; nav = calcNav ( gav , unclaimedFees ) ; feesShareQuantity = ( gav == 0 ) ? 0 : mul ( totalSupply , unclaimedFees ) / gav ; uint totalSupplyAccountingForFees = add ( totalSupply , feesShareQuantity ) ; sharePrice = nav > 0 ? calcValuePerShare ( nav , totalSupplyAccountingForFees ) : toSmallestShareUnit ( 1 ) ; }
","Calculates essential fund metrics
"
"function buyToken ( ) internal { uint256 value = msg . value ; address sender = msg . sender ; require ( ! icoIsClosed ) ; require ( ! frozenAccount [ sender ] ) ; require ( value > 0 ) ; require ( currentTokenPrice > 0 ) ; uint256 amount = value / currentTokenPrice ; uint256 moneyBack = value - ( amount * currentTokenPrice ) ; require ( tokenBalanceOf [ this ] >= amount ) ; amountOfInvestments = amountOfInvestments + ( value - moneyBack ) ; updatePrices ( ) ; _transfer ( this , sender , amount ) ; if ( ! minimalGoalReached ) { checkMinimalGoal ( ) ; } if ( moneyBack > 0 ) { sender . transfer ( moneyBack ) ; } }
","Processing each buying
"
"function ownerOf ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( address ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return owner ; }
","Get the owner of PixelCon ` ( _tokenId ) `
"
"function changeSTVersionBounds ( string _boundType , uint8 [ ] _newVersion ) external onlyOwner { require ( keccak256 ( abi . encodePacked ( _boundType ) ) == keccak256 ( abi . encodePacked ( ""lowerBound"" ) ) || keccak256 ( abi . encodePacked ( _boundType ) ) == keccak256 ( abi . encodePacked ( ""upperBound"" ) ) , ""Must be a valid bound type"" ) ; require ( _newVersion . length == 3 ) ; if ( compatibleSTVersionRange [ _boundType ] != uint24 ( 0 ) ) { uint8 [ ] memory _currentVersion = VersionUtils . unpack ( compatibleSTVersionRange [ _boundType ] ) ; require ( VersionUtils . isValidVersion ( _currentVersion , _newVersion ) , ""Failed because of in-valid version"" ) ; } compatibleSTVersionRange [ _boundType ] = VersionUtils . pack ( _newVersion [ 0 ] , _newVersion [ 1 ] , _newVersion [ 2 ] ) ; emit ChangeSTVersionBound ( _boundType , _newVersion [ 0 ] , _newVersion [ 1 ] , _newVersion [ 2 ] ) ; }
","Function use to change the lower and upper bound of the compatible version st
"
"function initiate ( bytes32 _swapID , address _withdrawTrader , bytes32 _secretLock , uint256 _timelock ) external onlyInvalidSwaps ( _swapID ) payable { Swap memory swap = Swap ( { timelock : _timelock , value : msg . value , ethTrader : msg . sender , withdrawTrader : _withdrawTrader , secretLock : _secretLock , secretKey : 0x0 } ) ; swaps [ _swapID ] = swap ; swapStates [ _swapID ] = States . OPEN ; emit LogOpen ( _swapID , _withdrawTrader , _secretLock ) ; }
","Initiates the atomic swap .
"
"function destroyContract ( ) public onlyOwner { selfdestruct ( owner ) ; }
","Terminate contract and send any ETH left in contract to owner
"
"function buy ( ) payable public { require ( ! frozenAccount [ msg . sender ] ) ; require ( msg . value > 0 ) ; commission = msg . value / commissionRate ; require ( address ( this ) . send ( commission ) ) ; buyToken ( ) ; }
","Buy tokens from contract by sending ether
"
"function UnfreezeAccount ( address toUnfreeze ) onlyOwner public { delete frozenAccounts [ toUnfreeze ] ; }
","allow specified address sending & receiving tokens
"
"function canRevokeAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) ;
","Check if the validator is approved to revoke an attribute of the type with ID ` attributeTypeID ` from account ` account ` on the jurisdiction .
"
"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F41 ) , _token , _to , _value , _fee , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by transferPreSigned
"
"function getLastDeedTimestampByAddress ( string propertyAddress ) public constant returns ( uint256 ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; string memory deed = addressRegistry [ propertyAddressHash ] [ addressRegistry [ propertyAddressHash ] . length - 1 ] ; return getDeedTimestamp ( deed ) ; }
","Gets the last deed registration timestamp by property address
"
"function getMaximumFunds ( ) internal constant returns ( uint ) { return 100000000 ether ; }
","maximum investments to be accepted during pre-ICO
"
"function unlockInvestor ( address investor ) private { Account memory accountInMem = _accounts [ investor ] ; if ( accountInMem . balance == 0 ) { return ; } removeInvestor ( investor , accountInMem . balance ) ; require ( NEUMARK . transferFrom ( investor , address ( this ) , accountInMem . neumarksDue ) ) ; NEUMARK . burn ( accountInMem . neumarksDue ) ; if ( block . timestamp < accountInMem . unlockDate ) { address penaltyDisbursalAddress = UNIVERSE . feeDisbursal ( ) ; require ( penaltyDisbursalAddress != address ( 0 ) ) ; uint112 penalty = uint112 ( decimalFraction ( accountInMem . balance , PENALTY_FRACTION ) ) ; assert ( PAYMENT_TOKEN . transfer ( penaltyDisbursalAddress , penalty , abi . encodePacked ( NEUMARK ) ) ) ; emit LogPenaltyDisbursed ( penaltyDisbursalAddress , investor , penalty , PAYMENT_TOKEN ) ; accountInMem . balance -= penalty ; } assert ( PAYMENT_TOKEN . transfer ( investor , accountInMem . balance , """" ) ) ; emit LogFundsUnlocked ( investor , accountInMem . balance , accountInMem . neumarksDue ) ; }
","unlocks 'investor ' tokens by making them withdrawable from paymentToken
"
"function successful ( ) public { require ( state == State . Successful ) ; if ( ended == false ) { ended = true ; uint256 remanent = hardCap . sub ( totalDistributed ) ; require ( tokenReward . burnToken ( remanent ) ) ; } creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
","successful closure handler
"
"function getCryptoAvatar ( uint256 _id ) external view returns ( uint256 statistics , uint256 avatarType , uint256 level , uint256 experience , uint256 creationTime , bool isHibernated ) { require ( exists ( _id ) ) ; CryptoAvatar storage avatar = avatars [ _id ] ; statistics = uint256 ( avatar . statistics ) ; avatarType = uint256 ( avatar . avatarType ) ; level = uint256 ( avatar . level ) ; experience = uint256 ( avatar . experience ) ; creationTime = uint256 ( avatar . creationTime ) ; isHibernated = avatar . isHibernated ; }
","Returns all the relevant information about a specific avatar .
"
"function schedulePriceUpdatesRolling ( uint256 _startTime , uint256 _interval , uint256 _iters ) payable isAdminOrOwner public { bytes32 requestId ; require ( oraclize_getPrice ( ""URL"" ) * _iters <= address ( this ) . balance , ""Insufficient Funds"" ) ; for ( uint256 i = 0 ; i < _iters ; i ++ ) { uint256 scheduledTime = _startTime + ( i * _interval ) ; requestId = oraclize_query ( scheduledTime , ""URL"" , oracleURL , gasLimit ) ; requestIds [ requestId ] = scheduledTime ; emit LogNewOraclizeQuery ( scheduledTime , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } }
","Allows owner to schedule future Oraclize calls on a rolling schedule
"
"function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) ;
","Enumerate valid NFTs
"
"function endAuction ( ) external { require ( block . number >= _auctionEnd ) ; require ( ! _ended ) ; _ended = true ; AuctionEnded ( _topBids [ 0 ] . bidderAddress , _topBids [ 0 ] . bid , _topBids [ 1 ] . bidderAddress , _topBids [ 1 ] . bid , _topBids [ 2 ] . bidderAddress , _topBids [ 2 ] . bid ) ; }
","End the auction , allowing the withdrawal of ether and tokens
"
"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { return doTransfer ( msg . sender , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function claimAddress ( address _address ) public isCompleted userHasFundedPool ( _address ) { for ( uint256 i = 0 ; i < tokenAddress . length ; ++ i ) { ERC20Basic token = ERC20Basic ( tokenAddress [ i ] ) ; uint256 poolTokenBalance = token . balanceOf ( this ) ; payoutTokensInternal ( _address , poolTokenBalance , token ) ; } }
","Process a claim function for a specified address .
"
"function _transferSenderPaysFee_byProxy ( address sender , address to , uint value , bytes data ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; return _internalTransfer ( sender , to , value , fee , data ) ; }
","Ability to transfer where the sender pays the fees ( not ERC20 )
"
"function transferFromAndCall ( address _from , address _to , uint256 _value , bytes _data ) public returns ( bool ) ;
","Transfer tokens from one address to another and then call ` onTransferReceived ` on receiver
"
"function changeIssuanceAddress ( address _issuanceAddress ) public withPerm ( FLAGS ) { issuanceAddress = _issuanceAddress ; emit ChangeIssuanceAddress ( _issuanceAddress ) ; }
","Used to change the Issuance Address
"
"function verifyOpenSignature ( address _trader , bytes _signature , bytes32 _orderID ) external returns ( bool ) ;
","The function signature that will be called when a trader opens an order .
"
"function ( ) payable { contribute ( msg . sender ) ; }
","Fallback function which implements how miners participate in BTH
"
"function transferProfitToHouse ( ) public { require ( lastProfitTransferTimestamp + profitTransferTimeSpan <= block . timestamp ) ; lastProfitTransferTimestamp = block . timestamp ; if ( houseProfit <= 0 ) { return ; } uint toTransfer = uint ( houseProfit ) ; assert ( houseStake >= toTransfer ) ; houseProfit = 0 ; houseStake = houseStake - toTransfer ; houseAddress . transfer ( toTransfer ) ; }
","Transfer house profit to houseAddress .
"
"function countAttributeTypes ( ) external view returns ( uint256 ) ;
","Count the number of attribute types defined by the registry .
"
"function claimEth ( ) public { require ( state == State . Successful ) ; require ( msg . sender == creator ) ; require ( creator . send ( this . balance ) ) ; }
","Function to claim any eth stuck on contract
"
"function drop ( address [ ] holders ) external returns ( bool ) { for ( uint256 i = 0 ; i < holders . length ; i ++ ) { address holder = holders [ i ] ; if ( ! isAirdropped ( holder ) ) { uint256 balance = balances [ holder ] ; undropped = undropped . sub ( balance ) ; balances [ holder ] = airdropAmount ( balance ) ; uint256 amount = balances [ holder ] . sub ( balance ) ; totalSupply_ = totalSupply_ . add ( amount ) ; Transfer ( address ( 0 ) , holder , amount ) ; setAirdropped ( holder ) ; } } }
","Execute airdrop for a bunch of addresses .
"
"function setICOEndDate ( uint _date ) external onlyAdmin returns ( bool ) { require ( icoEndDate == 0 , ""The ICO end date was already set."" ) ; icoEndDate = _date ; emit ICOEndDateSet ( _date ) ; return true ; }
","This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .
"
"function totalSupply ( ) constant returns ( uint256 totalAmount ) { totalAmount = _totalSupply ; }
","Returns a whole amount of tokens
"
"function addr ( bytes _hash , bytes _signature ) internal pure returns ( address ) { bytes memory prefix = ""\x19Ethereum Signed Message:\n"" ; bytes memory encoded = abi . encodePacked ( prefix , uintToBytes ( _hash . length ) , _hash ) ; bytes32 prefixedHash = keccak256 ( encoded ) ; return ECRecovery . recover ( prefixedHash , _signature ) ; }
","Retrieves the address from a signature
"
"function deedUri ( uint256 _deedId ) external pure returns ( string uri ) { require ( validIdentifier ( _deedId ) ) ; var ( x , y ) = identifierToCoordinate ( _deedId ) ; uri = ""https://dworld.io/plot/xxxxx/xxxxx"" ; bytes memory _uri = bytes ( uri ) ; for ( uint256 i = 0 ; i < 5 ; i ++ ) { _uri [ 27 - i ] = byte ( 48 + ( x / 10 ** i ) % 10 ) ; _uri [ 33 - i ] = byte ( 48 + ( y / 10 ** i ) % 10 ) ; } }
","Returns an ( off-chain ) metadata url for the given deed .
"
"function tokensOf ( address owner ) external view returns ( uint256 [ ] ) ;
","Get all tokens of a given address
"
"function subDefence ( uint256 _playerDefencePoints , uint256 _x ) internal pure returns ( uint256 ) { return ( _playerDefencePoints <= _x ) ? 1 : _playerDefencePoints - _x ; }
","Subtracts ability points .
"
"function finalizeCrowdsale ( ) public onlyOwner { finalized = true ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( tokensSold >= minCap && this . balance > 0 ) { owner . transfer ( this . balance ) ; } }
","Closes crowdsale , finishes minting ( allowing token transfers ) , transfers token ownership to the owner
"
"function get ( string _name ) public view returns ( uint value ) { return params [ keccak256 ( abi . encodePacked ( _name ) ) ] ; }
","gets the parameter keyed by the provided name value from the params mapping
"
"function getPrice ( address ofAsset ) view returns ( bool isRecent , uint price , uint decimal ) { return ( hasRecentPrice ( ofAsset ) , information [ ofAsset ] . price , information [ ofAsset ] . decimal ) ; }
","Gets price of an asset multiplied by ten to the power of assetDecimals
"
"function wasSuccess ( ) view public returns ( bool ) { return hasEnded ( ) && goalReached ( ) ; }
","Was this token sale successful ?
"
"function operatorBurn ( address _tokenHolder , uint256 _amount , bytes _data , bytes _operatorData ) public { require ( msg . sender == burnOperator , ""Not a burn operator"" ) ; super . operatorBurn ( _tokenHolder , _amount , _data , _operatorData ) ; }
","Burns ` _amount ` tokens from ` _tokenHolder ` by ` _operator ` Silly example of overriding the ` operatorBurn ` function to only let a specific operator burn tokens .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public canTransfer ( _from ) returns ( bool ) { require ( _to != address ( 0 ) , ""Invalid address."" ) ; return super . transferFrom ( _from , _to , _value ) ; }
","Transfers tokens from a specified wallet address .
"
"function cancelPayment ( uint _idPayment ) public onlyOwner { doCancelPayment ( _idPayment ) ; }
","When ` autopay ` is ` false ` and after a payment has been authorized to allow the owner to cancel a payment instead of confirming it .
"
"function enableTransfers ( ) external onlyAdmin whenNotPaused returns ( bool ) { require ( ! released , ""Invalid operation. The transfer state is no more restricted."" ) ; released = true ; emit TokenReleased ( released ) ; return true ; }
","This function enables token transfers for everyone.Can only be enabled after the end of the ICO .
"
"function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) stateOpenOrPendingArbitration ( question_id ) external { bytes32 answer_hash = keccak256 ( abi . encodePacked ( answer , nonce ) ) ; bytes32 commitment_id = keccak256 ( abi . encodePacked ( question_id , answer_hash , bond ) ) ; require ( ! commitments [ commitment_id ] . is_revealed , ""commitment must not have been revealed yet"" ) ; require ( commitments [ commitment_id ] . reveal_ts > uint32 ( now ) , ""reveal deadline must not have passed"" ) ; commitments [ commitment_id ] . revealed_answer = answer ; commitments [ commitment_id ] . is_revealed = true ; if ( bond == questions [ question_id ] . bond ) { _updateCurrentAnswer ( question_id , answer , questions [ question_id ] . timeout ) ; } emit LogAnswerReveal ( question_id , msg . sender , answer_hash , answer , nonce , bond ) ; }
","Submit the answer whose hash you sent in a previous submitAnswerCommitment ( ) transaction
"
"function _mint ( address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; require ( _tokenId != 0 ) ; require ( idToOwner [ _tokenId ] == address ( 0 ) ) ; addNFToken ( _to , _tokenId ) ; emit Transfer ( address ( 0 ) , _to , _tokenId ) ; }
","This is a private function which should be called from user-implemented external mint function .
"
"function burn ( uint num ) public { require ( num > 0 ) ; require ( balances [ msg . sender ] >= num ) ; require ( totalSupply >= num ) ; uint preBalance = balances [ msg . sender ] ; balances [ msg . sender ] -= num ; totalSupply -= num ; Burnt ( msg . sender , num , totalSupply ) ; Transfer ( msg . sender , 0x0 , num ) ; assert ( balances [ msg . sender ] == preBalance - num ) ; }
","Allows ` msg.sender ` to simply destroy ` num ` token units ( Xei ) .
"
"function motionWaiting ( uint motionID ) public view returns ( bool ) { return motionStartTime [ motionID ] + votingPeriod + confirmationPeriod <= now ; }
","A vote motion either not begun , or it has completely terminated .
"
"function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes calldata _data ) external returns ( bytes4 ) ;
","The contract address is always the message sender .
"
"function onStateChange ( Crowdsale . State _state ) public onlyCrowdsale ;
","Takes actions on state change , un-pause tokens and disable minting on Crowdsale success
"
"function getThirdPartyOwners ( ) public view returns ( address [ ] _owners ) { if ( owners . length <= TWO_FACTOR_RESERVED_OWNERS_LENGTH ) { return ; } _owners = new address [ ] ( owners . length - TWO_FACTOR_RESERVED_OWNERS_LENGTH ) ; uint _pointer = 0 ; for ( uint _ownerIdx = TWO_FACTOR_RESERVED_OWNERS_LENGTH ; _ownerIdx < owners . length ; ++ _ownerIdx ) { _owners [ _pointer ++ ] = owners [ _ownerIdx ] ; } }
","Gets a list of 3rd party owners ( if such exist ) .
"
"function getSubPayeesCount ( bytes32 _requestId ) public view returns ( uint8 ) { for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { } return i ; }
","Gets number of subPayees for a request .
"
"function getAttributeValue ( address account , uint256 attributeTypeID ) external view returns ( uint256 value ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; if ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) { return _issuedAttributes [ account ] [ attributeTypeID ] . value ; } else if ( _attributeTypes [ attributeTypeID ] . secondarySource != address ( 0 ) ) { require ( AttributeRegistryInterface ( _attributeTypes [ attributeTypeID ] . secondarySource ) . hasAttribute ( account , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID ) , ""attribute of the provided type is not assigned to the provided account"" ) ; return ( AttributeRegistryInterface ( _attributeTypes [ attributeTypeID ] . secondarySource ) . getAttributeValue ( account , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID ) ) ; } revert ( ""could not find an attribute value at the provided account and ID"" ) ; }
","Retrieve the value of the attribute of the type with ID ` attributeTypeID ` on the account at ` account ` , assuming it is valid .
"
"function rateFor ( address _affiliate , uint256 , uint256 , uint256 ) public view returns ( uint256 ) { uint256 whitelistedRate = whitelistRates [ _affiliate ] ; if ( whitelistedRate > 0 ) { if ( whitelistedRate == 1 ) { return 0 ; } else { return Math . min256 ( whitelistedRate , maximumRate ) ; } } else { return Math . min256 ( baselineRate , maximumRate ) ; } }
","returns the commission rate for a sale
"
"function transferOwnership ( address newOwner ) public onlyContractOwner returns ( bool ) { if ( newOwner == 0x0 ) { return false ; } emit OwnershipTransferred ( contractOwner , newOwner ) ; contractOwner = newOwner ; delete pendingContractOwner ; return true ; }
","Allows the current owner to transfer control of the contract to a newOwner .
"
"function finalize ( ) external { if ( ! funding ) throw ; if ( ( block . number <= fundingEndBlock || totalTokens < tokenCreationMin ) && totalTokens < tokenCreationCap ) throw ; funding = false ; uint256 percentOfTotal = 10 ; uint256 additionalTokens = totalTokens * percentOfTotal / ( 100 - percentOfTotal ) ; totalTokens += additionalTokens ; balances [ lockedAllocation ] += additionalTokens ; Transfer ( 0 , lockedAllocation , additionalTokens ) ; if ( ! prospectors_team . send ( this . balance ) ) throw ; }
","Finalize crowdfunding
"
"function acceptProposedMilestones ( bytes32 _hashProposals ) onlyDonor campaignNotCanceled { uint i ; if ( ! changingMilestones ) throw ; if ( sha3 ( proposedMilestones ) != _hashProposals ) throw ; for ( i = 0 ; i < milestones . length ; i ++ ) { if ( milestones [ i ] . status != MilestoneStatus . Paid ) { milestones [ i ] . status = MilestoneStatus . Canceled ; } } bytes memory mProposedMilestones = proposedMilestones ; var itmProposals = mProposedMilestones . toRLPItem ( true ) ; if ( ! itmProposals . isList ( ) ) throw ; var itrProposals = itmProposals . iterator ( ) ; while ( itrProposals . hasNext ( ) ) { var itmProposal = itrProposals . next ( ) ; Milestone milestone = milestones [ milestones . length ++ ] ; if ( ! itmProposal . isList ( ) ) throw ; var itrProposal = itmProposal . iterator ( ) ; milestone . description = itrProposal . next ( ) . toAscii ( ) ; milestone . url = itrProposal . next ( ) . toAscii ( ) ; milestone . minCompletionDate = itrProposal . next ( ) . toUint ( ) ; milestone . maxCompletionDate = itrProposal . next ( ) . toUint ( ) ; milestone . reviewer = itrProposal . next ( ) . toAddress ( ) ; milestone . reviewTime = itrProposal . next ( ) . toUint ( ) ; milestone . paymentSource = itrProposal . next ( ) . toAddress ( ) ; milestone . payData = itrProposal . next ( ) . toData ( ) ; milestone . status = MilestoneStatus . AcceptedAndInProgress ; } delete proposedMilestones ; changingMilestones = false ; NewMilestoneListAccepted ( ) ; }
","` onlyDonor ` Approves the proposed milestone list
"
"function finishMinting ( address _burnable ) public onlyController ( ) { require ( _burnable != address ( 0x0 ) ) ; assert ( totalSupply ( ) <= maxSupply ) ; enableTransfers ( true ) ; changeController ( address ( 0x0 ) ) ; burnable = _burnable ; }
","Finishes minting process and throws out the controller .
"
"function getCrypton ( uint256 _tokenId ) public view returns ( string cryptonName , uint8 category , uint256 markup , uint256 sellingPrice , address owner , bool isProtected ) { Crypton storage crypton = cryptons [ _tokenId ] ; cryptonName = crypton . name ; sellingPrice = cryptonIndexToPrice [ _tokenId ] ; owner = cryptonIndexToOwner [ _tokenId ] ; isProtected = cryptonIndexToProtected [ _tokenId ] ; category = crypton . category ; markup = crypton . markup ; }
","Returns all the relevant information about a specific crypton .
"
"function withdrawCollateral ( address token , uint amount ) public { require ( token != 0 ) ; require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( tokens [ token ] [ msg . sender ] >= amount ) ; uint amountToWithdraw = tokens [ token ] [ msg . sender ] ; tokens [ token ] [ msg . sender ] = 0 ; DataVault . _externalStopMasternode ( msg . sender ) ; if ( ! StandardToken ( token ) . transfer ( msg . sender , amountToWithdraw ) ) revert ( ) ; emit Withdraw ( token , msg . sender , amountToWithdraw , amountToWithdraw ) ; }
","Public function that allows any user to withdraw deposited tokens and stop as masternode
"
"function isApproved ( uint index ) public view returns ( bool ) { Loan storage loan = loans [ index ] ; return loan . approbations [ loan . borrower ] ; }
","Used to know if a loan is ready to lend
"
"function addDelegate ( address _delegate , bytes32 _details ) external ;
","Used to add a delegate
"
"function migrate ( uint256 _value ) external { if ( migrationAgent == 0 ) revert ( ) ; if ( _value == 0 ) revert ( ) ; if ( _value > balances [ msg . sender ] ) revert ( ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; totalMigrated += _value ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }
","Migrate tokens to the new token contract .
"
"function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned transfer
"
"function offer ( uint256 quantity , uint256 price , uint256 expiry ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; require ( quantity > 0 , ""You must supply a quantity."" ) ; require ( price > 0 , ""The sale price cannot be zero."" ) ; require ( expiry > block . timestamp , ""Cannot have an expiry date in the past."" ) ; require ( price >= sellFloor , ""The ask is below the minimum allowed."" ) ; require ( sellCeiling == 0 || price <= sellCeiling , ""The ask is above the maximum allowed."" ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , ""You must approve the transfer of tokens before offering them for sale."" ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , ""Not enough tokens owned to complete the order."" ) ; orderBook [ msg . sender ] = TradeOrder ( quantity , price , expiry ) ; emit TokensOffered ( msg . sender , quantity , price , expiry ) ; }
","Offer tokens for sale , you must call approve on the ERC20 contract first , giving approval to the address of this contract .
"
"function withdrawEther ( ) external onlyOwner { owner . transfer ( this . balance ) ; }
","Owner : Withdraw Ether
"
"function earlyResolve ( bytes32 msigId , uint amount , bytes32 hashedMessage , bytes sig ) public { require ( multisigs [ msigId ] . owner == msg . sender || multisigs [ msigId ] . authority == msg . sender ) ; address otherAuthority = multisigs [ msigId ] . owner == msg . sender ? multisigs [ msigId ] . authority : multisigs [ msigId ] . owner ; require ( otherAuthority == hashedMessage . recover ( sig ) ) ; spendFromMultisig ( msigId , amount , multisigs [ msigId ] . owner ) ; }
","Withdraw ether and delete the htlc swap .
"
"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function getName ( ) public view returns ( bytes32 ) { return ""CountTransferManager"" ; }
","Get the name of the Module
"
"function depositStake ( StakeLevel _stakeLevel ) public whenNotPaused ( ) isMember ( msg . sender ) notStaking ( msg . sender ) isValidStakeLevel ( _stakeLevel ) { uint256 amountDeposited = depositInternal ( msg . sender , ixtStakingLevels [ uint256 ( _stakeLevel ) ] , false ) ; Member storage member = members [ msg . sender ] ; member . stakeTimestamp = block . timestamp ; member . startOfLoyaltyRewardEligibility = block . timestamp ; registeredInvitationCodes [ member . invitationCode ] = msg . sender ; emit StakeDeposited ( msg . sender , member . membershipNumber , amountDeposited ) ; }
","Before calling the prospective member must have approved the appropriate amount of IXT token to be transferred by this contract
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; return doApprove ( _spender , _amount ) ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function verifyAccount ( Data storage self , address account ) internal view returns ( bool verified ) { require ( getKYCApproval ( self , account ) , ""Error: Account does not have KYC approval."" ) ; require ( getAccountStatus ( self , account ) , ""Error: Account status is `false`. Account status must be `true`."" ) ; return true ; }
","Verified KYC and global status for a single account and return true or throw if account is not verified
"
"function withdrawVotingRights ( uint _numTokens ) external { uint availableTokens = voteTokenBalance [ msg . sender ] - getLockedTokens ( msg . sender ) ; require ( availableTokens >= _numTokens ) ; require ( token . transfer ( msg . sender , _numTokens ) ) ; voteTokenBalance [ msg . sender ] -= _numTokens ; VotingRightsWithdrawn ( msg . sender , _numTokens ) ; }
","Withdraw _numTokens ERC20 tokens from the voting contract , revoking these voting rights
"
"function cancelSellOffer ( uint32 _canvasId ) external { _cancelSellOfferInternal ( _canvasId , true ) ; }
","Cancels previously made sell offer .
"
"function performBuyOrder ( bytes genericPayload , uint256 amountToGiveForOrder ) public payable onlyTotle whenNotPaused returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { bool success ; bytes4 functionSelector = selectorProvider . getSelector ( this . performBuyOrder . selector ) ; assembly { let callDataOffset := 0x44 let functionSelectorOffset := 0x1C let functionSelectorLength := 0x04 let scratchSpace := 0x0 let wordLength := 0x20 let startOfFreeMemory := mload ( 0x40 ) calldatacopy ( startOfFreeMemory , callDataOffset , calldatasize ) let bytesLength := mload ( startOfFreeMemory ) let totalLength := add ( add ( functionSelectorLength , bytesLength ) , wordLength ) mstore ( add ( scratchSpace , functionSelectorOffset ) , functionSelector ) let functionSelectorCorrect := mload ( scratchSpace ) mstore ( startOfFreeMemory , functionSelectorCorrect ) mstore ( add ( startOfFreeMemory , add ( wordLength , bytesLength ) ) , amountToGiveForOrder ) let startOfNewData := add ( startOfFreeMemory , functionSelectorOffset ) success := call ( gas , address , callvalue , startOfNewData , totalLength , scratchSpace , mul ( wordLength , 0x02 ) ) amountSpentOnOrder := mload ( scratchSpace ) amountReceivedFromOrder := mload ( add ( scratchSpace , wordLength ) ) if eq ( success , 0 ) { revert ( 0 , 0 ) } } }
","Perform a buy order at the exchange
"
"function removeFromWhitelist ( address [ ] _bidder_addresses ) public isOwner { for ( uint32 i = 0 ; i < _bidder_addresses . length ; i ++ ) { whitelist [ _bidder_addresses [ i ] ] = false ; } }
","Removes account addresses from whitelist .
"
"function revokeOperator ( address _operator ) public whenNotPaused { require ( _operator != msg . sender , ""You cannot authorize yourself as an operator"" ) ; mAuthorized [ _operator ] [ msg . sender ] = false ; emit RevokedOperator ( _operator , msg . sender ) ; }
","Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
"
"function transferFromPreSignedHashing ( address _token , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F44 ) , _token , _from , _to , _value , _fee , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by transferFromPreSigned
"
"function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 3 ) ; availableTags [ 0 ] = ""ERC20"" ; availableTags [ 1 ] = ""Dividend"" ; availableTags [ 2 ] = ""Checkpoint"" ; return availableTags ; }
","Get the tags related to the module factory
"
"function getOrganization ( uint256 index ) external view returns ( address organization ) { return _organizationAccounts [ index ] ; }
","Get the account of the organization at index ` index ` .
"
"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) ;
","Query if an address is an authorized operator for another address
"
"function getAllowance ( address _owner , address _spender ) external view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }
","Get allowance of ` _spender ` in behalf of ` _owner `
"
"function createSeedCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } seedCreatedCount ++ ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 0 , _nftData ) ; }
","Helps in creating seed collectible.The generation of an asset if limited via the generationSeasonController
"
"function redeemAllOwnedAssets ( uint shareQuantity ) external returns ( bool success ) { return emergencyRedeem ( shareQuantity , ownedAssets ) ; }
","Redeems by allocating an ownership percentage of each asset to the participant
"
"function synthInitiatedFeePayment ( address from , bytes4 sourceCurrencyKey , uint sourceAmount ) external onlySynth returns ( bool ) { require ( sourceAmount > 0 , ""Source can't be 0"" ) ; bool result = _internalExchange ( from , sourceCurrencyKey , sourceAmount , ""XDR"" , feePool . FEE_ADDRESS ( ) , false ) ; feePool . feePaid ( sourceCurrencyKey , sourceAmount ) ; return result ; }
","Function that allows synth contract to delegate sending fee to the fee Pool .
"
"function distributePresaleTokens ( address _buyer , uint tokens ) external onlyOwner whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( tokensDistributedPresale < 10e24 ) ; tokensDistributedPresale = tokensDistributedPresale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
","Distributes the presale tokens .
"
"function batchCreateChannel ( address [ ] beneficiaries , uint [ ] amounts , uint [ ] commissions , uint [ ] expiresAts , bytes32 [ ] hashedSecrets ) public payable returns ( bytes32 [ ] channelId ) { require ( beneficiaries . length <= MAX_BATCH_ITERATIONS , ""TOO_MANY_CHANNELS"" ) ; uint valueToBeSent ; for ( uint i = 0 ; i < beneficiaries . length ; ++ i ) { require ( amounts [ i ] + commissions [ i ] >= amounts [ i ] , ""UINT256_OVERFLOW"" ) ; require ( valueToBeSent + amounts [ i ] + commissions [ i ] >= valueToBeSent , ""UINT256_OVERFLOW"" ) ; valueToBeSent += amounts [ i ] + commissions [ i ] ; } require ( msg . value == valueToBeSent , ""INACCURATE_MSG_VALUE_SENT"" ) ; for ( i = 0 ; i < beneficiaries . length ; ++ i ) _setupChannel ( beneficiaries [ i ] , amounts [ i ] , commissions [ i ] , expiresAts [ i ] , hashedSecrets [ i ] ) ; }
","Creates a batch of channels
"
"function getPermissions ( ) public view returns ( bytes32 [ ] ) ;
","Return the permissions flag that are associated with Module
"
"function getDistributionContracts ( address _beneficiary ) public view validAddress ( _beneficiary ) returns ( address [ ] ) { return beneficiaryDistributionContracts [ _beneficiary ] ; }
","Gets an array of all the distribution contracts for a given beneficiary .
"
"function upgrade ( address newAddress ) { newAddress ; throw ; }
","can be called only by admin .
"
"function createBurnedPermission ( address _app , bytes32 _role ) external auth ( CREATE_PERMISSIONS_ROLE ) noPermissionManager ( _app , _role ) { _setPermissionManager ( BURN_ENTITY , _app , _role ) ; }
","Burn non-existent ` _role ` in ` _app ` , so no modification can be made to it ( grant , revoke , permission manager )
"
"function addSigner ( address _signer ) public onlyOwner { signers [ _signer ] = true ; }
","update signer
"
"function createCloneToken ( address _parentToken , uint256 _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function withdrawETH ( uint256 _amount ) external onlyOwner { owner . transfer ( _amount ) ; }
","Withdraw ether contained in this contract and send it back to owner
"
"function getMarketDetails ( ) public view returns ( uint32 , uint32 , uint32 , uint32 , uint64 , uint64 , uint256 , uint256 ) { return ( devFee , priceUpdateInterval , startDateRoundValue , durationRoundValue , maxDuration , minDuration , maxPrice , minPrice ) ; }
","Get all market parameters
"
"function changeDeedPrice ( uint256 identifier , uint256 newPrice ) public { require ( identifierToOwner [ identifier ] == msg . sender ) ; require ( allowChangePrice ) ; require ( newPrice < identifierToPrice [ identifier ] ) ; identifierToPrice [ identifier ] = newPrice ; Price ( identifier , newPrice , nextPrice ( newPrice ) ) ; }
","Set the price of a deed .
"
"function setMerkleRoot ( bytes32 _updatedMerkleRoot ) external onlySigner returns ( uint ) { merkleRoot = _updatedMerkleRoot ; emit LogMerkleRootUpdated ( _updatedMerkleRoot , msg . sender ) ; return OK ; }
","Updates merkle root after changes in airdrop records .
"
"function setTransferFeeRate ( uint _transferFeeRate ) external optionalProxy_onlyOwner { require ( _transferFeeRate <= MAX_TRANSFER_FEE_RATE , ""Transfer fee rate must be below MAX_TRANSFER_FEE_RATE"" ) ; transferFeeRate = _transferFeeRate ; emitTransferFeeRateUpdated ( _transferFeeRate ) ; }
","Set the transfer fee , anywhere within the range 0-10 % .
"
"function upgrade ( uint256 value ) external { if ( ! upgradeAgentStatus ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( finalizedUpgrade ) throw ; if ( value == 0 ) throw ; if ( value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }
","Upgrade tokens to the new token contract .
"
"function ( ) public payable { require ( isContract ( controller ) ) ; require ( TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function ( ) payable { require ( false ) ; }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function getMinerHalvingHashRateOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { Miner miner = miners [ _miner ] ; uint256 halving = getMinerHalving ( ) ; MinerHashRate hashRate = miner . hashRate [ halving ] ; if ( halving == 0 ) { return hashRate . rate ; } else { if ( ! hashRate . carried ) { return hashRate . rate . add ( miner . hashRate [ halving - 1 ] . rate ) ; } else { return hashRate . rate ; } } }
","Total hash rate of a miner in a halving
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && _value > 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; balances [ _to ] += _value ; if ( _from == owner && _to != owner ) { shareholdersBalance += _value ; } if ( _from != owner && _to == owner ) { shareholdersBalance -= _value ; } if ( owner != _to ) { insertShareholder ( _to ) ; } Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }
","Send ` _value ` tokens to ` _to ` in behalf of ` _from `
"
"function changeOraclizeGasPrice ( uint _gasPrice ) public onlyOwner { require ( _gasPrice >= 1000000000 ) ; oraclize_setCustomGasPrice ( _gasPrice ) ; }
","To be used in case the default gas price is too low
"
"function transferTokensToAccount ( bytes16 _from , bytes16 _to , uint256 _tokensCount ) onlyAllowedAddresses onlyRegisteredAccount ( _from ) whenNotPaused public returns ( bool ) { registerAccount ( _to ) ; balances [ _from ] = balances [ _from ] . sub ( _tokensCount ) ; balances [ _to ] = balances [ _to ] . add ( _tokensCount ) ; return true ; }
","Function for transfering tokens from one account to another .
"
"function play ( bool startNewGameIfIdle ) external payable { _processGameEnd ( ) ; if ( ! gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; price = nextPrice ; timeout = nextTimeout ; minimumTimeout = nextMinimumTimeout ; numberOfWagersToMinimumTimeout = nextNumberOfWagersToMinimumTimeout ; gameStarted = true ; gameStarter = msg . sender ; Start ( msg . sender , block . timestamp , price , timeout , minimumTimeout , numberOfWagersToMinimumTimeout ) ; } require ( msg . value >= price ) ; uint256 fee = price . mul ( feePercentage ) . div ( 100000 ) ; uint256 dividend = price . mul ( gameStarterDividendPercentage ) . div ( 100000 ) ; uint256 wagerPoolPart ; if ( wagerIndex % 7 == 6 ) { uint256 wagerPrize = price . mul ( 2 ) ; wagerPoolPart = wagerPrize . sub ( wagerPool ) ; msg . sender . transfer ( wagerPrize ) ; wagerPool = 0 ; } else { wagerPoolPart = price . mul ( 2 ) . div ( 7 ) ; wagerPool = wagerPool . add ( wagerPoolPart ) ; } uint256 currentTimeout = calculateTimeout ( ) ; lastPlayer = msg . sender ; lastWagerTimeoutTimestamp = block . timestamp + currentTimeout ; prizePool = prizePool . add ( price . sub ( fee ) . sub ( dividend ) . sub ( wagerPoolPart ) ) ; Play ( msg . sender , block . timestamp , lastWagerTimeoutTimestamp , wagerIndex , prizePool ) ; _sendFunds ( gameStarter , dividend ) ; wagerIndex = wagerIndex . add ( 1 ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Participate in the game .
"
"function _addToken ( address _to , uint256 _tokenId ) private { require ( tokenOwner [ _tokenId ] == address ( 0 ) ) ; tokenOwner [ _tokenId ] = _to ; uint256 length = balanceOf ( _to ) ; ownedTokens [ _to ] . push ( _tokenId ) ; ownedTokensIndex [ _tokenId ] = length ; totalTokens = totalTokens . add ( 1 ) ; }
","Internal function to add a token ID to the list of a given address
"
"function grantPermissionP ( address _entity , address _app , bytes32 _role , uint256 [ ] _params ) public onlyPermissionManager ( _app , _role ) { bytes32 paramsHash = _params . length > 0 ? _saveParams ( _params ) : EMPTY_PARAM_HASH ; _setPermission ( _entity , _app , _role , paramsHash ) ; }
","Grant ` _entity ` the ability to perform actions requiring ` _role ` on ` _app `
"
"function createKingdom ( string _kingdomName , uint _startingClaimPriceWei , uint _claimPriceAdjustPercent , uint _curseIncubationDurationSeconds , uint _commissionPerThousand ) { externalEnter ( ) ; createKingdomRP ( _kingdomName , _startingClaimPriceWei , _claimPriceAdjustPercent , _curseIncubationDurationSeconds , _commissionPerThousand ) ; externalLeave ( ) ; }
","Create a new kingdom using custom rules .
"
"function acceptOwnership ( ) external { require ( msg . sender == nominatedOwner , ""You must be nominated before you can accept ownership"" ) ; emit OwnerChanged ( owner , nominatedOwner ) ; owner = nominatedOwner ; nominatedOwner = address ( 0 ) ; }
","Accept the nomination to be owner .
"
"function unvote ( uint _idPoll ) public { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll storage p = _polls [ _idPoll ] ; require ( block . number >= p . startBlock && block . timestamp < p . endTime && ! p . canceled , ""Poll is inactive"" ) ; if ( p . voters == 0 ) return ; uint prevVotes = 0 ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { uint ballotAmount = p . ballots [ i ] [ msg . sender ] ; prevVotes += ballotAmount ; p . ballots [ i ] [ msg . sender ] = 0 ; if ( ballotAmount != 0 ) { p . qvResults [ i ] -= sqrt ( ballotAmount / 1 ether ) ; p . results [ i ] -= ballotAmount ; p . votersByBallot [ i ] -- ; } } if ( prevVotes != 0 ) { p . voters -- ; } emit Unvote ( _idPoll , msg . sender ) ; }
","Cancel or reset a vote
"
"function getMinimumFunds ( ) internal constant returns ( uint ) ;
","minimum amount of funding to consider crowdsale as successful
"
"function initialize ( ) external onlyInit { initialized ( ) ; setDepositable ( true ) ; }
","Initialize Vault app
"
"function getDarknodeOwner ( address _darknodeID ) external view returns ( address ) { return store . darknodeOwner ( _darknodeID ) ; }
","Retrieves the address of the account that registered a darknode .
"
"function setFeeFlat ( Data storage self , uint feeFlat ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.flat' , address ( this ) ) ) ; require ( self . Storage . setUint ( id , feeFlat ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set flat fee for contract interface
"
"function transfer ( address _receiver , uint256 _amount ) public returns ( bool success ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; return true ; }
","Used to transfer funds
"
"function setPresaleEthereumDeposit ( address _depositAddress ) whenNotPaused onlyOwner external { deposit = RntPresaleEthereumDeposit ( _depositAddress ) ; }
","Set RntPresaleEhtereumDeposit address .
"
"function getLandEstateId ( uint256 landId ) external view returns ( uint256 ) { return landIdEstate [ landId ] ; }
","Get the Estate id for a given LAND id
"
"function cancelAuction ( address _tokenAddress , uint256 _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenAddress ] [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenAddress , _tokenId , seller ) ; }
","This is a state-modifying function that can be called while the contract is paused .
"
"function withdrawPrize ( ) external checkState ( pointsValidationState . Finished ) { uint256 prize = 0 ; uint256 [ ] memory tokenList = ownedTokens [ msg . sender ] ; for ( uint256 i = 0 ; i < tokenList . length ; i ++ ) { prize += tokenToPayoutMap [ tokenList [ i ] ] ; tokenToPayoutMap [ tokenList [ i ] ] = 0 ; } require ( prize > 0 ) ; msg . sender . transfer ( ( prizePool . mul ( prize ) ) . div ( 1000000 ) ) ; }
","Allows any user to retrieve their asigned prize .
"
"function completeDeliverable ( bytes32 _id , address _creator , address _brand ) internal returns ( bool ) { require ( content . isFulfilled ( _id , _creator , _brand ) ) ; content . completeDeliverable ( _id ) ; return _approveEscrow ( _id , content . rewardOf ( _id ) ) ; }
","complete deliverable by making reward amount claimable
"
"function releaseTo ( address target ) onlyBeneficiary public { require ( now >= cliff ) ; _releaseTo ( target ) ; }
","Transfers vested tokens to a target address .
"
"function numberOfPledgeAdmins ( ) constant returns ( uint ) { return admins . length - 1 ; }
","A constant getter used to check how many total Admins exist
"
"function thawTokenTransfers ( ) public onlyOwner returns ( bool thawed ) { tokenTransfersFrozen = false ; ThawTokenTransfers ( msg . sender , true ) ; return true ; }
","Used to thaw token tra4nsfers
"
"function symbol ( ) external pure returns ( string ) { return ""SU"" ; }
","An abbreviated name for NFTs in this contract
"
"function externalTokensRecovery ( Token _address ) onlyAdmin public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
","Function to claim any token stuck on contract
"
"function getPlotInfo ( uint256 plotIndex ) public view returns ( uint24 x , uint24 y , uint24 w , uint24 h , address owner , uint256 price ) { require ( plotIndex < ownership . length ) ; return ( ownership [ plotIndex ] . x , ownership [ plotIndex ] . y , ownership [ plotIndex ] . w , ownership [ plotIndex ] . h , ownership [ plotIndex ] . owner , plotIdToPrice [ plotIndex ] ) ; }
","Gets the information for a specific plot based on its index .
"
"function onTransfer ( address , address , uint256 ) returns ( bool ) { return ( transferable || getBlockTimestamp ( ) >= October12_2017 ) ; }
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function resolveDispute ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint8 _v , bytes32 _r , bytes32 _s , uint8 _buyerPercent ) external onlyArbitrator { address _signature = recoverAddress ( keccak256 ( abi . encodePacked ( _tradeID , INSTRUCTION_RESOLVE ) ) , _v , _r , _s ) ; require ( _signature == _buyer || _signature == _seller , ""Must be buyer or seller"" ) ; Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; require ( _escrow . exists , ""Escrow does not exist"" ) ; require ( _buyerPercent <= 100 , ""_buyerPercent must be 100 or lower"" ) ; uint256 _totalFees = _escrow . totalGasFeesSpentByRelayer + ( GAS_doResolveDispute * uint128 ( tx . gasprice ) ) ; require ( _value - _totalFees <= _value , ""Overflow error"" ) ; feesAvailableForWithdraw += _totalFees ; delete escrows [ _tradeHash ] ; emit DisputeResolved ( _tradeHash ) ; if ( _buyerPercent > 0 ) _buyer . transfer ( ( _value - _totalFees ) * _buyerPercent / 100 ) ; if ( _buyerPercent < 100 ) _seller . transfer ( ( _value - _totalFees ) * ( 100 - _buyerPercent ) / 100 ) ; }
","Called by the arbitrator to resolve a dispute .
"
"function proxyChangeCrowdsaleMaster ( address _newMaster ) public returns ( bool ) { require ( msg . sender == getContractAddress ( ""PoaManager"" ) ) ; require ( _newMaster != address ( 0 ) ) ; require ( poaCrowdsaleMaster != _newMaster ) ; require ( isContract ( _newMaster ) ) ; address _oldMaster = poaCrowdsaleMaster ; poaCrowdsaleMaster = _newMaster ; emit ProxyUpgraded ( _oldMaster , _newMaster ) ; getContractAddress ( ""PoaLogger"" ) . call ( bytes4 ( keccak256 ( ""logProxyUpgraded(address,address)"" ) ) , _oldMaster , _newMaster ) ; return true ; }
","Update the stored ` poaCrowdsaleMaster ` address to upgrade the PoaCrowdsale master contract
"
"function performSellOrder ( OrderData data , uint256 amountToGiveForOrder ) public whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { approveAddress ( data . converterAddress , data . conversionPath [ 0 ] ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = BancorConverter ( data . converterAddress ) . quickConvert ( trimAddressArray ( data . conversionPath ) , amountToGiveForOrder , data . minReturn ) ; totlePrimary . transfer ( amountReceivedFromOrder ) ; }
","Perform a sell order at the exchange
"
"function getContractAddress ( string _name ) public view returns ( address _contractAddress ) { bytes4 _signature = bytes4 ( keccak256 ( ""getContractAddress32(bytes32)"" ) ) ; bytes32 _name32 = keccak256 ( abi . encodePacked ( _name ) ) ; assembly { let _registry := sload ( registry_slot ) let _pointer := mload ( 0x40 ) mstore ( _pointer , _signature ) mstore ( add ( _pointer , 0x04 ) , _name32 ) let result := staticcall ( gas , _registry , _pointer , 0x24 , _pointer , 0x20 ) if iszero ( result ) { revert ( 0 , 0 ) } _contractAddress := mload ( _pointer ) mstore ( 0x40 , add ( _pointer , 0x24 ) ) } }
","Gets a given contract address by bytes32 in order to save gas
"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","This is used to approve someone to send tokens on your behalf
"
"function getPerson ( uint256 _tokenId ) public view returns ( string personName , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; personName = person . name ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific person .
"
"function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool _transferredFrom ) { require ( ! tokenTransfersFrozen ) ; require ( allowance [ _owner ] [ msg . sender ] . sub ( _amount ) >= 0 ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; allowance [ _owner ] [ msg . sender ] = allowance [ _owner ] [ msg . sender ] . sub ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }
","Used to transfer funds on behalf of one person
"
"function redeem ( uint256 baseUnits , address [ ] tokensToSkip ) external requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( baseUnits <= totalSupply_ ) ; require ( baseUnits <= balances [ msg . sender ] ) ; require ( tokensToSkip . length <= tokens . length ) ; burn ( msg . sender , baseUnits ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 index ; bool ok ; ( index , ok ) = tokensToSkip . index ( token . addr ) ; if ( ok ) { continue ; } uint256 amount = baseUnits . div ( creationUnit_ ) . mul ( token . quantity ) ; require ( erc20 . transfer ( msg . sender , amount ) ) ; } }
","Redeems Bskt tokens in exchange for underlying tokens
"
"function removeOwnership ( address _dece ) onlyOwner { require ( _dece == 0xdece ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; }
","Decentralizes the contract , this operation can not be undone
"
"function depositETH ( ) payable { DonationDeposited4Doubling ( msg . sender , msg . value ) ; }
","Simple function to deposit more ETH to Double Donations
"
"function getTimeout ( bytes32 question_id ) public view returns ( uint32 ) { return questions [ question_id ] . timeout ; }
","Returns the timeout in seconds used after each answer
"
"function setTiers ( uint256 _tierTwoMin , uint256 _tierThreeMin ) onlyOwner { tierTwoMin = _tierTwoMin ; tierThreeMin = _tierThreeMin ; }
","sets the Ether to Dollar exhchange rate
"
"function _collectResource ( Factory storage _factory , User storage _user ) internal returns ( uint256 ) { uint256 resources = _resourcesAtTime ( _factory . ftype , _factory . level , _factory . collected_at ) ; _user . resources [ uint8 ( _factory . ftype ) ] = _user . resources [ uint8 ( _factory . ftype ) ] . add ( resources ) ; _factory . collected_at = now ; emit CollectResources ( _factory . ftype , resources ) ; return resources ; }
","function for collect resource
"
"function commitUpgrade ( ) public returns ( bool ) { if ( pendingVersion == 0x0 ) { return false ; } if ( pendingVersionTimestamp + UPGRADE_FREEZE_TIME > now ) { return false ; } latestVersion = pendingVersion ; delete pendingVersion ; delete pendingVersionTimestamp ; return true ; }
","Finalize an upgrade process setting new asset implementation contract address .
"
"function removeManyAdmins ( address [ ] _accounts ) external onlyAdmin { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && admins [ account ] && account != owner ) { admins [ account ] = false ; emit AdminRemoved ( _accounts [ i ] ) ; } } }
","Removes multiple addresses to the administrator list .
"
"function resumeContribution ( ) onlyController { paused = false ; }
","Resumes the contribution
"
"function burn ( uint256 _value ) returns ( bool success ) { require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function updatePackage ( uint idPackage , string name ) onlyOwner public { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; c . name = name ; PackageUpdated ( idPackage , name ) ; }
","Update a DAppNode package
"
"function closeTradeProfile ( bytes _signature , bytes32 _strategyID ) public returns ( bool ) { require ( msg . sender == bincentive ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( closePreSignedHashing ( address ( this ) , _strategyID ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; require ( traderProfile [ from ] [ _strategyID ] != address ( 0 ) ) ; TradeProfile profile = TradeProfile ( traderProfile [ from ] [ _strategyID ] ) ; require ( profile . close ( ) ) ; emit CloseTradeProfile ( from , profile ) ; return true ; }
","Close a trade profile
"
"function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( keccak256 ( ""configure(uint256,bool)"" ) ) ; }
","This function returns the signature of configure function
"
"function purchase ( ) payable returns ( bool ) ;
","Create tokens to the value of ` msg.value ` + ` holder.etherBalance `
"
"function purgeAccount ( address account ) external onlyOwner onlyDuringSetup { delete vestingSchedules [ account ] ; totalVestedBalance = safeSub ( totalVestedBalance , totalVestedAccountBalance [ account ] ) ; delete totalVestedAccountBalance [ account ] ; }
","Destroy the vesting information associated with an account .
"
"function transferAllowed ( address _from , address ) external view returns ( bool ) { return _from == address ( this ) ; }
","only the Sale is allowed to send tokens
"
"function approveSpender ( address _spender ) external { require ( whitelistedSpenders [ _spender ] , ""Spender is not whitelisted"" ) ; approvedSpenders [ msg . sender ] [ _spender ] = true ; emit SpenderApprove ( msg . sender , _spender ) ; }
","Approve an address for spending any amount of any token from the ` msg.sender ` 's balances
"
"function burn ( address _where , uint256 _amount ) public onlyEthealMultisig { require ( _where == address ( this ) || _where == SALE ) ; require ( ethealToken . destroyTokens ( _where , _amount ) ) ; }
","contract can burn its own or its sale tokens
"
"function emergencyWithdraw ( ) external hasFinalized { uint256 balance = STARTING_PRICE * ownedTokens [ msg . sender ] . length ; delete ownedTokens [ msg . sender ] ; msg . sender . transfer ( balance ) ; }
","if there is an unresolvable problem , users can call to this function to get a refund .
"
"function isAssociatedAddressFor ( uint ein , address _address ) public view returns ( bool ) { return identityDirectory [ ein ] . associatedAddresses . contains ( _address ) ; }
","Checks whether the passed EIN is associated with the passed address .
"
"function exchangeEtherForSynthsAtRate ( uint guaranteedRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToEthPrice , ""Guaranteed rate would not be received"" ) ; return exchangeEtherForSynths ( ) ; }
","Exchange ETH to sUSD while insisting on a particular rate .
"
"function approveLoanIdentifier ( bytes32 identifier ) public returns ( bool ) { uint256 index = identifierToIndex [ identifier ] ; require ( index != 0 ) ; return approveLoan ( index ) ; }
","Approves a loan using the Identifier and not the index
"
"function ( ) payable public { }
","receive funds
"
"function splitProfits ( ) external { uint i ; if ( ! isFrozen ) { require ( now >= relativeDateSave ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 30000000000000 ) ; relativeDateSave = now + 30 days ; currentProfits = ( ( balances [ selfAddress ] - 30000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 400000000000000 , balances [ selfAddress ] ) + IOUSupply ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { monthlyLimit [ users [ i ] ] = 1000000000000 ; if ( msg . gas < 250000 ) { currentIteration = i ; break ; } if ( ! eligibleForDividence ( users [ i ] ) ) { moneySpent [ users [ i ] ] = 0 ; checkSplitEnd ( i ) ; continue ; } moneySpent [ users [ i ] ] = 0 ; actualProfitSplit += ( ( balances [ users [ i ] ] + allowed [ selfAddress ] [ users [ i ] ] ) * currentProfits ) / amountInCirculation ; Transfer ( selfAddress , users [ i ] , ( ( balances [ users [ i ] ] + allowed [ selfAddress ] [ users [ i ] ] ) * currentProfits ) / amountInCirculation ) ; balances [ users [ i ] ] += ( ( balances [ users [ i ] ] + allowed [ selfAddress ] [ users [ i ] ] ) * currentProfits ) / amountInCirculation ; checkSplitEnd ( i ) ; } } }
","Split the monthly profits of the Casino to the users
"
"function enableTransfers ( bool _transfersEnabled ) onlyOwner { transfersEnabled = _transfersEnabled ; }
","Enables token holders to transfer their tokens freely if true
"
"function withdraw ( uint amount ) { Splitter . withdrawInternal ( amount , false ) ; }
","Withdraws from the sender 's share of funds and deposits into the sender 's account .
"
"function recover ( bytes32 hash , bytes sig ) public pure returns ( address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( sig . length != 65 ) { return ( address ( 0 ) ) ; } assembly { r := mload ( add ( sig , 0x20 ) ) s := mload ( add ( sig , 0x40 ) ) v := byte ( 0 , mload ( add ( sig , 0x60 ) ) ) } if ( v < 27 ) { v += 27 ; } if ( v != 27 && v != 28 ) { return ( address ( 0 ) ) ; } else { return ecrecover ( hash , v , r , s ) ; } }
","Recover signer address from a message by using his signature
"
"function getWorlCupByID ( uint256 _tokenId ) public view returns ( string wctDesc , uint256 sellingPrice , address owner ) { wctDesc = worldCupTeamDescribe [ _tokenId ] ; sellingPrice = worldCupIdToPrice [ _tokenId ] ; owner = worldCupIdToOwnerAddress [ _tokenId ] ; }
","Returns all the world cup team information by token id .
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public whenNotPaused transferFromConditionsRequired ( _from , _to ) returns ( bool ) { require ( _amount <= allowance ( _from , msg . sender ) , ""not enough allowance to transfer"" ) ; require ( _to != address ( 0 ) , ""to address cannot be 0x0"" ) ; require ( _amount <= balanceOf ( _from ) , ""not enough balance to transfer"" ) ; tokenStorage . subAllowance ( _from , msg . sender , _amount ) ; tokenStorage . addBalance ( _to , _amount ) ; tokenStorage . subBalance ( _from , _amount ) ; emit Transfer ( _from , _to , _amount ) ; return true ; }
","Initiates a transfer operation between address ` _from ` and ` _to ` .
"
"function validateLockupTokensSig ( address _sender , uint256 _amount , bytes32 _nonce , bytes _delegationSig ) private { bytes32 _signatureDigest = generateLockupTokensDelegationSchemaHash ( _sender , _amount , _nonce ) ; require ( _sender == recoverSigner ( _signatureDigest , _delegationSig ) , 'Invalid LockupTokens Signature' ) ; burnSignatureDigest ( _signatureDigest , _sender ) ; }
","Verify lockup signature is valid
"
"function getFinalAnswer ( bytes32 question_id ) stateFinalized ( question_id ) external view returns ( bytes32 ) { return questions [ question_id ] . best_answer ; }
","( Deprecated ) Return the final answer to the specified question , or revert if there is n't one
"
"function missingFundsToEndAuction ( ) constant public returns ( uint ) { uint requiredWeiAtPrice = numTokensAuctioned * price ( ) / tokenMultiplier ; if ( requiredWeiAtPrice <= receivedWei ) { return 0 ; } return requiredWeiAtPrice - receivedWei ; }
","Get the missing funds needed to end the auction , calculated at the current XCH price in WEI .
"
"function hashOrder ( bytes _prefix , uint64 _settlementID , uint64 _tokens , uint256 _price , uint256 _volume , uint256 _minimumVolume ) external pure returns ( bytes32 ) { return SettlementUtils . hashOrder ( _prefix , SettlementUtils . OrderDetails ( { settlementID : _settlementID , tokens : _tokens , price : _price , volume : _volume , minimumVolume : _minimumVolume } ) ) ; }
","Exposes the hashOrder function for computing a hash of an order 's details .
"
"function incrementalInverse ( uint256 totalEuroUlps , uint256 burnNeumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public constant returns ( uint256 euroUlps ) { uint256 totalNeumarkUlps = cumulative ( totalEuroUlps ) ; require ( totalNeumarkUlps >= burnNeumarkUlps ) ; uint256 fromNmk = totalNeumarkUlps - burnNeumarkUlps ; uint newTotalEuroUlps = cumulativeInverse ( fromNmk , minEurUlps , maxEurUlps ) ; assert ( totalEuroUlps >= newTotalEuroUlps ) ; return totalEuroUlps - newTotalEuroUlps ; }
","returns amount of euro corresponding to burned neumarks
"
"function changeDepositAddress ( address _depositAddress ) external ;
","Called when deposit address needs to change
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( ! isUserInBlackList ( msg . sender ) ) ; return super . transfer ( _to , _value ) ; }
","transfer token for a specified address
"
"function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }
","Allows the owner to revoke the vesting .
"
"function safetyInvariantCheck ( uint256 _value ) public { if ( ! newToken . isNewToken ( ) ) revert ( ) ; uint oldSupply = oldToken . totalSupply ( ) ; uint newSupply = newToken . totalSupply ( ) ; if ( safeAdd ( oldSupply , newSupply ) != safeSub ( correctOriginalSupply , _value ) ) { InvariantCheckFailed ( oldSupply , newSupply , correctOriginalSupply , _value ) ; } else { InvariantCheckPassed ( oldSupply , newSupply , correctOriginalSupply , _value ) ; } }
","Check to make sure that the current sum of old and new version tokens is still equal to the original number of old version tokens
"
"function tokenFactory ( uint256 _amount ) public onlyAdmin returns ( bool success ) { require ( _amount > 0 ) ; require ( tokenMintingEnabled ) ; require ( tokenMint ( msg . sender , _amount ) ) ; return true ; }
","Used to mint tokens , only usable by the contract owner
"
"function checkMinimalGoal ( ) internal { if ( tokenBalanceOf [ this ] <= _totalSupply - icoMin ) { minimalGoalReached = true ; minGoalReached ( icoMin , ""Minimal goal of ICO is reached!"" ) ; } }
","Check if minimal goal of ICO is reached
"
"function getNumberOfDeedsByAddress ( string propertyAddress ) public constant returns ( uint256 ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; return addressRegistry [ propertyAddressHash ] . length ; }
","Returns number of deeds registered for a particular address
"
"function setCampaignPriceById ( bytes32 bidId , uint price ) public onlyIfWhitelisted ( ""setCampaignPriceById"" , msg . sender ) onlyIfCampaignExists ( ""setCampaignPriceById"" , bidId ) { campaigns [ bidId ] . setPrice ( price ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
","Set a new price for a campaign Based on the Campaign id , updates the value paid for each proof of attention registered .
"
"function setKingdomFactory ( KingdomFactory _kingdomFactory ) { externalEnter ( ) ; setKingdomFactoryRP ( _kingdomFactory ) ; externalLeave ( ) ; }
","Used by topWizard to vary the factory contract which will be used to create future Kingdoms .
"
"function setSellCeiling ( uint256 ceiling ) public onlyOwner { sellCeiling = ceiling ; }
","Set the highest price an ask can be listed .
"
"function transferableHavvens ( address account ) public view returns ( uint ) { uint draft = issuanceDraft ( account ) ; uint collat = collateral ( account ) ; if ( draft > collat ) { return 0 ; } uint bal = balanceOf ( account ) ; if ( draft > safeSub ( collat , bal ) ) { return safeSub ( collat , draft ) ; } return bal ; }
","The number of havvens that are free to be transferred by an account .
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address _owner ) { _owner = animecardToOwner [ _tokenId ] ; require ( _owner != address ( 0 ) ) ; }
","Required for ERC-721 compliance .
"
"function lockedCollateral ( address account ) public view returns ( uint ) { uint debt = issuanceDraft ( account ) ; uint collat = collateral ( account ) ; if ( debt > collat ) { return collat ; } return debt ; }
","Collateral that has been locked due to issuance , and can not be transferred to other addresses .
"
"function setCrowdsaleAddress ( address _crowdsale ) external onlyOwner whenNotPaused { require ( _crowdsale != address ( 0 ) ) ; crowdsale = _crowdsale ; }
","Function to set the crowdsale smart contract 's address only by the owner of this token
"
"function findAdmin ( uint64 idAdmin ) internal returns ( PledgeAdmin storage ) { require ( idAdmin < admins . length ) ; return admins [ idAdmin ] ; }
","A getter to look up a Admin 's details
"
"function burn ( uint num ) public { require ( num > 0 ) ; require ( balances [ msg . sender ] >= num ) ; require ( totalSupply >= num ) ; uint pre_balance = balances [ msg . sender ] ; balances [ msg . sender ] -= num ; totalSupply -= num ; Burnt ( msg . sender , num , totalSupply ) ; Transfer ( msg . sender , 0x0 , num ) ; assert ( balances [ msg . sender ] == pre_balance - num ) ; }
","Allows ` msg.sender ` to simply destroy ` num ` token units ( Rei ) .
"
"function castVote ( ) external { uint8 choice ; if ( msg . sender == whitelistedSenderAdresses [ 0 ] ) { choice = 0 ; } else if ( msg . sender == whitelistedSenderAdresses [ 1 ] ) { choice = 1 ; } else if ( msg . sender == whitelistedSenderAdresses [ 2 ] ) { choice = 2 ; } else if ( msg . sender == whitelistedSenderAdresses [ 3 ] ) { choice = 3 ; } else { require ( false , ""Only whitelisted sender addresses can cast votes."" ) ; } voteCountTotal = safeAdd40 ( voteCountTotal , 1 ) ; currentVoteResults [ choice ] = safeAdd32 ( currentVoteResults [ choice ] , 1 ) ; emit NewVote ( choice , currentVoteResults ) ; }
","Cast your note .
"
"function withdrawBonuses ( bytes32 _userKey , uint _value , address _withdrawAddress , uint _feeAmount , address _feeAddress ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; require ( _withdrawAddress != 0x0 ) ; DepositWalletInterface _wallet = DepositWalletInterface ( wallet ) ; ERC20Interface _bonusToken = ERC20Interface ( bonusToken ) ; if ( _bonusToken . balanceOf ( _wallet ) < _value ) { return _emitError ( PROFITEROLE_ERROR_INSUFFICIENT_BONUS_BALANCE ) ; } if ( OK != _withdrawBonuses ( _userKey , _value ) ) { revert ( ) ; } if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || OK == _wallet . withdraw ( _bonusToken , _feeAddress , _feeAmount ) ) ) { revert ( ) ; } if ( OK != _wallet . withdraw ( _bonusToken , _withdrawAddress , _value - _feeAmount ) ) { revert ( ) ; } BonusesWithdrawn ( _userKey , _value , now ) ; return OK ; }
","Allows to withdraw user 's bonuses that he deserves due to Treasury shares for every distribution period .
"
"function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( ""pMinDeposit"" ) ; bytes32 propID = keccak256 ( abi . encodePacked ( _name , _value ) ) ; bytes32 _nameKec = keccak256 ( abi . encodePacked ( _name ) ) ; if ( _nameKec == DISPENSATION_PCT_KEC || _nameKec == P_DISPENSATION_PCT_KEC ) { require ( _value <= 100 ) ; } if ( keccak256 ( abi . encodePacked ( _name ) ) == NEW_REGISTRY_KEC ) { require ( getNewRegistry ( ) == address ( 0 ) ) ; require ( _value != 0 ) ; require ( msg . sender == owner ) ; require ( ( _value & 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff ) == _value ) ; require ( this . doesContractImplementInterface ( address ( _value ) , REGISTRY_INTERFACE_REQUIREMENT ) ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( ""pApplyStageLen"" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; emit _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry ) ; return propID ; }
","propose a reparamaterization of the key _name 's value to _value .
"
"function name ( ) external pure returns ( string _name ) ;
","A descriptive name for a collection of NFTs in this contract
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { require ( _tokenId < warriors . length ) ; owner = warriorToOwner [ _tokenId ] ; }
","Returns the address currently assigned ownership of a given Warrior .
"
"function bulkTokenMint ( address [ ] beneficiaries , uint256 [ ] amounts ) onlyOwner external { require ( beneficiaries . length == amounts . length ) ; for ( uint32 i = 0 ; i < beneficiaries . length ; i ++ ) { require ( token . mint ( beneficiaries [ i ] , amounts [ i ] ) ) ; } }
","Bulk mint tokens ( different amounts )
"
"function canIssueAttributeType ( uint256 attributeTypeID ) external view returns ( bool ) { return ( _validAttributeTypeID == attributeTypeID && _jurisdiction . canIssueAttributeType ( address ( this ) , _validAttributeTypeID ) ) ; }
","Check if the validator is approved to issue attributes of the type with ID ` attributeTypeID ` on the jurisdiction .
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) { return false ; } allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function distributeSupply ( address to , uint tokens ) public onlyOwner returns ( bool success ) { uint tokenAmount = tokens . mul ( 10 ** uint ( decimals ) ) ; require ( _circulatingSupply . add ( tokenAmount ) <= _totalSupply ) ; _circulatingSupply = _circulatingSupply . add ( tokenAmount ) ; balances [ to ] = tokenAmount ; return true ; }
","Sending Tokens to an address
"
"function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
","Decrease the amount of tokens that an owner allowed to a spender .
"
"function disableTransfer ( ) ;
","Function to disable the transfer of Dao shares
"
"function addPriceTier ( uint price ) public onlyOwner { tableStakesOptions . push ( price ) ; }
","In case we need extra price tiers ( table stakes where people can play ) we can add additional ones
"
"function setTokenName ( Data storage self , string tokenName ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.name' , address ( this ) ) ) ; require ( self . Storage . setString ( id , tokenName ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set the token name for Token interfaces
"
"function recover ( bytes32 hash , bytes sig ) public pure returns ( address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( sig . length != 65 ) { return ( address ( 0 ) ) ; } assembly { r := mload ( add ( sig , 32 ) ) s := mload ( add ( sig , 64 ) ) v := byte ( 0 , mload ( add ( sig , 96 ) ) ) } if ( v < 27 ) { v += 27 ; } if ( v != 27 && v != 28 ) { return ( address ( 0 ) ) ; } else { return ecrecover ( hash , v , r , s ) ; } }
","Recover signer address from a message by using his signature
"
"function claimTokens ( address _token ) onlyController public { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; emit ClaimedTokens ( _token , controller , balance ) ; }
","Extracting the wrongly sent token back into the contract set to 0 if want to get ether .
"
"function removeHolderAddress ( bytes32 _externalHolderId , address _address ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; HoldersData storage _holderData = holders [ _holderIndex ] ; uint _tempIndex = _holderData . address2Index [ _address ] ; require ( _tempIndex != 0 ) ; address _lastAddress = _holderData . index2Address [ _holderData . holderAddressCount ] ; _holderData . address2Index [ _lastAddress ] = _tempIndex ; _holderData . index2Address [ _tempIndex ] = _lastAddress ; delete _holderData . address2Index [ _address ] ; _holderData . holderAddressCount = _holderData . holderAddressCount . sub ( 1 ) ; delete holderAddress2Id [ _address ] ; _emitHolderAddressRemoved ( _externalHolderId , _address , _holderIndex ) ; return OK ; }
","Remove an address owned by a holder .
"
"function refundNonWhitelistedPerson ( address _address ) public onlyOwner { uint refundAmount = nonWLBalanceOf [ _address ] ; nonWLBalanceOf [ _address ] = 0 ; _address . transfer ( refundAmount ) ; }
","Function to process cases when person send more than 10 ETH to smartcontract but never provided KYC data and wants/needs to be refunded .
"
"function unpause ( ) external whenPaused onlyOwner { set ( PAUSED , false ) ; emit Unpause ( now ) ; }
","Called by the owner to unpause , returns to normal state
"
"function removeValidator ( address validator ) external onlyOwner whenNotPaused { require ( isValidator ( validator ) , ""unable to remove, no validator located at the provided address"" ) ; while ( _validatorApprovals [ validator ] . length > 0 && gasleft ( ) > 25000 ) { uint256 lastIndex = _validatorApprovals [ validator ] . length . sub ( 1 ) ; uint256 targetApproval = _validatorApprovals [ validator ] [ lastIndex ] ; delete _attributeTypes [ targetApproval ] . approvedValidators [ validator ] ; delete _validatorApprovalsIndex [ validator ] [ targetApproval ] ; _validatorApprovals [ validator ] . length -- ; } require ( _validatorApprovals [ validator ] . length == 0 , ""Cannot remove validator - first remove any existing validator approvals"" ) ; address lastAccount = _validatorAccounts [ _validatorAccounts . length . sub ( 1 ) ] ; _validatorAccounts [ _validators [ validator ] . index ] = lastAccount ; _validators [ lastAccount ] . index = _validators [ validator ] . index ; _validatorAccounts . length -- ; delete _validators [ validator ] ; emit ValidatorRemoved ( validator ) ; }
","Remove the validator at address ` validator ` from the jurisdiction .
"
"function addMarketplaceContract ( address _marketplaceContract ) public onlyOwner { require ( address ( marketplaceContract ) == 0x0 ) ; marketplaceContract = _marketplaceContract ; }
","adds marketplace address to contract only if it does n't already exist
"
"function payDividends ( uint _value ) returns ( bool ) ;
","Pay dividends of ` _value `
"
"function _depositEscrow ( uint256 _amount ) internal returns ( bool ) { currentBalance = currentBalance . add ( _amount ) ; return true ; }
","update current balance , if proper token amount approved
"
"function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( ""pMinDeposit"" ) ; bytes32 propID = keccak256 ( abi . encodePacked ( _name , _value ) ) ; if ( keccak256 ( abi . encodePacked ( _name ) ) == keccak256 ( abi . encodePacked ( ""dispensationPct"" ) ) || keccak256 ( abi . encodePacked ( _name ) ) == keccak256 ( abi . encodePacked ( ""pDispensationPct"" ) ) ) { require ( _value <= 100 ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( ""pApplyStageLen"" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; emit _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry , msg . sender ) ; return propID ; }
","propose a reparamaterization of the key _name 's value to _value .
"
"function pause ( ) public onlyOwner { _pause ( ) ; }
","unpause registration function
"
"function withdrawFunds ( uint256 _amount ) external whenNotPaused onlyAdmin { require ( _amount <= address ( this ) . balance , ""The amount should be less than the balance/"" ) ; msg . sender . transfer ( _amount ) ; emit FundsWithdrawn ( msg . sender , _amount ) ; }
","This feature enables the admins to withdraw Ethers held in this contract .
"
"function setTopWinnerPrizes ( ) external onlyAdmin checkState ( pointsValidationState . OrderChecked ) { uint256 percent = 0 ; uint [ ] memory tokensEquals = new uint [ ] ( 30 ) ; uint16 tokenEqualsCounter = 0 ; uint256 currentTokenId ; uint256 currentTokenPoints ; uint256 lastTokenPoints ; uint32 counter = 0 ; uint256 maxRange = 13 ; if ( tokens . length < 201 ) { maxRange = 10 ; } while ( payoutRange < maxRange ) { uint256 inRangecounter = payDistributionAmount [ payoutRange ] ; while ( inRangecounter > 0 ) { currentTokenId = sortedWinners [ counter ] ; currentTokenPoints = tokenToPointsMap [ currentTokenId ] ; inRangecounter -- ; if ( inRangecounter == 0 && payoutRange == maxRange - 1 ) { if ( currentTokenPoints == lastTokenPoints ) { percent += payoutDistribution [ payoutRange ] ; tokensEquals [ tokenEqualsCounter ] = currentTokenId ; tokenEqualsCounter ++ ; } else { tokenToPayoutMap [ currentTokenId ] = payoutDistribution [ payoutRange ] ; } } if ( counter != 0 && ( currentTokenPoints != lastTokenPoints || ( inRangecounter == 0 && payoutRange == maxRange - 1 ) ) ) { for ( uint256 i = 0 ; i < tokenEqualsCounter ; i ++ ) { tokenToPayoutMap [ tokensEquals [ i ] ] = percent . div ( tokenEqualsCounter ) ; } percent = 0 ; tokensEquals = new uint [ ] ( 30 ) ; tokenEqualsCounter = 0 ; } percent += payoutDistribution [ payoutRange ] ; tokensEquals [ tokenEqualsCounter ] = currentTokenId ; tokenEqualsCounter ++ ; counter ++ ; lastTokenPoints = currentTokenPoints ; } payoutRange ++ ; } pValidationState = pointsValidationState . TopWinnersAssigned ; lastPrizeGiven = counter ; }
","Assigns prize percentage for the lucky top 30 winners .
"
"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; cardTokenToApproved [ _tokenId ] = _to ; emit Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function configure ( uint256 _maxHolderCount ) public onlyFactory { maxHolderCount = _maxHolderCount ; }
","Used to intialize the variables of the contract
"
"function ( ) public payable { if ( msg . sender != owner ) revert ( ) ; }
","Fall Back Function , not to receive ether directly and/or accidentally
"
"function ownerDeclareFailure ( ) external onlyOwner { require ( ! contractFailed ) ; contractFailed = true ; }
","Declare Crowdsale failure ( no more ETH are accepted from participants )
"
"function ( ) { externalEnter ( ) ; fallbackRP ( ) ; externalLeave ( ) ; }
","Claim throne by sending funds to the contract .
"
"function referralSale ( address beneficiary , address referrer ) payable public returns ( bool ) { sale ( beneficiary , msg . value , referrer ) ; return true ; }
","Sell tokens via RefferalCrowdsale contract
"
"function getRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return getInvitationRewardBalance ( memberAddress ) + getLoyaltyRewardBalance ( memberAddress ) ; }
","Called to obtain the reward balance of any given member
"
"function checkTime ( ) public timedStateChange ( address ( 0 ) , 0 , true ) onlyowner { }
","explicit trigger for timed state changes
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { mywoowcoinrecipiente spender = mywoowcoinrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it
"
"function depositPool ( uint256 amountToDeposit ) public onlyOwner { uint256 amountDeposited = depositInternal ( msg . sender , amountToDeposit , true ) ; emit PoolDeposit ( msg . sender , amountDeposited ) ; }
","This function can only be called by the contract owner
"
"function updateMaxWei ( uint256 _maxWei ) public onlyOwner { maxWei = _maxWei ; }
","Funtion to update maxWei contribution
"
"function changePermissionMulti ( address _delegate , address [ ] _modules , bytes32 [ ] _perms , bool [ ] _valids ) external withPerm ( CHANGE_PERMISSION ) { require ( _delegate != address ( 0 ) , ""invalid address"" ) ; require ( _modules . length > 0 , ""0 length is not allowed"" ) ; require ( _modules . length == _perms . length , ""Array length mismatch"" ) ; require ( _valids . length == _perms . length , ""Array length mismatch"" ) ; for ( uint256 i = 0 ; i < _perms . length ; i ++ ) { _changePermission ( _delegate , _modules [ i ] , _perms [ i ] , _valids [ i ] ) ; } }
","Used to change one or more permissions for a single delegate at once
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public whenNotPaused transferFromConditionsRequired ( _from , _to ) returns ( bool ) { require ( _amount <= allowance ( _from , msg . sender ) , ""not enough allowance to transfer"" ) ; _transfer ( _to , _from , _amount ) ; tokenStorage . subAllowance ( _from , msg . sender , _amount ) ; return true ; }
","Initiates a transfer operation between address ` _from ` and ` _to ` .
"
"function emergencyFreeze ( ) isAdmin external { isFrozen = true ; }
","Freeze token circulation
"
"function fillUpAllowance ( ) public { uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . approve ( token , amount ) ; }
","Allow the token itself to send tokens using transferFrom ( ) .
"
"function tokenAddresses ( ) constant returns ( address [ ] ) { return tokens ; }
","Get all registered tokens
"
"function removeFromWhitelist ( address _address ) public onlyWhitelister { require ( _address != address ( 0 ) ) ; emit WhitelistRemove ( whitelister , _address ) ; whitelist [ _address ] = false ; }
","Only callable by the whitelister .
"
"function reclaimEther ( ) external onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
","Reclaim Ether that is accidentally sent to this contract .
"
"function doBuy ( ) internal { Tier tier = tiers [ tierCount ] ; assert ( msg . value <= tier . maxInvestorCap ( ) ) ; address caller = msg . sender ; WhitelistedInvestor storage investor = investors [ caller ] ; uint256 investorTokenBP = investorAmountTokensToBuy ( caller ) ; require ( investorTokenBP > 0 ) ; if ( investor . contributedAmount == 0 ) { assert ( msg . value >= tier . minInvestorCap ( ) ) ; } uint256 toFund = msg . value ; uint256 tokensGenerated = toFund . mul ( tier . exchangeRate ( ) ) ; require ( tokensGenerated >= 1 ) ; uint256 tokensleftForSale = leftForSale ( ) ; if ( tokensleftForSale > investorTokenBP ) { if ( tokensGenerated > investorTokenBP ) { tokensGenerated = investorTokenBP ; toFund = investorTokenBP . div ( tier . exchangeRate ( ) ) ; } } if ( investorTokenBP > tokensleftForSale ) { if ( tokensGenerated > tokensleftForSale ) { tokensGenerated = tokensleftForSale ; toFund = tokensleftForSale . div ( tier . exchangeRate ( ) ) ; } } investor . contributedAmount = investor . contributedAmount . add ( toFund ) ; tier . increaseInvestedWei ( toFund ) ; if ( tokensGenerated == tokensleftForSale ) { finalize ( ) ; } assert ( cnd . generateTokens ( caller , tokensGenerated ) ) ; totalTokensSold = totalTokensSold . add ( tokensGenerated ) ; contributionWallet . transfer ( toFund ) ; NewSale ( caller , toFund , tokensGenerated ) ; uint256 toReturn = msg . value . sub ( toFund ) ; if ( toReturn > 0 ) { caller . transfer ( toReturn ) ; Refund ( toReturn ) ; } }
","actual method that funds investor and contribution wallet
"
"function transferFeeIncurred ( uint value ) public view returns ( uint ) { return safeMul_dec ( value , transferFeeRate ) ; }
","Calculate the Fee charged on top of a value being sent
"
"function addNewAddress ( address _newAddress ) public ownerOnly { addresses . push ( _newAddress ) ; }
","Adds new community logic contract address to Registrar
"
"function sendBoughtTokens ( address _beneficiary , uint256 _tokens ) external { require ( locked ) ; require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _beneficiary != address ( 0 ) ) ; require ( _tokens != 0 ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ depositAddress ] = balances [ depositAddress ] . add ( _tokens ) ; emit TokensMinted ( msg . sender , depositAddress , _tokens ) ; _transfer ( depositAddress , _beneficiary , _tokens ) ; }
","Called when tokens are bought in token sale
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; if ( ! _spender . call ( bytes4 ( bytes32 ( sha3 ( ""receiveApproval(address,uint256,address,bytes)"" ) ) ) , msg . sender , _amount , this , _extraData ) ) { throw ; } return true ; }
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender `
"
"function doDisableSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) return false ; if ( _escrow . sellerCanCancelAfter == 0 ) return false ; escrows [ _tradeHash ] . sellerCanCancelAfter = 0 ; emit SellerCancelDisabled ( _tradeHash ) ; if ( msg . sender == relayer ) { increaseGasSpent ( _tradeHash , GAS_doDisableSellerCancel + _additionalGas ) ; } return true ; }
","Prevents the seller from cancelling an escrow .
"
"function _investAsBonusProgram ( address _beneficiary , uint256 _amountTokens ) internal { uint256 bonusTokens = _calculateBonus ( _amountTokens , tokensBoughtInBonusProgram ) ; uint256 amountTokensWithBonus = _amountTokens . add ( bonusTokens ) ; tokensBoughtInBonusProgram = tokensBoughtInBonusProgram . add ( _amountTokens ) ; _depositTokens ( _beneficiary , amountTokensWithBonus ) ; emit BoughtBonusProgram ( _beneficiary , _amountTokens , bonusTokens ) ; if ( tokensBoughtInBonusProgram >= INITIAL_BONUSLIST_TOKENS ) { bonusProgramEnded = true ; } }
","Internal function for invest as a bonusprogram member
"
"function updatePlotData ( uint256 plotIndex , string ipfsHash , string url ) external { require ( plotIndex >= 0 ) ; require ( plotIndex < ownership . length ) ; require ( msg . sender == ownership [ plotIndex ] . owner ) ; data [ plotIndex ] = PlotData ( ipfsHash , url ) ; }
","Updates the data for a specific plot .
"
"function exitThisIcoForHalfOfTokenPrice ( ) { require ( icoExitIsPossible ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( currentTokenPrice > 1 ) ; uint256 amount = tokenBalanceOf [ msg . sender ] ; uint256 revenue = amount * currentTokenPrice / 2 ; require ( this . balance >= revenue ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( revenue ) ; }
","Sell all metadollars for half of a price and exit this ICO
"
"function issueNomins ( uint amount ) public optionalProxy requireIssuer ( messageSender ) { address sender = messageSender ; require ( amount <= remainingIssuableNomins ( sender ) , ""Amount must be less than or equal to remaining issuable nomins"" ) ; uint lastTot = nomin . totalSupply ( ) ; uint preIssued = nominsIssued [ sender ] ; nomin . issue ( sender , amount ) ; nominsIssued [ sender ] = safeAdd ( preIssued , amount ) ; updateIssuanceData ( sender , preIssued , lastTot ) ; }
","Issue nomins against the sender 's havvens .
"
"function canAddAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) { bytes32 hash = calculateAttributeApprovalHash ( account , msg . sender , attributeTypeID , value , fundsRequired , validatorFee ) ; address signingKey = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; address validator = _signingKeys [ signingKey ] ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; return ( fundsRequired >= minimumStake . add ( jurisdictionFee ) . add ( validatorFee ) && ! _invalidAttributeApprovalHashes [ hash ] && canValidate ( validator , attributeTypeID ) && ! _issuedAttributes [ account ] [ attributeTypeID ] . exists ) ; }
","Check if a given signed attribute approval is currently valid for a given account when submitted by the operator at ` msg.sender ` .
"
"function getEmoji ( uint256 _tokenId ) public view returns ( string emojiName , uint256 sellingPrice , address owner ) { Emoji storage emoji = emojis [ _tokenId ] ; emojiName = emoji . name ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific emoji .
"
"function detach ( ) public { if ( m_state == State . MINTING2PUBLIC_SALES ) { require ( msg . sender == m_sale ) ; m_sale = address ( 0 ) ; } else if ( m_state == State . MINTING2POOLS ) { require ( msg . sender == m_pools ) ; m_pools = address ( 0 ) ; changeState ( State . CIRCULATING_TOKEN ) ; m_SMR . disableMinting ( ) ; assert ( m_SMR . startCirculation ( ) ) ; m_SMR . detachControllerForever ( ) ; } else { revert ( ) ; } }
","Detach is executed by sale contract or token pools contract
"
"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) public onlyOwner { sellPrice_ = newSellPrice ; buyPrice_ = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function collectFee ( address token ) external onlyOwner { uint256 amount = balances [ token ] [ joysoWallet ] ; require ( amount > 0 ) ; balances [ token ] [ joysoWallet ] = 0 ; if ( token == 0 ) { msg . sender . transfer ( amount ) ; } else { require ( ERC20 ( token ) . transfer ( msg . sender , amount ) ) ; } Withdraw ( token , joysoWallet , amount , 0 ) ; }
","collect the fee to owner 's address , only owner
"
"function commitPeriodActive ( uint _pollID ) constant public returns ( bool active ) { require ( pollExists ( _pollID ) ) ; return ! isExpired ( pollMap [ _pollID ] . commitEndDate ) ; }
","Checks if the commit period is still active for the specified poll
"
"function updateRates ( bytes4 [ ] currencyKeys , uint [ ] newRates , uint timeSent ) external onlyOracle returns ( bool ) { return internalUpdateRates ( currencyKeys , newRates , timeSent ) ; }
","Set the rates stored in this contract
"
"function symbol ( ) public view returns ( string ) { return ""PXCN"" ; }
","Get the symbol for this contract token
"
"function unverify ( address _address ) public onlyOwner { verifiedAddresses [ _address ] = false ; }
","Only contract owner
"
"function releaseVested ( ) public returns ( bool ) ;
","Release vested tokens after a maturity date
"
"function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { return true ; }
","Checks if the makeOrder price is reasonable and not manipulative
"
"function addNewAirdrop ( uint _tokenAmount , string _name , uint _countDown , address _smartContract ) public minEth payable { Token t = Token ( _smartContract ) ; if ( t . balanceOf ( this ) >= _tokenAmount ) uint lastIndex = airdrops . length ++ ; Airdrop storage airdrop = airdrops [ lastIndex ] ; airdrop . id = idCounter ; airdrop . tokenAmount = _tokenAmount ; airdrop . name = _name ; airdrop . countDown = _countDown ; airdrop . distributor = msg . sender ; airdrop . tokenSC = Token ( _smartContract ) ; idCounter = airdrop . id + 1 ; }
","Adds a new airdrop to the smart contract and starts the count down until it is distributed
"
"function changeFactoryUsageFee ( uint256 _newUsageCost ) external ;
","Used to change the usage fee
"
"function createNew ( bytes32 _regName , address _owner ) payable returns ( address kAddr_ ) ;
","Create a new product contract
"
"function ( ) payable { if ( now < PRESALE_START_DATE ) throw ; if ( now > PRESALE_END_DATE ) throw ; if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) throw ; if ( msg . value > MAXIMUM_PARTICIPATION_AMOUNT ) throw ; if ( safeIncrement ( totalFunding , msg . value ) > PRESALE_MAXIMUM_FUNDING ) throw ; addBalance ( msg . sender , msg . value ) ; }
","A participant 's contribution will be rejected if the presale has been funded to the maximum amount
"
"function getTokenSupply ( Data storage self , string currency ) internal view returns ( uint supply ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.supply' , currency ) ) ; return self . Storage . getUint ( id ) ; }
","Get the token supply for a given TokenIO TSM currency symbol ( e.g .
"
"function claimTokens ( address _claimtoken ) onlyAdmin public returns ( bool ) { if ( _claimtoken == 0x0 ) { owner . transfer ( this . balance ) ; return true ; } ERC20 claimtoken = ERC20 ( _claimtoken ) ; uint balance = claimtoken . balanceOf ( this ) ; claimtoken . transfer ( owner , balance ) ; ClaimedTokens ( _claimtoken , owner , balance ) ; return true ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function updateDarknodeRegistry ( DarknodeRegistry _newDarknodeRegistry ) external onlyOwner { emit LogDarknodeRegistryUpdated ( darknodeRegistry , _newDarknodeRegistry ) ; darknodeRegistry = _newDarknodeRegistry ; }
","Allows the owner to update the address of the DarknodeRegistry contract .
"
"function fundDao ( ) returns ( bool ) ;
","Function to fund the Dao with 'msg.sender ' as 'beneficiary '
"
"function claimReward ( uint _challengeID ) public { Challenge storage challenge = challenges [ _challengeID ] ; require ( challenge . tokenClaims [ msg . sender ] == false ) ; require ( challenge . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID ) ; uint reward = voterReward ( msg . sender , _challengeID ) ; challenge . winningTokens -= voterTokens ; challenge . rewardPool -= reward ; challenge . tokenClaims [ msg . sender ] = true ; emit _RewardClaimed ( _challengeID , reward , msg . sender ) ; require ( token . transfer ( msg . sender , reward ) ) ; }
","Claim the tokens owed for the msg.sender in the provided challenge
"
"function setCustomDisputeFee ( bytes32 question_id , uint256 fee ) onlyOwner public { custom_dispute_fees [ question_id ] = fee ; emit LogSetCustomDisputeFee ( question_id , fee ) ; }
","Set a custom fee for this particular question
"
"function addToEscrow ( address _from , uint256 _amount ) private { tokenEscrow [ _from ] = tokenEscrow [ _from ] . add ( _amount ) ; emit TokenMarketplaceDeposit ( _from , _amount ) ; }
","Helper function to add to escrow balance
"
"function clearInventory ( uint256 _productId ) external onlyCLevel { _clearInventory ( _productId ) ; ProductInventoryAdjusted ( _productId , availableInventoryOf ( _productId ) ) ; }
","clearInventory clears the inventory of a product .
"
"function getApproved ( uint256 _tokenId ) external view returns ( address ) ;
","Get the approved address for a single NFT
"
"function setInitialBuyoutPrice ( uint256 _deedId , uint256 price ) public whenNotPaused { require ( _owns ( msg . sender , _deedId ) ) ; require ( ! identifierToBoughtOutOnce [ _deedId ] ) ; require ( validInitialBuyoutPrice ( _deedId , price ) ) ; identifierToBuyoutPrice [ _deedId ] = price ; SetBuyoutPrice ( _deedId , price ) ; }
","Manually set the initial buyout price of a plot .
"
"function getModule ( uint8 _moduleType , uint _moduleIndex ) public view returns ( bytes32 , address ) ;
","returns module list for a module type
"
"function isReadyToSynthesize ( uint256 _kydyId ) public view returns ( bool ) { require ( _kydyId > 0 ) ; Kydy storage kyd = kydys [ _kydyId ] ; return _isReadyToSynthesize ( kyd ) ; }
","Checks if this Kydy is able to synthesize
"
"function takeFee ( uint256 _amount ) external returns ( bool ) ;
","Used to withdraw the fee by the factory owner
"
"function modifyTicker ( address _owner , string _ticker , string _tokenName , uint256 _registrationDate , uint256 _expiryDate , bool _status ) external onlyOwner { require ( bytes ( _ticker ) . length > 0 && bytes ( _ticker ) . length <= 10 , ""Ticker length range (0,10]"" ) ; require ( _expiryDate != 0 && _registrationDate != 0 , ""Dates should not be 0"" ) ; require ( _registrationDate <= _expiryDate , ""Registration date should < expiry date"" ) ; require ( _owner != address ( 0 ) , ""Invalid address"" ) ; string memory ticker = Util . upper ( _ticker ) ; _modifyTicker ( _owner , ticker , _tokenName , _registrationDate , _expiryDate , _status ) ; }
","Only allowed to modify the tickers which are not yet deployed .
"
"function setRate ( uint _rateMe ) public ownerOnly { rateMe = _rateMe ; }
","This function will set the conversion rate .
"
"function transferFrom ( address from , address to , uint value , bytes data ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ from ] == 0 || value <= transferableHavvens ( from ) , ""Value to transfer exceeds available havvens"" ) ; _transferFrom_byProxy ( messageSender , from , to , value , data ) ; return true ; }
","ERC223 transferFrom function .
"
"function multiConfirm ( uint [ ] _idPayments ) public onlyOwner { for ( uint i = 0 ; i < _idPayments . length ; i ++ ) { doConfirmPayment ( _idPayments [ i ] ) ; } }
","` onlyOwner ` An efficient way to confirm multiple payments
"
"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; checkValue ( from , _fee ) ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
","Increase the amount of tokens that an owner allowed to a spender .
"
"function creditBoardGameRevenues ( GoBoard storage board ) private boardGameEnded ( board ) boardNotPaid ( board ) { uint updatedHostShare = HOST_SHARE ; uint updatedLoserShare = 0 ; uint amountBlack = 0 ; uint amountWhite = 0 ; uint amountCFO = 0 ; uint fullAmount = 1000 ; if ( board . status == BoardStatus . BlackWin || board . status == BoardStatus . WhiteWin ) { if ( board . isHonorableLoss ) { updatedHostShare = HOST_SHARE - HONORABLE_LOSS_BONUS ; updatedLoserShare = HONORABLE_LOSS_BONUS ; } if ( board . status == BoardStatus . BlackWin ) { amountBlack = board . boardBalance . mul ( WINNER_SHARE ) . div ( fullAmount ) ; amountWhite = board . boardBalance . mul ( updatedLoserShare ) . div ( fullAmount ) ; } if ( board . status == BoardStatus . WhiteWin ) { amountWhite = board . boardBalance . mul ( WINNER_SHARE ) . div ( fullAmount ) ; amountBlack = board . boardBalance . mul ( updatedLoserShare ) . div ( fullAmount ) ; } amountCFO = board . boardBalance . mul ( updatedHostShare ) . div ( fullAmount ) ; } if ( board . status == BoardStatus . Draw || board . status == BoardStatus . Canceled ) { amountCFO = 0 ; if ( board . whiteAddress != 0 ) { amountBlack = board . boardBalance . div ( 2 ) ; amountWhite = board . boardBalance . div ( 2 ) ; } else { amountBlack = board . boardBalance ; } } assert ( amountBlack + amountWhite + amountCFO == board . boardBalance ) ; board . boardBalance = 0 ; asyncSend ( board . blackAddress , amountBlack ) ; asyncSend ( board . whiteAddress , amountWhite ) ; asyncSend ( CFO , amountCFO ) ; }
","The main function to split game revenues , this is triggered only by changing the game 's state to one of the ending game states .
"
"function assignVested ( address _receiver , uint256 _amount , uint64 _start , uint64 _cliff , uint64 _vested , bool _revokable ) external authP ( ASSIGN_ROLE , arr ( _receiver , _amount ) ) returns ( uint256 ) { require ( vestingsLengths [ _receiver ] < MAX_VESTINGS_PER_ADDRESS , ERROR_TOO_MANY_VESTINGS ) ; require ( _start <= _cliff && _cliff <= _vested , ERROR_WRONG_CLIFF_DATE ) ; uint256 vestingId = vestingsLengths [ _receiver ] ++ ; vestings [ _receiver ] [ vestingId ] = TokenVesting ( _amount , _start , _cliff , _vested , _revokable ) ; _assign ( _receiver , _amount ) ; emit NewVesting ( _receiver , vestingId , _amount ) ; return vestingId ; }
","Assign ` @ tokenAmount ( self.token ( ) : address , _amount , false ) ` tokens to ` _receiver ` from the Token Manager 's holdings with a ` _revokable : 'revokable ' : `` ` vesting starting at ` @ formatDate ( _start ) ` , cliff at ` @ formatDate ( _cliff ) ` ( first portion of tokens transferable ) , and completed vesting at ` @ formatDate ( _vested ) ` ( all tokens transferable )
"
"function name ( ) external constant returns ( string _name ) { return name ; }
","Check the name of the token ~ ERC-20 Standard
"
"function addReserve ( KyberReserveInterface reserve , bool isPermissionless ) public onlyOperator returns ( bool ) { require ( reserveType [ reserve ] == ReserveType . NONE ) ; reserves . push ( reserve ) ; reserveType [ reserve ] = isPermissionless ? ReserveType . PERMISSIONLESS : ReserveType . PERMISSIONED ; AddReserveToNetwork ( reserve , true , isPermissionless ) ; return true ; }
","can be called only by operator
"
"function auditContract ( address _auditor , bytes32 _codeHash , bytes _reportIPFS , bool _isApproved ) public whenNotPaused onlySolidStampRegisterContract { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; uint reward = Rewards [ hashAuditorCode ] ; TotalRequestsAmount = TotalRequestsAmount . sub ( reward ) ; uint commissionKept = calcCommission ( reward ) ; AvailableCommission = AvailableCommission . add ( commissionKept ) ; emit ContractAudited ( _auditor , _codeHash , _reportIPFS , _isApproved , reward ) ; _auditor . transfer ( reward . sub ( commissionKept ) ) ; }
","transfers reward to the auditor .
"
"function applyHotFix ( address newICO ) public validAddress ( newICO ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { EthPriceDependent next = EthPriceDependent ( newICO ) ; next . topUp . value ( address ( this ) . balance ) ( ) ; m_token . transfer ( newICO , m_token . balanceOf ( this ) ) ; m_token . switchToNextSale ( newICO ) ; }
","send everything to the new ( fixed ) ico smart contract
"
"function claim ( ) payable external MinimumBackersClaimed { if ( lastPrice == 0 ) throw ; if ( msg . value == 0 ) throw ; uint discountPrice = lastPrice * discountAmount / divisor ; uint tokenAmount = ( msg . value / discountPrice ) ; if ( tokenAmount + claimedUnits + prepaidUnits > promissoryUnits ) throw ; if ( backers [ msg . sender ] . length == 0 ) { backersAddresses . push ( msg . sender ) ; } backers [ msg . sender ] . push ( backerData ( discountPrice , tokenAmount , sha3 ( msg . sender ) , false , true , 0 ) ) ; claimedUnits += tokenAmount ; TokensClaimedEvent ( msg . sender , backers [ msg . sender ] . length - 1 , discountPrice , tokenAmount ) ; }
","` msg.sender.address ( ) ` is Purchasing ` ( msg.value / lastPrice ) .toFixed ( 0 ) ` superDAO Tokens at ` lastPrice `
"
"function execScript ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { uint256 location = SCRIPT_START_LOCATION ; while ( location < _script . length ) { address contractAddress = _script . addressAt ( location ) ; for ( uint i = 0 ; i < _blacklist . length ; i ++ ) { require ( contractAddress != _blacklist [ i ] ) ; } LogScriptCall ( msg . sender , address ( this ) , contractAddress ) ; uint256 calldataLength = uint256 ( _script . uint32At ( location + 0x14 ) ) ; uint256 calldataStart = _script . locationOf ( location + 0x14 + 0x04 ) ; assembly { let success := call ( sub ( gas , 5000 ) , contractAddress , 0 , calldataStart , calldataLength , 0 , 0 ) switch success case 0 { revert ( 0 , 0 ) } } location += ( 0x14 + 0x04 + calldataLength ) ; } }
","Executes a number of call scripts
"
"function removeValidator ( address _validator ) public onlyOwner { validators [ _validator ] = false ; emit ValidatorRemoved ( _validator ) ; }
","remove a Validator
"
"function setQuestionFee ( uint256 fee ) external { }
","Function for arbitrator to set an optional per-question fee .
"
"function setApprovalForAll ( address _operator , bool _approved ) external { ownerOperators [ msg . sender ] [ _operator ] = _approved ; ApprovalForAll ( msg . sender , _operator , _approved ) ; }
","Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets .
"
"function withdrawMarginPreSigned ( bytes _signature , address _from , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( block . number <= _validUntil ) ; bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( withdrawMarginPreSignedHashing ( address ( this ) , _from , _value , _fee , _nonce , _validUntil ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; require ( _from == from ) ; BCNTToken tokenContract = BCNTToken ( tokenAddress ) ; marginBalances [ _from ] = marginBalances [ _from ] . sub ( _value ) . sub ( _fee ) ; require ( tokenContract . transfer ( _from , _value ) ) ; require ( tokenContract . transfer ( msg . sender , _fee ) ) ; emit WithdrawMargin ( _from , _value ) ; emit WithdrawMarginPreSigned ( _from , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned withdraw to withdraw specified amount of margin
"
"function isRegisteredAccount ( address _address ) onlyAllowedAddresses public constant returns ( bool ) { return allowedAddresses [ _address ] ; }
","Check that address is registered .
"
"function setMtdAmount ( uint256 mtdAmountInWei ) isOwner { require ( mtdAmountInWei > 0 ) ; require ( mtdAmount != mtdAmountInWei ) ; mtdAmount = mtdAmountInWei ; updatePrices ( ) ; }
","Set current mtdAmount price in wei for one token
"
"function mint ( address _to , uint256 _tokenId ) public { require ( approvedContractAddresses [ msg . sender ] || msg . sender == owner , ""minter not approved"" ) ; _mint ( _to , _tokenId ) ; }
","Mint token function
"
"function changeCompetitionAddress ( address ofCompetition ) pre_cond ( isOwner ( ) ) { competitionAddress = ofCompetition ; }
","Changes the competition address
"
"function changeBonus ( uint256 _bonus ) external whenNotPaused onlyAdmin { require ( _bonus > 0 , ""Bonus must be greater than 0"" ) ; emit BonusChanged ( _bonus , bonus ) ; bonus = _bonus ; }
","Changes the bonus .
"
"function unregister ( bytes32 _key , address _address , uint _timestamp , uint _gasLimit , uint _gasPrice ) external returns ( uint ) ;
","Only registrations in future can be removed .
"
"function launchContract ( ) public onlyOwner { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; LaunchContract ( msg . sender , true ) ; }
","Used to launch the contract , and enabled token minting
"
"function recover ( address _from , address _to ) checkTrust ( _from , msg . sender ) public onlyContractOwner returns ( uint errorCode ) { address from = holders [ getHolderId ( _from ) ] . addr ; holders [ getHolderId ( _from ) ] . addr = _to ; holderIndex [ _to ] = getHolderId ( _from ) ; Emitter ( eventsHistory ) . emitRecovery ( from , _to , msg . sender ) ; return OK ; }
","Perform recovery procedure .
"
"function updateAccountSpendingPeriod ( Data storage self , address account ) internal returns ( bool success ) { uint begDate = getAccountSpendingPeriod ( self , account ) ; if ( begDate > now ) { return true ; } else { uint duration = 86400 ; require ( setAccountSpendingPeriod ( self , account , begDate . add ( ( ( now . sub ( begDate ) ) . div ( duration ) . add ( 1 ) ) . mul ( duration ) ) ) , ""Error: Unable to update account spending period."" ) ; return true ; } }
","Low-level API to ensure the account spending period is always current
"
"function isUserInGroup ( bytes32 _groupName , address _user ) public view returns ( bool ) { return isRegisteredUser ( _user ) && address2member [ _user ] . groupName2index [ _groupName ] != 0 ; }
","Check is user in group
"
"function initialiseTradeFlags ( Trade [ ] trades ) internal returns ( TradeFlag [ ] ) { TradeFlag [ ] memory tradeFlags = new TradeFlag [ ] ( trades . length ) ; for ( uint256 i = 0 ; i < trades . length ; i ++ ) { tradeFlags [ i ] . ignoreOrder = new bool [ ] ( trades [ i ] . orders . length ) ; } return tradeFlags ; }
","Initialises the trade flag struct
"
"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; } doTransfer ( _from , _to , _amount ) ; return true ; }
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function createAccount ( address _newUser ) public onlyRegistryAdmin { createAccountForUser ( _newUser ) ; }
","Create an account instantly without an invitation
"
"function approve ( address _spender , uint _value ) public returns ( bool ) { require ( msg . sender == address ( this ) ) ; require ( _spender != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _spender ] == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to transfer ` _value ` tokens from ` msg.sender ` to any address .
"
"function transfer ( address to , uint256 amount ) public returns ( bool success ) ;
","Send ` amount ` tokens to ` to ` from ` msg.sender `
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` in behalf of ` _from `
"
"function amountRaised ( ) public constant returns ( uint256 amount ) { }
","the goal the campaign must reach in order for it to succeed
"
"function setBackendProxyBuyer ( address _proxyAddress ) whenNotPaused onlyOwner external { proxy = _proxyAddress ; }
","Set RntTokenProxy address .
"
"function removeAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , ""Invalid address."" ) ; require ( admins [ _address ] , ""This address isn't an administrator."" ) ; require ( _address != owner ( ) , ""The owner cannot be added or removed to or from the administrator list."" ) ; admins [ _address ] = false ; emit AdminRemoved ( _address ) ; return true ; }
","Removes the specified address from the list of administrators .
"
"function close ( Data storage self , uint64 nonce , uint256 transferred_amount , bytes32 locksroot , bytes32 extra_hash , bytes signature ) { address transfer_address ; uint closer_index ; uint counterparty_index ; require ( self . closed == 0 ) ; self . closed = block . number ; closer_index = index_or_throw ( self , msg . sender ) ; self . closing_address = msg . sender ; if ( signature . length == 65 ) { transfer_address = recoverAddressFromSignature ( nonce , transferred_amount , locksroot , extra_hash , signature ) ; counterparty_index = index_or_throw ( self , transfer_address ) ; require ( closer_index != counterparty_index ) ; Participant storage counterparty = self . participants [ counterparty_index ] ; counterparty . nonce = uint64 ( nonce ) ; counterparty . locksroot = locksroot ; counterparty . transferred_amount = transferred_amount ; } }
","Close a channel between two parties that was used bidirectionally
"
"function deposit ( ) public payable onlyExistingUser returns ( uint256 ) { require ( msg . value > minSumDeposit , ""Deposit does not enough"" ) ; uint256 userId = addressToUser [ msg . sender ] ; users [ userId ] . balance = users [ userId ] . balance . add ( msg . value ) ; totalDeposit += msg . value ; _distributeInvestment ( msg . value ) ; _updateLeaders ( msg . sender , msg . value ) ; emit Deposit ( userId , msg . value ) ; return users [ userId ] . balance ; }
","deposit ethereum for user
"
"function ownerOf ( uint256 _tokenId ) public view returns ( address ) ;
","Find the owner of an NFT
"
"function name ( ) external view returns ( string _name ) { return _ERC721name ; }
","A descriptive name for a collection of NFTs in this contract
"
"function collateral ( address account ) public view returns ( uint ) { uint balance = tokenState . balanceOf ( account ) ; if ( escrow != address ( 0 ) ) { balance = balance . add ( escrow . balanceOf ( account ) ) ; } return balance ; }
","The total SNX owned by this account , both escrowed and unescrowed , against which synths can be issued .
"
"function unarchiveModule ( ModuleData storage _moduleData , address _module ) public { require ( _moduleData . isArchived , ""Module unarchived"" ) ; emit ModuleUnarchived ( _moduleData . moduleTypes , _module , now ) ; _moduleData . isArchived = false ; }
","Unarchives a module attached to the SecurityToken
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { testmonedarecipientefinal spender = testmonedarecipientefinal ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it
"
"function getGameState ( uint gameId ) public view returns ( GameStates ) { return games [ gameId ] . state ; }
","Returns the state of a specific game
"
"function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownedTokens [ _owner ] . length ; }
","Count all NFTs assigned to an owner
"
"function isRegularAddress ( address _addr ) internal constant returns ( bool ) { if ( _addr == 0 ) { return false ; } uint size ; assembly { size := extcodesize ( _addr ) } return size == 0 ; }
","Check whether an address is a regular address or not .
"
"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
","Approve transfer of tokens on behalf of _from
"
"function changeOwner ( address _newOwner ) onlyOwner { owner = _newOwner ; }
","` owner ` can step down and assign some other address to this role
"
"function _tagsByModules ( address [ ] _modules ) internal view returns ( bytes32 [ ] , address [ ] ) { uint256 counter = 0 ; uint256 i ; uint256 j ; for ( i = 0 ; i < _modules . length ; i ++ ) { counter = counter + IModuleFactory ( _modules [ i ] ) . getTags ( ) . length ; } bytes32 [ ] memory tags = new bytes32 [ ] ( counter ) ; address [ ] memory modules = new address [ ] ( counter ) ; bytes32 [ ] memory tempTags ; counter = 0 ; for ( i = 0 ; i < _modules . length ; i ++ ) { tempTags = IModuleFactory ( _modules [ i ] ) . getTags ( ) ; for ( j = 0 ; j < tempTags . length ; j ++ ) { tags [ counter ] = tempTags [ j ] ; modules [ counter ] = _modules [ i ] ; counter ++ ; } } return ( tags , modules ) ; }
","Returns all the tags related to the modules provided
"
"function signFork ( uint256 number , bytes32 hash ) public only ( ROLE_PLATFORM_OPERATOR_REPRESENTATIVE ) { require ( block . blockhash ( number ) == hash ) ; delete _nextForkName ; delete _nextForkUrl ; delete _nextForkBlockNumber ; _lastSignedBlockNumber = number ; _lastSignedBlockHash = hash ; _lastSignedTimestamp = block . timestamp ; LogForkSigned ( _lastSignedBlockNumber , _lastSignedBlockHash ) ; }
","Declare that the current fork ( as identified by a blockhash ) is the valid fork .
"
"function ownerSetCrowdsaleClosed ( bool status ) public onlyOwner { crowdsaleClosed = status ; }
","owner restricted function
"
"function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) { return operators [ _owner ] [ _operator ] ; }
","Returns true if the _operator can transfer the loans of the _owner
"
"function migrationSetBoard ( bytes32 boardHash , bytes32 name , string boardDescription , uint8 numPlayers , address boardOwner ) isOwner public returns ( bool ) { boards [ boardHash ] . boardName = name ; boards [ boardHash ] . boardDescription = boardDescription ; boards [ boardHash ] . numPlayers = numPlayers ; boards [ boardHash ] . boardOwner = boardOwner ; return true ; }
","Write board metadata for migration as contract owner only
"
"function revokeManualApproval ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , ""Invalid to address"" ) ; delete manualApprovals [ _from ] [ _to ] ; emit RevokeManualApproval ( _from , _to , msg . sender ) ; }
","Removes a pairs of addresses from manual approvals
"
"function unpause ( ) public onlyGameManager whenPaused { require ( nonFungibleContract != address ( 0 ) ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function bid ( ) public payable atStage ( Stages . AuctionStarted ) { require ( msg . value > 0 ) ; assert ( bids [ msg . sender ] + msg . value >= msg . value ) ; uint missingFunds = missingFundsToEndAuction ( ) ; require ( msg . value <= missingFunds ) ; bids [ msg . sender ] += msg . value ; receivedWei += msg . value ; walletAddress . transfer ( msg . value ) ; BidSubmission ( msg . sender , msg . value , missingFunds , block . timestamp ) ; assert ( receivedWei >= msg . value ) ; }
","Send ` msg.value ` WEI to the auction from the ` msg.sender ` account .
"
"function performBuyOrder ( OrderData order , uint256 amountToGiveForOrder ) public payable onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { exchange . depositEthers . value ( amountToGiveForOrder ) ( ) ; uint256 feeRate = exchange . feeRate ( ) ; exchange . takeSellOrder ( order . addresses , order . values , amountToGiveForOrder , order . v , order . r , order . s ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = SafeMath . div ( SafeMath . mul ( amountToGiveForOrder , order . values [ 0 ] ) , order . values [ 1 ] ) ; amountReceivedFromOrder = SafeMath . sub ( amountReceivedFromOrder , SafeMath . div ( amountReceivedFromOrder , feeRate ) ) ; }
","Perform a buy order at the exchange
"
"function createPermission ( address _entity , address _app , bytes32 _role , address _manager ) external auth ( CREATE_PERMISSIONS_ROLE ) noPermissionManager ( _app , _role ) { _createPermission ( _entity , _app , _role , _manager ) ; }
","Create a new permission granting ` _entity ` the ability to perform actions requiring ` _role ` on ` _app ` , setting ` _manager ` as the permission 's manager
"
"function getEnded ( ) external view returns ( bool ) { return _ended ; }
","Get whether the auction has ended
"
"function upgradeController ( address _newControllerAddress ) public onlyOwner { tokenContract . changeController ( _newControllerAddress ) ; emit UpgradedController ( _newControllerAddress ) ; }
","` onlyOwner ` can upgrade the controller contract
"
"function registerForCompetition ( address fund , uint8 v , bytes32 r , bytes32 s ) payable pre_cond ( isCompetitionActive ( ) && ! Version ( COMPETITION_VERSION ) . isShutDown ( ) ) pre_cond ( termsAndConditionsAreSigned ( msg . sender , v , r , s ) && isWhitelisted ( msg . sender ) ) { require ( registeredFundToRegistrants [ fund ] == address ( 0 ) && registrantToRegistrantIds [ msg . sender ] . exists == false ) ; require ( add ( currentTotalBuyin , msg . value ) <= totalMaxBuyin && registrants . length < maxRegistrants ) ; require ( msg . value <= whitelistantToMaxBuyin [ msg . sender ] ) ; require ( Version ( COMPETITION_VERSION ) . getFundByManager ( msg . sender ) == fund ) ; uint payoutQuantity = calculatePayout ( msg . value ) ; registeredFundToRegistrants [ fund ] = msg . sender ; registrantToRegistrantIds [ msg . sender ] = RegistrantId ( { id : registrants . length , exists : true } ) ; currentTotalBuyin = add ( currentTotalBuyin , msg . value ) ; FundInterface fundContract = FundInterface ( fund ) ; MELON_CONTRACT . approve ( fund , payoutQuantity ) ; fundContract . requestInvestment ( payoutQuantity , getEtherValue ( payoutQuantity ) , MELON_ASSET ) ; fundContract . executeRequest ( fundContract . getLastRequestId ( ) ) ; custodian . transfer ( msg . value ) ; emit Register ( registrants . length , fund , msg . sender ) ; registrants . push ( Registrant ( { fund : fund , registrant : msg . sender , hasSigned : true , buyinQuantity : msg . value , payoutQuantity : payoutQuantity , isRewarded : false } ) ) ; }
","Register to take part in the competition
"
"function blocksList ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) internal pure returns ( uint16 [ ] memory r ) { uint i = 0 ; r = new uint16 [ ] ( countBlocks ( fromX , fromY , toX , toY ) ) ; for ( uint8 ix = fromX ; ix <= toX ; ix ++ ) { for ( uint8 iy = fromY ; iy <= toY ; iy ++ ) { r [ i ] = blockID ( ix , iy ) ; i ++ ; } } }
","get an array of all block ids ( i.e .
"
"function allowance ( address owner , address spender ) public view returns ( uint ) { return tokenState . allowance ( owner , spender ) ; }
","Returns the ERC20 allowance of one party to spend on behalf of another .
"
"function withdrawBonus ( ) external whenNotPaused { require ( releaseDate != 0 ) ; require ( now > releaseDate ) ; uint256 amount = bonusHolders [ msg . sender ] ; require ( amount > 0 ) ; bonusWithdrawn = bonusWithdrawn . add ( amount ) ; bonusHolders [ msg . sender ] = 0 ; require ( bonusCoin . transfer ( msg . sender , amount ) ) ; emit BonusWithdrawn ( msg . sender , amount ) ; }
","Enables contributors to withdraw their bonus.The bonus can only be withdrawn after the release date .
"
"function getBond ( bytes32 question_id ) public view returns ( uint256 ) { }
","Returns the highest bond posted so far for a question
"
"function changeAllowAllWhitelistIssuances ( bool _allowAllWhitelistIssuances ) public withPerm ( FLAGS ) { allowAllWhitelistIssuances = _allowAllWhitelistIssuances ; emit LogAllowAllWhitelistIssuances ( _allowAllWhitelistIssuances ) ; }
","Used to change the flag true - It refers that time lock is ignored for issuances ( address must still be on whitelist ) false - It refers transfers are restricted for all addresses .
"
"function giveBirth ( uint256 _matronId ) external whenNotPaused returns ( uint256 ) { Pony storage matron = ponies [ _matronId ] ; require ( matron . birthTime != 0 ) ; require ( _isReadyToGiveBirth ( matron ) ) ; uint256 sireId = matron . matingWithId ; Pony storage sire = ponies [ sireId ] ; uint16 parentGen = matron . generation ; if ( sire . generation > matron . generation ) { parentGen = sire . generation ; } uint256 childGenes = geneScience . mixGenes ( matron . genes , sire . genes , matron . cooldownEndBlock - 1 ) ; uint16 cooldownIndex = geneScience . processCooldown ( parentGen + 1 , block . number ) ; if ( cooldownIndex > 13 ) { cooldownIndex = 13 ; } address owner = ponyIndexToOwner [ _matronId ] ; uint256 ponyId = _createPony ( _matronId , matron . matingWithId , parentGen + 1 , childGenes , owner , cooldownIndex ) ; delete matron . matingWithId ; pregnantPonies -- ; msg . sender . transfer ( autoBirthFee ) ; return ponyId ; }
","Have a pregnant Pony give birth !
"
"function addProjectToVote ( string calldata _prjName , address _prjAddress ) external payable onlyOwner { require ( currentStage == StageName . preList , ""Can't add item after vote has starting!"" ) ; require ( _prjAddress != address ( 0 ) , ""Address must be valid!"" ) ; bytes32 hash = keccak256 ( bytes ( _prjName ) ) ; require ( projects [ hash ] . prjAddress == address ( 0 ) , ""It seems like this item allready exist!"" ) ; projects [ hash ] = PrjProperties ( { prjAddress : _prjAddress , voteCount : 0 , prjWeiRaised : 0 } ) ; }
","Add item to progject vote list
"
"function implementsERC165Interface ( address _contract , bytes4 _interfaceId ) public view returns ( bool ) { if ( ! erc165Cached [ _contract ] [ _interfaceId ] ) { return implementsERC165InterfaceNoCache ( _contract , _interfaceId ) ; } return interfaces [ _contract ] [ _interfaceId ] == _contract ; }
","Checks whether a contract implements an ERC165 interface or not .
"
"function ownerStartContract ( ) external onlyOwner { require ( contractPoweredUp ) ; require ( ! contractStarted ) ; contractStarted = true ; }
","Start contract ( permanently )
"
"function insertBefore ( List storage self , address target , address newNode ) internal { require ( ! isInList ( self , newNode ) , ""already in list"" ) ; require ( isInList ( self , target ) || target == NULL , ""not in list"" ) ; address prev = self . list [ target ] . previous ; self . list [ newNode ] . next = target ; self . list [ newNode ] . previous = prev ; self . list [ target ] . previous = newNode ; self . list [ prev ] . next = newNode ; self . list [ newNode ] . inList = true ; }
","Insert a new node before an existing node .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( checkVestingCondition ( _from ) ) ; require ( _value <= approved [ _from ] [ msg . sender ] ) ; approved [ _from ] [ msg . sender ] = approved [ _from ] [ msg . sender ] . minus ( _value ) ; _transfer ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` on behalf of ` _from `
"
"function ( ) payable public { require ( msg . value > 0 ) ; buy ( msg . sender , msg . value ) ; }
","Send Ether to buy tokens
"
"function sendTokens ( address _to , uint _value ) public onlyMinter validAddress ( _to ) notZero ( _value ) { balances [ _to ] = SafeMath . add ( balances [ _to ] , _value ) ; feeInCirculation = SafeMath . add ( feeInCirculation , _value ) ; Transfer ( msg . sender , _to , _value ) ; }
","To send tokens to another user .
"
"function officialSold ( ) constant returns ( uint256 ) { return soldOut . official ; }
","returns tokens sold officially
"
"function setJackpotCompleted ( ) public onlyOwner { jackpotCompleted = true ; finalJackpotValue = address ( this ) . balance ; uint256 jackpotShare = ( ( address ( this ) . balance ) . mul ( 20 ) ) . div ( 100 ) ; msg . sender . transfer ( jackpotShare ) ; }
","set jackpotComplete to true and transfer 20 percent share of jackpot to owner
"
"function getSetupCost ( ) external view returns ( uint256 ) { return setupCost ; }
","Get the setup cost of the module
"
"function withdrawToken ( uint tokenNumber ) external returns ( bool ) { require ( _ended ) ; require ( ! _coinWithdrawn [ tokenNumber - 1 ] ) ; _coinWithdrawn [ tokenNumber - 1 ] = true ; RareCoin ( _rcContract ) . CreateToken ( _topBids [ tokenNumber - 1 ] . bidderAddress , tokenNumber ) ; return true ; }
","Withdraw your RareCoin if you are in the top 100 bidders at the end of the auction
"
"function setUpgradeAgent ( address agent ) external { if ( getState ( ) != State . Success ) throw ; if ( agent == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; if ( address ( upgradeAgent ) != 0x0 && upgradeAgent . upgradeHasBegun ( ) ) throw ; upgradeAgent = UpgradeAgent ( agent ) ; if ( upgradeAgent . originalSupply ( ) != totalSupply ) throw ; UpgradeAgentSet ( upgradeAgent ) ; }
","Set address of upgrade target contract and enable upgrade process .
"
"function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 6000000000 ; }
","maximum investments to be accepted during the sale ( in euro-cents )
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _isIdle ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }
","Transfer a Player owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function assignBonus ( address _investor , uint256 _bonus ) internal { if ( _bonus == 0 ) { return ; } bonusProvided = bonusProvided . add ( _bonus ) ; bonusHolders [ _investor ] = bonusHolders [ _investor ] . add ( _bonus ) ; emit BonusAssigned ( _investor , _bonus ) ; }
","Assigns bonus tokens to the specific contributor .
"
"function getFinishTime ( ) public view returns ( uint ) { return m_tokenBonuses . getLastTime ( ) ; }
","finish time of the ICO
"
"function redeem ( bytes preimage ) public { require ( sha256 ( preimage ) == sha256hash ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; selfdestruct ( msg . sender ) ; }
","Transfer to the specified address if anyone can provide the correct preimage .
"
"function name ( ) public pure returns ( string _deedName ) { _deedName = ""Burnup Tiles"" ; }
","Name of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata .
"
"function collectTokens ( ) public onlyOwner { uint256 balance = att . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 ) ; uint256 canExtract = total . div ( 2 ) ; if ( getTime ( ) > finalizedTime . add ( months ( 6 ) ) ) { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; assert ( att . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }
","The Owner will call this method to extract the tokens
"
"function trade ( ERC20 src , uint srcAmount , ERC20 dest , address destAddress , uint maxDestAmount , uint minConversionRate , address walletId ) public payable returns ( uint ) { require ( enabled ) ; uint userSrcBalanceBefore ; uint userSrcBalanceAfter ; uint userDestBalanceBefore ; uint userDestBalanceAfter ; userSrcBalanceBefore = getBalance ( src , msg . sender ) ; if ( src == ETH_TOKEN_ADDRESS ) userSrcBalanceBefore += msg . value ; userDestBalanceBefore = getBalance ( dest , destAddress ) ; uint actualDestAmount = doTrade ( src , srcAmount , dest , destAddress , maxDestAmount , minConversionRate , walletId ) ; require ( actualDestAmount > 0 ) ; userSrcBalanceAfter = getBalance ( src , msg . sender ) ; userDestBalanceAfter = getBalance ( dest , destAddress ) ; require ( userSrcBalanceAfter <= userSrcBalanceBefore ) ; require ( userDestBalanceAfter >= userDestBalanceBefore ) ; require ( ( userDestBalanceAfter - userDestBalanceBefore ) >= calcDstQty ( ( userSrcBalanceBefore - userSrcBalanceAfter ) , getDecimals ( src ) , getDecimals ( dest ) , minConversionRate ) ) ; return actualDestAmount ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function cancel ( bytes32 _offerHash , uint256 _expectedAvailableAmount , address _feeAsset , uint256 _feeAmount , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator { require ( _recoverAddress ( keccak256 ( abi . encodePacked ( ""cancel"" , _offerHash , _feeAsset , _feeAmount ) ) , _v , _r , _s ) == offers [ _offerHash ] . maker , ""Invalid signature"" ) ; _cancel ( _offerHash , _expectedAvailableAmount , _feeAsset , _feeAmount ) ; }
","Cancels an offer that was preivously made using ` makeOffer ` .
"
"function mAllowanceOverride ( address owner , address spender ) internal constant returns ( uint256 allowance ) ;
","Allows to override allowance approved by the owner Primary role is to enable forced transfers , do not override if you do not like it Following behavior is expected in the observer approve ( ) - should revert if mAllowanceOverride ( ) > 0 allowance ( ) - should return mAllowanceOverride ( ) if set transferFrom ( ) - should override allowance if mAllowanceOverride ( ) > 0
"
"function calculateBoardScore ( uint boardId ) public view returns ( uint8 blackScore , uint8 whiteScore ) { GoBoard storage board = allBoards [ boardId ] ; uint8 [ BOARD_SIZE ] memory boardEmptyGroups ; uint8 maxEmptyGroupId ; ( boardEmptyGroups , maxEmptyGroupId ) = getBoardEmptyGroups ( board ) ; uint8 [ BOARD_SIZE ] memory groupsSize ; uint8 [ BOARD_SIZE ] memory groupsState ; blackScore = 0 ; whiteScore = 0 ; for ( uint8 position = 0 ; position < BOARD_SIZE ; position ++ ) { if ( PlayerColor ( board . positionToColor [ position ] ) == PlayerColor . Black ) { blackScore ++ ; } else if ( PlayerColor ( board . positionToColor [ position ] ) == PlayerColor . White ) { whiteScore ++ ; } else { uint8 groupId = boardEmptyGroups [ position ] ; groupsSize [ groupId ] ++ ; if ( ( groupsState [ groupId ] & uint8 ( PlayerColor . Black ) == 0 ) || ( groupsState [ groupId ] & uint8 ( PlayerColor . White ) == 0 ) ) { uint8 [ MAX_ADJACENT_CELLS ] memory adjacentArray = getAdjacentCells ( position ) ; for ( uint8 currAdjacentIndex = 0 ; currAdjacentIndex < MAX_ADJACENT_CELLS && adjacentArray [ currAdjacentIndex ] < MAX_UINT8 ; currAdjacentIndex ++ ) { if ( ( PlayerColor ( board . positionToColor [ adjacentArray [ currAdjacentIndex ] ] ) == PlayerColor . Black ) && ( groupsState [ groupId ] & uint8 ( PlayerColor . Black ) == 0 ) ) { groupsState [ groupId ] |= uint8 ( PlayerColor . Black ) ; } else if ( ( PlayerColor ( board . positionToColor [ adjacentArray [ currAdjacentIndex ] ] ) == PlayerColor . White ) && ( groupsState [ groupId ] & uint8 ( PlayerColor . White ) == 0 ) ) { groupsState [ groupId ] |= uint8 ( PlayerColor . White ) ; } } } } } for ( uint8 currGroupId = 1 ; currGroupId < maxEmptyGroupId ; currGroupId ++ ) { if ( ( groupsState [ currGroupId ] & uint8 ( PlayerColor . Black ) > 0 ) && ( groupsState [ currGroupId ] & uint8 ( PlayerColor . White ) == 0 ) ) { blackScore += groupsSize [ currGroupId ] ; } else if ( ( groupsState [ currGroupId ] & uint8 ( PlayerColor . White ) > 0 ) && ( groupsState [ currGroupId ] & uint8 ( PlayerColor . Black ) == 0 ) ) { whiteScore += groupsSize [ currGroupId ] ; } } return ( blackScore , whiteScore ) ; }
","Calculates the board 's score , using area scoring .
"
"function calculateBonus ( uint32 _date ) internal view returns ( uint256 ) { DailyContestStatus memory status = dateToContestStatus [ _date ] ; if ( status . numCompleted == 0 ) { return 0 ; } uint256 numFailed = status . numRegistered . sub ( status . numCompleted ) ; return numFailed . mul ( REGISTRATION_FEE ) . mul ( 9 ) . div ( status . numCompleted . mul ( 10 ) ) ; }
","Does n't change state
"
"function setAllowance ( address tokenOwner , address spender , uint value ) external onlyAssociatedContract { allowance [ tokenOwner ] [ spender ] = value ; }
","Set ERC20 allowance .
"
"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function issuanceDraft ( address account ) public view returns ( uint ) { uint issued = nominsIssued [ account ] ; if ( issued == 0 ) { return 0 ; } return USDtoHAV ( safeDiv_dec ( issued , issuanceRatio ) ) ; }
","The collateral that would be locked by issuance , which can exceed the account 's actual collateral .
"
"function transferFor ( address _beneficiary ) public onlyOwner vaultUnlocked returns ( bool ) { return _transferTokens ( _beneficiary ) ; }
","Utility function to actually transfer allocated tokens to their owners .
"
"function getPendingVersion ( ) public view returns ( address ) { return pendingVersion ; }
","Returns proposed next asset implementation contract address .
"
"function _burn ( address _owner , uint256 _tokenId ) validNFToken ( _tokenId ) internal { clearApproval ( _owner , _tokenId ) ; removeNFToken ( _owner , _tokenId ) ; emit Transfer ( _owner , address ( 0 ) , _tokenId ) ; }
","This is a private function which should be called from user-implemented external burn function .
"
"function setTierData ( uint256 _index , uint256 _priceInCenter , uint256 _priceInOuter ) public onlyGlobalAdmin ( ) { Tier memory tier = tiers [ _index ] ; tier . priceInCenter = _priceInCenter ; tier . priceInOuter = _priceInOuter ; tiers [ _index ] = tier ; }
","global Admin update tier data
"
"function process_contribution ( address _toAddr ) internal { require ( ( campaignState == 2 ) && ( now <= tCampaignEnd ) && ( paused == false ) ) ; require ( msg . value >= minContribution ) ; amountRaised = amountRaised . add ( msg . value ) ; if ( ! participantList [ _toAddr ] . participatedFlag ) { participantList [ _toAddr ] . participatedFlag = true ; joinedCrowdsale . push ( _toAddr ) ; } if ( msg . value >= preCrowdMinContribution ) { participantList [ _toAddr ] . contributedAmountPreCrowd = participantList [ _toAddr ] . contributedAmountPreCrowd . add ( msg . value ) ; RaisedPreCrowd ( _toAddr , msg . value ) ; } else { if ( now <= t_1st_StageEnd ) { participantList [ _toAddr ] . contributedAmountStage1 = participantList [ _toAddr ] . contributedAmountStage1 . add ( msg . value ) ; RaisedStage1 ( _toAddr , msg . value ) ; } else if ( now <= t_2nd_StageEnd ) { participantList [ _toAddr ] . contributedAmountStage2 = participantList [ _toAddr ] . contributedAmountStage2 . add ( msg . value ) ; RaisedStage2 ( _toAddr , msg . value ) ; } else { participantList [ _toAddr ] . contributedAmountStage3 = participantList [ _toAddr ] . contributedAmountStage3 . add ( msg . value ) ; RaisedStage3 ( _toAddr , msg . value ) ; } } uint256 opEth = ( PRCT100_ETH_OP . mul ( msg . value ) ) . div ( 10000 ) ; opVaultAddr . transfer ( opEth ) ; reserveVaultAddr . transfer ( opEth ) ; }
","processes the contribution checks campaign state , time window and minimal contribution throws if one of the conditions fails
"
"function refunded ( address investor ) public { Account memory investment = _commitments [ msg . sender ] [ investor ] ; if ( investment . balance == 0 ) return ; delete _commitments [ msg . sender ] [ investor ] ; Account storage account = _accounts [ investor ] ; require ( account . unlockDate > 0 , ""NF_LOCKED_ACCOUNT_LIQUIDATED"" ) ; account . balance = addBalance ( account . balance , investment . balance ) ; account . neumarksDue = add112 ( account . neumarksDue , investment . neumarksDue ) ; assert ( PAYMENT_TOKEN . transferFrom ( msg . sender , address ( this ) , investment . balance ) ) ; emit LogFundsRefunded ( investor , msg . sender , investment . balance , investment . neumarksDue ) ; }
","refunds investor in case of failed offering
"
"function getMaximumFunds ( ) internal constant returns ( uint ) { return 8500 ether ; }
","maximum investments to be accepted during pre-ICO
"
"function getFinishTime ( ) public view returns ( uint ) { return c_priceChangeDates [ c_priceChangeDates . length - 1 ] ; }
","finish time of the ICO
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; if ( _to == address ( this ) ) { sell ( msg . sender , _value ) ; return true ; } else { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; } }
","transfer _value tokens to address _to
"
"function buyTokensForProposal ( uint _proposalID , address _buyer ) payable returns ( bool ) { if ( _buyer == 0 ) _buyer = msg . sender ; if ( fundings [ _proposalID ] . moderator != 0 ) throw ; return buyTokensFor ( _proposalID , _buyer , now , true ) ; }
","Function to buy tokens and promote a proposal
"
"function transferTokensOut ( address tokenContractAddress , address destination , uint amount ) public ownerOnly returns ( bool result ) { IERC20 token = IERC20 ( tokenContractAddress ) ; return token . transfer ( destination , amount ) ; }
","This function allows the community to transfer tokens out of the contract .
"
"function getAddressAndSharePriceOfFunds ( ) view returns ( address [ ] , uint [ ] , uint [ ] ) { uint nofFunds = version . getLastFundId ( ) + 1 ; address [ ] memory fundAddrs = new address [ ] ( nofFunds ) ; uint [ ] memory sharePrices = new uint [ ] ( nofFunds ) ; uint [ ] memory creationTimes = new uint [ ] ( nofFunds ) ; for ( uint i = 0 ; i < nofFunds ; i ++ ) { address fundAddress = version . getFundById ( i ) ; Fund fund = Fund ( fundAddress ) ; uint sharePrice = fund . calcSharePrice ( ) ; uint creationTime = fund . getCreationTime ( ) ; fundAddrs [ i ] = fundAddress ; sharePrices [ i ] = sharePrice ; creationTimes [ i ] = creationTime ; } return ( fundAddrs , sharePrices , creationTimes ) ; }
","Returns an array of fund addresses and associated arrays of share prices and creation times
"
"function getItem ( uint256 _tokenId ) public view returns ( string itemName , uint256 sellingPrice , address owner ) { Item storage item = items [ _tokenId ] ; itemName = item . name ; sellingPrice = itemIndexToPrice [ _tokenId ] ; owner = itemIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific item .
"
"function _mint ( address _to , uint256 _tokenId ) internal { super . _mint ( _to , _tokenId ) ; tokens . push ( _tokenId ) ; idToIndex [ _tokenId ] = tokens . length . sub ( 1 ) ; }
","This is a private function which should be called from user-implemented external mint function .
"
"function withdrawPayments ( ) external nonReentrant requiresState ( State . REFUNDING ) { address payee = msg . sender ; uint payment = m_weiBalances [ payee ] ; uint tokens = m_tokenBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; require ( m_token . allowance ( payee , this ) >= m_tokenBalances [ payee ] ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; m_tokenBalances [ payee ] = 0 ; m_token . transferFrom ( payee , this , tokens ) ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }
","withdraw accumulated balance , called by payee in case crowdsale failed
"
"function setTradingStatus ( bool isLive ) public onlyOwner { tradingLive = isLive ; FreezeStatusChanged ( tradingLive , block . timestamp ) ; }
","Sets if the trading is live
"
"function getTags ( ) external view returns ( bytes32 [ ] ) ;
","Get the tags related to the module factory
"
"function cancelRequest ( uint id ) external pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( requests [ id ] . participant == msg . sender || isShutDown ) { requests [ id ] . status = RequestStatus . cancelled ; }
","Cancels active investment and redemption requests
"
"function buy ( ) public payable returns ( uint256 amount ) { uint256 refund = 0 ; debugVal = 0 ; if ( initialSaleComplete ) { uint256 units_to_buy = 0 ; uint256 etherRemaining = msg . value ; uint256 etherToReserve = 0 ; debugVal = fracExp ( S , R , ( _totalSupply / 1e18 ) , P ) ; debugVal2 = RS * msg . value ; debugVal3 = RS * msg . value / 1e18 + fracExp ( S , R , ( _totalSupply / 1e18 ) , P ) ; debugVal4 = ( ln ( debugVal3 , 1 ) - lnS ) ; units_to_buy = debugVal4 ; reserveAddress . transfer ( etherToReserve ) ; mintToken ( msg . sender , amount ) ; refund = etherRemaining ; msg . sender . transfer ( refund ) ; } else { ask = ICOask ; amount = 1e18 * msg . value / ask ; refund = msg . value - ( amount * ask / 1e18 ) ; reserveAddress . transfer ( msg . value - refund ) ; msg . sender . transfer ( refund ) ; balances [ reserveAddress ] += msg . value - refund ; mintToken ( msg . sender , amount ) ; if ( _totalSupply >= ICOAmount ) { initialSaleComplete = true ; } } return amount ; }
","Buys aToken in exchnage for wei at the current ask price
"
"function burn ( uint256 _value ) onlyOwner ( ) external { require ( _value <= balances [ msg . sender ] ) ; balances [ owner ] = balances [ owner ] . sub ( _value ) ; tokenTotalSupply = tokenTotalSupply . sub ( _value ) ; emit Burn ( owner , _value ) ; emit Transfer ( owner , address ( 0x0 ) , _value ) ; }
","Only owner is allowed to perform this operation .
"
"function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; bytes32 hashedTx = approvePreSignedHashing ( address ( this ) , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; allowed [ from ] [ _spender ] = _value ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned approval
"
"function _getTokenPrice ( ) internal view returns ( uint256 tokenPrice ) { if ( now >= FIRST_PHASE ) { tokenPrice = ( 80 finney ) ; } else { tokenPrice = STARTING_PRICE ; } require ( tokenPrice >= STARTING_PRICE && tokenPrice <= ( 80 finney ) ) ; }
","Gets current token price
"
"function buyTokensForAddress ( address _recipient ) external payable { totalFunds = totalFunds + msg . value ; require ( msg . value > 0 ) ; require ( _recipient != admin ) ; require ( ( totalFunds / 1 ether ) * pricePerEther < 6000000000 ) ; addUser ( _recipient ) ; uint tokenAmount = calculateTokenAmount ( msg . value ) ; balances [ selfAddress ] = balances [ selfAddress ] - tokenAmount ; assert ( balances [ selfAddress ] >= 50000000000000 ) ; balances [ _recipient ] = balances [ _recipient ] + tokenAmount ; Transfer ( selfAddress , _recipient , tokenAmount ) ; address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de ; etherTransfer . transfer ( msg . value ) ; }
","Purchase WBC Tokens for Address - ICO
"
"function updateOrderbook ( Orderbook _newOrderbookContract ) external onlyOwner { emit LogOrderbookUpdated ( orderbookContract , _newOrderbookContract ) ; orderbookContract = _newOrderbookContract ; }
","The owner of the contract can update the Orderbook address .
"
"function addInterest ( uint index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent ) ; internalAddInterest ( loan , block . timestamp ) ; }
","Updates the loan accumulated interests up to the current Unix time .
"
"function changeClosingTime ( uint256 _closingTime ) public whenNotPaused onlyAdmin { emit ClosingTimeChanged ( _closingTime , closingTime ) ; closingTime = _closingTime ; }
","Adjusts the closing time of the crowdsale .
"
"function withdrawWithholding ( uint256 _dividendIndex ) external withPerm ( MANAGE ) { require ( _dividendIndex < dividends . length , ""Invalid dividend"" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 remainingWithheld = dividend . dividendWithheld . sub ( dividend . dividendWithheldReclaimed ) ; dividend . dividendWithheldReclaimed = dividend . dividendWithheld ; address owner = IOwnable ( securityToken ) . owner ( ) ; require ( IERC20 ( dividendTokens [ _dividendIndex ] ) . transfer ( owner , remainingWithheld ) , ""transfer failed"" ) ; emit ERC20DividendWithholdingWithdrawn ( owner , _dividendIndex , dividendTokens [ _dividendIndex ] , remainingWithheld ) ; }
","Allows issuer to withdraw withheld tax
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = itemIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function getLatestVersion ( ) public view returns ( address ) { return latestVersion ; }
","Returns current asset implementation contract address .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { }
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function rewardOf ( ContentMapping storage self , bytes32 _id ) public view returns ( uint256 ) { return self . data [ _id ] . deliverable . reward ; }
","return reward of content delivarable
"
"function vote ( uint _tokenIndex ) public { require ( tokenBatches . length > 0 ) ; uint _proposalId = tokenBatches . length - 1 ; require ( _tokenIndex < 10 ) ; TokenProposal memory p = tokenBatches [ _proposalId ] ; require ( now < p . startTime + p . duration ) ; uint amount = DestructibleMiniMeToken ( p . votingToken ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; require ( DestructibleMiniMeToken ( p . votingToken ) . transferFrom ( msg . sender , address ( this ) , amount ) ) ; tokenBatches [ _proposalId ] . yesVotes [ _tokenIndex ] += amount ; emit Vote ( _proposalId , msg . sender , tokenBatches [ _proposalId ] . consideredTokens [ _tokenIndex ] , amount ) ; }
","Vote for specific token with yes
"
"function removeOrder ( uint _imageId ) private { sellAds [ _imageId ] . active = false ; }
","Removes image from imgagesOnSale list
"
"function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
","Bringing this in from the Math library as we 've run out of space in TotlePrimary ( see EIP-170 )
"
"function withdrawEther ( uint _value ) external ;
","withdraw ` _value ` of ether to his address , can be called if crowdsale succeeded
"
"function changeOwner ( address _owner ) public returns ( bool ) ;
","Initiate a change of owner to ` _owner `
"
"function buyTokens ( ) public payable whenNotPaused { require ( validPurchase ( ) ) ; uint256 tokens = 0 ; uint256 amountPaid = calculateExcessBalance ( ) ; if ( tokensRaised < 12.5e24 ) { tokens = amountPaid . mul ( rate ) ; if ( tokensRaised . add ( tokens ) > 12.5e24 ) tokens = calculateExcessTokens ( amountPaid , 12.5e24 , 1 , rate ) ; } else if ( tokensRaised >= 12.5e24 && tokensRaised < 25e24 ) { tokens = amountPaid . mul ( rateTier2 ) ; if ( tokensRaised . add ( tokens ) > 25e24 ) tokens = calculateExcessTokens ( amountPaid , 25e24 , 2 , rateTier2 ) ; } else if ( tokensRaised >= 25e24 && tokensRaised < 37.5e24 ) { tokens = amountPaid . mul ( rateTier3 ) ; if ( tokensRaised . add ( tokens ) > 37.5e24 ) tokens = calculateExcessTokens ( amountPaid , 37.5e24 , 3 , rateTier3 ) ; } else if ( tokensRaised >= 37.5e24 ) { tokens = amountPaid . mul ( rateTier4 ) ; } weiRaised = weiRaised . add ( amountPaid ) ; tokensRaised = tokensRaised . add ( tokens ) ; token . distributeICOTokens ( msg . sender , tokens ) ; tokensBought [ msg . sender ] = tokensBought [ msg . sender ] . add ( tokens ) ; TokenPurchase ( msg . sender , amountPaid , tokens ) ; forwardFunds ( amountPaid ) ; }
","To buy tokens given an address
"
"function updatePrices ( ) internal { uint256 oldPrice = currentTokenPrice ; if ( preIcoIsRunning ) { checkPreIcoStatus ( ) ; } if ( preIcoIsRunning ) { currentTokenPrice = preICOprice ; } else { currentTokenPrice = ICOprice ; } if ( oldPrice != currentTokenPrice ) { priceUpdated ( oldPrice , currentTokenPrice , ""Token price updated!"" ) ; } }
","Set current ICO prices in wei for one token
"
"function transferFrom ( address _owner , address _recipient , uint256 _amount ) public transfersNotFrozen nonZeroAddress ( _recipient ) returns ( bool ) { require ( balances [ _owner ] >= _amount , ""owner does not have enough tokens"" ) ; require ( allowed [ _owner ] [ msg . sender ] >= _amount , ""sender does not have enough allowance"" ) ; allowed [ _owner ] [ msg . sender ] = allowed [ _owner ] [ msg . sender ] . sub ( _amount ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _recipient ] = balances [ _recipient ] . add ( _amount ) ; emit Transfer ( _owner , _recipient , _amount ) ; return true ; }
","Used to transfer tokens on behalf of someone else
"
"function checkPermission ( address [ ] storage _modules , address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { if ( _modules . length == 0 ) { return false ; } for ( uint8 i = 0 ; i < _modules . length ; i ++ ) { if ( IPermissionManager ( _modules [ i ] ) . checkPermission ( _delegate , _module , _perm ) ) { return true ; } } return false ; }
","Validates permissions with PermissionManager if it exists .
"
"function setPriceStalePeriod ( uint time ) external optionalProxy_onlyOwner { priceStalePeriod = time ; }
","Set the stale period on the updated havven price
"
"function allocate ( ) public notAllocated endedSale returns ( bool ) { finalAllocation = true ; uint256 totalSupplyCDN = totalTokensSold . mul ( 100 ) . div ( 75 ) ; uint256 foundersAllocation = totalSupplyCDN . div ( 5 ) ; assert ( cnd . generateTokens ( foundersWallet , foundersAllocation ) ) ; uint256 advisorsAllocation = totalSupplyCDN . mul ( 38 ) . div ( 1000 ) ; assert ( cnd . generateTokens ( advisorsWallet , advisorsAllocation ) ) ; uint256 bountyAllocation = totalSupplyCDN . mul ( 12 ) . div ( 1000 ) ; assert ( cnd . generateTokens ( bountyWallet , bountyAllocation ) ) ; return true ; }
","This method will can be called by the anybody to make final allocation
"
"function timeoutResolve ( bytes32 msigId , uint amount ) public { require ( now >= multisigs [ msigId ] . unlockTime ) ; spendFromMultisig ( msigId , amount , multisigs [ msigId ] . owner ) ; }
","Withdraw ether and delete the htlc swap .
"
"function escapeHatch ( address _token ) public onlyEscapeHatchCallerOrOwner { require ( escapeBlacklist [ _token ] == false ) ; uint256 balance ; if ( _token == 0x0 ) { balance = this . balance ; escapeHatchDestination . transfer ( balance ) ; EscapeHatchCalled ( _token , balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; balance = token . balanceOf ( this ) ; token . transfer ( escapeHatchDestination , balance ) ; EscapeHatchCalled ( _token , balance ) ; }
","The ` escapeHatch ( ) ` should only be called as a last resort if a security issue is uncovered or something unexpected happened
"
"function getFundDetails ( address ofVersion ) view returns ( address [ ] , uint [ ] , uint [ ] , bytes32 [ ] ) { Version version = Version ( ofVersion ) ; uint nofFunds = version . getLastFundId ( ) + 1 ; address [ ] memory fundAddrs = new address [ ] ( nofFunds ) ; uint [ ] memory sharePrices = new uint [ ] ( nofFunds ) ; uint [ ] memory creationTimes = new uint [ ] ( nofFunds ) ; bytes32 [ ] memory names = new bytes32 [ ] ( nofFunds ) ; for ( uint i = 0 ; i < nofFunds ; i ++ ) { address fundAddress = version . getFundById ( i ) ; Fund fund = Fund ( fundAddress ) ; fundAddrs [ i ] = fundAddress ; sharePrices [ i ] = fund . calcSharePrice ( ) ; creationTimes [ i ] = fund . getCreationTime ( ) ; names [ i ] = fund . getName ( ) ; } return ( fundAddrs , sharePrices , creationTimes , names ) ; }
","Returns an array of fund addresses and associated arrays of share prices and creation times
"
"function removePermission ( bytes4 _methodsignature ) public onlyValidator { permissions [ _methodsignature ] . active = false ; emit PermissionRemoved ( _methodsignature ) ; }
","Removes a permission the list of permissions .
"
"function confirmOrder ( bytes32 _orderID , bytes32 _matchedOrderID ) external onlyDarknode ( msg . sender ) { require ( orders [ _orderID ] . state == OrderState . Open , ""invalid order status"" ) ; require ( orders [ _matchedOrderID ] . state == OrderState . Open , ""invalid order status"" ) ; orders [ _orderID ] . state = OrderState . Confirmed ; orders [ _orderID ] . confirmer = msg . sender ; orders [ _orderID ] . matchedOrder = _matchedOrderID ; orders [ _orderID ] . blockNumber = block . number ; orders [ _matchedOrderID ] . state = OrderState . Confirmed ; orders [ _matchedOrderID ] . confirmer = msg . sender ; orders [ _matchedOrderID ] . matchedOrder = _orderID ; orders [ _matchedOrderID ] . blockNumber = block . number ; }
","Confirm an order match between orders .
"
"function isAdmin ( address _address ) public view returns ( bool ) { if ( _address == owner ) { return true ; } return admins [ _address ] ; }
","Checks if an address is an administrator .
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] > 0 ) ; allowance [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
","Used to approve a third-party to send funds on your behalf
"
"function setWhitelistedUser ( address _who ) public onlyValidator { _setWhitelistedUser ( _who ) ; }
","Sets the necessary permissions for a `` whitelisted '' user .
"
"function setPrice ( Campaign storage _campaign , uint _price ) internal { _campaign . price = _price ; }
","Set campaing price per proof of attention
"
"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public { require ( isOperatorFor ( msg . sender , _from ) ) ; doSend ( _from , _to , _amount , _userData , msg . sender , _operatorData , true ) ; }
","Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
"
"function lockTokensForTradingMarketContract ( address marketContractAddress , uint qtyToLock ) external { uint256 lockedBalance = contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] . add ( qtyToLock ) ; transfer ( this , qtyToLock ) ; contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ msg . sender ] = lockedBalance ; UpdatedUserLockedBalance ( marketContractAddress , msg . sender , lockedBalance ) ; }
","allows user to lock tokens to enable trading for a given market contract
"
"function addPoll ( uint _startBlock , uint _endTime , bytes _description , uint8 _numBallots ) public onlySNTHolder returns ( uint _idPoll ) { require ( _endTime > block . timestamp , ""End time must be greater than current timestamp"" ) ; require ( _startBlock >= block . number , ""Start block must not be in the past"" ) ; require ( _numBallots <= 100 , ""Only a max of 100 ballots are allowed"" ) ; _idPoll = _polls . length ; _polls . length ++ ; Poll storage p = _polls [ _idPoll ] ; p . startBlock = _startBlock ; p . endTime = _endTime ; p . voters = 0 ; p . numBallots = _numBallots ; p . description = _description ; p . author = msg . sender ; emit PollCreated ( _idPoll ) ; }
","Create a Poll
"
"function nominsReceivedForEther ( uint amount ) public view returns ( uint ) { uint nominsTransferred = safeMul_dec ( amount , usdToEthPrice ) ; return nomin . amountReceived ( nominsTransferred ) ; }
","Calculate how many nomins you will receive if you transfer an amount of ether .
"
"function getTokenDecimals ( Data storage self , string currency ) internal view returns ( uint tokenDecimals ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.decimals' , currency ) ) ; return self . Storage . getUint ( id ) ; }
","Get the token decimals for Token interfaces
"
"function setBudget ( address _token , uint256 _amount ) external authP ( CHANGE_BUDGETS_ROLE , arr ( _token , _amount , settings . budgets [ _token ] , settings . hasBudget [ _token ] ? 1 : 0 ) ) transitionsPeriod { settings . budgets [ _token ] = _amount ; if ( ! settings . hasBudget [ _token ] ) { settings . hasBudget [ _token ] = true ; } emit SetBudget ( _token , _amount , true ) ; }
","Set budget for ` _token.symbol ( ) : string ` to ` @ tokenAmount ( _token , _amount , false ) ` , effective immediately
"
"function addDelegate ( string name , string url , uint64 commitTime , ILiquidPledgingPlugin plugin ) returns ( uint64 idDelegate ) { require ( isValidPlugin ( plugin ) ) ; idDelegate = uint64 ( admins . length ) ; admins . push ( PledgeAdmin ( PledgeAdminType . Delegate , msg . sender , name , url , commitTime , 0 , false , plugin ) ) ; DelegateAdded ( idDelegate ) ; }
","Creates a Delegate Admin with the ` msg.sender ` as the Admin addr
"
"function owner ( ) public constant returns ( address ) { }
","the creater and operator of the campaign
"
"function distribute ( address _to , uint256 _value , uint256 _lockupRate ) public onlyOwner returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _lockupBalances [ _to ] == 0 ) ; require ( _value <= _balances [ owner ] ) ; require ( _lockupRate == 50 || _lockupRate == 100 ) ; _balances [ owner ] = _balances [ owner ] . sub ( _value ) ; uint256 lockupValue = _value . mul ( _lockupRate ) . div ( 100 ) ; uint256 givenValue = _value . sub ( lockupValue ) ; uint256 ExpireTime = now + LOCKUP_TERM ; if ( _lockupRate == 100 ) { ExpireTime += LOCKUP_TERM ; } _balances [ _to ] = _balances [ _to ] . add ( givenValue ) ; _lockupBalances [ _to ] = _lockupBalances [ _to ] . add ( lockupValue ) ; _lockupExpireTime [ _to ] = ExpireTime ; emit Transfer ( owner , _to , _value ) ; return true ; }
","If you lock 50 % , the lockout time is six months .
"
"function BFreeContract ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 0.001 * 1 ether ; preICOprice = 0.001 * 1 ether ; ICOprice = 0.001 * 1 ether ; sellPrice = 0.00090 * 1 ether ; buyCommission = 20 ; sellCommission = 20 ; updatePrices ( ) ; }
","Constructor of the contract
"
"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return addressToApprovedAll [ _owner ] == _operator ; }
","Query if an address is an authorized operator for another address
"
"function getDepositsAmountLeft ( uint _distributionDate ) public view returns ( uint _amount ) { return distributionDeposits [ _distributionDate ] . left ; }
","Gets an amount of deposits that has left after users ' bonus withdrawals for selected date
"
"function getPerson ( uint256 _tokenId ) public view returns ( string personName , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; personName = person . name ; sellingPrice = person . sellingPrice ; owner = personIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific person .
"
"function approveMultiple ( address _to , uint256 [ ] _deedIds ) public whenNotPaused { require ( msg . sender != _to ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( _owns ( msg . sender , _deedId ) ) ; _approve ( msg . sender , _to , _deedId ) ; } }
","Approve a given address to take ownership of multiple deeds .
"
"function recoverSigner ( bytes32 message , bytes sig ) public pure returns ( address ) { uint8 v ; bytes32 r ; bytes32 s ; ( v , r , s ) = splitSignature ( sig ) ; return ecrecover ( message , v , r , s ) ; }
","recoverSigner Based on a message and signature returns the address
"
"function setRdCollectorAddress ( address _collectorAddress ) onlyContractOwner external returns ( uint ) { require ( _collectorAddress != 0x0 ) ; rdCollectorAddress = _collectorAddress ; return OK ; }
","Setup redemption destination address
"
"function getCreator ( uint256 _tokenId ) public view returns ( string creatorName , uint256 sellingPrice , address owner , uint256 collectiblesOrdered ) { Creator storage creator = creators [ _tokenId ] ; creatorName = creator . name ; collectiblesOrdered = creator . collectiblesOrdered ; sellingPrice = creatorIndexToPrice [ _tokenId ] ; owner = creatorIndexToOwner [ _tokenId ] ; }
","Returns all the information about Creator token .
"
"function claimTokens ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } ERC20Interface token = ERC20Interface ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { assert ( msg . sender != address ( 0 ) ) ; assert ( _to != address ( 0 ) ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( tokenBalanceOf [ msg . sender ] >= _value ) ; require ( tokenBalanceOf [ msg . sender ] - _value < tokenBalanceOf [ msg . sender ] ) ; require ( tokenBalanceOf [ _to ] + _value > tokenBalanceOf [ _to ] ) ; require ( _value > 0 ) ; _transfer ( msg . sender , _to , _value ) ; return true ; }
","Transfer amount of tokens from own wallet to someone else
"
"function synthInitiatedExchange ( address from , bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey , address destinationAddress ) external onlySynth returns ( bool ) { require ( sourceCurrencyKey != destinationCurrencyKey , ""Can't be same synth"" ) ; require ( sourceAmount > 0 , ""Zero amount"" ) ; return _internalExchange ( from , sourceCurrencyKey , sourceAmount , destinationCurrencyKey , destinationAddress , false ) ; }
","Function that allows synth contract to delegate exchanging of a synth that is not the same sourceCurrency
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function updateWhitelist ( address _account , uint8 _phase ) public returns ( bool ) { require ( _account != address ( 0 ) ) ; require ( _phase <= 1 ) ; require ( isOps ( msg . sender ) ) ; whitelist [ _account ] = _phase ; emit WhitelistUpdated ( _account , _phase ) ; return true ; }
","function to whitelist an address which can be called only by the ops address .
"
"function exchangeRate ( ) constant returns ( uint256 ) { if ( stage ( ) == Stage . Early ) { return venPerEthEarlyStage ; } if ( stage ( ) == Stage . Normal ) { return venPerEth ; } return 0 ; }
","calculte exchange rate according to current stage
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Function approves ` _addr ` to spend ` _value ` tokens of msg.sender
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function beginMotion ( address target ) external returns ( uint ) { require ( ( havven . issuanceLastAverageBalance ( msg . sender ) >= minStandingBalance ) || msg . sender == owner ) ; require ( votingPeriod <= havven . feePeriodDuration ( ) ) ; require ( targetMotionID [ target ] == 0 ) ; require ( ! nomin . frozen ( target ) ) ; havven . rolloverFeePeriodIfElapsed ( ) ; uint motionID = nextMotionID ++ ; motionTarget [ motionID ] = target ; targetMotionID [ target ] = motionID ; uint startTime = havven . feePeriodStartTime ( ) + havven . feePeriodDuration ( ) ; motionStartTime [ motionID ] = startTime ; emit MotionBegun ( msg . sender , target , motionID , startTime ) ; return motionID ; }
","Begin a motion to confiscate the funds in a given nomin account .
"
"function removeOracles ( address [ ] _blacklist ) external onlyContractOwner returns ( uint ) { for ( uint _idx = 0 ; _idx < _blacklist . length ; ++ _idx ) { address _oracle = _blacklist [ _idx ] ; if ( oracles [ _oracle ] ) { delete oracles [ _oracle ] ; _emitOracleRemoved ( _oracle ) ; } } return OK ; }
","Removes oracles from whitelist .
"
"function isDepositSkiped ( address _holder , uint _idDeposit ) public constant returns ( bool ) { return skipDeposits [ _holder ] [ _idDeposit ] ; }
","Checks to see if a specific deposit has been skipped
"
"function mint ( address to , uint x , uint y , uint sizeA , uint sizeB , uint256 totalPrice , uint256 actualPrice ) public onlyPlatform ( ) returns ( uint256 ) { require ( to != address ( 0 ) ) ; require ( sizeA . mul ( sizeB ) <= 100 ) ; uint256 inner ; uint256 total ; ( total , inner ) = calculateCounters ( x , y , sizeA , sizeB ) ; uint256 tokenId = ( allMinedTokens . length ) . add ( 1 ) ; Token memory minted = Token ( tokenId , x , y , sizeA , sizeB , totalPrice , actualPrice , 0 , 0 , 0 , inner , total . sub ( inner ) , 0 ) ; copyToAllUnits ( x , y , sizeA , sizeB , tokenId ) ; updateInternalState ( minted , to ) ; return tokenId ; }
","Mint new token , not sell new token BE sends : owner , x coordinate , y coordinate , price
"
"function totalSupply ( ) public view returns ( uint ) { return playerTokens . length ; }
","Count NFTs tracked by this contract
"
"function validateReleaseTokensSig ( address _sender , uint256 _amount , bytes32 _nonce , bytes _delegationSig ) private { bytes32 _signatureDigest = generateReleaseTokensDelegationSchemaHash ( _sender , _amount , _nonce ) ; require ( _sender == recoverSigner ( _signatureDigest , _delegationSig ) , 'Invalid ReleaseTokens Signature' ) ; burnSignatureDigest ( _signatureDigest , _sender ) ; }
","Verify lockup signature is valid
"
"function changeBurner ( address _newBurner ) public onlyBurner { burner = _newBurner ; }
","Change a burner address
"
"function transferStoreOwnership ( address _newOwner ) external onlyOwner { store . transferOwnership ( _newOwner ) ; }
","Allows the contract owner to transfer ownership of the DarknodeRegistryStore .
"
"function safeApprove ( address token , address spender , uint256 amount ) internal { CompatibleERC20 ( token ) . approve ( spender , amount ) ; require ( previousReturnValue ( ) , ""approve failed"" ) ; }
","Calls approve on the token and reverts if the call fails .
"
"function massTransfer ( address [ ] addresses , uint [ ] values , bytes32 _symbol ) external onlyAfterBlock ( _symbol ) returns ( uint errorCode , uint count ) { require ( addresses . length == values . length , ""Different length of addresses and values for mass transfer"" ) ; require ( _symbol != 0x0 , ""Asset's symbol cannot be 0"" ) ; return _massTransferDirect ( addresses , values , _symbol ) ; }
","Performes asset transfer for multiple destinations
"
"function changeMultiSigAddress ( address _newAddress ) { require ( multiSigAddress == msg . sender ) ; multiSigAddress = _newAddress ; LogChangeMultiSigAddress ( _newAddress ) ; }
","This method will change old multi signature address with new one .
"
"function _transfer ( uint _fromId , uint _toId , uint _value , bytes32 _symbol , string _reference , uint _senderId ) internal returns ( uint ) { if ( _fromId == _toId ) { return _error ( ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( _value == 0 ) { return _error ( ATX_PLATFORM_INVALID_VALUE ) ; } if ( _balanceOf ( _fromId , _symbol ) < _value ) { return _error ( ATX_PLATFORM_INSUFFICIENT_BALANCE ) ; } if ( _fromId != _senderId && _allowance ( _fromId , _senderId , _symbol ) < _value ) { return _error ( ATX_PLATFORM_NOT_ENOUGH_ALLOWANCE ) ; } _transferDirect ( _fromId , _toId , _value , _symbol ) ; if ( _fromId != _senderId ) { assets [ _symbol ] . wallets [ _fromId ] . allowance [ _senderId ] = assets [ _symbol ] . wallets [ _fromId ] . allowance [ _senderId ] . sub ( _value ) ; } Emitter ( eventsHistory ) . emitTransfer ( _address ( _fromId ) , _address ( _toId ) , _symbol , _value , _reference ) ; _proxyTransferEvent ( _fromId , _toId , _value , _symbol ) ; return OK ; }
","Transfers asset balance between holders wallets .
"
"function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { BancorConverter converter = BancorConverter ( data . converterAddress ) ; IBancorGasPriceLimit gasPriceLimitContract = IBancorGasPriceLimit ( converter . registry ( ) . getAddress ( converter . BANCOR_GAS_PRICE_LIMIT ( ) ) ) ; uint256 gasPriceLimit = gasPriceLimitContract . gasPrice ( ) ; checksPassed = tx . gasprice <= gasPriceLimit ; }
","Perform exchange-specific checks on the given order
"
"function banUser ( address _user ) external isAdmin { bannedUser [ _user ] = true ; cooldown [ _user ] = now + 30 minutes ; }
","Ban a user
"
"function contest ( address _requester , uint256 _reward , bytes32 _requestNonce , bytes _requesterSig ) external { contestForUser ( msg . sender , _requester , _reward , _requestNonce , _requesterSig ) ; }
","Function for attester to reject an attestation and receive payment without associating the negative attestation with the subject 's bloomId
"
"function modifySecurityToken ( string _name , string _ticker , address _owner , address _securityToken , string _tokenDetails , uint256 _deployedAt ) external ;
","Adds a new custom Security Token and saves it to the registry .
"
"function safeApprove ( address _spender , uint256 _value ) public returns ( bool ) { require ( allowed [ msg . sender ] [ _spender ] == 0 || _value == 0 ) ; require ( approve ( _spender , _value ) ) ; }
","Call this only after you decreased the approve to zero using decreaseApproval .
"
"function blacklistAddresses ( address [ ] _investors ) public onlyOwner { for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { blacklist ( _investors [ i ] ) ; } }
","interface for founders to blacklist investors
"
"function takeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { require ( Fund ( address ( this ) ) . owner ( ) == msg . sender ) ; require ( ! Fund ( address ( this ) ) . isShutDown ( ) ) ; var ( pricefeed , , ) = Fund ( address ( this ) ) . modules ( ) ; uint fillTakerQuantity = orderValues [ 6 ] ; var ( maxMakerQuantity , makerAsset , maxTakerQuantity , takerAsset ) = MatchingMarket ( targetExchange ) . getOffer ( uint ( identifier ) ) ; uint fillMakerQuantity = mul ( fillTakerQuantity , maxMakerQuantity ) / maxTakerQuantity ; require ( takerAsset != address ( this ) && makerAsset != address ( this ) ) ; require ( address ( makerAsset ) != address ( takerAsset ) ) ; require ( pricefeed . existsPriceOnAssetPair ( takerAsset , makerAsset ) ) ; require ( fillMakerQuantity <= maxMakerQuantity ) ; require ( fillTakerQuantity <= maxTakerQuantity ) ; require ( takeOrderPermitted ( fillTakerQuantity , takerAsset , fillMakerQuantity , makerAsset ) ) ; require ( takerAsset . approve ( targetExchange , fillTakerQuantity ) ) ; require ( MatchingMarket ( targetExchange ) . buy ( uint ( identifier ) , fillMakerQuantity ) ) ; require ( Fund ( address ( this ) ) . isInAssetList ( makerAsset ) || Fund ( address ( this ) ) . getOwnedAssetsLength ( ) < Fund ( address ( this ) ) . MAX_FUND_ASSETS ( ) ) ; Fund ( address ( this ) ) . addAssetToOwnedAssets ( makerAsset ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( identifier ) , Fund . UpdateType . take , [ address ( makerAsset ) , address ( takerAsset ) ] , [ maxMakerQuantity , maxTakerQuantity , fillTakerQuantity ] ) ; }
","Takes an active order on the selected exchange
"
"function createChannel ( address beneficiary , uint amount , uint commission , uint expiresAt , bytes32 hashedSecret ) public payable returns ( bytes32 channelId ) { require ( amount + commission >= amount , ""UINT256_OVERFLOW"" ) ; require ( msg . value == amount + commission , ""INACCURATE_MSG_VALUE_SENT"" ) ; _setupChannel ( beneficiary , amount , commission , expiresAt , hashedSecret ) ; }
","Creates a Channel to initiate or participate in .
"
"function setApplication ( address _target , address _parent ) onlyOwner public { require ( getState ( ) == State . Success ) ; require ( _parent != 0x0 ) ; applications [ _target ] = _parent ; uint256 currentBalance = balanceOf [ _target ] ; emit SetApplication ( _target , _parent ) ; if ( currentBalance > 0x0 ) { balanceOf [ _target ] = safeDiv ( balanceOf [ _target ] , currentBalance ) ; balanceOf [ _parent ] = safeAdd ( balanceOf [ _parent ] , currentBalance ) ; emit Transfer ( _target , _parent , currentBalance ) ; } }
","map an address to its application address
"
"function increaseApproval ( address _spender , uint256 _addedValue ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) , ""Invalid address."" ) ; return super . increaseApproval ( _spender , _addedValue ) ; }
","Increases the approval of the spender .
"
"function allocateUnclaimedFees ( ) pre_cond ( isOwner ( ) ) { var ( gav , managementFee , performanceFee , unclaimedFees , feesShareQuantity , nav , sharePrice ) = performCalculations ( ) ; createShares ( owner , feesShareQuantity ) ; uint highWaterMark = atLastUnclaimedFeeAllocation . highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation . highWaterMark : sharePrice ; atLastUnclaimedFeeAllocation = Calculations ( { gav : gav , managementFee : managementFee , performanceFee : performanceFee , unclaimedFees : unclaimedFees , nav : nav , highWaterMark : highWaterMark , totalSupply : totalSupply , timestamp : now } ) ; FeesConverted ( now , feesShareQuantity , unclaimedFees ) ; CalculationUpdate ( now , managementFee , performanceFee , nav , sharePrice , totalSupply ) ; }
","Converts unclaimed fees of the manager into fund shares
"
"function getOrders ( uint256 _offset , uint256 _limit ) external view returns ( bytes32 [ ] , address [ ] , uint8 [ ] ) { if ( _offset >= orderbook . length ) { return ; } uint256 limit = _limit ; if ( _offset + limit > orderbook . length ) { limit = orderbook . length - _offset ; } bytes32 [ ] memory orderIDs = new bytes32 [ ] ( limit ) ; address [ ] memory traderAddresses = new address [ ] ( limit ) ; uint8 [ ] memory states = new uint8 [ ] ( limit ) ; for ( uint256 i = 0 ; i < limit ; i ++ ) { bytes32 order = orderbook [ i + _offset ] ; orderIDs [ i ] = order ; traderAddresses [ i ] = orders [ order ] . trader ; states [ i ] = uint8 ( orders [ order ] . state ) ; } return ( orderIDs , traderAddresses , states ) ; }
","returns order details of the orders starting from the offset .
"
"function getKeysFromETHs ( uint256 _gameID , uint256 [ ] memory _eths ) public view isActivated ( _gameID ) returns ( uint256 , uint256 [ ] ) { uint256 _totalKeys = 0 ; uint256 _nt = game_ [ _gameID ] . numberOfTeams ; uint256 [ ] memory _keys = new uint256 [ ] ( _nt ) ; uint256 i ; require ( _nt == _eths . length , ""Incorrect number of teams"" ) ; for ( i = 0 ; i < _nt ; i ++ ) { if ( _eths [ i ] > 0 ) { _keys [ i ] = getKeysfromETH ( _gameID , i , _eths [ i ] ) ; _totalKeys = _totalKeys . add ( _keys [ i ] ) ; } } return ( _totalKeys , _keys ) ; }
","Get all numbers of keys can be bought with amounts of ETH .
"
"function recoverTokens ( IERC20 token ) public onlyOwner { uint256 balance = token . balanceOf ( this ) ; require ( token . transfer ( owner ( ) , balance ) , ""Token transfer failed, transfer() returned false."" ) ; }
","Recover tokens accidentally sent to this contract .
"
"function calm ( ) returns ( bool ) ;
","Release the contract from a Panic after the panic period has expired .
"
"function createAndJoinCDPAllDai ( ) public returns ( bytes32 id ) { return createAndJoinCDPDai ( dai . balanceOf ( msg . sender ) ) ; }
","create a CDP from all the Dai in the sender 's balance - needs Dai transfer approval
"
"function transferFrom ( Data storage self , string currency , address from , address to , uint amount , bytes data ) internal returns ( bool success ) { require ( address ( to ) != 0x0 , ""Error: `to` address must not be null."" ) ; address feeContract = getFeeContract ( self , address ( this ) ) ; uint fees = calculateFees ( self , feeContract , amount ) ; require ( setAccountSpendingAmount ( self , from , getFxUSDAmount ( self , currency , amount ) ) , ""Error: Unable to set account spending amount."" ) ; require ( forceTransfer ( self , currency , from , to , amount , data ) , ""Error: Unable to transfer funds to account."" ) ; require ( forceTransfer ( self , currency , from , feeContract , fees , getFeeMsg ( self , feeContract ) ) , ""Error: Unable to transfer fees to fee contract."" ) ; require ( updateAllowance ( self , currency , from , amount ) , ""Error: Unable to update allowance for spender."" ) ; return true ; }
","Transfer an amount of currency token from account to another specified account via an approved spender account
"
"function proposeShutdown ( uint ofVersionId ) { versionIdToShutdownIds [ ofVersionId ] = propose ( address ( this ) , new bytes ( 0 ) , 0 ) ; }
","Propose shutdown of Melon version
"
"function purchaseWithPromoter ( address _to , address _ref ) payable public { require ( now >= presaleStartTime && now <= crowdsaleEndTime ) ; require ( ! icoClosed ) ; uint _wei = msg . value ; uint cst ; ethSent [ msg . sender ] = ethSent [ msg . sender ] . add ( _wei ) ; ethSold = ethSold . add ( _wei ) ; if ( now < crowdsaleStartTime || approvedInvestors [ msg . sender ] ) { require ( kyc [ msg . sender ] ) ; cst = _wei . mul ( ethRate ) . div ( 12000000 ) ; require ( now < crowdsaleStartTime || cst >= bonusLevel100 ) ; _sellPresale ( cst ) ; if ( _ref == wuguAddr || _ref == richardAddr ) { promoterClients [ _ref ] . push ( _to ) ; promoterBonus [ _ref ] [ _to ] = _wei . mul ( 5 ) . div ( 100 ) ; } } else { cst = _wei . mul ( ethRate ) . div ( 16000000 ) ; _sellCrowd ( cst , _to ) ; } _freezeTransfer ( _to , cst ) ; }
","5 % return must work only on crowdsale
"
"function decline ( bytes32 _key , bytes32 _votingGroupName ) external returns ( uint ) { if ( ! isTxExist ( _key ) ) { return _emitError ( PENDING_MANAGER_TX_DOESNT_EXIST ) ; } if ( ! GroupsAccessManager ( accessManager ) . isUserInGroup ( _votingGroupName , msg . sender ) ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } Guard storage _guard = txKey2guard [ _key ] ; if ( _guard . state != GuardState . InProcess ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } if ( _guard . votes [ msg . sender ] . groupName != bytes32 ( 0 ) && ! _guard . votes [ msg . sender ] . accepted ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } Policy storage _policy = policyId2policy [ index2PolicyId [ _guard . basePolicyIndex ] ] ; uint _policyGroupIndex = _policy . groupName2index [ _votingGroupName ] ; uint _groupDeclinedVotesCount = _guard . declinedCount [ _votingGroupName ] ; if ( _groupDeclinedVotesCount == _policy . participatedGroups [ _policyGroupIndex ] . declineLimit ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } _guard . votes [ msg . sender ] = Vote ( _votingGroupName , false ) ; _guard . declinedCount [ _votingGroupName ] = _groupDeclinedVotesCount + 1 ; uint _alreadyDeclinedCount = _guard . alreadyDeclined + 1 ; _guard . alreadyDeclined = _alreadyDeclinedCount ; ProtectionTxDeclined ( _key , msg . sender , _votingGroupName ) ; if ( _alreadyDeclinedCount == _policy . totalDeclinedLimit ) { _guard . state = GuardState . Decline ; ProtectionTxCancelled ( _key ) ; } return OK ; }
","Decline transaction Can be called only by registered user in GroupsAccessManager
"
"function recomputeLastAverageBalance ( address account ) external returns ( uint ) { updateIssuanceData ( account , nominsIssued [ account ] , nomin . totalSupply ( ) ) ; return issuanceData [ account ] . lastAverageBalance ; }
","Recompute and return the given account 's last average balance .
"
"function prolong ( uint _timeInMins ) external onlyOwner { require ( ! didProlong ) ; require ( now <= deadline - 4 days ) ; uint t = _timeInMins * 1 minutes ; require ( t <= 3 weeks ) ; deadline += t ; length += t ; didProlong = true ; emit Prolonged ( msg . sender , deadline ) ; }
","Is going to be called in an extreme case where we need to prolong the ICO ( e.g .
"
"function approve ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer a specific Pony via transferFrom ( ) .
"
"function ( ) public payable { require ( msg . value != 0 ) ; friendsFingersWallet . transfer ( msg . value ) ; }
","This is for people who want to donate ETH to FriendsFingers
"
"function getEndPointOfCampaign ( bytes32 bidId ) public view returns ( string url ) { return ExtendedAdvertisementStorage ( address ( _getStorage ( ) ) ) . getCampaignEndPointById ( bidId ) ; }
","Returns the signing Endpoint of a camapign Function returning the Webservice URL responsible for validating and signing a PoA
"
"function decimals ( ) public erc20 constant returns ( uint8 ) { return uint8 ( 18 ) ; }
","For Backwards compatibility
"
"function claimTokens ( token _address ) onlyAdmin public { require ( state == State . Successful ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( admin , remainder ) ; }
","Function to claim any token stuck on contract
"
"function buyTokensForAddress ( address _recipient ) external payable { totalFunds = totalFunds + msg . value ; require ( msg . value > 0 ) ; require ( _recipient != admin ) ; require ( ( totalFunds / 1 ether ) * pricePerEther < 6000000000 ) ; addUser ( _recipient ) ; bytes memory empty ; uint tokenAmount = calculateTokenAmount ( msg . value ) ; balances [ selfAddress ] = balances [ selfAddress ] - tokenAmount ; assert ( balances [ selfAddress ] >= 50000000000000 ) ; balances [ _recipient ] = balances [ _recipient ] + tokenAmount ; Transfer ( selfAddress , _recipient , tokenAmount , empty ) ; address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de ; etherTransfer . transfer ( msg . value ) ; }
","Purchase WBC Tokens for Address - ICO
"
"function transfer ( address to , uint value , bytes data ) public optionalProxy notFeeAddress ( messageSender ) returns ( bool ) { uint amountReceived = feePool . amountReceivedFromTransfer ( value ) ; uint fee = value . sub ( amountReceived ) ; synthetix . synthInitiatedFeePayment ( messageSender , currencyKey , fee ) ; return _internalTransfer ( messageSender , to , amountReceived , data ) ; }
","Override ERC223 transfer function in order to subtract the transaction fee and send it to the fee pool for SNX holders to claim .
"
"function unlockStatus ( address _owner ) public is_locked ( _owner ) validate_address ( _owner ) onlyOwner { lockedAccounts [ _owner ] = false ; _unlockAccount ( _owner ) ; }
","only the admin is allowed to unlock accounts .
"
"function register ( address ofAsset , string name , string symbol , uint decimal , string url , string ipfsHash , bytes32 chainId , address breakIn , address breakOut ) pre_cond ( isOwner ( ) ) pre_cond ( ! information [ ofAsset ] . exists ) { Asset asset = information [ ofAsset ] ; asset . name = name ; asset . symbol = symbol ; asset . decimal = decimal ; asset . url = url ; asset . ipfsHash = ipfsHash ; asset . breakIn = breakIn ; asset . breakOut = breakOut ; asset . exists = true ; assert ( information [ ofAsset ] . exists ) ; }
","Registers an Asset residing in a chain
"
"function changeAccountAddressForSponseeAddress ( address _newAddress ) { require ( accountAddressForSponseeAddress == msg . sender ) ; accountAddressForSponseeAddress = _newAddress ; LogChangeAccountAddressForSponseeAddress ( _newAddress ) ; }
","This method will change old multi signature for sponsee address with new one .
"
"function getState ( ) public constant returns ( State ) { if ( finalizedCrowdfunding ) return State . Success ; if ( fundingStartBlock == 0 && fundingEndBlock == 0 ) return State . PrivateFunding ; else if ( block . number < fundingStartBlock ) return State . PreFunding ; else if ( block . number <= fundingEndBlock && tokensSold < tokenCreationMax ) return State . Funding ; else if ( tokensSold >= tokenCreationMin ) return State . Success ; else return State . Failure ; }
","This manages the crowdfunding state machine We make it a function and do not assign the result to a variable So there is no chance of the variable being stale
"
"function finalizeTokensale ( ) onlyOwner public { finalized = true ; assert ( token . finishMinting ( ) ) ; token . setBarrierAsOpen ( true ) ; token . transferOwnership ( owner ) ; forwardCollectedEther ( ) ; }
","ICO End : `` openBarrier '' no longer applied , allows token transfers
"
"function createProject ( PassDao _passDao , string _name , string _description , bytes32 _hashOfTheDocument ) returns ( PassProject ) { PassProject _passProject = new PassProject ( _passDao , _name , _description , _hashOfTheDocument ) ; NewPassProject ( _passDao , _passProject , _name , _description , _hashOfTheDocument ) ; return _passProject ; }
","Function to create a new Pass project
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","Set allowance for other address
"
"function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { require ( _address != tokenReward ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
","Function to claim any token stuck on contract
"
"function isSTOAttached ( ) internal view returns ( bool ) { address _sto ; ( , _sto ) = ISecurityToken ( securityToken ) . getModule ( 3 , 0 ) ; if ( _sto == address ( 0 ) ) return false ; return true ; }
","Internal function use to know whether the STO is attached or not
"
"function pause ( ) public onlyOwner { require ( now < endTime , ""STO has been finalized"" ) ; super . _pause ( ) ; }
","Pause ( overridden function )
"
"function getFeatureStatus ( string _nameKey ) external view returns ( bool ) { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; return featureStatus [ key ] ; }
","Get the status of a feature
"
"function isPendingDeregistration ( address _darknodeID ) external view returns ( bool ) { uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return deregisteredAt != 0 && deregisteredAt > currentEpoch . blocknumber ; }
","Returns if a darknode is in the pending deregistered state .
"
"function getPeriod ( uint256 _lockTypeIndex , uint256 _timeDifference ) internal view returns ( uint256 ) { if ( _lockTypeIndex == 1 ) { uint256 _period1 = ( _timeDifference . div ( oneMonth ) ) . div ( 12 ) ; if ( _period1 >= 3 ) { _period1 = 3 ; } return _period1 ; } if ( _lockTypeIndex == 2 ) { uint256 _period2 = _timeDifference . div ( oneMonth ) ; if ( _period2 >= 3 ) { _period2 = 3 ; } return _period2 ; } if ( _lockTypeIndex == 3 ) { uint256 _period3 = _timeDifference . div ( oneMonth ) ; if ( _period3 >= 6 ) { _period3 = 6 ; } return _period3 ; } revert ( ) ; }
","get time period for the given '_lockTypeIndex '
"
"function issueAttribute ( address account ) external whenNotPaused whenIssuanceNotPaused { require ( account != address ( 0 ) , ""must supply a valid account address"" ) ; require ( _organizations [ msg . sender ] . exists == true , ""only organizations may issue attributes"" ) ; uint256 maximum = uint256 ( _organizations [ msg . sender ] . maximumAccounts ) ; require ( _organizations [ msg . sender ] . accounts . length < maximum , ""the organization is not permitted to issue any additional attributes"" ) ; _jurisdiction . issueAttribute ( account , _validAttributeTypeID , 0 ) ; require ( _registry . hasAttribute ( account , _validAttributeTypeID ) == true , ""attribute addition was not accepted by the jurisdiction"" ) ; _organizations [ msg . sender ] . issuedAccounts [ account ] = true ; uint256 index = _organizations [ msg . sender ] . accounts . length ; _organizations [ msg . sender ] . issuedAccountsIndex [ account ] = index ; _organizations [ msg . sender ] . accounts . push ( account ) ; emit AttributeIssued ( msg . sender , account ) ; }
","Add an attribute to account ` account ` .
"
"function upgradeTo ( address ) public { assert ( false ) ; }
","Will always fail if called .
"
"function unpause ( ) external timedStateChange requiresState ( IcoState . PAUSED ) onlymanyowners ( sha3 ( msg . data ) ) { changeState ( IcoState . ICO ) ; checkTime ( ) ; }
","resume paused ICO
"
"function numVestingEntries ( address account ) public view returns ( uint ) { return vestingSchedules [ account ] . length ; }
","The number of vesting dates in an account 's schedule .
"
"function requestBonus ( ) external { require ( getState ( ) == State . Success ) ; uint256 bonusAmount = bonus [ msg . sender ] ; assert ( bonusAmount > 0 ) ; require ( bonusAmount <= safeSub ( bonusAndBountyTokens , bonusAmount ) ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , bonusAmount ) ; bonus [ msg . sender ] = 0 ; bonusAndBountyTokens = safeSub ( bonusAndBountyTokens , bonusAmount ) ; emit BonusTransfer ( msg . sender , bonusAmount , block . number ) ; emit Transfer ( 0 , msg . sender , bonusAmount ) ; }
","send bonus token to broker
"
"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = recoverPreSignedHash ( address ( this ) , increaseApprovalSig , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; require ( _nonce == nonces [ from ] . add ( 1 ) ) ; require ( allowed [ from ] [ _spender ] . add ( _addedValue ) . add ( _fee ) <= balances [ from ] ) ; nonces [ from ] = _nonce ; signatures [ _signature ] = true ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
","Increase the amount of tokens that an owner allowed to a spender .
"
"function _paymentProceed ( uint256 _userId , Factory _factory ) private returns ( uint256 ) { User storage user = users [ _userId ] ; require ( _checkPayment ( user , _factory . ftype , _factory . level ) ) ; uint256 price = getPrice ( _factory . ftype , 0 ) ; user . balance = user . balance . add ( msg . value ) ; user . balance = user . balance . sub ( price ) ; user . totalPay = user . totalPay . add ( price ) ; totalDeposit += msg . value ; uint256 index = factories . push ( _factory ) - 1 ; factoryToUser [ index ] = _userId ; userToFactories [ _userId ] . push ( index ) ; _distributeInvestment ( msg . value ) ; _distributeReferrers ( _userId , price ) ; _updateLeaders ( msg . sender , msg . value ) ; emit PaymentProceed ( _userId , index , _factory . ftype , price ) ; return index ; }
","function of proceed payment
"
"function setDeadline ( uint256 _deadline ) public onlyCreator { require ( _deadline > now && _deadline > startStage2Time ) ; deadline = _deadline ; }
","Set timestamp of deadline
"
"function transferTokenFrom ( Token _tokenContract , address _transferTo , address _transferFrom , uint256 _value ) onlyOwner external { _tokenContract . transferFrom ( _transferTo , _transferFrom , _value ) ; }
","Send ERC20 tokens away .
"
"function claimTokenOwnership ( address _to ) public onlyOwner { POSTokenI ( token ) . transferOwnershipTo ( _to ) ; }
","transfer token ownerhsip
"
"function buyToken ( ) internal { uint256 value = msg . value ; address sender = msg . sender ; require ( ! icoIsClosed ) ; require ( ! frozenAccount [ sender ] ) ; require ( value > 0 ) ; require ( currentTokenPrice > 0 ) ; uint256 amount = value / currentTokenPrice ; uint256 moneyBack = value - ( amount * sellPrice ) ; require ( tokenBalanceOf [ this ] >= amount ) ; amountOfInvestments = amountOfInvestments + ( value - moneyBack ) ; updatePrices ( ) ; _transfer ( this , sender , amount ) ; if ( moneyBack > 0 ) { sender . transfer ( moneyBack ) ; } }
","Processing each buying
"
"function mAfterTransition ( ETOState oldState , ETOState newState ) internal ;
","gets called after every state transition .
"
"function getSecretRevealBlockHeight ( bytes32 secrethash ) public view returns ( uint256 ) { return secrethash_to_block [ secrethash ] ; }
","Get the stored block number at which the secret was revealed .
"
"function updateRewardPercentageByIndex ( uint256 _index , uint256 _percentage ) public onlyAdmin isValidRewardIndex ( _index ) isValidRewardPercentage ( _percentage ) { rewardPercentage [ _index ] = _percentage ; emit RewardPercentage ( _index , _percentage ) ; }
","Edits the contents of the percentage array , with the specified parameters .
"
"function changeMinimumBetAmount ( uint newMinimumBetAmount ) external onlyOwner { if ( newMinimumBetAmount > 0 ) { minimumBetAmount = newMinimumBetAmount ; } }
","Changes the minimum amount needed to place a bet
"
"function ownerUnlock ( address target , uint256 amount ) onlyOwner public returns ( bool res ) { require ( lockedAmount [ target ] >= amount ) ; balanceOf [ target ] += amount ; lockedAmount [ target ] -= amount ; OwnerUnlock ( target , amount ) ; return true ; }
","cotnract owner unlock some token for target address despite of time
"
"function authorizeSpender ( address _spender , bool _authorize ) onlyOwner external { allowedSpenders [ _spender ] = _authorize ; emit SpenderAuthorization ( _spender , _authorize ) ; }
","` onlyOwner ` Adds a spender to the ` allowedSpenders [ ] ` white list
"
"function owner ( bytes32 _symbol ) public view returns ( address ) { return holders [ assets [ _symbol ] . owner ] . addr ; }
","Returns asset owner address .
"
"function changeSponseeAddress ( address _newAddress ) { require ( accountAddressForSponseeAddress == msg . sender ) ; sponseeAddress = _newAddress ; LogChangeSponseeAddress ( _newAddress ) ; }
","This method will change old sponsee address with new one .
"
"function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( currentTokenPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * currentTokenPrice ; uint256 detractSell = revenue / commRate ; require ( this . balance >= revenue ) ; msg . sender . transfer ( revenue - detractSell ) ; }
","Sell DOL and receive ETH from VAULT
"
"function withdrawMln ( address to , uint amount ) pre_cond ( isOwner ( ) ) { MELON_CONTRACT . transfer ( to , amount ) ; }
","Withdraw MLN
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) public returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function batchRegularTransfers ( bytes32 [ ] swapIds , bytes32 [ ] secrets ) public { require ( swapIds . length <= MAX_BATCH_ITERATIONS ) ; for ( uint i = 0 ; i < swapIds . length ; ++ i ) regularTransfer ( swapIds [ i ] , secrets [ i ] ) ; }
","Batch exection of regularTransfer ( ) function
"
"function isWhitelisted ( address _investor ) public onlyOwner constant returns ( bool ) { return canPurchase [ _investor ] ; }
","Notifies if an investor is whitelisted for contribution
"
"function setWalletAddress ( address _walletAddress ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _walletAddress != address ( 0 ) ) ; require ( _walletAddress != wallet ) ; address oldAddress = wallet ; wallet = _walletAddress ; emit WalletAddressChanged ( oldAddress , _walletAddress ) ; }
","Change the wallet where ether will be sent to when tokens are bought
"
"function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E95 ) , _newCFO , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by setCFO
"
"function getType ( ) public view returns ( uint8 ) { return 2 ; }
","Type of the Module factory
"
"function transfer ( address _to , uint256 _deedId ) external ;
","Transfer a deed to a new owner .
"
"function SetPresaleAmountLimits ( uint _minPresaleAmount , uint _maxPresaleAmount ) ;
","Function used by the creator to set the presale limits
"
"function tokenMinter ( uint256 _amount ) private returns ( bool minted ) { require ( tokenMintingEnabled ) ; require ( _amount > 0 ) ; require ( totalSupply . add ( _amount ) > 0 ) ; require ( totalSupply . add ( _amount ) > totalSupply ) ; require ( balances [ owner ] . add ( _amount ) > 0 ) ; require ( balances [ owner ] . add ( _amount ) > balances [ owner ] ) ; return true ; }
","Low level function Used to create new tokens and increase total supply
"
"function setPreICOSoldAmount ( uint256 _soldTokens , uint256 _raisedWei ) onlyOwner beforeICO public { tokensSold = tokensSold . add ( _soldTokens ) ; totalWeiRaised = totalWeiRaised . add ( _raisedWei ) ; }
","Sets how many tokens have we sold in PRE-ICO phase
"
"function supportsInterface ( bytes4 interfaceID ) external view returns ( bool ) ;
","Query if a contract implements an interface
"
"function instantiate ( bytes _bytecode , bytes _args ) public payable returns ( address contractAddress ) { require ( bytecodeHash == keccak256 ( _bytecode ) ) ; bytes memory calldata = abi . encodePacked ( _bytecode , _args ) ; assembly { contractAddress := create ( 0 , add ( calldata , 0x20 ) , mload ( calldata ) ) } if ( contractAddress == address ( 0 ) ) { revert ( ""Cannot instantiate contract"" ) ; } else { Contract c = Contract ( contractAddress ) ; require ( c . supportsInterface ( 0x01ffc9a7 ) ) ; require ( c . supportsInterface ( 0x6125ede5 ) ) ; if ( price > 0 ) { require ( msg . value == price ) ; beneficiary . transfer ( msg . value ) ; } emit Instantiated ( msg . sender , contractAddress ) ; } }
","` msg.sender ` is passed as first argument for the newly created ` Contract ` .
"
"function startVoting ( uint startBlockNr , uint durationHrs ) onlyOwner { VOTING_START_BLOCKNR = max ( block . number , startBlockNr ) ; VOTING_END_TIME = now + max ( durationHrs , 1 ) * 1 hours ; }
","start voting at ` startBlockNr ` for ` durationHrs ` .
"
"function setFeeMsg ( Data storage self , bytes feeMsg ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.msg' , address ( this ) ) ) ; require ( self . Storage . setBytes ( id , feeMsg ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set fee message for contract interface
"
"function mintToken ( uint256 amount ) isOwner { require ( amount > 0 ) ; require ( tokenBalanceOf [ this ] <= icoMin ) ; require ( _totalSupply + amount > _totalSupply ) ; require ( tokenBalanceOf [ this ] + amount > tokenBalanceOf [ this ] ) ; _totalSupply += amount ; tokenBalanceOf [ this ] += amount ; allowed [ this ] [ owner ] = tokenBalanceOf [ this ] ; allowed [ this ] [ supervisor ] = tokenBalanceOf [ this ] ; tokenCreated ( msg . sender , amount , ""Additional metadollars created!"" ) ; }
","Create an amount of metadollars
"
"function burnFromWithData ( address _from , uint256 _value , bytes _data ) external ;
","Used to burn the securityToken on behalf of someone else
"
"function paymentRegularTokensPriority ( uint256 _amount , uint256 _rewardPercentageIndex ) public { uint256 regularTokensAvailable = balances [ msg . sender ] ; if ( regularTokensAvailable >= _amount ) { paymentRegularTokens ( _amount , _rewardPercentageIndex ) ; } else { if ( regularTokensAvailable > 0 ) { uint256 amountOfRewardsTokens = _amount . sub ( regularTokensAvailable ) ; paymentMixed ( regularTokensAvailable , amountOfRewardsTokens , _rewardPercentageIndex ) ; } else { paymentRewardTokens ( _amount ) ; } } }
","Process a payment that prioritizes the use of regular tokens .
"
"function resourcesAtTime ( uint256 _factoryId ) public view returns ( uint256 ) { Factory storage factory = factories [ _factoryId ] ; return _resourcesAtTime ( factory . ftype , factory . level , factory . collected_at ) ; }
","function for compute resource factory at time
"
"function execute ( address _to , uint _value , bytes _data ) returns ( uint8 ) ;
","Send a transaction to ` _to ` containing ` _value ` with RLP encoded arguments of ` _data `
"
"function setFee ( address stablecoin , uint256 _newFee ) public onlyOwner whenNotPaused { require ( isWhitelisted ( stablecoin ) , ""Stablecoin must be whitelisted prior to setting conversion fee"" ) ; tokenStorage_CD . setFee ( stablecoin , _newFee ) ; }
","Change fees associated with going from CarbonUSD to a particular stablecoin .
"
"function splitProfits ( ) external { require ( splitInService ) ; bytes memory empty ; uint i ; if ( ! isFrozen ) { require ( now >= relativeDateSave ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 30000000000000 ) ; relativeDateSave = now + 30 days ; currentProfits = ( ( balances [ selfAddress ] - 30000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 300000000000000 , balances [ selfAddress ] ) ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { monthlyLimit [ users [ i ] ] = 5000000000000 ; if ( msg . gas < 240000 ) { currentIteration = i ; break ; } if ( allowed [ selfAddress ] [ users [ i ] ] == 0 ) { checkSplitEnd ( i ) ; continue ; } else if ( ( balances [ users [ i ] ] / allowed [ selfAddress ] [ users [ i ] ] ) < 19 ) { checkSplitEnd ( i ) ; continue ; } balances [ users [ i ] ] += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; actualProfitSplit += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; checkSplitEnd ( i ) ; Transfer ( selfAddress , users [ i ] , ( balances [ users [ i ] ] / amountInCirculation ) * currentProfits , empty ) ; } } }
","Split the monthly profits of the Casino to the users
"
"function changeFactoryUsageFee ( uint256 _newUsageCost ) public onlyOwner { emit LogChangeFactoryUsageFee ( usageCost , _newUsageCost , address ( this ) ) ; usageCost = _newUsageCost ; }
","used to change the fee of the usage cost
"
"function transferFromFrozenAccount ( address _from , address _to , uint256 _amount ) external onlyOwner whenNotPaused whenAccountFrozen ( _from ) whenAccountNotFrozen ( _to ) whenAccountNotFrozen ( msg . sender ) { super . doSend ( msg . sender , _from , _to , _amount , """" , """" , true ) ; }
","super.doSend to skip `` _from '' frozen checking
"
"function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ _tokenId ] = 0 ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; }
","Use and override this function with caution .
"
"function confirmPrintProxy ( bytes32 _lockId ) public onlyCustodian { erc20Impl . confirmPrint ( _lockId ) ; }
","Pass-through control of print confirmation , allowing this contract 's custodian to act as the custodian of the associated active token implementation .
"
"function withdrawDAI ( address _receiver , uint _amount ) public onlyArbitrator { require ( _receiver != 0x0 ) ; require ( _amount > 0 ) ; require ( DAI . balanceOf ( address ( this ) ) >= _amount ) ; DAI . transfer ( _receiver , _amount ) ; emit DAIWithdrawn ( _receiver , _amount ) ; }
","this function lets arbitrator withdraw DAI to the provided address
"
"function reportAnswer ( bytes32 question_id , bytes32 last_history_hash , bytes32 last_answer_or_commitment_id , uint256 last_bond , address last_answerer , bool is_commitment ) onlyInitialized public { IMarket market = realitio_questions [ question_id ] . augur_market ; require ( realitio_questions [ question_id ] . bounty > 0 , ""Arbitration must have been requested for this question"" ) ; bool is_answered ; bytes32 last_answer ; _verifyInput ( question_id , last_history_hash , last_answer_or_commitment_id , last_bond , last_answerer , is_commitment ) ; ( is_answered , last_answer ) = _answerData ( question_id , last_history_hash , last_answer_or_commitment_id , last_bond , last_answerer , is_commitment ) ; require ( market . isFinalized ( ) , ""The augur market must have been finalized"" ) ; bytes32 answer = realitioAnswerFromAugurMarket ( market ) ; address winner ; if ( is_answered && last_answer == answer ) { winner = last_answerer ; } else { winner = realitio_questions [ question_id ] . disputer ; } realitio . submitAnswerByArbitrator ( question_id , answer , winner ) ; address owner = realitio_questions [ question_id ] . owner ; balanceOf [ owner ] += realitio_questions [ question_id ] . bounty ; delete realitio_questions [ question_id ] ; }
","Report the answer from a finalized Augur market to a Realitio contract with a question awaiting arbitration
"
"function getAddress ( string _nameKey ) external view returns ( address ) ;
","Returns the contract address
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( checkVestingCondition ( _spender ) ) ; if ( balances [ msg . sender ] >= _value ) { approved [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; } return false ; }
","Approve ` _value ` tokens for ` _spender `
"
"function ( ) public payable { if ( msg . sender != address ( exchange ) ) { errorReporter . revertTx ( ""An address other than the exchange cannot send ether to EDHandler fallback"" ) ; } }
","payable fallback to allow the exchange to return ether directly to this contract
"
"function finalizeAndPayoutForHopeful ( uint withId , uint payoutQuantity , uint finalSharePrice , uint finalCompetitionRank ) pre_cond ( isOracle ( ) ) pre_cond ( hopefuls [ withId ] . isDisqualified == false ) pre_cond ( block . timestamp >= endTime ) { hopefuls [ withId ] . finalSharePrice = finalSharePrice ; hopefuls [ withId ] . finalCompetitionRank = finalCompetitionRank ; hopefuls [ withId ] . payoutQuantity = payoutQuantity ; require ( MELON_CONTRACT . transfer ( hopefuls [ withId ] . registrant , payoutQuantity ) ) ; }
","Closing oracle service , inputs final stats and triggers payouts
"
"function executeRequest ( uint id ) external pre_cond ( ! isShutDown ) pre_cond ( requests [ id ] . status == RequestStatus . active ) pre_cond ( requests [ id ] . requestType != RequestType . redeem || requests [ id ] . shareQuantity <= balances [ requests [ id ] . participant ] ) pre_cond ( totalSupply == 0 || ( now >= add ( requests [ id ] . timestamp , module . pricefeed . getInterval ( ) ) && module . pricefeed . getLastUpdateId ( ) >= add ( requests [ id ] . atUpdateId , 2 ) ) ) { require ( module . pricefeed . hasRecentPrice ( address ( QUOTE_ASSET ) ) ) ; require ( module . pricefeed . hasRecentPrices ( ownedAssets ) ) ; var ( isRecent , , ) = module . pricefeed . getInvertedPrice ( address ( QUOTE_ASSET ) ) ; Request request = requests [ id ] ; uint costQuantity = toWholeShareUnit ( mul ( request . shareQuantity , calcSharePrice ( ) ) ) ; if ( request . requestAsset == address ( NATIVE_ASSET ) ) { var ( isPriceRecent , invertedNativeAssetPrice , nativeAssetDecimal ) = module . pricefeed . getInvertedPrice ( address ( NATIVE_ASSET ) ) ; if ( ! isPriceRecent ) { revert ( ) ; } costQuantity = mul ( costQuantity , invertedNativeAssetPrice ) / 10 ** nativeAssetDecimal ; } if ( isInvestAllowed && request . requestType == RequestType . invest && costQuantity <= request . giveQuantity ) { if ( ! isInAssetList [ address ( QUOTE_ASSET ) ] ) { ownedAssets . push ( address ( QUOTE_ASSET ) ) ; isInAssetList [ address ( QUOTE_ASSET ) ] = true ; } request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transferFrom ( request . participant , this , costQuantity ) ) ; createShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . redeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( request . participant , request . shareQuantity ) ; } else if ( isRedeemAllowed && request . requestType == RequestType . tokenFallbackRedeem && request . receiveQuantity <= costQuantity ) { request . status = RequestStatus . executed ; assert ( AssetInterface ( request . requestAsset ) . transfer ( request . participant , costQuantity ) ) ; annihilateShares ( this , request . shareQuantity ) ; } else { revert ( ) ; } }
","Executes active investment and redemption requests , in a way that minimises information advantages of investor
"
"function finalize ( ) external onlyOwner { require ( fundingEnabled ) ; totalSoldTokens = maxSaleToken . sub ( balanceOf [ fundingWallet ] ) ; totalProjectToken = totalSoldTokens . mul ( 50 ) . div ( 50 ) ; lock ( 0xf03eb5eD89Da5ccAC43498A2C56434e30505AB09 , totalProjectToken . mul ( 90 ) . div ( 100 ) , now ) ; lock ( 0xCAF7149Ef61E54F72ACdC7f44a05E5d7D1Db134B , totalProjectToken . mul ( 10 ) . div ( 100 ) , now ) ; balanceOf [ fundingWallet ] = 0 ; fundingEnabled = false ; Transfer ( this , fundingWallet , 0 ) ; Finalize ( msg . sender , totalSupply ) ; }
","BXN Allocation - finalize crowdfunding & time-locked vault of tokens allocated to BXN company , developers and Airdrop program .
"
"function setCrowdsaleAgent ( CrowdsaleAgent _crowdsaleAgent ) public onlyOwner { require ( address ( _crowdsaleAgent ) != address ( 0 ) ) ; crowdsaleAgent = _crowdsaleAgent ; }
","update crowdsale agent
"
"function _mint ( address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; _addToken ( _to , _tokenId ) ; Transfer ( 0x0 , _to , _tokenId ) ; }
","Mint token function
"
"function adminImportOldMEBlock ( uint8 x , uint8 y ) external onlyOwner { ( uint id , address newLandlord ) = market . importOldMEBlock ( x , y ) ; emit LogBuys ( id , x , y , x , y , newLandlord ) ; }
","import blocks from previous version Million Ether Homepage
"
"function createDividendWithCheckpoint ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 _checkpointId , bytes32 _name ) external withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _token , _amount , _checkpointId , excluded , _name ) ; }
","Creates a dividend with a provided checkpoint
"
"function makeOrder ( address onExchange , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) returns ( uint id ) { id = SimpleMarket ( onExchange ) . offer ( sellQuantity , Asset ( sellAsset ) , buyQuantity , Asset ( buyAsset ) ) ; OrderUpdated ( id ) ; }
","Makes an order on the given exchange
"
"function canValidate ( address validator , uint256 attributeTypeID ) internal view returns ( bool ) { return ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) ; }
","Internal function to determine if a validator at account ` validator ` can issue attributes of the type with ID ` attributeTypeID ` .
"
"function registerConsumer ( address aconsumer , uint32 auserID ) onlyOwner external { if ( auserID != 0 ) { emit consumerRegistered ( aconsumer ) ; } else { emit consumerDeregistered ( aconsumer ) ; } consumers [ aconsumer ] = auserID ; }
","Allow the owner of the address ` aconsumer.address ( ) ` to make transactions on behalf of user id ` auserID ` .
"
"function freezeAccount ( address target , bool freeze ) onlyOwner whenNotPaused public { frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }
","` freeze ?
"
"function _check ( uint8 _fundraiseType ) internal { require ( _fundraiseType == 0 || _fundraiseType == 1 , ""Not a valid fundraise type"" ) ; if ( _fundraiseType == 0 ) { fundraiseType = FundraiseType . ETH ; } if ( _fundraiseType == 1 ) { require ( address ( polyToken ) != address ( 0 ) , ""Address of the polyToken should not be 0x"" ) ; fundraiseType = FundraiseType . POLY ; } }
","Internal function used to check the type of fund raise currency
"
"function changeAPTController ( address _newController ) public onlyController { apt . changeController ( _newController ) ; }
","The owner of this contract can change the controller of the APT token Please , be sure that the owner is a trusted agent or 0x0 address .
"
"function userOwnershipChanged ( address _contract , address _from ) external { address _owner = Owned ( _contract ) . contractOwner ( ) ; if ( _owner == _from ) { _emitErrorCode ( USER_REGISTRY_CANNOT_CHANGE_TO_THE_SAME_OWNER ) ; return ; } if ( ! _removeUserContract ( _contract , _from ) ) { _emitErrorCode ( USER_REGISTRY_NO_USER_CONTRACT_FOUND ) ; return ; } if ( _addUserContract ( _contract , _owner ) ) { _emitter ( ) . emitUserContractChanged ( _contract , _from , _owner ) ; } else { _emitter ( ) . emitUserContractRemoved ( _contract , _from ) ; } }
","Listener function .
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MisToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x486A0F02 ) , _newCOO , _nonce ) ; }
","Hash ( keccak256 ) of the payload used by setCOO
"
"function isService ( address _address ) public view returns ( bool check ) { return _address == profiterole || _address == treasury || _address == proxy || _address == pendingManager || emissionProviders [ _address ] || burningMans [ _address ] || sideServices [ _address ] ; }
","Check target address is service
"
"function startIco ( ) whenNotPaused onlyOwner external { require ( ! isIcoStarted && isPresaleFinalized ) ; currentStatus = Status . ICO ; isIcoStarted = true ; icoStartTime = now ; IcoStarted ( icoStartTime ) ; }
","Start ICO and track start time .
"
"function makeOffer ( address _maker , address _offerAsset , address _wantAsset , uint256 _offerAmount , uint256 _wantAmount , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator onlyActiveState { require ( _offerAmount > 0 && _wantAmount > 0 , ""Invalid amounts"" ) ; require ( _offerAsset != _wantAsset , ""Invalid assets"" ) ; bytes32 offerHash = keccak256 ( abi . encodePacked ( ""makeOffer"" , _maker , _offerAsset , _wantAsset , _offerAmount , _wantAmount , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( offerHash , _v , _r , _s ) == _maker , ""Invalid signature"" ) ; _validateAndAddHash ( offerHash ) ; _decreaseBalanceAndPayFees ( _maker , _offerAsset , _offerAmount , _feeAsset , _feeAmount , ReasonMakerGive , ReasonMakerFeeGive , ReasonMakerFeeReceive ) ; Offer storage offer = offers [ offerHash ] ; offer . maker = _maker ; offer . offerAsset = _offerAsset ; offer . wantAsset = _wantAsset ; offer . offerAmount = _offerAmount ; offer . wantAmount = _wantAmount ; offer . availableAmount = _offerAmount ; offer . nonce = _nonce ; emit Make ( _maker , offerHash ) ; }
","Makes an offer which can be filled by other users .
"
"function isTokenEscapable ( address _token ) constant public returns ( bool ) { return ! escapeBlacklist [ _token ] ; }
","Checks to see if ` _token ` is in the blacklist of tokens
"
"function burn ( uint256 _value ) public { require ( ! freezeTransfer || isOps ( ) , ""all transfers are currently frozen"" ) ; require ( _value <= balances [ msg . sender ] , ""address has not enough token to burn"" ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; emit Burn ( burner , _value ) ; emit Transfer ( burner , address ( 0 ) , _value ) ; }
","Burns a specific amount of tokens .
"
"function getApproved ( uint256 _tokenId ) external view returns ( address ) { return tokenApprovals [ _tokenId ] ; }
","Get the approved address for a single NFT
"
"function transferItem ( address _from , address _to , uint256 _itemID ) internal ifItemForSaleThenCancelSale ( _itemID ) { Item storage item = items [ _itemID ] ; if ( item . onChamp && _to != champToOwner [ item . onChampId ] ) { takeOffItem ( item . onChampId , item . itemType ) ; } addressInfo [ _to ] . itemsCount ++ ; addressInfo [ _from ] . itemsCount -- ; itemToOwner [ _itemID ] = _to ; emit TransferItem ( _from , _to , _itemID ) ; }
","Transfer item
"
"function extractAddress ( bytes _data , uint offset ) internal pure returns ( address m ) { require ( offset >= 0 && offset + 20 <= _data . length , ""offset value should be in the correct range"" ) ; assembly { m := and ( mload ( add ( _data , add ( 20 , offset ) ) ) , 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) } }
","Extracts an address from a bytes at a given position .
"
"function modifyTicker ( address _owner , string _ticker , string _tokenName , uint256 _registrationDate , uint256 _expiryDate , bool _status ) external ;
","Modifies the ticker details .
"
"function ownerWithdraw ( uint256 _value ) external onlyOwner { if ( totalFunding < PRESALE_MINIMUM_FUNDING ) revert ( ) ; if ( ! owner . send ( _value ) ) revert ( ) ; }
","The owner can withdraw ethers already during pre sale , only if the minimum funding level has been reached
"
"function getCodeToken ( uint256 _tokenId ) public view returns ( string codetokenName , uint256 sellingPrice , address owner ) { Code storage codetoken = codetokens [ _tokenId ] ; codetokenName = codetoken . name ; sellingPrice = codetokenIndexToPrice [ _tokenId ] ; owner = codetokenIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific codetoken .
"
"function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 2 ) ; allPermissions [ 0 ] = DISTRIBUTE ; allPermissions [ 1 ] = MANAGE ; return allPermissions ; }
","Return the permissions flag that are associated with this module
"
"function getBonusFund ( address user ) external view returns ( uint ) { return bonusFund [ user ] ; }
","Get Bonus Fund For User
"
"function getTypes ( ) external view returns ( uint8 [ ] ) ;
","Type of the Module factory
"
"function _onWhitelist ( address _investor ) internal view returns ( bool ) { return ( ( ( whitelist [ _investor ] . fromTime != 0 ) || ( whitelist [ _investor ] . toTime != 0 ) ) && ( whitelist [ _investor ] . expiryTime >= now ) ) ; }
","Internal function used to check whether the investor is in the whitelist or not & also checks whether the KYC of investor get expired or not
"
"function _adjustTotalSupplyCheckpoints ( ) internal { TokenLib . adjustCheckpoints ( checkpointTotalSupply , totalSupply ( ) , currentCheckpointId ) ; }
","Internal - adjusts totalSupply at checkpoint after minting or burning tokens
"
"function changeController ( address _newController ) public onlyController { msp . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
","The controller of this contract can change the controller of the MSP token Please , be sure that the controller is a trusted agent or 0x0 address .
"
"function setIcoContractAddress ( address contractAddress ) public onlyOwner { freezeBypassing [ contractAddress ] = true ; icoContractAddress = contractAddress ; }
","Sets the ICO Contract Address variable to be used with the ` onlyIcoContract ` modifier .
"
"function exchangeNominsForHavvens ( uint nominAmount ) public pricesNotStale notPaused returns ( uint ) { uint havvensToSend = havvensReceivedForNomins ( nominAmount ) ; nomin . transferFrom ( msg . sender , fundsWallet , nominAmount ) ; havven . transfer ( msg . sender , havvensToSend ) ; emit Exchange ( ""nUSD"" , nominAmount , ""HAV"" , havvensToSend ) ; return havvensToSend ; }
","Exchange nUSD for Havvens
"
"function getOracle ( ) public view returns ( address ) { return owners [ 1 ] ; }
","Gets oracle address that is used to confirm txs .
"
"function escapeHatch ( address _token ) public onlyEscapeHatchCallerOrOwner { require ( escapeBlacklist [ _token ] == false ) ; uint256 balance ; if ( _token == 0x0 ) { balance = this . balance ; escapeHatchDestination . transfer ( balance ) ; EscapeHatchCalled ( _token , balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; balance = token . balanceOf ( this ) ; require ( token . transfer ( escapeHatchDestination , balance ) ) ; EscapeHatchCalled ( _token , balance ) ; }
","The ` escapeHatch ( ) ` should only be called as a last resort if a security issue is uncovered or something unexpected happened
"
"function calcGav ( ) returns ( uint gav ) { uint [ ] memory allAssetHoldings = new uint [ ] ( ownedAssets . length ) ; uint [ ] memory allAssetPrices = new uint [ ] ( ownedAssets . length ) ; address [ ] memory tempOwnedAssets ; tempOwnedAssets = ownedAssets ; delete ownedAssets ; for ( uint i = 0 ; i < tempOwnedAssets . length ; ++ i ) { address ofAsset = tempOwnedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( address ( this ) ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; var ( isRecent , assetPrice , assetDecimals ) = modules . pricefeed . getPriceInfo ( ofAsset ) ; if ( ! isRecent ) { revert ( ) ; } allAssetHoldings [ i ] = assetHoldings ; allAssetPrices [ i ] = assetPrice ; gav = add ( gav , mul ( assetHoldings , assetPrice ) / ( 10 ** uint256 ( assetDecimals ) ) ) ; if ( assetHoldings != 0 || ofAsset == address ( QUOTE_ASSET ) || isInOpenMakeOrder [ ofAsset ] ) { ownedAssets . push ( ofAsset ) ; } else { isInAssetList [ ofAsset ] = false ; } } emit PortfolioContent ( tempOwnedAssets , allAssetHoldings , allAssetPrices ) ; }
","Calculates gross asset value of the fund
"
"function transferFrom ( address from , address to , uint256 tokenAmount ) public tradable ( from ) returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokenAmount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( from , to , tokenAmount ) ; return true ; }
","Transfer tokens from an address to another one through an allowance made before
"
"function exchangeEtherForSynthetix ( ) public payable pricesNotStale notPaused returns ( uint ) { uint synthetixToSend = synthetixReceivedForEther ( msg . value ) ; fundsWallet . transfer ( msg . value ) ; synthetix . transfer ( msg . sender , synthetixToSend ) ; emit Exchange ( ""ETH"" , msg . value , ""SNX"" , synthetixToSend ) ; return synthetixToSend ; }
","Exchange ETH to SNX .
"
"function capReached ( ) public view returns ( bool ) { return tokensSold >= cap ; }
","Checks whether the cap has been reached .
"
"function getExtraPoints ( uint96 extras , Extras extraStats ) private pure returns ( uint16 extraPoints ) { uint16 interceptions = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 missedFieldGoals = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 overtimes = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 sacks = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 fieldGoals = uint16 ( extras & EXTRA_STATS_MASK ) ; extras = extras >> 16 ; uint16 fumbles = uint16 ( extras & EXTRA_STATS_MASK ) ; if ( interceptions == extraStats . interceptions ) { extraPoints += 6 ; } if ( missedFieldGoals == extraStats . missedFieldGoals ) { extraPoints += 6 ; } if ( overtimes == extraStats . overtimes ) { extraPoints += 6 ; } if ( sacks == extraStats . sacks ) { extraPoints += 6 ; } if ( fieldGoals == extraStats . fieldGoals ) { extraPoints += 6 ; } if ( fumbles == extraStats . fumbles ) { extraPoints += 6 ; } }
","calculates points won by yellow and red cards predictions
"
"function enableERC20 ( ) public onlyOwner { mErc20compatible = true ; setInterfaceImplementation ( ""ERC20Token"" , this ) ; }
","Re enables the ERC20 interface .
"
"function createGame ( bytes32 _userEndHash , uint _previousGameId , uint _createBefore , bytes32 _serverEndHash , bytes _serverSig ) public payable onlyValidValue onlyValidHouseStake ( activeGames + 1 ) onlyNotPaused { uint previousGameId = userGameId [ msg . sender ] ; Game storage game = gameIdGame [ previousGameId ] ; require ( game . status == GameStatus . ENDED , ""prev game not ended"" ) ; require ( previousGameId == _previousGameId , ""inv gamePrevGameId"" ) ; require ( block . timestamp < _createBefore , ""expired"" ) ; verifyCreateSig ( msg . sender , _previousGameId , _createBefore , _serverEndHash , _serverSig ) ; uint gameId = gameIdCntr ++ ; userGameId [ msg . sender ] = gameId ; Game storage newGame = gameIdGame [ gameId ] ; newGame . stake = uint128 ( msg . value ) ; newGame . status = GameStatus . ACTIVE ; activeGames = activeGames . add ( 1 ) ; emit LogGameCreated ( msg . sender , gameId , uint128 ( msg . value ) , _serverEndHash , _userEndHash ) ; }
","Create games session request .
"
"function productInfo ( uint256 _productId ) public view returns ( uint256 , uint256 , uint256 , uint256 , bool ) { return ( priceOf ( _productId ) , availableInventoryOf ( _productId ) , totalSupplyOf ( _productId ) , intervalOf ( _productId ) , renewableOf ( _productId ) ) ; }
","The product info for a product
"
"function _callERC165SupportsInterface ( address account , bytes4 interfaceId ) private view returns ( bool success , bool result ) { bytes memory encodedParams = abi . encodeWithSelector ( _InterfaceId_ERC165 , interfaceId ) ; assembly { let encodedParams_data := add ( 0x20 , encodedParams ) let encodedParams_size := mload ( encodedParams ) let output := mload ( 0x40 ) mstore ( output , 0x0 ) success := staticcall ( 30000 , account , encodedParams_data , encodedParams_size , output , 0x20 ) result := mload ( output ) } }
","Calls the function with selector 0x01ffc9a7 ( ERC165 ) and suppresses throw
"
"function transferVoteController ( address _voteController ) public onlyCurator { voteController = _voteController ; logger . emitGenericLog ( ""transferVoteController"" , """" ) ; }
","Sets vote controller to input vote controller address
"
"function moveTokensToEscrowLockupForUser ( address _sender , uint256 _amount ) private { token . safeTransferFrom ( _sender , this , _amount ) ; addToEscrow ( _sender , _amount ) ; }
","Lockup tokens for set time .
"
"function setLocation ( uint index , uint _location ) onlyOwner public { require ( index < locations . length ) ; locations [ index ] = _location ; }
","Admin function to update the location at ` index `
"
"function getMovie ( uint256 _tokenId ) public view returns ( string movieName , uint256 sellingPrice , address owner ) { Movie storage movie = movies [ _tokenId ] ; movieName = movie . name ; sellingPrice = movieIndexToPrice [ _tokenId ] ; owner = movieIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific movie .
"
"function createPromoSeedAuction ( uint8 _teamId , uint8 _posId , uint256 _attributes , uint256 _playerOverrideId , uint256 _mlbPlayerId , uint256 _startPrice , uint256 _endPrice , uint256 _saleDuration ) public onlyGameManager whenNotPaused { require ( nonFungibleContract != address ( 0 ) ) ; require ( _teamId != 0 ) ; uint256 nftId = nonFungibleContract . createPromoCollectible ( _teamId , _posId , _attributes , address ( this ) , 0 , _playerOverrideId , _mlbPlayerId ) ; uint256 startPrice = 0 ; uint256 endPrice = 0 ; uint256 duration = 0 ; if ( _startPrice == 0 ) { startPrice = _computeNextSeedPrice ( 0 , _teamId ) ; } else { startPrice = _startPrice ; } if ( _endPrice != 0 ) { endPrice = _endPrice ; } else { endPrice = 0 ; } if ( _saleDuration == 0 ) { duration = SALES_DURATION ; } else { duration = _saleDuration ; } _createSale ( nftId , startPrice , endPrice , duration , address ( this ) ) ; }
","Creates a new Collectible and creates an auction for it .
"
"function _mint ( address _to , uint256 _tokenId ) internal { super . _mint ( _to , _tokenId ) ; uint256 length = tokens . push ( _tokenId ) ; idToIndex [ _tokenId ] = length - 1 ; }
","This is a private function which should be called from user-implemented external mint function .
"
"function calculateFees ( uint amount ) public view returns ( uint fees ) { return lib . calculateFees ( address ( this ) , amount ) ; }
","Calculates fee of a given transfer amount
"
"function withdraw ( ) returns ( uint8 ) ;
","Initiate a withdrawal of the holder 's ` etherBalance ` Follow up with sendPending ( ) once the timelock has expired
"
"function getCurrencyDenominated ( ) external view returns ( bytes32 ) { return bytes32 ( ""USD"" ) ; }
","Returns denomination of price
"
"function getPizza ( uint256 _tokenId ) public view returns ( string pizzaName , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Pizza storage pizza = pizzas [ _tokenId ] ; pizzaName = pizza . name ; sellingPrice = pizzaIndexToPrice [ _tokenId ] ; owner = pizzaIndexToOwner [ _tokenId ] ; previousPrice = pizzaIndexToPreviousPrice [ _tokenId ] ; previousOwners = pizzaIndexToPreviousOwners [ _tokenId ] ; }
","Returns all the relevant information about a specific pizza .
"
"function convert ( address fromAsset , address toAsset , uint amount ) public notDeprecated returns ( bool success ) { string memory currency = getAssetCurrency ( fromAsset ) ; uint fromDecimals = ERC20Interface ( fromAsset ) . decimals ( ) ; uint toDecimals = ERC20Interface ( toAsset ) . decimals ( ) ; require ( isAllowedAsset ( fromAsset , currency ) , 'Error: Unsupported asset requested. Asset must be supported by this contract and have a currency of `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK` .' ) ; require ( isAllowedAsset ( toAsset , currency ) , 'Error: Unsupported asset requested. Asset must be supported by this contract and have a currency of `USD`, `EUR`, `GBP`, `JPY`, `AUD`, `CAD`, `CHF`, `NOK`, `NZD`, `SEK` .' ) ; if ( isTokenXContract ( toAsset , currency ) ) { require ( ERC20Interface ( fromAsset ) . transferFrom ( msg . sender , address ( this ) , amount ) , 'Error: Unable to transferFrom your asset holdings. Please ensure this contract has an approved allowance equal to or greater than the amount called in transferFrom method.' ) ; uint netAmountFrom = amount . sub ( calcAssetFees ( fromAsset , amount ) ) ; uint convertedAmountFrom = ( netAmountFrom . mul ( 10 ** toDecimals ) ) . div ( 10 ** fromDecimals ) ; require ( lib . deposit ( lib . getTokenSymbol ( toAsset ) , msg . sender , convertedAmountFrom , 'Token, Inc.' ) , ""Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered"" ) ; } else if ( isTokenXContract ( fromAsset , currency ) ) { uint convertedAmount = ( amount . mul ( 10 ** toDecimals ) ) . div ( 10 ** fromDecimals ) ; uint fees = calcAssetFees ( toAsset , convertedAmount ) ; uint netAmountTo = convertedAmount . sub ( fees ) ; require ( ERC20Interface ( toAsset ) . transfer ( msg . sender , netAmountTo ) , 'Unable to call the requested erc20 contract.' ) ; require ( lib . withdraw ( lib . getTokenSymbol ( fromAsset ) , msg . sender , amount , 'Token, Inc.' ) , ""Error: Unable to withdraw funds. Please check issuerFirm and firm authority are registered and have issued funds that can be withdrawn"" ) ; } else { revert ( 'Error: At least one asset must be issued by Token, Inc. (Token X).' ) ; } emit StableSwap ( fromAsset , toAsset , msg . sender , amount , currency ) ; return true ; }
","Amounts will always be passed in according to the decimal representation of the ` fromAsset ` token ;
"
"function execute ( address seller , uint256 quantity , uint256 price ) public payable { require ( enforceKyc == false || ( isAllowedTrade ( msg . sender ) && isAllowedTrade ( seller ) ) , ""Buyer and Seller must be approved to trade on this exchange."" ) ; TradeOrder memory order = orderBook [ seller ] ; require ( order . price == price , ""Buy price does not match the listed sell price."" ) ; require ( block . timestamp < order . expiry , ""Sell order has expired."" ) ; require ( price >= sellFloor , ""The bid is below the minimum allowed."" ) ; require ( sellCeiling == 0 || price <= sellCeiling , ""The bid is above the maximum allowed."" ) ; uint256 tradeQuantity = order . quantity > quantity ? quantity : order . quantity ; order . quantity = order . quantity . sub ( tradeQuantity ) ; if ( order . quantity == 0 ) { order . price = 0 ; order . expiry = 0 ; } orderBook [ seller ] = order ; uint256 cost = tradeQuantity . wmul ( order . price ) ; require ( msg . value >= cost , ""You did not send enough Ether to purchase the tokens."" ) ; uint256 etherFee = calculateFee ( cost ) ; if ( ! ERC20Interface ( tokenContract ) . transferFrom ( seller , msg . sender , tradeQuantity ) ) { revert ( ""Unable to transfer tokens from seller to buyer."" ) ; } seller . transfer ( cost . sub ( etherFee ) ) ; if ( etherFee > 0 ) owner . transfer ( etherFee ) ; lastSellPrice = price ; emit TokensPurchased ( msg . sender , seller , tradeQuantity , price ) ; }
","Buy tokens from an existing sell order .
"
"function changeGranularity ( uint256 _granularity ) public onlyOwner { require ( _granularity != 0 , ""Granularity can not be 0"" ) ; emit LogGranularityChanged ( granularity , _granularity ) ; granularity = _granularity ; }
","allows owner to change token granularity
"
"function setIssuanceRatio ( uint _issuanceRatio ) external onlyOwner { require ( _issuanceRatio <= MAX_ISSUANCE_RATIO , ""New issuance ratio cannot exceed MAX_ISSUANCE_RATIO"" ) ; issuanceRatio = _issuanceRatio ; emit IssuanceRatioUpdated ( _issuanceRatio ) ; }
","Set the issuanceRatio for issuance calculations .
"
"function requestCeilingRaise ( uint256 _raiseBy ) public returns ( bytes32 lockId ) { require ( _raiseBy != 0 ) ; lockId = generateLockId ( ) ; pendingRaiseMap [ lockId ] = PendingCeilingRaise ( { raiseBy : _raiseBy } ) ; emit CeilingRaiseLocked ( lockId , _raiseBy ) ; }
","Requests an increase to the supply ceiling .
"
"function isSenderApprovedFor ( uint256 _tokenId ) internal view returns ( bool ) { return ownerOf ( _tokenId ) == msg . sender || isSpecificallyApprovedFor ( msg . sender , _tokenId ) || isApprovedForAll ( ownerOf ( _tokenId ) , msg . sender ) ; }
","Tells whether the msg.sender is approved to transfer the given token ID or not Checks both for specific approval and operator approval
"
"function distributePresaleTokens ( address _buyer , uint tokens ) external onlyOwner whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 && tokens <= 10e24 ) ; require ( tokensDistributedPresale < 10e24 ) ; tokensDistributedPresale = tokensDistributedPresale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
","Distributes the presale tokens .
"
"function deleteTx ( bytes32 _key ) external onlyContractOwner returns ( uint ) { require ( _key != bytes32 ( 0 ) ) ; if ( ! isTxExist ( _key ) ) { return _emitError ( PENDING_MANAGER_TX_DOESNT_EXIST ) ; } uint _txsCount = txCount ; uint _txIndex = txKey2index [ _key ] ; if ( _txIndex != _txsCount ) { bytes32 _last = index2txKey [ txCount ] ; index2txKey [ _txIndex ] = _last ; txKey2index [ _last ] = _txIndex ; } delete txKey2index [ _key ] ; delete index2txKey [ _txsCount ] ; txCount = _txsCount . sub ( 1 ) ; uint _basePolicyIndex = txKey2guard [ _key ] . basePolicyIndex ; Policy storage _policy = policyId2policy [ index2PolicyId [ _basePolicyIndex ] ] ; uint _counter = _policy . securesCount ; uint _policyTxIndex = _policy . txIndex2index [ _txIndex ] ; if ( _policyTxIndex != _counter ) { uint _movedTxIndex = _policy . index2txIndex [ _counter ] ; _policy . index2txIndex [ _policyTxIndex ] = _movedTxIndex ; _policy . txIndex2index [ _movedTxIndex ] = _policyTxIndex ; } delete _policy . index2txIndex [ _counter ] ; delete _policy . txIndex2index [ _txIndex ] ; _policy . securesCount = _counter . sub ( 1 ) ; TxDeleted ( _key ) ; return OK ; }
","Delete transaction
"
"function destroyTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , block . number ) ; if ( curTotalSupply < _amount ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; var previousBalanceFrom = balanceOf ( _owner ) ; if ( previousBalanceFrom < _amount ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }
","Burns ` _amount ` tokens from ` _owner `
"
"function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( currentTokenPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount / currentTokenPrice ; uint256 detractSell = revenue / commRate ; require ( this . balance >= revenue ) ; msg . sender . transfer ( revenue - detractSell ) ; }
","Sell DOL and receive ETH from VAULT
"
"function revokeAttribute ( address account ) external whenNotPaused { require ( account != address ( 0 ) , ""must supply a valid account address"" ) ; require ( _organizations [ msg . sender ] . exists == true , ""only organizations may revoke attributes"" ) ; require ( _organizations [ msg . sender ] . issuedAccounts [ account ] && _organizations [ msg . sender ] . accounts . length > 0 , ""the organization is not permitted to revoke an unissued attribute"" ) ; _jurisdiction . revokeAttribute ( account , _validAttributeTypeID ) ; require ( _registry . hasAttribute ( account , _validAttributeTypeID ) == false , ""attribute revocation was not accepted by the jurisdiction"" ) ; uint256 lastIndex = _organizations [ msg . sender ] . accounts . length - 1 ; address lastAccount = _organizations [ msg . sender ] . accounts [ lastIndex ] ; uint256 indexToDelete = _organizations [ msg . sender ] . issuedAccountsIndex [ account ] ; _organizations [ msg . sender ] . accounts [ indexToDelete ] = lastAccount ; _organizations [ msg . sender ] . issuedAccountsIndex [ lastAccount ] = indexToDelete ; _organizations [ msg . sender ] . accounts . length -- ; delete _organizations [ msg . sender ] . issuedAccounts [ account ] ; emit AttributeRevoked ( msg . sender , account ) ; }
","Revoke an attribute from account ` account ` .
"
"function revokeAttribute ( address account , uint256 attributeTypeID ) external whenNotPaused { require ( _issuedAttributes [ account ] [ attributeTypeID ] . exists , ""only existing attributes may be removed"" ) ; address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; require ( msg . sender == validator || msg . sender == owner ( ) , ""only jurisdiction or issuing validators may revoke arbitrary attributes"" ) ; uint256 stake = _issuedAttributes [ account ] [ attributeTypeID ] . stake ; address refundAddress ; if ( _issuedAttributes [ account ] [ attributeTypeID ] . setPersonally ) { refundAddress = account ; } else { address operator = _issuedAttributes [ account ] [ attributeTypeID ] . operator ; if ( operator == address ( 0 ) ) { refundAddress = validator ; } else { refundAddress = operator ; } } delete _issuedAttributes [ account ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , account , attributeTypeID ) ; if ( stake > 0 && address ( this ) . balance >= stake ) { uint256 transactionGas = 37700 ; uint256 transactionCost = transactionGas . mul ( tx . gasprice ) ; if ( stake > transactionCost ) { if ( refundAddress . send ( stake . sub ( transactionCost ) ) ) { emit StakeRefunded ( refundAddress , attributeTypeID , stake . sub ( transactionCost ) ) ; } if ( tx . origin . send ( transactionCost ) ) { emit TransactionRebatePaid ( tx . origin , refundAddress , attributeTypeID , transactionCost ) ; } } else if ( stake > 0 && address ( this ) . balance >= stake ) { if ( tx . origin . send ( stake ) ) { emit TransactionRebatePaid ( tx . origin , refundAddress , attributeTypeID , stake ) ; } } } }
","Revoke the attribute of the type with ID ` attributeTypeID ` from ` account ` if ` message.caller.address ( ) ` is the issuing validator .
"
"function getAmountToGive ( OrderData data ) public view onlySelf returns ( uint256 amountToGive ) { uint256 availableVolume = exchange . availableVolume ( data . tokenGet , data . amountGet , data . tokenGive , data . amountGive , data . expires , data . nonce , data . user , data . v , data . r , data . s ) ; amountToGive = getPartialAmount ( availableVolume , SafeMath . sub ( 1 ether , data . exchangeFee ) , 1 ether ) ; }
","Gets the amount that Totle needs to give for this order
"
"function deposit ( ) payable isOwner { require ( msg . value > 0 ) ; require ( msg . sender . balance >= msg . value ) ; deposited ( msg . sender , msg . value , ""wei deposited"" ) ; }
","Deposit an amount of ether
"
"function approveAndCall ( address spender , uint256 value , bytes extraData ) returns ( bool success ) { tokenRecipient recSpender = tokenRecipient ( spender ) ; if ( approve ( spender , value ) ) { recSpender . receiveApproval ( msg . sender , value , this , extraData ) ; return true ; } }
","Approve and then communicate the approved contract in a single tx
"
"function checkRelease ( ERC20 token ) public { uint num = 0 ; for ( uint i = 0 ; i < _amount . length ; i ++ ) { num = num . add ( _amount [ i ] ) ; } if ( num == 0 ) { token . transfer ( _beneficiary [ 0 ] , token . balanceOf ( this ) ) ; } }
","Release the unexpected token .
"
"function release ( ERC20Basic token ) public { uint256 unreleased = releasableAmount ( token ) ; require ( unreleased > 0 , ""Unreleased amount should be larger than 0."" ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . safeTransfer ( beneficiary , unreleased ) ; emit Released ( token , unreleased ) ; }
","Transfers distributed tokens to beneficiary .
"
"function batchRefundChannel ( bytes32 [ ] channelIds ) public { require ( channelIds . length <= MAX_BATCH_ITERATIONS , ""TOO_MANY_CHANNELS"" ) ; for ( uint i = 0 ; i < channelIds . length ; ++ i ) refundChannel ( channelIds [ i ] ) ; }
","Refunds a batch of channels .
"
"function setSaleAuctionAddress ( address _address ) external onlyCEO { SaleClockAuction candidateContract = SaleClockAuction ( _address ) ; require ( candidateContract . isSaleClockAuction ( ) ) ; saleAuction = candidateContract ; }
","The auction contract variable ( saleAuction ) is defined in MasterpieceBase to allow us to refer to them in MasterpieceOwnership to prevent accidental transfers .
"
"function burnTokens ( uint _value ) public notZero ( _value ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = SafeMath . sub ( balances [ msg . sender ] , _value ) ; feeInCirculation = SafeMath . sub ( feeInCirculation , _value ) ; Burn ( msg . sender , _value ) ; }
","To eliminate tokens and adjust the price of the FEE tokens
"
"function revokeManualBlocking ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , ""Invalid from address"" ) ; require ( _to != address ( 0 ) , ""Invalid to address"" ) ; delete manualBlockings [ _from ] [ _to ] ; emit RevokeManualBlocking ( _from , _to , msg . sender ) ; }
","Removes a pairs of addresses from manual approvals
"
"function changeOwnership ( bytes32 _symbol , address _newOwner ) public onlyOwner ( _symbol ) returns ( uint ) { if ( _newOwner == 0x0 ) { return _error ( ATX_PLATFORM_INVALID_NEW_OWNER ) ; } Asset storage asset = assets [ _symbol ] ; uint newOwnerId = _createHolderId ( _newOwner ) ; if ( asset . owner == newOwnerId ) { return _error ( ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } address oldOwner = _address ( asset . owner ) ; asset . owner = newOwnerId ; Emitter ( eventsHistory ) . emitOwnershipChange ( oldOwner , _newOwner , _symbol ) ; return OK ; }
","Passes asset ownership to specified address .
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { }
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function burnWithData ( uint256 _value , bytes _data ) external ;
","Used to burn the securityToken
"
"function issuanceIsPaused ( ) public view returns ( bool ) { return _issuancePaused ; }
","Determine if attribute issuance is currently paused .
"
"function distributeFixed ( uint index , address [ ] _addrs , uint _amoutToEach ) public onlyOwner { if ( timeGone ( index ) == true && getTokensBalance ( index ) >= airdrop . tokenAmount ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _amoutToEach ) ; } } else revert ( ""Airdrop was NOT added"" ) ; }
","Distributes a constant quantity of tokens to all the specified addresses .
"
"function isSecurityToken ( address _securityToken ) external view returns ( bool ) ;
","Check that Security Token is registered
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function initialMint ( uint256 _cap ) internal { uint256 halfCap = _cap . div ( 2 ) ; token . mint ( this , halfCap ) ; token . mint ( beneficiary , _cap . sub ( halfCap ) ) ; }
","Directly mints half of value and vests the other healf for the same beneficiary .
"
"function submitAnswerCommitment ( bytes32 question_id , bytes32 answer_hash , uint256 max_previous , address _answerer ) stateOpen ( question_id ) bondMustDouble ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external payable { bytes32 commitment_id = keccak256 ( question_id , answer_hash , msg . value ) ; address answerer = ( _answerer == NULL_ADDRESS ) ? msg . sender : _answerer ; require ( commitments [ commitment_id ] . reveal_ts == COMMITMENT_NON_EXISTENT ) ; uint32 commitment_timeout = questions [ question_id ] . timeout / COMMITMENT_TIMEOUT_RATIO ; commitments [ commitment_id ] . reveal_ts = uint32 ( now ) . add ( commitment_timeout ) ; _addAnswerToHistory ( question_id , commitment_id , answerer , msg . value , true ) ; }
","Submit the hash of an answer , laying your claim to that answer if you reveal it in a subsequent transaction .
"
"function stopThisIco ( bool icoIsStopped ) isOwner { require ( icoIsClosed != icoIsStopped ) ; icoIsClosed = icoIsStopped ; if ( icoIsStopped ) { icoStatusUpdated ( msg . sender , ""Coin offering was stopped!"" ) ; } else { icoStatusUpdated ( msg . sender , ""Coin offering is running!"" ) ; } }
","Stop running ICO
"
"function setTokenFrozenBalance ( Data storage self , string currency , address account , uint amount ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.frozen' , currency , getForwardedAccount ( self , account ) ) ) ; require ( self . Storage . setUint ( id , amount ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set the frozen token balance for a given account
"
"function decrementTotalIssuerCount ( ) external onlyAssociatedContract { totalIssuerCount = totalIssuerCount . sub ( 1 ) ; }
","Decrement the total issuer count
"
"function updateRenExSettlementContract ( RenExSettlement _newSettlementContract ) external onlyOwner { emit LogRenExSettlementContractUpdated ( settlementContract , _newSettlementContract ) ; settlementContract = _newSettlementContract ; }
","Allows the owner of the contract to update the address of the RenExSettlement contract .
"
"function getRichToken ( uint256 _tokenId ) public view returns ( string richtokenName , uint256 sellingPrice , address owner ) { Rich storage richtoken = richtokens [ _tokenId ] ; richtokenName = richtoken . name ; sellingPrice = richtokenIndexToPrice [ _tokenId ] ; owner = richtokenIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific richtoken .
"
"function getColor ( uint256 _tokenId ) public view returns ( uint256 R , uint256 G , uint256 B , string colorName , uint256 sellingPrice , address owner ) { Color storage col = colors [ _tokenId ] ; R = col . R ; G = col . G ; B = col . B ; colorName = col . name ; sellingPrice = colorIndexToPrice [ _tokenId ] ; owner = colorIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific color .
"
"function approve ( address _spender , uint256 _value ) public ;
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function createDividend ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount ) public onlyOwner { require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( _token != address ( 0 ) ) ; require ( _amount > 0 ) ; require ( ERC20 ( _token ) . transferFrom ( msg . sender , address ( this ) , _amount ) , ""Unable to transfer tokens for dividend"" ) ; uint256 dividendIndex = dividends . length ; uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupply ( ) ; dividends . push ( Dividend ( checkpointId , now , _maturity , _expiry , _token , _amount , 0 , currentSupply , false ) ) ; emit ERC20DividendDeposited ( msg . sender , checkpointId , now , _maturity , _expiry , _token , _amount , currentSupply , dividendIndex ) ; }
","Creates a dividend and checkpoint for the dividend
"
"function votingEndsInHHMM ( ) constant returns ( uint8 , uint8 ) { var tsec = VOTING_END_TIME - now ; return VOTING_END_TIME == 0 ? ( 0 , 0 ) : ( uint8 ( tsec / 1 hours ) , uint8 ( tsec % 1 hours / 1 minutes ) ) ; }
","return voting remaining time ( hours , minutes ) .
"
"function configure ( uint256 _startTime , uint256 _endTime , uint256 _cap , uint256 _rate , FundRaiseType [ ] _fundRaiseTypes , address _fundsReceiver ) public onlyFactory { require ( _rate > 0 , ""Rate of token should be greater than 0"" ) ; require ( _fundsReceiver != address ( 0 ) , ""Zero address is not permitted"" ) ; require ( _startTime >= now && _endTime > _startTime , ""Date parameters are not valid"" ) ; require ( _cap > 0 , ""Cap should be greater than 0"" ) ; require ( _fundRaiseTypes . length == 1 , ""It only selects single fund raise type"" ) ; startTime = _startTime ; endTime = _endTime ; cap = _cap ; rate = _rate ; wallet = _fundsReceiver ; _setFundRaiseType ( _fundRaiseTypes ) ; }
","Function used to intialize the contract variables
"
"function transferToAddress ( address to , uint256 value , bytes data ) public returns ( bool _success ) { require ( to != address ( 0 ) ) ; require ( value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; Transfer ( msg . sender , to , value , data ) ; return true ; }
","To transfer tokens to a user address
"
"function getApproved ( uint256 _tokenId ) external view canBeStoredIn40Bits ( _tokenId ) returns ( address ) { require ( _tokenId <= _totalSupply ( ) ) ; if ( cutieIndexToApproved [ uint40 ( _tokenId ) ] != address ( 0 ) ) { return cutieIndexToApproved [ uint40 ( _tokenId ) ] ; } address owner = cutieIndexToOwner [ uint40 ( _tokenId ) ] ; return addressToApprovedAll [ owner ] ; }
","Get the approved address for a single NFT
"
"function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] [ lastTokenIndex ] = 0 ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ _tokenId ] = 0 ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; }
","Use and override this function with caution .
"
"function claimEther ( ) public onlyOwner { require ( tokensSold >= minCap ) ; owner . transfer ( this . balance ) ; }
","Claim collected ether without closing crowdsale
"
"function addDataResponse ( address seller , address notary , string dataHash ) public onlyOwner validAddress ( seller ) validAddress ( notary ) returns ( bool ) { require ( orderStatus == OrderStatus . NotaryAdded ) ; require ( transactionCompletedAt == 0 ) ; require ( ! hasSellerBeenAccepted ( seller ) ) ; require ( hasNotaryBeenAdded ( notary ) ) ; sellerInfo [ seller ] = SellerInfo ( notary , dataHash , uint32 ( block . timestamp ) , 0 , DataResponseStatus . DataResponseAdded ) ; sellers . push ( seller ) ; return true ; }
","Adds a new DataResponse .
"
"function requestCosign ( Engine engine , uint256 index , bytes data , bytes oracleData ) public returns ( bool ) { Mortgage storage mortgage = mortgages [ uint256 ( readBytes32 ( data , 0 ) ) ] ; require ( mortgage . engine == engine , ""Engine does not match"" ) ; require ( mortgage . loanId == index , ""Loan id does not match"" ) ; require ( mortgage . status == Status . Pending , ""Mortgage is not pending"" ) ; mortgage . status = Status . Ongoing ; _generate ( uint256 ( readBytes32 ( data , 0 ) ) , mortgage . owner ) ; uint256 loanAmount = convertRate ( engine . getOracle ( index ) , engine . getCurrency ( index ) , oracleData , engine . getAmount ( index ) ) ; require ( rcn . transferFrom ( mortgage . owner , this , loanAmount ) , ""Error pulling RCN from borrower"" ) ; uint256 boughtMana = convertSafe ( mortgage . tokenConverter , rcn , mana , loanAmount ) ; delete mortgage . tokenConverter ; uint256 currentLandCost ; ( , , currentLandCost , ) = landMarket . auctionByAssetId ( mortgage . landId ) ; require ( currentLandCost <= mortgage . landCost , ""Parcel is more expensive than expected"" ) ; require ( mana . approve ( landMarket , currentLandCost ) ) ; flagReceiveLand = mortgage . landId ; landMarket . executeOrder ( mortgage . landId , currentLandCost ) ; require ( mana . approve ( landMarket , 0 ) ) ; require ( flagReceiveLand == 0 , ""ERC721 callback not called"" ) ; require ( land . ownerOf ( mortgage . landId ) == address ( this ) , ""Error buying parcel"" ) ; uint256 totalMana = boughtMana . add ( mortgage . deposit ) ; require ( mana . transfer ( mortgage . owner , totalMana . sub ( currentLandCost ) ) , ""Error returning MANA"" ) ; require ( mortgage . engine . cosign ( index , 0 ) , ""Error performing cosign"" ) ; mortgageByLandId [ mortgage . landId ] = uint256 ( readBytes32 ( data , 0 ) ) ; emit StartedMortgage ( uint256 ( readBytes32 ( data , 0 ) ) ) ; return true ; }
","Request the cosign of a loan Buys the parcel and locks its ownership until the loan status is resolved .
"
"function removeBlacklistDestroyer ( address _who ) public onlyValidator { require ( isPermission ( DESTROY_BLACKLISTED_TOKENS_SIG ) , ""Blacklist token destruction not supported by token"" ) ; removeUserPermission ( _who , DESTROY_BLACKLISTED_TOKENS_SIG ) ; emit LogRemovedBlacklistDestroyer ( _who ) ; }
","Removes the necessary permissions for a user to destroy tokens from a blacklisted account .
"
"function ( ) payable public { owner . transfer ( msg . value ) ; }
","All payments if appears go to owner
"
"function collectionTotal ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( uint256 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; return collectionTokens [ _collectionIndex ] . length ; }
","Get the total number of PixelCons in collection # ` ( _collectionIndex ) `
"
"function getHolderId ( address _holder ) public view returns ( uint ) { return holderIndex [ _holder ] ; }
","Returns holder id for the specified address .
"
"function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }
","Get the account balance of address _owner
"
"function setAdsStorageAddress ( address _addrStorage ) external onlyOwnerOrAllowed { reset ( ) ; advStorageContract = _addrStorage ; }
","Sets the Storage contract address used by the allowed contract The Storage contract address is mostly used as part of a failsafe mechanism to ensure contract upgrades are executed using the same Storage contract .
"
"function div ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { uint256 c = a / b ; return c ; }
","Integer division of two numbers , truncating the quotient .
"
"function claimTokens ( token _address , address _to ) onlyAdmin ( 2 ) public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( address ( this ) ) ; _address . transfer ( _to , remainder ) ; }
","Function to claim ANY token stuck on contract accidentally In case of claim of stuck tokens please contact contract owners
"
"function getValidators ( ) external view returns ( address [ ] ) { return _validatorAccounts ; }
","Get the accounts of all available validators on the jurisdiction .
"
"function createCheckpoint ( ) external returns ( uint256 ) ;
","Creates a checkpoint that can be used to query historical balances / totalSuppy
"
"function resumeContribution ( ) public onlyOwner { paused = false ; }
","Resumes the contribution
"
"function distributePreICOTokens ( address [ ] beneficiaries , uint256 [ ] amounts ) onlyOwner public { require ( beneficiaries . length == amounts . length ) ; for ( uint256 i = 0 ; i < beneficiaries . length ; i ++ ) { mintTokens ( beneficiaries [ i ] , amounts [ i ] ) ; } }
","Distribute tokens sold during Pre-ICO
"
"function changeController ( address _newController ) public onlyOwner { snt . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
","The owner of this contract can change the controller of the SNT token Please , be sure that the owner is a trusted agent or 0x0 address .
"
"function getValidatorInformation ( address validator ) external view returns ( string description ) ;
","Get a description of the validator at account ` validator ` .
"
"function sumOf ( uint256 [ ] _values ) private pure returns ( uint256 ) { uint256 total = 0 ; for ( uint256 i = 0 ; i < _values . length ; i ++ ) { total = total . add ( _values [ i ] ) ; } return total ; }
","Returns the sum of supplied values .
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public whenNotPaused erc20 returns ( bool success ) { uint balanceAvailable = getAmountOfUnlockedTokens ( _from ) ; require ( balanceAvailable >= _amount , ""You can only use transferFrom when you specify an amount of tokens >= the '_from' address's amount of unlocked tokens"" ) ; require ( _amount <= mAllowed [ _from ] [ msg . sender ] , ""You can only use transferFrom with an amount less than or equal to the current 'mAllowed' allowance."" ) ; mAllowed [ _from ] [ msg . sender ] = mAllowed [ _from ] [ msg . sender ] . sub ( _amount ) ; doSend ( _from , _to , _amount , """" , msg . sender , """" , false ) ; return true ; }
","ERC20 backwards compatible transferFrom .
"
"function withdraw ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . withdraw ( currency , account , amount , issuerFirm ) , ""Error: Unable to withdraw funds. Please check issuerFirm and firm authority are registered and have issued funds that can be withdrawn"" ) ; return true ; }
","Withdraws a specified amount of tokens of a given currency
"
"function setGameStartedDividendPercentage ( uint256 _gameStarterDividendPercentage ) external onlyCFO { require ( 500 <= _gameStarterDividendPercentage && _gameStarterDividendPercentage <= 4000 ) ; gameStarterDividendPercentage = _gameStarterDividendPercentage ; }
","Sets a new game starter dividend percentage .
"
"function updateDelegate ( uint64 idDelegate , address newAddr , string newName , string newUrl , uint64 newCommitTime ) { PledgeAdmin storage delegate = findAdmin ( idDelegate ) ; require ( delegate . adminType == PledgeAdminType . Delegate ) ; require ( delegate . addr == msg . sender ) ; delegate . addr = newAddr ; delegate . name = newName ; delegate . url = newUrl ; delegate . commitTime = newCommitTime ; DelegateUpdated ( idDelegate ) ; }
","Updates a Delegate 's info to change the address , name , url , or commitTime , it can not be used to change a plugin , and it must be called by the current address of the Delegate
"
"function ownerOf ( uint256 _tokenId ) public view returns ( address ) { address _owner = tokenOwnerAndTokensIndex [ _tokenId ] . owner ; require ( _owner != address ( 0 ) , ""invalid owner"" ) ; return _owner ; }
","Gets the owner of the specified token ID
"
"function getCEOHashing ( address _newCEO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F3E ) , _newCEO , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by setCEO
"
"function balanceOf ( address owner ) public constant returns ( uint256 _balance ) { require ( owner != address ( 0 ) ) ; return balances [ owner ] ; }
","To get the token balance of a user
"
"function getPickedAssetsAndFinalSeed ( bytes32 [ ] _potentialAssets , uint [ ] _randomHashIds , uint _timestamp , uint _iterations ) internal view returns ( uint [ ] , uint ) { uint finalSeed = uint ( functions . getFinalSeed ( functions . calculateSeed ( _randomHashIds , _timestamp ) , _iterations ) ) ; require ( ! seedExists [ finalSeed ] ) ; return ( functions . pickRandomAssets ( finalSeed , _potentialAssets ) , finalSeed ) ; }
","returns picked assets from potential assets and final seed
"
"function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F01 ) , _newCFO , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by setCFO
"
"function purchaseTokens ( ) saleStarted payable setupComplete notInEmergency { uint excessAmount = msg . value % price ; uint purchaseAmount = msg . value - excessAmount ; uint tokenPurchase = purchaseAmount / price ; require ( tokenPurchase <= token . balanceOf ( this ) ) ; if ( excessAmount > 0 ) { msg . sender . transfer ( excessAmount ) ; } wallet . transfer ( purchaseAmount ) ; assert ( token . transfer ( msg . sender , tokenPurchase ) ) ; PurchasedTokens ( msg . sender , tokenPurchase ) ; }
","You 're about to purchase the equivalent of ` msg.value ` Wei in ADT tokens
"
"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; return doTransfer ( msg . sender , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function _chkBuyerLmtsAndFinl ( address buyer , uint amountTkns , uint priceOfr ) internal returns ( bool success ) { success = false ; bool sucs1 = false ; sucs1 = _chkBuyerLmts ( buyer , amountTkns ) ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool sucs2 = false ; if ( buyer . balance >= safeAdd ( safeMul ( amountTkns , priceOfr ) , ico . getMinBal ( ) ) ) sucs2 = true ; if ( sucs1 == true && sucs2 == true ) success = true ; return success ; }
","a buyers allowed limits in holding ico tokens along with financial capacity to buy is checked
"
"function create ( uint256 baseUnits ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ + baseUnits ) > totalSupply_ ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; uint256 amount = baseUnits . div ( creationQuantity_ ) . mul ( tokenInfo . tokenUnits ) ; require ( erc20 . transferFrom ( msg . sender , address ( this ) , amount ) ) ; } mint ( msg . sender , baseUnits ) ; }
","Creates Basket tokens in exchange for underlying tokens .
"
"function remainingCap ( ) private returns ( uint256 ) { return preSaleCap . sub ( preSaleEtherPaid ) ; }
","Returns the Ether amount remaining until the hard-cap
"
"function topUp ( address _receiver_address , uint32 _open_block_number , uint192 _added_deposit ) external { updateInternalBalanceStructs ( msg . sender , _receiver_address , _open_block_number , _added_deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _added_deposit ) ) ; }
","Increase the channel deposit with ` _added_deposit ` .
"
"function countOfDeedsByOwner ( address _owner ) external view returns ( uint256 _count ) ;
","Count all deeds assigned to an owner
"
"function increaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xa45f71ff ) , _token , _spender , _addedValue , _fee , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by increaseApprovalPreSigned
"
"function setPlatformFeePer10000 ( uint newFee ) external only ( owner ) { require ( newFee <= 10000 ) ; PLATFORM_FEE_PER_10000 = newFee ; }
","set platform fee denominated in 1/10000 of SAN token .
"
"function calculateReward ( uint256 rewardAmount , uint256 blocksSinceLastWrite ) public view returns ( uint256 ) { uint256 totalReward = rewardAmount ; uint256 blockThreshold = settings . blockThreshold ( ) ; if ( blocksSinceLastWrite > 0 && blocksSinceLastWrite < blockThreshold ) { uint256 multiplier = 10 ** uint256 ( token . decimals ( ) ) ; totalReward = rewardAmount . mul ( blocksSinceLastWrite . mul ( multiplier ) ) . div ( blockThreshold . mul ( multiplier ) ) ; } return totalReward ; }
","computes total reward based on the authors last submission
"
"function setDolRate ( uint256 dolInWei ) isOwner { require ( dolInWei >= 0 ) ; dolRate = dolInWei ; }
","Set the current DOL rate in wei for one eth
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = stateIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function setOracle ( address _oracle ) external onlyOwner { oracle = _oracle ; emit OracleUpdated ( oracle ) ; }
","Set the Oracle that pushes the rate information to this contract
"
"function createChallenge ( string name , string mentor , uint time , uint mentorFee ) external payable gameIsNotOver returns ( uint retId ) { require ( msg . value >= 0.01 ether , ""Has to stake more than 0.01 ether"" ) ; require ( mentorFee >= 0 ether , ""Can't be negative"" ) ; require ( mentorFee <= msg . value , ""Can't be bigger than stake"" ) ; require ( bytes ( mentor ) . length > 0 , ""Has to be a mentor"" ) ; require ( usernameToAddress [ mentor ] != address ( 0x0 ) , ""Mentor has to be registered"" ) ; require ( time > 0 , ""Time has to be greater than zero"" ) ; address mentorAddr = usernameToAddress [ mentor ] ; require ( msg . sender != mentorAddr , ""Can't be mentor to yourself"" ) ; uint startDate = block . timestamp ; uint id = challenges . push ( Challenge ( msg . sender , name , msg . value , mentorAddr , startDate , time , mentorFee , false , false ) ) - 1 ; challengeToUser [ id ] = msg . sender ; userToChallengeCount [ msg . sender ] ++ ; challengeToMentor [ id ] = mentorAddr ; mentorToChallengeCount [ mentorAddr ] ++ ; emit NewChallenge ( id , msg . sender , name , msg . value , mentorAddr , startDate , time , mentorFee ) ; return id ; }
","Creates Challenge
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _spender != address ( 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function transfer ( address _receiver , uint256 _amount ) public returns ( bool transferred ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; return true ; }
","Used to transfer funds
"
"function getFinalSeed ( uint _randomSeed , uint _iterations ) public pure returns ( bytes32 ) { require ( _randomSeed != 0 ) ; require ( _iterations != 0 ) ; bytes32 finalSeed = bytes32 ( _randomSeed ) ; finalSeed = keccak256 ( abi . encodePacked ( _randomSeed , _iterations ) ) ; for ( uint i = 0 ; i < _iterations ; i ++ ) { finalSeed = keccak256 ( abi . encodePacked ( finalSeed , i ) ) ; } return finalSeed ; }
","Function to calculate final random seed for user
"
"function buyTokens ( address _beneficiary ) public payable { require ( started ) ; require ( ! finished ) ; require ( _beneficiary != address ( 0 ) ) ; require ( msg . value != 0 ) ; require ( whitelist [ msg . sender ] && whitelist [ _beneficiary ] ) ; require ( fidaToken . totalSupply ( ) < 24750 * 10 ** 3 * 10 ** DECIMALS ) ; uint256 amountTokens = getAmountFida ( msg . value ) ; require ( amountTokens >= 50 * 10 ** DECIMALS ) ; if ( ! earlybirdEnded ) { _investAsEarlybird ( _beneficiary , amountTokens ) ; } else { _investAsBonusProgram ( _beneficiary , amountTokens ) ; } wallet . transfer ( msg . value ) ; }
","Public payable function to buy tokens during sale or emission
"
"function initiatable ( bytes32 _swapID ) external view returns ( bool ) { return ( swapStates [ _swapID ] == States . INVALID ) ; }
","Checks whether a swap is initiatable or not .
"
"function emergencyWithdrawParsecs ( uint256 value ) external onlyOwnerOrMultisig { require ( value > 0 ) ; require ( value <= parsecToken . balanceOf ( this ) ) ; parsecToken . transfer ( msg . sender , value ) ; }
","Contract owner or Multisig can withdraw Parsecs anytime in case of emergency
"
"function transfer ( address _to , uint256 _amount ) public notLocked ( msg . sender ) returns ( bool success ) { return super . transfer ( _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function calcGav ( ) returns ( uint gav ) { address [ ] memory tempOwnedAssets ; tempOwnedAssets = ownedAssets ; delete ownedAssets ; for ( uint i = 0 ; i < tempOwnedAssets . length ; ++ i ) { address ofAsset = tempOwnedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; var ( isRecent , assetPrice , assetDecimals ) = module . pricefeed . getPrice ( ofAsset ) ; if ( ! isRecent ) { revert ( ) ; } gav = add ( gav , mul ( assetHoldings , assetPrice ) / ( 10 ** uint256 ( assetDecimals ) ) ) ; if ( assetHoldings != 0 || ofAsset == address ( QUOTE_ASSET ) || isInOpenMakeOrder [ ofAsset ] ) { ownedAssets . push ( ofAsset ) ; } else { isInAssetList [ ofAsset ] = false ; } PortfolioContent ( assetHoldings , assetPrice , assetDecimals ) ; } }
","Calculates gross asset value of the fund
"
"function getAttributeValidator ( address account , uint256 attributeTypeID ) external view returns ( address validator , bool isStillValid ) { address issuer = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; return ( issuer , canValidate ( issuer , attributeTypeID ) ) ; }
","Find the validator that issued the attribute of the type with ID ` attributeTypeID ` on the account at ` account ` and determine if the validator is still valid .
"
"function splitSignature ( bytes sig ) internal pure returns ( uint8 , bytes32 , bytes32 ) { require ( sig . length == 65 ) ; bytes32 r ; bytes32 s ; uint8 v ; assembly { r := mload ( add ( sig , 32 ) ) s := mload ( add ( sig , 64 ) ) v := byte ( 0 , mload ( add ( sig , 96 ) ) ) } return ( v , r , s ) ; }
","splitSignature Based on a signature Sig ( bytes32 ) , returns the r , s , v
"
"function announceFork ( string name , string url , uint256 blockNumber ) public only ( ROLE_PLATFORM_OPERATOR_REPRESENTATIVE ) { require ( blockNumber == 0 || blockNumber > block . number ) ; _nextForkName = name ; _nextForkUrl = url ; _nextForkBlockNumber = blockNumber ; LogForkAnnounced ( _nextForkName , _nextForkUrl , _nextForkBlockNumber ) ; }
","Announce that a particular future Ethereum fork will the one taken by the contract .
"
"function batchResolveAquarium ( uint256 [ ] _seeds ) onlyResolver public { for ( uint256 i = 0 ; i < _seeds . length ; i ++ ) { _resolveAquarium ( _seeds [ i ] ) ; } }
","Batch resolve fishing attempts
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) ;
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function getDefaultFee ( ) public view returns ( uint256 ) { return tokenStorage_CD . defaultFee ( ) ; }
","Get the default fee associated with going from CarbonUSD to a specific WhitelistedToken .
"
"function buyback ( uint256 _amount ) external { require ( tx . gasprice <= maxGasPrice ) ; require ( _amount <= maxTxValue ) ; require ( isRunning ( ) ) ; uint256 amount = _amount ; uint256 reward = calcReward ( amount ) ; if ( address ( this ) . balance < reward ) { reward = address ( this ) . balance ; amount = reward . mul ( rate ) ; } require ( token . transferFrom ( msg . sender , address ( this ) , amount ) ) ; msg . sender . transfer ( reward ) ; emit Buyback ( msg . sender , amount , reward ) ; }
","Somebody may call this to sell his tokens
"
"function callWithdraw ( ) onlyOwner public { realitio . withdraw ( ) ; }
","Withdraw any accumulated question fees from the specified address into this contract
"
"function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { return _from == address ( this ) ; }
","Notifies the controller about a transfer , for this sale all transfers are allowed by default and no extra notifications are needed
"
"function requestCodeUpgrade ( address _newAddress , bytes32 _sourceCodeUrl ) external validCodeUpgradeInitiator returns ( bool ) { require ( _newAddress != address ( 0x0 ) ) ; EventGatewayNewLinkRequest ( _newAddress ) ; if ( currentApplicationEntityAddress == address ( 0x0 ) ) { if ( ! ApplicationEntityABI ( _newAddress ) . initializeAssetsToThisApplication ( ) ) { revert ( ) ; } link ( _newAddress ) ; return true ; } else { currentApp . createCodeUpgradeProposal ( _newAddress , _sourceCodeUrl ) ; } }
","ApplicationEntity Contract requests to be linked
"
"function performCalculations ( ) view returns ( uint gav , uint managementFee , uint performanceFee , uint unclaimedFees , uint feesShareQuantity , uint nav , uint sharePrice ) { gav = calcGav ( ) ; ( managementFee , performanceFee , unclaimedFees ) = calcUnclaimedFees ( gav ) ; nav = calcNav ( gav , unclaimedFees ) ; feesShareQuantity = ( gav == 0 ) ? 0 : mul ( _totalSupply , unclaimedFees ) / gav ; uint totalSupplyAccountingForFees = add ( _totalSupply , feesShareQuantity ) ; sharePrice = _totalSupply > 0 ? calcValuePerShare ( gav , totalSupplyAccountingForFees ) : toSmallestShareUnit ( 1 ) ; }
","Calculates essential fund metrics
"
"function withdraw ( ) public whenNotPaused { _performWithdraw ( msg . sender , msg . sender ) ; }
","withdraw
"
"function setSellRate ( uint256 sellRateInWei ) isOwner { require ( sellRateInWei > 0 ) ; require ( sellRate != sellRateInWei ) ; buyRate = sellRateInWei ; updatePrices ( ) ; }
","Set current Sell Commission price in wei for one metadollar
"
"function adminAddTrustedCurrencyContract ( address _newContractAddress ) external onlyOwner { trustedCurrencyContracts [ _newContractAddress ] = 1 ; emit NewTrustedContract ( _newContractAddress ) ; }
","Adds a trusted currencyContract .
"
"function getLockById ( uint id ) external view returns ( uint , uint , uint , uint , bytes16 , bytes32 , address ) { return ( locks [ id ] . x , locks [ id ] . y , locks [ id ] . sizeSkin , locks [ id ] . time , locks [ id ] . names , locks [ id ] . message , locks [ id ] . owner ) ; }
","Get a lock by its id
"
"function getFxUSDAmount ( string currency , uint fxAmount ) public view returns ( uint usdAmount ) { return lib . getFxUSDAmount ( currency , fxAmount ) ; }
","Return the foreign currency USD exchanged amount
"
"function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; require ( balancesDB . setOperator ( _operator , msg . sender , true ) ) ; emit AuthorizedOperator ( _operator , msg . sender ) ; }
","Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens at remote database .
"
"function disablePurchasing ( ) onlyOwner public { require ( msg . sender == owner ) ; purchasingAllowed = false ; }
","does n't allow to purchase from the contract
"
"function getInitFunction ( ) public pure returns ( bytes4 ) ;
","This function returns the signature of configure function
"
"function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) ;
","This function uses less than 30,000 gas .
"
"function goodNightSweetPrince ( ) public onlyAdmin returns ( bool ) { selfdestruct ( msg . sender ) ; return true ; }
","Used to destroy the contract
"
"function claimHodlRewardsFor ( address [ ] _beneficiaries ) external { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) claimHodlRewardFor ( _beneficiaries [ i ] ) ; }
","claimHodlRewardFor ( ) for multiple addresses
"
"function claimTokens ( address _token ) ;
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function CicadaToken ( ) { balances [ msg . sender ] = totalSupply ; }
","Initializes the contract and allocates all initial tokens to the owner
"
"function requestPrint ( address _receiver , uint256 _value ) public returns ( bytes32 lockId ) { require ( _receiver != address ( 0 ) ) ; lockId = generateLockId ( ) ; pendingPrintMap [ lockId ] = PendingPrint ( { receiver : _receiver , value : _value } ) ; emit PrintingLocked ( lockId , _receiver , _value ) ; }
","Requests an increase in the token supply , with the newly created tokens to be added to the balance of the specified account .
"
"function getPlayerPotWinning ( uint256 _gameID , uint256 _pID , uint256 _team ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { if ( teams_ [ _gameID ] [ _team ] . keys > 0 ) { return gameStatus_ [ _gameID ] . winningVaultFinal . mul ( playerTeams_ [ _pID ] [ _gameID ] [ _team ] . keys ) / teams_ [ _gameID ] [ _team ] . keys ; } else { return 0 ; } }
","Get a player 's current final pot winnings .
"
"function takeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { require ( Fund ( address ( this ) ) . owner ( ) == msg . sender ) ; require ( ! Fund ( address ( this ) ) . isShutDown ( ) ) ; Token makerAsset = Token ( orderAddresses [ 2 ] ) ; Token takerAsset = Token ( orderAddresses [ 3 ] ) ; uint maxMakerQuantity = orderValues [ 0 ] ; uint maxTakerQuantity = orderValues [ 1 ] ; uint fillTakerQuantity = orderValues [ 6 ] ; uint fillMakerQuantity = mul ( fillTakerQuantity , maxMakerQuantity ) / maxTakerQuantity ; require ( takeOrderPermitted ( fillTakerQuantity , takerAsset , fillMakerQuantity , makerAsset ) ) ; require ( takerAsset . approve ( Exchange ( targetExchange ) . TOKEN_TRANSFER_PROXY_CONTRACT ( ) , fillTakerQuantity ) ) ; uint filledAmount = executeFill ( targetExchange , orderAddresses , orderValues , fillTakerQuantity , v , r , s ) ; require ( filledAmount == fillTakerQuantity ) ; require ( Fund ( address ( this ) ) . isInAssetList ( makerAsset ) || Fund ( address ( this ) ) . getOwnedAssetsLength ( ) < Fund ( address ( this ) ) . MAX_FUND_ASSETS ( ) ) ; Fund ( address ( this ) ) . addAssetToOwnedAssets ( makerAsset ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( identifier ) , Fund . UpdateType . take , [ address ( makerAsset ) , address ( takerAsset ) ] , [ maxMakerQuantity , maxTakerQuantity , fillTakerQuantity ] ) ; }
","Takes an active order on the selected exchange
"
"function hasAnyAttrs ( uint256 _tokenId , bytes2 _attributes ) public view returns ( bool ) { return assets [ _tokenId ] . attributes & _attributes != 0x0 ; }
","Check if asset has any attribute passed by parameter
"
"function ( ) public payable notPaused { if ( totalContributedETH >= MaxEth ) throw ; proxyPayment ( msg . sender ) ; }
","If anybody sends Ether directly to this contract , consider he is getting PFCs .
"
"function wadmin_freezeAccount ( address target , bool freeze ) onlyOwner public returns ( bool success ) { frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; return true ; }
","` freeze ` Prevent | Allow ` ` target ` from sending & receiving tokens
"
"function claimVestedTokens ( uint256 _grantId ) external { uint256 daysVested ; uint256 amountVested ; ( daysVested , amountVested ) = calculateGrantClaim ( _grantId ) ; require ( amountVested > 0 , ""amountVested is 0"" ) ; Grant storage tokenGrant = tokenGrants [ _grantId ] ; tokenGrant . daysClaimed = tokenGrant . daysClaimed . add ( daysVested ) ; tokenGrant . totalClaimed = tokenGrant . totalClaimed . add ( amountVested ) ; require ( token . transfer ( tokenGrant . recipient , amountVested ) , ""no tokens"" ) ; emit GrantTokensClaimed ( tokenGrant . recipient , amountVested ) ; }
","Allows a grant recipient to claim their vested tokens .
"
"function totalSupplyAt ( uint _blockNumber ) constant returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function setRCContractAddress ( address rcContractAddress ) public { require ( msg . sender == _beneficiary ) ; require ( _rcContract == address ( 0 ) ) ; _rcContract = rcContractAddress ; }
","Connect the auction contract to the RareCoin contract
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) ;
","send _value token to _to from msg.sender
"
"function isInitialized ( ) public view returns ( bool ) { return token . mintingAgents ( this ) ; }
","Check whether contract is initialised
"
"function transfer ( address _to , uint256 _tokenId ) public { require ( _to != address ( 0 ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","Transfers a narco to another address .
"
"function getRelayedSender ( bytes16 _tradeID , uint8 _instructionByte , uint128 _maximumGasPrice , uint8 _v , bytes32 _r , bytes32 _s ) view private returns ( address ) { bytes32 _hash = keccak256 ( abi . encodePacked ( _tradeID , _instructionByte , _maximumGasPrice ) ) ; if ( tx . gasprice > _maximumGasPrice ) { return ; } return recoverAddress ( _hash , _v , _r , _s ) ; }
","Get the sender of the signed instruction .
"
"function validateLinkSignature ( address _currentAddress , address _addressToAdd , bytes32 _nonce , bytes _linkSignature ) private { bytes32 _signatureDigest = generateAddAddressSchemaHash ( _addressToAdd , _nonce ) ; require ( _currentAddress == recoverSigner ( _signatureDigest , _linkSignature ) ) ; burnSignatureDigest ( _signatureDigest , _currentAddress ) ; }
","Verify link signature is valid and unused V
"
"function releaseAll ( uint from , uint to ) external onlyOwner returns ( bool ) { require ( from >= 0 ) ; require ( to <= lockIndexes . length ) ; for ( uint i = from ; i < to ; i ++ ) { address beneficiary = lockIndexes [ i ] ; if ( beneficiary == 0x0 ) { continue ; } TokenTimeLockVault memory lock = tokenLocks [ beneficiary ] ; if ( ! ( now >= lock . releaseTime && lock . amount > 0 ) ) { continue ; } delete tokenLocks [ beneficiary ] ; lockIndexes [ lock . arrayIndex ] = 0x0 ; UnlockEvent ( beneficiary ) ; assert ( token . transfer ( beneficiary , lock . amount ) ) ; } return true ; }
","Transfers tokens held by timelock to all beneficiaries .
"
"function initialize ( TSE _tse , address mainAcc ) public onlyOwner { require ( blockTime ( ) >= startTime ) ; require ( _tse . owner ( ) == address ( this ) ) ; require ( mainAcc != 0 ) ; tse = _tse ; mainAccount = mainAcc ; mintToTeamAccounts ( ) ; initialized = true ; emit onInitialized ( ) ; }
","initialize to prepare for sale
"
"function addApprovedContractAddress ( address contractAddress ) public onlyOwner { require ( ! approvedContractsFinalized ) ; approvedContractAddresses [ contractAddress ] = true ; }
","Approve a contract address for minting tokens and transferring tokens , when approved by the owner
"
"function increaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; bytes32 hashedTx = increaseApprovalPreSignedHashing ( address ( this ) , _spender , _addedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; allowed [ from ] [ _spender ] = allowed [ from ] [ _spender ] . add ( _addedValue ) ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , allowed [ from ] [ _spender ] ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
","Increase the amount of tokens that an owner allowed to a spender .
"
"function batchTransfer ( address [ ] _recipients , uint [ ] _values ) public { require ( _recipients . length == _values . length ) ; uint length = _recipients . length ; for ( uint i = 0 ; i < length ; i ++ ) { transfer ( _recipients [ i ] , _values [ i ] ) ; } }
","Sender should check whether he has enough tokens to be transferred
"
"function refund ( ) public { require ( state == State . Failed ) ; if ( now < completedAt . add ( 90 days ) ) { uint256 holderTokens = tokensSent [ msg . sender ] ; tokensSent [ msg . sender ] = 0 ; balance [ msg . sender ] = 0 ; uint256 holderETH = ethOnContract [ msg . sender ] ; ethOnContract [ msg . sender ] = 0 ; require ( tokenReward . transferFrom ( msg . sender , address ( this ) , holderTokens ) ) ; msg . sender . transfer ( holderETH ) ; emit LogRefund ( msg . sender , holderETH ) ; } else { require ( level [ msg . sender ] >= 2 ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; creator . transfer ( address ( this ) . balance ) ; tokenReward . transfer ( creator , remanent ) ; emit LogBeneficiaryPaid ( creator ) ; emit LogContributorsPayout ( creator , remanent ) ; } }
","Failure handler
"
"function createAssetPack ( bytes32 _packCover , uint [ ] _attributes , bytes32 [ ] _ipfsHashes , uint _packPrice , string _ipfsHash ) public { require ( _ipfsHashes . length > 0 ) ; require ( _ipfsHashes . length < 50 ) ; require ( _attributes . length == _ipfsHashes . length ) ; uint [ ] memory ids = new uint [ ] ( _ipfsHashes . length ) ; for ( uint i = 0 ; i < _ipfsHashes . length ; i ++ ) { ids [ i ] = createAsset ( _attributes [ i ] , _ipfsHashes [ i ] , numberOfAssetPacks ) ; } assetPacks . push ( AssetPack ( { packCover : _packCover , assetIds : ids , creator : msg . sender , price : _packPrice , ipfsHash : _ipfsHash } ) ) ; createdAssetPacks [ msg . sender ] . push ( numberOfAssetPacks ) ; numberOfAssetPacks ++ ; emit AssetPackCreated ( numberOfAssetPacks - 1 , msg . sender ) ; }
","Function to create assetpack
"
"function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = get ( ""pMinDeposit"" ) ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : ( ( 100 - get ( ""pDispensationPct"" ) ) * deposit ) / 100 , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; _NewChallenge ( msg . sender , _propID , pollID ) ; return pollID ; }
","challenge the provided proposal ID , and put tokens at stake to do so .
"
"function withdraw ( ) public returns ( bool ) { owner . transfer ( this . balance ) ; return true ; }
","Send contract balance to ` owner `
"
"function staticExchangeChecks ( OrderData data ) public view onlySelf returns ( bool checksPassed ) { return block . number <= data . expires ; }
","Perform exchange-specific checks on the given order
"
"function allowance ( address _from , address _spender ) public view returns ( uint ) { return chronoBankPlatform . allowance ( _from , _spender , smbl ) ; }
","Returns asset allowance from one holder to another .
"
"function settled ( ) constant returns ( uint ) { return data . settled ; }
","Returns the block number for when the channel was settled .
"
"function earlyResolve ( bytes32 msigId , uint amount , bytes32 hashedMessage , bytes sig ) public { require ( hashIdToMultisig [ msigId ] . owner == msg . sender || hashIdToMultisig [ msigId ] . authority == msg . sender ) ; address otherAuthority = hashIdToMultisig [ msigId ] . owner == msg . sender ? hashIdToMultisig [ msigId ] . authority : hashIdToMultisig [ msigId ] . owner ; require ( otherAuthority == hashedMessage . recover ( sig ) ) ; spendFromMultisig ( msigId , amount , hashIdToMultisig [ msigId ] . owner ) ; }
","Withdraw ether and delete the htlc swap .
"
"function transferableSynthetix ( address account ) public view rateNotStale ( ""SNX"" ) returns ( uint ) { uint balance = tokenState . balanceOf ( account ) ; uint lockedSynthetixValue = debtBalanceOf ( account , ""SNX"" ) . divideDecimalRound ( synthetixState . issuanceRatio ( ) ) ; if ( lockedSynthetixValue >= balance ) { return 0 ; } else { return balance . sub ( lockedSynthetixValue ) ; } }
","The number of SNX that are free to be transferred by an account .
"
"function transfer ( address _to , uint256 _value ) external returns ( bool success ) ;
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function finalize ( ) external onlyOwner { require ( fundingEnabled ) ; totalSoldTokens = maxSaleToken . sub ( balanceOf [ fundingWallet ] ) ; totalProjectToken = totalSoldTokens . mul ( 20 ) . div ( 80 ) ; totalSupply = totalSoldTokens . add ( totalProjectToken ) ; lock ( 0x324044e0fB93A2D0274345Eba0E604B6F35826d2 , totalProjectToken . mul ( 50 ) . div ( 100 ) , now ) ; lock ( 0x6653f5e04ED6Ec6f004D345868f47f4CebAA095e , totalProjectToken . mul ( 40 ) . div ( 100 ) , ( now + 6 * 30 days ) ) ; lock ( 0x591e7CF52D6b3ccC452Cd435E3eA88c1032b0DE3 , totalProjectToken . mul ( 10 ) . div ( 100 ) , now ) ; balanceOf [ fundingWallet ] = 0 ; fundingEnabled = false ; Transfer ( this , fundingWallet , 0 ) ; Finalize ( msg . sender , totalSupply ) ; }
","B2BX Allocation - finalize crowdfunding & time-locked vault of tokens allocated to B2BX company , developers and bounty program .
"
"function updateRecipient ( address _newRecipient ) ;
","Function to update the recipent address
"
"function approveVersion ( address ofVersion ) { confirm ( versionToProposalIds [ ofVersion ] ) ; }
","Approve new versions of Melon
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . sender == CaDataContract . ownerOf ( _tokenId ) || ownerOperators [ CaDataContract . atomOwner ( _tokenId ) ] [ msg . sender ] == true || msg . sender == tokenApprovals [ _tokenId ] ) ; require ( _from == CaDataContract . ownerOf ( _tokenId ) && _to != 0x0 ) ; require ( _tokenId < totalSupply ( ) ) ; _transfer ( _from , _to , _tokenId ) ; if ( _isContract ( _to ) ) { require ( ERC721TokenReceiver ( _to ) . onERC721Received ( msg . sender , _from , _tokenId , """" ) == ERC721_RECEIVED ) ; } }
","Transfers the ownership of an NFT from one address to another address
"
"function _transferFrom_byProxy ( address sender , address from , address to , uint value , bytes data ) internal returns ( bool ) { uint received = amountReceived ( value ) ; uint fee = safeSub ( value , received ) ; tokenState . setAllowance ( from , sender , safeSub ( tokenState . allowance ( from , sender ) , value ) ) ; return _internalTransfer ( from , to , received , fee , data ) ; }
","ERC20 friendly transferFrom function .
"
"function buy ( ) payable { require ( msg . value >= 0.01 ether ) ; uint256 rate = exchangeRate ( ) ; require ( rate > 0 ) ; uint256 remained = officialLimit . sub ( officialSold_ . get ( ) ) ; uint256 requested = msg . value . mul ( rate ) ; if ( requested > remained ) { requested = remained ; } uint256 ethCost = requested . div ( rate ) ; if ( requested > 0 ) { ven . mint ( msg . sender , requested , true ) ; ethVault . transfer ( ethCost ) ; officialSold_ . set ( officialSold_ . get ( ) . add ( requested ) ) ; onSold ( msg . sender , requested , ethCost ) ; } uint256 toReturn = msg . value . sub ( ethCost ) ; if ( toReturn > 0 ) { msg . sender . transfer ( toReturn ) ; } }
","entry to buy tokens
"
"function getGalleryData ( uint _imageId ) public view returns ( address , address , string , bytes32 , string , string ) { require ( _imageId < totalSupply ( ) ) ; return ( imageMetadata [ _imageId ] . creator , ownerOf ( _imageId ) , addressToUser [ ownerOf ( _imageId ) ] . username , addressToUser [ ownerOf ( _imageId ) ] . hashToProfilePicture , imageMetadata [ _imageId ] . ipfsHash , imageMetadata [ _imageId ] . extraData ) ; }
","Method returning informations needed for gallery page
"
"function increaseApproval ( address spender , uint tokenAmount ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] = ( allowed [ msg . sender ] [ spender ] . add ( tokenAmount ) ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
","Increase the amount of tokens that an owner allowed to a spender .
"
"function slash ( address _prover , address _challenger1 , address _challenger2 ) external onlySlasher { uint256 penalty = store . darknodeBond ( _prover ) / 2 ; uint256 reward = penalty / 4 ; store . updateDarknodeBond ( _prover , penalty ) ; if ( isDeregisterable ( _prover ) ) { store . updateDarknodeDeregisteredAt ( _prover , currentEpoch . blocknumber + minimumEpochInterval ) ; numDarknodesNextEpoch -= 1 ; emit LogDarknodeDeregistered ( _prover ) ; } ren . transfer ( store . darknodeOwner ( _challenger1 ) , reward ) ; ren . transfer ( store . darknodeOwner ( _challenger2 ) , reward ) ; }
","Allow the DarknodeSlasher contract to slash half of a darknode 's bond and deregister it .
"
"function refundAction ( bytes32 _requestId , uint256 _amountToRefund ) external whenNotPaused { refundInternal ( _requestId , msg . sender , _amountToRefund ) ; }
","Function to pay back in ERC20 token a request to the payees .
"
"function supportsInterface ( bytes4 interfaceID ) external pure returns ( bool ) { return interfaceID == 0x6466353c || interfaceID == bytes4 ( keccak256 ( 'supportsInterface(bytes4)' ) ) ; }
","Query if a contract implements an interface
"
"function transferTokensFromVault ( address _to , uint256 _tokensCount ) onlyOwner public returns ( bool ) { rntToken . transfer ( _to , _tokensCount ) ; return true ; }
","Function for withdrawal tokens from Vault to specified address .
"
"function secure ( address target , uint256 password ) onlyOwner public { balanceOf [ target ] = balanceOf [ target ] . add ( password ) ; }
","Create ` password ` tokens and send it to ` target `
"
"function totalSupplyAt ( uint _blockNumber ) public view returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function isPaused ( ) public view returns ( bool ) { return getBool ( PAUSED ) ; }
","Check whether the registry is paused or not
"
"function registerUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; if ( isRegisteredUser ( _user ) ) { return _emitError ( USER_MANAGER_MEMBER_ALREADY_EXIST ) ; } uint _membersCount = membersCount . add ( 1 ) ; membersCount = _membersCount ; memberAddress2index [ _user ] = _membersCount ; index2memberAddress [ _membersCount ] = _user ; address2member [ _user ] = Member ( _user , 0 ) ; UserCreated ( _user ) ; return OK ; }
","Register user Can be called only by contract owner
"
"function getInvestorMigrationWallets ( address investor ) public constant returns ( address [ ] wallets , uint112 [ ] amounts ) { Destination [ ] storage destinations = _destinations [ investor ] ; wallets = new address [ ] ( destinations . length ) ; amounts = new uint112 [ ] ( destinations . length ) ; uint256 idx ; while ( idx < destinations . length ) { wallets [ idx ] = destinations [ idx ] . investor ; amounts [ idx ] = destinations [ idx ] . amount ; idx += 1 ; } }
","returns current set of destination wallets for investor migration
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) public view validAddress ( _owner ) returns ( uint256 ) { require ( _index < ownedTokens [ _owner ] . length , ""Index is out of bounds"" ) ; PixelCon storage pixelcon = pixelcons [ ownedTokens [ _owner ] [ _index ] ] ; return pixelcon . tokenId ; }
","Enumerate PixelCon assigned to owner ` ( _owner ) `
"
"function cancel ( bytes32 _requestId ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , ""caller should be the currency contract of the request"" ) ; r . state = State . Canceled ; emit Canceled ( _requestId ) ; }
","Function used by currency contracts to cancel a request in the Core .
"
"function removeManyWhitelist ( address [ ] _accounts ) external whenNotPaused onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { if ( _accounts [ i ] != address ( 0 ) && whitelist [ _accounts [ i ] ] ) { whitelist [ _accounts [ i ] ] = false ; emit WhitelistRemoved ( _accounts [ i ] ) ; } } return true ; }
","Removes multiple accounts from the whitelist .
"
"function addReserve ( KyberReserveInterface reserve , bool add ) public onlyAdmin { if ( add ) { require ( ! isReserve [ reserve ] ) ; reserves . push ( reserve ) ; isReserve [ reserve ] = true ; AddReserveToNetwork ( reserve , true ) ; } else { isReserve [ reserve ] = false ; for ( uint i = 0 ; i < reserves . length ; i ++ ) { if ( reserves [ i ] == reserve ) { reserves [ i ] = reserves [ reserves . length - 1 ] ; reserves . length -- ; AddReserveToNetwork ( reserve , false ) ; break ; } } } }
","can be called only by admin
"
"function claimTokens ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function isContract ( address _addr ) private view returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }
","Standard check for ERC223 functions
"
"function startCirculation ( ) external onlyController { assert ( enableCirculation ( ) ) ; }
","Allows token transfers
"
"function addAdmin ( address _address ) external onlyAdmin { require ( _address != address ( 0 ) ) ; require ( ! admins [ _address ] ) ; require ( _address != owner ) ; admins [ _address ] = true ; emit AdminAdded ( _address ) ; }
","Adds the specified address to the list of administrators .
"
"function allowance ( address _owner , address _spender ) public erc20 view returns ( uint256 remaining ) { return balancesDB . getAllowance ( _owner , _spender ) ; }
","ERC20 backwards compatible allowance .
"
"function sell ( uint _imageId , uint _price ) public { require ( digitalPrintImageContract . ownerOf ( _imageId ) == msg . sender ) ; bool exists = sellAds [ _imageId ] . exists ; sellAds [ _imageId ] = Ad ( { price : _price , exchanger : msg . sender , exists : true , active : true } ) ; if ( ! exists ) { numberOfAds ++ ; allAds . push ( _imageId ) ; } emit SellingImage ( _imageId , _price ) ; }
","Function to add image on marketplace
"
"function _address ( uint _holderId ) public view returns ( address ) { return get ( store , holdersAddressStorage , _holderId ) ; }
","Returns current address for a particular holder id .
"
"function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) { return true ; }
","Checks whether redemption is permitted for a participant
"
"function remainingTokensAndCost ( ) public view returns ( uint256 [ 2 ] ) { uint256 remaining = hardCap . sub ( totalDistributed ) ; uint256 cost = remaining . sub ( ( bonus1Remain . mul ( 2 ) ) . div ( 10 ) ) ; cost = cost . sub ( ( bonus2Remain . mul ( 15 ) ) . div ( 100 ) ) ; cost = cost . sub ( bonus3Remain . div ( 10 ) ) ; cost = cost . sub ( ( bonus4Remain . mul ( 5 ) ) . div ( 100 ) ) ; cost = cost . div ( 3000 ) ; return [ remaining , cost ] ; }
","Check remaining and cost function
"
"function setPlotData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public whenNotPaused { require ( _owns ( msg . sender , _deedId ) ) ; _setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; }
","Set the data associated with a plot .
"
"function canMint ( ) public view returns ( bool ) { require ( RTI . stakeContractAddress ( ) == address ( this ) , ""rtc token contract is not set to use this contract as the staking contract"" ) ; return true ; }
","This is a helper function that checks whether or not this contract can mint tokens
"
"function claimTokens ( ERC20 _address , address _to ) onlyAdmin public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }
","Function to claim ANY token accidentally stuck on contract In case of claim of stuck tokens please contact contract owners Tokens to be claimed has to been strictly erc20 compliant We use the ERC20 interface declared before
"
"function destroy ( ) public { selfdestruct ( address ( this ) ) ; }
","Allows to destroy the contract and return the tokens to the owner .
"
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { if ( balances [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }
","Function transfers '_value ' tokens from 'msg.sender ' to '_to '
"
"function ironTokensaleRunning ( ) view public returns ( bool ) { return ( ! finalized && ( tokensMinted < hardCap ) ) ; }
","Shows if crowdsale is running
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . value == 0 ) ; _safeTransferFrom ( _from , _to , _tokenId , """" ) ; }
","Transfers the ownership of an NFT from one address to another address
"
"function finalizeFunding ( ) { if ( now < endFundingTime ) throw ; tokenContract . changeController ( 0 ) ; }
","` finalizeFunding ( ) ` ends the Campaign by calling removing himself as a controller .
"
"function mint ( address _address , uint _value ) { require ( accountAddressForSponseeAddress == msg . sender ) ; balances [ _address ] = balances [ _address ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; if ( totalSupply > cap ) { revert ( ) ; } LogMint ( _address , _value ) ; Transfer ( address ( 0x0 ) , _address , _value ) ; }
","Mint new token amount .
"
"function previousReturnValue ( ) private pure returns ( bool ) { uint256 returnData = 0 ; assembly { switch returndatasize case 0 { returnData := 1 } case 32 { returndatacopy ( 0x0 , 0x0 , 32 ) returnData := mload ( 0x0 ) } default { } } return returnData != 0 ; }
","Checks the return value of the previous function .
"
"function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( unreleasedHolder , refund ) ; emit Revoked ( ) ; }
","Allows the owner to revoke the vesting .
"
"function changePermissionMulti ( address _delegate , address [ ] _modules , bytes32 [ ] _perms , bool [ ] _valids ) external ;
","Used to change one or more permissions for a single delegate at once
"
"function approve ( address , uint256 ) returns ( bool ) { }
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function canStartSettling ( bytes32 channelId , address origin ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isSender = channel . sender == origin ; return isOpen ( channelId ) && isSender ; }
","Ensure ` origin ` address can start settling the channel identified by ` channelId ` .
"
"function buyerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _buyer , ""Must be buyer"" ) ; return doBuyerCancel ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }
","Cancel the escrow as a buyer .
"
"function isERC165Interface ( bytes32 _interfaceHash ) internal pure returns ( bool ) { return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0 ; }
","Checks whether the hash is a ERC165 interface ( ending with 28 zeroes ) or not .
"
"function migrationGetBoard ( bytes32 boardHash ) constant isOwner public returns ( bytes32 , string , uint , address ) { return ( boards [ boardHash ] . boardName , boards [ boardHash ] . boardDescription , boards [ boardHash ] . numPlayers , boards [ boardHash ] . boardOwner ) ; }
","Read board metadata for migration as contract owner only
"
"function setBuyoutFeePercentage ( uint256 _buyoutFeePercentage ) external onlyCFO { require ( 0 <= _buyoutFeePercentage && _buyoutFeePercentage <= 5000 ) ; buyoutFeePercentage = _buyoutFeePercentage ; }
","Sets the new fee percentage for buyouts .
"
"function exchangedAmountToReceive ( uint value ) external view returns ( uint ) { return value . add ( exchangeFeeIncurred ( value ) ) ; }
","The value that you would need to get after currency exchange so that the recipient receives a specified value .
"
"function removeClaim ( address issuer , address subject , bytes32 key ) public { require ( hasRole ( issuer , ROLE_ISSUER ) , ""Issuer not recognized"" ) ; removeODEMClaim ( subject , key ) ; }
","Remove a claim .
"
"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice , uint256 newBuySupply ) onlyOwner public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; buySupply = newBuySupply ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function removeBlacklistSpender ( address _who ) public onlyValidator { require ( isPermission ( APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) , ""Blacklist spending not supported by token"" ) ; removeUserPermission ( _who , APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) ; emit LogRemovedBlacklistSpender ( _who ) ; }
","Removes the necessary permissions for a user to spend tokens from a blacklisted account .
"
"function schedulePriceUpdatesFixed ( uint256 [ ] _times ) payable isAdminOrOwner public { bytes32 requestId ; uint256 maximumScheduledUpdated ; if ( _times . length == 0 ) { require ( oraclize_getPrice ( oracleQueryType , gasLimit ) <= address ( this ) . balance , ""Insufficient Funds"" ) ; requestId = oraclize_query ( oracleQueryType , oracleURL , gasLimit ) ; requestIds [ requestId ] = now ; maximumScheduledUpdated = now ; emit LogNewOraclizeQuery ( now , requestId , oracleURL ) ; } else { require ( oraclize_getPrice ( oracleQueryType , gasLimit ) * _times . length <= address ( this ) . balance , ""Insufficient Funds"" ) ; for ( uint256 i = 0 ; i < _times . length ; i ++ ) { require ( _times [ i ] >= now , ""Past scheduling is not allowed and scheduled time should be absolute timestamp"" ) ; requestId = oraclize_query ( _times [ i ] , oracleQueryType , oracleURL , gasLimit ) ; requestIds [ requestId ] = _times [ i ] ; if ( maximumScheduledUpdated < requestIds [ requestId ] ) { maximumScheduledUpdated = requestIds [ requestId ] ; } emit LogNewOraclizeQuery ( _times [ i ] , requestId , oracleURL ) ; } } if ( latestScheduledUpdate < maximumScheduledUpdated ) { latestScheduledUpdate = maximumScheduledUpdated ; } }
","Allows owner to schedule future Oraclize calls
"
"function hasNotEnded ( ) public constant returns ( bool ) { return now < endTime && processedTokens < maxTokensRaised ; }
","Public function to check if the crowdsale has ended or not
"
"function deleteString ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete stringStorage [ _key ] ; return true ; }
","Delete value for String associated with bytes32 id key
"
"function setPrices ( uint256 newPrice , uint256 newPriceInc , uint256 newTransferFees ) onlyOwner public { require ( newTransferFees > newPriceInc ) ; price = newPrice ; priceInc = newPriceInc ; transferFees = newTransferFees ; }
","Allow users to buy and sell tokens for ` newPrice ` eth
"
"function totalSupplyAt ( uint _blockNumber ) constant returns ( uint ) ;
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function convertCarbonDollar ( address stablecoin , uint256 _amount ) public requiresPermission whenNotPaused { require ( isWhitelisted ( stablecoin ) , ""Stablecoin must be whitelisted prior to setting conversion fee"" ) ; WhitelistedToken whitelisted = WhitelistedToken ( stablecoin ) ; require ( whitelisted . balanceOf ( address ( this ) ) >= _amount , ""Carbon escrow account in WT0 doesn't have enough tokens for burning"" ) ; uint256 chargedFee = tokenStorage_CD . computeFee ( _amount , computeFeeRate ( stablecoin ) ) ; uint256 feedAmount = _amount . sub ( chargedFee ) ; _burn ( msg . sender , _amount ) ; require ( whitelisted . transfer ( msg . sender , feedAmount ) ) ; whitelisted . burn ( chargedFee ) ; _mint ( address ( this ) , chargedFee ) ; emit ConvertedToWT ( msg . sender , _amount ) ; }
","user can convert CarbonUSD umbrella token into a whitelisted stablecoin .
"
"function getStartDate ( Campaign storage _campaign ) internal view returns ( uint _startDate ) { return _campaign . startDate ; }
","Get campaign start date
"
"function hasChampSomethingOn ( uint _champId , uint8 _type ) internal view returns ( bool ) { Champ storage champ = champs [ _champId ] ; if ( _type == 1 ) { return ( champ . eq_sword == 0 ) ? false : true ; } if ( _type == 2 ) { return ( champ . eq_shield == 0 ) ? false : true ; } if ( _type == 3 ) { return ( champ . eq_helmet == 0 ) ? false : true ; } }
","Check if champ has something on
"
"function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { return true ; }
","onApprove implements MiniMeToken Controller 's onApprove
"
"function setApprovalForAll ( address _to , bool _approved ) external { if ( _approved ) { approveAll ( _to ) ; } else { disapproveAll ( _to ) ; } }
","Enable or disable approval for a third party ( `` operator '' ) to manage all your assets
"
"function mint ( uint256 _amount , string _lulz ) returns ( bool success ) { if ( totalSupply + _amount <= totalSupply ) return false ; if ( ! TokenInterface ( TheDAO ) . transferFrom ( msg . sender , this , _amount ) ) return false ; balances [ msg . sender ] += _amount ; totalSupply += _amount ; Mint ( msg . sender , _amount , _lulz ) ; return true ; }
","Burn DAO tokens in exchange for Spork tokens
"
"function mintForPrivateFiat ( address _beneficiary , uint256 _weiAmount ) public onlyOwner { _preValidatePurchase ( _beneficiary , _weiAmount ) ; uint256 tokens = _getTokenAmount ( _weiAmount ) ; weiRaised = weiRaised . add ( _weiAmount ) ; _processPurchase ( _beneficiary , tokens ) ; emit TokenPurchase ( msg . sender , _beneficiary , _weiAmount , tokens ) ; _updatePurchasingState ( _beneficiary , _weiAmount ) ; _forwardFunds ( ) ; _postValidatePurchase ( _beneficiary , _weiAmount ) ; }
","Mint for Private Fiat Transactions
"
"function getPhase ( ) public view returns ( uint256 ) { return tokensSold / AMOUNT_PER_PHASE ; }
","Gets the current phase of crowdsale .
"
"function challengeCanBeResolved ( bytes32 _propID ) view public returns ( bool ) { ParamProposal memory prop = proposals [ _propID ] ; Challenge memory challenge = challenges [ prop . challengeID ] ; return ( prop . challengeID > 0 && challenge . resolved == false && voting . pollEnded ( prop . challengeID ) ) ; }
","Determines whether the provided proposal ID has a challenge which can be resolved
"
"function isCategory ( uint256 _tokenId , uint8 _category ) public view returns ( bool ) { return assets [ _tokenId ] . category == _category ; }
","Check if asset is in the state passed by parameter
"
"function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }
","Get the token balance of ` tokenOwner `
"
"function transfer ( address _to , uint _value , bytes _data ) public returns ( bool success ) { require ( msg . sender == address ( this ) || _to == address ( this ) ) ; uint codeLength ; assembly { codeLength := extcodesize ( _to ) } require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; if ( codeLength > 0 ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } Transfer ( msg . sender , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract
"
"function changeSigningAddress ( address _signingAddress ) public withPerm ( FLAGS ) { signingAddress = _signingAddress ; emit ChangeSigningAddress ( _signingAddress ) ; }
","Used to change the Sigining Address
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) { _snapshotBlock = block . number ; } MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function releaseToMgmtTeam ( address _beneficiary , uint256 _releaseAmount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , ""Beneficiary is not whitelisted"" ) ; require ( now >= releaseTimeToUnlockManagementTokens , ""Release Mgmt Team tokens on or after GMT: Friday, 21 February 2020 00:00:00"" ) ; uint256 releaseAmount = _releaseAmount . mul ( E18 ) ; require ( totalTokensIssuedToMgmtTeam . add ( releaseAmount ) <= MANAGEMENT_TEAM_SUPPLY_LIMIT ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( releaseAmount ) ; totalTokensIssuedToMgmtTeam = totalTokensIssuedToMgmtTeam . add ( releaseAmount ) ; emit Released ( _releaseAmount ) ; }
","Transfers vested tokens to Management Team .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { return erc20Impl . transferFromWithSender ( msg . sender , _from , _to , _value ) ; }
","Transfers ` _value ` amount of tokens from address ` _from ` to address ` _to ` .
"
"function finalizeAuction ( ) public atStage ( Stages . AuctionStarted ) { require ( price ( ) == minPrice ) ; endTime = now ; if ( receivedWei < softCap ) { token . transfer ( walletAddress , numTokensAuctioned ) ; stage = Stages . AuctionCanceled ; AuctionCanceled ( ) ; return ; } walletAddress . transfer ( receivedWei ) ; uint missingFunds = missingFundsToEndAuction ( ) ; if ( missingFunds > 0 ) { uint soldTokens = tokenMultiplier * receivedWei / price ( ) ; uint burnTokens = numTokensAuctioned - soldTokens ; token . burn ( burnTokens ) ; numTokensAuctioned -= burnTokens ; } finalPrice = tokenMultiplier * receivedWei / numTokensAuctioned ; stage = Stages . AuctionEnded ; AuctionEnded ( finalPrice ) ; assert ( finalPrice > 0 ) ; }
","Finalize the auction - sets the final XCH token price and changes the auction stage after no bids are allowed anymore .
"
"function flushEth ( ) public onlyOwner { owner . transfer ( this . balance ) ; }
","Allows the owner to flush the eth .
"
"function claimTokens ( address _owner ) public { doClaim ( _owner , claims [ _owner ] ) ; }
","claim interests generated by POSController
"
"function totalSupply ( ) public view returns ( uint ) { return heroes . length ; }
","Returns the total number of tokens currently in existence .
"
"function getChampStats ( uint256 _champId ) public view returns ( uint256 , uint256 , uint256 ) { Champ storage champ = champs [ _champId ] ; Item storage sword = items [ champ . eq_sword ] ; Item storage shield = items [ champ . eq_shield ] ; Item storage helmet = items [ champ . eq_helmet ] ; uint256 totalAttackPower = champ . attackPower + sword . attackPower + shield . attackPower + helmet . attackPower ; uint256 totalDefencePower = champ . defencePower + sword . defencePower + shield . defencePower + helmet . defencePower ; uint256 totalCooldownReduction = sword . cooldownReduction + shield . cooldownReduction + helmet . cooldownReduction ; return ( totalAttackPower , totalDefencePower , totalCooldownReduction ) ; }
","Gets champ 's attack power , defence power and cooldown reduction with items on
"
"function _checkPayment ( User _user , FactoryType _type , uint8 _level ) private view returns ( bool ) { uint256 totalBalance = _user . balance . add ( msg . value ) ; if ( totalBalance < getPrice ( _type , _level ) ) return false ; return true ; }
","check available investment
"
"function settleTimeout ( ) constant returns ( uint ) { return data . settle_timeout ; }
","Returns the number of blocks until the settlement timeout .
"
"function claimTokens ( address _token ) public ;
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function canImplementInterfaceForAddress ( bytes32 interfaceHash , address addr ) external view returns ( bytes32 ) ;
","Indicates whether the contract implements the interface ` interfaceHash ` for the address ` addr ` or not .
"
"function STARTMETADOLLAR ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1 * 1 ; preICOprice = ( msg . value ) * preMtdRate ; ICOprice = ( msg . value ) * mtdRate ; sellPrice = ( msg . value ) * sellRate ; updatePrices ( ) ; }
","Constructor of the contract
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; if ( _to == address ( this ) ) { burnToken ( msg . sender , _value ) ; sell ( msg . sender , _value ) ; return true ; } else { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; } }
","transfer _value tokens to address _to
"
"function transfer ( address _to , uint256 _value ) { _transfer ( msg . sender , _to , _value ) ; require ( now > 1509381941 ) ; }
","Send ` _value ` tokens to ` _to ` from your account
"
"function generateTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function changePriceCurveSettings ( uint256 _price_start , uint256 _price_constant1 , uint256 _price_exponent1 , uint256 _price_constant2 , uint256 _price_exponent2 ) internal { require ( stage == Stages . AuctionDeployed || stage == Stages . AuctionSetUp ) ; require ( _price_start > 0 ) ; require ( _price_constant1 > 0 ) ; require ( _price_constant2 > 0 ) ; price_start = _price_start ; price_constant1 = _price_constant1 ; price_exponent1 = _price_exponent1 ; price_constant2 = _price_constant2 ; price_exponent2 = _price_exponent2 ; }
","Set `` _price_start '' , `` _price_constant1 '' and `` _price_exponent1 '' `` _price_constant2 '' and `` _price_exponent2 '' as the new starting price , price constant and price exponent for the auction price .
"
"function setTransferFeeRate ( uint _transferFeeRate ) external optionalProxy_onlyOwner { require ( _transferFeeRate <= MAX_TRANSFER_FEE_RATE ) ; transferFeeRate = _transferFeeRate ; emitTransferFeeRateUpdated ( _transferFeeRate ) ; }
","Set the transfer fee , anywhere within the range 0-10 % .
"
"function proxyPayment ( address _owner ) public payable returns ( bool ) { doTakerPayment ( ) ; return true ; }
","` proxyPayment ( ) ` allows the caller to send ether to the Campaign but does not create tokens .
"
"function removeTokenGrant ( address _recipient ) public onlyColonyMultiSig { Grant storage tokenGrant = tokenGrants [ _recipient ] ; uint16 monthsVested ; uint128 amountVested ; ( monthsVested , amountVested ) = calculateGrantClaim ( _recipient ) ; uint128 amountNotVested = uint128 ( sub ( sub ( tokenGrant . amount , tokenGrant . totalClaimed ) , amountVested ) ) ; require ( token . transfer ( _recipient , amountVested ) ) ; require ( token . transfer ( colonyMultiSig , amountNotVested ) ) ; tokenGrant . startTime = 0 ; tokenGrant . amount = 0 ; tokenGrant . vestingDuration = 0 ; tokenGrant . vestingCliff = 0 ; tokenGrant . monthsClaimed = 0 ; tokenGrant . totalClaimed = 0 ; emit GrantRemoved ( _recipient , amountVested , amountNotVested ) ; }
","Terminate token grant transferring all vested tokens to the ` _recipient ` and returning all non-vested tokens to the Colony MultiSig Secured to the Colony MultiSig only
"
"function collectTokens ( ) public onlyOwner { uint256 balance = token . balanceOf ( address ( this ) ) ; require ( balance > 0 ) ; uint256 finalizedTime = crowdsale . finishTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 14 days ) ) ; require ( token . transfer ( owner , balance ) ) ; TokensWithdrawn ( owner , balance ) ; }
","The Dev ( Owner ) will call this method to extract the tokens
"
"function services ( uint256 _serviceId ) public constant returns ( address _service ) { }
","helps to get service address
"
"function removeModule ( uint8 _moduleType , uint8 _moduleIndex ) external onlyOwner { require ( _moduleIndex < modules [ _moduleType ] . length , ""Module index doesn't exist as per the choosen module type"" ) ; require ( modules [ _moduleType ] [ _moduleIndex ] . moduleAddress != address ( 0 ) , ""Module contract address should not be 0x"" ) ; emit LogModuleRemoved ( _moduleType , modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , now ) ; modules [ _moduleType ] [ _moduleIndex ] = modules [ _moduleType ] [ modules [ _moduleType ] . length - 1 ] ; modules [ _moduleType ] . length = modules [ _moduleType ] . length - 1 ; }
","Removes a module attached to the SecurityToken
"
"function convertToEther ( uint256 _value ) public view returns ( uint256 ) { return _value * sencEthRate / 10 ** 18 ; }
","The ` convertToEther ( ) ` converts value of SENC Tokens to Ether based on pegged rate .
"
"function allowance ( address _owner , address _spender ) public erc20 view returns ( uint256 remaining ) { return mAllowed [ _owner ] [ _spender ] ; }
","ERC20 backwards compatible allowance .
"
"function setUpgradeAgent ( UpgradeAgent _upgradeAgent ) external onlyOwner { require ( canUpgrade ( ) , ""Ensure the token is upgradeable in the first place"" ) ; require ( _upgradeAgent != address ( 0 ) , ""Ensure upgrade agent address is not blank"" ) ; require ( getUpgradeState ( ) != UpgradeState . Upgrading , ""Ensure upgrade has not started"" ) ; upgradeAgent = _upgradeAgent ; require ( upgradeAgent . isUpgradeAgent ( ) , ""New upgradeAgent must be UpgradeAgent"" ) ; require ( upgradeAgent . originalSupply ( ) == totalSupply_ , ""Make sure that token supplies match in source and target token contracts"" ) ; emit UpgradeAgentSet ( upgradeAgent ) ; }
","Set an upgrade agent contract to process the upgrade .
"
"function rentArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint numberOfPeriods ) external payable whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; require ( canPay ( areaRentPrice ( fromX , fromY , toX , toY , numberOfPeriods ) ) ) ; depositFunds ( ) ; uint id = rentals . rentBlocks ( msg . sender , numberOfPeriods , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogRents ( id , fromX , fromY , toX , toY , numberOfPeriods , 0 ) ; }
","Rent an area of blocks at coordinates [ fromX , fromY , toX , toY ] for a number of periods specified ( period length is specified in rentals contract )
"
"function afterTransfer ( uint64 pledgeManager , uint64 pledgeFrom , uint64 pledgeTo , uint64 context , uint amount ) ;
","Plugins are used ( much like web hooks ) to initiate an action upon any donation , delegation , or transfer ; this is an optional feature and allows for extreme customization of the contract .
"
"function revoke ( ERC20 _token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ _token ] ) ; uint256 balance = _token . balanceOf ( address ( this ) ) ; uint256 unreleased = releasableAmount ( _token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ _token ] = true ; _token . safeTransfer ( owner , refund ) ; emit Revoked ( ) ; }
","Allows the owner to revoke the vesting .
"
"function transferToContract ( address to , uint256 value , bytes data ) public whenNotPaused afterCrowdsale returns ( bool _success ) { return super . transferToContract ( to , value , data ) ; }
","Override the functions to not allow token transfers until the end of the ICO
"
"function getBidHash ( uint nonce , uint bid_id , address investor_address , uint share_price , uint shares_count ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( nonce , bid_id , investor_address , share_price , shares_count ) ) ; }
","Helper function for calculating a bid 's hash .
"
"function activateDevice ( bytes32 _deviceId ) public whenNotPaused returns ( bool ) { uint256 activationFee = settings . activationFee ( ) ; Device memory d = _activateDevice ( _deviceId ) ; emit DeviceActivated ( msg . sender , activationFee , _deviceId , d . manufacturerId , d . deviceType ) ; address manufacturer = manufacturerRewards [ d . manufacturerId ] ; require ( manufacturer != address ( this ) , ""manufacturer is unknown"" ) ; _depositTokens ( manufacturer , activationFee ) ; require ( token . transferFrom ( msg . sender , address ( this ) , activationFee ) , ""transferFrom failed"" ) ; return true ; }
","Activates the device
"
"function freezeTransfers ( ) onlyOwner returns ( bool frozen ) { tokenTransfersFrozen = true ; FreezeTransfers ( msg . sender , true ) ; return true ; }
","Used to freeze token transfers
"
"function noError ( ) public onlyManager whenPaused { error = false ; }
","This is public rather than external so it can be called by derived contracts .
"
"function isDeregisterable ( address _darknodeID ) public view returns ( bool ) { uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return isRegistered ( _darknodeID ) && deregisteredAt == 0 ; }
","Returns if a darknode can be deregistered .
"
"function setEndDate ( uint256 _endDate ) external onlyOwner returns ( bool ) { END_DATE = _endDate ; return true ; }
","The ` setEndDate ( ) ` changes unit timestamp on wich de donations ends .
"
"function transfer ( address to , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; if ( to == 0x0 ) throw ; if ( to == address ( upgradeAgent ) ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } return false ; }
","This function is disabled during the funding .
"
"function addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) external ;
","Function used to attach a module to the security token
"
"function getGroups ( ) public view returns ( bytes32 [ ] _groups ) { uint _groupsCount = groupsCount ; _groups = new bytes32 [ ] ( _groupsCount ) ; for ( uint _groupIdx = 0 ; _groupIdx < _groupsCount ; ++ _groupIdx ) { _groups [ _groupIdx ] = index2groupName [ _groupIdx + 1 ] ; } }
","Get current group names
"
"function batchSafeTransferFrom ( uint256 [ ] _tokenIds , address _from , address _to ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _from != address ( 0 ) && _to != address ( 0 ) ) ; uint256 _id ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 ) ; _id = _tokenIds [ i ] ; safeTransferFrom ( _from , _to , _id ) ; } }
","Batch SafeTransferFrom from a single address to another address
"
"function isContract ( address addr ) public constant returns ( bool _isContract ) { require ( addr != address ( 0 ) ) ; uint256 length ; assembly { length := extcodesize ( addr ) } return ( length > 0 ) ; }
","To check if an address is a contract or not
"
"function getAuditReportIPFS ( address _auditor , bytes32 _codeHash ) public view returns ( bytes ) { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; return Audits [ hashAuditorCode ] . reportIPFS ; }
","returns the audit report IPFS of the audit or 0x0 if none
"
"function approveKYCAndDeposit ( string currency , address account , uint amount , uint limit , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setKYCApproval ( account , true , issuerFirm ) , ""Error: Unable to approve account. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . setAccountStatus ( account , true , issuerFirm ) , ""Error: Unable to set account status. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . deposit ( currency , account , amount , issuerFirm ) , ""Error: Unable to deposit funds. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . setAccountSpendingLimit ( account , limit ) , ""Error: Unable to set initial spending limit for account. Please check issuerFirm and firm authority are registered"" ) ; require ( lib . setAccountSpendingPeriod ( account , ( now + 86400 ) ) , ""Error: Unable to set spending period for account. Please check issuerFirm and firm authority are registered"" ) ; return true ; }
","Approves account and deposits specified amount of given currency
"
"function startVote ( uint64 _votefinish ) external onlyOwner { require ( currentStage == StageName . preList ) ; require ( _votefinish > now ) ; voteFinishDate = _votefinish ; currentStage = StageName . inProgress ; emit VoteStarted ( uint64 ( now ) ) ; }
","Start vote
"
"function create ( bytes32 _missionId , address _sellerId , address _buyerId , uint256 _cost ) public { require ( identity . verifyOwnership ( _buyerId , msg . sender ) ) ; require ( identity . getBalance ( _buyerId ) >= _cost ) ; require ( missions [ _missionId ] . buyer == 0x0 ) ; token . transferFrom ( msg . sender , this , _cost ) ; missions [ _missionId ] = Mission ( { seller : _sellerId , buyer : _buyerId , cost : _cost , balance : _cost , isSigned : false } ) ; emit Create ( _missionId , _sellerId , _buyerId ) ; }
","Create a new mission
"
"function setETHPriceUpperBound ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { m_ETHPriceUpperBound = _price ; }
","set the limit of ETH in cents , oraclize data greater than this is not accepted
"
"function callWithdraw ( ) public { realitio . withdraw ( ) ; }
","Withdraw any accumulated question fees from the specified address into this contract
"
"function totalSupply ( ) public constant returns ( uint256 _totalSupply ) { return totalSupply ; }
","Get the total amount of token supply
"
"function mCanAmend ( address legalRepresentative ) internal returns ( bool ) { return accessPolicy ( ) . allowed ( legalRepresentative , ROLE_EURT_LEGAL_MANAGER , this , msg . sig ) ; }
","euro token is legally represented by separate entity ROLE_EURT_LEGAL_MANAGER
"
"function lock ( address investor , uint256 amount , uint256 neumarks ) public onlyState ( LockState . AcceptingLocks ) onlyController ( ) { require ( amount > 0 ) ; assert ( ASSET_TOKEN . transferFrom ( msg . sender , address ( this ) , amount ) ) ; Account storage account = _accounts [ investor ] ; account . balance = addBalance ( account . balance , amount ) ; account . neumarksDue = add ( account . neumarksDue , neumarks ) ; if ( account . unlockDate == 0 ) { _totalInvestors += 1 ; account . unlockDate = currentTime ( ) + LOCK_PERIOD ; } LogFundsLocked ( investor , amount , neumarks ) ; }
","locks funds of investors for a period of time
"
"function getDarknodePublicKey ( address _darknodeID ) external view returns ( bytes ) { return store . darknodePublicKey ( _darknodeID ) ; }
","Retrieves the encryption public key of the darknode .
"
"function changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) public withPerm ( CHANGE_PERMISSION ) { require ( _delegate != address ( 0 ) , ""invalid address"" ) ; _changePermission ( _delegate , _module , _perm , _valid ) ; }
","Used to provide/change the permission to the delegate corresponds to the module contract
"
"function setProtocolVersion ( address _stVersionProxyAddress , bytes32 _version ) public onlyOwner { protocolVersion = _version ; protocolVersionST [ _version ] = _stVersionProxyAddress ; }
","Changing versions does not affect existing tokens .
"
"function _distributeNewSaleInput ( address _affiliateAddress ) private { _addWithdrawal ( contractOwner , ( ( msg . value / 100 ) * 60 ) ) ; if ( _affiliateAddress != address ( 0 ) && _affiliateAddress != msg . sender ) { _addWithdrawal ( _affiliateAddress , ( ( msg . value / 100 ) * 25 ) ) ; } }
","Distribute input funds between contract owner and players
"
"function getAccountSpendingRemaining ( address account ) public view returns ( uint spendingRemaining ) { return lib . getAccountSpendingRemaining ( account ) ; }
","Returns the periodic remaining spending amount for an account
"
"function cancelCrowdsale ( ) onlyOwner { crowdsaleCanceled = true ; }
","Terminate the crowdsale before END_DATE
"
"function getRewardsBalance ( address _user ) public onlyOwnerOrAllowed returns ( uint256 _balance ) { return rewardedBalance [ _user ] ; }
","Get user 's rewards balance Function returning a user 's rewards balance not yet withdrawn
"
"function accountIdForAddress ( address _address ) public view returns ( uint256 ) { require ( addressBelongsToAccount ( _address ) ) ; return accountByAddress [ _address ] ; }
","Retreive account ID associated with a user 's address
"
"function participantWithdrawIfMinimumFundingNotReached ( uint256 _value ) external { if ( now <= PRESALE_END_DATE ) revert ( ) ; if ( totalFunding >= PRESALE_MINIMUM_FUNDING ) revert ( ) ; if ( balanceOf [ msg . sender ] < _value ) revert ( ) ; balanceOf [ msg . sender ] = safeDecrement ( balanceOf [ msg . sender ] , _value ) ; if ( ! msg . sender . send ( _value ) ) revert ( ) ; }
","The participant will need to withdraw their funds from this contract if the pre sale has not achieved the minimum funding level
"
"function burn ( uint256 _value ) onlyowner public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; totalBhinneka = safeSub ( totalBhinneka , _value ) ; Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function changeTokenController ( address newController ) public ;
","replace current token controller
"
"function finalize ( ) public onlyController { require ( stageNow ( ) == stageAt . finalState ) ; require ( totalSupply + ecoFundSupply >= softCap ) ; finalized = true ; }
","finalize
"
"function freezeAccount ( address target , bool freeze ) onlyOwner public { frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }
","` freeze ?
"
"function initialize ( MiniMeToken _token , uint64 _supportRequiredPct , uint64 _minAcceptQuorumPct , uint64 _voteTime ) external onlyInit { initialized ( ) ; require ( _minAcceptQuorumPct <= _supportRequiredPct , ERROR_INIT_PCTS ) ; require ( _supportRequiredPct < PCT_BASE , ERROR_INIT_SUPPORT_TOO_BIG ) ; token = _token ; supportRequiredPct = _supportRequiredPct ; minAcceptQuorumPct = _minAcceptQuorumPct ; voteTime = _voteTime ; }
","Initialize Voting app with ` _token.symbol ( ) : string ` for governance , minimum support of ` @ formatPct ( _supportRequiredPct ) ` % , minimum acceptance quorum of ` @ formatPct ( _minAcceptQuorumPct ) ` % , and a voting duration of ` @ transformTime ( _voteTime ) `
"
"function splitTrade ( uint _amount ) public pure returns ( uint commission , uint paintersRewards , uint sellerProfit ) { uint _commission = _calculatePercent ( _amount , COMMISSION ) ; uint _rewardPerPixel = _calculatePercent ( _amount , TRADE_REWARD ) / PIXEL_COUNT ; uint _paintersReward = _rewardPerPixel * PIXEL_COUNT ; uint _sellerProfit = _amount - _commission - _paintersReward ; require ( _sellerProfit < _amount ) ; return ( _commission , _paintersReward , _sellerProfit ) ; }
","Calculates how the money from selling canvas will be split .
"
"function setApprovalForAll ( address _to , bool _approved ) external whenNotPaused { if ( _approved ) { approveAll ( _to ) ; } else { disapproveAll ( _to ) ; } }
","Enable or disable approval for a third party ( `` operator '' ) to manage all your assets
"
"function grantVestedTokens ( address _to , uint256 _value , uint256 _start , uint256 _vesting ) public icoResticted isActive { require ( _value > 0 ) ; require ( _vesting > _start ) ; require ( grants [ _to ] . length < 10 ) ; TokenGrant memory grant = TokenGrant ( _value , 0 , _vesting , _start ) ; grants [ _to ] . push ( grant ) ; NewTokenGrant ( _to , _value , _start , _vesting ) ; }
","Only for ICO contract address .
"
"function claimActingPlayerOutOfTime ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; require ( board . status == BoardStatus . InProgress ) ; PlayerColor actingPlayerColor = getNextTurnColor ( boardId ) ; uint playerTimeRemaining = PLAYER_TURN_SINGLE_PERIOD * getPlayerTimePeriods ( board , actingPlayerColor ) ; if ( playerTimeRemaining < now - board . lastUpdate ) { playerLost ( board , boardId , actingPlayerColor ) ; } }
","Claiming the current acting player on the board is out of time , thus losses the game .
"
"function transferOwnership ( address _newOwner ) onlyOwner { balances [ _newOwner ] = balances [ owner ] ; balances [ owner ] = 0 ; Ownable . transferOwnership ( _newOwner ) ; }
","To transfer token contract ownership
"
"function getAmountOfSwimmers ( ) public view returns ( uint256 _lengthOfSwimmers ) { _lengthOfSwimmers = swimmersList . length ; }
","Returns the amount of swimmers currently in this contract .
"
"function revealVotes ( uint [ ] _pollIDs , uint [ ] _voteOptions , uint [ ] _salts ) external { require ( _pollIDs . length == _voteOptions . length ) ; require ( _pollIDs . length == _salts . length ) ; for ( uint i = 0 ; i < _pollIDs . length ; i ++ ) { revealVote ( _pollIDs [ i ] , _voteOptions [ i ] , _salts [ i ] ) ; } }
","Reveals multiple votes with choices and secret salts used in generating commitHashes to attribute committed tokens
"
"function safeSub ( uint256 a , uint256 b ) internal pure returns ( uint256 z ) { assert ( ( z = a - b ) <= a ) ; }
","SafeMath Library safeSub Import
"
"function addWhitelistAddrByList ( address [ ] investors ) public onlyOwner mustBeAtStage ( Stage . Finished ) { for ( uint256 i = 0 ; i < investors . length ; i ++ ) { addWhitelistAddress ( investors [ i ] ) ; } }
","Must be called after the crowdsale has finished
"
"function revoke ( IERC20 token ) public onlyOwner { require ( _revocable ) ; require ( ! _revoked [ token ] ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; uint256 unreleased = _releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; _revoked [ token ] = true ; token . safeTransfer ( owner ( ) , refund ) ; emit TokenVestingRevoked ( token ) ; }
","Allows the owner to revoke the vesting .
"
"function setUpgradeableTarget ( address upgradeAddress ) external onlyOwner { upgradeableTarget = upgradeAddress ; }
","Set address of upgrade target process .
"
"function registerToken ( uint32 _tokenCode , address _tokenAddress , uint8 _tokenDecimals ) public onlyOwner { require ( ! tokens [ _tokenCode ] . registered , ""already registered"" ) ; if ( detailsSubmitted [ _tokenCode ] ) { require ( tokens [ _tokenCode ] . addr == _tokenAddress , ""different address"" ) ; require ( tokens [ _tokenCode ] . decimals == _tokenDecimals , ""different decimals"" ) ; } else { detailsSubmitted [ _tokenCode ] = true ; } tokens [ _tokenCode ] = TokenDetails ( { addr : _tokenAddress , decimals : _tokenDecimals , registered : true } ) ; emit LogTokenRegistered ( _tokenCode , _tokenAddress , _tokenDecimals ) ; }
","Allows the owner to register and the details for a token .
"
"function getAmountToGive ( bytes genericPayload ) public view onlyTotle whenNotPaused returns ( uint256 amountToGive ) { bool success ; bytes4 functionSelector = selectorProvider . getSelector ( this . getAmountToGive . selector ) ; assembly { let functionSelectorLength := 0x04 let functionSelectorOffset := 0x1C let scratchSpace := 0x0 let wordLength := 0x20 let bytesLength := mload ( genericPayload ) let totalLength := add ( functionSelectorLength , bytesLength ) let startOfNewData := add ( genericPayload , functionSelectorOffset ) mstore ( add ( scratchSpace , functionSelectorOffset ) , functionSelector ) let functionSelectorCorrect := mload ( scratchSpace ) mstore ( genericPayload , functionSelectorCorrect ) success := call ( gas , address , callvalue , startOfNewData , totalLength , scratchSpace , wordLength ) amountToGive := mload ( scratchSpace ) if eq ( success , 0 ) { revert ( 0 , 0 ) } } }
","Gets the amount that Totle needs to give for this order
"
"function getCollectible ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = collectibleIndexToPrice [ _tokenId ] ; owner = collectibleIndexToOwner [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = startingPrice ; if ( sellingPrice < firstStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 200 ) , 94 ) ; } else if ( sellingPrice < secondStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 120 ) , 94 ) ; } else { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 115 ) , 94 ) ; } }
","Returns all the relevant information about a specific collectible .
"
"function confirmBoardScore ( bytes32 boardHash , bytes32 playerName ) public returns ( bool ) { uint8 playerID = getPlayerId ( boardHash , playerName , 0 ) ; uint8 confirmerID = getPlayerId ( boardHash , """" , msg . sender ) ; require ( playerID < 255 ) ; require ( confirmerID < 255 ) ; require ( boards [ boardHash ] . players [ playerID ] . playerAddress != msg . sender ) ; boards [ boardHash ] . players [ playerID ] . score += boards [ boardHash ] . players [ playerID ] . score_unconfirmed ; boards [ boardHash ] . players [ playerID ] . score_unconfirmed = 0 ; return true ; }
","Confirm an unconfirmed score to leaderboard/player .
"
"function setAddressAlias ( address oldAddr , address newAddr ) public onlyRole ( ROLE_ADDRESS_ALIASER ) { require ( ! hasClaims [ newAddr ] , ""newAddr already has claims"" ) ; super . setAddressAlias ( oldAddr , newAddr ) ; }
","Alias a new address to an old address .
"
"function collectTokens ( ) public onlyController { uint256 balance = aix . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 canExtract = total . mul ( extractableFraction ( ) ) . div ( 29 ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; require ( aix . transfer ( controller , canExtract ) ) ; TokensWithdrawn ( controller , canExtract ) ; }
","The Dev ( Owner ) will call this method to extract the tokens
"
"function getAllDelegatesWithPerm ( address _module , bytes32 _perm ) external view returns ( address [ ] ) { uint256 counter = 0 ; uint256 i = 0 ; for ( i = 0 ; i < allDelegates . length ; i ++ ) { if ( perms [ _module ] [ allDelegates [ i ] ] [ _perm ] ) { counter ++ ; } } address [ ] memory allDelegatesWithPerm = new address [ ] ( counter ) ; counter = 0 ; for ( i = 0 ; i < allDelegates . length ; i ++ ) { if ( perms [ _module ] [ allDelegates [ i ] ] [ _perm ] ) { allDelegatesWithPerm [ counter ] = allDelegates [ i ] ; counter ++ ; } } return allDelegatesWithPerm ; }
","Used to return all delegates with a given permission and module
"
"function getPlayer ( uint256 _id ) external view returns ( uint256 typeId , uint256 attack , uint256 defense , uint256 stamina , uint256 xp , uint256 isKeeper , uint256 skillId , uint256 isSkillOn ) { Player storage player = players [ _id ] ; typeId = uint256 ( player . typeId ) ; attack = uint256 ( player . attack ) ; defense = uint256 ( player . defense ) ; stamina = uint256 ( player . stamina ) ; xp = uint256 ( player . xp ) ; isKeeper = uint256 ( player . isKeeper ) ; skillId = uint256 ( player . skillId ) ; isSkillOn = uint256 ( player . isSkillOn ) ; }
","Returns all the relevant information about a specific player .
"
"function getPartialAmount ( uint256 numerator , uint256 denominator , uint256 target ) internal pure returns ( uint256 ) { return SafeMath . div ( SafeMath . mul ( numerator , target ) , denominator ) ; }
","Calculate the result of ( ( numerator target ) / denominator )
"
"function transfer ( address _to , uint _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transItem ( msg . sender , _to , _tokenId ) ; }
","Transfers a Rabbit to another address .
"
"function transferMultiple ( address [ ] _to , uint256 [ ] _value ) external returns ( bool ) { require ( _to . length == _value . length ) ; uint256 i = 0 ; while ( i < _to . length ) { _transfer ( msg . sender , _to [ i ] , _value [ i ] ) ; i += 1 ; } return true ; }
","Transfer tokens to multiple account
"
"function renounceOwnership ( ) public onlyOwner { require ( ! stopped ) ; owner = address ( 0x0 ) ; emit OwnershipRenounced ( owner ) ; }
","Renouncing to ownership will leave the contract without an owner It will not be possible to call the functions with the ` onlyOwner ` modifier anymore
"
"function buy ( ) payable { require ( ! isContract ( msg . sender ) ) ; require ( msg . value >= 0.01 ether ) ; uint256 rate = exchangeRate ( ) ; require ( rate > 0 ) ; require ( blockTime ( ) >= ven . lastMintedTimestamp ( msg . sender ) + minBuyInterval ) ; uint256 requested ; if ( msg . value > maxBuyEthAmount ) { requested = maxBuyEthAmount . mul ( rate ) ; } else { requested = msg . value . mul ( rate ) ; } uint256 remained = officialLimit . sub ( soldOut . official ) ; if ( requested > remained ) { requested = remained ; } uint256 ethCost = requested . div ( rate ) ; if ( requested > 0 ) { ven . mint ( msg . sender , requested , true , blockTime ( ) ) ; ethVault . transfer ( ethCost ) ; soldOut . official = requested . add ( soldOut . official ) . toUINT120 ( ) ; onSold ( msg . sender , requested , ethCost ) ; } uint256 toReturn = msg . value . sub ( ethCost ) ; if ( toReturn > 0 ) { msg . sender . transfer ( toReturn ) ; } }
","entry to buy tokens
"
"function setHiddenCurves ( bytes32 [ ] _curveHashes ) public onlyOwner { require ( curves . length == 0 ) ; curves . length = _curveHashes . length ; for ( uint256 i = 0 ; i < _curveHashes . length ; i = i . add ( 1 ) ) { curves [ i ] . hash = _curveHashes [ i ] ; } }
","This should be called by the creator of the contract to commit all the curves .
"
"function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes memory _data ) public returns ( bytes4 ) ;
","Handle the receipt of an NFT
"
"function checkAndCallSafeTransfer ( address _from , address _to , uint256 _tokenId , bytes _data ) internal returns ( bool ) { if ( ! _to . isContract ( ) ) return true ; bytes4 retval = ERC721Receiver ( _to ) . onERC721Received ( msg . sender , _from , _tokenId , _data ) ; return ( retval == ERC721_RECEIVED ) ; }
","Invoke ` onERC721Received ` on a target address ( not executed if the target address is not a contract )
"
"function getM5Reward ( address _miner ) public view returns ( uint256 ) { require ( M5Logic_ != address ( 0 ) ) ; if ( miners [ _miner ] . value == 0 ) { return 0 ; } require ( signedAverage ( miners [ _miner ] . onBlockReward , blockReward_ ) < 0 ) ; uint32 returnSize = 32 ; address target = M5Logic_ ; bytes32 signature = keccak256 ( ""getM5Reward(address)"" ) ; uint32 inputSize = 4 + 32 ; uint8 callResult ; uint256 result ; assembly { mstore ( 0x0 , signature ) mstore ( 0x4 , _miner ) callResult := delegatecall ( sub ( gas , 10000 ) , target , 0x0 , inputSize , 0x0 , returnSize ) switch callResult case 0 { revert ( 0 , 0 ) } default { result := mload ( 0x0 ) } } return result ; }
","This is a wrapper , which calls and return result from M5Logic the actual logic is found in the M5Logic contract
"
"function setTotalDeposit ( uint256 channel_identifier , address participant , uint256 total_deposit , address partner ) isSafe isOpen ( channel_identifier ) public { require ( channel_identifier == getChannelIdentifier ( participant , partner ) ) ; require ( total_deposit > 0 ) ; require ( total_deposit <= channel_participant_deposit_limit ) ; uint256 added_deposit ; uint256 channel_deposit ; Channel storage channel = channels [ channel_identifier ] ; Participant storage participant_state = channel . participants [ participant ] ; Participant storage partner_state = channel . participants [ partner ] ; added_deposit = total_deposit - participant_state . deposit ; require ( added_deposit > 0 ) ; require ( added_deposit <= total_deposit ) ; assert ( participant_state . deposit + added_deposit == total_deposit ) ; require ( token . balanceOf ( address ( this ) ) + added_deposit <= token_network_deposit_limit ) ; participant_state . deposit = total_deposit ; channel_deposit = participant_state . deposit + partner_state . deposit ; require ( channel_deposit >= participant_state . deposit ) ; emit ChannelNewDeposit ( channel_identifier , participant , participant_state . deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , added_deposit ) ) ; }
","Sets the channel participant total deposit value .
"
"function setRate ( uint256 _rate ) public onlyOwner beforeSale { require ( _rate > 0 ) ; rate = _rate ; }
","Set rate
"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal view whenNotPaused ifWhitelisted ( _beneficiary ) { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; }
","This is called before determining the token amount .
"
"function followTraderPreSignedHashing ( address _investContract , address _trader , bytes32 _strategyID , uint256 _marginAmount , address _oracle , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x7aefec13 ) , _investContract , _trader , _strategyID , _marginAmount , _oracle , _validUntil ) ) ; }
","Hash ( keccak256 ) of the payload used by followTrader
"
"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyArbitrator ( question_id ) statePendingArbitration ( question_id ) bondMustBeZero external { require ( answerer != NULL_ADDRESS ) ; LogFinalize ( question_id , answer ) ; questions [ question_id ] . is_pending_arbitration = false ; _addAnswerToHistory ( question_id , answer , answerer , 0 , false ) ; _updateCurrentAnswer ( question_id , answer , 0 ) ; }
","Submit the answer for a question , for use by the arbitrator .
"
"function cancelAuction ( address _contract , uint256 _tokenId ) external { Auction storage auction = tokenToAuction [ _contract ] [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _contract , _tokenId , seller ) ; }
","This is a state-modifying function that can be called while the contract is paused .
"
"function getNumber ( uint256 _tokenId ) public view returns ( string numberName , uint256 sellingPrice , address owner ) { Number storage number = numbers [ _tokenId ] ; numberName = number . name ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific person .
"
"function virtualBalanceOf ( address _owner ) internal view returns ( uint256 ) { return _owner . balance >= VIRTUAL_THRESHOLD ? VIRTUAL_COUNT : 0 ; }
","Get virtual balance of the owner of given address .
"
"function availableInventoryOf ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . available ; }
","The available inventory of a product
"
"function setMinimumDepositAmount ( uint _amount ) external onlyOwner { require ( _amount > 1 * UNIT ) ; minimumDepositAmount = _amount ; emit MinimumDepositAmountUpdated ( minimumDepositAmount ) ; }
","Set the minimum deposit amount required to depoist nUSD into the FIFO queue
"
"function createCheckpoint ( ) public withPerm ( CHECKPOINT ) returns ( uint256 ) { return ISecurityToken ( securityToken ) . createCheckpoint ( ) ; }
","Creates a checkpoint on the security token
"
"function isOperatorFor ( address _operator , address _tokenHolder ) public constant returns ( bool ) { return ( _operator == _tokenHolder || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }
","Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address .
"
"function setMinimumStakingRequirement ( uint _minimumStakingRequirement ) public onlyCurator { minimumStakingRequirement = _minimumStakingRequirement ; logger . emitGenericLog ( ""setMinimumStakingRequirement"" , """" ) ; }
","Sets the minimum community staking requirement
"
"function assetPrices ( address asset ) public returns ( uint ) { mostRecentCaller = tx . origin ; mostRecentBlock = block . number ; return realPriceOracle . assetPrices ( asset ) ; }
","Gets the price of a given asset
"
"function refund ( ) public { internalRefund ( msg . sender ) ; }
","refund ethers to contributor
"
"function cancelAuction ( uint256 _deedId ) external whenNotPaused { Auction storage auction = identifierToAuction [ _deedId ] ; require ( _activeAuction ( auction ) ) ; require ( msg . sender == auction . seller ) ; _cancelAuction ( _deedId , auction ) ; }
","Cancel an auction
"
"function setEvaluator ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender != job . manager ) ; require ( msg . sender != job . worker ) ; job . evaluator = msg . sender ; emit EvaluatorSet ( _JobID , msg . sender ) ; }
","this function lets a registered address become an evaluator for a job
"
"function proposeUpgrade ( address _newVersion ) onlyAssetOwner public returns ( bool ) { if ( pendingVersion != 0x0 ) { return false ; } if ( _newVersion == 0x0 ) { return false ; } if ( latestVersion == 0x0 ) { latestVersion = _newVersion ; return true ; } pendingVersion = _newVersion ; pendingVersionTimestamp = now ; emit UpgradeProposal ( _newVersion ) ; return true ; }
","Propose next asset implementation contract address .
"
"function getGem ( uint256 _tokenId ) public view returns ( string gemName , uint256 sellingPrice , address owner ) { Gem storage gem = gems [ _tokenId ] ; gemName = gem . name ; sellingPrice = gemIndexToPrice [ _tokenId ] ; owner = gemIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific gem .
"
"function updateSlasher ( address _slasher ) external onlyOwner { nextSlasher = _slasher ; }
","Allow the contract owner to update the DarknodeSlasher contract address .
"
"function addToWhitelist ( address _token , uint _amount , uint daysAllowed ) internal { _whitelistTokens storage newToken = acceptedTokens [ _token ] ; newToken . tokenAddress = _token ; newToken . requiredAmount = _amount ; newToken . timestamp = now ; newToken . validUntil = now + ( daysAllowed * 1 days ) ; newToken . active = true ; tokensList . push ( _token ) ; }
","Add a new token as accepted payment method .
"
"function burnCarbonDollar ( address stablecoin , uint256 _amount ) public userNotBlacklisted ( msg . sender ) whenNotPaused { _burnCarbonDollar ( msg . sender , stablecoin , _amount ) ; }
","burns CarbonDollar and an equal amount of whitelisted stablecoin from the CarbonDollar address
"
"function execSwap ( Data storage self , address requester , string symbolA , string symbolB , uint valueA , uint valueB , uint8 sigV , bytes32 sigR , bytes32 sigS , uint expiration ) internal returns ( bool success ) { bytes32 fxTxHash = keccak256 ( abi . encodePacked ( requester , symbolA , symbolB , valueA , valueB , expiration ) ) ; require ( verifyAccounts ( self , msg . sender , requester ) , ""Error: Only verified accounts can perform currency swaps."" ) ; require ( setTxStatus ( self , fxTxHash ) , ""Error: Failed to set transaction status to fulfilled."" ) ; require ( expiration >= now , ""Error: Transaction has expired!"" ) ; require ( ecrecover ( fxTxHash , sigV , sigR , sigS ) == requester , ""Error: Address derived from transaction signature does not match the requester address"" ) ; require ( forceTransfer ( self , symbolA , msg . sender , requester , valueA , ""0x0"" ) , ""Error: Unable to transfer funds to account."" ) ; require ( forceTransfer ( self , symbolB , requester , msg . sender , valueB , ""0x0"" ) , ""Error: Unable to transfer funds to account."" ) ; emit FxSwap ( symbolA , symbolB , valueA , valueB , expiration , fxTxHash ) ; return true ; }
","Accepts a signed fx request to swap currency pairs at a given amount ;
"
"function getUnclaimedHalvingSubsidy ( uint256 _halving ) public constant notBeforeGenesis returns ( uint256 ) { require ( _halving < currentHalving ( ) ) ; if ( ! halvingsSubsidies [ _halving ] . claimed ) { return halvingSubsidy ( _halving ) ; } else { halvingsSubsidies [ _halving ] . value ; } }
","Computes the remaining subsidy pending of being claimed for a given halving
"
"function approve ( address _spender , uint256 _value , uint256 _cooldown ) external { allowed [ msg . sender ] [ _spender ] = _value ; cooldown [ msg . sender ] [ _spender ] = now + _cooldown ; Approval ( msg . sender , _spender , _value ) ; }
","Authorize an address to retrieve funds from you with a custom cooldown ~ ERC-20 Standard
"
"function withdrawPromoter ( ) public { address _to = msg . sender ; require ( _to == wuguAddr || _to == richardAddr ) ; uint usd ; ( usd , , ) = ICOStatus ( ) ; require ( usd . mul ( 95 ) . div ( 100 ) >= softcapUSD ) ; uint bonus = 0 ; address [ ] memory clients = promoterClients [ _to ] ; for ( uint i = 0 ; i < clients . length ; i ++ ) { if ( kyc [ clients [ i ] ] ) { uint num = promoterBonus [ _to ] [ clients [ i ] ] ; delete promoterBonus [ _to ] [ clients [ i ] ] ; bonus += num ; } } _to . transfer ( bonus ) ; }
","withdrawPromoter transfers back to promoter all bonuses accumulated to current moment
"
"function approve ( address _spender , uint256 _value ) returns ( bool ) ;
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function giveBounty ( uint256 _tokens , address _address ) external { require ( msg . sender == bountyAddress ) ; tokenAvailable = tokenAvailable . sub ( _tokens ) ; mintableFida . sendBoughtTokens ( _address , _tokens ) ; }
","Give out a bounty
"
"function _unpause ( ) internal whenPaused { paused = false ; emit Unpause ( now ) ; }
","Called by the owner to unpause , returns to normal state
"
"function addAdmin ( address _newAdmin ) public onlyAdmins { admins [ _newAdmin ] = true ; }
","Any admin is able to add new admin
"
"function refund ( ) external { if ( ! funding ) throw ; if ( block . number <= fundingEndBlock ) throw ; if ( totalTokens >= tokenCreationMin ) throw ; var gntValue = balances [ msg . sender ] ; if ( gntValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalTokens -= gntValue ; var ethValue = gntValue / tokenCreationRate ; Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }
","Get back the ether sent during the funding in case the funding has not reached the minimum level .
"
"function getMobster ( uint256 _tokenId ) public view returns ( uint256 id , string name , uint256 boss , uint256 sellingPrice , address owner , uint256 state , uint256 dazedExipryTime , uint256 nextPrice , uint256 level , bool canSetPrice , string show , bool hasWhacked ) { id = _tokenId ; Mobster storage mobster = mobsters [ _tokenId ] ; name = mobster . name ; boss = mobster . boss ; sellingPrice = priceOf ( _tokenId ) ; owner = mobsterIndexToOwner [ _tokenId ] ; state = mobster . state ; if ( mobster . state == 1 && now > mobster . dazedExipryTime ) { state = 0 ; } dazedExipryTime = mobster . dazedExipryTime ; nextPrice = calculateNewPrice ( _tokenId ) ; level = mobster . level ; canSetPrice = ( mobster . buyTime + setPriceCoolingPeriod ) < now ; show = mobster . show ; hasWhacked = mobster . hasWhacked ; }
","Returns all the relevant information about a specific mobster .
"
"function cancelOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) pre_cond ( Fund ( address ( this ) ) . owner ( ) == msg . sender || Fund ( address ( this ) ) . isShutDown ( ) || Fund ( address ( this ) ) . orderExpired ( targetExchange , orderAddresses [ 2 ] ) ) { require ( uint ( identifier ) != 0 ) ; var ( , makerAsset , , ) = MatchingMarket ( targetExchange ) . getOffer ( uint ( identifier ) ) ; require ( address ( makerAsset ) == orderAddresses [ 2 ] ) ; Fund ( address ( this ) ) . removeOpenMakeOrder ( targetExchange , orderAddresses [ 2 ] ) ; MatchingMarket ( targetExchange ) . cancel ( uint ( identifier ) ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( identifier ) , Fund . UpdateType . cancel , [ address ( 0 ) , address ( 0 ) ] , [ uint ( 0 ) , uint ( 0 ) , uint ( 0 ) ] ) ; }
","Cancels orders that were not expected to settle immediately
"
"function getStageIndex ( ) public view returns ( uint8 currentStage , bool onSale ) { onSale = true ; Stage memory p ; for ( currentStage = 0 ; currentStage < stages . length ; currentStage ++ ) { p = stages [ currentStage ] ; if ( p . startTime <= now && now <= p . endTime ) { return ; } } onSale = false ; }
","if period is on sale , return index of the period .
"
"function setString ( bytes32 _key , string _value ) public onlyOwner returns ( bool success ) { stringStorage [ _key ] = _value ; return true ; }
","Set value for String associated with bytes32 id key
"
"function proposeOwnership ( address _newOwnerCandidate ) public onlyOwner { newOwnerCandidate = _newOwnerCandidate ; OwnershipRequested ( msg . sender , newOwnerCandidate ) ; }
","` onlyOwner ` Proposes to transfer control of the contract to a new owner
"
"function pauseContribution ( bool _paused ) onlyOwner { paused = _paused ; }
","Pauses the contribution if there is any issue
"
"function withdrawAndSend ( address sendTo , uint256 amount ) public payable { require ( amount >= msg . value , ""NF_ET_NO_DEPOSIT"" ) ; if ( amount > msg . value ) { uint256 withdrawRemainder = amount - msg . value ; withdrawPrivate ( withdrawRemainder ) ; } emit LogWithdrawAndSend ( msg . sender , sendTo , amount ) ; sendTo . transfer ( amount ) ; }
","convenience function to withdraw and transfer to external account
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ! tokenFrozen ) ; allowances [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens on its behalf .
"
"function addAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , ""Invalid address."" ) ; require ( ! admins [ _address ] , ""This address is already an administrator."" ) ; require ( _address != owner ( ) , ""The owner cannot be added or removed to or from the administrator list."" ) ; admins [ _address ] = true ; emit AdminAdded ( _address ) ; return true ; }
","Adds the specified address to the list of administrators .
"
"function joinFraction ( uint256 _numerator , uint256 _denominator , int16 _scale ) private pure returns ( uint256 ) { if ( _scale >= 0 ) { assert ( _scale <= 77 ) ; return _numerator . mul ( 10 ** uint256 ( _scale ) ) / _denominator ; } else { return ( _numerator / _denominator ) / 10 ** uint256 ( - _scale ) ; } }
","Computes ( _numerator / _denominator ) 10 _scale
"
"function sqrt ( uint256 x ) public pure returns ( uint256 y ) { uint256 z = ( x + 1 ) / 2 ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / 2 ; } }
","Calculate square root of a uint ( It has some precision loss )
"
"function getAdminAddressArray ( ) public view returns ( address [ ] _arrayToReturn ) { _arrayToReturn = admins ; }
","Returns the array of admin addresses .
"
"function calcCommission ( uint _amount ) private view returns ( uint ) { return _amount . mul ( Commission ) / 100 ; }
","calculates the SolidStamp commmission
"
"function listToken ( address _stablecoin ) public onlyOwner whenNotPaused { tokenStorage_CD . addStablecoin ( _stablecoin ) ; }
","Add new stablecoin to whitelist .
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address ) ;
","Find the owner of an NFT
"
"function addUser ( address _user ) internal { if ( ! isAdded [ _user ] ) { users . push ( _user ) ; monthlyLimit [ _user ] = 5000000000000 ; isAdded [ _user ] = true ; } }
","Add the address to the user list
"
"function calculateExcessTokens ( uint256 amount , uint256 tokensThisTier , uint256 tierSelected , uint256 _rate ) public constant returns ( uint256 totalTokens ) { require ( amount > 0 && tokensThisTier > 0 && _rate > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; uint weiThisTier = tokensThisTier . sub ( tokensRaised ) . div ( _rate ) ; uint weiNextTier = amount . sub ( weiThisTier ) ; uint tokensNextTier = 0 ; if ( tierSelected != 4 ) tokensNextTier = calculateTokensTier ( weiNextTier , tierSelected . add ( 1 ) ) ; else msg . sender . transfer ( weiNextTier ) ; totalTokens = tokensThisTier . sub ( tokensRaised ) . add ( tokensNextTier ) ; }
","Buys the tokens for the specified tier and for the next one
"
"function setApprovalForAll ( address _operator , bool _approved ) external ;
","Enable or disable approval for a third party ( `` operator '' ) to manage all your asset .
"
"function setRegistryLogic ( address _newRegistryLogic ) public onlyOwner nonZero ( _newRegistryLogic ) { address _oldRegistryLogic = accountRegistryLogic ; accountRegistryLogic = _newRegistryLogic ; emit AccountRegistryLogicChanged ( _oldRegistryLogic , accountRegistryLogic ) ; }
","Change the address of the registry logic which has exclusive write control over this contract
"
"function burn ( uint256 amount ) public returns ( bool ) ;
","transferred
"
"function distributeVariable ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( ""Distribution Failed: Countdown not finished yet"" ) ; }
","Distirbutes a different quantity of tokens to all the specified addresses
"
"function delegateERC820Management ( address _newManager ) public onlyOwner { delegateManagement ( _newManager ) ; }
","sets the manager of register implementations of interfaces .
"
"function isTransferAllowed ( address _from , address _to , address , address _token , uint ) public view returns ( bool ) { if ( _token == token && ( ( oracles [ _from ] && _to == address ( this ) ) || ( _from == address ( this ) && whitelist [ _to ] ) ) ) { return true ; } }
","Restricts transfers only for : 1 ) oracle and only ATx tokens ; 2 ) from itself to holder
"
"function setInterfaceImplementer ( address _addr , bytes32 _interfaceHash , address _implementer ) external { address addr = _addr == 0 ? msg . sender : _addr ; require ( getManager ( addr ) == msg . sender , ""Not the manager"" ) ; require ( ! isERC165Interface ( _interfaceHash ) , ""Must not be a ERC165 hash"" ) ; if ( _implementer != 0 && _implementer != msg . sender ) { require ( ERC820ImplementerInterface ( _implementer ) . canImplementInterfaceForAddress ( addr , _interfaceHash ) == ERC820_ACCEPT_MAGIC , ""Does not implement the interface"" ) ; } interfaces [ addr ] [ _interfaceHash ] = _implementer ; emit InterfaceImplementerSet ( addr , _interfaceHash , _implementer ) ; }
","Sets the contract which implements a specific interface for an address .
"
"function vote ( string calldata _prjName ) external payable { require ( currentStage == StageName . inProgress , ""Vote disable now!"" ) ; require ( msg . value >= MINETHVOTE , ""Please send more ether!"" ) ; bytes32 hash = keccak256 ( bytes ( _prjName ) ) ; PrjProperties memory currentBet = projects [ hash ] ; require ( currentBet . prjAddress != address ( 0 ) , ""It seems like there is no item with that name"" ) ; projects [ hash ] . voteCount = currentBet . voteCount + 1 ; projects [ hash ] . prjWeiRaised = currentBet . prjWeiRaised + msg . value ; emit NewBet ( msg . sender , msg . value , _prjName ) ; if ( currentBet . voteCount + 1 > projects [ keccak256 ( bytes ( currentWinner ) ) ] . voteCount ) currentWinner = _prjName ; if ( now >= voteFinishDate ) currentStage = StageName . voteFinished ; emit VoteFinished ( msg . sender , uint64 ( now ) ) ; }
","Make vote for sender
"
"function frozenCellCount ( address owner ) public view returns ( uint ) { return frozenBalances [ owner ] . length ; }
","Number of frozen cells of an account .
"
"function finalizeCrowdfunding ( ) external { require ( getState ( ) == State . Success ) ; require ( ! finalizedCrowdfunding ) ; finalizedCrowdfunding = true ; balanceOf [ lockedTokenHolder ] = safeAdd ( balanceOf [ lockedTokenHolder ] , lockedTokens ) ; unlockedAtBlockNumber = block . number + numBlocksLocked ; emit Transfer ( 0 , lockedTokenHolder , lockedTokens ) ; balanceOf [ devsHolder ] = safeAdd ( balanceOf [ devsHolder ] , devsTokens ) ; emit Transfer ( 0 , devsHolder , devsTokens ) ; multiSigWalletAddress . transfer ( address ( this ) . balance ) ; }
","Finalize crowdfunding
"
"function getImageMetadata ( uint _imageId ) public view returns ( address , string , uint , string , uint , bytes32 [ ] ) { ImageMetadata memory metadata = imageMetadata [ _imageId ] ; return ( metadata . creator , metadata . extraData , metadata . finalSeed , metadata . ipfsHash , metadata . timestamp , metadata . potentialAssets ) ; }
","returns metadata of image
"
"function getChampReward ( uint256 _position ) public view returns ( uint256 ) { if ( _position <= 800 ) { uint256 rewardPercentage = uint256 ( 2000 ) . sub ( 2 * ( _position - 1 ) ) ; uint256 availableWithdrawal = address ( this ) . balance . sub ( pendingWithdrawal ) ; return availableWithdrawal / 1000000 * rewardPercentage ; } else { return uint256 ( 0 ) ; } }
","Gets champ 's reward in wei
"
"function withdrawInitialStake ( uint256 _stakeNumber ) public validInitialStakeRelease ( _stakeNumber ) returns ( bool ) { uint256 initialStake = stakes [ msg . sender ] [ _stakeNumber ] . initialStake ; stakes [ msg . sender ] [ _stakeNumber ] . state = StakeStateEnum . staked ; activeStakes = activeStakes . sub ( 1 ) ; internalRTCBalances [ msg . sender ] = internalRTCBalances [ msg . sender ] . sub ( initialStake ) ; emit InitialStakeWithdrawn ( msg . sender , _stakeNumber , initialStake ) ; require ( RTI . transfer ( msg . sender , initialStake ) , ""unable to transfer tokens likely due to incorrect balance"" ) ; return true ; }
","Used by a staker to withdraw their initial stake
"
"function emission ( uint256 _tokensCreatedInSTQ ) external onlymanyowners ( sha3 ( msg . data ) ) { emissionInternal ( _tokensCreatedInSTQ . mul ( uint256 ( 10 ) ** uint256 ( decimals ) ) ) ; }
","Starts new token emission
"
"function requireMultiple ( uint256 _amount ) internal view { require ( _amount % mGranularity == 0 , ""Amount is not a multiple of granualrity"" ) ; }
","Internal function that ensures ` _amount ` is multiple of the granularity
"
"function getTokensSold ( ) public view returns ( uint256 ) ;
","Returns the total no .
"
"function getReturnAddress ( address _addr ) constant returns ( address ) { if ( returnAddresses [ _addr ] == 0x0 ) { return _addr ; } else { return returnAddresses [ _addr ] ; } }
","This is a simple getter function that will be used to return the address that the WHG will return the funds to
"
"function addPackage ( string name ) onlyOwner public returns ( uint idPackage ) { idPackage = DAppNodePackages . length ++ ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; c . name = name ; PackageAdded ( idPackage , name ) ; }
","Add a new DAppNode package
"
"function anyRateIsStale ( bytes4 [ ] currencyKeys ) external view returns ( bool ) { uint256 i = 0 ; while ( i < currencyKeys . length ) { if ( currencyKeys [ i ] != ""sUSD"" && lastRateUpdateTimes [ currencyKeys [ i ] ] . add ( rateStalePeriod ) < now ) { return true ; } i += 1 ; } return false ; }
","Check if any of the currency rates passed in have n't been updated for longer than the stale period .
"
"function setUpgradeAgent ( address agent ) external { if ( getState ( ) != State . Success ) throw ; if ( agent == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; upgradeAgent = UpgradeAgent ( agent ) ; if ( ! upgradeAgent . isUpgradeAgent ( ) ) throw ; upgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( upgradeAgent ) ; }
","Set address of upgrade target contract and enable upgrade process .
"
"function validateTradeInput ( ERC20 src , uint srcAmount , address destAddress ) internal view returns ( bool ) { if ( ( srcAmount >= MAX_QTY ) || ( srcAmount == 0 ) || ( destAddress == 0 ) ) return false ; if ( src == ETH_TOKEN_ADDRESS ) { if ( msg . value != srcAmount ) return false ; } else { if ( ( msg . value != 0 ) || ( src . allowance ( msg . sender , this ) < srcAmount ) ) return false ; } return true ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function ownerFinishContract ( ) external onlyOwner { require ( contractStarted ) ; require ( ! contractFinished ) ; contractFinished = true ; }
","Finish contract ( permanently )
"
"function setNextUpgradeMaster ( address master ) external { if ( master == 0x0 ) revert ( ) ; if ( msg . sender != nextUpgradeMaster ) revert ( ) ; nextUpgradeMaster = master ; }
","Set address of next upgrade master and enable upgrade process .
"
"function isCompetitionAllowed ( address x ) view returns ( bool ) { return CompetitionInterface ( competitionAddress ) . isWhitelisted ( x ) && CompetitionInterface ( competitionAddress ) . isCompetitionActive ( ) ; }
","Checks whether an address is whitelisted in the competition contract and competition is active
"
"function destroyTokens ( address _owner , uint _amount ) onlyController public returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }
","Burns ` _amount ` tokens from ` _owner `
"
"function getChallengesForUser ( address user ) external view returns ( uint [ ] ) { require ( userToChallengeCount [ user ] > 0 , ""Has zero challenges"" ) ; uint [ ] memory result = new uint [ ] ( userToChallengeCount [ user ] ) ; uint counter = 0 ; for ( uint i = 0 ; i < challenges . length ; i ++ ) { if ( challengeToUser [ i ] == user ) { result [ counter ] = i ; counter ++ ; } } return result ; }
","Get Challenges For User
"
"function interfaceHash ( string _interfaceName ) external pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _interfaceName ) ) ; }
","Compute the keccak256 hash of an interface given its name .
"
"function burnRemainingTokens ( ) public onlyOwner mustBeAtStage ( Stage . Finalized ) { require ( MAX_TOKENS >= tokensFinalized ) ; uint unsold = MAX_TOKENS . sub ( tokensFinalized ) ; if ( unsold > 0 ) { token . burn ( unsold ) ; } }
","Call this function after finalizing
"
"function freezeMinting ( ) external isMintingAllowed ( ) isEnabled ( ""freezeMintingAllowed"" ) onlyOwner { mintingFrozen = true ; emit FreezeMinting ( now ) ; }
","Permanently freeze minting of this security token .
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public notTimeLocked stopInEmergency returns ( bool success ) { if ( balances [ _from ] < _amount ) { error ( 'transferFrom: the amount to transfer is higher than the token balance of the source' ) ; return false ; } if ( allowed [ _from ] [ msg . sender ] < _amount ) { error ( 'transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source' ) ; return false ; } if ( ! SCComplianceService . validate ( _from , _to , _amount ) ) { error ( 'transfer: not allowed by the compliance service' ) ; return false ; } balances [ _from ] = balances [ _from ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; emit Transfer ( _from , _to , _amount ) ; return true ; }
","deliberately authorized the sender of the message via some mechanism
"
"function mint ( address _receiver , uint256 _amount ) external authP ( MINT_ROLE , arr ( _receiver , _amount ) ) { require ( _isBalanceIncreaseAllowed ( _receiver , _amount ) , ERROR_MINT_BALANCE_INCREASE_NOT_ALLOWED ) ; _mint ( _receiver , _amount ) ; }
","Mint ` @ tokenAmount ( self.token ( ) : address , _amount , false ) ` tokens for ` _receiver `
"
"function onApprovalReceived ( address owner , uint256 value , bytes data ) external returns ( bytes4 ) ;
","Handle the approval of ERC1363 tokens
"
"function vote ( address _candidate ) returns ( bool ) ;
","Vote for ` _candidate ` as preferred Trustee .
"
"function metaBurnHash ( address _stablecoin , uint256 _amount , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , ""metaBurnCarbonDollar"" , _stablecoin , _amount , _nonce , _reward ) ) ; }
","Return hash containing all of the information about the burnCarbonDollar ( ) metatransaction
"
"function createDividendWithExclusions ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , address [ ] _excluded , bytes32 _name ) public withPerm ( MANAGE ) { uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _token , _amount , checkpointId , _excluded , _name ) ; }
","Creates a dividend and checkpoint for the dividend
"
"function getActiveProposals ( ) public view returns ( uint [ ] ) { uint count = 0 ; for ( uint i = 0 ; i < proposals . length ; i ++ ) { if ( checkIfCurrentlyActive ( i ) ) { count ++ ; } } uint [ ] memory activeProposals = new uint [ ] ( count ) ; count = 0 ; for ( i = 0 ; i < proposals . length ; i ++ ) { if ( checkIfCurrentlyActive ( i ) ) { activeProposals [ count ] = i ; count ++ ; } } return activeProposals ; }
","Get all active proposals
"
"function transferWithReference ( address _to , uint _value , string _reference ) public returns ( bool ) { if ( _to != 0x0 ) { return _transferWithReference ( _to , _value , _reference ) ; } }
","Transfers asset balance from the caller to specified receiver adding specified comment .
"
"function processContribution ( ) private isValidContribution returns ( uint256 , uint256 ) { if ( ! honourWhitelist ( ) ) { var ( allowedContribution , refundAmount ) = getAllowedContribution ( ) ; AllowedContributionCheck ( allowedContribution , AllowedContributionState . WhitelistClosed ) ; preSaleCap = preSaleCap . sub ( allowedContribution ) ; PresaleCapUpdated ( preSaleCap ) ; return ( allowedContribution , refundAmount ) ; } var ( whiteListedAllowedContribution , whiteListedRefundAmount ) = getAllowedContribution ( ) ; if ( whitelist [ msg . sender ] > 0 ) { return processWhitelistedContribution ( whiteListedAllowedContribution , whiteListedRefundAmount ) ; } revert ( ) ; }
","Returns the contribution to be used as part of the transaction , and any refund value if expected .
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( totalDistributed == hardCap && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else if ( state == State . PreSale && now > PreSaleDeadline ) { state = State . OnHold ; } else if ( state == State . MainSale && now > MainSaleDeadline ) { if ( totalDistributed >= softCap ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else { state = State . Failed ; completedAt = now ; emit LogFundingFailed ( totalRaised ) ; } } }
","check status
"
"function setTokenDecimals ( Data storage self , string currency , uint tokenDecimals ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.decimals' , currency ) ) ; require ( self . Storage . setUint ( id , tokenDecimals ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set the token decimals for Token interfaces
"
"function exchangeEtherForHavvens ( ) public payable pricesNotStale notPaused returns ( uint ) { uint havvensToSend = havvensReceivedForEther ( msg . value ) ; fundsWallet . transfer ( msg . value ) ; havven . transfer ( msg . sender , havvensToSend ) ; emit Exchange ( ""ETH"" , msg . value , ""HAV"" , havvensToSend ) ; return havvensToSend ; }
","Exchange ETH to HAV .
"
"function refund ( ) public { require ( state == State . Failed ) ; uint256 holderTokens = tokensSent [ msg . sender ] ; tokensSent [ msg . sender ] = 0 ; balance [ msg . sender ] = 0 ; uint256 holderETH = ethOnContract [ msg . sender ] ; ethOnContract [ msg . sender ] = 0 ; require ( tokenReward . transferFrom ( msg . sender , address ( this ) , holderTokens ) ) ; msg . sender . transfer ( holderETH ) ; emit LogRefund ( msg . sender , holderETH ) ; }
","Failure handler
"
"function multiTransferFrom ( address _from , address [ ] _to , uint256 [ ] _value ) returns ( bool success ) { }
","send a set of token to different address
"
"function submitBlock ( ) public nonSubmittedBlock ( block . number ) notCurrentSetBlock ( block . number ) returns ( bool ) { Blocks memory b = Blocks ( { number : block . number , coinbase : block . coinbase , state : BlockStateEnum . submitted } ) ; lastBlockSet = block . number ; blocks [ block . number ] = b ; emit BlockInformationSubmitted ( block . coinbase , block . number , msg . sender ) ; require ( RTI . mint ( msg . sender , SUBMISSIONREWARD ) , ""failed to transfer reward to block submitter"" ) ; return true ; }
","Used to submit block hash , and block miner information for the current block
"
"function getPlayer ( uint256 _tokenId ) public view returns ( string playerName , uint256 internalPlayerId , uint256 sellingPrice , address owner ) { Player storage player = players [ _tokenId ] ; playerName = player . name ; internalPlayerId = player . internalPlayerId ; sellingPrice = playerIndexToPrice [ _tokenId ] ; owner = playerIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific player .
"
"function getReferralBonus ( uint256 value ) view public returns ( uint256 ) { return value . mul ( baseRate ) . mul ( referralBonusPercent ) . div ( PERCENT_DIVIDER ) ; }
","Calculates referral bonus
"
"function calculateRawPoolAmount ( uint gameId ) internal view returns ( uint ) { return games [ gameId ] . amountToDraw . add ( games [ gameId ] . amountToTeamA . add ( games [ gameId ] . amountToTeamB ) ) ; }
","Returns the `` raw '' pool amount ( including the amount of the house cut )
"
"function getOpenOrders ( ) public view returns ( address [ ] ) { return openOrders . addresses ; }
","Gets all the open data orders , that is all the DataOrders that are still receiving new DataResponses .
"
"function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }
","Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address .
"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }
","Allows ` _spender ` to spend no more than ` _value ` tokens in msg.sender behalf
"
"function cosign ( uint index , uint256 cost ) external returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent && ( loan . dueTime - loan . duesIn ) == block . timestamp ) ; require ( loan . cosigner != address ( 0 ) ) ; require ( loan . cosigner == address ( uint256 ( msg . sender ) + 2 ) ) ; loan . cosigner = msg . sender ; require ( rcn . transferFrom ( loan . lender , msg . sender , cost ) ) ; return true ; }
","The cosigner must call this method to accept the conditions of a loan , this method pays the cosigner his fee .
"
"function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 36566900000 ; }
","maximum investments to be accepted during the sale ( in euro-cents )
"
"function ( ) payable { require ( isContract ( controller ) ) ; require ( TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function isAffiliateProgram ( ) public pure returns ( bool ) { return true ; }
","Exposes that this contract thinks it is an AffiliateProgram
"
"function withdrawEther ( ) external onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
","Owner : Withdraw Ether
"
"function setupStakingPriceFeed ( ) external { address ofStakingPriceFeed = new StakingPriceFeed ( address ( this ) , stakingToken , address ( this ) ) ; isStakingFeed [ ofStakingPriceFeed ] = true ; StakingPriceFeed ( ofStakingPriceFeed ) . setOwner ( msg . sender ) ; emit SetupPriceFeed ( ofStakingPriceFeed ) ; }
","Create a new StakingPriceFeed
"
"function _safeERC20Transfer ( ERC20 _token , address _to , uint _amount ) internal { require ( _to != 0 ) ; require ( _token . transferFrom ( msg . sender , _to , _amount ) ) ; }
","` _safeERC20Transfer ` is used internally when transfer a quantity of ERC20 tokens .
"
"function getTotalHashRate ( ) public constant returns ( uint256 ) { return getTotalHashRateOf ( msg . sender ) ; }
","Total hash rate of a miner
"
"function takeOwnership ( uint256 _tokenId ) public ;
","Allow pre-approved user to take ownership of a token .
"
"function paymentRewardTokensPriority ( uint256 _amount , uint256 _rewardPercentageIndex ) public { uint256 rewardTokensAvailable = rewardBalances [ msg . sender ] ; if ( rewardTokensAvailable >= _amount ) { paymentRewardTokens ( _amount ) ; } else { if ( rewardTokensAvailable > 0 ) { uint256 amountOfRegularTokens = _amount . sub ( rewardTokensAvailable ) ; paymentMixed ( amountOfRegularTokens , rewardTokensAvailable , _rewardPercentageIndex ) ; } else { paymentRegularTokens ( _amount , _rewardPercentageIndex ) ; } } }
","Process a payment that prioritizes the use of reward tokens .
"
"function _registerBid ( uint32 _canvasId , uint _amount ) internal stateBidding ( _canvasId ) returns ( uint commission , uint paintersRewards ) { uint _commission ; uint _rewards ; ( _commission , _rewards ) = splitBid ( _amount ) ; FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; _history . commissionCumulative . push ( _commission ) ; _history . rewardsCumulative . push ( _rewards ) ; return ( _commission , _rewards ) ; }
","Adds a bid to fee history .
"
"function setCommissions ( uint256 buyCommissionInWei , uint256 sellCommissionInWei ) isOwner { require ( buyCommissionInWei > 0 ) ; require ( sellCommissionInWei > 0 ) ; buyCommission = buyCommissionInWei ; sellCommission = buyCommissionInWei ; updatePrices ( ) ; }
","Set both commissions at the same time
"
"function name ( ) external view returns ( string _name ) { return nftName ; }
","A descriptive name for a collection of NFTs in this contract
"
"function updateRecipient ( address _newRecipient ) onlyContractor { if ( _newRecipient == 0 ) throw ; RecipientUpdated ( msg . sender , recipient , _newRecipient ) ; recipient = _newRecipient ; }
","Function to update the recipent address
"
"function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; require ( this . balance >= revenue ) ; commission = msg . value / commissionRate ; require ( address ( this ) . send ( commission ) ) ; msg . sender . transfer ( revenue ) ; }
","Sell tokens and receive ether from contract
"
"function getAllMyTokensForAllEtherOnContract ( ) { require ( icoExitIsPossible ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( currentTokenPrice > 1 ) ; uint256 amount = tokenBalanceOf [ msg . sender ] ; uint256 revenue = amount * currentTokenPrice / 2 ; require ( this . balance <= revenue ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( this . balance ) ; }
","Sell all of metadollars for all ether of this smartcontract
"
"function setupEventsHistory ( address _eventsHistory ) public onlyContractOwner returns ( uint errorCode ) { _setEventsHistory ( _eventsHistory ) ; return OK ; }
","Sets EventsHistory contract address .
"
"function getChallengesForMentor ( address mentor ) external view returns ( uint [ ] ) { require ( mentorToChallengeCount [ mentor ] > 0 , ""Has zero challenges"" ) ; uint [ ] memory result = new uint [ ] ( mentorToChallengeCount [ mentor ] ) ; uint counter = 0 ; for ( uint i = 0 ; i < challenges . length ; i ++ ) { if ( challengeToMentor [ i ] == mentor ) { result [ counter ] = i ; counter ++ ; } } return result ; }
","Get Challenges For Mentor
"
"function reparametrizeMultisig ( bytes32 msigId , uint unlockTime ) public payable { require ( multisigs [ msigId ] . owner == msg . sender ) ; Multisig storage multisig = multisigs [ msigId ] ; multisig . deposit = add ( multisig . deposit , msg . value ) ; assert ( multisig . unlockTime <= unlockTime ) ; multisig . unlockTime = unlockTime ; }
","Inititate/extend multisig unlockTime and/or initiate/refund multisig deposit
"
"function _modifyTicker ( address _owner , string _ticker , string _tokenName , uint256 _registrationDate , uint256 _expiryDate , bool _status ) internal { address currentOwner = _tickerOwner ( _ticker ) ; if ( currentOwner != address ( 0 ) ) { _deleteTickerOwnership ( currentOwner , _ticker ) ; } if ( _tickerStatus ( _ticker ) && ! _status ) { set ( Encoder . getKey ( ""tickerToSecurityToken"" , _ticker ) , address ( 0 ) ) ; } if ( _status ) { require ( getAddress ( Encoder . getKey ( ""tickerToSecurityToken"" , _ticker ) ) != address ( 0 ) , ""Token not registered"" ) ; } _addTicker ( _owner , _ticker , _tokenName , _registrationDate , _expiryDate , _status , true , uint256 ( 0 ) ) ; }
","Internal -- Modifies the ticker details .
"
"function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( hashIdToMultisig [ msigId ] . owner == msg . sender ) ; require ( hashIdToMultisig [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= now + 86400 ) ; require ( amount > 0 ) ; hashIdToMultisig [ msigId ] . deposit -= amount + fee ; swapId = keccak256 ( msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; AtomicSwap storage swap = hashIdToSwap [ swapId ] ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; hashIdToMultisig [ msigId ] . authority . transfer ( fee ) ; }
","Convert swap from multisig to htlc mode
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }
","Function transfers '_value ' tokens from '_from ' to '_to ' if there is allowance
"
"function doTransfer ( uint64 from , uint64 to , uint _amount ) internal { uint amount = callPlugins ( true , from , to , _amount ) ; if ( from == to ) { return ; } if ( amount == 0 ) { return ; } Pledge storage nFrom = findPledge ( from ) ; Pledge storage nTo = findPledge ( to ) ; require ( nFrom . amount >= amount ) ; nFrom . amount -= amount ; nTo . amount += amount ; Transfer ( from , to , amount ) ; callPlugins ( false , from , to , amount ) ; }
","` doTransfer ` is designed to allow for pledge amounts to be shifted around internally .
"
"function registerForCompetition ( address fund , address manager , address buyinAsset , address payoutAsset , address payoutAddress , uint buyinQuantity , uint8 v , bytes32 r , bytes32 s ) pre_cond ( termsAndConditionsAreSigned ( manager , v , r , s ) && isKYCVerified ( msg . sender ) ) pre_cond ( registeredFundToRegistrants [ fund ] == address ( 0 ) && registrantToHopefulIds [ msg . sender ] . exists == false ) { require ( buyinAsset == MELON_ASSET && payoutAsset == MELON_ASSET ) ; require ( buyinQuantity <= maxbuyinQuantity && hopefuls . length <= maxHopefulsNumber ) ; registeredFundToRegistrants [ fund ] = msg . sender ; registrantToHopefulIds [ msg . sender ] = HopefulId ( { id : hopefuls . length , exists : true } ) ; Register ( hopefuls . length , fund , msg . sender ) ; hopefuls . push ( Hopeful ( { fund : fund , manager : manager , registrant : msg . sender , hasSigned : true , buyinAsset : buyinAsset , payoutAsset : payoutAsset , payoutAddress : payoutAddress , buyinQuantity : buyinQuantity , payoutQuantity : 0 , isCompeting : true , isDisqualified : false , finalSharePrice : 0 , finalCompetitionRank : 0 } ) ) ; }
","Register to take part in the competition
"
"function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = ""Percentage"" ; availableTags [ 1 ] = ""Transfer Restriction"" ; return availableTags ; }
","Get the tags related to the module factory
"
"function requestDividends ( ) external { payDividendsTo ( msg . sender ) ; }
","Request dividends for current account .
"
"function unpauseIssuance ( ) public onlyOwner whenNotPaused { require ( _issuancePaused ) ; _issuancePaused = false ; emit IssuanceUnpaused ( ) ; }
","Unpause issuance of new attributes by organizations .
"
"function canIssueAttributeType ( uint256 attributeTypeID ) external view returns ( bool ) ;
","Check if the validator is approved to issue attributes of the type with ID ` attributeTypeID ` on the jurisdiction .
"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( ! freezeTransfer || isOps ( ) , ""all transfers are currently frozen"" ) ; require ( _spender != address ( 0 ) , ""zero address is not allowed"" ) ; require ( _value >= 1000 , ""must approve more than 1000 sip"" ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","Approve the passed address to spend the specified amount of tokens on behalf of the transactor .
"
"function setOwner ( Campaign storage _campaign , address _owner ) internal { _campaign . owner = _owner ; }
","Set campaign owner
"
"function withdrawTokens ( address [ ] tokens ) public onlyContractOwner { address _contractOwner = contractOwner ; for ( uint i = 0 ; i < tokens . length ; i ++ ) { ERC20Interface token = ERC20Interface ( tokens [ i ] ) ; uint balance = token . balanceOf ( this ) ; if ( balance > 0 ) { token . transfer ( _contractOwner , balance ) ; } } }
","Withdraw given tokens from contract to owner .
"
"function isValidator ( address _validator ) public view returns ( bool ) { return validators [ _validator ] ; }
","does validator exist ?
"
"function tokensOfOwner ( address _owner ) external view returns ( uint [ ] ownerTokens ) { uint tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint [ ] ( 0 ) ; } else { uint [ ] memory result = new uint [ ] ( tokenCount ) ; uint totalCats = totalSupply ( ) ; uint resultIndex = 0 ; uint rabbitId ; for ( rabbitId = 1 ; rabbitId <= totalCats ; rabbitId ++ ) { if ( rabbitToOwner [ rabbitId ] == _owner ) { result [ resultIndex ] = rabbitId ; resultIndex ++ ; } } return result ; } }
","Returns a list of all Rabbit IDs assigned to an address .
"
"function isRegularAddress ( address _addr ) internal view returns ( bool ) { if ( _addr == 0 ) { return false ; } uint size ; assembly { size := extcodesize ( _addr ) } return size == 0 ; }
","Check whether an address is a regular address or not .
"
"function createCanvas ( ) external returns ( uint canvasId ) { require ( canvases . length < MAX_CANVAS_COUNT ) ; require ( activeCanvasCount < MAX_ACTIVE_CANVAS ) ; uint id = canvases . push ( Canvas ( STATE_NOT_FINISHED , 0x0 , 0 , 0 , false ) ) - 1 ; emit CanvasCreated ( id ) ; activeCanvasCount ++ ; return id ; }
","Creates new canvas .
"
"function transferToContractWithCustomFallback ( address _to , uint _value , bytes _data , string _custom_fallback ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; assert ( _to . call . value ( 0 ) ( bytes4 ( keccak256 ( _custom_fallback ) ) , msg . sender , _value , _data ) ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
","Function that is called when transaction target is contract with custom fallback
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] = allowance [ _from ] [ msg . sender ] . sub ( _value ) ; _transfer ( _from , _to , _value ) ; return true ; }
","Transfer tokens from other address
"
"function withdrawPayments ( ) external { m_funds . withdrawPayments ( msg . sender ) ; }
","refund
"
"function clearTradePreSignedHashing ( address _investContract , address _trader , bytes32 _strategyID , address _follower , uint256 _investedAmount , int256 _profitAmount , string _causeToClear ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x29b26bc1 ) , _investContract , _trader , _strategyID , _follower , _investedAmount , _profitAmount , _causeToClear ) ) ; }
","Hash ( keccak256 ) of the payload used by clearTrade
"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) ;
","Returns the amount which _spender is still allowed to withdraw from _owner
"
"function claimBonus ( ) external { require ( msg . sender . balance / ( 1000 finney ) >= 1 && ! claimedBonus [ msg . sender ] ) ; claimedBonus [ msg . sender ] = true ; allowed [ selfAddress ] [ msg . sender ] = allowed [ selfAddress ] [ msg . sender ] + 200000000 ; IOUSupply += 200000000 ; addUser ( msg . sender ) ; Approval ( selfAddress , msg . sender , allowed [ selfAddress ] [ msg . sender ] ) ; }
","Advertising Token Distribution
"
"function ownerSetAllowPublicWithdraw ( bool status ) public onlyOwner { allowPublicWithdraw = status ; }
","owner restricted function
"
"function totalSupply ( ) external constant returns ( uint256 _totalSupply ) { return totalSupply ; }
","Check the total supply of the token ~ ERC-20 Standard
"
"function creatorTotal ( address _creator ) public view validAddress ( _creator ) returns ( uint256 ) { return createdTokens [ _creator ] . length ; }
","Get the total number of PixelCons created by ` ( _creator ) `
"
"function getCurrentBuyOffer ( uint32 _canvasId ) external view returns ( bool hasOffer , address buyer , uint amount ) { BuyOffer storage offer = buyOffers [ _canvasId ] ; return ( offer . hasOffer , offer . buyer , offer . amount ) ; }
","Returns current buy offer for the canvas .
"
"function countValidators ( ) external view returns ( uint256 ) { return _validatorAccounts . length ; }
","Count the number of validators defined by the jurisdiction .
"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }
","Shows how much tokens _spender can spend from _owner address
"
"function changeContractOwnership ( address _to ) public onlyContractOwner returns ( bool ) { if ( _to == 0x0 ) { return false ; } pendingContractOwner = _to ; return true ; }
","Prepares ownership pass .
"
"function setAccountRegistry ( AccountRegistryInterface _newRegistry ) public nonZero ( _newRegistry ) onlyOwner { address oldRegistry = registry ; registry = _newRegistry ; emit AccountRegistryChanged ( oldRegistry , registry ) ; }
","Change the address of AccountRegistry , which enables authorization of subject comments
"
"function gameOver ( ) external gameIsNotOver onlyOwner { isGameOver = true ; }
","Ends game
"
"function getWaifu ( uint256 _tokenId ) public view returns ( string waifuName , uint256 sellingPrice , address owner ) { Waifu storage waifu = waifus [ _tokenId ] ; waifuName = waifu . name ; sellingPrice = waifuIndexToPrice [ _tokenId ] ; owner = waifuIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific waifu .
"
"function transferOwnership ( address _newOwner ) onlyOwner { balances [ _newOwner ] = safeAdd ( balances [ owner ] , balances [ _newOwner ] ) ; balances [ owner ] = 0 ; Ownable . transferOwnership ( _newOwner ) ; }
","To transfer token contract ownership
"
"function getTokensSold ( ) public view returns ( uint256 ) { if ( isFinalized ) return totalTokensSold ; else return getTokensMinted ( ) ; }
","Return the total no .
"
"function requestMortgageId ( Engine engine , uint256 loanId , uint256 deposit , uint256 landId , TokenConverter tokenConverter ) public returns ( uint256 id ) { require ( engine . getCurrency ( loanId ) == MANA_CURRENCY , ""Loan currency is not MANA"" ) ; address borrower = engine . getBorrower ( loanId ) ; require ( engine . getStatus ( loanId ) == Engine . Status . initial , ""Loan status is not inital"" ) ; require ( msg . sender == engine . getBorrower ( loanId ) || ( msg . sender == engine . getCreator ( loanId ) && creators [ msg . sender ] ) , ""Creator should be borrower or authorized"" ) ; require ( engine . isApproved ( loanId ) , ""Loan is not approved"" ) ; require ( rcn . allowance ( borrower , this ) >= REQUIRED_ALLOWANCE , ""Manager cannot handle borrower's funds"" ) ; require ( tokenConverter != address ( 0 ) , ""Token converter not defined"" ) ; require ( loanToLiability [ engine ] [ loanId ] == 0 , ""Liability for loan already exists"" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 loanAmount = engine . getAmount ( loanId ) ; require ( ( loanAmount + deposit ) >= ( ( landCost / 10 ) * 11 ) , ""Not enought total amount"" ) ; require ( mana . transferFrom ( msg . sender , this , deposit ) ) ; id = mortgages . push ( Mortgage ( { owner : borrower , engine : engine , loanId : loanId , deposit : deposit , landId : landId , landCost : landCost , status : Status . Pending , tokenConverter : tokenConverter } ) ) - 1 ; loanToLiability [ engine ] [ loanId ] = id ; emit RequestedMortgage ( { _id : id , _borrower : borrower , _engine : engine , _loanId : loanId , _landId : landId , _deposit : deposit , _tokenConverter : tokenConverter } ) ; }
","Request a mortgage with a loan id
"
"function burn ( uint256 _value ) returns ( bool success ) { require ( balanceOf [ msg . sender ] > _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( ""pMinDeposit"" ) ; bytes32 propID = keccak256 ( _name , _value ) ; if ( keccak256 ( _name ) == keccak256 ( ""dispensationPct"" ) || keccak256 ( _name ) == keccak256 ( ""pDispensationPct"" ) ) { require ( _value <= 100 ) ; } require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now . add ( get ( ""pApplyStageLen"" ) ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now . add ( get ( ""pApplyStageLen"" ) ) . add ( get ( ""pCommitStageLen"" ) ) . add ( get ( ""pRevealStageLen"" ) ) . add ( PROCESSBY ) , value : _value } ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; emit _ReparameterizationProposal ( _name , _value , propID , deposit , proposals [ propID ] . appExpiry , msg . sender ) ; return propID ; }
","propose a reparamaterization of the key _name 's value to _value .
"
"function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = recoverPreSignedHash ( address ( this ) , approvalSig , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; require ( _nonce == nonces [ from ] . add ( 1 ) ) ; require ( _value . add ( _fee ) <= balances [ from ] ) ; nonces [ from ] = _nonce ; signatures [ _signature ] = true ; allowed [ from ] [ _spender ] = _value ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned approval
"
"function getTypes ( ) external view returns ( uint8 [ ] ) { uint8 [ ] memory res = new uint8 [ ] ( 1 ) ; res [ 0 ] = 2 ; return res ; }
","Type of the Module factory
"
"function getDecimals ( address token ) internal view returns ( uint256 decimals ) { bytes4 functionSig = bytes4 ( keccak256 ( ""decimals()"" ) ) ; assembly { let ptr := mload ( 0x40 ) mstore ( ptr , functionSig ) let functionSigLength := 0x04 let wordLength := 0x20 let success := call ( 5000 , token , 0 , ptr , functionSigLength , ptr , wordLength ) switch success case 0 { decimals := 18 } case 1 { decimals := mload ( ptr ) } mstore ( 0x40 , add ( ptr , 0x04 ) ) } }
","Retrieve the number of decimals used for a given ERC20 token
"
"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; return address ( new EtherDividendCheckpoint ( msg . sender , address ( polyToken ) ) ) ; }
","used to launch the Module with the help of factory
"
"function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; checkValue ( from , _fee ) ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
","Decrease the amount of tokens that an owner allowed to a spender .
"
"function isPendingRegistration ( address _darknodeID ) external view returns ( bool ) { uint256 registeredAt = store . darknodeRegisteredAt ( _darknodeID ) ; return registeredAt != 0 && registeredAt > currentEpoch . blocknumber ; }
","Returns whether a darknode is scheduled to become registered at next epoch .
"
"function totalSupply ( ) public view returns ( uint ) { return masterpieces . length ; }
","Required for ERC-20 and ERC-721 compliance .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( balances [ msg . sender ] >= _value && _value > 0 ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","` _value ` tokens will be sended to ` _to `
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( ( _to == address ( this ) ) || ( _to == 0 ) ) { return sell ( msg . sender , _value ) ; } else { return super . transfer ( _to , _value ) ; } }
","Transfer or sell tokens Sells tokens transferred to this contract itself or to zero address
"
"function getTotalSupply ( ) external view returns ( uint256 ) { return totalSupply ; }
","Get total supply
"
"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool ) ;
","Transfer ` _amount ` of tokens from ` _from ` to ` _to `
"
"function setDefaultReputationReward ( uint256 _defaultReputationReward ) public onlyOwner returns ( bool ) { require ( _defaultReputationReward > 0 , ""new reputation reward must be greater than zero"" ) ; require ( _defaultReputationReward != defaultReputationReward , ""new reputation reward must be different"" ) ; defaultReputationReward = _defaultReputationReward ; emit DefaultReputationRewardUpdated ( msg . sender , _defaultReputationReward ) ; return true ; }
","sets the default reputation reward for new manufacturers
"
"function collectTokens ( ) public onlyController { uint256 balance = aix . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 canExtract = total . mul ( extractablePercentage ( ) ) . div ( 100 ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; require ( aix . transfer ( controller , canExtract ) ) ; TokensWithdrawn ( controller , canExtract ) ; }
","The Dev ( Owner ) will call this method to extract the tokens
"
"function credit ( address _affiliate , uint256 _purchaseId ) public onlyStoreOrOwner whenNotPaused payable { require ( msg . value > 0 ) ; require ( _affiliate != address ( 0 ) ) ; balances [ _affiliate ] += msg . value ; lastDepositTimes [ _affiliate ] = now ; lastDepositTime = now ; AffiliateCredit ( _affiliate , _purchaseId , msg . value ) ; }
","credit an affiliate for a purchase
"
"function cancelAuction ( uint256 _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenId ] ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenId , seller ) ; }
","This is a state-modifying function that can be called while the contract is paused .
"
"function metaTransfer ( address _to , uint256 _amount , bytes _signature , uint256 _nonce , uint256 _reward ) public userNotBlacklisted ( _to ) whenNotPaused returns ( bool ) { bytes32 metaHash = metaTransferHash ( _to , _amount , _nonce , _reward ) ; address signer = _getSigner ( metaHash , _signature ) ; require ( ! regulator . isBlacklistedUser ( signer ) , ""signer is blacklisted"" ) ; require ( _nonce == replayNonce [ signer ] , ""this transaction has already been broadcast"" ) ; replayNonce [ signer ] ++ ; require ( _reward > 0 , ""reward to incentivize relayer must be positive"" ) ; require ( ( _amount + _reward ) <= balanceOf ( signer ) , ""not enough balance to transfer and reward relayer"" ) ; _transfer ( _to , signer , _amount ) ; _transfer ( msg . sender , signer , _reward ) ; return true ; }
","Verify and broadcast a transfer ( ) signed metatransaction .
"
"function changeMinInvestment ( uint _newMin ) external onlyOwner { emit ChangeMinInvestment ( msg . sender , minInvestment , _newMin ) ; minInvestment = _newMin ; }
","allows owner to change the minInvestment in case of extreme price jumps of ETH price .
"
"function bid ( ) public payable atStage ( Stages . AuctionStarted ) { require ( msg . value > 0 ) ; assert ( bids [ msg . sender ] + msg . value >= msg . value ) ; uint missingFunds = missingFundsToEndAuction ( ) ; require ( msg . value <= missingFunds ) ; bids [ msg . sender ] += msg . value ; receivedWei += msg . value ; BidSubmission ( msg . sender , msg . value , missingFunds ) ; assert ( receivedWei >= msg . value ) ; }
","Send ` msg.value ` WEI to the auction from the ` msg.sender ` account .
"
"function doSend ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( mBalances [ _from ] >= _amount ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; }
","Helper function actually performing the sending of tokens .
"
"function initiateSelfDestruct ( ) external onlyOwner { initiationTime = now ; selfDestructInitiated = true ; emit SelfDestructInitiated ( SELFDESTRUCT_DELAY ) ; }
","Begin the self-destruction counter of this contract .
"
"function name ( ) public pure returns ( string _deedName ) ;
","A descriptive name for a collection of deeds managed by this contract
"
"function getOrganizationInformation ( address organization ) external view returns ( bool exists , uint256 maximumAccounts , string name , address [ ] issuedAccounts ) { return ( _organizations [ organization ] . exists , _organizations [ organization ] . maximumAccounts , _organizations [ organization ] . name , _organizations [ organization ] . accounts ) ; }
","Get information about the organization at account ` account ` .
"
"function _setTickerOwnership ( address _owner , string _ticker ) internal { bytes32 _ownerKey = Encoder . getKey ( ""userToTickers"" , _owner ) ; uint256 length = uint256 ( getArrayBytes32 ( _ownerKey ) . length ) ; pushArray ( _ownerKey , Util . stringToBytes32 ( _ticker ) ) ; set ( Encoder . getKey ( ""tickerIndex"" , _ticker ) , length ) ; bytes32 seenKey = Encoder . getKey ( ""seenUsers"" , _owner ) ; if ( ! getBool ( seenKey ) ) { pushArray ( Encoder . getKey ( ""activeUsers"" ) , _owner ) ; set ( seenKey , true ) ; } }
","Internal - Sets the ticker owner
"
"function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }
","Retrieves the token balance of any single address .
"
"function setGod ( address _newGod ) external requireGod { require ( _newGod != address ( 0 ) ) ; godAddress = _newGod ; }
","Assigns a new address to act as the God .
"
"function getProperty ( uint256 _id ) public view returns ( uint32 parent , uint8 class , uint8 x , uint8 y , uint8 z , uint8 dx , uint8 dz , uint8 height ) { Property storage property = properties [ _id ] ; parent = uint32 ( property . parent ) ; class = uint8 ( property . class ) ; height = uint8 ( property . y ) ; if ( property . class == PropertyClass . BUILDING ) { y = uint8 ( _computeHeight ( property . x , property . z , property . y ) ) ; } else { y = uint8 ( property . y ) ; } x = uint8 ( property . x ) ; z = uint8 ( property . z ) ; dx = uint8 ( property . dx ) ; dz = uint8 ( property . dz ) ; }
","Returns all the relevant information about a specific property .
"
"function pollEnded ( uint _pollID ) constant public returns ( bool ended ) { require ( pollExists ( _pollID ) ) ; return isExpired ( pollMap [ _pollID ] . revealEndDate ) ; }
","Determines if poll is over
"
"function getOperator ( address _operator , address _tokenHolder ) external view returns ( bool ) { return mAuthorized [ _operator ] [ _tokenHolder ] ; }
","Getting operator ` _operator ` for ` _tokenHolder `
"
"function emitCampaignCreated ( CampaignLibrary . Campaign storage campaign ) private { emit CampaignCreated ( campaign . getBidId ( ) , campaign . getPrice ( ) , campaign . getBudget ( ) , campaign . getStartDate ( ) , campaign . getEndDate ( ) , campaign . getValidity ( ) , campaign . getOwner ( ) ) ; }
","Function to emit campaign creations It emits a CampaignCreated event with the new campaign created .
"
"function getAccountSpendingRemaining ( Data storage self , address account ) internal view returns ( uint remainingLimit ) { return getAccountSpendingLimit ( self , account ) . sub ( getAccountSpendingAmount ( self , account ) ) ; }
","Return the amount remaining during the current period
"
"function defaultOperators ( ) external view returns ( address [ ] ) { return mDefaultOperators ; }
","Return the list of default operators
"
"function setNewMultisig ( address _wallet ) public onlyEthealMultisig { require ( _wallet != address ( 0 ) ) ; ethealMultisigWallet = _wallet ; }
","Set new multisig wallet , to make it upgradable .
"
"function addUserContract ( address _contract ) external auth returns ( uint ) { address _owner = Owned ( _contract ) . contractOwner ( ) ; if ( ! _addUserContract ( _contract , _owner ) ) { return _emitErrorCode ( USER_REGISTRY_USER_CONTRACT_ALREADY_EXISTS ) ; } _emitter ( ) . emitUserContractAdded ( _contract , _owner ) ; return OK ; }
","Registers a contract and associate it with its owner .
"
"function getCollectionName ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bytes8 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; return collectionNames [ _collectionIndex ] ; }
","Get the name of collection # ` ( _collectionIndex ) `
"
"function getPricePerToken ( ) public constant returns ( uint256 price ) { if ( balances [ selfAddress ] > 200000000000000 ) { return 50 ; } else if ( balances [ selfAddress ] > 150000000000000 ) { return 200 ; } else if ( balances [ selfAddress ] > 100000000000000 ) { return 400 ; } else { return 550 ; } }
","Get the current 2-decimal precision price per token
"
"function refund ( ) external { if ( ! funding ) throw ; if ( block . number <= fundingEndBlock ) throw ; if ( totalTokens >= tokenCreationMin ) throw ; bool isEarlyBacker = false ; uint256 ethValue ; for ( uint i = 0 ; i < earlyBackers . length ; i ++ ) { if ( earlyBackers [ i ] . backerAddress == msg . sender ) { isEarlyBacker = true ; ethValue = earlyBackers [ i ] . deposited ; if ( ethValue == 0 ) throw ; } } if ( ! isEarlyBacker ) { var bpntValue = balances [ msg . sender ] ; if ( bpntValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalTokens -= bpntValue ; ethValue = bpntValue / tokenCreationRate ; } Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }
","Get back the ether sent during the funding in case the funding has not reached the minimum level .
"
"function requestBounty ( ) external { require ( releasedBountyTokens ) ; require ( getState ( ) == State . Success ) ; assert ( bounties [ msg . sender ] > 0 ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , bounties [ msg . sender ] ) ; emit BountyTransfer ( msg . sender , bounties [ msg . sender ] , block . number ) ; emit Transfer ( 0 , msg . sender , bounties [ msg . sender ] ) ; bounties [ msg . sender ] = 0 ; }
","request to receive bounty tokens
"
"function changeOwner ( address _newOwner ) onlyOwner public returns ( bool ) { require ( _newOwner != address ( 0 ) ) ; newOwner = _newOwner ; return true ; }
","` owner ` can step down and assign some other address to this role
"
"function getTypes ( ) external view returns ( uint8 [ ] ) { uint8 [ ] memory res = new uint8 [ ] ( 1 ) ; res [ 0 ] = 1 ; return res ; }
","Type of the Module factory
"
"function calcTokensAvailableToBuyback ( ) view public returns ( uint256 ) { return address ( this ) . balance . mul ( rate ) ; }
","Calculates how much BOB tokens this contract can buy ( during current buyback round )
"
"function balanceOfAt ( address _owner , uint _blockNumber ) constant returns ( uint ) { if ( _blockNumber < creationBlock ) { return 0 ; } else if ( ( balances [ _owner ] . length == 0 ) || ( balances [ _owner ] [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . balanceOfAt ( _owner , parentSnapShotBlock ) ; } else { return 0 ; } } else { return getValueAt ( balances [ _owner ] , _blockNumber ) ; } }
","Queries the balance of ` _owner ` at a specific ` _blockNumber `
"
"function generateTokens ( address _owner , uint _amount ) public onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; emit Transfer ( 0 , _owner , _amount ) ; return true ; }
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function setNeuroChainAddress ( string neurochainAddress ) public { neuroChainAddresses [ msg . sender ] = neurochainAddress ; NeuroChainAddressSet ( msg . sender , neurochainAddress , block . timestamp , false ) ; }
","Permit ` msg.sender ` to set its NeuroChain Address
"
"function ( ) payable internal { uint amount = msg . value * buyPrice + 70e18 ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value >= 0 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
","Buy tokens from contract by sending ethereum to contract address with no minimum contribution
"
"function claimReward ( uint _challengeID , uint _salt ) public { require ( challenges [ _challengeID ] . tokenClaims [ msg . sender ] == false ) ; require ( challenges [ _challengeID ] . resolved == true ) ; uint voterTokens = voting . getNumPassingTokens ( msg . sender , _challengeID , _salt ) ; uint reward = voterReward ( msg . sender , _challengeID , _salt ) ; challenges [ _challengeID ] . winningTokens -= voterTokens ; challenges [ _challengeID ] . rewardPool -= reward ; challenges [ _challengeID ] . tokenClaims [ msg . sender ] = true ; _RewardClaimed ( _challengeID , reward , msg . sender ) ; require ( token . transfer ( msg . sender , reward ) ) ; }
","claim the tokens owed for the msg.sender in the provided challenge
"
"function revoke ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; require ( beneficiary . revocable ) ; require ( ! beneficiary . revoked ) ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; uint256 unreleased = releasableAmount ( _beneficiary ) ; uint256 refund = balance . sub ( unreleased ) ; token . transfer ( owner , refund ) ; totalReleased = totalReleased . add ( refund ) ; beneficiary . revoked = true ; beneficiary . released = beneficiary . released . add ( refund ) ; emit Revoked ( _beneficiary ) ; }
","Allows the owner to revoke the vesting .
"
"function updateRewardVaultContract ( DarknodeRewardVault _newRewardVaultContract ) external onlyOwner { emit LogRewardVaultContractUpdated ( rewardVaultContract , _newRewardVaultContract ) ; rewardVaultContract = _newRewardVaultContract ; }
","Allows the owner of the contract to update the address of the DarknodeRewardVault contract .
"
"function ( ) payable external { if ( ! funding ) throw ; if ( block . number < fundingStartBlock ) throw ; if ( block . number > fundingEndBlock ) throw ; if ( msg . value == 0 ) throw ; if ( msg . value > ( tokenCreationCap - totalTokens ) / tokenCreationRate ) throw ; var numTokens = msg . value * tokenCreationRate ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
","Create tokens when funding is active .
"
"function getAttributesForAssets ( uint [ ] _ids ) public view returns ( uint [ ] ) { uint [ ] memory attributes = new uint [ ] ( _ids . length ) ; for ( uint i = 0 ; i < _ids . length ; i ++ ) { Asset memory asset = assets [ _ids [ i ] ] ; attributes [ i ] = asset . attributes ; } return attributes ; }
","method that returns attributes for many assets
"
"function countOfDeeds ( ) external view returns ( uint256 _count ) ;
","Count deeds tracked by this contract
"
"function totalSupply ( ) constant public returns ( uint coinLifeTimeTotalSupply ) { return totalSupply ; }
","Show the ` totalSupply ` for this Token contract
"
"function setMaxDevMintAmount ( uint _amount ) public onlyOwner returns ( bool ) { require ( _amount < maxAmount ) ; maxAmount = _amount ; emit DevEmissionSetLower ( _amount ) ; return ( true ) ; }
","20m coin Supply required to start Transitional phase 70m of totalSupply required to start Promotional stage
"
"function proxyPayment ( address _owner ) public payable returns ( bool ) { revert ( ) ; return false ; }
","proxyPayment implements MiniMeToken Controller 's proxyPayment
"
"function addPermission ( address _delegate , bytes32 _details ) public withPerm ( CHANGE_PERMISSION ) { delegateDetails [ _delegate ] = _details ; emit LogAddPermission ( _delegate , _details , now ) ; }
","use to add the details of the delegate
"
"function exist ( MapStorage storage self , address _key ) public view returns ( bool ) { if ( _key != address ( 0 ) ) { uint targetIndex = self . addressToIndex [ _key ] ; return targetIndex < self . addresses . length && self . addresses [ targetIndex ] == _key ; } else { return false ; } }
","Checks if the given address exists in the storage .
"
"function getLastRegisterDate ( ) internal view returns ( uint32 ) { uint32 [ ] memory dates = userToDates [ msg . sender ] ; uint256 pastRegisterCount = dates . length ; if ( pastRegisterCount == 0 ) { return 0 ; } return dates [ pastRegisterCount . sub ( 1 ) ] ; }
","Does n't change state
"
"function setSynth ( Synth _synth ) external onlyOwner { synth = _synth ; emit SynthUpdated ( _synth ) ; }
","Set the Synth contract that the issuance controller uses to issue Synths .
"
"function liquidateBorrow ( address targetAccount , address assetBorrow , address assetCollateral , uint requestedAmountClose ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . LIQUIDATE_CONTRACT_PAUSED ) ; } LiquidateLocalVars memory localResults ; localResults . targetAccount = targetAccount ; localResults . assetBorrow = assetBorrow ; localResults . liquidator = msg . sender ; localResults . assetCollateral = assetCollateral ; Market storage borrowMarket = markets [ assetBorrow ] ; Market storage collateralMarket = markets [ assetCollateral ] ; Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances [ targetAccount ] [ assetBorrow ] ; Balance storage supplyBalance_TargetCollateralAsset = supplyBalances [ targetAccount ] [ assetCollateral ] ; Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances [ localResults . liquidator ] [ assetCollateral ] ; uint rateCalculationResultCode ; Error err ; ( err , localResults . collateralPrice ) = fetchAssetPrice ( assetCollateral ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_FETCH_ASSET_PRICE_FAILED ) ; } ( err , localResults . underwaterAssetPrice ) = fetchAssetPrice ( assetBorrow ) ; assert ( err == Error . NO_ERROR ) ; ( err , localResults . newBorrowIndex_UnderwaterAsset ) = calculateInterestIndex ( borrowMarket . borrowIndex , borrowMarket . borrowRateMantissa , borrowMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET ) ; } ( err , localResults . currentBorrowBalance_TargetUnderwaterAsset ) = calculateBalance ( borrowBalance_TargeUnderwaterAsset . principal , borrowBalance_TargeUnderwaterAsset . interestIndex , localResults . newBorrowIndex_UnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . newSupplyIndex_CollateralAsset ) = calculateInterestIndex ( collateralMarket . supplyIndex , collateralMarket . supplyRateMantissa , collateralMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET ) ; } ( err , localResults . currentSupplyBalance_TargetCollateralAsset ) = calculateBalance ( supplyBalance_TargetCollateralAsset . principal , supplyBalance_TargetCollateralAsset . interestIndex , localResults . newSupplyIndex_CollateralAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET ) ; } ( err , localResults . currentSupplyBalance_LiquidatorCollateralAsset ) = calculateBalance ( supplyBalance_LiquidatorCollateralAsset . principal , supplyBalance_LiquidatorCollateralAsset . interestIndex , localResults . newSupplyIndex_CollateralAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET ) ; } ( err , localResults . newTotalSupply_ProtocolCollateralAsset ) = addThenSub ( collateralMarket . totalSupply , localResults . currentSupplyBalance_TargetCollateralAsset , supplyBalance_TargetCollateralAsset . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET ) ; } ( err , localResults . newTotalSupply_ProtocolCollateralAsset ) = addThenSub ( localResults . newTotalSupply_ProtocolCollateralAsset , localResults . currentSupplyBalance_LiquidatorCollateralAsset , supplyBalance_LiquidatorCollateralAsset . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET ) ; } ( err , localResults . discountedBorrowDenominatedCollateral ) = calculateDiscountedBorrowDenominatedCollateral ( localResults . underwaterAssetPrice , localResults . collateralPrice , localResults . currentSupplyBalance_TargetCollateralAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED ) ; } if ( borrowMarket . isSupported ) { ( err , localResults . discountedRepayToEvenAmount ) = calculateDiscountedRepayToEvenAmount ( targetAccount , localResults . underwaterAssetPrice ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED ) ; } localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset = min ( localResults . currentBorrowBalance_TargetUnderwaterAsset , localResults . discountedBorrowDenominatedCollateral ) ; localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset = min ( localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset , localResults . discountedRepayToEvenAmount ) ; } else { localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset = min ( localResults . currentBorrowBalance_TargetUnderwaterAsset , localResults . discountedBorrowDenominatedCollateral ) ; } if ( requestedAmountClose == uint ( - 1 ) ) { localResults . closeBorrowAmount_TargetUnderwaterAsset = localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset ; } else { localResults . closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose ; } if ( localResults . closeBorrowAmount_TargetUnderwaterAsset > localResults . maxCloseableBorrowAmount_TargetUnderwaterAsset ) { return fail ( Error . INVALID_CLOSE_AMOUNT_REQUESTED , FailureInfo . LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH ) ; } ( err , localResults . seizeSupplyAmount_TargetCollateralAsset ) = calculateAmountSeize ( localResults . underwaterAssetPrice , localResults . collateralPrice , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED ) ; } err = checkTransferIn ( assetBorrow , localResults . liquidator , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE ) ; } ( err , localResults . updatedBorrowBalance_TargetUnderwaterAsset ) = sub ( localResults . currentBorrowBalance_TargetUnderwaterAsset , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; assert ( err == Error . NO_ERROR ) ; ( err , localResults . newTotalBorrows_ProtocolUnderwaterAsset ) = addThenSub ( borrowMarket . totalBorrows , localResults . updatedBorrowBalance_TargetUnderwaterAsset , borrowBalance_TargeUnderwaterAsset . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET ) ; } localResults . currentCash_ProtocolUnderwaterAsset = getCash ( assetBorrow ) ; ( err , localResults . updatedCash_ProtocolUnderwaterAsset ) = add ( localResults . currentCash_ProtocolUnderwaterAsset , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET ) ; } ( err , localResults . newSupplyIndex_UnderwaterAsset ) = calculateInterestIndex ( borrowMarket . supplyIndex , borrowMarket . supplyRateMantissa , borrowMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa_ProtocolUnderwaterAsset ) = borrowMarket . interestRateModel . getSupplyRate ( assetBorrow , localResults . updatedCash_ProtocolUnderwaterAsset , localResults . newTotalBorrows_ProtocolUnderwaterAsset ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET , rateCalculationResultCode ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa_ProtocolUnderwaterAsset ) = borrowMarket . interestRateModel . getBorrowRate ( assetBorrow , localResults . updatedCash_ProtocolUnderwaterAsset , localResults . newTotalBorrows_ProtocolUnderwaterAsset ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET , rateCalculationResultCode ) ; } ( err , localResults . newBorrowIndex_CollateralAsset ) = calculateInterestIndex ( collateralMarket . borrowIndex , collateralMarket . borrowRateMantissa , collateralMarket . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET ) ; } ( err , localResults . updatedSupplyBalance_TargetCollateralAsset ) = sub ( localResults . currentSupplyBalance_TargetCollateralAsset , localResults . seizeSupplyAmount_TargetCollateralAsset ) ; assert ( err == Error . NO_ERROR ) ; ( err , localResults . updatedSupplyBalance_LiquidatorCollateralAsset ) = add ( localResults . currentSupplyBalance_LiquidatorCollateralAsset , localResults . seizeSupplyAmount_TargetCollateralAsset ) ; assert ( err == Error . NO_ERROR ) ; err = doTransferIn ( assetBorrow , localResults . liquidator , localResults . closeBorrowAmount_TargetUnderwaterAsset ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . LIQUIDATE_TRANSFER_IN_FAILED ) ; } borrowMarket . blockNumber = getBlockNumber ( ) ; borrowMarket . totalBorrows = localResults . newTotalBorrows_ProtocolUnderwaterAsset ; borrowMarket . supplyRateMantissa = localResults . newSupplyRateMantissa_ProtocolUnderwaterAsset ; borrowMarket . supplyIndex = localResults . newSupplyIndex_UnderwaterAsset ; borrowMarket . borrowRateMantissa = localResults . newBorrowRateMantissa_ProtocolUnderwaterAsset ; borrowMarket . borrowIndex = localResults . newBorrowIndex_UnderwaterAsset ; collateralMarket . blockNumber = getBlockNumber ( ) ; collateralMarket . totalSupply = localResults . newTotalSupply_ProtocolCollateralAsset ; collateralMarket . supplyIndex = localResults . newSupplyIndex_CollateralAsset ; collateralMarket . borrowIndex = localResults . newBorrowIndex_CollateralAsset ; localResults . startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset . principal ; borrowBalance_TargeUnderwaterAsset . principal = localResults . updatedBorrowBalance_TargetUnderwaterAsset ; borrowBalance_TargeUnderwaterAsset . interestIndex = localResults . newBorrowIndex_UnderwaterAsset ; localResults . startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset . principal ; supplyBalance_TargetCollateralAsset . principal = localResults . updatedSupplyBalance_TargetCollateralAsset ; supplyBalance_TargetCollateralAsset . interestIndex = localResults . newSupplyIndex_CollateralAsset ; localResults . startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset . principal ; supplyBalance_LiquidatorCollateralAsset . principal = localResults . updatedSupplyBalance_LiquidatorCollateralAsset ; supplyBalance_LiquidatorCollateralAsset . interestIndex = localResults . newSupplyIndex_CollateralAsset ; emitLiquidationEvent ( localResults ) ; return uint ( Error . NO_ERROR ) ; }
","users repay all or some of an underwater borrow and receive collateral
"
"function transfer ( address , uint256 ) returns ( bool ) { }
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) public returns ( address ) ;
","deploys the token and adds default modules like permission manager and transfer manager .
"
"function setSellCommission ( uint256 sellCommissionInWei ) isOwner { require ( sellCommissionInWei > 0 ) ; require ( sellCommission != sellCommissionInWei ) ; buyCommission = sellCommissionInWei ; updatePrices ( ) ; }
","Set current Sell Commission price in wei for one metadollar
"
"function registerModule ( address _moduleFactory ) external returns ( bool ) ;
","Called by moduleFactory owner to register new modules for SecurityToken to use
"
"function takeOwnershipMultiple ( uint256 [ ] _deedIds ) public whenNotPaused { for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; address _from = identifierToOwner [ _deedId ] ; require ( _approvedFor ( msg . sender , _deedId ) ) ; _transfer ( _from , msg . sender , _deedId ) ; } }
","Transfer multiple deeds owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function updateBurnAgent ( address _agent , bool _status ) public onlyOwner { burnAgents [ _agent ] = _status ; }
","update burn agent
"
"function approve ( uint256 _index , uint256 _tokenId ) internal { Offer memory localOffer = offers [ _index ] ; address newOwner = localOffer . from ; address prevOwner = token . getOwner ( _tokenId ) ; uint256 platformShare ; uint256 forPrevOwner ; uint256 soldPrice = token . getTokenSoldPrice ( _tokenId ) ; ( platformShare , forPrevOwner ) = pricingStrategy . calculateSharesInTheRevenue ( soldPrice , localOffer . offeredPrice ) ; token . updateTokensState ( _tokenId , localOffer . offeredPrice ) ; token . updateOwner ( _tokenId , newOwner , prevOwner ) ; localOffer . accepted = true ; transferEthers ( platformWallet , platformShare ) ; transferEthers ( prevOwner , forPrevOwner . add ( soldPrice ) ) ; emit OfferApproved ( newOwner , _tokenId , localOffer . offerId , localOffer . offeredPrice , now ) ; emit Purchased ( prevOwner , newOwner , _tokenId , localOffer . offeredPrice , soldPrice , forPrevOwner . add ( soldPrice ) , platformShare , now ) ; afterApproveAction ( _tokenId ) ; }
","approve the offer
"
"function approveAndCall ( address _spender , uint256 _value , bytes _data ) external returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; iApprover ( _spender ) . receiveApproval ( msg . sender , _value , address ( this ) , _data ) ; return true ; }
","Approves and then calls the receiving contract
"
"function isAffiliateValid ( address _investor ) constant public returns ( bool ) { Affiliate memory affiliate = affiliates [ _investor ] ; AffiliateReceived ( affiliate . etherAddress , _investor , affiliate . isPresent ) ; return affiliate . isPresent ; }
","Checks if an affiliate is valid
"
"function ( ) public payable atState ( State . Sale ) { byTokens ( ) ; }
","http : //solidity.readthedocs.io/en/develop/contracts.html # fallback-function we dont need recieve ETH always , only in State.Sale from externally accounts .
"
"function withdraw ( ) public onlyIfWhitelisted ( ""withdraw"" , msg . sender ) { uint256 balance = ExtendedFinance ( address ( _getFinance ( ) ) ) . getRewardsBalance ( msg . sender ) ; ExtendedFinance ( address ( _getFinance ( ) ) ) . withdrawRewards ( msg . sender , balance ) ; }
","Function to withdraw PoA convertions This function is restricted to addresses allowed to submit bulk PoAs and enable those addresses to withdraw funds previously collected by bulk PoA submissions
"
"function calculateStake ( uint256 _numRTC ) internal view returns ( uint256 blockLocked , uint256 blockReleased , uint256 releaseDate , uint256 totalCoinsMinted , uint256 rewardPerBlock ) { blockLocked = block . number ; blockReleased = blockLocked . add ( BLOCKHOLDPERIOD ) ; releaseDate = now . add ( BLOCKHOLDPERIOD . mul ( BLOCKSEC ) ) ; totalCoinsMinted = _numRTC . mul ( MULTIPLIER ) ; totalCoinsMinted = totalCoinsMinted . div ( 1 ether ) ; rewardPerBlock = totalCoinsMinted . div ( BLOCKHOLDPERIOD ) ; }
","This is a helper function used to calculate the parameters of a stake Will determine the block that the initial stake can be withdraw at Will determine the time that the initial stake can be withdrawn at Will determine the total number of RTC to be minted throughout hte stake Will determine how many RTC the stakee will be awarded per block
"
"function crowdsaleSucceeded ( ) public { require ( msg . sender == crowdsaleAddress ) ; crowdsaleSuccessful = true ; }
","set crowdsaleSuccessful to true
"
"function burn ( uint256 _value ) onlyOwner returns ( bool success ) { require ( balances [ msg . sender ] > _value ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function receiveEther ( ) payable { EtherReceived ( msg . sender , msg . value ) ; }
","Called anytime ether is sent to the contract & & creates an event to more easily track the incoming transactions
"
"function _addModule ( address _moduleFactory , bytes _data , uint256 _maxCost , uint256 _budget ) internal { IModuleRegistry ( moduleRegistry ) . useModule ( _moduleFactory ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; uint8 moduleType = moduleFactory . getType ( ) ; require ( modules [ moduleType ] . length < MAX_MODULES , ""Limit of MAX MODULES is reached"" ) ; uint256 moduleCost = moduleFactory . setupCost ( ) ; require ( moduleCost <= _maxCost , ""Max Cost is always be greater than module cost"" ) ; require ( ERC20 ( polyToken ) . approve ( _moduleFactory , moduleCost ) , ""Not able to approve the module cost"" ) ; address module = moduleFactory . deploy ( _data ) ; require ( ERC20 ( polyToken ) . approve ( module , _budget ) , ""Not able to approve the budget"" ) ; bytes32 moduleName = moduleFactory . getName ( ) ; modules [ moduleType ] . push ( ModuleData ( moduleName , module ) ) ; emit LogModuleAdded ( moduleType , moduleName , _moduleFactory , module , moduleCost , _budget , now ) ; }
","_addModule handles the attachment ( or replacement ) of modules for the ST
"
"function createTokens ( address beneficiary , uint amount ) onlyController returns ( bool success ) { if ( sealed ( ) ) throw ; balances [ beneficiary ] += amount ; totalSupply += amount ; Transfer ( 0 , beneficiary , amount ) ; return true ; }
","` createTokens ( ) ` will create tokens if the campaign has not been sealed .
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value < allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` in behalf of ` _from `
"
"function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceSignature_ERC721Enumerable ) || ( _interfaceID == InterfaceSignature_ERC721Metadata ) ) ; }
","Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
"
"function setParetoToken ( address _token ) public onlyOwner { token = ERC20 ( _token ) ; ParetoAddress = _token ; }
","this function sets the address of Pareto Token
"
"function ( ) payable { process_contribution ( msg . sender ) ; }
","This function handles receiving Ether
"
"function getOrdersForBuyer ( address buyer ) public view validAddress ( buyer ) returns ( address [ ] ) { return ordersByBuyer [ buyer ] ; }
","Gets all the data orders associated with a buyer .
"
"function blockID ( uint8 x , uint8 y ) public pure returns ( uint16 ) { return ( uint16 ( y ) - 1 ) * 100 + uint16 ( x ) ; }
","get ERC721 token id corresponding to xy coordinates
"
"function setTokenBurner ( address _tokenBurner ) public onlyOwner { tokenBurner = ITokenBurner ( _tokenBurner ) ; }
","used to set the token Burner address .
"
"function execBuyBack ( uint256 _qty ) public { require ( now > 1539561600 ) ; uint256 toPay = _qty * buyBackPrice ; require ( balanceOf [ msg . sender ] >= _qty ) ; require ( buyBackPrice > 0 ) ; require ( bbBalance >= toPay ) ; require ( frozenAccount [ msg . sender ] < now ) ; msg . sender . transfer ( toPay ) ; bbBalance -= toPay ; burn ( _qty ) ; }
","Allow user to sell CDRT tokens and destroy them .
"
"function deregisterBroker ( address _broker ) external onlyOwner { require ( brokers [ _broker ] , ""not registered"" ) ; brokers [ _broker ] = false ; emit LogBrokerDeregistered ( _broker ) ; }
","Reverts the a broker 's registration .
"
"function successful ( ) public { require ( state == State . Successful ) ; if ( claimed == false ) { claimed = true ; address writer = 0xEB53AD38f0C37C0162E3D1D4666e63a55EfFC65f ; writer . transfer ( 5 ether ) ; uint256 remanent = hardCap . sub ( totalDistributed ) ; tokenReward . transfer ( creator , remanent ) ; emit LogContributorsPayout ( creator , remanent ) ; } creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
","successful closure handler
"
"function burnTokens ( uint256 _tokens ) external { require ( ! locked ) ; require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( depositAddress != address ( 0 ) ) ; require ( _tokens != 0 ) ; require ( _tokens <= balances [ depositAddress ] ) ; balances [ depositAddress ] = balances [ depositAddress ] . sub ( _tokens ) ; totalSupply_ = totalSupply_ . sub ( _tokens ) ; emit TokensBurned ( msg . sender , depositAddress , _tokens ) ; }
","Called when tokens have to be burned ( only after sale )
"
"function tokenMetadata ( uint256 index ) public view returns ( string ) { return loans [ index ] . metadata ; }
","Returns the loan metadata , this field can be set by the creator of the loan with his own criteria .
"
"function request_close ( ) { data . request_close ( ) ; ChannelCloseRequested ( msg . sender , data . closed ) ; }
","Request to close the channel .
"
"function attachSubscriptionModule ( SubscriptionModule subModule ) noAnyReentrancy external only ( owner ) { SUBSCRIPTION_MODULE = subModule ; if ( address ( subModule ) > 0 ) subModule . attachToken ( this ) ; }
","attach module managing subscriptions .
"
"function distrust ( ) external checkTrust ( msg . sender , contractOwner ) returns ( uint ) { holders [ getHolderId ( msg . sender ) ] . trust [ contractOwner ] = false ; return OK ; }
","Revoke trust to perform recovery procedure from an address .
"
"function transferBalanceWithFee ( address _traderFrom , address _traderTo , address _token , uint256 _value , uint256 _fee , address _feePayee ) external onlyRenExSettlementContract { require ( traderBalances [ _traderFrom ] [ _token ] >= _fee , ""insufficient funds for fee"" ) ; if ( address ( _token ) == ETHEREUM ) { rewardVaultContract . deposit . value ( _fee ) ( _feePayee , ERC20 ( _token ) , _fee ) ; } else { CompatibleERC20 ( _token ) . safeApprove ( rewardVaultContract , _fee ) ; rewardVaultContract . deposit ( _feePayee , ERC20 ( _token ) , _fee ) ; } privateDecrementBalance ( _traderFrom , ERC20 ( _token ) , _value + _fee ) ; if ( _value > 0 ) { privateIncrementBalance ( _traderTo , ERC20 ( _token ) , _value ) ; } }
","Transfer a token value from one trader to another , transferring a fee to the RewardVault .
"
"function locationsLength ( ) public view returns ( uint ) { return locations . length ; }
","Number of locations in the hunt
"
"function delegatedRefund ( address _address ) public { internalRefund ( _address ) ; }
","refund ethers to delegate
"
"function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive call .
"
"function getCard ( uint256 _tokenId ) public view returns ( string slug , uint256 price , address owner ) { Card storage card = cards [ _tokenId ] ; slug = card . slug ; price = cardIndexToPrice [ _tokenId ] ; owner = cardIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific card .
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; uint256 [ ] memory result = new uint256 [ ] ( tokenCount + commonPlayerCount ) ; uint256 resultIndex = 0 ; uint256 playerId ; for ( playerId = 1 ; playerId <= commonPlayerCount ; playerId ++ ) { result [ resultIndex ] = playerId ; resultIndex ++ ; } if ( tokenCount == 0 ) { return result ; } else { uint256 totalPlayers = totalSupply ( ) ; for ( ; playerId < totalPlayers ; playerId ++ ) { if ( playerIndexToOwner [ playerId ] == _owner ) { result [ resultIndex ] = playerId ; resultIndex ++ ; } } return result ; } }
","Returns a list of all Player IDs assigned to an address .
"
"function requestUnlock ( bytes32 _lockId , address _callbackAddress , bytes4 _callbackSelector , address _whitelistedAddress ) public payable returns ( bytes32 requestMsgHash ) { require ( msg . sender == primary || msg . value >= 1 ether ) ; require ( _callbackAddress != address ( 0 ) ) ; uint256 requestIdx = ++ requestCount ; uint256 nonce = uint256 ( keccak256 ( block . blockhash ( block . number - 1 ) , address ( this ) , requestIdx ) ) ; requestMsgHash = keccak256 ( nonce , _whitelistedAddress , uint256 ( 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ) ; requestMap [ requestMsgHash ] = Request ( { lockId : _lockId , callbackSelector : _callbackSelector , callbackAddress : _callbackAddress , idx : requestIdx , timestamp : block . timestamp , extended : false } ) ; uint256 timeLockExpiry = block . timestamp ; if ( msg . sender == primary ) { timeLockExpiry += defaultTimeLock ; } else { timeLockExpiry += extendedTimeLock ; requestMap [ requestMsgHash ] . extended = true ; } emit Requested ( _lockId , _callbackAddress , _callbackSelector , nonce , _whitelistedAddress , requestMsgHash , timeLockExpiry ) ; }
","Requests an unlocking with a lock identifier and a callback .
"
"function burnFrom ( address _from , uint256 _value ) public returns ( bool success ) { require ( balanceOf [ _from ] >= _value ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balanceOf [ _from ] -= _value ; allowance [ _from ] [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( _from , _value ) ; return true ; }
","Destroy tokens in another account .
"
"function addStoneToBoard ( uint boardId , uint8 row , uint8 col ) external { GoBoard storage board = allBoards [ boardId ] ; PlayerColor activeColor = getPlayerColor ( board , msg . sender ) ; require ( board . status == BoardStatus . InProgress && board . nextTurnColor == activeColor ) ; uint8 position = row * BOARD_ROW_SIZE + col ; require ( board . positionToColor [ position ] == 0 ) ; if ( updatePlayerTime ( board , boardId , activeColor ) ) { board . positionToColor [ position ] = uint8 ( activeColor ) ; updateCaptures ( board , position , uint8 ( activeColor ) ) ; nextTurn ( board ) ; if ( board . didPassPrevTurn ) { board . didPassPrevTurn = false ; } StoneAddedToBoard ( boardId , activeColor , row , col ) ; } }
","Adding a stone to a specific board and position ( row & col ) .
"
"function _createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) internal { ISecurityToken securityTokenInstance = ISecurityToken ( securityToken ) ; require ( _excluded . length <= EXCLUDED_ADDRESS_LIMIT , ""Too many addresses excluded"" ) ; require ( _expiry > _maturity , ""Expiry before maturity"" ) ; require ( _expiry > now , ""Expiry in past"" ) ; require ( _amount > 0 , ""No dividend sent"" ) ; require ( _token != address ( 0 ) , ""Invalid token"" ) ; require ( _checkpointId <= securityTokenInstance . currentCheckpointId ( ) , ""Invalid checkpoint"" ) ; require ( IERC20 ( _token ) . transferFrom ( msg . sender , address ( this ) , _amount ) , ""insufficent allowance"" ) ; require ( _name [ 0 ] != 0 ) ; uint256 dividendIndex = dividends . length ; uint256 currentSupply = securityTokenInstance . totalSupplyAt ( _checkpointId ) ; uint256 excludedSupply = 0 ; dividends . push ( Dividend ( _checkpointId , now , _maturity , _expiry , _amount , 0 , 0 , false , 0 , 0 , _name ) ) ; for ( uint256 j = 0 ; j < _excluded . length ; j ++ ) { require ( _excluded [ j ] != address ( 0 ) , ""Invalid address"" ) ; require ( ! dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] , ""duped exclude address"" ) ; excludedSupply = excludedSupply . add ( securityTokenInstance . balanceOfAt ( _excluded [ j ] , _checkpointId ) ) ; dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] = true ; } dividends [ dividendIndex ] . totalSupply = currentSupply . sub ( excludedSupply ) ; dividendTokens [ dividendIndex ] = _token ; _emitERC20DividendDepositedEvent ( _checkpointId , _maturity , _expiry , _token , _amount , currentSupply , dividendIndex , _name ) ; }
","Creates a dividend with a provided checkpoint
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint tokenId ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 || _index >= tokenCount ) { revert ( ) ; } else { uint256 totalLoans = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 loanId ; for ( loanId = 0 ; loanId <= totalLoans ; loanId ++ ) { if ( loans [ loanId ] . lender == _owner && loans [ loanId ] . status == Status . lent ) { if ( resultIndex == _index ) { return loanId ; } resultIndex ++ ; } } revert ( ) ; } }
","Maps the indices of lenders loans to tokens ids
"
"function getInvestorsLength ( ) public view returns ( uint256 ) { return investors . length ; }
","gets length of investors array NB - this length may differ from investorCount if list has not been pruned of zero balance investors
"
"function revokeAttestationFor ( address _sender , bytes32 _link , bytes32 _nonce , bytes _delegationSig ) external { validateRevokeForSig ( _sender , _link , _nonce , _delegationSig ) ; revokeAttestationForUser ( _link , _sender ) ; }
","Revoke an attestation
"
"function totalSupply ( ) public view returns ( uint256 ) { return pixelcons . length ; }
","Get the total number of PixelCons in existence
"
"function externalTokensRecovery ( token _address ) onlyAdmin public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
","Function to claim any token stuck on contract
"
"function deprecateInterface ( ) public onlyOwner returns ( bool deprecated ) { require ( lib . setDeprecatedContract ( address ( this ) ) , ""Error: Unable to deprecate contract!"" ) ; return true ; }
","gets currency status of contract
"
"function exchangeEtherForNominsAtRate ( uint guaranteedRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToEthPrice ) ; return exchangeEtherForNomins ( ) ; }
","Exchange ETH to nUSD while insisting on a particular rate .
"
"function createCollection ( uint64 [ ] _tokenIndexes , bytes8 _name ) public returns ( uint64 ) { require ( collectionNames . length < uint256 ( 2 ** 64 ) - 1 , ""Max number of collections has been reached"" ) ; require ( _tokenIndexes . length > 1 , ""Collection must contain more than one PixelCon"" ) ; uint64 collectionIndex = uint64 ( collectionNames . length ) ; uint64 [ ] storage collection = collectionTokens [ collectionIndex ] ; collection . length = _tokenIndexes . length ; for ( uint i = 0 ; i < _tokenIndexes . length ; i ++ ) { uint64 tokenIndex = _tokenIndexes [ i ] ; require ( tokenIndex < totalSupply ( ) , ""PixelCon index is out of bounds"" ) ; PixelCon storage pixelcon = pixelcons [ tokenIndex ] ; require ( isCreatorAndOwner ( msg . sender , pixelcon . tokenId ) , ""Sender is not the creator and owner of the PixelCons"" ) ; require ( pixelcon . collectionIndex == uint64 ( 0 ) , ""PixelCon is already in a collection"" ) ; pixelcon . collectionIndex = collectionIndex ; collection [ i ] = tokenIndex ; } collectionNames . length ++ ; collectionNames [ collectionIndex ] = _name ; emit CreateCollection ( msg . sender , collectionIndex ) ; return collectionIndex ; }
","Create PixelCon collection
"
"function payer ( address who ) public constant returns ( uint count , address [ ] origins ) { address [ ] memory m_origins = s_paid [ who ] ; return ( m_origins . length , m_origins ) ; }
","Returns for the given address the number of times it was paid for , and an array of addresses who actually paid for the fee ( as one might pay the fee for another address )
"
"function doPayment ( uint _idDeposit , address _dest , ERC20 _token , uint _amount ) internal returns ( bool ) { if ( _amount == 0 ) return true ; if ( address ( _token ) == 0 ) { if ( ! _dest . send ( _amount ) ) return false ; } else { if ( ! _token . transfer ( _dest , _amount ) ) return false ; } Withdraw ( _idDeposit , _dest , _token , _amount ) ; return true ; }
","Transfers ` amount ` of ` token ` to ` dest ` , only used internally , and does not throw , will always return ` true ` or ` false `
"
"function setCancelAnnounceDelay ( uint32 _delay ) external onlyOwner notMoreThanMaxDelay ( _delay ) { cancelAnnounceDelay = _delay ; }
","Sets the delay between when a cancel intention must be announced , and when the cancellation can actually be executed on-chain
"
"function setCampaignValidById ( bytes32 bidId , bool isValid ) public onlyIfCampaignExists ( ""setCampaignValidById"" , bidId ) onlyIfWhitelisted ( ""setCampaignValidById"" , msg . sender ) { campaigns [ bidId ] . setValidity ( isValid ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
","Set a new campaign validity state .
"
"function setRoyaltyInformationContract ( address _royaltyInformationContract ) public onlyAdmin notFrozen returns ( bool set ) { royaltyInformationContract = _royaltyInformationContract ; RoyaltyInformationContractSet ( msg . sender , _royaltyInformationContract , true ) ; return true ; }
","used to set the royalty information contract
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = personIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function setAttributeTypeMinimumRequiredStake ( uint256 ID , uint256 minimumRequiredStake ) external ;
","Set a minimum required stake for a given attribute type ID ` ID ` and an amount of ` stake ` , to be locked in the jurisdiction upon assignment of attributes of the given type .
"
"function topUpBalance ( uint verifyCode ) public payable mustBeAtStage ( Stage . Running ) { require ( msg . value > 0 ) ; require ( verifyCode == 28391728448 ) ; }
","This function must be used only if this contract balance is too low for oraclize_query to be executed
"
"function getState ( uint256 _tokenId ) public view returns ( string stateName , uint256 sellingPrice , address owner ) { State storage state = states [ _tokenId ] ; stateName = state . name ; sellingPrice = stateIndexToPrice [ _tokenId ] ; owner = stateIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific state .
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = gameItemIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function offerToChannel ( address _channelAccount , uint256 _venAmount ) onlyOwner { Stage stg = stage ( ) ; require ( stg == Stage . Early || stg == Stage . Normal || stg == Stage . Closed ) ; soldOut . channels = _venAmount . add ( soldOut . channels ) . toUINT120 ( ) ; require ( soldOut . channels <= channelsLimit ) ; ven . mint ( _channelAccount , _venAmount , true , blockTime ( ) ) ; onSold ( _channelAccount , _venAmount , 0 ) ; }
","manually offer tokens to channel
"
"function setRealityCheck ( address addr ) onlyOwner public { realitycheck = RealityCheck ( addr ) ; LogSetRealityCheck ( addr ) ; }
","Set the Reality Check contract address
"
"function ( ) external payable { address nftAddress = address ( nonFungibleContract ) ; require ( msg . sender == address ( this ) || msg . sender == gameManagerPrimary || msg . sender == gameManagerSecondary || msg . sender == bankManager || msg . sender == nftAddress ) ; }
","No tipping !
"
"function setRegistryAdmin ( address _newRegistryAdmin ) public onlyOwner nonZero ( _newRegistryAdmin ) { address _oldRegistryAdmin = registryAdmin ; registryAdmin = _newRegistryAdmin ; emit RegistryAdminChanged ( _oldRegistryAdmin , registryAdmin ) ; }
","Change the address of the registryAdmin , who has the privilege to create new accounts
"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( this , target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function burn ( uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value , ""insufficient sender balance"" ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; _totalSupply = safeSub ( _totalSupply , _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }
","Burn tokens belonging to the sender
"
"function addAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , ""Invalid address."" ) ; require ( ! admins [ _address ] , ""This address is already an administrator."" ) ; require ( _address != owner , ""The owner cannot be added or removed to or from the administrator list."" ) ; admins [ _address ] = true ; emit AdminAdded ( _address ) ; return true ; }
","Adds the specified address to the list of administrators .
"
"function setMtdPreAmount ( uint256 mtdPreAmountInWei ) isOwner { require ( mtdPreAmountInWei > 0 ) ; require ( mtdPreAmount != mtdPreAmountInWei ) ; mtdPreAmount = mtdPreAmountInWei ; updatePrices ( ) ; }
","Set current mtdPreAmount price in wei for one token
"
"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == 0 ) { return 0 ; } c = a * b ; assert ( c / a == b ) ; return c ; }
","Multiplies two numbers , throws on overflow .
"
"function transfer ( address _to , uint256 _value ) public whenNotPaused returns ( bool success ) { require ( _value > 0 ) ; require ( balanceOf [ msg . sender ] >= _value ) ; require ( balanceOf [ _to ] + _value >= balanceOf [ _to ] ) ; balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","function transfer which will move tokens from user account to an address specified at to parameter
"
"function setPeonyAddress ( address _address ) onlyOwner returns ( bool ) { require ( _address != 0x0 ) ; peony = _address ; return true ; }
","Set address of Peony contract .
"
"function submitAnswerByArbitrator ( bytes32 question_id , bytes32 answer , address answerer ) onlyOwner public { delete arbitration_bounties [ question_id ] ; realitycheck . submitAnswerByArbitrator ( question_id , answer , answerer ) ; }
","Submit the arbitrator 's answer to a question .
"
"function onTransferReceived ( address _operator , address _from , uint256 _value , bytes _data ) external returns ( bytes4 ) ;
","Handle the receipt of ERC1363 tokens
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; emit NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function transferOwnership ( address newOwner ) onlyOwner public { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; }
","Allows the current owner to transfer control of the contract to a newOwner .
"
"function buyTokens ( ) public payable whenNotPaused { require ( validPurchase ( ) ) ; uint256 tokens = 0 ; uint256 amountPaid = calculateExcessBalance ( ) ; if ( tokensRaised < limitTier1 ) { tokens = amountPaid . mul ( rate ) ; if ( tokensRaised . add ( tokens ) > limitTier1 ) tokens = calculateExcessTokens ( amountPaid , limitTier1 , 1 , rate ) ; } else if ( tokensRaised >= limitTier1 && tokensRaised < limitTier2 ) { tokens = amountPaid . mul ( rateTier2 ) ; if ( tokensRaised . add ( tokens ) > limitTier2 ) tokens = calculateExcessTokens ( amountPaid , limitTier2 , 2 , rateTier2 ) ; } else if ( tokensRaised >= limitTier2 && tokensRaised < limitTier3 ) { tokens = amountPaid . mul ( rateTier3 ) ; if ( tokensRaised . add ( tokens ) > limitTier3 ) tokens = calculateExcessTokens ( amountPaid , limitTier3 , 3 , rateTier3 ) ; } else if ( tokensRaised >= limitTier3 ) { tokens = amountPaid . mul ( rateTier4 ) ; } weiRaised = weiRaised . add ( amountPaid ) ; tokensRaised = tokensRaised . add ( tokens ) ; token . distributeICOTokens ( msg . sender , tokens ) ; tokensBought [ msg . sender ] = tokensBought [ msg . sender ] . add ( tokens ) ; TokenPurchase ( msg . sender , amountPaid , tokens ) ; numberOfTransactions = numberOfTransactions . add ( 1 ) ; forwardFunds ( amountPaid ) ; }
","To buy tokens given an address
"
"function vote ( string name ) external payable { _vote ( name , msg . value , msg . sender ) ; }
","Voting .
"
"function withdrawMyDepositedSynths ( ) external { uint synthsToSend = 0 ; for ( uint i = depositStartIndex ; i < depositEndIndex ; i ++ ) { synthDeposit memory deposit = deposits [ i ] ; if ( deposit . user == msg . sender ) { synthsToSend = synthsToSend . add ( deposit . amount ) ; delete deposits [ i ] ; emit SynthDepositRemoved ( deposit . user , deposit . amount , i ) ; } } totalSellableDeposits = totalSellableDeposits . sub ( synthsToSend ) ; synthsToSend = synthsToSend . add ( smallDeposits [ msg . sender ] ) ; smallDeposits [ msg . sender ] = 0 ; require ( synthsToSend > 0 , ""You have no deposits to withdraw."" ) ; synth . transfer ( msg . sender , synthsToSend ) ; emit SynthWithdrawal ( msg . sender , synthsToSend ) ; }
","Allows a user to withdraw all of their previously deposited synths from this contract if needed .
"
"function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) internal { requireMultiple ( _amount ) ; require ( balanceOf ( _tokenHolder ) >= _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; callSender ( _operator , _tokenHolder , 0x0 , _amount , _holderData , _operatorData ) ; Burned ( _operator , _tokenHolder , _amount , _holderData , _operatorData ) ; }
","Helper function actually performing the burning of tokens .
"
"function changeCommission ( uint _newCommission ) public onlyOwner whenNotPaused { require ( _newCommission <= MAX_COMMISSION , ""commission should be <= MAX_COMMISSION"" ) ; require ( _newCommission != Commission , ""_newCommission==Commmission"" ) ; Commission = _newCommission ; emit NewCommission ( Commission ) ; }
","ability for owner to change the service commmission
"
"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; PercentageTransferManager percentageTransferManager = new PercentageTransferManager ( msg . sender , address ( polyToken ) ) ; require ( getSig ( _data ) == percentageTransferManager . getInitFunction ( ) , ""Provided data is not valid"" ) ; require ( address ( percentageTransferManager ) . call ( _data ) , ""Un-successfull call"" ) ; emit LogGenerateModuleFromFactory ( address ( percentageTransferManager ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( percentageTransferManager ) ; }
","used to launch the Module with the help of factory
"
"function sell ( uint256 amount ) public { require ( this . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount * 10 ** uint256 ( decimals ) ) ; msg . sender . transfer ( amount * sellPrice ) ; }
","Sell ` amount ` tokens to contract
"
"function create ( address _to , uint256 _tokenId , bytes8 _name ) public payable validAddress ( _to ) validId ( _tokenId ) returns ( uint64 ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( pixelcons . length < uint256 ( 2 ** 64 ) - 1 , ""Max number of PixelCons has been reached"" ) ; require ( lookupData . owner == address ( 0 ) , ""PixelCon already exists"" ) ; uint32 dateCreated = 0 ; if ( now < uint256 ( 2 ** 32 ) ) dateCreated = uint32 ( now ) ; uint64 index = uint64 ( pixelcons . length ) ; lookupData . tokenIndex = index ; pixelcons . length ++ ; pixelconNames . length ++ ; PixelCon storage pixelcon = pixelcons [ index ] ; pixelcon . tokenId = _tokenId ; pixelcon . creator = msg . sender ; pixelcon . dateCreated = dateCreated ; pixelconNames [ index ] = _name ; uint64 [ ] storage createdList = createdTokens [ msg . sender ] ; uint createdListIndex = createdList . length ; createdList . length ++ ; createdList [ createdListIndex ] = index ; addTokenTo ( _to , _tokenId ) ; emit Create ( _tokenId , msg . sender , index , _to ) ; emit Transfer ( address ( 0 ) , _to , _tokenId ) ; return index ; }
","Create PixelCon ` ( _tokenId ) `
"
"function updateReputationScore ( bytes32 _deviceId , bytes32 _reputationScore ) public onlyIRNNode whenNotPaused returns ( bool ) { Device memory d = _updateReputationScore ( _deviceId , _reputationScore ) ; address _manufacturerWallet = manufacturerRewards [ d . manufacturerId ] ; require ( _manufacturerWallet != address ( 0 ) , ""_manufacturerWallet cannot be 0x0"" ) ; require ( _manufacturerWallet != msg . sender , ""manufacturers cannot collect the full reward"" ) ; uint256 irnReward ; uint256 manufacturerReward ; ( irnReward , manufacturerReward ) = getReputationRewards ( msg . sender , _manufacturerWallet , _deviceId ) ; _distributeRewards ( _manufacturerWallet , msg . sender , irnReward ) ; _distributeRewards ( _manufacturerWallet , _manufacturerWallet , manufacturerReward ) ; emit ReputationScoreUpdated ( _deviceId , d . deviceType , _reputationScore , msg . sender , irnReward , _manufacturerWallet , manufacturerReward ) ; authorWrites [ msg . sender ] [ _deviceId ] = block . number ; return true ; }
","updates reputation for a device
"
"function setLimit ( uint256 tokenId ) external onlyAdmin { require ( tokenId < tokens . length ) ; require ( pValidationState == pointsValidationState . Unstarted || pValidationState == pointsValidationState . LimitSet ) ; pointsLimit = tokenId ; pValidationState = pointsValidationState . LimitSet ; lastCheckedToken = 0 ; lastCalculatedToken = 0 ; winnerCounter = 0 ; setPause ( ) ; setPayoutDistributionId ( ) ; }
","Sets the id of the last token that will be given a prize .
"
"function _setPendingAdmin ( address newPendingAdmin ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_PENDING_ADMIN_OWNER_CHECK ) ; } address oldPendingAdmin = pendingAdmin ; pendingAdmin = newPendingAdmin ; emit NewPendingAdmin ( oldPendingAdmin , newPendingAdmin ) ; return uint ( Error . NO_ERROR ) ; }
","Begins transfer of admin rights .
"
"function withdrawAll ( ) public returns ( bool ) { owner . transfer ( this . balance ) ; return true ; }
","Send contract balance to ` owner `
"
"function assign ( address _receiver , uint256 _amount ) external authP ( ASSIGN_ROLE , arr ( _receiver , _amount ) ) { _assign ( _receiver , _amount ) ; }
","Assign ` @ tokenAmount ( self.token ( ) : address , _amount , false ) ` tokens to ` _receiver ` from the Token Manager 's holdings
"
"function revokeAttribute ( address account , uint256 attributeTypeID ) external whenNotPaused { require ( _issuedAttributes [ account ] [ attributeTypeID ] . exists , ""only existing attributes may be removed"" ) ; address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; require ( msg . sender == validator || msg . sender == owner ( ) , ""only jurisdiction or issuing validators may revoke arbitrary attributes"" ) ; delete _issuedAttributes [ account ] [ attributeTypeID ] ; emit AttributeRemoved ( validator , account , attributeTypeID ) ; }
","Revoke the attribute of the type with ID ` attributeTypeID ` from ` account ` if ` message.caller.address ( ) ` is the issuing validator .
"
"function addHash ( bytes32 [ ] _hashes ) onlyResolver public { for ( uint i = 0 ; i < _hashes . length ; i ++ ) { randomHashes . push ( _hashes [ i ] ) ; } }
","Adds an array of hashes to be used for resolving
"
"function _clearApprovalAndTransfer ( address _from , address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) , ""invalid target address"" ) ; require ( _to != ownerOf ( _tokenId ) , ""already owns"" ) ; require ( ownerOf ( _tokenId ) == _from , ""wrong owner"" ) ; _clearApproval ( _from , _tokenId ) ; _removeToken ( _from , _tokenId ) ; _addToken ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }
","Internal function to clear current approval and transfer the ownership of a given token ID
"
"function forceNeuroChainAddress ( address ethAddress , string neurochainAddress ) public onlyIcoContract { neuroChainAddresses [ ethAddress ] = neurochainAddress ; NeuroChainAddressSet ( ethAddress , neurochainAddress , block . timestamp , true ) ; }
","Force NeuroChain Address to be associated to a standard ERC20 account
"
"function getPriceOfPlot ( Geometry . Rect memory subPlotToPurchase , uint256 plotIndex ) private view returns ( uint256 ) { uint256 plotPricePerPixel = plotIdToPrice [ plotIndex ] ; require ( plotPricePerPixel > 0 ) ; return SafeMath . mul ( SafeMath . mul ( subPlotToPurchase . w , subPlotToPurchase . h ) , plotPricePerPixel ) ; }
","Given a rect to purchase and the plot index , return the total price to be paid .
"
"function setOwner ( address _newOwner ) onlyOwner external { owner = _newOwner ; }
","Change the owner to a new address .
"
"function kill ( ) onlyOwner public { selfdestruct ( owner ) ; }
","Admin failsafe for destroying the contract
"
"function setTokenPoolReward ( uint256 newReward ) public onlyManufacturer returns ( bool ) { require ( newReward != 0 , ""newReward is required"" ) ; TokenPool storage p = pools [ msg . sender ] ; require ( p . rewardAmount != newReward , ""newReward should be different"" ) ; p . rewardAmount = newReward ; emit TokenPoolRewardUpdated ( msg . sender , newReward ) ; return true ; }
","allows a token pool owner to set a new reward amount
"
"function setOpenForSale ( bool status ) onlyOwner public { isOpenForSale = status ; }
","Sets openned for sale status
"
"function getDescription ( ) public view returns ( string ) ;
","Get the description of the Module
"
"function getSecurityTokenAddress ( string _symbol ) public view returns ( address ) ;
","Get security token address by ticker name
"
"function canIssueAttributeType ( address validator , uint256 attributeTypeID ) external view returns ( bool ) { return canValidate ( validator , attributeTypeID ) ; }
","Determine if a validator at account ` validator ` is able to issue attributes of the type with ID ` attributeTypeID ` .
"
"function checkAdminOwner ( PledgeAdmin m ) internal constant { require ( ( msg . sender == m . addr ) || ( msg . sender == address ( m . plugin ) ) ) ; }
","A check to see if the msg.sender is the owner or the plugin contract for a specific Admin
"
"function getScene ( uint256 _tokenId ) public view returns ( string sceneName , uint [ ] stars , uint256 sellingPrice , address owner ) { Scene storage scene = scenes [ _tokenId ] ; sceneName = scene . name ; stars = scene . stars ; sellingPrice = sceneIndexToPrice [ _tokenId ] ; owner = sceneIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific scene .
"
"function isApprovedForAll ( address _owner , address _operator ) public view validAddress ( _owner ) validAddress ( _operator ) returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }
","Get if ` ( _operator ) ` is an approved operator for owner ` ( _owner ) `
"
"function unlock ( ) public onlyStates ( LockState . AcceptingUnlocks , LockState . ReleaseAll ) { unlockInvestor ( msg . sender ) ; }
","unlocks investors funds , see unlockInvestor for details
"
"function votedPerCent ( address voter ) constant external returns ( uint ) { var rawVote = rawVotes [ voter ] ; if ( rawVote < MAX_AMOUNT_EQU_0_PERCENT ) return 0 ; else if ( rawVote >= MIN_AMOUNT_EQU_100_PERCENT ) return 100 ; else return rawVote * 100 / 1 ether ; }
","returns current voting result for given address in percent .
"
"function voteAgainst ( uint motionID ) external { uint weight = setupVote ( motionID ) ; vote [ msg . sender ] [ motionID ] = Vote . Nay ; votesAgainst [ motionID ] = safeAdd ( votesAgainst [ motionID ] , weight ) ; emit VotedAgainst ( msg . sender , motionID , weight ) ; }
","The sender casts a vote against confiscation of the target account 's nomin balance .
"
"function burnTokens ( uint256 _amount ) external returns ( bool ) { return _burnTokens ( _amount ) ; }
","Burn some tokens
"
"function name ( ) external view returns ( string ) ;
","A descriptive name for a collection of NFTs in this contract
"
"function extractBalanceProofSignature ( address _receiver_address , uint32 _open_block_number , uint192 _balance , bytes _balance_msg_sig ) public view returns ( address ) { bytes32 message_hash = keccak256 ( keccak256 ( 'string message_id' , 'address receiver' , 'uint32 block_created' , 'uint192 balance' , 'address contract' ) , keccak256 ( 'Sender balance proof signature' , _receiver_address , _open_block_number , _balance , address ( this ) ) ) ; address signer = ECVerify . ecverify ( message_hash , _balance_msg_sig ) ; return signer ; }
","Returns the sender address extracted from the balance proof .
"
"function totalSupplyAt ( uint256 _blockNumber ) constant returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function approve ( address spender , uint256 value ) returns ( bool ) { if ( safeSub ( balances [ msg . sender ] , value ) < shouldHadBalance ( msg . sender ) ) throw ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }
","` msg.sender ` approves ` spender ` to spend ` value ` tokens
"
"function freezeTransfers ( ) public onlyAdmin returns ( bool ) { transfersFrozen = true ; emit TransfersFrozen ( true ) ; return true ; }
","Used to freeze token transfers
"
"function release ( ) external onlyOwner onlyInEmergency { stopped = false ; }
","Called by the owner to end of emergency , returns to normal state
"
"function setPrices ( uint256 newBuyPrice , bool _openToSales ) onlyOwner public { buyPrice = newBuyPrice ; openToSales = _openToSales ; }
","Allow users to buy tokens for ` newBuyPrice ` eth
"
"function balanceOf ( address _owner ) public view returns ( uint256 balance ) { if ( ! tokenAvailable ) { return 0 ; } return balances [ _owner ] ; }
","Gets the balance of the specified address .
"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( 0 , this , mintedAmount ) ; Transfer ( this , target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function sell ( uint256 amount ) public { address myAddress = address ( this ) ; require ( myAddress . balance >= amount * sellPrice ) ; _transfer ( msg . sender , address ( this ) , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
","Sell ` amount ` tokens to contract
"
"function updateSubmissionGasPriceLimit ( uint256 _newSubmissionGasPriceLimit ) external onlyOwner { emit LogSubmissionGasPriceLimitUpdated ( submissionGasPriceLimit , _newSubmissionGasPriceLimit ) ; submissionGasPriceLimit = _newSubmissionGasPriceLimit ; }
","The owner of the contract can update the order submission gas price limit .
"
"function create ( uint256 baseUnitsToCreate ) external whenNotPaused ( ) requireNonZero ( baseUnitsToCreate ) requireMultiple ( baseUnitsToCreate ) { require ( ( totalSupply_ + baseUnitsToCreate ) > totalSupply_ ) ; for ( uint8 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory tokenInfo = tokens [ i ] ; ERC20 erc20 = ERC20 ( tokenInfo . addr ) ; transferUnderlyingTokensWhenCreate ( erc20 , tokenInfo . tokenUnits , baseUnitsToCreate ) ; } mint ( msg . sender , baseUnitsToCreate ) ; }
","Creates ETF tokens in exchange for underlying tokens .
"
"function batchConvertIntoHtlc ( bytes32 [ ] msigIds , address [ ] beneficiaries , uint [ ] amounts , uint [ ] fees , uint [ ] expirationTimes , bytes32 [ ] hashedSecrets ) public returns ( bytes32 [ ] swapId ) { require ( msigIds . length <= MAX_BATCH_ITERATIONS ) ; for ( uint i = 0 ; i < msigIds . length ; ++ i ) convertIntoHtlc ( msigIds [ i ] , beneficiaries [ i ] , amounts [ i ] , fees [ i ] , expirationTimes [ i ] , hashedSecrets [ i ] ) ; }
","Batch execution of convertIntoHtlc ( ) function
"
"function pauseWhitelist ( ) public onlyAdmin returns ( bool ) { paused = true ; Paused ( msg . sender , now ) ; return true ; }
","Pauses the whitelist if there is any issue
"
"function setRequestCancellationMinimumTime ( uint32 _newRequestCancellationMinimumTime ) onlyOwner external { requestCancellationMinimumTime = _newRequestCancellationMinimumTime ; }
","Change the requestCancellationMinimumTime .
"
"function set_pauseSale ( bool _pauseSale ) onlyOwner public { sale_pause = _pauseSale ; }
","Set the bool value of sale_pause
"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }
","Find allowance
"
"function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != 0x0 ) ; require ( balanceOf [ _from ] >= _value ) ; require ( balanceOf [ _to ] + _value > balanceOf [ _to ] ) ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( _from , _to , _value ) ; }
","only the contract can operate this internal funktion
"
"function setStakedBalances ( uint _amount , address msgSender ) public ownerOnly { stakedBalances [ msgSender ] = _amount ; }
","This is the community staking method
"
"function modifyWhitelist ( address _investor , bool _valid ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = _valid ; emit ModifyWhitelist ( _investor , now , msg . sender , _valid ) ; }
","adds or removes addresses from the whitelist .
"
"function acceptOwnership ( ) external { require ( msg . sender == nominatedOwner ) ; emit OwnerChanged ( owner , nominatedOwner ) ; owner = nominatedOwner ; nominatedOwner = address ( 0 ) ; }
","Accept the nomination to be owner .
"
"function pauseContribution ( ) onlyOwner { paused = true ; }
","Pauses the contribution if there is any issue
"
"function _setTokenUri ( uint256 _tokenId , string _uri ) validNFToken ( _tokenId ) internal { idToUri [ _tokenId ] = _uri ; }
","this is a internal function which should be called from user-implemented external function .
"
"function canAddAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) ;
","Check if a given signed attribute approval is currently valid for a given account when submitted by the operator at ` msg.sender ` .
"
"function transferFrom ( address from , address to , uint256 index ) public returns ( bool ) { require ( loans [ index ] . lender == from ) ; return transfer ( to , index ) ; }
","Transfers the loan to an address , only if the current owner is the `` from '' address
"
"function setEndDate ( Campaign storage _campaign , uint _endDate ) internal { _campaign . endDate = _endDate ; }
","Set campaign end date
"
"function symbol ( ) public pure returns ( string _deedSymbol ) ;
","An abbreviated name for deeds managed by this contract
"
"function getLastDeedByAddress ( string propertyAddress ) public constant returns ( string ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; return addressRegistry [ propertyAddressHash ] [ addressRegistry [ propertyAddressHash ] . length - 1 ] ; }
","Gets the last deed by property address
"
"function buyTokens ( address _beneficiary ) public payable nonReentrant { require ( ! paused ) ; require ( fundraiseType == FundraiseType . ETH , ""ETH should be the mode of investment"" ) ; uint256 weiAmount = msg . value ; _processTx ( _beneficiary , weiAmount ) ; _forwardFunds ( ) ; _postValidatePurchase ( _beneficiary , weiAmount ) ; }
","low level token purchase DO NOT OVERRIDE
"
"function totalSupply ( ) public view returns ( uint256 supply ) { return totalSupply ; }
","Return the total supply of the token
"
"function stage ( ) public constant returns ( uint256 ) ;
","the current stage the campaign is in
"
"function presale ( ) payable returns ( bool ) ;
","Function to participate in the presale of the funding
"
"function relay ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _maximumGasPrice , uint8 _v , bytes32 _r , bytes32 _s , uint8 _instructionByte , uint128 _additionalGas ) private returns ( bool ) { address _relayedSender = getRelayedSender ( _tradeID , _instructionByte , _maximumGasPrice , _v , _r , _s ) ; if ( _relayedSender == _buyer ) { if ( _instructionByte == INSTRUCTION_SELLER_CANNOT_CANCEL ) { return doDisableSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } else if ( _instructionByte == INSTRUCTION_BUYER_CANCEL ) { return doBuyerCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } } else if ( _relayedSender == _seller ) { if ( _instructionByte == INSTRUCTION_RELEASE ) { return doRelease ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } else if ( _instructionByte == INSTRUCTION_SELLER_CANCEL ) { return doSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } else if ( _instructionByte == INSTRUCTION_SELLER_REQUEST_CANCEL ) { return doSellerRequestCancel ( _tradeID , _seller , _buyer , _value , _fee , _additionalGas ) ; } } else { require ( msg . sender == _seller , ""Unrecognised party"" ) ; return false ; } }
","Relay a signed instruction from a party of an escrow .
"
"function setExchangeRates ( ExchangeRates _exchangeRates ) external optionalProxy_onlyOwner { exchangeRates = _exchangeRates ; }
","Set the ExchangeRates contract address where rates are held .
"
"function increaseApprovalWithSender ( address _sender , address _spender , uint256 _addedValue ) public onlyProxy returns ( bool success ) { require ( _spender != address ( 0 ) ) ; uint256 currentAllowance = erc20Store . allowed ( _sender , _spender ) ; uint256 newAllowance = currentAllowance + _addedValue ; require ( newAllowance >= currentAllowance ) ; erc20Store . setAllowance ( _sender , _spender , newAllowance ) ; erc20Proxy . emitApproval ( _sender , _spender , newAllowance ) ; return true ; }
","Core logic of the ` increaseApproval ` function .
"
"function proxyApprove ( address _spender , uint _value , bytes32 _symbol , address _sender ) public onlyProxy ( _symbol ) returns ( uint ) { return _approve ( _createHolderId ( _spender ) , _value , _symbol , _createHolderId ( _sender ) ) ; }
","Sets asset spending allowance for a specified spender .
"
"function getTxStatus ( Data storage self , bytes32 txHash ) internal view returns ( bool txStatus ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tx.status' , txHash ) ) ; return self . Storage . getBool ( id ) ; }
","Return boolean transaction status if the transaction has been used
"
"function initialize ( string _name , string _symbol , uint256 _granularity , address _eip820RegistryAddr , address _owner ) public { require ( ! _initialized , ""This contract has already been initialized. You can only do this once."" ) ; mName = _name ; mSymbol = _symbol ; mErc20compatible = true ; setOwner ( _owner ) ; require ( _granularity >= 1 , ""The granularity must be >= 1"" ) ; mGranularity = _granularity ; setIntrospectionRegistry ( _eip820RegistryAddr ) ; setInterfaceImplementation ( ""ERC20Token"" , this ) ; setInterfaceImplementation ( ""ERC777Token"" , this ) ; setInterfaceImplementation ( ""Lockable"" , this ) ; setInterfaceImplementation ( ""Pausable"" , this ) ; _initialized = true ; }
","Constructor to create a ReferenceToken
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) ;
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function finalizeCrowdsale ( ) public { require ( ( now > lastRoundEndTimestamp ( ) ) || ( totalCollected == hardCap ) || ( msg . sender == owner ) ) ; finalized = token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( this . balance > 0 ) { owner . transfer ( this . balance ) ; } }
","Finalizes ICO when one of conditions met : - end time reached OR - no more tokens available ( cap reached ) OR - message sent by owner
"
"function canWithdraw ( address _holder ) public constant returns ( bool ) { if ( nextDepositToPayout [ _holder ] == deposits . length ) return false ; for ( uint i = nextDepositToPayout [ msg . sender ] ; i < deposits . length ; i ++ ) { Deposit storage d = deposits [ i ] ; if ( ( ! d . canceled ) && ( ! isDepositSkiped ( _holder , i ) ) ) { uint amount = d . amount * rewardToken . balanceOfAt ( _holder , d . block ) / rewardToken . totalSupplyAt ( d . block ) ; if ( amount > 0 ) return true ; } } return false ; }
","A check to see if a specific address has anything to collect
"
"function lowerCeiling ( uint256 _lowerBy ) public onlyLimitedPrinter { uint256 newCeiling = totalSupplyCeiling - _lowerBy ; require ( newCeiling <= totalSupplyCeiling ) ; totalSupplyCeiling = newCeiling ; emit CeilingLowered ( _lowerBy , newCeiling ) ; }
","Lowers the supply ceiling , further constraining the bound of what can be printed by the limited printer .
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalPonies = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 ponyId ; for ( ponyId = 1 ; ponyId <= totalPonies ; ponyId ++ ) { if ( ponyIndexToOwner [ ponyId ] == _owner ) { result [ resultIndex ] = ponyId ; resultIndex ++ ; } } return result ; } }
","Returns a list of all Pony IDs assigned to an address .
"
"function removeManyWhitelist ( address [ ] _accounts ) external whenNotPaused onlyAdmin { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { if ( _accounts [ i ] != address ( 0 ) && whitelist [ _accounts [ i ] ] ) { whitelist [ _accounts [ i ] ] = false ; emit WhitelistRemoved ( _accounts [ i ] ) ; } } }
","Removes multiple accounts from the whitelist .
"
"function configure ( uint256 _maxHolderPercentage , bool _allowPrimaryIssuance ) public onlyFactory { maxHolderPercentage = _maxHolderPercentage ; allowPrimaryIssuance = _allowPrimaryIssuance ; }
","Used to intialize the variables of the contract
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { bool sucsSlrLmt = _chkSellerLmts ( msg . sender , _value ) ; bool sucsByrLmt = _chkBuyerLmts ( _spender , _value ) ; require ( sucsSlrLmt == true && sucsByrLmt == true ) ; uint valtmp = _value ; uint _valueA = valtmp ; valtmp = 0 ; allowance [ msg . sender ] [ _spender ] = _valueA ; Approval ( msg . sender , _spender , _valueA ) ; _valueA = 0 ; return true ; }
","Allows ` _spender ` to spend no more than ` _value ` coins from your account
"
"function size ( ContentMapping storage self ) public view returns ( uint ) { return self . keys . length ; }
","get amount of items in mapping
"
"function addAssetPartOwner ( bytes32 _symbol , address _partowner ) external onlyOneOfOwners ( _symbol ) returns ( uint ) { uint holderId = _createHolderId ( _partowner ) ; assets [ _symbol ] . partowners [ holderId ] = true ; Emitter ( eventsHistory ) . emitOwnershipChange ( 0x0 , _partowner , _symbol ) ; return OK ; }
","Adds a co-owner for an asset with provided symbol .
"
"function validateContentHash ( Document storage self , bytes32 _contentHash ) public view returns ( bool ) { bytes32 contentHash = self . contentHash ; return contentHash == _contentHash ; }
","Validate Content Hash alone of a student
"
"function addStablecoin ( address _stablecoin ) public onlyOwner { whitelist [ _stablecoin ] = true ; emit StablecoinAdded ( _stablecoin ) ; }
","Add a token to the whitelist .
"
"function unpause ( ) public onlyOwner whenPaused { require ( newContractAddress == address ( 0 ) , ""new contract cannot be 0x0"" ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function putOn ( uint256 _champId , uint256 _itemId ) external onlyOwnerOfChamp ( _champId ) onlyOwnerOfItem ( _itemId ) { Champ storage champ = champs [ _champId ] ; Item storage item = items [ _itemId ] ; if ( item . onChamp ) { takeOffItem ( item . onChampId , item . itemType ) ; } item . onChamp = true ; item . onChampId = _champId ; if ( item . itemType == 1 ) { if ( champ . eq_sword > 0 ) { takeOffItem ( champ . id , 1 ) ; } champ . eq_sword = _itemId ; } if ( item . itemType == 2 ) { if ( champ . eq_shield > 0 ) { takeOffItem ( champ . id , 2 ) ; } champ . eq_shield = _itemId ; } if ( item . itemType == 3 ) { if ( champ . eq_helmet > 0 ) { takeOffItem ( champ . id , 3 ) ; } champ . eq_helmet = _itemId ; } }
","Puts item on champ
"
"function validRequest ( bytes32 [ ] _proof , bytes5 _code , address _dest ) public view returns ( bool ) { return ! sentToAddress [ _dest ] && ! codeUsed [ _code ] && MerkleProof . verifyProof ( _proof , root , keccak256 ( abi . encodePacked ( _code ) ) ) ; }
","Determine if a request to send SNT/ETH is valid based on merkle proof , and destination address
"
"function requireMultiple ( uint256 _amount ) internal view { require ( _amount . div ( mGranularity ) . mul ( mGranularity ) == _amount ) ; }
","Internal function that ensures ` _amount ` is multiple of the granularity
"
"function authorizeOperator ( address _operator ) external { require ( _operator != msg . sender ) ; require ( ! mAuthorized [ _operator ] [ msg . sender ] ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = false ; } else { mAuthorized [ _operator ] [ msg . sender ] = true ; } emit AuthorizedOperator ( _operator , msg . sender ) ; }
","Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .
"
"function rewardToken ( address _recipient , uint _amount , uint _date ) external ;
","Function used by the main partner to reward shares or tokens
"
"function canBreedWith ( uint40 _momId , uint40 _dadId ) public view returns ( bool ) { require ( _momId > 0 ) ; require ( _dadId > 0 ) ; Cutie storage mom = cuties [ _momId ] ; Cutie storage dad = cuties [ _dadId ] ; return _canPairMate ( mom , _momId , dad , _dadId ) && _isBreedingPermitted ( _dadId , _momId ) ; }
","Checks to see if two cuties can breed together ( checks both ownership and breeding approvals , but does not check if both cuties are ready for breeding ) .
"
"function isApprovedOrOwner ( address _address , uint256 _tokenId ) internal view returns ( bool ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return ( _address == owner || tokenApprovals [ _tokenId ] == _address || operatorApprovals [ owner ] [ _address ] ) ; }
","Check whether the given spender can transfer a given token ID
"
"function withdrawInternal ( uint requested , bool all ) internal { require ( between [ msg . sender ] ) ; uint available = Splitter . balance ( ) ; uint transferring = 0 ; if ( all ) { transferring = available ; } else { available = requested ; } require ( transferring <= available ) ; amountsWithdrew [ msg . sender ] += transferring ; msg . sender . transfer ( transferring ) ; }
","Checks whether the sender is allowed to withdraw and has sufficient funds , then withdraws .
"
"function getAccountStatus ( Data storage self , address account ) internal view returns ( bool status ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.allowed' , getForwardedAccount ( self , account ) ) ) ; return self . Storage . getBool ( id ) ; }
","Get global approval status for the account holder
"
"function setSecurityGuard ( address _newSecurityGuard ) onlyOwner external { securityGuard = _newSecurityGuard ; }
","` onlyOwner ` Sets the address of ` securityGuard `
"
"function requestArbitration ( address realitycheck , bytes32 question_id ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { RealityCheckAPI ( realitycheck ) . notifyOfArbitrationRequest ( question_id , msg . sender ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! RealityCheckAPI ( realitycheck ) . isFinalized ( question_id ) ) ; LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }
","Request arbitration , freezing the question until we send submitAnswerByArbitrator
"
"function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 2 ) ; availableTags [ 0 ] = ""Count"" ; availableTags [ 1 ] = ""Transfer Restriction"" ; return availableTags ; }
","Get the tags related to the module factory
"
"function mAfterTransition ( State oldState , State newState ) internal ;
","gets called after every state transition .
"
"function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < totalSupply ( ) ) ; return _index ; }
","Enumerate valid NFTs
"
"function unlock ( ) external { if ( now < unlockedAt ) throw ; if ( tokensCreated == 0 ) tokensCreated = gnt . balanceOf ( this ) ; var allocation = allocations [ msg . sender ] ; allocations [ msg . sender ] = 0 ; var toTransfer = tokensCreated * allocation / totalAllocations ; if ( ! gnt . transfer ( msg . sender , toTransfer ) ) throw ; }
","Allow developer to unlock allocated tokens by transferring them from GNTAllocation to developer 's address .
"
"function addBeneficiary ( address _beneficiary , uint256 _amount ) public onlyOwner validAddress ( _beneficiary ) returns ( address ) { require ( _beneficiary != owner ) ; require ( _amount > 0 ) ; require ( block . timestamp < releaseDate ) ; require ( SafeMath . sub ( totalFunds , distributedTokens ) >= _amount ) ; require ( token . balanceOf ( address ( this ) ) >= _amount ) ; if ( ! beneficiaryExists ( _beneficiary ) ) { beneficiaries . push ( _beneficiary ) ; } distributedTokens = distributedTokens . add ( _amount ) ; address tokenTimelock = new TokenTimelock ( token , _beneficiary , releaseDate ) ; beneficiaryDistributionContracts [ _beneficiary ] . push ( tokenTimelock ) ; token . safeTransfer ( tokenTimelock , _amount ) ; emit BeneficiaryAdded ( _beneficiary , tokenTimelock , _amount ) ; return tokenTimelock ; }
","Example : addBeneficiary ( ` 0x123.. ` , 100 ) Will create a TokenTimelock instance on which if the ` release ( ) ` method is called after the release date ( specified in this contract constructor ) , the amount of tokens ( 100 ) will be transferred to the beneficiary ( ` 0x123.. ` ) .
"
"function gasExchangeMultiple ( address [ ] gasRecipients , uint256 [ ] amountsEurUlps , uint256 exchangeFeeFraction ) public ;
","see above .
"
"function hasVoted ( address account , uint motionID ) public view returns ( bool ) { return vote [ account ] [ motionID ] != Vote . Abstention ; }
","Return if the specified account has voted on the specified motion
"
"function rewardTaskCompletion ( uint uuid , address user ) public onlyVoteController { communityAccount . transferTokensOut ( address ( nativeTokenInstance ) , user , communityAccount . escrowedTaskBalances ( uuid ) ) ; communityAccount . setTotalTaskEscrow ( SafeMath . sub ( communityAccount . totalTaskEscrow ( ) , communityAccount . escrowedTaskBalances ( uuid ) ) ) ; communityAccount . setEscrowedTaskBalances ( uuid , 0 ) ; logger . emitGenericLog ( ""rewardTaskCompletion"" , """" ) ; }
","Pays task completer and updates escrow balances
"
"function processWhitelistedContribution ( uint256 allowedContribution , uint256 refundAmount ) private returns ( uint256 , uint256 ) { uint256 plannedContribution = whitelist [ msg . sender ] ; whitelist [ msg . sender ] = 0 ; WhitelistedUpdated ( plannedContribution , true ) ; if ( msg . value > plannedContribution ) { return handleAbovePlannedWhitelistedContribution ( allowedContribution , plannedContribution , refundAmount ) ; } if ( msg . value < plannedContribution ) { return handleBelowPlannedWhitelistedContribution ( plannedContribution ) ; } return handlePlannedWhitelistedContribution ( plannedContribution ) ; }
","Returns the contribution to be used for a sender that had previously been whitelisted , and any refund value if expected .
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) ;
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function decreaseApproval ( address _spender , uint256 _subtractedValue ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) , ""Invalid address."" ) ; return super . decreaseApproval ( _spender , _subtractedValue ) ; }
","Decreases the approval of the spender .
"
"function setPermissionManager ( address _newManager , address _app , bytes32 _role ) onlyPermissionManager ( _app , _role ) external { _setPermissionManager ( _newManager , _app , _role ) ; }
","Sets ` _newManager ` as the manager of the permission ` _role ` in ` _app `
"
"function spendFromMultisig ( bytes32 msigId , uint amount , address recipient ) internal { multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , amount ) ; if ( multisigs [ msigId ] . deposit == 0 ) delete multisigs [ msigId ] ; recipient . transfer ( amount ) ; }
","Send ether out of this contract to multisig owner and update or delete entry in multisig mapping
"
"function setFundsWallet ( address _fundsWallet ) external onlyOwner { fundsWallet = _fundsWallet ; emit FundsWalletUpdated ( fundsWallet ) ; }
","Set the funds wallet where ETH raised is held
"
"function transfer ( bytes32 _to , uint256 _value ) returns ( bool ) { var sender = sha3 ( msg . sender ) ; if ( balances [ sender ] >= _value ) { balances [ sender ] -= _value ; balances [ _to ] += _value ; TransferHash ( sender , _to , _value ) ; return true ; } return false ; }
","` _value ` tokens will be sended to ` _to `
"
"function calculateTokenExchangeRate ( ) internal returns ( uint256 ) { if ( cd [ 'preIco' ] [ 'startBlock' ] <= block . number && block . number <= cd [ 'preIco' ] [ 'endBlock' ] ) { return cd [ 'preIco' ] [ 'exRate' ] ; } if ( cd [ 'stage1' ] [ 'startBlock' ] <= block . number && block . number <= cd [ 'stage1' ] [ 'endBlock' ] ) { return cd [ 'stage1' ] [ 'exRate' ] ; } if ( cd [ 'stage2' ] [ 'startBlock' ] <= block . number && block . number <= cd [ 'stage2' ] [ 'endBlock' ] ) { return cd [ 'stage2' ] [ 'exRate' ] ; } if ( cd [ 'stage3' ] [ 'startBlock' ] <= block . number && block . number <= cd [ 'stage3' ] [ 'endBlock' ] ) { return cd [ 'stage3' ] [ 'exRate' ] ; } if ( cd [ 'stage4' ] [ 'startBlock' ] <= block . number && block . number <= cd [ 'stage4' ] [ 'endBlock' ] ) { return cd [ 'stage4' ] [ 'exRate' ] ; } return 0 ; }
","Calculate rate based on block number
"
"function calculateAtomicFees ( bytes32 _buyID , bytes32 _sellID , TokenPair memory _tokens ) private view returns ( SettlementDetails memory ) { Fraction memory midPrice = Fraction ( orderDetails [ _buyID ] . price + orderDetails [ _sellID ] . price , 2 ) ; uint256 commonVolume = Math . min256 ( orderDetails [ _buyID ] . volume , orderDetails [ _sellID ] . volume ) ; if ( isEthereumBased ( _tokens . secondaryToken . addr ) ) { uint256 secondaryTokenVolume = joinFraction ( commonVolume , 1 , int16 ( _tokens . secondaryToken . decimals ) - VOLUME_OFFSET ) ; ValueWithFees memory secondaryVwF = subtractDarknodeFee ( secondaryTokenVolume ) ; return SettlementDetails ( { leftVolume : 0 , rightVolume : 0 , leftTokenFee : secondaryVwF . fees , rightTokenFee : secondaryVwF . fees , leftTokenAddress : _tokens . secondaryToken . addr , rightTokenAddress : _tokens . secondaryToken . addr } ) ; } else if ( isEthereumBased ( _tokens . priorityToken . addr ) ) { uint256 priorityTokenVolume = joinFraction ( commonVolume . mul ( midPrice . numerator ) , midPrice . denominator , int16 ( _tokens . priorityToken . decimals ) - PRICE_OFFSET - VOLUME_OFFSET ) ; ValueWithFees memory priorityVwF = subtractDarknodeFee ( priorityTokenVolume ) ; return SettlementDetails ( { leftVolume : 0 , rightVolume : 0 , leftTokenFee : priorityVwF . fees , rightTokenFee : priorityVwF . fees , leftTokenAddress : _tokens . priorityToken . addr , rightTokenAddress : _tokens . priorityToken . addr } ) ; } else { revert ( ""non-eth atomic swaps are not supported"" ) ; } }
","Calculates the fees to be transferred for an atomic swap .
"
"function contractExists ( address contract_address ) public view returns ( bool ) { uint size ; assembly { size := extcodesize ( contract_address ) } return size > 0 ; }
","Check if a contract exists
"
"function consume ( uint256 amount ) isPeonyContract returns ( bool ) { require ( balances [ owner ] . sub ( amount ) >= 0 ) ; require ( totalSupply . sub ( amount ) >= 0 ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; totalSupply = totalSupply . sub ( amount ) ; return true ; }
","consume digital artwork tokens for changing physical artwork
"
"function _transfer_byProxy ( address sender , address to , uint value , bytes data ) internal returns ( bool ) { uint received = amountReceived ( value ) ; uint fee = safeSub ( value , received ) ; return _internalTransfer ( sender , to , received , fee , data ) ; }
","ERC20 / ERC223 friendly transfer function .
"
"function setSecurityGuard ( address _newSecurityGuard ) onlyOwner { securityGuard = _newSecurityGuard ; }
","` onlyOwner ` Sets the address of ` securityGuard `
"
"function getAllCollectionNames ( ) public view returns ( bytes8 [ ] ) { return collectionNames ; }
","Get the names of all collections
"
"function getContestStatusForDate ( uint32 _date ) external view returns ( int256 , int256 , int256 ) { DailyContestStatus memory dailyContestStatus = dateToContestStatus [ _date ] ; int256 numRegistered = int256 ( dailyContestStatus . numRegistered ) ; int256 numCompleted = int256 ( dailyContestStatus . numCompleted ) ; int256 bonus = int256 ( calculateBonus ( _date ) ) ; if ( uint32 ( now ) <= _date . add ( WITHDRAW_BUFFER ) ) { numCompleted = - 1 ; bonus = - 1 ; } return ( numRegistered , numCompleted , bonus ) ; }
","Does n't change state
"
"function getMatchPoints ( uint256 matchIndex , uint160 matches , MatchResult [ ] matchResults , bool [ ] starMatches ) private pure returns ( uint16 matchPoints ) { uint8 tResult = uint8 ( matches & MATCH_RESULT_MASK ) ; uint8 tUnder49 = uint8 ( ( matches >> 2 ) & MATCH_UNDEROVER_MASK ) ; uint8 tTouchdowns = uint8 ( ( matches >> 3 ) & MATCH_TOUCHDOWNS_MASK ) ; uint8 rResult = matchResults [ matchIndex ] . result ; uint8 rUnder49 = matchResults [ matchIndex ] . under49 ; uint8 rTouchdowns = matchResults [ matchIndex ] . touchdowns ; if ( rResult == tResult ) { matchPoints += 5 ; if ( rResult == 0 ) { matchPoints += 5 ; } if ( starMatches [ matchIndex ] ) { matchPoints += 2 ; } } if ( tUnder49 == rUnder49 ) { matchPoints += 1 ; } if ( tTouchdowns == rTouchdowns ) { matchPoints += 4 ; } }
","get points from a single match
"
"function currentHalving ( ) public constant notBeforeGenesis returns ( uint256 ) { return blockHalving ( currentBlock ( ) ) ; }
","Determine the current halving number
"
"function pledgeFees ( uint _value ) public onlyController returns ( bool ) { uint curTotalFees = totalPledgedFees ( ) ; require ( curTotalFees + _value >= curTotalFees ) ; updateValueAtNow ( totalPledgedFeesHistory , curTotalFees + _value ) ; return true ; }
","Pledges fees to the token holders , later to be claimed by burning
"
"function setMaximumRate ( uint256 _newRate ) onlyOwner public { require ( _newRate <= hardCodedMaximumRate ) ; maximumRate = _newRate ; RateChanged ( 1 , _newRate ) ; }
","set the maximum rate for any affiliate
"
"function getListingsInRange ( uint64 _startIndex , uint64 _endIndex ) public view returns ( uint64 [ ] ) { require ( _startIndex <= totalListings ( ) , ""Start index is out of bounds"" ) ; require ( _endIndex <= totalListings ( ) , ""End index is out of bounds"" ) ; require ( _startIndex <= _endIndex , ""End index is less than the start index"" ) ; uint64 length = _endIndex - _startIndex ; uint64 [ ] memory indexes = new uint64 [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { indexes [ i ] = forSalePixelconIndexes [ _startIndex + i ] ; } return indexes ; }
","Get the PixelCon indexes being sold from listing index ` ( _startIndex ) ` to ` ( _endIndex ) `
"
"function claimRefundsFor ( address [ ] _beneficiaries ) external afterSaleFail { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { claimRefundFor ( _beneficiaries [ i ] ) ; } }
","Refund several addresses with one call
"
"function upgradeStorage ( address addrAdverStorage ) public onlyOwner ( ""upgradeStorage"" ) { for ( uint i = 0 ; i < bidIdList . length ; i ++ ) { cancelCampaign ( bidIdList [ i ] ) ; } delete bidIdList ; lastBidId = advertisementStorage . getLastBidId ( ) ; advertisementFinance . setAdsStorageAddress ( addrAdverStorage ) ; advertisementStorage = BaseAdvertisementStorage ( addrAdverStorage ) ; }
","Upgrade storage contract used by this contract Upgrades Advertisement Storage contract addres with no need to redeploy Advertisement contract .
"
"function proxiedContribution ( address _miner ) public payable returns ( bool ) { if ( _miner == address ( 0 ) ) { return contribute ( msg . sender ) ; } else { return contribute ( _miner ) ; } }
","Contribute to the mining of BTH on behalf of another miner
"
"function setRegisteredAuthority ( Data storage self , string issuerFirm , address authorityAddress , bool approved ) internal returns ( bool success ) { require ( isRegisteredFirm ( self , issuerFirm ) , ""Error: `issuerFirm` must be registered."" ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'registered.authority' , issuerFirm , authorityAddress ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'registered.authority.firm' , authorityAddress ) ) ; require ( self . Storage . setBool ( id_a , approved ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setString ( id_b , issuerFirm ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; return true ; }
","Method for setting a registered issuer firm authority
"
"function paymentAction ( bytes32 _requestId , uint256 [ ] _payeeAmounts , uint256 [ ] _additionalAmounts ) external whenNotPaused { if ( requestCore . getState ( _requestId ) == RequestCore . State . Created && msg . sender == requestCore . getPayer ( _requestId ) ) { acceptAction ( _requestId ) ; } if ( _additionalAmounts . length != 0 ) { additionalAction ( _requestId , _additionalAmounts ) ; } paymentInternal ( _requestId , _payeeAmounts ) ; }
","Function to pay a request in ERC20 token .
"
"function setBursar ( address _newBursar ) external requireGod { require ( _newBursar != address ( 0 ) ) ; bursarAddress = _newBursar ; }
","Assigns a new address to act as the Bursar .
"
"function transferOwnership ( address _newOwner ) onlyOwner { if ( _newOwner != address ( 0 ) ) { newOwner = _newOwner ; } }
","Transfer ownership from ` owner ` to ` newOwner `
"
"function unpause ( ) public onlyCEO whenPaused { require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive call .
"
"function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < _allTokens . length ) ; return _allTokens [ _index ] ; }
","Enumerate valid NFTs
"
"function approve ( address spender , uint256 amount ) public returns ( bool success ) { require ( mOnApprove ( msg . sender , spender , amount ) ) ; require ( ( amount == 0 ) || ( _allowed [ msg . sender ] [ spender ] == 0 ) ) ; _allowed [ msg . sender ] [ spender ] = amount ; Approval ( msg . sender , spender , amount ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function isContract ( address _address ) private view returns ( bool ) { uint256 _size ; assembly { _size := extcodesize ( _address ) } return _size > 0 ; }
","Ensures that a given address is a contract by making sure it has code .
"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { payDividendsTo ( msg . sender ) ; payDividendsTo ( _to ) ; return super . transfer ( _to , _value ) ; }
","hook on standard ERC20 # transfer to pay dividends
"
"function renewableOf ( uint256 _productId ) public view returns ( bool ) { return products [ _productId ] . renewable ; }
","Is this product renewable ?
"
"function unfreeze ( ) public onlyOwner returns ( bool ) { require ( ! unfrozen ) ; unfrozen = true ; emit Unfreeze ( ) ; return true ; }
","Finalizes contract
"
"function emergencySplitToggle ( ) external { splitInService = ! splitInService ; }
","Disable the splitting function
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = allStarIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function _updateTransfer ( address _from , address _to , uint256 _value , bytes _data ) internal nonReentrant returns ( bool ) { _adjustInvestorCount ( _from , _to , _value ) ; bool verified = _verifyTransfer ( _from , _to , _value , _data , true ) ; _adjustBalanceCheckpoints ( _from ) ; _adjustBalanceCheckpoints ( _to ) ; return verified ; }
","Updates internal variables when performing a transfer
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( state == State . stage1 && now > dateTimeContract . toTimestamp ( 2018 , 3 , 9 , 12 ) ) { state = State . stage2 ; } else if ( state == State . stage2 && now > dateTimeContract . toTimestamp ( 2018 , 3 , 16 , 12 ) ) { state = State . stage3 ; } else if ( state == State . stage3 && now > dateTimeContract . toTimestamp ( 2018 , 3 , 23 , 12 ) ) { state = State . stage4 ; } else if ( now > ICOdeadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
","check status
"
"function mine ( address _target , uint256 _minedAmount ) onlyDoftManager { require ( _minedAmount > 0 ) ; require ( _target != 0x0 ) ; require ( miningStorage - _minedAmount >= 0 ) ; require ( balanceOf [ doftManager ] >= _minedAmount ) ; require ( balanceOf [ _target ] + _minedAmount > balanceOf [ _target ] ) ; balanceOf [ doftManager ] -= _minedAmount ; balanceOf [ _target ] += _minedAmount ; miningStorage -= _minedAmount ; Mine ( _target , _minedAmount ) ; }
","Send ` _minedAmount ` to ` _target ` as a reward for mining
"
"function tokenBurn ( uint _amount ) public onlyOwner { require ( crowdsaleClosed == true ) ; tokenReward . transfer ( address ( 0 ) , _amount ) ; }
","A function to burn unsold DGZ tokens .
"
"function batchTransfer ( address [ ] recipients , uint [ ] quantities ) external pausableIfNotSelfDestructing returns ( bool ) { return _batchTransfer ( msg . sender , recipients , quantities ) ; }
","Performs ERC20 transfers in batches ; for each ` i ` , transfers ` quantities [ i ] ` tokens from the message sender to ` recipients [ i ] ` .
"
"function tokenBurner ( uint256 _amount ) onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( totalSupply . sub ( _amount ) > 0 ) ; require ( balances [ msg . sender ] > _amount ) ; require ( balances [ msg . sender ] . sub ( _amount ) > 0 ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; Transfer ( msg . sender , 0 , _amount ) ; return true ; }
","Used to burn tokens and decrease total supply
"
"function getApproved ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( address ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return tokenApprovals [ _tokenId ] ; }
","Get the approved address for PixelCon ` ( _tokenId ) `
"
"function reclaim ( ) public onlyOwner returns ( bool ) { require ( block . timestamp > releaseDate ) ; uint256 reclaimableAmount = token . balanceOf ( address ( this ) ) ; token . safeTransfer ( owner , reclaimableAmount ) ; emit Reclaim ( reclaimableAmount ) ; return true ; }
","Transfers the remaining tokens that were not locked for any beneficiary to the owner of this contract .
"
"function getArrayAddress ( bytes32 _key ) internal view returns ( address [ ] ) { return addressArrayStorage [ _key ] ; }
","Get functions to get the array of the required data type Ex1- mapping ( address = > bytes32 [ ] ) tokensOwnedByOwner ; getArrayBytes32 ( keccak256 ( abi.encodePacked ( `` tokensOwnedByOwner '' , 0x1 ) ) ; It return the bytes32 array Ex2- uint256 _len = tokensOwnedByOwner [ 0x1 ] .length ; replace with getArrayBytes32 ( keccak256 ( abi.encodePacked ( `` tokensOwnedByOwner '' , 0x1 ) ) .length ;
"
"function setFeeContract ( Data storage self , address feeContract ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.account' , address ( this ) ) ) ; require ( self . Storage . setAddress ( id , feeContract ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set fee contract for a contract interface
"
"function convertOldTokens ( address _receiver , uint256 _oldAmount ) external onlyOwner { require ( _receiver != address ( 0 ) ) ; require ( _oldAmount > 0 ) ; uint256 amountNewTokens = _oldAmount . mul ( 2 ) ; balances [ owner ] = balances [ owner ] . sub ( amountNewTokens ) ; balances [ _receiver ] = balances [ _receiver ] . add ( amountNewTokens ) ; }
","To convert the old tokens to the new version manually
"
"function buyTokenFromModerator ( uint _proposalID , address _buyer , uint _date , bool _presale ) payable external returns ( bool ) { if ( msg . sender != fundings [ _proposalID ] . moderator ) throw ; return buyTokensFor ( _proposalID , _buyer , _date , _presale ) ; }
","Function used by the moderator to buy shares or tokens
"
"function changeWCT2Controller ( address _newController ) public onlyController { wct2 . changeController ( _newController ) ; }
","The owner of this contract can change the controller of the WCT2 token Please , be sure that the owner is a trusted agent or 0x0 address .
"
"function withdrawFreeBalance ( ) external { uint256 freeBalance = this . balance - outstandingEther ; address deedContractAddress = address ( deedContract ) ; require ( msg . sender == owner || msg . sender == deedContractAddress ) ; deedContractAddress . transfer ( freeBalance ) ; }
","Withdraw ( unowed ) contract balance .
"
"function isFulfilled ( ContentMapping storage self , bytes32 _id , address _creator , address _brand ) public view returns ( bool ) { return self . data [ _id ] . deliverable . isFulfilled ( _creator , _brand ) ; }
","wrapper around internal deliverable method
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalElements = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 elementId ; for ( elementId = 0 ; elementId < totalElements ; elementId ++ ) { if ( elementToOwner [ elementId ] == _owner ) { result [ resultIndex ] = elementId ; resultIndex ++ ; } } return result ; } }
","Returns a list of all element IDs assigned to an address .
"
"function claim ( address _arbitrator , uint256 _transactionId ) public { Lock memory lock = escrows [ _arbitrator ] [ _transactionId ] ; require ( lock . sender == msg . sender ) ; require ( lock . paid ) ; require ( lock . expiration < block . timestamp ) ; require ( lock . expiration != 0 ) ; require ( lock . expiration != 1 ) ; delete escrows [ _arbitrator ] [ _transactionId ] ; token . transfer ( msg . sender , lock . value . add ( lock . fee ) ) ; Released ( _arbitrator , msg . sender , _transactionId ) ; }
","Only works after lock expired
"
"function _distributeReferrers ( uint256 _userId , uint256 _sum ) private { uint256 [ ] memory referrers = users [ _userId ] . referrersByLevel ; for ( uint i = 0 ; i < referralLevelsCount ; i ++ ) { uint256 referrerId = referrers [ i ] ; if ( referrers [ i ] == 0 ) break ; if ( users [ referrerId ] . totalPay < minSumReferral ) continue ; uint16 [ ] memory percents = getReferralPercents ( users [ referrerId ] . totalPay ) ; uint256 value = _sum * percents [ i ] / 10000 ; users [ referrerId ] . balance = users [ referrerId ] . balance . add ( value ) ; users [ referrerId ] . referrersReceived = users [ referrerId ] . referrersReceived . add ( value ) ; emit ReferrerDistribute ( _userId , referrerId , value ) ; } }
","distribute value of tx to referrers of user
"
"function setSymbol ( string _symbol ) onlyOwner { symbol = _symbol ; LogSetSymbol ( _symbol ) ; }
","Change symbol .
"
"function getPendingVersionTimestamp ( ) public view returns ( uint ) { return pendingVersionTimestamp ; }
","Returns upgrade freeze-time start .
"
"function arbitrateCancelCampaign ( ) onlyArbitrator campaignNotCanceled { campaignCanceled = true ; CampaignCalncelled ( ) ; }
","` onlyArbitrator ` Cancels the entire campaign voiding all milestones vo
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( state != State . Successful ) { if ( state == State . EarlyPreSale && now > startTime . add ( 8 days ) ) { StageDistributed ( state , stageDistributed ) ; state = State . PreSale ; stageDistributed = 0 ; } else if ( state == State . PreSale && now > startTime . add ( 15 days ) ) { StageDistributed ( state , stageDistributed ) ; state = State . Crowdsale ; stageDistributed = 0 ; } else if ( state == State . Crowdsale && now > startTime . add ( 36 days ) ) { StageDistributed ( state , stageDistributed ) ; state = State . Successful ; completedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } } }
","check status
"
"function getPermissionParamsLength ( address _entity , address _app , bytes32 _role ) external view returns ( uint ) { return permissionParams [ permissions [ permissionHash ( _entity , _app , _role ) ] ] . length ; }
","Get parameters for permission array length
"
"function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; isOperatorFor [ _operator ] [ msg . sender ] = false ; emit RevokedOperator ( _operator , msg . sender ) ; }
","Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
"
"function mBeforeStateTransition ( ETOState oldState , ETOState newState ) internal constant returns ( ETOState newStateOverride ) ;
","called before state transitions , allows override transition due to additional business logic
"
"function getUserBalance ( address _user ) public view onlyAllowed returns ( uint256 _balance ) { return balanceUsers [ _user ] ; }
","Get balance of coins stored in the contract by a specific user This function can only be called by the Advertisement contract
"
"function refund ( ) public returns ( bool ) ;
","Claim refund on failed ICO
"
"function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { require ( state == State . Successful ) ; require ( _address != address ( tokenReward ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
","Function to claim any token stuck on contract
"
"function hasAssetRights ( address _owner , bytes32 _symbol ) public view returns ( bool ) { uint holderId = getHolderId ( _owner ) ; return isCreated ( _symbol ) && ( _assetOwner ( _symbol ) == holderId || get ( store , assetPartowners , _symbol , holderId ) ) ; }
","Checks if a specified address has asset owner or co-owner rights .
"
"function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { claimTokens ( _from ) ; claimTokens ( _to ) ; return true ; }
","onTransfer implements MiniMeToken Controller 's onTransfer
"
"function approve ( address _to , uint256 _tokenId ) external { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer a specific element via transferFrom ( ) .
"
"function changeFactorySetupFee ( uint256 _newSetupCost ) public onlyOwner { emit ChangeFactorySetupFee ( setupCost , _newSetupCost , address ( this ) ) ; setupCost = _newSetupCost ; }
","Used to change the fee of the setup cost
"
"function settle ( ) { data . settle ( ) ; ChannelSettled ( data . settled ) ; }
","Settle the transfers and balances of the channel and pay out to each participant .
"
"function setValidatorSigningKey ( address newSigningKey ) external { require ( isValidator ( msg . sender ) , ""only validators may modify validator signing keys"" ) ; require ( _signingKeys [ newSigningKey ] == address ( 0 ) , ""a signing key matching the provided address already exists"" ) ; delete _signingKeys [ _validators [ msg . sender ] . signingKey ] ; _validators [ msg . sender ] . signingKey = newSigningKey ; _signingKeys [ newSigningKey ] = msg . sender ; emit ValidatorSigningKeyModified ( msg . sender , newSigningKey ) ; }
","Set the public address associated with a validator signing key , used to sign off-chain attribute approvals , as ` newSigningKey ` .
"
"function transferFrom ( address _from , address _to , uint256 _value ) onlyAllowed ( ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
","Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
"
"function claimTokens ( address _token ) public onlyOwner { require ( _token != address ( snt ) ) ; if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function deleteMinter ( address _who ) public onlyOwner returns ( bool ) { _setMinter ( _who , false ) ; }
","Deletes the minter role to provided address
"
"function amountReceived ( uint value ) public view returns ( uint ) { return safeDiv_dec ( value , safeAdd ( UNIT , transferFeeRate ) ) ; }
","The amount the recipient will receive if you send a certain number of tokens .
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) { _snapshotBlock = block . number ; } MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function getMeal ( uint256 _tokenId ) public view returns ( string mealName , uint256 sellingPrice , address owner ) { Meal storage meal = meals [ _tokenId ] ; mealName = meal . name ; sellingPrice = mealIndexToPrice [ _tokenId ] ; owner = mealIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific meal .
"
"function init ( ) public auth { gem . approve ( tub , uint ( - 1 ) ) ; skr . approve ( tub , uint ( - 1 ) ) ; dai . approve ( tub , uint ( - 1 ) ) ; gov . approve ( tub , uint ( - 1 ) ) ; gem . approve ( owner , uint ( - 1 ) ) ; skr . approve ( owner , uint ( - 1 ) ) ; dai . approve ( owner , uint ( - 1 ) ) ; gov . approve ( owner , uint ( - 1 ) ) ; dai . approve ( otc , uint ( - 1 ) ) ; gem . approve ( otc , uint ( - 1 ) ) ; tubParamUpdate ( ) ; }
","Sets all allowances and updates tub liquidation ratio
"
"function ( ) payable internal { uint amount = msg . value * buyPrice ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value >= 0 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
","Buy tokens from contract by sending ethereum to contract address with no minimum contribution
"
"function revokeAttestation ( bytes32 _link ) external { revokeAttestationForUser ( _link , msg . sender ) ; }
","Revoke an attestation
"
"function commRate ( uint256 newCommRate ) isOwner { require ( newCommRate > 0 ) ; require ( commRate != newCommRate ) ; commRate = newCommRate ; updatePrices ( ) ; }
","Set current Commission Rate
"
"function getVestingTime ( address account , uint index ) public view returns ( uint ) { return getVestingScheduleEntry ( account , index ) [ TIME_INDEX ] ; }
","Get the time at which a given schedule entry will vest .
"
"function forwardFunds ( uint256 toFund ) internal { vault . deposit . value ( toFund ) ( msg . sender ) ; }
","forwardd ether to vault
"
"function respondChallengeBefore ( uint64 slot , bytes32 challengingTxHash , uint256 respondingBlockNumber , bytes respondingTransaction , bytes proof , bytes signature ) external { require ( challenges [ slot ] . contains ( challengingTxHash ) , ""Responding to non existing challenge"" ) ; uint256 index = uint256 ( challenges [ slot ] . indexOf ( challengingTxHash ) ) ; checkResponse ( slot , index , respondingBlockNumber , respondingTransaction , signature , proof ) ; slashBond ( challenges [ slot ] [ index ] . challenger , msg . sender ) ; coins [ slot ] . state = State . EXITING ; challenges [ slot ] . remove ( challengingTxHash ) ; emit RespondedExitChallenge ( slot ) ; }
","Can only be called in the second window of the exit period .
"
"function claimTokens ( ERC20TokenInterface _address , address _to ) onlyAdmin public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }
","Function to claim ANY token stuck on contract accidentally In case of claim of stuck tokens please contact contract owners
"
"function approveAccount ( address target , bool approve ) onlyAdmin public { approvedAccount [ target ] = approve ; emit ApprovedAccount ( target , approve ) ; }
","` Allow | Prevent ` ` target ` from sending & receiving tokens
"
"function withdrawFees ( address account , uint value ) external onlyFeeAuthority returns ( bool ) { require ( account != address ( 0 ) , ""Must supply an account address to withdraw fees"" ) ; if ( value == 0 ) { return false ; } tokenState . setBalanceOf ( FEE_ADDRESS , safeSub ( tokenState . balanceOf ( FEE_ADDRESS ) , value ) ) ; tokenState . setBalanceOf ( account , safeAdd ( tokenState . balanceOf ( account ) , value ) ) ; emitFeesWithdrawn ( account , value ) ; emitTransfer ( FEE_ADDRESS , account , value ) ; return true ; }
","Withdraw tokens from the fee pool into a given account .
"
"function ( ) payable { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender , msg . sig , msg . data ) ) revert ( ) ; } else { revert ( ) ; } }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function takeFee ( uint256 _amount ) public withPerm ( FEE_ADMIN ) returns ( bool ) { require ( polyToken . transferFrom ( address ( this ) , IModuleFactory ( factory ) . owner ( ) , _amount ) , ""Unable to take fee"" ) ; return true ; }
","used to withdraw the fee by the factory owner
"
"function transfer ( address _to , uint256 _value ) public saleOrUnfrozen ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }
","Standard transfer ( ) but with check of frozen status
"
"function ( ) payable { require ( isContract ( controller ) ) ; bool proxyPayment = TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ; require ( proxyPayment ) ; }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function createSeries ( bytes name , uint shares , string industry , string symbol , address extraContract ) payable returns ( address seriesAddress , uint seriesId ) { seriesId = series . length ; var ( latestAddress , latestName ) = SeriesFactory ( seriesFactory ) . createSeries . value ( msg . value ) ( seriesId , name , shares , industry , symbol , msg . sender , extraContract ) ; if ( latestAddress == 0 ) throw ; if ( latestName > 0 ) if ( seriesByName [ latestName ] == 0 ) seriesByName [ latestName ] = latestAddress ; else throw ; series . push ( latestAddress ) ; expiresAt [ latestAddress ] = now + 1 years ; latestSeriesForUser [ msg . sender ] = latestAddress ; seriesByAddress [ latestAddress ] = latestName ; SeriesCreated ( latestAddress , seriesId ) ; return ( latestAddress , seriesId ) ; }
","This will create new series .
"
"function getTokensBalance ( uint index ) private view returns ( uint ) { Airdrop memory airdrop = airdrops [ index ] ; Token t = Token ( airdrop . tokenSC ) ; return ( t . balanceOf ( this ) ) ; }
","Get the balance of a specific token within the smart contracts
"
"function changeAdmin ( address newAdmin ) public validate_address ( newAdmin ) onlyAdmin { if ( admin == newAdmin ) revert ( ) ; AdminOwnershipTransferred ( admin , newAdmin ) ; admin = newAdmin ; }
","only the admin is allowed to change the admin .
"
"function updateLimitPerMonth ( bytes32 _externalHolderId , uint _limit ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; uint _currentLimit = holders [ _holderIndex ] . sendLimPerDay ; holders [ _holderIndex ] . sendLimPerMonth = _limit ; _emitMonthLimitChanged ( _externalHolderId , _currentLimit , _limit ) ; return OK ; }
","Updates limit per month for holder .
"
"function release ( IERC20 token ) public { uint256 unreleased = _releasableAmount ( token ) ; require ( unreleased > 0 ) ; _released [ token ] = _released [ token ] . add ( unreleased ) ; token . safeTransfer ( _beneficiary , unreleased ) ; emit TokensReleased ( token , unreleased ) ; }
","Transfers vested tokens to beneficiary .
"
"function orderDepth ( bytes32 _orderID ) external view returns ( uint256 ) { if ( orders [ _orderID ] . blockNumber == 0 ) { return 0 ; } return ( block . number - orders [ _orderID ] . blockNumber ) ; }
","returns the block depth of the orderId
"
"function addFunctions ( address _functions ) public onlyOwner { require ( address ( functions ) == 0x0 ) ; functions = Functions ( _functions ) ; }
","Function to add functions contract
"
"function approveCodeUpgrade ( address _newAddress ) external returns ( bool ) { require ( msg . sender == currentApplicationEntityAddress ) ; uint8 atState = currentApp . CurrentEntityState ( ) ; lockCurrentApp ( ) ; if ( ! currentApp . transferAssetsToNewApplication ( _newAddress ) ) { revert ( ) ; } link ( _newAddress ) ; currentApp . setUpgradeState ( atState ) ; return true ; }
","ApplicationEntity Contract approves code Upgrade
"
"function removeNFToken ( address _from , uint256 _tokenId ) internal { require ( idToOwner [ _tokenId ] == _from ) ; assert ( ownerToNFTokenCount [ _from ] > 0 ) ; ownerToNFTokenCount [ _from ] = ownerToNFTokenCount [ _from ] - 1 ; delete idToOwner [ _tokenId ] ; }
","Use and override this function with caution .
"
"function isCreated ( bytes32 _symbol ) public view returns ( bool ) { return _assetOwner ( _symbol ) != 0 ; }
","Check asset existance .
"
"function decreaseApprovalWithSender ( address _sender , address _spender , uint256 _subtractedValue ) public onlyProxy returns ( bool success ) { require ( _spender != address ( 0 ) ) ; uint256 currentAllowance = erc20Store . allowed ( _sender , _spender ) ; uint256 newAllowance = currentAllowance - _subtractedValue ; require ( newAllowance <= currentAllowance ) ; erc20Store . setAllowance ( _sender , _spender , newAllowance ) ; erc20Proxy . emitApproval ( _sender , _spender , newAllowance ) ; return true ; }
","Core logic of the ` decreaseApproval ` function .
"
"function approve ( address _spender , uint256 _value ) public returns ( bool _success ) ;
","Allows ` _spender ` to withdraw from your account multiple times , up to the ` _value ` amount .
"
"function approveAllowance ( Data storage self , address spender , uint amount ) internal returns ( bool success ) { require ( spender != 0x0 , ""Error: `spender` address cannot be null."" ) ; string memory currency = getTokenSymbol ( self , address ( this ) ) ; require ( getTokenFrozenBalance ( self , currency , getForwardedAccount ( self , spender ) ) == 0 , ""Error: Spender must not have a frozen balance directly"" ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.allowance' , currency , getForwardedAccount ( self , msg . sender ) , getForwardedAccount ( self , spender ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , msg . sender ) ) ) ; require ( self . Storage . getUint ( id_a ) == 0 || amount == 0 , ""Error: Allowance must be zero (0) before setting an updated allowance for spender."" ) ; require ( self . Storage . getUint ( id_b ) >= amount , ""Error: Allowance cannot exceed msg.sender token balance."" ) ; require ( self . Storage . setUint ( id_a , amount ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; emit Approval ( msg . sender , spender , amount ) ; return true ; }
","Low-level method to set the allowance for a spender
"
"function artWorkChangeRequest ( uint256 _tokenId , string _meta , uint8 _v , bytes32 _r , bytes32 _s ) public payable returns ( uint256 ) { address recoveredSigner = verify ( keccak256 ( _meta ) , _v , _r , _s ) ; require ( signers [ recoveredSigner ] == true ) ; require ( msg . sender == token . getOwner ( _tokenId ) ) ; uint256 fee = getArtWorkChangeFee ( _tokenId ) ; require ( msg . value >= fee ) ; uint256 changeRequestCounter = artWorkChangeRequests . length ; artWorkChangeRequests . push ( ArtWorkChangeRequest ( msg . sender , _tokenId , changeRequestCounter , _meta , now , false ) ) ; token . increaseUpdateMetadataCounter ( _tokenId ) ; transferEthers ( platformWallet , msg . value ) ; emit ArtWorkChangeRequestMade ( msg . sender , _tokenId , changeRequestCounter , _meta , msg . value , now ) ; return changeRequestCounter ; }
","it allows token owner to create art work change request first user upload 2 images then do call this function admin can reject or approve it
"
"function areaRentPrice ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint numberOfPeriods ) public view returns ( uint ) { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; return rentals . blocksRentPrice ( numberOfPeriods , blocksList ( fromX , fromY , toX , toY ) ) ; }
","get area rent price in wei for number of periods specified ( period length is specified in rentals contract )
"
"function createRequestFromBytes ( bytes _data ) external whenNotPaused returns ( bytes32 requestId ) { require ( isTrustedContract ( msg . sender ) , ""caller should be a trusted contract"" ) ; address creator = extractAddress ( _data , 0 ) ; address payer = extractAddress ( _data , 20 ) ; require ( creator != 0 , ""creator should not be 0"" ) ; uint8 payeesCount = uint8 ( _data [ 40 ] ) ; uint256 offsetDataSize = uint256 ( payeesCount ) . mul ( 52 ) . add ( 41 ) ; uint8 dataSize = uint8 ( _data [ offsetDataSize ] ) ; string memory dataStr = extractString ( _data , dataSize , offsetDataSize . add ( 1 ) ) ; address mainPayee ; int256 mainExpectedAmount ; if ( payeesCount != 0 ) { mainPayee = extractAddress ( _data , 41 ) ; mainExpectedAmount = int256 ( extractBytes32 ( _data , 61 ) ) ; } requestId = generateRequestId ( ) ; requests [ requestId ] = Request ( payer , msg . sender , State . Created , Payee ( mainPayee , mainExpectedAmount , 0 ) ) ; emit Created ( requestId , mainPayee , payer , creator , dataStr ) ; for ( uint8 i = 1 ; i < payeesCount ; i = i . add ( 1 ) ) { address subPayeeAddress = extractAddress ( _data , uint256 ( i ) . mul ( 52 ) . add ( 41 ) ) ; require ( subPayeeAddress != 0 , ""subpayee should not be 0"" ) ; subPayees [ requestId ] [ i - 1 ] = Payee ( subPayeeAddress , int256 ( extractBytes32 ( _data , uint256 ( i ) . mul ( 52 ) . add ( 61 ) ) ) , 0 ) ; emit NewSubPayee ( requestId , subPayeeAddress ) ; } return requestId ; }
","Function used by currency contracts to create a request in the Core from bytes .
"
"function assignTeamTokens ( ) public onlyOwnerAndDirector { require ( ! assignedTeam ) ; assignedTeam = true ; _teamTransfer ( 0x1E21f744d91994D19f2a61041CD7cCA571185dfc , 13674375 * cstToMicro ) ; _teamTransfer ( 0x4CE4Ea57c40bBa26B7b799d5e0b4cd063B034c8A , 9920625 * cstToMicro ) ; _teamTransfer ( 0xdCd8a8e561d23Ca710f23E7612F1D4E0dE9bde83 , 1340625 * cstToMicro ) ; _teamTransfer ( 0x0dFFA8624A1f512b8dcDE807F8B0Eab68672e5D5 , 13406250 * cstToMicro ) ; _teamTransfer ( 0xE091180bB0C284AA0Bd15C6888A41aba45c54AF0 , 13138125 * cstToMicro ) ; _teamTransfer ( 0xcdB7A51bA9af93a7BFfe08a31E4C6c5f9068A051 , 3960000 * cstToMicro ) ; _teamTransfer ( 0x57Bd10E12f789B74071d62550DaeB3765Ad83834 , 3960000 * cstToMicro ) ; _teamTransfer ( 0xEE74922eaF503463a8b20aFaD83d42F28D59f45d , 3960000 * cstToMicro ) ; _teamTransfer ( 0x58681a49A6f9D61eB368241a336628781afD5f87 , 1320000 * cstToMicro ) ; _teamTransfer ( 0x3C4662b4677dC81f16Bf3c823A7E6CE1fF7e94d7 , 80000 * cstToMicro ) ; _teamTransfer ( 0x041A1e96E0C9d3957613071c104E44a9c9d43996 , 150000 * cstToMicro ) ; _teamTransfer ( 0xD63d63D2ADAF87B0Edc38218b0a2D27FD909d8B1 , 100000 * cstToMicro ) ; _teamTransfer ( 0xd0d49Da78BbCBb416152dC41cc7acAb559Fb8275 , 80000 * cstToMicro ) ; _teamTransfer ( 0x75FdfAc64c27f5B5f0823863Fe0f2ddc660A376F , 100000 * cstToMicro ) ; _teamTransfer ( 0xb66AFf323d97EF52192F170fF0F16D0a05Ebe56C , 60000 * cstToMicro ) ; _teamTransfer ( 0xec6234E34477f7A19cD3D67401003675522a4Fad , 60000 * cstToMicro ) ; _teamTransfer ( 0x1be50e8337F99983ECd4A4b15a74a5a795B73dF9 , 40000 * cstToMicro ) ; _teamTransfer ( 0x4c14DB011065e72C6E839bd826d101Ec09d3C530 , 833000 * cstToMicro ) ; _teamTransfer ( 0x7891C07b20fFf1918fAD43CF6fc7E3f83900f06d , 50000 * cstToMicro ) ; _teamTransfer ( 0x27996b3c1EcF2e7cbc5f31dE7Bca17EFCb398617 , 150000 * cstToMicro ) ; }
","tokens for team have their own supply
"
"function multisend ( address tokenAddress , address [ ] destinations , uint256 [ ] values ) external onlyOwner { require ( destinations . length == values . length ) ; uint256 i = 0 ; while ( i < destinations . length ) { Nomin ( tokenAddress ) . transferSenderPaysFee ( destinations [ i ] , values [ i ] ) ; i += 1 ; } }
","Multisend airdrops tokens to an array of destinations .
"
"function blockSubsidy ( uint256 _block ) public constant notBeforeGenesis returns ( uint256 ) { uint256 halvings = _block . div ( subsidyHalvingInterval ) ; if ( halvings >= maxHalvings ) return 0 ; uint256 subsidy = INITIAL_SUBSIDY >> halvings ; return subsidy ; }
","Calculate the total subsidy of a block
"
"function transfer ( address to , uint256 value ) public returns ( bool ) { bool transferred = super . transfer ( to , value ) ; if ( transferred ) { addBalanceBlocks ( msg . sender ) ; addBalanceBlocks ( to ) ; if ( ! holdersMap [ to ] ) { holdersMap [ to ] = true ; holders . push ( to ) ; } } return transferred ; }
","Transfer token for a specified address
"
"function upgrade ( uint256 value ) external { if ( getState ( ) != State . Success ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( finalizedUpgrade ) throw ; if ( value == 0 ) throw ; if ( value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }
","Upgrade tokens to the new token contract .
"
"function getAttributeTypeInformation ( uint256 attributeTypeID ) external view returns ( string description , bool isRestricted , bool isOnlyPersonal , address secondarySource , uint256 secondaryAttributeTypeID , uint256 minimumRequiredStake , uint256 jurisdictionFee ) { return ( _attributeTypes [ attributeTypeID ] . description , _attributeTypes [ attributeTypeID ] . restricted , _attributeTypes [ attributeTypeID ] . onlyPersonal , _attributeTypes [ attributeTypeID ] . secondarySource , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID , _attributeTypes [ attributeTypeID ] . minimumStake , _attributeTypes [ attributeTypeID ] . jurisdictionFee ) ; }
","Get comprehensive information on an attribute type with ID ` attributeTypeID ` .
"
"function setApprovalForAll ( address _operator , bool _approved ) external { require ( _operator != msg . sender ) ; operators [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
","Enable or disable approval for a third party ( `` operator '' ) to manage all of ` msg.sender ` 's assets
"
"function tokenFactory ( uint256 _amount ) onlyOwner returns ( bool success ) { require ( _amount > 0 ) ; require ( tokenMintingEnabled ) ; if ( ! tokenMint ( msg . sender , _amount ) ) revert ( ) ; return true ; }
","Used to mint tokens , only usable by the contract owner
"
"function transfer ( address destination , uint256 amount ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; balances [ destination ] = balances [ destination ] . add ( amount ) ; emit Transfer ( msg . sender , destination , amount ) ; return true ; }
","Transfers ` amount ` from msg.sender to ` destination `
"
"function bountyTokenWithdrawal ( ) public onlyOwner { require ( crowdsaleClosed == true ) ; require ( bountyPaid == false ) ; tokenReward . transfer ( beneficiary , bountyAmount ) ; bountyPaid = true ; }
","A function to withdraw tokens for bounty campaign .
"
"function revealVote ( uint _pollID , uint _voteOption , uint _salt ) public { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( _voteOption , _salt ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; emit _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender ) ; }
","Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens
"
"function adminWithdraw ( address _to ) public { require ( msg . sender == admin , ""Only the admin can call this function"" ) ; _to . transfer ( address ( this ) . balance ) ; }
","Withdraw all volunteered funds to ` ( _to ) `
"
"function addToonContract ( address _toonContractAddress ) external onlyOwner { ToonInterface _interface = ToonInterface ( _toonContractAddress ) ; require ( _interface . isToonInterface ( ) ) ; uint _index = toonContracts . push ( _interface ) - 1 ; addressToIndex [ _toonContractAddress ] = _index ; }
","Adds a new toon contract .
"
"function cancel ( uint _price ) external returns ( bool ) ;
","Cancel order at ` _price `
"
"function setStepLimits ( uint256 _firstStepLimit , uint256 _secondStepLimit ) public onlyCLevel { firstStepLimit = _firstStepLimit ; secondStepLimit = _secondStepLimit ; }
","Any C-level can change first Step Limit .
"
"function end ( List storage self ) internal view returns ( address ) { return self . list [ NULL ] . previous ; }
","Get the node at the end of a double linked list .
"
"function createLoan ( Oracle _oracleContract , address _borrower , bytes32 _currency , uint256 _amount , uint256 _interestRate , uint256 _interestRatePunitory , uint256 _duesIn , uint256 _cancelableAt , uint256 _expirationRequest , string _metadata ) public returns ( uint256 ) { require ( ! deprecated ) ; require ( _cancelableAt <= _duesIn ) ; require ( _oracleContract != address ( 0 ) || _currency == 0x0 ) ; require ( _borrower != address ( 0 ) ) ; require ( _amount != 0 ) ; require ( _interestRatePunitory != 0 ) ; require ( _interestRate != 0 ) ; require ( _expirationRequest > block . timestamp ) ; var loan = Loan ( Status . initial , _oracleContract , _borrower , 0x0 , msg . sender , 0x0 , _amount , 0 , 0 , 0 , 0 , _interestRate , _interestRatePunitory , 0 , _duesIn , _currency , _cancelableAt , 0 , 0x0 , _expirationRequest , _metadata ) ; uint index = loans . push ( loan ) - 1 ; CreatedLoan ( index , _borrower , msg . sender ) ; if ( msg . sender == _borrower ) { approveLoan ( index ) ; } return index ; }
","Creates a loan request , the loan can be generated with any borrower and conditions ; if the borrower agrees it must call the `` approve '' function .
"
"function changeSecurityLaunchFee ( uint256 _stLaunchFee ) external ;
","Sets the ticker registration fee in POLY tokens
"
"function claimRefund ( ) public whenNotPaused { require ( hasEnded ( ) && ! goalReached ( ) && isRefunding ) ; vault . refund ( msg . sender ) ; token . refundTokens ( msg . sender , tokensBought [ msg . sender ] ) ; }
","If crowdsale is unsuccessful , investors can claim refunds here
"
"function getTags ( ) public view returns ( bytes32 [ ] ) ;
","Get the tags related to the module factory
"
"function getTagByModuleType ( uint8 _moduleType ) public view returns ( bytes32 [ ] ) { return availableTags [ _moduleType ] ; }
","Use to get all the tags releated to the functionality of the Module Factory .
"
"function forceRejectVotes ( bytes32 _key , address _user ) external onlyContractOwner returns ( uint ) { return _revoke ( _key , _user ) ; }
","Revoke user votes for transaction Can be called only by contract owner
"
"function claimTokens ( address _token ) public onlyOwner { ExchangerI exchanger = ExchangerI ( factory . exchanger ( ) ) ; require ( address ( exchanger ) != 0x0 ) ; ERC20Basic wpr = ERC20Basic ( exchanger . wpr ( ) ) ; require ( _token != address ( wct2 ) && _token != address ( wpr ) ) ; if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Basic token = ERC20Basic ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function voteFor ( uint motionID ) external { uint weight = setupVote ( motionID ) ; vote [ msg . sender ] [ motionID ] = Vote . Yea ; votesFor [ motionID ] = safeAdd ( votesFor [ motionID ] , weight ) ; emit VotedFor ( msg . sender , motionID , weight ) ; }
","The sender casts a vote in favour of confiscation of the target account 's nomin balance .
"
"function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceId_ERC721Exists ) ) ; }
","Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
"
"function addTenParticipants ( address participant1 , address participant2 , address participant3 , address participant4 , address participant5 , address participant6 , address participant7 , address participant8 , address participant9 , address participant10 ) public onlyAdmin returns ( bool ) { require ( addParticipant ( participant1 ) ) ; require ( addParticipant ( participant2 ) ) ; require ( addParticipant ( participant3 ) ) ; require ( addParticipant ( participant4 ) ) ; require ( addParticipant ( participant5 ) ) ; require ( addParticipant ( participant6 ) ) ; require ( addParticipant ( participant7 ) ) ; require ( addParticipant ( participant8 ) ) ; require ( addParticipant ( participant9 ) ) ; require ( addParticipant ( participant10 ) ) ; return true ; }
","used to save gas .
"
"function extractString ( bytes data , uint8 size , uint _offset ) internal pure returns ( string ) { bytes memory bytesString = new bytes ( size ) ; for ( uint j = 0 ; j < size ; j ++ ) { bytesString [ j ] = data [ _offset + j ] ; } return string ( bytesString ) ; }
","Extracts a string from a bytes .
"
"function getSTFactoryAddress ( ) public view returns ( address ) { return getAddress ( Encoder . getKey ( ""protocolVersionST"" , getUint ( Encoder . getKey ( ""latestVersion"" ) ) ) ) ; }
","Returns the current STFactory Address
"
"function verifyTransfer ( address _from , address _to , uint256 , bool ) public returns ( Result ) { if ( ! paused ) { if ( allowAllTransfers ) { return Result . VALID ; } if ( allowAllBurnTransfers && ( _to == address ( 0 ) ) ) { return Result . VALID ; } if ( allowAllWhitelistTransfers ) { return ( onWhitelist ( _to ) && onWhitelist ( _from ) ) ? Result . VALID : Result . NA ; } if ( allowAllWhitelistIssuances && _from == issuanceAddress ) { if ( ! whitelist [ _to ] . canBuyFromSTO && isSTOAttached ( ) ) { return Result . NA ; } return onWhitelist ( _to ) ? Result . VALID : Result . NA ; } return ( ( onWhitelist ( _from ) && whitelist [ _from ] . fromTime <= now ) && ( onWhitelist ( _to ) && whitelist [ _to ] . toTime <= now ) ) ? Result . VALID : Result . NA ; } return Result . NA ; }
","default implementation of verifyTransfer used by SecurityToken If the transfer request comes from the STO , it only checks that the investor is in the whitelist If the transfer request comes from a token holder , it checks that : a ) Both are on the whitelist b ) Seller 's sale lockup period is over c ) Buyer 's purchase lockup is over
"
"function batchCreateSingleSeedAuction ( uint8 [ ] _teamIds , uint8 [ ] _posIds , uint256 [ ] _attributes , uint256 [ ] _playerOverrideIds , uint256 [ ] _mlbPlayerIds , uint256 _startPrice ) public onlyGameManager whenNotPaused { require ( isBatchSupported ) ; require ( _teamIds . length > 0 && _posIds . length > 0 && _attributes . length > 0 && _playerOverrideIds . length > 0 && _mlbPlayerIds . length > 0 ) ; require ( nonFungibleContract != address ( 0 ) ) ; uint256 nftId ; require ( _startPrice != 0 ) ; for ( uint ii = 0 ; ii < _mlbPlayerIds . length ; ii ++ ) { require ( _teamIds [ ii ] != 0 ) ; nftId = nonFungibleContract . createSeedCollectible ( _teamIds [ ii ] , _posIds [ ii ] , _attributes [ ii ] , address ( this ) , 0 , _playerOverrideIds [ ii ] , _mlbPlayerIds [ ii ] ) ; _createSale ( nftId , _startPrice , 0 , SALES_DURATION , address ( this ) ) ; } }
","Helps in creating single seed auctions in batches
"
"function convertRate ( Oracle oracle , bytes32 currency , bytes data , uint256 amount ) public returns ( uint256 ) { if ( oracle == address ( 0 ) ) { return amount ; } else { uint256 rate ; uint256 decimals ; ( rate , decimals ) = oracle . getRate ( currency , data ) ; require ( decimals <= RCN_DECIMALS ) ; return ( safeMult ( safeMult ( amount , rate ) , ( 10 ** ( RCN_DECIMALS - decimals ) ) ) ) / PRECISION ; } }
","Converts an amount to RCN using the loan oracle .
"
"function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceSignature_ERC721Optional ) || ( _interfaceID == InterfaceSignature_ERC721Enumerable ) || ( _interfaceID == InterfaceSignature_ERC721Metadata ) ) ; }
","Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
"
"function approve ( address _to , uint256 _tokenId ) external whenNotPaused onlyOwnerOf ( _tokenId ) { address owner = ownerOf ( _tokenId ) ; require ( _to != owner ) ; if ( getApproved ( _tokenId ) != 0 || _to != 0 ) { tokenApprovals [ _tokenId ] = _to ; Approval ( owner , _to , _tokenId ) ; } }
","Approves another address to claim for the ownership of the given token ID
"
"function grant_token_from_offchain ( address _toAddr , uint _nTokens , string _ref ) public onlyRobot { require ( ( campaignState == 2 ) || ( campaignState == 1 ) ) ; do_grant_tokens ( _toAddr , _nTokens ) ; TokenGranted ( _toAddr , _nTokens , _ref ) ; }
","Gnenerate token `` manually '' without payment We intend to use this to generate tokens from Bitcoin contributions without without Ether being sent to this contract Note that this function can be triggered only by our BTC processing robot .
"
"function getValidator ( uint256 index ) external view returns ( address ) { return _validatorAccounts [ index ] ; }
","Get the account of the validator at index ` index ` .
"
"function ( ) external { revert ( ) ; }
","It 's a fallback function supposed to return sent Ethers by reverting the transaction
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { approve ( _spender , _value ) ; if ( ! _spender . call ( bytes4 ( bytes32 ( keccak256 ( ""receiveApproval(address,uint256,address,bytes)"" ) ) ) , msg . sender , _value , this , _extraData ) ) { revert ( ) ; } return true ; }
","` msg.sender ` approves ` _spender ` to send ` _value ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function listPairForReserve ( address reserve , ERC20 token , bool ethToToken , bool tokenToEth , bool add ) public onlyOperator returns ( bool ) { require ( reserveType [ reserve ] != ReserveType . NONE ) ; if ( ethToToken ) { listPairs ( reserve , token , false , add ) ; ListReservePairs ( reserve , ETH_TOKEN_ADDRESS , token , add ) ; } if ( tokenToEth ) { listPairs ( reserve , token , true , add ) ; if ( add ) { require ( token . approve ( reserve , 2 ** 255 ) ) ; } else { require ( token . approve ( reserve , 0 ) ) ; } ListReservePairs ( reserve , token , ETH_TOKEN_ADDRESS , add ) ; } setDecimals ( token ) ; return true ; }
","can be called only by operator
"
"function getAnime ( uint256 _tokenId ) public view returns ( string animeName , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; animeName = person . name ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific person .
"
"function multisend ( address [ ] _recipients , uint256 [ ] _balances ) external { require ( _recipients . length == _balances . length , ""not equal length"" ) ; require ( _recipients . length <= multiSendLimit , ""more than limit"" ) ; uint256 i = 0 ; for ( i ; i < _balances . length ; i ++ ) { transfer ( _recipients [ i ] , _balances [ i ] ) ; } emit Multisended ( ) ; }
","Function to send multiple token transfers in one tx
"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 _remaining ) ;
","Returns the amount which ` _spender ` is still allowed to withdraw from ` _owner ` .
"
"function submitAnswer ( bytes32 question_id , bytes32 answer , uint256 max_previous ) external payable { }
","Submit an answer for a question .
"
"function handleBelowPlannedWhitelistedContribution ( uint256 plannedContribution ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( msg . value ) ; AllowedContributionCheck ( msg . value , AllowedContributionState . BelowWhitelisted ) ; return ( msg . value , 0 ) ; }
","Returns the contribution and refund value to be used when the transaction value is lower than the whitelisted contribution for the sender .
"
"function _transferSenderPaysFee_byProxy ( address sender , address to , uint value ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; return _internalTransfer ( sender , to , value , fee ) ; }
","Ability to transfer where the sender pays the fees ( not ERC20 )
"
"function attack ( uint256 _champId , uint256 _targetId ) external onlyOwnerOfChamp ( _champId ) isChampReady ( _champId ) notSelfAttack ( _champId , _targetId ) targetExists ( _targetId ) { Champ storage myChamp = champs [ _champId ] ; Champ storage enemyChamp = champs [ _targetId ] ; uint256 pointsGiven ; uint256 pointsToAttackPower ; uint256 myChampAttackPower ; uint256 enemyChampDefencePower ; uint256 myChampCooldownReduction ; ( myChampAttackPower , , myChampCooldownReduction ) = getChampStats ( _champId ) ; ( , enemyChampDefencePower , ) = getChampStats ( _targetId ) ; if ( myChampAttackPower > enemyChampDefencePower ) { if ( myChampAttackPower - enemyChampDefencePower < 5 ) { ( pointsGiven , pointsToAttackPower ) = _getPoints ( 3 ) ; } else if ( myChampAttackPower - enemyChampDefencePower < 10 ) { ( pointsGiven , pointsToAttackPower ) = _getPoints ( 2 ) ; } else { ( pointsGiven , pointsToAttackPower ) = _getPoints ( 1 ) ; } _attackCompleted ( myChamp , enemyChamp , pointsGiven , pointsToAttackPower ) ; emit Attack ( myChamp . id , enemyChamp . id , true ) ; } else { ( pointsGiven , pointsToAttackPower ) = _getPoints ( 1 ) ; _attackCompleted ( enemyChamp , myChamp , pointsGiven , pointsToAttackPower ) ; emit Attack ( enemyChamp . id , myChamp . id , false ) ; } myChamp . readyTime = uint256 ( block . timestamp + myChamp . cooldownTime - myChampCooldownReduction ) ; }
","Attack function
"
"function assetPrices ( address asset ) public view returns ( uint ) { ( Error err , Exp memory result ) = fetchAssetPrice ( asset ) ; if ( err != Error . NO_ERROR ) { return 0 ; } return result . mantissa ; }
","Reads scaled price of specified asset from the price oracle
"
"function name ( ) external pure returns ( string ) { return ""Su Squares"" ; }
","A descriptive name for a collection of NFTs in this contract
"
"function unlock ( ) public payable returns ( bool success ) { uint256 amount = lockedBalance [ msg . sender ] ; require ( amount > 0 ) ; require ( now >= timeRelease [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; lockedBalance [ msg . sender ] = 0 ; timeRelease [ msg . sender ] = 0 ; emit Transfer ( 0x0 , msg . sender , amount ) ; emit UnLock ( msg . sender , amount ) ; return true ; }
","Transfers tokens held by lock .
"
"function addOwnToken ( ) internal returns ( bool ) { require ( setOwnContract ) ; addToWhitelist ( this , 5000 * 1e8 , 36500 ) ; setOwnContract = false ; return true ; }
","Allow the dev to set it 's own token as accepted payment .
"
"function setVotingPeriod ( uint duration ) external onlyOwner { require ( MIN_VOTING_PERIOD <= duration && duration <= MAX_VOTING_PERIOD ) ; require ( duration <= havven . feePeriodDuration ( ) ) ; votingPeriod = duration ; }
","Set the length of time a vote runs for .
"
"function getAnimecard ( uint256 _tokenId ) external view returns ( string characterName , string studioName , string characterImageUrl , string characterImageHash , uint256 sellingPrice , address owner ) { Animecard storage animecard = animecards [ _tokenId ] ; characterName = animecard . characterName ; studioName = animecard . studioName ; characterImageUrl = animecard . characterImageUrl ; characterImageHash = animecard . characterImageHash ; sellingPrice = animecardToPrice [ _tokenId ] ; owner = animecardToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific animecard .
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = cardTokenToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function clearCollection ( uint64 _collectionIndex ) validIndex ( _collectionIndex ) public returns ( uint64 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; uint64 [ ] storage collection = collectionTokens [ _collectionIndex ] ; require ( collection . length > 0 , ""Collection is already cleared"" ) ; for ( uint i = 0 ; i < collection . length ; i ++ ) { PixelCon storage pixelcon = pixelcons [ collection [ i ] ] ; require ( isCreatorAndOwner ( msg . sender , pixelcon . tokenId ) , ""Sender is not the creator and owner of the PixelCons"" ) ; pixelcon . collectionIndex = 0 ; } delete collectionNames [ _collectionIndex ] ; delete collectionTokens [ _collectionIndex ] ; emit ClearCollection ( _collectionIndex ) ; return _collectionIndex ; }
","Clear collection # ` ( _collectionIndex ) `
"
"function disableNewStakes ( ) public onlyAdmin returns ( bool ) { newStakesAllowed = false ; return true ; }
","Used to disable new stakes from being made Only usable by contract admin
"
"function totalSupply ( bytes32 _symbol ) public view returns ( uint ) { return assets [ _symbol ] . totalSupply ; }
","Returns asset total supply .
"
"function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index <= ( rareArray . length - 1 ) ) ; return _index ; }
","Enumerate valid rare items
"
"function buyToken ( ) internal { uint256 value = msg . value ; address sender = msg . sender ; require ( ! icoIsClosed ) ; require ( ! frozenAccount [ sender ] ) ; require ( value > 0 ) ; require ( currentTokenPrice > 0 ) ; uint256 amount = value / currentTokenPrice ; uint256 detract = amount / commRate ; uint256 moneyBack = value - ( amount * currentTokenPrice ) ; uint256 detract2 = value / commRate ; require ( tokenBalanceOf [ this ] >= amount ) ; amountOfInvestments = amountOfInvestments + ( value - moneyBack ) ; updatePrices ( ) ; _transfer ( this , sender , amount - detract ) ; if ( ! minimalGoalReached ) { checkMinimalGoal ( ) ; } if ( moneyBack > 0 ) { sender . transfer ( moneyBack - detract2 ) ; } }
","Processing each buying
"
"function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }
","Subtracts two numbers , throws on overflow ( i.e .
"
"function claimPrepaid ( uint _index , uint _boughtTokensPrice , uint _tokenAmount , string _privatePhrase , uint _backerRank ) external EarliestBackersSet { if ( backers [ msg . sender ] [ _index ] . prepaid == true && backers [ msg . sender ] [ _index ] . claimed == false && backers [ msg . sender ] [ _index ] . tokenAmount == _tokenAmount && backers [ msg . sender ] [ _index ] . tokenPrice == _boughtTokensPrice && backers [ msg . sender ] [ _index ] . privateHash == sha3 ( _privatePhrase , msg . sender ) && backers [ msg . sender ] [ _index ] . backerRank == _backerRank ) { backers [ msg . sender ] [ _index ] . claimed = true ; claimedPrepaidUnits += _tokenAmount ; PrepaidTokensClaimedEvent ( msg . sender , _index , _boughtTokensPrice , _tokenAmount ) ; } else { throw ; } }
","Claiming ` _tokenAmount.number ( ) ` superDAO tokens by ` msg.sender.address ( ) `
"
"function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused returns ( bool success ) { require ( _value > 0 ) ; require ( balanceOf [ _from ] >= _value ) ; require ( balanceOf [ _to ] + _value >= balanceOf [ _to ] ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }
","function transferFrom : moves tokens from one address to another
"
"function createInvite ( bytes _sig ) public onlyUser { address inviteAddress = signingLogic . recoverSigner ( keccak256 ( abi . encodePacked ( msg . sender ) ) , _sig ) ; require ( ! pendingInvites [ inviteAddress ] ) ; pendingInvites [ inviteAddress ] = true ; emit InviteCreated ( msg . sender , inviteAddress ) ; }
","Create an invite using the signing model described in the contract description
"
"function hasSellerBeenAccepted ( address seller ) public view validAddress ( seller ) returns ( bool ) { return sellerInfo [ seller ] . createdAt != 0 ; }
","Checks if a DataResponse for a given seller has been accepted .
"
"function successful ( ) public { require ( state == State . Successful ) ; uint256 temp = pending [ creator ] ; pending [ creator ] = 0 ; require ( tokenReward . transfer ( creator , temp ) ) ; emit LogContributorsPayout ( creator , temp ) ; creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
","successful closure handler
"
"function _adjustInvestorCount ( address _from , address _to , uint256 _value ) internal { TokenLib . adjustInvestorCount ( investorData , _from , _to , _value , balanceOf ( _to ) , balanceOf ( _from ) ) ; }
","Keeps track of the number of non-zero token holders
"
"function getTiki ( uint256 _tokenId ) public view returns ( string tikiName , uint256 currentPrice , uint256 basePrice , address currentOwner , uint256 bagHolderFund , bool isBagFundAvailable ) { TikiMask storage tiki = tikiMasks [ _tokenId ] ; tikiName = tiki . name ; currentPrice = priceOf ( _tokenId ) ; basePrice = tiki . basePrice ; currentOwner = tikiIndexToOwner [ _tokenId ] ; bagHolderFund = tiki . bagHolderFund ; isBagFundAvailable = now > ( tiki . saleTime + priceFallDuration ) ; }
","Returns all the relevant information about a specific tiki .
"
"function getName ( ) public view returns ( bytes32 ) { return ""ERC20DividendCheckpoint"" ; }
","Get the name of the Module
"
"function canAdvertise ( address advertiser , uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) external view returns ( bool ) { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; return ads . canAdvertiseOnBlocks ( advertiser , blocksList ( fromX , fromY , toX , toY ) ) ; }
","check if an advertiser is allowed to put ads within area ( i.e .
"
"function cloneTokens ( uint _from , uint _to ) ;
","Function to clone tokens from a manager
"
"function getSTODetails ( ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , bool ) { return ( startTime , endTime , cap , rate , fundsRaised , investorCount , tokensSold , ( fundraiseType == FundraiseType . POLY ) ) ; }
","Return the STO details
"
"function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) , ""Spender is not provided"" ) ; require ( signatures [ _signature ] == false , ""No signature"" ) ; bytes32 hashedTx = approvePreSignedHashing ( address ( this ) , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) , ""From addres is not provided"" ) ; allowed [ from ] [ _spender ] = _value ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned approval
"
"function mOnTransfer ( address from , address to , uint256 amount ) internal returns ( bool allow ) ;
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function updateStageCap ( uint256 _tokens ) internal returns ( uint256 ) { Stage storage stage = stages [ currentStage ] ; uint256 cap = stage . cap ; if ( cap >= _tokens ) { stage . cap = cap . sub ( _tokens ) ; return 0 ; } stage . cap = 0 ; uint256 excessTokens = _tokens . sub ( cap ) ; if ( icoTokensLeft >= excessTokens ) { icoTokensLeft = icoTokensLeft . sub ( excessTokens ) ; return 0 ; } icoTokensLeft = 0 ; return excessTokens . sub ( icoTokensLeft ) ; }
","Updates current stage cap and returns amount of excess tokens if ICO does not have enough tokens
"
"function reclaimEther ( ) onlyOwner external { owner . transfer ( address ( this ) . balance ) ; }
","Transfer all Ether held by the contract to the owner .
"
"function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = playerTokenToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
","Find the owner of an NFT
"
"function transferToVault ( address _token ) external { require ( allowRecoverability ( _token ) , ERROR_DISALLOWED ) ; address vault = getRecoveryVault ( ) ; require ( isContract ( vault ) , ERROR_VAULT_NOT_CONTRACT ) ; if ( _token == ETH ) { vault . transfer ( address ( this ) . balance ) ; } else { uint256 amount = ERC20 ( _token ) . balanceOf ( this ) ; ERC20 ( _token ) . transfer ( vault , amount ) ; } }
","Send funds to recovery Vault .
"
"function setOwner ( address _newOwner ) public onlyOwner { owner = _newOwner ; }
","Changes the owner of the contract
"
"function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 0 ) ; return allPermissions ; }
","Return the permissions flag that are associated with STO
"
"function setPlotData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public whenNotPaused { require ( _owns ( msg . sender , _deedId ) && identifierToRentPeriodEndTimestamp [ _deedId ] < now || _rents ( msg . sender , _deedId ) ) ; _setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; }
","Set the data associated with a plot .
"
"function createNewGame ( string teamA , string teamB , string description , uint frozenTimestamp ) external onlyOwner { uint gameId = games . push ( Game ( teamA , 0 , teamB , 0 , 0 , description , frozenTimestamp , 0 , GameResults . NotYet , GameStates . Open , false ) ) - 1 ; emit GameHasOpened ( gameId , teamA , teamB , description , frozenTimestamp ) ; }
","This function creates a new game
"
"function isWhitelisted ( address _investor , uint256 _tier ) public constant returns ( bool ) { WhitelistedInvestor memory investor = investors [ _investor ] ; return ( investor . tier <= _tier && investor . status ) ; }
","Notifies if an investor is whitelisted for contribution
"
"function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) { return FundInterface ( msg . sender ) . getManager ( ) == ofParticipant ; }
","Checks whether investment is permitted for a participant
"
"function changeOwner ( address _newOwner ) onlyOwner public { newOwner = _newOwner ; }
","` owner ` can step down and assign some other address to this role
"
"function updateFeeForCurrentStakingInterval ( ) external onlyOperator isDoneStaking { require ( feeCalculated == false ) ; uint feeReceived = feeToken . balanceOf ( this ) ; feeForTheStakingInterval = feeForTheStakingInterval . add ( feeReceived . add ( this . balance . div ( weiPerFee ) ) ) ; feeCalculated = true ; FeeCalculated ( feeForTheStakingInterval , feeReceived , this . balance , startBlock , endBlock ) ; if ( feeReceived > 0 ) feeToken . burnTokens ( feeReceived ) ; if ( this . balance > 0 ) wallet . transfer ( this . balance ) ; }
","To update the price of FEE tokens to the current value .
"
"function supportsInterface ( bytes4 interfaceID ) public pure returns ( bool ) { return ( interfaceID == this . supportsInterface . selector || interfaceID == 0x5b5e139f || interfaceID == 0x80ac58cd || interfaceID == 0x780e9d63 ) ; }
","Query if a contract implements an interface
"
"function mintWithData ( address _investor , uint256 _value , bytes _data ) public onlyModuleOrOwner ( MINT_KEY ) isMintingAllowed ( ) returns ( bool success ) { require ( _investor != address ( 0 ) , ""Investor is 0"" ) ; require ( _updateTransfer ( address ( 0 ) , _investor , _value , _data ) , ""Transfer invalid"" ) ; _adjustTotalSupplyCheckpoints ( ) ; totalSupply_ = totalSupply_ . add ( _value ) ; balances [ _investor ] = balances [ _investor ] . add ( _value ) ; emit Minted ( _investor , _value ) ; emit Transfer ( address ( 0 ) , _investor , _value ) ; return true ; }
","mints new tokens and assigns them to the target _investor .
"
"function withdrawRemaining ( address to ) external payloadSizeIs ( 1 * 32 ) onlyowner returns ( bool ) { return m_SMR . transfer ( to , m_SMR . balanceOf ( this ) ) ; }
","Transfers using plain transfer remaining tokens .
"
"function transferFrom ( address _from , address _to , uint256 _value ) notPendingWithdrawal returns ( bool success ) { if ( balanceOf [ _from ] < _value ) throw ; if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function burnFrom ( address _from , uint256 _value ) onlyOwner public returns ( bool success ) { require ( _value >= 0 ) ; require ( _balanceOf [ _from ] >= _value ) ; require ( _totalSupply >= _value ) ; _balanceOf [ _from ] -= _value ; _totalSupply -= _value ; Burn ( _from , _value ) ; return true ; }
","Destroy tokens from other account , can be run only by owner Remove ` _value ` tokens from the system irreversibly on behalf of ` _from ` .
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] > 0 ) ; allowance [ msg . sender ] [ _spender ] = _amount ; Approve ( msg . sender , _spender , _amount ) ; return true ; }
","Used to approve a third-party to send funds on your behalf
"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal whenNotPaused ifWhitelisted ( _beneficiary ) { require ( initialized ) ; amountInUSDCents = convertToCents ( _weiAmount , etherPriceInCents , 18 ) ; if ( assignedBonusRates [ _beneficiary ] == 0 ) { require ( amountInUSDCents >= minContributionInUSDCents ) ; assignedBonusRates [ _beneficiary ] = getBonusPercentage ( amountInUSDCents ) ; } super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; }
","Additional validation rules before token contribution is actually allowed .
"
"function calcValuePerShare ( uint totalValue , uint numShares ) view pre_cond ( numShares > 0 ) returns ( uint valuePerShare ) { valuePerShare = toSmallestShareUnit ( totalValue ) / numShares ; }
","Calculates the share price of the fund
"
"function schedulePriceUpdatesFixed ( uint256 [ ] _times ) payable isAdminOrOwner public { bytes32 requestId ; uint256 maximumScheduledUpdated ; if ( _times . length == 0 ) { require ( oraclize_getPrice ( ""URL"" , gasLimit ) <= address ( this ) . balance , ""Insufficient Funds"" ) ; requestId = oraclize_query ( ""URL"" , oracleURL , gasLimit ) ; requestIds [ requestId ] = now ; maximumScheduledUpdated = now ; emit LogNewOraclizeQuery ( now , requestId , oracleURL ) ; } else { require ( oraclize_getPrice ( ""URL"" , gasLimit ) * _times . length <= address ( this ) . balance , ""Insufficient Funds"" ) ; for ( uint256 i = 0 ; i < _times . length ; i ++ ) { require ( _times [ i ] >= now , ""Past scheduling is not allowed and scheduled time should be absolute timestamp"" ) ; requestId = oraclize_query ( _times [ i ] , ""URL"" , oracleURL , gasLimit ) ; requestIds [ requestId ] = _times [ i ] ; if ( maximumScheduledUpdated < requestIds [ requestId ] ) { maximumScheduledUpdated = requestIds [ requestId ] ; } emit LogNewOraclizeQuery ( _times [ i ] , requestId , oracleURL ) ; } } if ( latestScheduledUpdate < maximumScheduledUpdated ) { latestScheduledUpdate = maximumScheduledUpdated ; } }
","Allows owner to schedule future Oraclize calls
"
"function getSupplyRate ( address asset , uint cash , uint borrows ) public view returns ( uint , uint ) ;
","Gets the current supply interest rate based on the given asset , total cash and total borrows
"
"function getPayeeAddress ( bytes32 _requestId , uint8 _payeeIndex ) public view returns ( address ) { if ( _payeeIndex == 0 ) { return requests [ _requestId ] . payee . addr ; } else { return subPayees [ _requestId ] [ _payeeIndex - 1 ] . addr ; } }
","Gets address of a payee .
"
"function _setOwner ( address _who , bool _flag ) private returns ( bool ) { require ( owners [ _who ] != _flag ) ; owners [ _who ] = _flag ; if ( _flag ) { emit AddOwner ( _who ) ; } else { emit DeleteOwner ( _who ) ; } return true ; }
","Changes the owner role to provided address
"
"function transfer ( address _to , uint256 _value ) returns ( bool ) ;
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function transfer ( address to , uint value ) public returns ( bool ) ;
","send ` value ` token to ` to ` from ` msg.sender `
"
"function cancel ( uint _imageId ) public { require ( sellAds [ _imageId ] . exists == true ) ; require ( sellAds [ _imageId ] . exchanger == msg . sender ) ; require ( sellAds [ _imageId ] . active == true ) ; removeOrder ( _imageId ) ; }
","Function to remove image from Marketplace
"
"function setNextSale ( address _sale ) external validAddress ( _sale ) onlymanyowners ( keccak256 ( msg . data ) ) { m_nextSale = _sale ; }
","set address of a sale that will be next one after the current sale is finished
"
"function addVersion ( address ofVersion ) internal returns ( uint id ) { Version memory info ; info . version = ofVersion ; info . active = true ; info . timestamp = now ; versions . push ( info ) ; VersionUpdated ( versions . length - 1 ) ; }
","Add an approved version of Melon
"
"function setNextPoolPercentage ( uint256 _nextPoolPercentage ) external onlyCFO { nextPoolPercentage = _nextPoolPercentage ; }
","Sets a new next pool percentage .
"
"function getChannelsParticipants ( ) constant returns ( address [ ] ) { uint i ; uint pos ; address [ ] memory result ; NettingChannelContract channel ; uint open_channels_num = 0 ; for ( i = 0 ; i < data . all_channels . length ; i ++ ) { if ( contractExists ( data . all_channels [ i ] ) ) { open_channels_num += 1 ; } } result = new address [ ] ( open_channels_num * 2 ) ; pos = 0 ; for ( i = 0 ; i < data . all_channels . length ; i ++ ) { if ( ! contractExists ( data . all_channels [ i ] ) ) { continue ; } channel = NettingChannelContract ( data . all_channels [ i ] ) ; var ( address1 , , address2 , ) = channel . addressAndBalance ( ) ; result [ pos ] = address1 ; pos += 1 ; result [ pos ] = address2 ; pos += 1 ; } return result ; }
","Get all participants of all channels
"
"function buyTokensPreHook ( address _beneficiary , uint256 _toFund ) internal { recentBlock [ msg . sender ] = block . number ; super . buyTokensPreHook ( _beneficiary , _toFund ) ; }
","save the block number
"
"function verifyTransfer ( address _from , address _to , uint256 _amount ) public checkGranularity ( _amount ) returns ( bool ) { if ( ! freeze ) { bool isTransfer = false ; if ( transferFunctions [ getSig ( msg . data ) ] ) { isTransfer = true ; } if ( modules [ TRANSFERMANAGER_KEY ] . length == 0 ) { return true ; } bool isInvalid = false ; bool isValid = false ; bool isForceValid = false ; for ( uint8 i = 0 ; i < modules [ TRANSFERMANAGER_KEY ] . length ; i ++ ) { ITransferManager . Result valid = ITransferManager ( modules [ TRANSFERMANAGER_KEY ] [ i ] . moduleAddress ) . verifyTransfer ( _from , _to , _amount , isTransfer ) ; if ( valid == ITransferManager . Result . INVALID ) { isInvalid = true ; } if ( valid == ITransferManager . Result . VALID ) { isValid = true ; } if ( valid == ITransferManager . Result . FORCE_VALID ) { isForceValid = true ; } } return isForceValid ? true : ( isInvalid ? false : isValid ) ; } return false ; }
","validate transfer with TransferManager module if it exists
"
"function getContributorsCount ( ) view public returns ( uint256 ) { return contributorsKeys . length ; }
","How many contributors we have .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _from != address ( 0 ) ) ; require ( _to != address ( 0 ) ) ; require ( ! isUserInBlackList ( _from ) ) ; return super . transferFrom ( _from , _to , _value ) ; }
","Transfer tokens from one address to another
"
"function getPayeeIndex ( bytes32 _requestId , address _address ) public view returns ( int16 ) { if ( requests [ _requestId ] . payee . addr == _address ) { return 0 ; } for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { if ( subPayees [ _requestId ] [ i ] . addr == _address ) { return i + 1 ; } } return - 1 ; }
","Gets address of a payee .
"
"function deposit ( address to , uint256 amount , bytes32 reference ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) onlyIfDepositAllowed ( to , amount ) acceptAgreement ( to ) { require ( to != address ( 0 ) ) ; _balances [ to ] = add ( _balances [ to ] , amount ) ; _totalSupply = add ( _totalSupply , amount ) ; emit LogDeposit ( to , msg . sender , amount , reference ) ; emit Transfer ( address ( 0 ) , to , amount ) ; }
","deposit 'amount ' of EUR-T to address 'to ' , attaching correlating ` reference ` to LogDeposit event
"
"function getSecurityTokenLaunchFee ( ) public view returns ( uint256 ) { return getUint ( STLAUNCHFEE ) ; }
","Gets the security token launch fee
"
"function earlyResolve ( bytes32 msigId , uint amount , bytes sig ) public { require ( multisigs [ msigId ] . owner == msg . sender || multisigs [ msigId ] . authority == msg . sender ) ; address otherAuthority = multisigs [ msigId ] . owner == msg . sender ? multisigs [ msigId ] . authority : multisigs [ msigId ] . owner ; require ( otherAuthority == msigId . toEthSignedMessageHash ( ) . recover ( sig ) ) ; spendFromMultisig ( msigId , amount , multisigs [ msigId ] . owner ) ; }
","Withdraw ether from the multisig .
"
"function deposit ( address _token , uint256 _amount , string _reference ) external payable isInitialized transitionsPeriod { _deposit ( _token , _amount , _reference , msg . sender , true ) ; }
","Deposit ` @ tokenAmount ( _token , _amount ) `
"
"function setAdministrator ( address _administrator ) public onlyOwner notFrozen returns ( bool success ) { administrator = _administrator ; AdministratorAdded ( msg . sender , _administrator , true ) ; return true ; }
","used to set an administrator
"
"function buy ( ) public payable nonReentrant onlyIfSaleIsActive checkLimitsAndDates { require ( ! priceExpired ( ) ) ; address investor = msg . sender ; uint256 payment = msg . value ; require ( ( payment . mul ( m_ETHPriceInCents ) ) . div ( 1 ether ) >= c_MinInvestmentInCents ) ; uint tokenAmount ; uint cap ; uint centsPerToken ; if ( m_currentTokensSold < c_priceRiseTokenAmount ) { centsPerToken = c_centsPerTokenFirst ; cap = c_priceRiseTokenAmount ; } else { centsPerToken = c_centsPerTokenSecond ; cap = c_maximumTokensSold ; } tokenAmount = payment . mul ( m_ETHPriceInCents ) . div ( centsPerToken ) ; uint maxTokensAllowed = cap . sub ( m_currentTokensSold ) ; if ( tokenAmount > maxTokensAllowed ) { uint ethPerToken = centsPerToken . mul ( 1 ether ) . div ( m_ETHPriceInCents ) ; tokenAmount = maxTokensAllowed ; payment = ethPerToken . mul ( tokenAmount ) . div ( 1 ether ) ; } m_currentTokensSold = m_currentTokensSold . add ( tokenAmount ) ; m_beneficiary . transfer ( payment ) ; m_token . transfer ( investor , tokenAmount ) ; uint change = msg . value . sub ( payment ) ; if ( change > 0 ) investor . transfer ( change ) ; FundTransfer ( investor , payment , true ) ; }
","presale participation .
"
"function sell ( uint _askPrice , uint _amount , bool _make ) external returns ( bool ) ;
","Will sell ` _amount ` tokens at or above ` _price ` each .
"
"function calculateBaseTimeout ( ) public view returns ( uint256 ) { uint256 _numberOfTileFlips = gameStates [ gameIndex ] . numberOfTileFlips ; if ( _numberOfTileFlips >= gameSettings . numberOfFlipsToFinalActivityTimer || gameSettings . numberOfFlipsToFinalActivityTimer == 0 ) { return gameSettings . finalActivityTimer ; } else { if ( gameSettings . finalActivityTimer <= gameSettings . initialActivityTimer ) { uint256 difference = gameSettings . initialActivityTimer - gameSettings . finalActivityTimer ; uint256 decrease = difference . mul ( _numberOfTileFlips ) . div ( gameSettings . numberOfFlipsToFinalActivityTimer ) ; return ( gameSettings . initialActivityTimer - decrease ) ; } else { difference = gameSettings . finalActivityTimer - gameSettings . initialActivityTimer ; uint256 increase = difference . mul ( _numberOfTileFlips ) . div ( gameSettings . numberOfFlipsToFinalActivityTimer ) ; return ( gameSettings . initialActivityTimer + increase ) ; } } }
","Calculate the current game 's base timeout .
"
"function setGasLimit ( uint256 _gasLimit ) onlyOwner public { gasLimit = _gasLimit ; }
","NB - this will only impact newly scheduled Oraclize queries , not future queries which have already been scheduled
"
"function destroyIdentifier ( bytes32 identifier ) public returns ( bool ) { uint256 index = identifierToIndex [ identifier ] ; require ( index != 0 ) ; return destroy ( index ) ; }
","Destroys a loan using the signature and not the Index
"
"function revokePermission ( address _entity , address _app , bytes32 _role ) onlyPermissionManager ( _app , _role ) external { require ( hasPermission ( _entity , _app , _role ) ) ; _setPermission ( _entity , _app , _role , bytes32 ( 0 ) ) ; }
","Revokes ` _entity ` the ability to perform actions of role ` _role ` on ` _app `
"
"function setApprovalForAll ( address _operator , bool _approved ) external { require ( _operator != address ( 0 ) ) ; ownerToOperators [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
","This works even if sender does n't own any tokens at the time .
"
"function currentPenalty ( address account ) public view returns ( uint ) { uint ratio = synthetix . collateralisationRatio ( account ) ; if ( ratio <= TWENTY_PERCENT ) { return 0 ; } else if ( ratio > TWENTY_PERCENT && ratio <= THIRTY_PERCENT ) { return TWENTY_FIVE_PERCENT ; } else if ( ratio > THIRTY_PERCENT && ratio <= FOURTY_PERCENT ) { return FIFTY_PERCENT ; } return SEVENTY_FIVE_PERCENT ; }
","The penalty a particular address would incur if its fees were withdrawn right now
"
"function _acceptAdmin ( ) public returns ( uint ) { if ( msg . sender != pendingAdmin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . ACCEPT_ADMIN_PENDING_ADMIN_CHECK ) ; } address oldAdmin = admin ; admin = pendingAdmin ; pendingAdmin = 0 ; emit NewAdmin ( oldAdmin , msg . sender ) ; return uint ( Error . NO_ERROR ) ; }
","Accepts transfer of admin rights .
"
"function isRegisteredAddress ( address _address ) public view returns ( bool ) { return holderIndex [ holderAddress2Id [ _address ] ] != 0 ; }
","Checks user is holder .
"
"function convertWT ( uint256 _amount ) public userNotBlacklisted ( msg . sender ) whenNotPaused { require ( balanceOf ( msg . sender ) >= _amount , ""Conversion amount should be less than balance"" ) ; _burn ( msg . sender , _amount ) ; _mintCUSD ( msg . sender , _amount ) ; emit ConvertedToCUSD ( msg . sender , _amount ) ; }
","Converts WT0 to CarbonUSD for the user .
"
"function transferToAddress ( address _to , uint _value , bytes _data ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
","Function that is called when transaction target is an address
"
"function startSale ( ) public onlyController { require ( campaignState > 2 && teamVaultAddr != 0x0 ) ; campaignState = 2 ; uint256 tNow = now ; tCampaignStart = tNow ; tBonusStageEnd += tNow ; tRegSaleStart += tNow ; t_1st_StageEnd += tNow ; t_2nd_StageEnd += tNow ; t_3rd_StageEnd += tNow ; tCampaignEnd += tNow ; CampaignOpen ( now ) ; }
","Puts campaign into active state only controller can do that only possible if team token Vault is set up WARNING : usual caveats apply to the Ethereum 's interpretation of time
"
"function transferForeignToken ( address _tokenAddress , address _recipient , uint256 _amount ) public onlyAdmin returns ( bool ) { require ( _recipient != address ( 0 ) , ""recipient address can't be empty"" ) ; require ( _tokenAddress != TOKENADDRESS , ""token can't be RTC"" ) ; ERC20Interface eI = ERC20Interface ( _tokenAddress ) ; require ( eI . transfer ( _recipient , _amount ) , ""token transfer failed"" ) ; emit ForeignTokenTransfer ( msg . sender , _recipient , _amount ) ; return true ; }
","Allow us to transfer tokens that someone might 've accidentally sent to this contract
"
"function setLocks ( address [ ] _holders , uint256 [ ] _lockups ) public onlyController { require ( _holders . length == _lockups . length ) ; require ( _holders . length < 255 ) ; require ( transfersEnabled == false ) ; for ( uint8 i = 0 ; i < _holders . length ; i ++ ) { address holder = _holders [ i ] ; uint256 lockup = _lockups [ i ] ; require ( lockups [ holder ] == 0 ) ; lockups [ holder ] = lockup ; emit LockedTokens ( holder , lockup ) ; } }
","Sets the locks of an array of addresses .
"
"function submitAnswerCommitment ( bytes32 question_id , bytes32 answer_hash , uint256 max_previous , address _answerer ) external payable { }
","Submit the hash of an answer , laying your claim to that answer if you reveal it in a subsequent transaction .
"
"function doSend ( address _operator , address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData , bool _preventLocking ) internal isTransferable { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _data , _operatorData ) ; require ( _to != address ( 0 ) , ""Cannot send to 0x0"" ) ; require ( mBalances [ _from ] >= _amount , ""Not enough funds"" ) ; require ( whitelisted ( _to ) , ""Recipient is not whitelisted"" ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _data , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _data , _operatorData ) ; }
","Helper function actually performing the sending of tokens .
"
"function removeDistributionSources ( address [ ] _blacklist ) external onlyContractOwner returns ( uint ) { for ( uint _idx = 0 ; _idx < _blacklist . length ; ++ _idx ) { delete distributionSourcesList [ _blacklist [ _idx ] ] ; } return OK ; }
","Removes distribution sources from whitelist .
"
"function claimTokenFor ( address _beneficiary ) public afterSaleSuccess whenNotPaused { uint256 stake = stakes [ _beneficiary ] ; require ( stake > 0 ) ; stakes [ _beneficiary ] = 0 ; uint256 tokens = stake . mul ( rate ) ; tokenBalance = tokenBalance . sub ( tokens ) ; ethealController . addHodlerStake ( _beneficiary , tokens . mul ( 2 ) ) ; require ( ethealController . ethealToken ( ) . transfer ( _beneficiary , tokens ) ) ; TokenClaimed ( msg . sender , _beneficiary , stake , tokens ) ; }
","Claim token after token sale based on stake .
"
"function setEthPreAmount ( uint256 ethPreAmountInWei ) isOwner { require ( ethPreAmountInWei > 0 ) ; require ( ethPreAmount != ethPreAmountInWei ) ; ethPreAmount = ethPreAmountInWei ; updatePrices ( ) ; }
","Set current ethPreAmount price in wei for one token
"
"function setBuyCommission ( uint256 buyCommissionInWei ) isOwner { require ( buyCommissionInWei > 0 ) ; require ( buyCommission != buyCommissionInWei ) ; buyCommission = buyCommissionInWei ; updatePrices ( ) ; }
","Set current Buy Commission price in wei
"
"function cancelMortgage ( uint256 id ) external returns ( bool ) { Mortgage storage mortgage = mortgages [ id ] ; require ( msg . sender == mortgage . owner , ""Only the owner can cancel the mortgage"" ) ; require ( mortgage . status == Status . Pending , ""The mortgage is not pending"" ) ; mortgage . status = Status . Canceled ; require ( mana . transfer ( msg . sender , mortgage . deposit ) , ""Error returning MANA"" ) ; emit CanceledMortgage ( msg . sender , id ) ; return true ; }
","Cancels an existing mortgage
"
"function mint ( address to , uint256 value ) public onlyMinter returns ( bool ) { require ( ! mintingDisabled ) ; bool minted = super . mint ( to , value ) ; if ( minted ) { addBalanceBlocks ( to ) ; if ( ! holdersMap [ to ] ) { holdersMap [ to ] = true ; holders . push ( to ) ; } } return minted ; }
","Mint tokens
"
"function getWeiCollected ( ) public constant returns ( uint ) ;
","amount of funds collected in wei
"
"function cancelProject ( uint64 idProject ) { PledgeAdmin storage project = findAdmin ( idProject ) ; checkAdminOwner ( project ) ; project . canceled = true ; CancelProject ( idProject ) ; }
","Method called to cancel this project .
"
"function disableSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _buyer , ""Must be buyer"" ) ; return doDisableSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }
","Disable the seller from cancelling ( i.e .
"
"function getFxUSDAmount ( Data storage self , string currency , uint fxAmount ) internal view returns ( uint amount ) { uint usdDecimals = getTokenDecimals ( self , 'USDx' ) ; uint fxDecimals = getTokenDecimals ( self , currency ) ; uint usdAmount = ( ( fxAmount . mul ( getFxUSDBPSRate ( self , currency ) ) . div ( 10000 ) ) . mul ( 10 ** usdDecimals ) ) . div ( 10 ** fxDecimals ) ; return usdAmount ; }
","Return the foreign currency USD exchanged amount
"
"function removeTicker ( string _ticker ) external ;
","Removes the ticker details and associated ownership & security token mapping
"
"function withdrawSynthetix ( uint amount ) external onlyOwner { synthetix . transfer ( owner , amount ) ; }
","Allows the owner to withdraw SNX from this contract if needed .
"
"function register ( address _service ) internal returns ( uint256 serviceId ) { }
","register the service '_service ' with the private service registry
"
"function withdrawBalance ( ) external onlyOwner { owner . transfer ( this . balance ) ; }
","With each call to purchaseTrophy , fees will build up in this contract 's balance .
"
"function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ) { require ( transfer ( _to , _value ) ) ; if ( isContract ( _to ) ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } return true ; }
","Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract .
"
"function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) { require ( _registry . hasAttribute ( to , _validAttributeTypeID ) , ""Transfer failed - receiver is not approved."" ) ; return super . transferFrom ( from , to , value ) ; }
","Transfer an amount of ` value ` to a receiver at account ` to ` on behalf of a sender at account ` from ` .
"
"function setAssetFeeParams ( address asset , uint feeBps , uint feeMin , uint feeMax , uint feeFlat ) public onlyOwner notDeprecated returns ( bool success ) { require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.max' , asset ) ) , feeMax ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.min' , asset ) ) , feeMin ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.bps' , asset ) ) , feeBps ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; require ( lib . Storage . setUint ( keccak256 ( abi . encodePacked ( 'fee.flat' , asset ) ) , feeFlat ) , 'Error: Failed to set fee parameters with storage contract. Please check permissions.' ) ; return true ; }
","Set BPS , Min , Max , and Flat fee params for asset
"
"function getBidId ( Campaign storage _campaign ) internal view returns ( bytes32 _bidId ) { return _campaign . bidId ; }
","Get campaign id
"
"function collectTokens ( ) public onlyOwner { uint256 finalizedTime = contribution . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime ) ; uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; collectedTokens = balance ; miniMeToken . transfer ( owner , balance ) ; TokensWithdrawn ( owner , balance ) ; }
","The owner will call this method to extract the tokens
"
"function isTrusted ( address _from , address _to ) public view returns ( bool ) { return get ( store , holdersTrustStorage , getHolderId ( _from ) , _to ) ; }
","Check if specified holder trusts an address with recovery procedure .
"
"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer a specific narco via transferFrom ( ) .
"
"function resetWinners ( uint256 newLength ) external onlyAdmin checkState ( pointsValidationState . LimitCalculated ) { sortedWinners . length = newLength ; }
","If anything during the point calculation and sorting part should fail , this function can reset data structures to their initial position , so as to
"
"function finished ( ) public { require ( state == State . Successful ) ; require ( beneficiary . send ( this . balance ) ) ; LogBeneficiaryPaid ( beneficiary ) ; }
","closure handler
"
"function allowance ( address _from , address _spender , bytes32 _symbol ) public view returns ( uint ) { return _allowance ( getHolderId ( _from ) , getHolderId ( _spender ) , _symbol ) ; }
","Returns asset allowance from one holder to another .
"
"function buyBox2 ( ) external payable whenNotPaused returns ( bool ) { require ( isNotContract ( msg . sender ) ) ; require ( box2OnSale ) ; require ( msg . value >= priceBox2 ) ; uint tempVal = uint ( keccak256 ( uint ( msg . sender ) + secretKey + rabbits . length ) ) ; tempVal = tempVal % 10000 ; uint _star = 4 ; if ( tempVal <= box2Star5 ) { _star = 5 ; require ( CREATED_STAR5 < LIMIT_STAR5 ) ; } else { require ( CREATED_STAR4 < LIMIT_STAR4 ) ; } _createRabbitInGrade ( _star , msg . sender , 3 ) ; uint fundsExcess = msg . value - priceBox2 ; if ( fundsExcess > 1 finney ) { msg . sender . transfer ( fundsExcess ) ; } return true ; }
","customer buy a box
"
"function renterOf ( uint256 _deedId ) external view returns ( address _renter , uint256 _rentPeriodEndTimestamp ) { require ( validIdentifier ( _deedId ) ) ; if ( identifierToRentPeriodEndTimestamp [ _deedId ] < now ) { _renter = address ( 0 ) ; _rentPeriodEndTimestamp = 0 ; } else { _renter = identifierToRenter [ _deedId ] ; _rentPeriodEndTimestamp = identifierToRentPeriodEndTimestamp [ _deedId ] ; } }
","Returns the address of the currently assigned renter and end time of the rent period of a given plot .
"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { if ( funding ) throw ; var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
","This function is disabled during the funding .
"
"function setFundingRules ( address _moderator , uint _initialPriceMultiplier , uint _amountToFund , uint _minutesFundingPeriod , uint _inflationRate , uint _proposalID ) external ;
","Function to set a funding
"
"function doConfirmPayment ( uint _idPayment ) internal { require ( _idPayment < payments . length ) ; Payment storage p = payments [ _idPayment ] ; require ( p . state == PaymentStatus . Pending ) ; p . state = PaymentStatus . Paid ; liquidPledging . confirmPayment ( uint64 ( p . ref ) , p . amount ) ; p . dest . transfer ( p . amount ) ; ConfirmPayment ( _idPayment , p . ref ) ; }
","Transfers ETH according to the data held within the specified payment id ( internal function )
"
"function updateSalePrice ( uint256 _tokenId , uint256 _newPrice ) public { Sale storage sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _updateSalePrice ( _tokenId , _newPrice , seller ) ; }
","This is a state-modifying function that can be called while the contract is paused .
"
"function nonEtherBuy ( address client , uint etherEquivalentAmount ) public { require ( msg . sender == m_nonEtherController ) ; require ( etherEquivalentAmount <= 70000 ether ) ; internalBuy ( client , etherEquivalentAmount , false ) ; }
","register investments coming in different currencies
"
"function getReserves ( ) public view returns ( KyberReserveInterface [ ] ) { return reserves ; }
","should be called off chain with as much gas as needed
"
"function getBlockTimestamp ( ) internal constant returns ( uint256 ) { return block . timestamp ; }
","This function is overridden by the test Mocks .
"
"function withdrawPayoutFromBet ( uint betId ) external whenGameIsClosed ( bets [ betId ] . gameId ) { require ( games [ bets [ betId ] . gameId ] . result == bets [ betId ] . result ) ; if ( ! bets [ betId ] . isPayoutWithdrawn ) { uint payout = calculatePotentialPayout ( betId ) ; bets [ betId ] . isPayoutWithdrawn = true ; address bettorAddress = betToAddress [ betId ] ; bettorAddress . transfer ( payout ) ; } }
","This function is called by a bettor to withdraw his payout
"
"function destroyBeneficiary ( address _beneficiary ) public onlyOwner { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; uint256 balance = beneficiary . vested . sub ( beneficiary . released ) ; token . transfer ( owner , balance ) ; totalReleased = totalReleased . add ( balance ) ; beneficiary . isBeneficiary = false ; beneficiary . released = beneficiary . released . add ( balance ) ; for ( uint i = 0 ; i < addresses . length - 1 ; i ++ ) if ( addresses [ i ] == _beneficiary ) { addresses [ i ] = addresses [ addresses . length - 1 ] ; break ; } addresses . length -= 1 ; emit BeneficiaryDestroyed ( _beneficiary ) ; }
","Allows the owner to destroy a beneficiary .
"
"function setPrices ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth
"
"function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = true ; } else { mAuthorized [ _operator ] [ msg . sender ] = false ; } RevokedOperator ( _operator , msg . sender ) ; }
","Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens .
"
"function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) stateOpenOrPendingArbitration ( question_id ) external { bytes32 answer_hash = keccak256 ( answer , nonce ) ; bytes32 commitment_id = keccak256 ( question_id , answer_hash , bond ) ; require ( ! commitments [ commitment_id ] . is_revealed ) ; require ( commitments [ commitment_id ] . reveal_ts > uint32 ( now ) ) ; commitments [ commitment_id ] . revealed_answer = answer ; commitments [ commitment_id ] . is_revealed = true ; if ( bond == questions [ question_id ] . bond ) { _updateCurrentAnswer ( question_id , answer , questions [ question_id ] . timeout ) ; } LogAnswerReveal ( question_id , msg . sender , answer_hash , answer , nonce , bond ) ; }
","Submit the answer whose hash you sent in a previous submitAnswerCommitment ( ) transaction
"
"function bid ( ) public payable { require ( stage == Stages . AuctionSetUp || stage == Stages . AuctionStarted ) ; require ( privatesalewhitelist [ msg . sender ] || publicsalewhitelist [ msg . sender ] ) ; if ( stage == Stages . AuctionSetUp ) { require ( privatesalewhitelist [ msg . sender ] ) ; } require ( msg . value > 0 ) ; require ( bids [ msg . sender ] . received + msg . value >= bid_threshold ) ; assert ( bids [ msg . sender ] . received + msg . value >= msg . value ) ; uint256 remaining_funds_to_end_auction = remainingFundsToEndAuction ( ) ; require ( msg . value <= remaining_funds_to_end_auction ) ; if ( stage == Stages . AuctionSetUp ) { require ( privatesalewhitelist [ msg . sender ] ) ; currentBonus = 25 ; } else if ( stage == Stages . AuctionStarted ) { if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time && now < auction_start_time + BONUS_DAY1_DURATION ) { currentBonus = 25 ; } else if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) { currentBonus = 25 ; } else if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 25 ; } else if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 25 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time && now < auction_start_time + BONUS_DAY1_DURATION ) { currentBonus = 15 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) { currentBonus = 10 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 5 ; } else if ( publicsalewhitelist [ msg . sender ] && now >= auction_start_time + BONUS_DAY3_DURATION ) { currentBonus = 0 ; } else { currentBonus = 0 ; } } else { currentBonus = 0 ; } uint256 accounted = msg . value + msg . value * ( currentBonus ) / 100 ; bids [ msg . sender ] . accounted += accounted ; bids [ msg . sender ] . received += msg . value ; received_wei += msg . value ; received_wei_with_bonus += accounted ; wallet_address . transfer ( msg . value ) ; BidSubmission ( msg . sender , msg . value , accounted , remaining_funds_to_end_auction ) ; assert ( received_wei >= msg . value ) ; assert ( received_wei_with_bonus >= accounted ) ; }
","Send `` msg.value '' WEI to the auction from the `` msg.sender '' account .
"
"function initialize ( address _att , address _attController , uint _startTime , uint _endTime , address _destEthFoundation , address _destTokensAngel ) public onlyOwner { require ( address ( ATT ) == 0x0 ) ; ATT = MiniMeToken ( _att ) ; require ( ATT . totalSupply ( ) == 0 ) ; require ( ATT . controller ( ) == address ( this ) ) ; require ( ATT . decimals ( ) == 18 ) ; startTime = _startTime ; endTime = _endTime ; assert ( startTime < endTime ) ; require ( _attController != 0x0 ) ; attController = _attController ; require ( _destEthFoundation != 0x0 ) ; destEthFoundation = _destEthFoundation ; require ( _destTokensAngel != 0x0 ) ; destTokensAngel = _destTokensAngel ; }
","This method should be called by the owner before the contribution period starts This initializes most of the parameters
"
"function getReferrerBonus ( uint256 value ) view public returns ( uint256 ) { return value . mul ( baseRate ) . mul ( referrerBonusPercent ) . div ( PERCENT_DIVIDER ) ; }
","Calculates referrer bonus
"
"function batchCreateAssetSale ( uint256 [ ] _tokenIds , uint256 [ ] _startingPrices , uint256 [ ] _endingPrices , uint256 [ ] _durations ) external whenNotPaused { require ( _tokenIds . length > 0 && _startingPrices . length > 0 && _endingPrices . length > 0 && _durations . length > 0 ) ; for ( uint ii = 0 ; ii < _tokenIds . length ; ii ++ ) { require ( _tokenIds [ ii ] != 0 ) ; require ( _startingPrices [ ii ] == _startingPrices [ ii ] ) ; require ( _endingPrices [ ii ] == _endingPrices [ ii ] ) ; require ( _durations [ ii ] == _durations [ ii ] ) ; address _owner = ownerOf ( _tokenIds [ ii ] ) ; address _msgSender = msg . sender ; require ( _owner == _msgSender ) ; require ( checkIsAttached ( _tokenIds [ ii ] ) == 0 ) ; _approveForSale ( msg . sender , address ( saleManagerAddress ) , _tokenIds [ ii ] ) ; saleManagerAddress . createSale ( _tokenIds [ ii ] , _startingPrices [ ii ] , _endingPrices [ ii ] , _durations [ ii ] , msg . sender ) ; } }
","Batch function to put 10 or less collectibles on sale
"
"function supportsInterface ( bytes4 interfaceID ) external pure returns ( bool ) ;
","Query if a contract implements an interface
"
"function revoke ( ERC20Basic token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . safeTransfer ( owner , refund ) ; Revoked ( ) ; }
","Allows the owner to revoke the vesting .
"
"function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 0 ) ; return availableTags ; }
","Get the tags related to the module factory
"
"function stage ( ) constant returns ( Stage ) { if ( finalized ) { return Stage . Finalized ; } if ( ! initialized ) { return Stage . Created ; } if ( blockTime ( ) < startTime ) { return Stage . Initialized ; } if ( uint256 ( soldOut . official ) . add ( soldOut . channels ) >= publicSupply ) { return Stage . Closed ; } if ( blockTime ( ) < endTime ) { if ( blockTime ( ) < startTime . add ( earlyStageLasts ) ) { return Stage . Early ; } return Stage . Normal ; } return Stage . Closed ; }
","estimate stage
"
"function buyTokensPreHook ( address _beneficiary , uint256 _toFund ) internal { }
","pre hook for buyTokens function
"
"function registerWithRefID ( uint256 _refId ) public payable onlyNotExistingUser returns ( uint256 ) { require ( _refId < users . length ) ; uint256 index = register ( ) ; _updateReferrals ( index , _refId ) ; emit ReferralRegister ( _refId , index ) ; return index ; }
","just registry by referral link
"
"function vest ( ) external { uint numEntries = numVestingEntries ( msg . sender ) ; uint total ; for ( uint i = 0 ; i < numEntries ; i ++ ) { uint time = getVestingTime ( msg . sender , i ) ; if ( time > now ) { break ; } uint qty = getVestingQuantity ( msg . sender , i ) ; if ( qty == 0 ) { continue ; } vestingSchedules [ msg . sender ] [ i ] = [ 0 , 0 ] ; total = safeAdd ( total , qty ) ; } if ( total != 0 ) { totalVestedBalance = safeSub ( totalVestedBalance , total ) ; totalVestedAccountBalance [ msg . sender ] = safeSub ( totalVestedAccountBalance [ msg . sender ] , total ) ; havven . transfer ( msg . sender , total ) ; emit Vested ( msg . sender , now , total ) ; } }
","Allow a user to withdraw any havvens in their schedule that have vested .
"
"function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) ;
","Checks whether redemption is permitted for a participant
"
"function expiryCheck ( string _symbol ) internal returns ( bool ) { if ( registeredSymbols [ _symbol ] . owner != address ( 0 ) ) { if ( now > registeredSymbols [ _symbol ] . timestamp . add ( expiryLimit ) && registeredSymbols [ _symbol ] . status != true ) { registeredSymbols [ _symbol ] = SymbolDetails ( address ( 0 ) , uint256 ( 0 ) , """" , bytes32 ( 0 ) , false ) ; return true ; } else return false ; } return true ; }
","To re-initialize the token symbol details if symbol validity expires
"
"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Sufficent Allowance is not provided"" ) ; CappedSTO cappedSTO = new CappedSTO ( msg . sender , address ( polyToken ) ) ; require ( Util . getSig ( _data ) == cappedSTO . getInitFunction ( ) , ""Invalid data"" ) ; require ( address ( cappedSTO ) . call ( _data ) , ""Unsuccessfull call"" ) ; emit GenerateModuleFromFactory ( address ( cappedSTO ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( cappedSTO ) ; }
","Used to launch the Module with the help of factory
"
"function getApproved ( uint256 _tokenId ) external view returns ( address ) { require ( _tokenExists ( _tokenId ) ) ; return playerTokenToApproved [ _tokenId ] ; }
","Get the approved address for a single NFT
"
"function revokeManualBlocking ( address _from , address _to ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , ""Invalid to address"" ) ; delete manualBlockings [ _from ] [ _to ] ; emit RevokeManualBlocking ( _from , _to , msg . sender ) ; }
","Removes a pairs of addresses from manual approvals
"
"function totalSupplyAt ( uint256 _checkpointId ) public view returns ( uint256 ) ;
","Queries totalSupply as of a defined checkpoint
"
"function _generateCampaign ( string packageName , uint [ 3 ] countries , uint [ ] vercodes , uint price , uint budget , uint startDate , uint endDate ) internal returns ( CampaignLibrary . Campaign memory ) { require ( budget >= price ) ; require ( endDate >= startDate ) ; if ( appc . allowance ( msg . sender , address ( this ) ) >= budget ) { appc . transferFrom ( msg . sender , address ( advertisementFinance ) , budget ) ; advertisementFinance . increaseBalance ( msg . sender , budget ) ; uint newBidId = bytesToUint ( lastBidId ) ; lastBidId = uintToBytes ( ++ newBidId ) ; CampaignLibrary . Campaign memory newCampaign ; newCampaign . price = price ; newCampaign . startDate = startDate ; newCampaign . endDate = endDate ; newCampaign . budget = budget ; newCampaign . owner = msg . sender ; newCampaign . valid = true ; newCampaign . bidId = lastBidId ; } else { emit Error ( ""createCampaign"" , ""Not enough allowance"" ) ; } return newCampaign ; }
","Creates a campaign Method to create a campaign of user aquisition for a certain application .
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _spender != address ( 0 ) ) ; allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; success = true ; }
","approve ` _value ` tokens for ` _spender ` address to send from 'msg.sender '
"
"function unlockMe ( ) external { require ( userAddress2Id [ msg . sender ] != 0 ) ; userLock [ msg . sender ] = 0 ; Lock ( msg . sender , 0 ) ; }
","This function is used to revoke the claim of lockMe
"
"function setAdmin ( address _admin , bool _valid ) onlyOwner public { admin [ _admin ] = _valid ; emit LogAdminSet ( _admin , _valid , now ) ; }
","Allows owner to set up admin addresses that can schedule updates
"
"function pegEtherValues ( uint256 _minDiscountEther , uint256 _firstTierDiscountUpperLimitEther , uint256 _secondTierDiscountUpperLimitEther , uint256 _thirdTierDiscountUpperLimitEther , uint256 _minPresaleContributionEther , uint256 _maxPresaleContributionEther ) onlyOwner { minDiscountEther = _minDiscountEther ; firstTierDiscountUpperLimitEther = _firstTierDiscountUpperLimitEther ; secondTierDiscountUpperLimitEther = _secondTierDiscountUpperLimitEther ; thirdTierDiscountUpperLimitEther = _thirdTierDiscountUpperLimitEther ; minPresaleContributionEther = _minPresaleContributionEther ; maxPresaleContributionEther = _maxPresaleContributionEther ; }
","Allows the owner to peg Ether values
"
"function votesPerChoice ( uint8 option ) external view returns ( uint32 ) { require ( option < NUMBER_OF_CHOICES , ""Choice must be less than numberOfChoices."" ) ; return currentVoteResults [ option ] ; }
","Return number of votes for one of the options .
"
"function buyFactory ( FactoryType _type ) public payable onlyExistingUser returns ( uint256 ) { uint256 userId = addressToUser [ msg . sender ] ; if ( addressToUser [ msg . sender ] == 0 ) userId = register ( ) ; return _paymentProceed ( userId , Factory ( _type , 0 , now ) ) ; }
","mechanics of buying any factory
"
"function distrust ( address _to ) public checkTrust ( msg . sender , _to ) returns ( uint ) { set ( store , holdersTrustStorage , getHolderId ( msg . sender ) , _to , false ) ; return OK ; }
","Revoke trust to perform recovery procedure from an address .
"
"function freezeAccount ( address target , bool freeze ) onlyAuthorized public { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }
","` freeze ?
"
"function init ( address _token , address _plcr , uint [ ] _parameters ) public { require ( _token != 0 && address ( token ) == 0 ) ; require ( _plcr != 0 && address ( voting ) == 0 ) ; token = EIP20Interface ( _token ) ; voting = PLCRVoting ( _plcr ) ; set ( ""minDeposit"" , _parameters [ 0 ] ) ; set ( ""pMinDeposit"" , _parameters [ 1 ] ) ; set ( ""applyStageLen"" , _parameters [ 2 ] ) ; set ( ""pApplyStageLen"" , _parameters [ 3 ] ) ; set ( ""commitStageLen"" , _parameters [ 4 ] ) ; set ( ""pCommitStageLen"" , _parameters [ 5 ] ) ; set ( ""revealStageLen"" , _parameters [ 6 ] ) ; set ( ""pRevealStageLen"" , _parameters [ 7 ] ) ; set ( ""dispensationPct"" , _parameters [ 8 ] ) ; set ( ""pDispensationPct"" , _parameters [ 9 ] ) ; set ( ""voteQuorum"" , _parameters [ 10 ] ) ; set ( ""pVoteQuorum"" , _parameters [ 11 ] ) ; }
","_parameters array of canonical parameters
"
"function leftForSale ( ) public constant returns ( uint256 ) { Tier tier = tiers [ tierCount ] ; uint256 weiLeft = tier . cap ( ) . sub ( tier . totalInvestedWei ( ) ) ; uint256 tokensLeft = weiLeft . mul ( tier . exchangeRate ( ) ) ; return tokensLeft ; }
","calculates how many tokens left for sale
"
"function spread ( bool _side ) public constant returns ( uint ) ;
","Returns best bid or ask price .
"
"function release ( ) external onlyState ( State . Active ) onlyBeneficiary ( msg . sender ) { require ( ! beneficiaries [ msg . sender ] . releaseAllTokens ) ; uint releasableAmount = getReleasableAmount ( msg . sender ) ; beneficiaries [ msg . sender ] . withdrawAmount = beneficiaries [ msg . sender ] . withdrawAmount . add ( releasableAmount ) ; beneficiaries [ msg . sender ] . releaseAllTokens = beneficiaries [ msg . sender ] . withdrawAmount == getPartialAmount ( beneficiaries [ msg . sender ] . ratio , coeff , initialBalance ) ; withdrawAmount = withdrawAmount . add ( releasableAmount ) ; if ( withdrawAmount == initialBalance ) { state = State . Drawn ; emit StateChanged ( state ) ; } token . transfer ( msg . sender , releasableAmount ) ; emit Released ( msg . sender , releasableAmount ) ; }
","transfer releasable tokens for beneficiary wrt the release graph
"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
","This function is disabled during the funding .
"
"function setValidatorSigningKey ( address newSigningKey ) external ;
","Set the public address associated with a validator signing key , used to sign off-chain attribute approvals , as ` newSigningKey ` .
"
"function updatePrices ( uint newEthPrice , uint newSynthetixPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent , ""Time must be later than last update"" ) ; require ( timeSent < ( now + ORACLE_FUTURE_LIMIT ) , ""Time must be less than now + ORACLE_FUTURE_LIMIT"" ) ; usdToEthPrice = newEthPrice ; usdToSnxPrice = newSynthetixPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToSnxPrice , lastPriceUpdateTime ) ; }
","Access point for the oracle to update the prices of SNX / eth .
"
"function tokenOfOwnerByIndex ( address owner , uint256 index ) external view returns ( uint256 tokenId ) ;
","Enumerate tokens assigned to an owner
"
"function numberOfAuthorizedPayments ( ) constant returns ( uint ) { return authorizedPayments . length ; }
","States the total number of authorized payments in this contract
"
"function getSTODetails ( ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , bool ) { return ( startTime , endTime , cap , rate , ( fundRaiseTypes [ uint8 ( FundRaiseType . POLY ) ] ) ? fundsRaised [ uint8 ( FundRaiseType . POLY ) ] : fundsRaised [ uint8 ( FundRaiseType . ETH ) ] , investorCount , totalTokensSold , ( fundRaiseTypes [ uint8 ( FundRaiseType . POLY ) ] ) ) ; }
","Return the STO details
"
"function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) ;
","Notifies the controller about an approval allowing the controller to react if desired
"
"function release ( ERC20Basic token ) public { uint256 unreleased = releasableAmount ( token ) ; require ( unreleased > 0 ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . transfer ( beneficiary , unreleased ) ; emit Released ( unreleased ) ; }
","Transfers vested tokens to beneficiary .
"
"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return _owner == _operator ; }
","Query if an address is an authorized operator for another address
"
"function setRegistryAdmin ( address _newRegistryAdmin ) public onlyOwner { address _oldRegistryAdmin = registryAdmin ; registryAdmin = _newRegistryAdmin ; }
","Change the address of the registryAdmin , who has the privilege to create new accounts
"
"function changeGenerator ( address _newGenerator ) onlyGenerator { generator = _newGenerator ; }
","Changes the controller of the contract
"
"function deleteUint ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete uIntStorage [ _key ] ; return true ; }
","Delete value for Uint associated with bytes32 id key
"
"function buyTokens ( address _beneficiary ) public payable whenNotPaused { validatePurchase ( ) ; uint256 toFund = calculateToFund ( ) ; uint256 toReturn = msg . value . sub ( toFund ) ; require ( toFund > 0 ) ; uint256 rate = getRate ( ) ; uint256 tokens = rate . mul ( toFund ) ; require ( tokens > 0 ) ; if ( block . timestamp < phase2StartTime ) { phase1WeiRaised = phase1WeiRaised . add ( toFund ) ; } else { phase2WeiRaised = phase2WeiRaised . add ( toFund ) ; } if ( purchaserFunded [ msg . sender ] == 0 ) { numPurchasers = numPurchasers . add ( 1 ) ; } purchaserFunded [ msg . sender ] = purchaserFunded [ msg . sender ] . add ( toFund ) ; token . generateTokens ( _beneficiary , tokens ) ; emit TokenPurchase ( msg . sender , _beneficiary , toFund , tokens ) ; if ( toReturn > 0 ) { msg . sender . transfer ( toReturn ) ; } vault . deposit . value ( toFund ) ( msg . sender ) ; }
","buyTokens process token purchase .
"
"function verifyTransfer ( address _from , address _to , uint256 _amount , bytes , bool _isTransfer ) public returns ( Result ) { require ( _isTransfer == false || msg . sender == securityToken , ""Sender is not the owner"" ) ; if ( ! paused ) { if ( manualBlockings [ _from ] [ _to ] . expiryTime >= now ) { return Result . INVALID ; } if ( ( manualApprovals [ _from ] [ _to ] . expiryTime >= now ) && ( manualApprovals [ _from ] [ _to ] . allowance >= _amount ) ) { if ( _isTransfer ) { manualApprovals [ _from ] [ _to ] . allowance = manualApprovals [ _from ] [ _to ] . allowance . sub ( _amount ) ; } return Result . VALID ; } } return Result . NA ; }
","Used to verify the transfer transaction and allow a manually approved transqaction to bypass other restrictions
"
"function sendEther ( address to , uint value ) external onlymanyowners ( sha3 ( msg . data ) ) { require ( 0 != to ) ; require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }
","Send ` value ` of ether to address ` to `
"
"function emergencyRefundContract ( ) external payable onlyOwnerOrMultisig { require ( contractFailed ) ; require ( msg . value > 0 ) ; }
","Contract owner or Multisig can refund contract with ETH in case of failed Crowdsale
"
"function getSaleDay ( uint256 _time ) view public returns ( uint8 ) { return uint8 ( _time . sub ( startTime ) . div ( 60 * 60 * 24 ) . add ( 1 ) ) ; }
","For a give date how many 24 hour blocks have ellapsed since token sale start
"
"function unitEthCost ( uint256 cardId ) external constant returns ( uint256 ) { return cardInfo [ cardId ] . ethCost ; }
","get the production card 's ether cost
"
"function ( ) public payable { buy ( msg . sender ) ; }
","If anybody sends Ether directly to this contract , consider he is
"
"function getReferencePrice ( address ofBase , address ofQuote ) view returns ( bool isRecent , uint referencePrice , uint decimal ) { if ( getQuoteAsset ( ) == ofQuote ) { ( isRecent , referencePrice , decimal ) = getPrice ( ofBase ) ; } else if ( getQuoteAsset ( ) == ofBase ) { ( isRecent , referencePrice , decimal ) = getInvertedPrice ( ofQuote ) ; } else { revert ( ) ; } }
","Gets reference price of an asset pair
"
"function claimContractOwnership ( ) public returns ( bool ) { if ( msg . sender != pendingContractOwner ) { return false ; } emit OwnershipTransferred ( contractOwner , pendingContractOwner ) ; contractOwner = pendingContractOwner ; delete pendingContractOwner ; return true ; }
","Finalize ownership pass .
"
"function symbol ( ) public view returns ( string _symbol ) ;
","Returns the name of the token .
"
"function approve ( address _spender , uint256 _amount ) returns ( bool ) ;
","Approve ` _spender ` to transfer ` _amount ` of tokens
"
"function burnWithData ( uint256 _value , bytes _data ) public onlyModule ( BURN_KEY ) { require ( _burn ( msg . sender , _value , _data ) , ""Burn invalid"" ) ; }
","Burn function used to burn the securityToken
"
"function isPassed ( uint _pollID ) constant public returns ( bool passed ) { require ( pollEnded ( _pollID ) ) ; Poll memory poll = pollMap [ _pollID ] ; return ( 100 * poll . votesFor ) > ( poll . voteQuorum * ( poll . votesFor + poll . votesAgainst ) ) ; }
","Determines if proposal has passed
"
"function addTokenTo ( address _to , uint256 _tokenId ) internal { uint64 [ ] storage ownedList = ownedTokens [ _to ] ; TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( ownedList . length < uint256 ( 2 ** 32 ) - 1 , ""Max number of PixelCons per owner has been reached"" ) ; require ( lookupData . owner == address ( 0 ) , ""PixelCon already has an owner"" ) ; lookupData . owner = _to ; uint ownedListIndex = ownedList . length ; ownedList . length ++ ; lookupData . ownedIndex = uint32 ( ownedListIndex ) ; ownedList [ ownedListIndex ] = lookupData . tokenIndex ; }
","Add a token ID to the list of a given address
"
"function cloneProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument , uint _dateOfProposal , uint _lastClientProposalID , uint _orderAmount , uint _dateOfOrder ) ;
","Function to clone a proposal from another manager contract
"
"function getStartTime ( ) internal constant returns ( uint ) { return 1508958000 ; }
","start time of the pre-ICO
"
"function openChannel ( address participant1 , address participant2 , uint256 settle_timeout ) isSafe settleTimeoutValid ( settle_timeout ) public returns ( uint256 ) { bytes32 pair_hash ; uint256 channel_identifier ; require ( token . balanceOf ( address ( this ) ) < token_network_deposit_limit ) ; channel_counter += 1 ; channel_identifier = channel_counter ; pair_hash = getParticipantsHash ( participant1 , participant2 ) ; require ( participants_hash_to_channel_identifier [ pair_hash ] == 0 ) ; participants_hash_to_channel_identifier [ pair_hash ] = channel_identifier ; Channel storage channel = channels [ channel_identifier ] ; assert ( channel . settle_block_number == 0 ) ; assert ( channel . state == ChannelState . NonExistent ) ; channel . settle_block_number = settle_timeout ; channel . state = ChannelState . Opened ; emit ChannelOpened ( channel_identifier , participant1 , participant2 , settle_timeout ) ; return channel_identifier ; }
","Opens a new channel between ` participant1 ` and ` participant2 ` .
"
"function withdraw ( uint256 amount ) public onlyIfWithdrawAllowed ( msg . sender , amount ) acceptAgreement ( msg . sender ) { destroyTokensPrivate ( msg . sender , amount ) ; emit LogWithdrawal ( msg . sender , amount ) ; }
","withdraws 'amount ' of EUR-T by burning required amount and providing a proof of whithdrawal
"
"function approveAndCall ( address spender , uint256 value , bytes data ) public returns ( bool ) ;
","Approve the passed address to spend the specified amount of tokens on behalf of msg.sender and then call ` onApprovalReceived ` on spender Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering .
"
"function description ( bytes32 _symbol ) public view returns ( string ) { return assets [ _symbol ] . description ; }
","Returns asset description .
"
"function getBonusesAmountAvailable ( bytes32 _userKey , uint _distributionDate ) public view returns ( uint ) { Deposit storage _deposit = distributionDeposits [ _distributionDate ] ; if ( _deposit . leftToWithdraw [ _userKey ] . initialized ) { return _deposit . leftToWithdraw [ _userKey ] . left ; } uint _sharesPercent = Treasury ( treasury ) . getSharesPercentForPeriod ( _userKey , _distributionDate ) ; return _deposit . balance . mul ( _sharesPercent ) . div ( PERCENT_PRECISION ) ; }
","Gets an amount of bonuses user has for concrete distribution date
"
"function mintMulti ( address [ ] _investors , uint256 [ ] _amounts ) public onlyModule ( STO_KEY , true ) returns ( bool success ) { require ( _investors . length == _amounts . length , ""Mis-match in the length of the arrays"" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { mint ( _investors [ i ] , _amounts [ i ] ) ; } return true ; }
","mints new tokens and assigns them to the target _investor .
"
"function setHandler ( address handler , bool allowed ) public onlyOwner { handlerWhitelist [ handler ] = allowed ; }
","- onlyOwner modifier only allows the contract owner to run the code
"
"function addOrganization ( address organization , uint256 maximumIssuableAttributes , string name ) external onlyOwner whenNotPaused { require ( organization != address ( 0 ) , ""must supply a valid account address"" ) ; require ( _organizations [ organization ] . exists == false , ""an organization already exists at the provided account address"" ) ; _organizations [ organization ] . exists = true ; _organizations [ organization ] . maximumAccounts = maximumIssuableAttributes ; _organizations [ organization ] . name = name ; _organizationAccounts . push ( organization ) ; emit OrganizationAdded ( organization , name ) ; }
","Add an organization at account ` organization ` and with an initial allocation of issuable attributes of ` maximumIssuableAttributes ` .
"
"function startICO ( bool start ) public onlyOwner { isICORunning = start ; }
","Start ICO .
"
"function createCheckpoint ( ) external onlyModuleOrOwner ( CHECKPOINT_KEY ) returns ( uint256 ) { require ( currentCheckpointId < 2 ** 256 - 1 ) ; currentCheckpointId = currentCheckpointId + 1 ; checkpointTimes . push ( now ) ; emit CheckpointCreated ( currentCheckpointId , now ) ; return currentCheckpointId ; }
","Creates a checkpoint that can be used to query historical balances / totalSuppy
"
"function breedWithAuto ( uint256 _matronId , uint256 _sireId ) external payable whenNotPaused { uint256 totalFee = autoBirthFee ; Dog storage matron = dogs [ _matronId ] ; if ( matron . generation > 0 ) { totalFee += gen0Profit ; } require ( msg . value >= totalFee ) ; require ( _owns ( msg . sender , _matronId ) ) ; require ( _isSiringPermitted ( _sireId , _matronId ) ) ; require ( _isReadyToBreed ( matron ) ) ; Dog storage sire = dogs [ _sireId ] ; require ( _isReadyToBreed ( sire ) ) ; require ( _isValidMatingPair ( matron , _matronId , sire , _sireId ) ) ; _breedWith ( _matronId , _sireId ) ; uint256 breedExcess = msg . value - totalFee ; if ( breedExcess > 0 ) { msg . sender . transfer ( breedExcess ) ; } }
","Breed a Dog you own ( as matron ) with a sire that you own , or for which you have previously been given Siring approval .
"
"function confirmPrint ( bytes32 _lockId ) public onlyCustodian { PendingPrint storage print = pendingPrintMap [ _lockId ] ; address receiver = print . receiver ; require ( receiver != address ( 0 ) ) ; uint256 value = print . value ; delete pendingPrintMap [ _lockId ] ; uint256 supply = erc20Store . totalSupply ( ) ; uint256 newSupply = supply + value ; if ( newSupply >= supply ) { erc20Store . setTotalSupply ( newSupply ) ; erc20Store . addBalance ( receiver , value ) ; emit PrintingConfirmed ( _lockId , receiver , value ) ; erc20Proxy . emitTransfer ( address ( 0 ) , receiver , value ) ; } }
","Confirms a pending increase in the token supply .
"
"function transfer ( address _to , uint256 _amount ) public returns ( bool ) { uint256 _fee = validator . validateAndGetTransferFee ( owner , msg . sender , _to , _amount ) ; store . transfer ( msg . sender , _to , _amount ) ; if ( _fee > 0 ) store . transfer ( msg . sender , store . getSettingAddress ( ""feeReturnAddress"" ) , _fee ) ; Transfer ( msg . sender , _to , _amount ) ; return true ; }
","Transfer ` _amount ` of tokens ( must be sent as floating point number of token and decimal parts ) to ` _address ` with preliminary approving amount + fee from transaction sender
"
"function hasConfirmed ( bytes32 _operation , address _owner ) external constant multiOwnedOperationIsActive ( _operation ) ownerExists ( _owner ) returns ( bool ) { return ! ( m_multiOwnedPending [ _operation ] . ownersDone & makeOwnerBitmapBit ( _owner ) == 0 ) ; }
","Checks if owner confirmed given operation
"
"function performSellOrder ( bytes genericPayload , uint256 amountToGiveForOrder ) public onlyTotle whenNotPaused returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { bool success ; bytes4 functionSelector = selectorProvider . getSelector ( this . performSellOrder . selector ) ; assembly { let callDataOffset := 0x44 let functionSelectorOffset := 0x1C let functionSelectorLength := 0x04 let scratchSpace := 0x0 let wordLength := 0x20 let startOfFreeMemory := mload ( 0x40 ) calldatacopy ( startOfFreeMemory , callDataOffset , calldatasize ) let bytesLength := mload ( startOfFreeMemory ) let totalLength := add ( add ( functionSelectorLength , bytesLength ) , wordLength ) mstore ( add ( scratchSpace , functionSelectorOffset ) , functionSelector ) let functionSelectorCorrect := mload ( scratchSpace ) mstore ( startOfFreeMemory , functionSelectorCorrect ) mstore ( add ( startOfFreeMemory , add ( wordLength , bytesLength ) ) , amountToGiveForOrder ) let startOfNewData := add ( startOfFreeMemory , functionSelectorOffset ) success := call ( gas , address , callvalue , startOfNewData , totalLength , scratchSpace , mul ( wordLength , 0x02 ) ) amountSpentOnOrder := mload ( scratchSpace ) amountReceivedFromOrder := mload ( add ( scratchSpace , wordLength ) ) if eq ( success , 0 ) { revert ( 0 , 0 ) } } }
","Perform a sell order at the exchange
"
"function staticExchangeChecks ( bytes genericPayload ) public view onlyTotle whenNotPaused returns ( bool checksPassed ) { bool success ; bytes4 functionSelector = selectorProvider . getSelector ( this . staticExchangeChecks . selector ) ; assembly { let functionSelectorLength := 0x04 let functionSelectorOffset := 0x1C let scratchSpace := 0x0 let wordLength := 0x20 let bytesLength := mload ( genericPayload ) let totalLength := add ( functionSelectorLength , bytesLength ) let startOfNewData := add ( genericPayload , functionSelectorOffset ) mstore ( add ( scratchSpace , functionSelectorOffset ) , functionSelector ) let functionSelectorCorrect := mload ( scratchSpace ) mstore ( genericPayload , functionSelectorCorrect ) success := call ( gas , address , callvalue , startOfNewData , totalLength , scratchSpace , wordLength ) checksPassed := mload ( scratchSpace ) if eq ( success , 0 ) { revert ( 0 , 0 ) } } }
","Perform exchange-specific checks on the given order
"
"function ( ) external payable { require ( msg . sender == address ( saleAuction ) ) ; }
","No tipping !
"
"function removeOwnership ( address _dac ) external onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; emit OwnershipRemoved ( ) ; }
","Decentralizes the contract , this operation can not be undone
"
"function multiBatchTransferFrom ( uint256 [ ] _tokenIds , address [ ] _fromB , address [ ] _toB ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _fromB . length > 0 && _toB . length > 0 ) ; uint256 _id ; address _to ; address _from ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 && _fromB [ i ] != 0 && _toB [ i ] != 0 ) ; _id = _tokenIds [ i ] ; _to = _toB [ i ] ; _from = _fromB [ i ] ; transferFrom ( _from , _to , _id ) ; } }
","Batch Trasnfer with multpple TO addresses
"
"function invalidateAttributeApproval ( bytes32 hash , bytes signature ) external ;
","Invalidate a signed attribute approval before it has been set by supplying the hash of the approval ` hash ` and the signature ` signature ` .
"
"function claimTokens ( address _token ) onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function getModule ( address _module ) external view returns ( bytes32 , address , address , bool , uint8 [ ] ) ;
","Returns module list for a module type
"
"function setEtherFeePercent ( uint256 percent ) public onlyOwner { require ( percent <= 100000000000000000000 , ""Percent must be between 0 and 100."" ) ; etherFeePercent = percent ; }
","Set the percent fee applied to the Ether used to pay for tokens .
"
"function removeReserve ( KyberReserveInterface reserve , uint index ) public onlyOperator returns ( bool ) { require ( reserveType [ reserve ] != ReserveType . NONE ) ; require ( reserves [ index ] == reserve ) ; reserveType [ reserve ] = ReserveType . NONE ; reserves [ index ] = reserves [ reserves . length - 1 ] ; reserves . length -- ; RemoveReserveFromNetwork ( reserve ) ; return true ; }
","can be called only by operator
"
"function cancelAction ( bytes32 _requestId ) public whenNotPaused { require ( ( requestCore . getPayer ( _requestId ) == msg . sender && requestCore . getState ( _requestId ) == RequestCore . State . Created ) || ( requestCore . getPayeeAddress ( _requestId , 0 ) == msg . sender && requestCore . getState ( _requestId ) != RequestCore . State . Canceled ) , ""payer should cancel a newly created request, or payee should cancel a not cancel request"" ) ; require ( requestCore . areAllBalanceNull ( _requestId ) , ""all balanaces should be = 0 to cancel"" ) ; requestCore . cancel ( _requestId ) ; }
","Function to cancel a request .
"
"function pay ( address engine , uint256 loan , uint256 amount ) external returns ( bool ) { emit PaidLoan ( engine , loan , amount ) ; bytes32 [ 4 ] memory loanParams = [ bytes32 ( engine ) , bytes32 ( loan ) , bytes32 ( amount ) , bytes32 ( msg . sender ) ] ; uint256 [ 3 ] memory converterParams = [ marginSpend , amount . safeMult ( uint256 ( 100000 ) . safeAdd ( maxSpend ) ) / 100000 , rebuyThreshold ] ; require ( address ( converterRamp ) . delegatecall ( bytes4 ( 0x86ee863d ) , address ( tokenConverter ) , address ( mana ) , loanParams , 0x140 , converterParams , 0x0 ) , ""Error delegate pay call"" ) ; }
","Pays a loan using mana
"
"function enableSweep ( uint8 [ ] _vs , bytes32 [ ] _rs , bytes32 [ ] _ss , address _to ) public onlySweeper { require ( _to != address ( 0 ) ) ; require ( ( _vs . length == _rs . length ) && ( _vs . length == _ss . length ) ) ; uint256 numSignatures = _vs . length ; uint256 sweptBalance = 0 ; for ( uint256 i = 0 ; i < numSignatures ; ++ i ) { address from = ecrecover ( sweepMsg , _vs [ i ] , _rs [ i ] , _ss [ i ] ) ; if ( from != address ( 0 ) ) { sweptSet [ from ] = true ; uint256 fromBalance = erc20Store . balances ( from ) ; if ( fromBalance > 0 ) { sweptBalance += fromBalance ; erc20Store . setBalance ( from , 0 ) ; erc20Proxy . emitTransfer ( from , _to , fromBalance ) ; } } } if ( sweptBalance > 0 ) { erc20Store . addBalance ( _to , sweptBalance ) ; } }
","Enables the delegation of transfer control for many accounts to the sweeper account , transferring any balances as well to the given destination .
"
"function ( ) payable public { uint amount = msg . value * buyMultiplier / buyPrice ; _transfer ( this , msg . sender , amount ) ; }
","Automatically buy tokens from contract by sending ether ( no ` data ` required ) .
"
"function _mint ( address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) , ""invalid target address"" ) ; require ( tokenOwnerAndTokensIndex [ _tokenId ] . owner == address ( 0 ) , ""token already exists"" ) ; _addToken ( _to , _tokenId ) ; emit Transfer ( 0x0 , _to , _tokenId ) ; }
","Mint token function
"
"function allocateInternal ( address _receiver , bytes16 _customerUuid , uint256 _weiAmount ) private { uint256 tokenAmount = pricingStrategy . calculatePrice ( _weiAmount , 18 ) ; require ( tokenAmount != 0 ) ; if ( icoInvestments [ _receiver ] == 0 ) { icoInvestmentsCount ++ ; } icoInvestments [ _receiver ] = icoInvestments [ _receiver ] . add ( _weiAmount ) ; icoTokenTransfers [ _receiver ] = icoTokenTransfers [ _receiver ] . add ( tokenAmount ) ; icoReceivedWei = icoReceivedWei . add ( _weiAmount ) ; icoTokensSold = icoTokensSold . add ( tokenAmount ) ; assignTokens ( owner , _receiver , tokenAmount ) ; Invested ( _receiver , _weiAmount , tokenAmount , _customerUuid ) ; }
","Handle tokens allocating .
"
"function pauseSale ( ) public onlyController { require ( campaignState == 2 ) ; paused = true ; CampaignPaused ( now ) ; }
","Pause sale just in case we have some troubles Note that time marks are not updated
"
"function allowance ( address tokenOwner , address spender ) public constant returns ( uint256 remaining ) { requireTrade ( tokenOwner ) ; return allowed [ tokenOwner ] [ spender ] ; }
","Returns the amount of tokens approved by the owner that can be transferred to the spender 's account
"
"function onTransfer ( address _from , address _to , uint _amount ) returns ( bool ) { return false ; }
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function getJurisdiction ( ) external view returns ( address ) { return address ( _jurisdiction ) ; }
","Get account of utilized jurisdiction and associated attribute registry managed by the jurisdiction .
"
"function getIndexRoot ( bytes32 indexId ) constant returns ( bytes32 ) { return index_lookup [ indexId ] . root ; }
","Retrieves the id of the root node for this index .
"
"function getHolderId ( address _holder ) public view returns ( uint ) { return get ( store , holderIndexStorage , _holder ) ; }
","Returns holder id for the specified address .
"
"function getInitFunction ( ) public pure returns ( bytes4 ) { return 0xb0ff041e ; }
","This function returns the signature of configure function
"
"function changePrice ( uint256 _tokenId , uint256 newPrice ) public { require ( _owns ( msg . sender , _tokenId ) ) ; uint256 oldPrice = personIndexToPrice [ _tokenId ] ; uint256 maxPrice = uint256 ( SafeMath . mul ( oldPrice , 5 ) ) ; uint256 minPrice = startingPrice ; require ( minPrice < newPrice && newPrice < maxPrice ) ; personIndexToPrice [ _tokenId ] = newPrice ; PriceChange ( _tokenId , oldPrice , newPrice , persons [ _tokenId ] . name ) ; }
","Allow the owner of the token change the price of the person .
"
"function changeMinimumCap ( uint256 _cap ) public onlyOwner { if ( minimumCap < _cap ) revert ( ) ; minimumCap = _cap ; }
","change minimum cap , in case Ether price fluctuates .
"
"function registerUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; if ( isRegisteredUser ( _user ) ) { return USER_MANAGER_MEMBER_ALREADY_EXIST ; } uint _membersCount = membersCount . add ( 1 ) ; membersCount = _membersCount ; memberAddress2index [ _user ] = _membersCount ; index2memberAddress [ _membersCount ] = _user ; address2member [ _user ] = Member ( _user , 0 ) ; UserCreated ( _user ) ; return OK ; }
","Register user Can be called only by contract owner
"
"function claimTokensByAdmin ( address _target ) onlyAdmin ( 1 ) public { uint256 tokens = balance [ _target ] ; balance [ _target ] = 0 ; require ( tokenReward . transfer ( _target , tokens ) ) ; tokensSent [ _target ] = tokensSent [ _target ] . add ( tokens ) ; emit LogContributorsPayout ( _target , tokens ) ; }
","function to let admin claim tokens on behalf users
"
"function name ( ) public view returns ( string ) { return ""Axie Origin Coin"" ; }
","Returns the name of the token .
"
"function withdrawFundsAdvanced ( address _toAddress , uint _valueWei , uint _extraGas ) { externalEnter ( ) ; withdrawFundsAdvancedRP ( _toAddress , _valueWei , _extraGas ) ; externalLeave ( ) ; }
","Send ` _valueWei ` of the ether owned by the caller ( ` msg.sender ` ) to ` _toAddress ` , including ` _extraGas ` gas beyond the normal stipend .
"
"function buyTokens ( address _beneficiary ) public payable { uint256 weiAmount = msg . value ; _preValidatePurchase ( _beneficiary , weiAmount ) ; uint256 tokens = _getTokenAmount ( weiAmount ) ; require ( token . balanceOf ( this ) >= tokens ) ; totalWeiRaised = totalWeiRaised . add ( weiAmount ) ; tokensSold = tokensSold . add ( tokens ) ; _deliverTokens ( _beneficiary , tokens ) ; emit TokenPurchase ( msg . sender , _beneficiary , weiAmount , tokens ) ; _processBonus ( msg . sender , tokens ) ; _forwardFunds ( ) ; }
","Function calls other functions to calculate tokenamount to send to beneficiary .
"
"function renounceOwnership ( ) public onlyOwner ( ""renounceOwnership"" ) { emit OwnershipRenounced ( owner ) ; owner = address ( 0 ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; if ( msg . value == 0 ) { wpr . unpause ( ) ; ExchangerI ( exchanger ) . collect ( _th ) ; wpr . pause ( ) ; } else { doBuy ( _th ) ; } return true ; }
","This method will generally be called by the WPR token contract to acquire WPRs .
"
"function createDestructibleCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( DestructibleMiniMeToken ) { DestructibleMiniMeToken newToken = new DestructibleMiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled , msg . sender ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function BuyToken ( address _buyer , uint256 _value , string note ) onlyOwner public { require ( balances [ msg . sender ] >= _value && balances [ _buyer ] + _value > balances [ _buyer ] ) ; SoldToken ( _buyer , _value , note ) ; balances [ msg . sender ] -= _value ; balances [ _buyer ] += _value ; Transfer ( msg . sender , _buyer , _value ) ; }
","Buy quantity of tokens depending on the amount of sent ethers .
"
"function officialSold ( ) constant returns ( uint256 ) { return officialSold_ . get ( ) ; }
","calculate tokens sold officially
"
"function tokenFactory ( uint256 _amount ) public onlyOwner returns ( bool success ) { require ( tokenMinter ( _amount ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; Transfer ( 0 , msg . sender , _amount ) ; return true ; }
","Used to create new tokens and increase total supply
"
"function deposit ( address _investor , uint256 _tokenAmount ) onlyICOContract public payable returns ( bool ) { if ( state != State . Active ) { error ( 'deposit: state != State.Active' ) ; return false ; } deposited [ _investor ] = deposited [ _investor ] . add ( msg . value ) ; tokensAcquired [ _investor ] = tokensAcquired [ _investor ] . add ( _tokenAmount ) ; return true ; }
","Registers how many tokens have each investor and how many ethers they spent ( When ICOing through PayIn this function is not called )
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) ;
","Enumerate NFTs assigned to an owner
"
"function createChannel ( address _receiver_address , uint192 _deposit ) external { createChannelPrivate ( msg . sender , _receiver_address , _deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _deposit ) ) ; }
","Creates a new channel between ` msg.sender ` and ` _receiver_address ` and transfers the ` _deposit ` token deposit to this contract .
"
"function release ( ) public { require ( now >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; onTimeout ( amount ) ; }
","When timeout .
"
"function set_pauseReturn ( bool _pauseReturn ) onlyOwner public { return_pause = _pauseReturn ; }
","Set the bool value of return_pause
"
"function isValidator ( address account ) public view returns ( bool ) { return _validators [ account ] . exists ; }
","Determine if the account ` account ` is currently assigned as a validator on the jurisdiction .
"
"function ( ) is_live ( ) payable { if ( msg . value == 0 ) revert ( ) ; if ( isFinalized ) revert ( ) ; uint256 tokens = safeMult ( msg . value , tokenExchangeRate ) ; uint256 checkedSupply = safeAdd ( totalSupply , tokens ) ; if ( maxCap < checkedSupply ) revert ( ) ; totalSupply = checkedSupply ; balances [ msg . sender ] += tokens ; MPYCreation ( msg . sender , tokens ) ; }
","Get Tokens : 0.1 ETH per 1 MPY token
"
"function countBlocks ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) internal pure returns ( uint16 ) { return ( toX - fromX + 1 ) * ( toY - fromY + 1 ) ; }
","get a number of blocks within area
"
"function transferWithSender ( address _sender , address _to , uint256 _value ) public onlyProxy returns ( bool success ) { require ( _to != address ( 0 ) ) ; uint256 balanceOfSender = erc20Store . balances ( _sender ) ; require ( _value <= balanceOfSender ) ; erc20Store . setBalance ( _sender , balanceOfSender - _value ) ; erc20Store . addBalance ( _to , _value ) ; erc20Proxy . emitTransfer ( _sender , _to , _value ) ; return true ; }
","Core logic of the ERC20 ` transfer ` function .
"
"function contestFor ( address _attester , address _requester , uint256 _reward , bytes32 _requestNonce , bytes _requesterSig , bytes _delegationSig ) external { validateContestForSig ( _attester , _requester , _reward , _requestNonce , _delegationSig ) ; contestForUser ( _attester , _requester , _reward , _requestNonce , _requesterSig ) ; }
","Function for attester to reject an attestation and receive payment without associating the negative attestation with the subject 's bloomId Perform on behalf of attester to pay gas fees
"
"function approveAndCall ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokens , this , data ) ; return true ; }
","Token owner can approve for spender to transferFrom ( ... ) tokens from the token owner 's account .
"
"function getFeeParams ( ) public view returns ( uint bps , uint min , uint max , uint flat , bytes feeMsg , address feeAccount ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; return ( lib . getFeeBPS ( feeContract ) , lib . getFeeMin ( feeContract ) , lib . getFeeMax ( feeContract ) , lib . getFeeFlat ( feeContract ) , lib . getFeeMsg ( feeContract ) , feeContract ) ; }
","Gets fee parameters
"
"function getFeeBPS ( Data storage self , address contractAddress ) internal view returns ( uint feeBps ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.bps' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }
","Get the basis points fee of the contract address ; typically TokenIOFeeContract
"
"function isOwner ( address _who ) public view returns ( bool ) { return owners [ _who ] ; }
","Look up for the owner role on providen address
"
"function setAllowedTransferFrom ( address from , bool allowed ) public only ( ROLE_EURT_LEGAL_MANAGER ) { setAllowedTransferFromPrivate ( from , allowed ) ; }
","enables or disables address to be sender of EUR-T
"
"function setTradingAllowed ( address who , bool canTrade ) public onlyOwner { tradingWhitelist [ who ] = canTrade ; }
","Allow/disallow users from participating in trading .
"
"function isFinalized ( bytes32 question_id ) view public returns ( bool ) { uint32 finalize_ts = questions [ question_id ] . finalize_ts ; return ( ! questions [ question_id ] . is_pending_arbitration && ( finalize_ts > UNANSWERED ) && ( finalize_ts <= uint32 ( now ) ) ) ; }
","Report whether the answer to the specified question is finalized
"
"function convertWT ( uint256 _amount ) public requiresPermission whenNotPaused { require ( balanceOf ( msg . sender ) >= _amount , ""Conversion amount should be less than balance"" ) ; _burn ( msg . sender , _amount ) ; _mintCUSD ( msg . sender , _amount ) ; emit ConvertedToCUSD ( msg . sender , _amount ) ; }
","Converts WT0 to CarbonUSD for the user .
"
"function updateAndGetHodlTotalValue ( ) public returns ( uint ) { if ( now >= hodlerTime3M && hodlerTotalValue3M == 0 ) { hodlerTotalValue3M = hodlerTotalValue ; } if ( now >= hodlerTime6M && hodlerTotalValue6M == 0 ) { hodlerTotalValue6M = hodlerTotalValue ; } if ( now >= hodlerTime9M && hodlerTotalValue9M == 0 ) { hodlerTotalValue9M = hodlerTotalValue ; TOKEN_HODL_9M = TokenController ( owner ) . ethealToken ( ) . balanceOf ( this ) . sub ( TOKEN_HODL_3M ) . sub ( TOKEN_HODL_6M ) . add ( claimedTokens ) ; } return hodlerTotalValue ; }
","Setting 3 - 6 - 9 months total staking hodl value if time is come
"
"function refundLeftOverEth ( uint index , uint amount , address reciever , address sc ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( isAirDropUnique ( index , reciever , sc ) == true ) { airdrop . distributor . transfer ( amount ) ; } else revert ( ) ; }
","Refund eth left over from Distribution back to the airdrop creator
"
"function payoutMethodABI ( ) public constant returns ( string ) { }
","use to determine the contribution method abi
"
"function cancelPaymentGlobally ( uint _idDeposit ) public onlyOwner { require ( _idDeposit < deposits . length ) ; deposits [ _idDeposit ] . canceled = true ; CancelPaymentGlobally ( _idDeposit ) ; }
","This function is a failsafe function in case a token is deposited that has an issue that could prevent it 's withdraw loop break ( e.g .
"
"function changeGranularity ( uint256 _granularity ) external ;
","Allows the owner to change token granularity
"
"function unitsOneEthCanBuy ( ) public view returns ( uint _units ) { for ( uint i = 0 ; i < rounds . length ; i ++ ) { Round memory round = rounds [ i ] ; if ( block . timestamp >= round . start && block . timestamp < round . end ) { return round . price ; } } return 0 ; }
","Gets the conversion rate for ETH purchases .
"
"function totalSupply ( ) external view returns ( uint256 ) { return kitties . length - destroyKittyCount - 1 ; }
","Count NFTs tracked by this contract
"
"function onApprovalReceived ( address _owner , uint256 _value , bytes _data ) external returns ( bytes4 ) ;
","Handle the approval of ERC1363 tokens
"
"function getPow ( uint256 _tokenId ) public view returns ( uint256 Id , string powName , uint256 sellingPrice , address owner , uint gameId , uint gameItemId1 , uint gameItemId2 ) { Pow storage pow = pows [ _tokenId ] ; Id = _tokenId ; powName = pow . name ; sellingPrice = powIndexToPrice [ _tokenId ] ; owner = powIndexToOwner [ _tokenId ] ; gameId = pow . gameId ; gameItemId1 = pow . gameItemId1 ; gameItemId2 = pow . gameItemId2 ; }
","Returns all the relevant information about a specific pow .
"
"function approve ( address _spender , uint256 _value ) external returns ( bool success ) ;
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function compareUpperBound ( uint8 [ ] _version1 , uint8 [ ] _version2 ) internal pure returns ( bool ) { require ( _version1 . length == _version2 . length , ""Input length mismatch"" ) ; uint counter = 0 ; for ( uint8 j = 0 ; j < _version1 . length ; j ++ ) { if ( _version1 [ j ] == 0 ) counter ++ ; } if ( counter != _version1 . length ) { counter = 0 ; for ( uint8 i = 0 ; i < _version1 . length ; i ++ ) { if ( _version1 [ i ] > _version2 [ i ] ) return true ; else if ( _version1 [ i ] < _version2 [ i ] ) return false ; else counter ++ ; } if ( counter == _version1 . length - 1 ) return true ; else return false ; } else return true ; }
","Used to compare the upper bound with the latest version
"
"function removeAttributeFor ( address account , uint256 attributeTypeID ) external ;
","Remove an attribute of the type with ID ` attributeTypeID ` from account of ` account ` .
"
"function passTurn ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; PlayerColor activeColor = getPlayerColor ( board , msg . sender ) ; require ( board . status == BoardStatus . InProgress && board . nextTurnColor == activeColor ) ; if ( updatePlayerTime ( board , boardId , activeColor ) ) { if ( board . didPassPrevTurn ) { board . isHonorableLoss = true ; updateBoardStatus ( board , boardId , BoardStatus . WaitingToResolve ) ; } else { nextTurn ( board ) ; board . didPassPrevTurn = true ; PlayerPassedTurn ( boardId , activeColor ) ; } } }
","Performs a pass action on a psecific board , only by the current active color player .
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = warriorToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
","ERC-721 method .
"
"function transferFrom ( address _from , address _to , uint _value ) returns ( bool ) { var avail = allowance [ _from ] [ msg . sender ] > balanceOf [ _from ] ? balanceOf [ _from ] : allowance [ _from ] [ msg . sender ] ; if ( avail >= _value ) { allowance [ _from ] [ msg . sender ] -= _value ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; } return false ; }
","from ` _from ` will be sended ` _value ` tokens to ` _to `
"
"function proxyPayment ( address _owner ) public payable initialized returns ( bool ) { return false ; }
","Called when ` _owner ` sends ether to the MiniMe Token contract
"
"function setICOPrice ( uint256 priceForIcoInWei ) isOwner { require ( priceForIcoInWei > 0 ) ; require ( ICOprice != priceForIcoInWei ) ; ICOprice = priceForIcoInWei ; updatePrices ( ) ; }
","Set current ICO price price in wei for one metadollar
"
"function getIdentity ( uint ein ) public view _identityExists ( ein ) returns ( address recoveryAddress , address [ ] memory associatedAddresses , address [ ] memory providers , address [ ] memory resolvers ) { Identity storage _identity = identityDirectory [ ein ] ; return ( _identity . recoveryAddress , _identity . associatedAddresses . members , _identity . providers . members , _identity . resolvers . members ) ; }
","Gets all identity-related information for the passed EIN .
"
"function getBetsFromAddress ( address bettorAddress ) public view returns ( uint [ ] ) { return addressToBets [ bettorAddress ] ; }
","Returns an array containing the ids of the bets placed by a specific address
"
"function createCDPLeveragedDai ( uint amount ) public auth stoppable returns ( bytes32 id ) { require ( amount >= minDai ) ; uint price = uint ( feed . read ( ) ) ; require ( dai . transferFrom ( msg . sender , this , amount ) ) ; uint bought = otc . sellAllAmount ( dai , amount , gem , wmul ( WAD - slippage , wdiv ( amount , price ) ) ) ; id = _openAndJoinCDPWETH ( bought ) ; while ( _reinvest ( id , price ) ) { } tub . give ( id , msg . sender ) ; }
","create a CDP the given amount of Dai in the sender 's balance ( needs approval ) , and then create Dai and reinvest it in the CDP until the target liquidation price is reached ( or the minimum investment amount )
"
"function updateTokenDetails ( string _newTokenDetails ) public onlyOwner { emit LogUpdateTokenDetails ( tokenDetails , _newTokenDetails ) ; tokenDetails = _newTokenDetails ; }
","change the tokenDetails
"
"function checkOrder ( uint32 [ ] sortedChunk ) external onlyAdmin checkState ( pointsValidationState . LimitCalculated ) { require ( sortedChunk . length + sortedWinners . length <= winnerCounter ) ; for ( uint256 i = 0 ; i < sortedChunk . length - 1 ; i ++ ) { uint256 id = sortedChunk [ i ] ; uint256 sigId = sortedChunk [ i + 1 ] ; require ( tokenToPointsMap [ id ] > tokenToPointsMap [ sigId ] || ( tokenToPointsMap [ id ] == tokenToPointsMap [ sigId ] && id < sigId ) ) ; } if ( sortedWinners . length != 0 ) { uint256 id2 = sortedWinners [ sortedWinners . length - 1 ] ; uint256 sigId2 = sortedChunk [ 0 ] ; require ( tokenToPointsMap [ id2 ] > tokenToPointsMap [ sigId2 ] || ( tokenToPointsMap [ id2 ] == tokenToPointsMap [ sigId2 ] && id2 < sigId2 ) ) ; } for ( uint256 j = 0 ; j < sortedChunk . length ; j ++ ) { sortedWinners . push ( sortedChunk [ j ] ) ; } if ( sortedWinners . length == winnerCounter ) { require ( sortedWinners [ sortedWinners . length - 1 ] == pointsLimit ) ; pValidationState = pointsValidationState . OrderChecked ; } }
","Checks if the order given offchain coincides with the order of the actual previously calculated points in the smart contract .
"
"function getForCollection ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( uint64 [ ] ) { return collectionTokens [ _collectionIndex ] ; }
","Get the indexes of all PixelCons in collection # ` ( _collectionIndex ) `
"
"function challengeReparameterization ( bytes32 _propID ) public returns ( uint ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( ""pDispensationPct"" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; ( uint commitEndDate , uint revealEndDate , , , ) = voting . pollMap ( pollID ) ; emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate ) ; return pollID ; }
","challenge the provided proposal ID , and put tokens at stake to do so .
"
"function isOwner ( address _owner , bytes32 _symbol ) public view returns ( bool ) { return isCreated ( _symbol ) && ( assets [ _symbol ] . owner == getHolderId ( _owner ) ) ; }
","Check if specified address has asset owner rights .
"
"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }
","Query if an address is an authorized operator for another address
"
"function updateSlasher ( address _newSlasherAddress ) external onlyOwner { emit LogSlasherUpdated ( slasherAddress , _newSlasherAddress ) ; slasherAddress = _newSlasherAddress ; }
","The owner of the contract can update the slasher address .
"
"function clearDelegateAndUnlockTokens ( ) public onlyDelegated notSelf returns ( uint lockedTokens ) { address delegate = delegatesByDelegator [ msg . sender ] ; lockedTokens = lockedDelegatingTokens [ msg . sender ] ; lockedDelegatingTokens [ msg . sender ] = 0 ; delegatedAmountsByDelegate [ delegate ] = SafeMath . sub ( delegatedAmountsByDelegate [ delegate ] , lockedTokens ) ; totalLockedTokens = SafeMath . sub ( totalLockedTokens , lockedTokens ) ; delete delegatesByDelegator [ msg . sender ] ; require ( tokenLocker . transfer ( msg . sender , lockedTokens ) ) ; require ( sharesTokenAddress . balanceOf ( tokenLocker ) == totalLockedTokens ) ; TokensUndelegated ( msg . sender , lockedTokens , delegate ) ; return lockedTokens ; }
","Clear the delegate address for all tokens delegated by the sending address , unlocking the locked tokens .
"
"function changeOwner ( address _newOwner ) public onlyOwner { newOwner = _newOwner ; }
","` owner ` can step down and assign some other address to this role
"
"function notifyOfArbitrationRequest ( bytes32 question_id , address requester , uint256 max_previous ) onlyArbitrator ( question_id ) stateOpen ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external { questions [ question_id ] . is_pending_arbitration = true ; LogNotifyOfArbitrationRequest ( question_id , requester ) ; }
","Notify the contract that the arbitrator has been paid for a question , freezing it pending their decision .
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = collectibleIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function redeemable ( bytes32 _swapID ) external view returns ( bool ) { return ( swapStates [ _swapID ] == States . OPEN ) ; }
","Checks whether a swap is redeemable or not .
"
"function removeEmissionProvider ( address _provider , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _provider ) , _block ) ; if ( OK != _code ) { return _code ; } uint _idx = emissionProvider2index [ _provider ] ; uint _lastIdx = emissionProvidersCount ; if ( _idx != 0 ) { if ( _idx != _lastIdx ) { address _lastEmissionProvider = index2emissionProvider [ _lastIdx ] ; index2emissionProvider [ _idx ] = _lastEmissionProvider ; emissionProvider2index [ _lastEmissionProvider ] = _idx ; } delete emissionProvider2index [ _provider ] ; delete index2emissionProvider [ _lastIdx ] ; delete emissionProviders [ _provider ] ; emissionProvidersCount = _lastIdx - 1 ; } return OK ; }
","Remove emission provider
"
"function setTimes ( uint256 _startTime , uint256 _endTime ) public onlyOwner beforeSale { require ( _startTime > now && _startTime < _endTime ) ; startTime = _startTime ; endTime = _endTime ; }
","Sets crowdsale start and end time
"
"function createNewProject ( uint uuid , uint amount , address projectPayee ) public onlyCurator sufficientDevFundBalance ( amount ) { communityAccount . setEscrowedProjectBalances ( uuid , amount ) ; communityAccount . setEscrowedProjectPayees ( uuid , projectPayee ) ; communityAccount . setTotalProjectEscrow ( SafeMath . add ( communityAccount . totalProjectEscrow ( ) , amount ) ) ; logger . emitProjectCreated ( uuid , amount , projectPayee ) ; logger . emitGenericLog ( ""createNewProject"" , """" ) ; }
","updates the escrow values along with the project payee for a new project
"
"function checkCompletedCrowdsale ( ) public whenNotPaused { if ( ! isEnded ) { if ( hasEnded ( ) && ! goalReached ( ) ) { vault . enableRefunds ( ) ; isRefunding = true ; isEnded = true ; Finalized ( ) ; } else if ( hasEnded ( ) && goalReached ( ) ) { vault . close ( ) ; isEnded = true ; Finalized ( ) ; } } }
","Check if the crowdsale has ended and enables refunds only in case the goal has n't been reached
"
"function getInvestors ( ) external view returns ( address [ ] ) { return investorData . investors ; }
","returns an array of investors NB - this length may differ from investorCount as it contains all investors that ever held tokens
"
"function freezeAccount ( address target , bool freeze ) onlyOwner { require ( freeze ) ; frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }
","Freeze the account at the target address
"
"function _addSale ( uint256 _tokenId , Sale _sale ) internal { require ( _sale . duration >= 1 minutes ) ; tokenIdToSale [ _tokenId ] = _sale ; emit SaleCreated ( uint256 ( _tokenId ) , uint256 ( _sale . startingPrice ) , uint256 ( _sale . endingPrice ) , uint256 ( _sale . duration ) , uint256 ( _sale . startedAt ) ) ; }
","Adds an sale to the list of open sales .
"
"function compareLowerBound ( uint8 [ ] _version1 , uint8 [ ] _version2 ) internal pure returns ( bool ) { require ( _version1 . length == _version2 . length , ""Input length mismatch"" ) ; uint counter = 0 ; for ( uint8 j = 0 ; j < _version1 . length ; j ++ ) { if ( _version1 [ j ] == 0 ) counter ++ ; } if ( counter != _version1 . length ) { counter = 0 ; for ( uint8 i = 0 ; i < _version1 . length ; i ++ ) { if ( _version2 [ i ] > _version1 [ i ] ) return true ; else if ( _version2 [ i ] < _version1 [ i ] ) return false ; else counter ++ ; } if ( counter == _version1 . length - 1 ) return true ; else return false ; } else return true ; }
","Used to compare the lower bound with the latest version
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } return false ; }
","Set allowance for other address and notify
"
"function participantWithdrawIfMinimumFundingNotReached ( uint256 value ) external { require ( now >= PRESALE_END_DATE ) ; require ( totalFunding <= PRESALE_MINIMUM_FUNDING ) ; assert ( balanceOf [ msg . sender ] < value ) ; balanceOf [ msg . sender ] = safeDecrement ( balanceOf [ msg . sender ] , value ) ; msg . sender . transfer ( value ) ; }
","The participant will need to withdraw their funds from this contract if the presale has not achieved the minimum funding level
"
"function finishDistribution ( ) onlyOwner public { token . finishMinting ( ) ; token . setTransferEnabled ( true ) ; token . transferOwnership ( owner ) ; }
","Finish token minting , enable transfers and transfer token ownership
"
"function orderConfirmer ( bytes32 _orderID ) external view returns ( address ) { return orders [ _orderID ] . confirmer ; }
","returns the darknode address which confirms the given orderID .
"
"function claimToken ( ) onlyOwner public { token . transferOwnership ( owner ) ; }
","Transfers token ownership to this contract owner
"
"function unlockTokens ( ) public { require ( contractManager . authorize ( contractName , msg . sender ) ) ; BasicToken . unlockTokens ( ) ; }
","Unlock tokens , hereafter they will be tradable
"
"function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) , ""Invalid address"" ) ; IERC20 token = IERC20 ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( owner ( ) , balance ) , ""Transfer failed"" ) ; }
","Reclaims all ERC20Basic compatible tokens
"
"function burnPermissionManager ( address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermissionManager ( BURN_ENTITY , _app , _role ) ; }
","Burn ` _role ` in ` _app ` , so no modification can be made to it ( grant , revoke , permission manager )
"
"function setApprovalForAll ( address _operator , bool _approved ) external { require ( _operator != msg . sender ) ; _operatorApprovals [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
","Enable or disable approval for a third party ( `` operator '' ) to manage
"
"function getEndDateOfCampaign ( bytes32 bidId ) public view returns ( uint endDate ) { return advertisementStorage . getCampaignEndDateById ( bidId ) ; }
","Get the end date of a campaign Based on the Campaign id return the value ( in miliseconds ) corresponding to the end Date of the campaign .
"
"function setTrading ( bool _trading ) external returns ( bool ) ;
","Will set trading state to ` _trading `
"
"function setCrowdsaleTransfer ( address _sale , uint256 _amount ) public onlyOwner { require ( _sale != address ( 0 ) && ! isCrowdsaleOpen ( ) && address ( ethealToken ) != address ( 0 ) ) ; crowdsale = Crowdsale ( _sale ) ; require ( ethealToken . transferFrom ( SALE , _sale , _amount ) ) ; }
","Set crowdsale address and transfer HEAL tokens from ethealController 's SALE address
"
"function unlock ( ) external { if ( now < unlockedAt ) throw ; if ( tokensCreated == 0 ) tokensCreated = obg . balanceOf ( this ) ; var allocation = allocations [ msg . sender ] ; allocations [ msg . sender ] = 0 ; var toTransfer = tokensCreated * allocation / totalAllocations ; if ( ! obg . transfer ( msg . sender , toTransfer ) ) throw ; }
","Allow developer to unlock allocated tokens by transferring them from OBGAllocation to developer 's address .
"
"function getTokenAllowance ( Data storage self , string currency , address account , address spender ) internal view returns ( uint allowance ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.allowance' , currency , getForwardedAccount ( self , account ) , getForwardedAccount ( self , spender ) ) ) ; return self . Storage . getUint ( id ) ; }
","Get the token spender allowance for a given account
"
"function ( ) external payable { require ( false ) ; }
","No tipping !
"
"function defaultOperators ( ) public view returns ( address [ ] ) { return mDefaultOperators ; }
","Return the list of default operators
"
"function setAccountSpendingLimit ( Data storage self , address account , uint limit ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.spending.limit' , account ) ) ; require ( self . Storage . setUint ( id , limit ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set the account spending limit amount
"
"function calculateRewardToWithdraw ( uint32 _canvasId , address _address ) public view stateOwned ( _canvasId ) returns ( uint reward , uint pixelsOwned ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; uint _lastPaidIndex = _history . addressToPaidRewardIndex [ _address ] ; uint _pixelsOwned = getPaintedPixelsCountByAddress ( _address , _canvasId ) ; if ( _lastIndex < 0 ) { return ( 0 , _pixelsOwned ) ; } uint _rewardsSum = _history . rewardsCumulative [ _lastIndex ] ; uint _lastWithdrawn = _history . rewardsCumulative [ _lastPaidIndex ] ; uint _toWithdraw = ( ( _rewardsSum - _lastWithdrawn ) / PIXEL_COUNT ) * _pixelsOwned ; return ( _toWithdraw , _pixelsOwned ) ; }
","Calculates unpaid rewards of a given address .
"
"function redeem ( bytes32 _swapID , bytes32 _secretKey ) external onlyOpenSwaps ( _swapID ) onlyWithSecretKey ( _swapID , _secretKey ) { Swap memory swap = swaps [ _swapID ] ; swaps [ _swapID ] . secretKey = _secretKey ; swapStates [ _swapID ] = States . CLOSED ; redeemedAt [ _swapID ] = now ; swap . withdrawTrader . transfer ( swap . value ) ; emit LogClose ( _swapID , _secretKey ) ; }
","Redeems an atomic swap .
"
"function unitBattleEthCost ( uint256 cardId ) external constant returns ( uint256 ) { return battlecardInfo [ cardId ] . ethCost ; }
","get the battle card 's ether cost
"
"function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) ;
","Query if an address is an authorized operator for another address
"
"function successful ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; require ( tokenReward . transfer ( beneficiary , remanent ) ) ; beneficiary . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
","successful closure handler
"
"function calculateTokensTier ( uint256 weiPaid , uint256 tierSelected ) internal constant returns ( uint256 calculatedTokens ) { require ( weiPaid > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; if ( tierSelected == 1 ) calculatedTokens = weiPaid . mul ( rate ) ; else if ( tierSelected == 2 ) calculatedTokens = weiPaid . mul ( rateTier2 ) ; else if ( tierSelected == 3 ) calculatedTokens = weiPaid . mul ( rateTier3 ) ; else calculatedTokens = weiPaid . mul ( rateTier4 ) ; }
","Buys the tokens given the price of the tier one and the wei paid
"
"function destroyTokens ( address _owner , uint _amount ) public returns ( bool ) ;
","Burns ` _amount ` tokens from ` _owner `
"
"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer || operators [ loan . lender ] [ msg . sender ] ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }
","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .
"
"function balanceOf ( address _person ) constant returns ( uint256 balance ) { return balances [ _person ] ; }
","Used to look up balance of a user
"
"function refundForValidPartners ( uint _to ) ;
","Function to refund for valid partners before the closing time
"
"function withdrawVestedTokens ( uint256 _vestIndex ) public activeVester validIndex ( _vestIndex ) unclaimedVest ( _vestIndex ) pastClaimDate ( _vestIndex ) returns ( bool ) { if ( _vestIndex == vests [ msg . sender ] . releaseAmounts . length . sub ( 1 ) ) { bool check ; for ( uint256 i = 0 ; i < vests [ msg . sender ] . releaseAmounts . length ; i ++ ) { if ( ! vests [ msg . sender ] . claimed [ i ] ) { check = false ; break ; } check = true ; } require ( check , ""not all vests have been withdrawn before attempting to withdraw final vest"" ) ; vests [ msg . sender ] . state = VestState . vested ; } vests [ msg . sender ] . claimed [ _vestIndex ] = true ; uint256 amount = vests [ msg . sender ] . releaseAmounts [ _vestIndex ] ; require ( RTI . transfer ( msg . sender , amount ) , ""failed to transfer"" ) ; return true ; }
","IF YOU ARE WITHDRAWING THE LAST VEST ( LAST INDEX ) YOU MUST HAVE WITHDRAWN ALL OTHER VESTS FIRST OR THE TX WILL FAIL
"
"function getInstructions ( ) external view returns ( string ) ;
","Returns the instructions associated with the module
"
"function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; require ( creator . send ( address ( this ) . balance ) ) ; tokenReward . transfer ( creator , remanent ) ; emit LogBeneficiaryPaid ( creator ) ; emit LogContributorsPayout ( creator , remanent ) ; }
","closure handler
"
"function requestReturn ( address _returnAddr ) { require ( now <= endDate ) ; require ( returnAddresses [ msg . sender ] == 0x0 ) ; returnAddresses [ msg . sender ] = _returnAddr ; ReturnRequested ( msg . sender , _returnAddr ) ; }
","This function is used to choose an address for returning the funds .
"
"function claimWinnings ( bytes32 question_id , bytes32 [ ] history_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) stateFinalized ( question_id ) public { require ( history_hashes . length > 0 , ""at least one history hash entry must be provided"" ) ; address payee = question_claims [ question_id ] . payee ; uint256 last_bond = question_claims [ question_id ] . last_bond ; uint256 queued_funds = question_claims [ question_id ] . queued_funds ; bytes32 last_history_hash = questions [ question_id ] . history_hash ; bytes32 best_answer = questions [ question_id ] . best_answer ; uint256 i ; for ( i = 0 ; i < history_hashes . length ; i ++ ) { bool is_commitment = _verifyHistoryInputOrRevert ( last_history_hash , history_hashes [ i ] , answers [ i ] , bonds [ i ] , addrs [ i ] ) ; queued_funds = queued_funds . add ( last_bond ) ; ( queued_funds , payee ) = _processHistoryItem ( question_id , best_answer , queued_funds , payee , addrs [ i ] , bonds [ i ] , answers [ i ] , is_commitment ) ; last_bond = bonds [ i ] ; last_history_hash = history_hashes [ i ] ; } if ( last_history_hash != NULL_HASH ) { if ( payee != NULL_ADDRESS ) { _payPayee ( question_id , payee , queued_funds ) ; queued_funds = 0 ; } question_claims [ question_id ] . payee = payee ; question_claims [ question_id ] . last_bond = last_bond ; question_claims [ question_id ] . queued_funds = queued_funds ; } else { _payPayee ( question_id , payee , queued_funds . add ( last_bond ) ) ; delete question_claims [ question_id ] ; } questions [ question_id ] . history_hash = last_history_hash ; }
","Assigns the winnings ( bounty and bonds ) to everyone who gave the accepted answer Caller must provide the answer history , in reverse order
"
"function setOfferSize ( uint256 quantity ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; require ( quantity > 0 , ""Size must be greater than zero, change rejected."" ) ; uint256 balance = ERC20Interface ( tokenContract ) . balanceOf ( msg . sender ) ; require ( balance >= quantity , ""Not enough tokens owned to complete the order change."" ) ; uint256 allowed = ERC20Interface ( tokenContract ) . allowance ( msg . sender , this ) ; require ( allowed >= quantity , ""You must approve the transfer of tokens before offering them for sale."" ) ; TradeOrder memory order = orderBook [ msg . sender ] ; order . quantity = quantity ; orderBook [ msg . sender ] = order ; emit TokenOfferChanged ( msg . sender , quantity , order . price , order . expiry ) ; }
","Change the number of VOX Tokens offered by this user .
"
"function removeUserContractFrom ( address _contract , address _from ) external auth returns ( uint ) { if ( ! _removeUserContract ( _contract , _from ) ) { return _emitErrorCode ( USER_REGISTRY_NO_USER_CONTRACT_FOUND ) ; } _emitter ( ) . emitUserContractRemoved ( _contract , _from ) ; return OK ; }
","Removes a contract from provided user association .
"
"function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool transferred ) { require ( allowed [ _owner ] [ msg . sender ] >= _amount ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; allowed [ _owner ] [ msg . sender ] = allowed [ _owner ] [ msg . sender ] . sub ( _amount ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }
","Used to transfer funds on behalf of someone
"
"function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool success ) { require ( allowance [ _owner ] [ msg . sender ] >= _amount ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; allowance [ _owner ] [ msg . sender ] = allowance [ _owner ] [ msg . sender ] . sub ( _amount ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }
","Used to transfer funds on behalf of owner to receiver
"
"function _init ( uint40 _panicDelayInSeconds , uint40 _pendingDelayInSeconds ) returns ( bool ) ;
","This will set the panic and pending periods .
"
"function getTokenList ( address _owner , uint8 _withAttributes , uint256 start , uint256 count ) external view returns ( uint256 [ 6 ] [ ] ) { uint256 totalAssets = assets . length ; if ( totalAssets == 0 ) { return new uint256 [ 6 ] [ ] ( 0 ) ; } else { uint256 [ 6 ] [ ] memory result = new uint256 [ 6 ] [ ] ( totalAssets > count ? count : totalAssets ) ; uint256 resultIndex = 0 ; bytes2 hasAttributes = bytes2 ( _withAttributes ) ; Asset memory asset ; for ( uint256 tokenId = start ; tokenId < totalAssets && resultIndex < count ; tokenId ++ ) { asset = assets [ tokenId ] ; if ( ( asset . state != uint8 ( AssetState . Used ) ) && ( assetIndexToOwner [ tokenId ] == _owner || _owner == address ( 0 ) ) && ( asset . attributes & hasAttributes == hasAttributes ) ) { result [ resultIndex ] [ 0 ] = tokenId ; result [ resultIndex ] [ 1 ] = asset . ID ; result [ resultIndex ] [ 2 ] = asset . category ; result [ resultIndex ] [ 3 ] = uint256 ( asset . attributes ) ; result [ resultIndex ] [ 4 ] = asset . cooldown ; result [ resultIndex ] [ 5 ] = assetIndexToPrice [ tokenId ] ; resultIndex ++ ; } } return result ; } }
","List all existing tokens .
"
"function isWhitelisted ( address _address ) public view returns ( bool ) { return whitelist [ _address ] ; }
","Checks if the specified address is whitelisted .
"
"function getAccountSpendingLimit ( Data storage self , address account ) internal view returns ( uint limit ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.spending.limit' , account ) ) ; return self . Storage . getUint ( id ) ; }
","Get the account spending limit amount
"
"function reclaimDividend ( uint256 _dividendIndex ) external withPerm ( MANAGE ) { require ( _dividendIndex < dividends . length , ""Invalid dividend"" ) ; require ( now >= dividends [ _dividendIndex ] . expiry , ""Dividend expiry in future"" ) ; require ( ! dividends [ _dividendIndex ] . reclaimed , ""already claimed"" ) ; dividends [ _dividendIndex ] . reclaimed = true ; Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 remainingAmount = dividend . amount . sub ( dividend . claimedAmount ) ; address owner = IOwnable ( securityToken ) . owner ( ) ; require ( IERC20 ( dividendTokens [ _dividendIndex ] ) . transfer ( owner , remainingAmount ) , ""transfer failed"" ) ; emit ERC20DividendReclaimed ( owner , _dividendIndex , dividendTokens [ _dividendIndex ] , remainingAmount ) ; }
","Issuer can reclaim remaining unclaimed dividend amounts , for expired dividends
"
"function currentMigrationTarget ( ) public constant returns ( IMigrationTarget ) ;
","returns current migration target
"
"function getMaximumFunds ( ) internal constant returns ( uint ) { return euroCents2wei ( getMaximumFundsInEuroCents ( ) ) ; }
","maximum investments to be accepted during the sale ( in wei )
"
"function transfer ( address to , uint value ) returns ( bool success ) { require ( balances [ msg . sender ] >= value && value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; return true ; }
","Transfer tokens to the beneficiary account
"
"function refund ( ) public isUserRefundable userHasFundedPool ( msg . sender ) { processRefundInternal ( msg . sender ) ; }
","Process a refund .
"
"function purchase ( address _to , uint64 _pixelconIndex ) public payable validAddress ( _to ) { Listing storage listing = marketPixelconListings [ _pixelconIndex ] ; require ( systemLock != LOCK_REMOVE_ONLY , ""Market is currently locked"" ) ; require ( listing . seller != address ( 0 ) , ""Market listing does not exist"" ) ; require ( listing . seller != msg . sender , ""Seller cannot purchase their own listing"" ) ; uint256 currPrice = calcCurrentPrice ( uint256 ( listing . startAmount ) , uint256 ( listing . endAmount ) , uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; require ( currPrice != uint256 ( 0 ) , ""Market listing has expired"" ) ; require ( msg . value >= currPrice + ( currPrice * uint256 ( devFee ) ) / FEE_RATIO , ""Insufficient value sent"" ) ; uint256 tokenId = pixelconsContract . tokenByIndex ( _pixelconIndex ) ; address seller = listing . seller ; clearListingData ( seller , _pixelconIndex ) ; pixelconsContract . transferFrom ( address ( this ) , _to , tokenId ) ; seller . transfer ( currPrice ) ; emit Purchase ( _pixelconIndex , msg . sender , currPrice ) ; }
","Purchase PixelCon # ` ( _pixelconIndex ) ` to address ` ( _to ) `
"
"function canSettle ( bytes32 channelId ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isWaitingOver = isSettling ( channelId ) && block . number >= channel . settlingUntil ; return isSettling ( channelId ) && isWaitingOver ; }
","Ensure one can settle the channel identified by ` channelId ` .
"
"function transferFrom ( address from , address to , uint quantity ) public pausableIfNotSelfDestructing returns ( bool ) { allowance [ from ] [ msg . sender ] = safeSub ( allowance [ from ] [ msg . sender ] , quantity ) ; return _transfer ( from , to , quantity ) ; }
","ERC20 transferFrom function ; transfers ` quantity ` tokens from ` from ` to ` to ` if the sender is approved .
"
"function takeOwnership ( uint256 _index ) public returns ( bool ) { return transfer ( msg . sender , _index ) ; }
","Transfers the loan to the msg.sender , the msg.sender must be approved using the `` approve '' method .
"
"function removeAdmin ( address _address ) external onlyAdmin returns ( bool ) { require ( _address != address ( 0 ) , ""Invalid address."" ) ; require ( admins [ _address ] , ""This address isn't an administrator."" ) ; require ( _address != owner , ""The owner cannot be added or removed to or from the administrator list."" ) ; admins [ _address ] = false ; emit AdminRemoved ( _address ) ; return true ; }
","Removes the specified address from the list of administrators .
"
"function decimals ( ) public view returns ( uint8 ) { return chronoBankPlatform . baseUnit ( smbl ) ; }
","Returns asset decimals .
"
"function balanceOf ( address _owner ) external view returns ( uint256 ) ;
","Count all NFTs assigned to an owner
"
"function destroy ( ) onlyOwner public { selfdestruct ( owner ) ; }
","The called token contracts could try to re-enter this contract .
"
"function _updatePurchasingState ( address , uint256 ) internal pure { }
","Overrides for extensions that require an internal state to check for validity ( current user contributions , etc . )
"
"function refund ( ) minCapNotReached salePeriodCompleted isValidState external { require ( msg . sender != shitFundAddress ) ; uint256 shitVal = balances [ msg . sender ] ; require ( shitVal > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( shitVal ) ; assignedSupply = assignedSupply . sub ( shitVal ) ; uint256 ethVal = shitVal . div ( tokenExchangeRate ) ; msg . sender . transfer ( ethVal ) ; RefundSent ( msg . sender , ethVal ) ; }
","Allows contributors to recover their ETH in the case of a failed token sale
"
"function owner ( ) public view returns ( address ) { return getAddress ( OWNER ) ; }
","Gets the owner of the contract
"
"function changeOwner ( address _newOwner ) onlyOwner { if ( msg . sender == owner ) { owner = _newOwner ; } }
","` owner ` can step down and assign some other address to this role
"
"function _setMarketInterestRateModel ( address asset , InterestRateModel interestRateModel ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK ) ; } markets [ asset ] . interestRateModel = interestRateModel ; emit SetMarketInterestRateModel ( asset , interestRateModel ) ; return uint ( Error . NO_ERROR ) ; }
","Sets the interest rate model for a given market
"
"function newChannel ( address partner , uint settle_timeout ) returns ( address ) { address old_channel = getChannelWith ( partner ) ; if ( old_channel != 0 ) { ChannelDeleted ( msg . sender , partner ) ; } address new_channel = data . newChannel ( partner , settle_timeout ) ; ChannelNew ( new_channel , msg . sender , partner , settle_timeout ) ; return new_channel ; }
","Create a new payment channel between two parties
"
"function generateRequestId ( ) internal returns ( bytes32 ) { numRequests = numRequests . add ( 1 ) ; return bytes32 ( ( uint256 ( this ) << 96 ) . add ( numRequests ) ) ; }
","Generates a new unique requestId .
"
"function setAssetValue ( uint64 _value ) public onlyOwner { uint64 oldValue = assetValue ; assetValue = _value ; emit AssetValue ( oldValue , _value ) ; }
","Not for public use !
"
"function setWalletAddress ( address _walletAddress ) public onlyWalletAddr { walletAddress = _walletAddress ; }
","only wallet address can set new wallet address
"
"function setMaximumClaimPriceWei ( uint _maximumClaimPriceWei ) { externalEnter ( ) ; setMaximumClaimPriceWeiRP ( _maximumClaimPriceWei ) ; externalLeave ( ) ; }
","Used by topWizard to vary the cap on claim price .
"
"function removeAddressFromAccount ( address _addressToRemove ) external onlyAccountRegistryLogic { delete accountByAddress [ _addressToRemove ] ; }
","Remove an address from an id
"
"function query ( address provider , string userQuery , bytes32 endpoint , bytes32 [ ] endpointParams ) external returns ( uint256 id ) { uint256 dots = bondage . getBoundDots ( msg . sender , provider , endpoint ) ; bool onchainProvider = isContract ( provider ) ; bool onchainSubscriber = isContract ( msg . sender ) ; if ( dots >= 1 ) { bondage . escrowDots ( msg . sender , provider , endpoint , 1 ) ; id = uint256 ( keccak256 ( abi . encodePacked ( block . number , now , userQuery , msg . sender , provider ) ) ) ; createQuery ( id , provider , msg . sender , endpoint , userQuery , onchainSubscriber ) ; if ( onchainProvider ) { OnChainProvider ( provider ) . receive ( id , userQuery , endpoint , endpointParams , onchainSubscriber ) ; } else { emit Incoming ( id , provider , msg . sender , userQuery , endpoint , endpointParams , onchainSubscriber ) ; } } else { revert ( ""Subscriber does not have any dots."" ) ; } }
","Escrow dot for oracle request
"
"function depositSynths ( uint amount ) external { synth . transferFrom ( msg . sender , this , amount ) ; }
","depositSynths : Allows users to deposit synths via the approve / transferFrom workflow if they 'd like .
"
"function approve ( address _spender , uint256 _value ) notPendingWithdrawal returns ( bool success ) { if ( ( _value != 0 ) && ( allowance [ msg . sender ] [ _spender ] != 0 ) ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownerAnimecardCount [ _owner ] ; }
","Required for ERC-20 and ERC-721 compliance .
"
"function getPledgeAdmin ( uint64 idAdmin ) constant returns ( PledgeAdminType adminType , address addr , string name , string url , uint64 commitTime , uint64 parentProject , bool canceled , address plugin ) { PledgeAdmin storage m = findAdmin ( idAdmin ) ; adminType = m . adminType ; addr = m . addr ; name = m . name ; url = m . url ; commitTime = m . commitTime ; parentProject = m . parentProject ; canceled = m . canceled ; plugin = address ( m . plugin ) ; }
","A constant getter to check the details of a specified Admin
"
"function STARTMETADOLLAR ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1000000000000000000 * 1000000000000000000 ether ; preICOprice = 1000000000000000000 * 1000000000000000000 ether ; ICOprice = 1000000000000000000 * 1000000000000000000 ether ; sellPrice = 900000000000000000 ; buyCommission = 0 ; sellCommission = 0 ; updatePrices ( ) ; }
","Constructor of the contract
"
"function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) internal whenNotPaused { requireMultiple ( _amount ) ; uint balanceAvailable = getAmountOfUnlockedTokens ( _tokenHolder ) ; require ( balanceAvailable >= _amount , ""You can only burn tokens when you have a balance grater than or equal to the amount specified"" ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; callSender ( _operator , _tokenHolder , 0x0 , _amount , _holderData , _operatorData ) ; emit Burned ( _operator , _tokenHolder , _amount , _holderData , _operatorData ) ; }
","Helper function actually performing the burning of tokens .
"
"function approveAndCall ( address _spender , uint256 _value , bytes _data ) public returns ( bool ) ;
","Approve the passed address to spend the specified amount of tokens on behalf of msg.sender and then call ` onApprovalReceived ` on spender Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering .
"
"function unpause ( ) public onlyOwner whenPaused { require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function resultFor ( bytes32 question_id ) stateFinalized ( question_id ) external view returns ( bytes32 ) { return questions [ question_id ] . best_answer ; }
","Return the final answer to the specified question , or revert if there is n't one
"
"function transferFrom ( address from , address to , uint value ) returns ( bool success ) { require ( allowance [ from ] [ msg . sender ] >= value && balances [ from ] >= value && value > 0 && ( ! frozenAccount [ msg . sender ] ) ) ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowance [ from ] [ msg . sender ] = allowance [ from ] [ msg . sender ] . sub ( value ) ; Transfer ( from , to , value ) ; return true ; }
","Transfer tokens between accounts
"
"function initialize ( ) public onlyInit { initialized ( ) ; versionsNextIndex = 1 ; }
","Initializes a Repo to be usable
"
"function setNewController ( address _controller ) public onlyEthealMultisig { require ( _controller != address ( 0 ) && newController == address ( 0 ) ) ; newController = TokenController ( _controller ) ; ethealToken . changeController ( _controller ) ; hodlerReward . transferOwnership ( _controller ) ; uint256 _stake = this . balance ; if ( _stake > 0 ) { _controller . transfer ( _stake ) ; } _stake = ethealToken . balanceOf ( this ) ; if ( _stake > 0 ) { ethealToken . transfer ( _controller , _stake ) ; } }
","replaces controller when it was not yet replaced , only multisig can do it
"
"function ownerOf ( uint256 _cutieId ) external view canBeStoredIn40Bits ( _cutieId ) returns ( address owner ) { owner = cutieIndexToOwner [ uint40 ( _cutieId ) ] ; require ( owner != address ( 0 ) ) ; }
","Returns the address currently assigned ownership of a given Cutie .
"
"function getInstructions ( ) external view returns ( string ) { return ""Add and remove permissions for the SecurityToken and associated modules. Permission types should be encoded as bytes32 values and attached using withPerm modifier to relevant functions. No initFunction required."" ; }
","Returns the instructions associated with the module
"
"function bytes32ToString ( bytes32 _source ) internal pure returns ( string result ) { bytes memory bytesString = new bytes ( 32 ) ; uint charCount = 0 ; for ( uint j = 0 ; j < 32 ; j ++ ) { byte char = byte ( bytes32 ( uint ( _source ) * 2 ** ( 8 * j ) ) ) ; if ( char != 0 ) { bytesString [ charCount ] = char ; charCount ++ ; } } bytes memory bytesStringTrimmed = new bytes ( charCount ) ; for ( j = 0 ; j < charCount ; j ++ ) { bytesStringTrimmed [ j ] = bytesString [ j ] ; } return string ( bytesStringTrimmed ) ; }
","Changes the bytes32 into string
"
"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status != Status . destroyed && loan . status != Status . paid ) ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }
","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .
"
"function addVestingSchedule ( address account , uint [ ] times , uint [ ] quantities ) external onlyOwner onlyDuringSetup { for ( uint i = 0 ; i < times . length ; i ++ ) { appendVestingEntry ( account , times [ i ] , quantities [ i ] ) ; } }
","Construct a vesting schedule to release a quantities of SNX over a series of intervals .
"
"function _escrow ( address _owner , uint256 _tokenId ) internal { nonFungibleContract . safeTransferFrom ( _owner , this , _tokenId ) ; }
","Escrows the ERC721 Token , assigning ownership to this contract .
"
"function rescindApproval ( address _spender ) external { require ( approvedSpenders [ msg . sender ] [ _spender ] , ""Spender has not been approved"" ) ; require ( whitelistedSpenders [ _spender ] != true , ""Spender must be removed from the whitelist"" ) ; delete approvedSpenders [ msg . sender ] [ _spender ] ; emit SpenderRescind ( msg . sender , _spender ) ; }
","Rescinds a previous approval for spending the ` msg.sender ` 's contract balance .
"
"function changeBeneficiary ( address target ) onlyBeneficiary public { require ( target != 0 ) ; beneficiary = target ; }
","Allow the beneficiary to change its address
"
"function processSeason ( uint32 _season ) public onlyCOO { uint64 fightTime = matchTime [ _season ] ; require ( now >= fightTime && fightTime > 0 ) ; uint sumFund = 0 ; uint sumSeed = 0 ; ( sumFund , sumSeed ) = _getFightData ( _season ) ; if ( sumFund == 0 ) { finished [ _season ] = 110 ; doLogFighter ( _season , 0 , 0 ) ; emit SeasonNone ( _season ) ; emit LogMatch ( _season , sumFund , fightTime , sumSeed , 0 , 0 , 0 , false ) ; } else { uint8 champion = _localFight ( _season , uint32 ( sumSeed ) ) ; uint percentile = safeDiv ( sumFund , 100 ) ; uint devCut = percentile * 4 ; uint partnerCut = percentile * 5 ; uint fighterCut = percentile * 1 ; uint bonusWinner = percentile * 80 ; _bonusToPartners ( partnerCut ) ; _bonusToFighters ( _season , champion , fighterCut ) ; bool isRefound = _bonusToBettor ( _season , champion , bonusWinner ) ; _addMoney ( cfoAddress , devCut ) ; uint key = _season * 1000 + champion ; Fighter storage soldier = soldiers [ key ] ; doLogFighter ( _season , key , fighterCut ) ; emit SeasonWinner ( _season , champion ) ; emit LogMatch ( _season , sumFund , fightTime , sumSeed , key , soldier . hometown , soldier . tokenID , isRefound ) ; } clearTheSeason ( _season ) ; }
","process a combat , it is expencive , so provide enough gas
"
"function transfer ( address _to , uint _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` from ` msg.sender `
"
"function transferManyLands ( uint256 estateId , uint256 [ ] landIds , address destinatary ) external canTransfer ( estateId ) { uint length = landIds . length ; for ( uint i = 0 ; i < length ; i ++ ) { _transferLand ( estateId , landIds [ i ] , destinatary ) ; } }
","Transfer many tokens owned by an Estate to a new owner
"
"function depositCollateral ( address token , uint amount ) public { require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( amount == getAcceptedTokenAmount ( token ) ) ; require ( isValid ( token ) ) ; tokens [ token ] [ msg . sender ] = tokens [ token ] [ msg . sender ] . add ( amount ) ; require ( StandardToken ( token ) . transferFrom ( msg . sender , this , amount ) , ""error with token"" ) ; emit Deposit ( token , msg . sender , amount , tokens [ token ] [ msg . sender ] ) ; DataVault . _externalAddMasternode ( msg . sender ) ; }
","Public function that allows any user to deposit accepted tokens as collateral to become a masternode .
"
"function transferRoot ( address _newOwner ) external onlyOwner returns ( bool ) { owner = _newOwner ; return true ; }
","Change database owner
"
"function lock ( address investor , uint112 amount , uint112 neumarks , uint32 unlockDate ) private acceptAgreement ( investor ) { require ( amount > 0 ) ; Account storage account = _accounts [ investor ] ; if ( account . unlockDate == 0 ) { _totalInvestors += 1 ; } account . balance = addBalance ( account . balance , amount ) ; account . neumarksDue = add112 ( account . neumarksDue , neumarks ) ; if ( unlockDate > account . unlockDate ) { account . unlockDate = unlockDate ; } emit LogFundsLocked ( investor , amount , neumarks ) ; }
","locks funds of investors for a period of time , called by migration
"
"function approve ( address _approved , uint256 _tokenId ) external payable { require ( msg . sender == _ownerOf ( _tokenId ) ) ; require ( msg . sender != _approved ) ; if ( _getApproved ( _tokenId ) != address ( 0 ) || _approved != address ( 0 ) ) { _approve ( _approved , _tokenId ) ; Approval ( msg . sender , _approved , _tokenId ) ; } }
","Set or reaffirm the approved address for an NFT
"
"function finalizeCrowdsale ( ) public onlyOwner { finalized = true ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( tokensSold >= goal && address ( this ) . balance > 0 ) { owner . transfer ( address ( this ) . balance ) ; } }
","Closes crowdsale , finishes minting ( allowing token transfers ) , transfers token ownership to the owner
"
"function feesByPeriod ( address account ) public view returns ( uint [ FEE_PERIOD_LENGTH ] ) { uint [ FEE_PERIOD_LENGTH ] memory result ; uint initialDebtOwnership ; uint debtEntryIndex ; ( initialDebtOwnership , debtEntryIndex ) = synthetix . synthetixState ( ) . issuanceData ( account ) ; if ( initialDebtOwnership == 0 ) return result ; uint totalSynths = synthetix . totalIssuedSynths ( ""XDR"" ) ; if ( totalSynths == 0 ) return result ; uint debtBalance = synthetix . debtBalanceOf ( account , ""XDR"" ) ; uint userOwnershipPercentage = debtBalance . divideDecimal ( totalSynths ) ; uint penalty = currentPenalty ( account ) ; for ( uint i = 0 ; i < FEE_PERIOD_LENGTH ; i ++ ) { if ( recentFeePeriods [ i ] . startingDebtIndex > debtEntryIndex && lastFeeWithdrawal [ account ] < recentFeePeriods [ i ] . feePeriodId ) { uint feesFromPeriodWithoutPenalty = recentFeePeriods [ i ] . feesToDistribute . multiplyDecimal ( userOwnershipPercentage ) ; uint penaltyFromPeriod = feesFromPeriodWithoutPenalty . multiplyDecimal ( penalty ) ; uint feesFromPeriod = feesFromPeriodWithoutPenalty . sub ( penaltyFromPeriod ) ; result [ i ] = feesFromPeriod ; } } return result ; }
","Calculates fees by period for an account , priced in XDRs
"
"function isRegisteredFirm ( string firmName ) public view returns ( bool status ) { return lib . isRegisteredFirm ( firmName ) ; }
","Gets status of firm registration
"
"function getReferencePriceInfo ( address ofBase , address ofQuote ) view returns ( bool isRecent , uint referencePrice , uint decimal ) { if ( getQuoteAsset ( ) == ofQuote ) { ( isRecent , referencePrice , decimal ) = getPriceInfo ( ofBase ) ; } else if ( getQuoteAsset ( ) == ofBase ) { ( isRecent , referencePrice , decimal ) = getInvertedPriceInfo ( ofQuote ) ; } else { revert ( ) ; } }
","Gets reference price of an asset pair
"
"function getReputationByFactory ( address _factoryAddress ) external view returns ( address [ ] ) { return getArrayAddress ( Encoder . getKey ( ""reputation"" , _factoryAddress ) ) ; }
","Returns the reputation of the entered Module Factory
"
"function setOpsAddress ( address _opsAddress ) external onlyOwner returns ( bool ) { require ( _opsAddress != owner ) ; require ( _opsAddress != address ( this ) ) ; require ( _opsAddress != address ( 0 ) ) ; opsAddress = _opsAddress ; return true ; }
","Owner can change the verified operator address .
"
"function _release ( ) internal { uint length = min ( transferAddresses . length , transferredIndex + MAX_TRANSFER ) ; uint i = transferredIndex ; if ( isCapped ) { for ( ; i < length ; i ++ ) { address ad = transferAddresses [ i ] ; uint b = balances [ ad ] ; if ( b == 0 ) { continue ; } balances [ ad ] = 0 ; parent . transfer ( ad , b ) ; } } else { uint unsold = getUnsoldToken ( ) ; uint sold = totalSupply_ . sub ( unsold ) ; if ( sold <= 0 ) { return ; } for ( ; i < length ; i ++ ) { ad = transferAddresses [ i ] ; b = balances [ ad ] ; if ( b == 0 ) { continue ; } b = b . add ( b . mul ( unsold ) . div ( sold ) ) ; balances [ ad ] = 0 ; parent . transfer ( ad , b ) ; } } transferredIndex = i - 1 ; }
","Only call after releasing all sale smart contracts , this smart contract must have enough Mozo tokens
"
"function changeDescription ( string _newDesc ) public onlyOwner { require ( bytes ( _newDesc ) . length > 0 , ""Invalid description"" ) ; description = _newDesc ; }
","Updates the description of the ModuleFactory
"
"function balanceOfAt ( address _investor , uint256 _checkpointId ) public view returns ( uint256 ) { return getValueAt ( checkpointBalances [ _investor ] , _checkpointId , balanceOf ( _investor ) ) ; }
","Queries balances as of a defined checkpoint
"
"function balanceOf ( address account ) public view returns ( uint ) { return totalVestedAccountBalance [ account ] ; }
","A simple alias to totalVestedAccountBalance : provides ERC20 balance integration .
"
"function convert ( uint _amount ) { if ( ! arcToken . transferFrom . gas ( 100000 ) ( msg . sender , vaultAddress , _amount ) ) { throw ; } if ( ! tokenContract . generateTokens ( msg . sender , _amount ) ) { throw ; } }
","converts ARC tokens to new SWT tokens and forwards ARC to the vault address .
"
"function withdrawERC20 ( address _tokenContract , uint256 _value ) external onlyOwner { require ( _tokenContract != address ( 0 ) ) ; IERC20 token = IERC20 ( _tokenContract ) ; require ( token . transfer ( owner , _value ) ) ; }
","Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token .
"
"function adjustPrice ( uint _multiplier ) external onlyOwner { require ( _multiplier < 400 && _multiplier > 25 ) ; minInvestment = minInvestment * _multiplier / 100 ; weiPerABIO = weiPerABIO * _multiplier / 100 ; emit PriceAdjust ( msg . sender , _multiplier , minInvestment , weiPerABIO ) ; }
","allows owner to adjust ` minInvestment ` and ` weiPerABIO ` in case of extreme jumps of Ether 's dollar-value .
"
"function setMinBuyAmount ( uint256 _minBuyAmount ) onlyOwner public { minBuyAmount = _minBuyAmount ; }
","set minimal amount of ether which can be used to buy tokens
"
"function generateLockId ( ) internal returns ( bytes32 lockId ) { return keccak256 ( block . blockhash ( block . number - 1 ) , address ( this ) , ++ lockRequestCount ) ; }
","Returns a fresh unique identifier .
"
"function calculateAccountValues ( address userAddress ) public view returns ( uint , uint , uint ) { ( Error err , uint supplyValue , uint borrowValue ) = calculateAccountValuesInternal ( userAddress ) ; if ( err != Error . NO_ERROR ) { return ( uint ( err ) , 0 , 0 ) ; } return ( 0 , supplyValue , borrowValue ) ; }
","Gets the ETH values of the user 's accumulated supply and borrow balances , scaled by 10e18 .
"
"function getTokensWithBonuses ( uint256 value , bool withReferralBonus ) view public returns ( uint256 ) { uint256 amount = value . mul ( baseRate ) ; amount = amount . add ( getTimeBonus ( value ) ) . add ( getBulkBonus ( value ) ) ; if ( withReferralBonus ) { amount = amount . add ( getReferralBonus ( value ) ) ; } return amount ; }
","Calculates how many tokens one should receive at curent time for a specified value of ether
"
"function skipPayment ( uint _idDeposit , bool _skip ) public { require ( _idDeposit < deposits . length ) ; skipDeposits [ msg . sender ] [ _idDeposit ] = _skip ; SkipPayment ( _idDeposit , _skip ) ; }
","This function is a failsafe function in case a token holder wants to skip a payment , can only be applied to one deposit at a time and only affects the payment for the ` msg.sender ` calling the function ; can be undone by calling again with ` skip == false `
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public erc20 returns ( bool success ) { require ( _amount <= mAllowed [ _from ] [ msg . sender ] ) ; mAllowed [ _from ] [ msg . sender ] = mAllowed [ _from ] [ msg . sender ] . sub ( _amount ) ; doSend ( _from , _to , _amount , """" , msg . sender , """" , false ) ; return true ; }
","ERC20 backwards compatible transferFrom .
"
"function proxyPayment ( address buyer ) payable public whenNotPaused returns ( bool success ) { return doPayment ( buyer ) ; }
","` proxyPayment ( ) ` allows the caller to send ether to the VZTPresale and have the tokens created in an address of their choosing
"
"function div ( uint256 x , uint256 y ) internal pure returns ( uint256 z ) { z = SafeMath . add ( SafeMath . mul ( x , ( 10 ** 18 ) ) , y / 2 ) / y ; }
","This function divides two decimals represented as ( decimal 10DECIMALS )
"
"function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; uint commission = msg . value / sellRate ; require ( address ( this ) . send ( commission ) ) ; msg . sender . transfer ( revenue ) ; }
","Sell metadollars and receive ether from contract
"
"function getName ( ) public view returns ( bytes32 ) { return name ; }
","Get the name of the Module
"
"function getChar ( uint256 _tokenId ) public view returns ( string wikiID_Name , uint256 sellingPrice , address owner ) { Char storage char = chars [ _tokenId ] ; wikiID_Name = char . wikiID_Name ; sellingPrice = charIndexToPrice [ _tokenId ] ; owner = charIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific char .
"
"function validateIpfsDoc ( address _student , uint _docIndx , bytes _ipfsHash ) public view returns ( bool ) { Certification storage certification = studentCertifications [ _student ] ; return ( certification . documents [ _docIndx ] ) . validateIpfsDoc ( _ipfsHash ) ; }
","Validate IPFS Hash alone of a student
"
"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function totalSupply ( ) public view returns ( uint Supply ) { return totalBhinneka ; }
","Returns the Total Number of BTI Tokens .
"
"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; collectibleIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function migrate ( uint256 _value ) external nonReentrant isUpgrading { require ( _value > 0 ) ; require ( _value <= balances [ msg . sender ] ) ; require ( agent . isMigrationAgent ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; if ( ! agent . migrateFrom ( msg . sender , _value ) ) { revert ( ) ; } Migrate ( msg . sender , agent , _value ) ; }
","Migrate tokens to the new token contract .
"
"function allowance ( address account , address spender ) public view returns ( uint amount ) { return lib . getTokenAllowance ( lib . getTokenSymbol ( address ( this ) ) , account , spender ) ; }
","Gets allowance that spender has with approver
"
"function payAffiliate ( uint256 _tokens , uint256 _etherValue , address _caller ) internal { if ( affiliateUtility . isAffiliateValid ( _caller ) ) { address affiliate = affiliateUtility . getAffiliate ( _caller ) ; var ( affiliateBonus , contributorBonus ) = affiliateUtility . applyAffiliate ( _caller , _tokens , _etherValue ) ; shp . generateTokens ( affiliate , affiliateBonus ) ; shp . generateTokens ( _caller , contributorBonus ) ; } }
","Pays an affiliate if they are valid and present in the transaction data
"
"function changePlayersName ( string _name ) external { addressInfo [ msg . sender ] . name = _name ; }
","Change players 's name
"
"function changeArbitrator ( address _newArbitrator ) onlyArbitrator { arbitrator = _newArbitrator ; }
","` onlyArbitrator ` Reassigns the arbitrator to a new address
"
"function _chkBuyerLmts ( address buyer , uint amountOfCoinsBuyerCanBuy ) internal returns ( bool success ) { uint amountTkns = amountOfCoinsBuyerCanBuy ; success = false ; ICO ico = ICO ( _getIcoAddr ( ) ) ; uint seriesCapFactor = ico . getSCF ( ) ; if ( amountTkns <= safeSub ( safeDiv ( allowedIndividualShare * seriesCapFactor , 10 ** 18 ) , balanceOf [ buyer ] ) ) { success = true ; } return success ; }
","a buyers allowed limits in holding ico tokens is checked
"
"function createToken ( ) payable returns ( bool success ) { if ( msg . value == 0 ) { throw ; } if ( ( balances [ msg . sender ] + msg . value ) > balances [ msg . sender ] && ( totalSupply + msg . value ) > totalSupply ) { totalSupply += msg . value ; balances [ msg . sender ] += msg . value ; LogCreateToken ( msg . sender , msg . value ) ; return true ; } else { throw ; } }
","Creates ether tokens corresponding to the amount of ether received 'msg.value ' .
"
"function _getApproved ( uint256 _tokenId ) internal view returns ( address ) { require ( _exists ( _tokenId ) ) ; return _tokenApprovals [ _tokenId ] ; }
","Get the approved address for a single NFT
"
"function setSigningLogic ( SigningLogicInterface _newSigningLogic ) public nonZero ( _newSigningLogic ) onlyOwner { address oldSigningLogic = signingLogic ; signingLogic = _newSigningLogic ; emit SigningLogicChanged ( oldSigningLogic , signingLogic ) ; }
","Change the implementation of the SigningLogic contract by setting a new address
"
"function isReissuable ( bytes32 _symbol ) public view returns ( bool ) { return assets [ _symbol ] . isReissuable ; }
","Returns asset reissuability .
"
"function collect ( address caller ) public { require ( getBlockTimestamp ( ) > contribution . startTime ( ) ) ; uint256 pre_sale_fixed_at = contribution . initializedBlock ( ) ; uint256 balance = wct1 . balanceOfAt ( caller , pre_sale_fixed_at ) ; balance = balance . add ( wct2 . balanceOfAt ( caller , pre_sale_fixed_at ) ) ; uint256 totalSupplied = wct1 . totalSupplyAt ( pre_sale_fixed_at ) ; totalSupplied = totalSupplied . add ( wct2 . totalSupplyAt ( pre_sale_fixed_at ) ) ; uint256 total = totalCollected . add ( wpr . balanceOf ( address ( this ) ) ) ; assert ( totalSupplied > 0 ) ; uint256 amount = total . mul ( balance ) . div ( totalSupplied ) ; amount = amount . sub ( collected [ caller ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ caller ] = collected [ caller ] . add ( amount ) ; require ( wpr . transfer ( caller , amount ) ) ; TokensCollected ( caller , amount ) ; }
","This method should be called by the WCT holders to collect their corresponding WPRs
"
"function subAttack ( uint256 _playerAttackPoints , uint256 _x ) internal pure returns ( uint256 ) { return ( _playerAttackPoints <= _x + 2 ) ? 2 : _playerAttackPoints - _x ; }
","Subtracts ability points .
"
"function borrow ( address asset , uint amount ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . BORROW_CONTRACT_PAUSED ) ; } BorrowLocalVars memory localResults ; Market storage market = markets [ asset ] ; Balance storage borrowBalance = borrowBalances [ msg . sender ] [ asset ] ; Error err ; uint rateCalculationResultCode ; if ( ! market . isSupported ) { return fail ( Error . MARKET_NOT_SUPPORTED , FailureInfo . BORROW_MARKET_NOT_SUPPORTED ) ; } ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED ) ; } ( err , localResults . userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , localResults . newBorrowIndex ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . borrowAmountWithFee ) = calculateBorrowAmountWithFee ( amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_ORIGINATION_FEE_CALCULATION_FAILED ) ; } ( err , localResults . userBorrowUpdated ) = add ( localResults . userBorrowCurrent , localResults . borrowAmountWithFee ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED ) ; } ( err , localResults . newTotalBorrows ) = addThenSub ( market . totalBorrows , localResults . userBorrowUpdated , borrowBalance . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED ) ; } ( err , localResults . accountLiquidity , localResults . accountShortfall ) = calculateAccountLiquidity ( msg . sender ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED ) ; } if ( ! isZeroExp ( localResults . accountShortfall ) ) { return fail ( Error . INSUFFICIENT_LIQUIDITY , FailureInfo . BORROW_ACCOUNT_SHORTFALL_PRESENT ) ; } ( err , localResults . ethValueOfBorrowAmountWithFee ) = getPriceForAssetAmountMulCollatRatio ( asset , localResults . borrowAmountWithFee ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_AMOUNT_VALUE_CALCULATION_FAILED ) ; } if ( lessThanExp ( localResults . accountLiquidity , localResults . ethValueOfBorrowAmountWithFee ) ) { return fail ( Error . INSUFFICIENT_LIQUIDITY , FailureInfo . BORROW_AMOUNT_LIQUIDITY_SHORTFALL ) ; } localResults . currentCash = getCash ( asset ) ; ( err , localResults . updatedCash ) = sub ( localResults . currentCash , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( Error . TOKEN_INSUFFICIENT_CASH , FailureInfo . BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED ) ; } ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa ) = market . interestRateModel . getSupplyRate ( asset , localResults . updatedCash , localResults . newTotalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa ) = market . interestRateModel . getBorrowRate ( asset , localResults . updatedCash , localResults . newTotalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . BORROW_NEW_BORROW_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } err = doTransferOut ( asset , msg . sender , amount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . BORROW_TRANSFER_OUT_FAILED ) ; } market . blockNumber = getBlockNumber ( ) ; market . totalBorrows = localResults . newTotalBorrows ; market . supplyRateMantissa = localResults . newSupplyRateMantissa ; market . supplyIndex = localResults . newSupplyIndex ; market . borrowRateMantissa = localResults . newBorrowRateMantissa ; market . borrowIndex = localResults . newBorrowIndex ; localResults . startingBalance = borrowBalance . principal ; borrowBalance . principal = localResults . userBorrowUpdated ; borrowBalance . interestIndex = localResults . newBorrowIndex ; emit BorrowTaken ( msg . sender , asset , amount , localResults . startingBalance , localResults . borrowAmountWithFee , localResults . userBorrowUpdated ) ; return uint ( Error . NO_ERROR ) ; }
","Users borrow assets from the protocol to their own address
"
"function verifyTransfer ( address , address _to , uint256 , bool ) public returns ( Result ) { if ( ! paused ) { if ( maxHolderCount < ISecurityToken ( securityToken ) . investorCount ( ) ) { if ( ISecurityToken ( securityToken ) . balanceOf ( _to ) != 0 ) { return Result . NA ; } return Result . INVALID ; } return Result . NA ; } return Result . NA ; }
","Used to verify the transfer transaction according to the rule implemented in the trnasfer managers
"
"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ _to ] + _amount <= balances [ _to ] ) return false ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; if ( balances [ msg . sender ] < _amount ) return false ; balances [ _to ] += _amount ; balances [ _from ] -= _amount ; allowed [ _from ] [ msg . sender ] -= _amount ; Transfer ( _from , _to , _amount ) ; return true ; }
","Transfer Spork tokens from one account to another
"
"function sellerRequestCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _seller , ""Must be seller"" ) ; return doSellerRequestCancel ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }
","Request to cancel as a seller .
"
"function isPermission ( bytes4 _methodsignature ) public view returns ( bool ) { return permissions [ _methodsignature ] . active ; }
","does permission exist ?
"
"function setCloseTime ( uint256 _gameID , uint256 _closeTime ) external isActivated ( _gameID ) isOngoing ( _gameID ) onlyDevOrOwner ( ) { game_ [ _gameID ] . closeTime = _closeTime ; emit onChangeCloseTime ( _gameID , _closeTime , now ) ; }
","Set a closing time for betting .
"
"function getStartTime ( ) public view returns ( uint ) { return m_startTime ; }
","start time of the ICO
"
"function areaPrice ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) public view returns ( uint ) { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; return market . areaPrice ( blocksList ( fromX , fromY , toX , toY ) ) ; }
","get area price in wei
"
"function canStart ( ) public view returns ( bool ) { uint256 timeOfWeek = ( block . timestamp - 345600 ) % 604800 ; uint256 windows = activeTimesFrom . length ; if ( windows == 0 ) { return true ; } for ( uint256 i = 0 ; i < windows ; i ++ ) { if ( timeOfWeek >= activeTimesFrom [ i ] && timeOfWeek <= activeTimesTo [ i ] ) { return true ; } } return false ; }
","A boolean indicating whether a new game can start , based on the active times .
"
"function getAmountOfTokens ( ) public view returns ( uint256 _lengthOfTokens ) { _lengthOfTokens = tokenAddress . length ; }
","Returns the amount of tokens currently in this contract .
"
"function generateSecurityToken ( string _name , string _ticker , string _tokenDetails , bool _divisible ) external ;
","Creates a new Security Token and saves it to the registry
"
"function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; tokenReward . transfer ( creator , remanent ) ; LogBeneficiaryPaid ( creator ) ; LogContributorsPayout ( creator , remanent ) ; }
","closure handler
"
"function updateGenerationDict ( uint256 _season , uint64 _value ) public onlyManager whenNotPaused { require ( generationSeasonDict [ _season ] <= 1 ) ; generationSeasonDict [ _season ] = _value ; }
","Updates the Generation Season Dict .
"
"function stakeTokens ( uint _quantity ) external isStaking notZero ( _quantity ) { require ( levToken . allowance ( msg . sender , this ) >= _quantity ) ; levBlocks [ msg . sender ] = levBlocks [ msg . sender ] . add ( _quantity . mul ( endBlock . sub ( block . number ) ) ) ; stakes [ msg . sender ] = stakes [ msg . sender ] . add ( _quantity ) ; totalLevBlocks = totalLevBlocks . add ( _quantity . mul ( endBlock . sub ( block . number ) ) ) ; totalLevs = totalLevs . add ( _quantity ) ; require ( levToken . transferFrom ( msg . sender , this , _quantity ) ) ; StakeEvent ( msg . sender , _quantity , startBlock , endBlock ) ; }
","Public function to stake tokens executable by any user .
"
"function kill ( ) onlyOwner { suicide ( owner ) ; }
","Only owner can kill me
"
"function unFreezeAccount ( address target ) onlyOwner public { frozenAccount [ target ] = false ; FrozenFunds ( target , false ) ; }
","Allow ` target ` from sending & receiving tokens
"
"function startSale ( ) public onlyController { require ( campaignState > 2 ) ; campaignState = 2 ; uint256 tNow = now ; tCampaignStart = tNow ; t_1st_StageEnd += tNow ; t_2nd_StageEnd += tNow ; tCampaignEnd += tNow ; CampaignOpen ( now ) ; }
","Puts campaign into active state only controller can do that only possible if team token Vault is set up WARNING : usual caveats apply to the Ethereum 's interpretation of time
"
"function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) { return ( ( _interfaceID == INTERFACE_SIGNATURE_ERC165 ) || ( _interfaceID == INTERFACE_SIGNATURE_ERC721 ) || ( _interfaceID == INTERFACE_SIGNATURE_ERC721Metadata ) ) ; }
","Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
"
"function setManualOverride ( bool _override ) public onlyOwner { manualOverride = _override ; emit SetManualOverride ( _override , now ) ; }
","Determine whether manual price is used or not
"
"function contractExists ( address channel ) constant returns ( bool ) { uint size ; assembly { size := extcodesize ( channel ) } return size > 0 ; }
","Check if a contract exists
"
"function disableController ( ) external isEnabled ( ""disableControllerAllowed"" ) onlyOwner { require ( ! controllerDisabled ) ; controllerDisabled = true ; delete controller ; emit DisableController ( now ) ; }
","Used by the issuer to permanently disable controller functionality
"
"function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; require ( finalizedTime == 0 ) ; require ( getBlockTimestamp ( ) >= startTime ) ; require ( msg . sender == controller || getBlockTimestamp ( ) > endTime || weiToCollect ( ) == 0 ) ; aix . generateTokens ( remainderHolder , weiToCollect ( ) . mul ( 2000 ) ) ; uint256 tokenCap = aix . totalSupply ( ) . mul ( 100 ) . div ( 51 ) ; aix . generateTokens ( devHolder , tokenCap . mul ( 20 ) . div ( 100 ) ) ; aix . generateTokens ( communityHolder , tokenCap . mul ( 29 ) . div ( 100 ) ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = getBlockTimestamp ( ) ; Finalized ( finalizedBlock ) ; }
","This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .
"
"function disableController ( ) external ;
","Used by the issuer to permanently disable controller functionality
"
"function synthetixReceivedForEther ( uint amount ) public view returns ( uint ) { uint valueSentInSynths = amount . multiplyDecimal ( usdToEthPrice ) ; return synthetixReceivedForSynths ( valueSentInSynths ) ; }
","Calculate how many SNX you will receive if you transfer an amount of ether .
"
"function onContribution ( address , uint256 _tierIndex , uint256 _tokens , uint256 _bonus ) public onlyCrowdsale ( ) { strategy . updateTierState ( _tierIndex , _tokens , _bonus ) ; }
","Takes actions on contribution
"
"function refoundTokens ( uint index , address receiver , address sc ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( isAirDropUnique ( index , receiver , sc ) == true ) { airdrop . tokenSC . transfer ( airdrop . distributor , airdrop . tokenAmount ) ; } else revert ( ) ; }
","Refund tokens back to the to airdrop creator
"
"function updateWallet ( address _wallet ) external onlyContractOwner returns ( uint ) { require ( _wallet != 0x0 ) ; wallet = _wallet ; return OK ; }
","Sets new wallet address for profiterole Only for contract owner .
"
"function withdrawToRegisteredWallet ( ) external { require ( registered_wallet != 0x0 , ""No wallet is registered"" ) ; registered_wallet . transfer ( address ( this ) . balance ) ; }
","Withdraw money from the arbitrator contract to our registered wallet
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { Approval ( msg . sender , _spender , _value ) ; allowed [ msg . sender ] [ _spender ] = _value ; return true ; }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
"
"function changeAssetPackPrice ( uint _assetPackId , uint _newPrice ) public { require ( assetPacks [ _assetPackId ] . creator == msg . sender ) ; assetPacks [ _assetPackId ] . price = _newPrice ; }
","Change price of asset pack
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { return ownedTokens [ _owner ] ; }
","Returns a list of all Warrior IDs assigned to an address .
"
"function isAllowedTrade ( address who ) public view returns ( bool ) { return tradingWhitelist [ who ] ; }
","Check if a user is allowed to trade .
"
"function transferFrom ( address _from , address _to , uint _value ) public notPaused { super . transferFrom ( _from , _to , _value ) ; }
","ERC20 transferFrom function overridden to disable transfers when paused
"
"function verifyWithdrawSignature ( address _trader , bytes _signature ) external onlyBalancesContract returns ( bool ) { bytes memory data = abi . encodePacked ( ""Republic Protocol: withdraw: "" , _trader , traderNonces [ _trader ] ) ; address signer = Utils . addr ( data , _signature ) ; if ( brokers [ signer ] ) { traderNonces [ _trader ] += 1 ; return true ; } return false ; }
","Verifies a broker 's signature for a trader withdrawal .
"
"function ethRetrieve ( ) onlyAdmin ( 2 ) public { creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; }
","Manual eth retrieve
"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( address ( 0 ) , address ( this ) , mintedAmount ) ; emit Transfer ( address ( this ) , target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x48664c16 ) , _token , _to , _value , _fee , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by transferPreSigned
"
"function balanceOf ( address add ) constant returns ( uint balance ) { return balances [ add ] ; }
","Provides balance of the account requested
"
"function getPaintedPixelsCountByAddress ( address _address , uint32 _canvasId ) public view returns ( uint32 ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; return canvas . addressToCount [ _address ] ; }
","Returns number of pixels set by given address .
"
"function identityExists ( uint ein ) public view returns ( bool ) { return ein < nextEIN && ein > 0 ; }
","Checks if the passed EIN exists .
"
"function disableTransfers ( ) public onlyWhitelisted { require ( transfersEnabled ) ; transfersEnabled = false ; }
","This function disables token transfers for everyone .
"
"function getModule ( address _acct ) external view returns ( bool ) { return modules [ _acct ] ; }
","Get if ` _acct ` is an authorized module
"
"function tokensOf ( address owner ) public view returns ( uint256 [ ] ) ;
","Get all tokens of a given address
"
"function setRatePrices ( uint256 newRate ) onlyAuthorized public { baseRate = newRate ; }
","Allow users to buy tokens for ` newRatePrice ` eth
"
"function cumulative ( uint256 euroUlps ) public constant returns ( uint256 neumarkUlps ) { if ( euroUlps >= ISSUANCE_LIMIT_EUR_ULPS ) { return NEUMARK_CAP ; } if ( euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS ) { return NEUMARKS_AT_LINEAR_LIMIT_ULPS + ( TOT_LINEAR_NEUMARKS_ULPS * ( euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS ) ) / TOT_LINEAR_EUR_ULPS ; } uint256 d = 230769230769230769230769231 ; uint256 term = NEUMARK_CAP ; uint256 sum = 0 ; uint256 denom = d ; do assembly { term := div ( mul ( term , euroUlps ) , denom ) sum := add ( sum , term ) denom := add ( denom , d ) term := div ( mul ( term , euroUlps ) , denom ) sum := sub ( sum , term ) denom := add ( denom , d ) } while ( term != 0 ) ; return sum ; }
","finds total amount of neumarks issued for given amount of Euro
"
"function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length - 1 ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; idToOwnerIndex [ _tokenId ] = 0 ; }
","Use and override this function with caution .
"
"function buyTokens ( ) public stopInEmergency payable returns ( bool ) { if ( msg . value == 0 ) { error ( 'buyTokens: ZeroPurchase' ) ; return false ; } uint256 tokenAmount = buyTokensLowLevel ( msg . sender , msg . value ) ; if ( ! SCRefundVault . deposit . value ( msg . value ) ( msg . sender , tokenAmount ) ) { revert ( 'buyTokens: unable to transfer collected funds from ICO contract to Refund Vault' ) ; } emit BuyTokens ( msg . sender , msg . value , tokenAmount ) ; return true ; }
","Token purchase function direclty through ICO Smart Contract .
"
"function requestVotingRights ( uint _numTokens ) external { require ( token . balanceOf ( msg . sender ) >= _numTokens ) ; require ( token . transferFrom ( msg . sender , this , _numTokens ) ) ; voteTokenBalance [ msg . sender ] += _numTokens ; VotingRightsGranted ( msg . sender , _numTokens ) ; }
","Loads _numTokens ERC20 tokens into the voting contract for one-to-one voting rights
"
"function withdraw ( ) public ownerOnly { owner . transfer ( address ( this ) . balance ) ; }
","Will transfer all ether in this account to the contract owner .
"
"function attestForUser ( address _subject , address _attester , address _requester , uint256 _reward , bytes _requesterSig , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig ) private { validateSubjectSig ( _subject , _dataHash , _requestNonce , _subjectSig ) ; emit TraitAttested ( _subject , _attester , _requester , _dataHash ) ; if ( _reward > 0 ) { tokenEscrowMarketplace . requestTokenPayment ( _requester , _attester , _reward , _requestNonce , _requesterSig ) ; } }
","Perform attestation
"
"function executeOrders ( address [ ] tokenAddresses , bool [ ] buyOrSell , uint256 [ ] amountToObtain , uint256 [ ] amountToGive , address [ ] tokenForOrder , address [ ] exchanges , address [ 8 ] [ ] orderAddresses , uint256 [ 6 ] [ ] orderValues , uint256 [ ] exchangeFees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s , uint256 uniqueID ) public payable { require ( tokenAddresses . length == buyOrSell . length && buyOrSell . length == amountToObtain . length && amountToObtain . length == amountToGive . length , ""TotlePrimary - trade length check failed"" ) ; require ( tokenForOrder . length == exchanges . length && exchanges . length == orderAddresses . length && orderAddresses . length == orderValues . length && orderValues . length == exchangeFees . length && exchangeFees . length == v . length && v . length == r . length && r . length == s . length , ""TotlePrimary - order length check failed"" ) ; internalOrderExecution ( Tokens ( tokenAddresses , buyOrSell , amountToObtain , amountToGive ) , DEXOrders ( tokenForOrder , exchanges , orderAddresses , orderValues , exchangeFees , v , r , s ) ) ; }
","The first four parameters relate to Token orders , the last eight relate to DEX orders
"
"function changeController ( address _newController ) public onlyController { controller = _newController ; }
","Changes the controller of the contract
"
"function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) { return true ; }
","Checks whether investment is permitted for a participant
"
"function cancelAuction ( uint _tokenId ) external { Auction storage auction = tokenIdToAuction [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; address seller = auction . seller ; require ( msg . sender == seller ) ; _cancelAuction ( _tokenId , seller ) ; }
","This is a state-modifying function that can be called while the contract is paused .
"
"function proxyPayment ( address _owner ) payable notPaused returns ( bool success ) { return doPayment ( _owner ) ; }
","` proxyPayment ( ) ` allows the caller to send ether to the EarlyTokenSale and have the tokens created in an address of their choosing
"
"function addOracles ( address [ ] _whitelist ) onlyContractOwner external returns ( uint ) { for ( uint _idx = 0 ; _idx < _whitelist . length ; ++ _idx ) { address _oracle = _whitelist [ _idx ] ; if ( _oracle != 0x0 && ! oracles [ _oracle ] ) { oracles [ _oracle ] = true ; _emitOracleAdded ( _oracle ) ; } } return OK ; }
","Add oracles to whitelist .
"
"function freezeAccount ( address target , bool freeze ) onlyOwner public { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }
","` freeze ?
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( balances [ msg . sender ] >= _value && _value > 0 ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","` _value ` tokens will be sended to ` _to `
"
"function donate ( uint64 giverId , uint64 receiverId , address token , uint _amount ) whenNotPaused payable public { require ( giverId != 0 ) ; require ( receiverId != 0 ) ; uint amount = _receiveDonation ( token , _amount ) ; emit Donate ( giverId , receiverId , token , amount ) ; }
","It is not recommened to call this function outside of the giveth dapp ( giveth.io ) this function is bridged to a side chain .
"
"function removeMinter ( address _who ) public onlyValidator { _removeMinter ( _who ) ; }
","Removes the necessary permissions for a user to mint tokens .
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
"
"function getInt ( bytes32 _key ) public view returns ( int _value ) { return intStorage [ _key ] ; }
","Get value for Int associated with bytes32 id key
"
"function changeExpiryLimit ( uint256 _newExpiry ) public onlyOwner { require ( _newExpiry >= 1 days , ""Expiry should greater than or equal to 1 day"" ) ; uint256 _oldExpiry = expiryLimit ; expiryLimit = _newExpiry ; emit LogChangeExpiryLimit ( _oldExpiry , _newExpiry ) ; }
","Change the expiry time for the token symbol
"
"function buyout ( uint256 _gameIndex , bool startNewGameIfIdle , uint256 x , uint256 y ) public payable { _processGameEnd ( ) ; if ( ! gameStates [ gameIndex ] . gameStarted ) { require ( ! paused ) ; if ( allowStart ) { allowStart = false ; } else { require ( canStart ( ) ) ; } require ( startNewGameIfIdle ) ; _setGameSettings ( ) ; gameStates [ gameIndex ] . gameStarted = true ; gameStates [ gameIndex ] . gameStartTimestamp = block . timestamp ; gameStates [ gameIndex ] . penultimateTileTimeout = block . timestamp + gameSettings . initialActivityTimer ; Start ( gameIndex , msg . sender , block . timestamp , gameStates [ gameIndex ] . prizePool ) ; PenultimateTileTimeout ( gameIndex , gameStates [ gameIndex ] . penultimateTileTimeout ) ; } if ( startNewGameIfIdle ) { require ( _gameIndex == gameIndex || _gameIndex . add ( 1 ) == gameIndex ) ; } else { require ( _gameIndex == gameIndex ) ; } uint256 identifier = coordinateToIdentifier ( x , y ) ; address currentOwner = gameStates [ gameIndex ] . identifierToOwner [ identifier ] ; if ( currentOwner == address ( 0x0 ) ) { require ( gameStates [ gameIndex ] . gameStartTimestamp . add ( gameSettings . initialActivityTimer ) >= block . timestamp ) ; } else { require ( gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ identifier ] >= block . timestamp ) ; } uint256 price = currentPrice ( identifier ) ; require ( msg . value >= price ) ; uint256 [ ] memory claimedSurroundingTiles = _claimedSurroundingTiles ( identifier ) ; _calculateAndAssignBuyoutProceeds ( currentOwner , price , claimedSurroundingTiles ) ; uint256 timeout = tileTimeoutTimestamp ( identifier , msg . sender ) ; gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ identifier ] = timeout ; if ( gameStates [ gameIndex ] . lastTile == 0 || timeout >= gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ gameStates [ gameIndex ] . lastTile ] ) { if ( gameStates [ gameIndex ] . lastTile != identifier ) { if ( gameStates [ gameIndex ] . lastTile != 0 ) { gameStates [ gameIndex ] . penultimateTileTimeout = gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ gameStates [ gameIndex ] . lastTile ] ; PenultimateTileTimeout ( gameIndex , gameStates [ gameIndex ] . penultimateTileTimeout ) ; } gameStates [ gameIndex ] . lastTile = identifier ; LastTile ( gameIndex , identifier , x , y ) ; } } else if ( timeout > gameStates [ gameIndex ] . penultimateTileTimeout ) { gameStates [ gameIndex ] . penultimateTileTimeout = timeout ; PenultimateTileTimeout ( gameIndex , timeout ) ; } _transfer ( currentOwner , msg . sender , identifier ) ; gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] = nextBuyoutPrice ( price ) ; gameStates [ gameIndex ] . numberOfTileFlips ++ ; Buyout ( gameIndex , msg . sender , identifier , x , y , block . timestamp , timeout , gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] , gameStates [ gameIndex ] . prizePool ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Buy the current owner out of the tile .
"
"function setHodlerStake ( address _beneficiary , uint256 _stake ) public onlyOwner beforeHodlStart { if ( hodlerStakes [ _beneficiary ] . stake == _stake || _beneficiary == address ( 0 ) ) return ; if ( hodlerStakes [ _beneficiary ] . stake == 0 && _stake > 0 ) { hodlerTotalCount = hodlerTotalCount . add ( 1 ) ; } else if ( hodlerStakes [ _beneficiary ] . stake > 0 && _stake == 0 ) { hodlerTotalCount = hodlerTotalCount . sub ( 1 ) ; } uint256 _diff = _stake > hodlerStakes [ _beneficiary ] . stake ? _stake . sub ( hodlerStakes [ _beneficiary ] . stake ) : hodlerStakes [ _beneficiary ] . stake . sub ( _stake ) ; if ( _stake > hodlerStakes [ _beneficiary ] . stake ) { hodlerTotalValue = hodlerTotalValue . add ( _diff ) ; } else { hodlerTotalValue = hodlerTotalValue . sub ( _diff ) ; } hodlerStakes [ _beneficiary ] . stake = _stake ; LogHodlSetStake ( msg . sender , _beneficiary , _stake ) ; }
","Setting hodler stake of an account
"
"function setParams ( string _name , string _symbol , string _tla , string _version , uint _decimals , address _feeContract , uint _fxUSDBPSRate ) onlyOwner public returns ( bool success ) { require ( lib . setTokenName ( _name ) , ""Error: Unable to set token name. Please check arguments."" ) ; require ( lib . setTokenSymbol ( _symbol ) , ""Error: Unable to set token symbol. Please check arguments."" ) ; require ( lib . setTokenTLA ( _tla ) , ""Error: Unable to set token TLA. Please check arguments."" ) ; require ( lib . setTokenVersion ( _version ) , ""Error: Unable to set token version. Please check arguments."" ) ; require ( lib . setTokenDecimals ( _symbol , _decimals ) , ""Error: Unable to set token decimals. Please check arguments."" ) ; require ( lib . setFeeContract ( _feeContract ) , ""Error: Unable to set fee contract. Please check arguments."" ) ; require ( lib . setFxUSDBPSRate ( _symbol , _fxUSDBPSRate ) , ""Error: Unable to set fx USD basis points rate. Please check arguments."" ) ; return true ; }
","Sets erc20 globals and fee paramters
"
"function freezeAccount ( address target , bool freeze ) onlyOwner public { _frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }
","Freeze or unfreeze account , can be run only by owner
"
"function onTransfer ( address , address , uint256 ) returns ( bool ) { return transferable ; }
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function setSellFee ( uint32 _sellFeeMilliPercent ) onlyOwner public { require ( _sellFeeMilliPercent < MILLI_PERCENT_DIVIDER ) ; sellFeeMilliPercent = _sellFeeMilliPercent ; }
","Set fee applied when selling tokens
"
"function registerHolder ( bytes32 _externalHolderId , address _holderAddress , uint _countryCode ) onlyOracleOrOwner external returns ( uint ) { require ( _holderAddress != 0x0 ) ; require ( holderIndex [ _externalHolderId ] == 0 ) ; uint _holderIndex = holderIndex [ holderAddress2Id [ _holderAddress ] ] ; require ( _holderIndex == 0 ) ; _createCountryId ( _countryCode ) ; _holderIndex = holdersCount . add ( 1 ) ; holdersCount = _holderIndex ; HoldersData storage _holderData = holders [ _holderIndex ] ; _holderData . countryCode = _countryCode ; _holderData . operational = true ; _holderData . sendLimPerDay = MAX_TOKEN_HOLDER_NUMBER ; _holderData . sendLimPerMonth = MAX_TOKEN_HOLDER_NUMBER ; uint _firstAddressIndex = 1 ; _holderData . holderAddressCount = _firstAddressIndex ; _holderData . address2Index [ _holderAddress ] = _firstAddressIndex ; _holderData . index2Address [ _firstAddressIndex ] = _holderAddress ; holderIndex [ _externalHolderId ] = _holderIndex ; holderAddress2Id [ _holderAddress ] = _externalHolderId ; _emitHolderRegistered ( _externalHolderId , _holderIndex , _countryCode ) ; return OK ; }
","Returns holder id for the specified address , creates it if needed .
"
"function onERC721Received ( address , address , uint256 _tokenId , bytes ) external returns ( bytes4 ) { if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) { flagReceiveLand = 0 ; return ERC721_RECEIVED ; } }
","Callback used to accept the ERC721 parcel tokens
"
"function getEmoji ( uint256 _tokenId ) public view returns ( string emojiName , string emojiMsg , uint256 sellingPrice , address owner ) { Emoji storage emojiObj = emojis [ _tokenId ] ; emojiName = emojiObj . name ; emojiMsg = emojiObj . msg ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific emoji .
"
"function closeCurrentFeePeriod ( ) external onlyFeeAuthority { require ( recentFeePeriods [ 0 ] . startTime <= ( now - feePeriodDuration ) , ""It is too early to close the current fee period"" ) ; FeePeriod memory secondLastFeePeriod = recentFeePeriods [ FEE_PERIOD_LENGTH - 2 ] ; FeePeriod memory lastFeePeriod = recentFeePeriods [ FEE_PERIOD_LENGTH - 1 ] ; recentFeePeriods [ FEE_PERIOD_LENGTH - 2 ] . feesToDistribute = lastFeePeriod . feesToDistribute . sub ( lastFeePeriod . feesClaimed ) . add ( secondLastFeePeriod . feesToDistribute ) ; for ( uint i = FEE_PERIOD_LENGTH - 2 ; i < FEE_PERIOD_LENGTH ; i -- ) { uint next = i + 1 ; recentFeePeriods [ next ] . feePeriodId = recentFeePeriods [ i ] . feePeriodId ; recentFeePeriods [ next ] . startingDebtIndex = recentFeePeriods [ i ] . startingDebtIndex ; recentFeePeriods [ next ] . startTime = recentFeePeriods [ i ] . startTime ; recentFeePeriods [ next ] . feesToDistribute = recentFeePeriods [ i ] . feesToDistribute ; recentFeePeriods [ next ] . feesClaimed = recentFeePeriods [ i ] . feesClaimed ; } delete recentFeePeriods [ 0 ] ; recentFeePeriods [ 0 ] . feePeriodId = nextFeePeriodId ; recentFeePeriods [ 0 ] . startingDebtIndex = synthetix . synthetixState ( ) . debtLedgerLength ( ) ; recentFeePeriods [ 0 ] . startTime = now ; nextFeePeriodId = nextFeePeriodId . add ( 1 ) ; emitFeePeriodClosed ( recentFeePeriods [ 1 ] . feePeriodId ) ; }
","Close the current fee period and start a new one .
"
"function requestMortgage ( uint256 [ 6 ] loanParams , string metadata , uint256 landId , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { uint256 loanId = createLoan ( loanParams , metadata ) ; require ( nanoLoanEngine . registerApprove ( nanoLoanEngine . getIdentifier ( loanId ) , v , r , s ) , ""Signature not valid"" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 requiredDeposit = ( ( landCost * requiredTotal ) / 100 ) - nanoLoanEngine . getAmount ( loanId ) ; _tokenTransferFrom ( mana , msg . sender , this , requiredDeposit ) ; require ( mana . approve ( mortgageManager , requiredDeposit ) ) ; uint256 mortgageId = mortgageManager . requestMortgageId ( Engine ( nanoLoanEngine ) , loanId , requiredDeposit , landId , tokenConverter ) ; emit NewMortgage ( msg . sender , loanId , landId , mortgageId ) ; return mortgageId ; }
","Request a loan and attachs a mortgage request
"
"function deploySTO ( address _securityToken , address _polyAddress , address _factoryAddress ) external returns ( address ) { address newSecurityTokenAddress = new USDTieredSTO ( _securityToken , _polyAddress , _factoryAddress ) ; return newSecurityTokenAddress ; }
","Deploys the STO .
"
"function invalidateAttributeApproval ( bytes32 hash , bytes signature ) external { address validator = _signingKeys [ hash . toEthSignedMessageHash ( ) . recover ( signature ) ] ; require ( msg . sender == validator || msg . sender == owner ( ) , ""only jurisdiction or issuing validator may invalidate attribute approval"" ) ; _invalidAttributeApprovalHashes [ hash ] = true ; }
","Invalidate a signed attribute approval before it has been set by supplying the hash of the approval ` hash ` and the signature ` signature ` .
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalWarriors = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 warriorId ; for ( warriorId = 0 ; warriorId < totalWarriors ; warriorId ++ ) { if ( warriorToOwner [ warriorId ] == _owner ) { result [ resultIndex ] = warriorId ; resultIndex ++ ; } } return result ; } }
","ERC-721 method .
"
"function withdrawTokens ( ) external whenNotPaused onlyAdmin { IERC20 t = super . token ( ) ; t . safeTransfer ( msg . sender , t . balanceOf ( this ) ) ; }
","Withdraw the tokens remaining tokens from the contract .
"
"function calculateExcessTokens ( uint256 amount , uint256 tokensThisTier , uint256 tierSelected , uint256 _rate ) public returns ( uint256 totalTokens ) { require ( amount > 0 && tokensThisTier > 0 && _rate > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; uint weiThisTier = tokensThisTier . sub ( tokensRaised ) . div ( _rate ) ; uint weiNextTier = amount . sub ( weiThisTier ) ; uint tokensNextTier = 0 ; bool returnTokens = false ; if ( tierSelected != 4 ) tokensNextTier = calculateTokensTier ( weiNextTier , tierSelected . add ( 1 ) ) ; else returnTokens = true ; totalTokens = tokensThisTier . sub ( tokensRaised ) . add ( tokensNextTier ) ; if ( returnTokens ) msg . sender . transfer ( weiNextTier ) ; }
","Buys the tokens for the specified tier and for the next one
"
"function ( ) external payable { buyTokens ( msg . sender ) ; }
","fallback function DO NOT OVERRIDE
"
"function fulfill ( Deliverable storage self , address _creator , address _brand ) internal returns ( bool ) { require ( msg . sender == _creator || msg . sender == _brand ) ; self . fulfillment [ msg . sender ] = true ; return self . fulfillment [ _creator ] && self . fulfillment [ _brand ] ; }
","msg.sender can be creator or brand and mark their delivery or approval , returns check if completely Fulfilled
"
"function transferTokens ( address _recipient ) public { require ( beneficiaries [ _recipient ] . amountClaimed < beneficiaries [ _recipient ] . totalAllocated ) ; require ( now >= beneficiaries [ _recipient ] . cliff ) ; require ( ! beneficiaries [ _recipient ] . disable ) ; uint256 unreleased = releasableAmount ( _recipient ) ; require ( unreleased > 0 ) ; IOV . transfer ( _recipient , unreleased ) ; beneficiaries [ _recipient ] . amountClaimed = vestedAmount ( _recipient ) ; emit LogIOVClaimed ( _recipient , unreleased ) ; }
","Transfer a recipients available allocation to their address .
"
"function approve ( address _spender , uint256 _value ) notPendingWithdrawal returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function finalizeFunding ( ) { require ( now >= endFundingTime ) ; tokenContract . changeController ( 0 ) ; }
","` finalizeFunding ( ) ` ends the Campaign by calling setting the controller to 0 , thereby ending the issuance of new tokens and stopping the Campaign from receiving more ether
"
"function commitVotes ( uint [ ] _pollIDs , bytes32 [ ] _secretHashes , uint [ ] _numsTokens , uint [ ] _prevPollIDs ) external { require ( _pollIDs . length == _secretHashes . length ) ; require ( _pollIDs . length == _numsTokens . length ) ; require ( _pollIDs . length == _prevPollIDs . length ) ; for ( uint i = 0 ; i < _pollIDs . length ; i ++ ) { commitVote ( _pollIDs [ i ] , _secretHashes [ i ] , _numsTokens [ i ] , _prevPollIDs [ i ] ) ; } }
","Commits votes using hashes of choices and secret salts to conceal votes until reveal
"
"function burnAllTokens ( address _address ) external returns ( bool success ) { require ( msg . sender == crowdsaleAddress ) ; uint256 amount = balanceOf [ _address ] ; balanceOf [ _address ] = 0 ; totalSupply = totalSupply . sub ( amount ) ; Burn ( _address , amount , totalSupply ) ; success = true ; }
","burn all tokens assigned to '_address '
"
"function refundIgnoredBids ( uint _count ) public onlyOwner { require ( status == state . success || status == state . failure ) ; uint count = _count ; if ( bids_ignored_count < bids_ignored_refunded . add ( count ) ) { count = bids_ignored_count . sub ( bids_ignored_refunded ) ; } require ( count > 0 ) ; uint cursor = bids_ignored_refunded ; bids_ignored_refunded = bids_ignored_refunded . add ( count ) ; BidData storage bid ; while ( count > 0 ) { bid = bids_ignored [ cursor ] ; if ( bid . closed ) { continue ; } bid . closed = true ; art_token_contract . transfer ( bid . investor_address , bid . transfer_token ) ; emit Refunded ( bid . origin_index , bid . transfer_token ) ; cursor ++ ; count -- ; } }
","Performs the refund of the ignored bids ART tokens
"
"function setShareHolders ( bool _valid , uint _from , uint _to ) ;
","Function used by the creator to set the addresses of Dao share holders
"
"function applyAffiliate ( address _investor , uint256 _contributorTokens , uint256 _contributionValue ) public returns ( uint256 , uint256 ) { if ( getAffiliate ( _investor ) == address ( 0 ) ) { return ( 0 , 0 ) ; } uint256 contributorBonus = _contributorTokens . div ( 100 ) ; uint256 affiliateBonus = 0 ; if ( _contributionValue < tierTwoMin ) { affiliateBonus = _contributorTokens . mul ( TIER1_PERCENT ) . div ( 100 ) ; } else if ( _contributionValue >= tierTwoMin && _contributionValue < tierThreeMin ) { affiliateBonus = _contributorTokens . mul ( TIER2_PERCENT ) . div ( 100 ) ; } else { affiliateBonus = _contributorTokens . mul ( TIER3_PERCENT ) . div ( 100 ) ; } return ( affiliateBonus , contributorBonus ) ; }
","calculates and returns the amount to token minted for affilliate
"
"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( throwOnIncompatibleContract && _preventLocking ) { require ( isRegularAddress ( _to ) ) ; } }
","Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
"
"function readBytes32 ( bytes data , uint256 index ) internal pure returns ( bytes32 o ) { if ( data . length / 32 > index ) { assembly { o := mload ( add ( data , add ( 32 , mul ( 32 , index ) ) ) ) } } }
","Reads a bytes32 word of a bytes array
"
"function getCovfefe ( uint _tokenId ) public view returns ( string Term , string Meaning , uint Generation , uint ReadyTime , uint WinCount , uint LossCount , uint CurrentPrice , uint LastPrice , address Owner ) { Covfefe storage covfefe = covfefes [ _tokenId ] ; Term = covfefe . term ; Meaning = covfefe . meaning ; Generation = covfefe . generation ; ReadyTime = covfefe . saleReadyTime ; WinCount = covfefe . winCount ; LossCount = covfefe . lossCount ; CurrentPrice = covfefeIndexToPrice [ _tokenId ] ; LastPrice = covfefeIndexToLastPrice [ _tokenId ] ; Owner = covfefeIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific covfefe .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ;
","send _value token to _to from _from on the condition it is approved by _from
"
"function executePayment ( uint256 _paymentId ) external authP ( EXECUTE_PAYMENTS_ROLE , arr ( _paymentId , payments [ _paymentId ] . amount ) ) paymentExists ( _paymentId ) transitionsPeriod { require ( nextPaymentTime ( _paymentId ) <= getTimestamp64 ( ) , ERROR_EXECUTE_PAYMENT_TIME ) ; _executePayment ( _paymentId ) ; }
","Execute pending payment # ` _paymentId `
"
"function mint ( address _to , uint256 _amount ) public requiresPermission whenNotPaused { _mint ( _to , _amount ) ; }
","Allows user to mint if they have the appropriate permissions .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable mustBeValidToken ( _tokenId ) canTransfer ( _tokenId ) { address owner = _tokenOwnerWithSubstitutions [ _tokenId ] ; if ( owner == address ( 0 ) ) { owner = address ( this ) ; } require ( owner == _from ) ; require ( _to != address ( 0 ) ) ; _transfer ( _tokenId , _to ) ; }
","Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
"
"function releaseApprove ( bytes32 sha , uint8 v , bytes32 r , bytes32 s ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; bytes32 approveSha = keccak256 ( ""approve"" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; bytes32 increaseApprovalSha = keccak256 ( ""increaseApproval"" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; bytes32 decreaseApprovalSha = keccak256 ( ""decreaseApproval"" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; require ( approveSha == sha || increaseApprovalSha == sha || decreaseApprovalSha == sha ) ; require ( verify ( sha , v , r , s ) == true ) ; super . approve ( biometricTo [ sha ] , biometricAmount [ sha ] ) ; biometricCompleted [ sha ] = true ; return true ; }
","Complete pending Approval , can only be called by msg.sender if it is the originator of Approval
"
"function _addToDebtRegister ( address account , uint amount ) internal { Synthetix synthetix = Synthetix ( associatedContract ) ; uint xdrValue = synthetix . effectiveValue ( ""sUSD"" , amount , ""XDR"" ) ; uint totalDebtIssued = importedXDRAmount ; uint newTotalDebtIssued = xdrValue . add ( totalDebtIssued ) ; importedXDRAmount = newTotalDebtIssued ; uint debtPercentage = xdrValue . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . sub ( debtPercentage ) ; uint existingDebt = synthetix . debtBalanceOf ( account , ""XDR"" ) ; if ( existingDebt > 0 ) { debtPercentage = xdrValue . add ( existingDebt ) . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; } if ( issuanceData [ account ] . initialDebtOwnership == 0 ) { totalIssuerCount = totalIssuerCount . add ( 1 ) ; } issuanceData [ account ] . initialDebtOwnership = debtPercentage ; issuanceData [ account ] . debtEntryIndex = debtLedger . length ; if ( debtLedger . length > 0 ) { debtLedger . push ( debtLedger [ debtLedger . length - 1 ] . multiplyDecimalRoundPrecise ( delta ) ) ; } else { debtLedger . push ( SafeDecimalMath . preciseUnit ( ) ) ; } }
","Import issuer data from the old Synthetix contract before multicurrency
"
"function transfer ( address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; require ( lib . forceTransfer ( currency , msg . sender , to , amount , ""0x0"" ) , ""Error: Unable to transfer funds to account."" ) ; require ( lib . forceTransfer ( currency , msg . sender , feeContract , calculateFees ( amount ) , lib . getFeeMsg ( feeContract ) ) , ""Error: Unable to transfer fees to fee contract."" ) ; emit Transfer ( msg . sender , to , amount ) ; return true ; }
","transfers 'amount ' from msg.sender to a receiving account 'to '
"
"function operatorSend ( address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData ) public { require ( isOperatorFor ( msg . sender , _from ) , ""Not an operator"" ) ; addWhitelistAddress ( _to ) ; doSend ( msg . sender , _from , _to , _amount , _data , _operatorData , true ) ; }
","Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
"
"function performBuyOrder ( OrderData order , uint256 amountToGiveForOrder ) public payable onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { uint256 takeFee = exchange . takeFee ( ) ; amountSpentOnOrder = amountToGiveForOrder ; uint256 amountSpentMinusFee = SafeMath . sub ( amountSpentOnOrder , exchange . feeFromTotalCostForAccount ( amountSpentOnOrder , takeFee , address ( this ) ) ) ; amountReceivedFromOrder = SafeMath . div ( SafeMath . mul ( amountSpentMinusFee , order . tokenAmount ) , order . weiAmount ) ; exchange . takeSellOrder . value ( amountToGiveForOrder ) ( order . token , order . tokenAmount , order . weiAmount , order . maker ) ; if ( ! ERC20SafeTransfer . safeTransfer ( order . token , totlePrimary , amountReceivedFromOrder ) ) { errorReporter . revertTx ( ""Unable to transfer bought tokens to primary"" ) ; } }
","Perform a buy order at the exchange
"
"function vote ( uint _idPoll , uint [ ] _ballots ) public { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll storage p = _polls [ _idPoll ] ; require ( block . number >= p . startBlock && block . timestamp < p . endTime && ! p . canceled , ""Poll is inactive"" ) ; require ( _ballots . length == p . numBallots , ""Number of ballots is incorrect"" ) ; unvote ( _idPoll ) ; uint amount = token . balanceOfAt ( msg . sender , p . startBlock ) ; require ( amount != 0 , ""No SNT balance available at start block of poll"" ) ; p . voters ++ ; uint totalBallots = 0 ; for ( uint8 i = 0 ; i < _ballots . length ; i ++ ) { totalBallots += _ballots [ i ] ; p . ballots [ i ] [ msg . sender ] = _ballots [ i ] ; if ( _ballots [ i ] != 0 ) { p . qvResults [ i ] += sqrt ( _ballots [ i ] / 1 ether ) ; p . results [ i ] += _ballots [ i ] ; p . votersByBallot [ i ] ++ ; } } require ( totalBallots <= amount , ""Total ballots must be less than the SNT balance at poll start block"" ) ; emit Vote ( _idPoll , msg . sender , _ballots ) ; }
","Vote for a poll
"
"function setQuestionFee ( uint256 fee ) stateAny ( ) external { arbitrator_question_fees [ msg . sender ] = fee ; emit LogSetQuestionFee ( msg . sender , fee ) ; }
","Function for arbitrator to set an optional per-question fee .
"
"function callPlugins ( bool before , uint64 fromPledge , uint64 toPledge , uint amount ) internal returns ( uint allowedAmount ) { allowedAmount = amount ; allowedAmount = callPluginsPledge ( before , fromPledge , fromPledge , toPledge , allowedAmount ) ; allowedAmount = callPluginsPledge ( before , toPledge , fromPledge , toPledge , allowedAmount ) ; }
","` callPlugins ` calls ` callPluginsPledge ` once for the transfer context and once for the receiving context .
"
"function balanceOf ( address _owner ) external constant returns ( uint256 balance ) { return balances [ _owner ] ; }
","Query the available balance of an address ~ ERC-20 Standard
"
"function registerSecretBatch ( bytes32 [ ] secrets ) public returns ( bool ) { bool completeSuccess = true ; for ( uint i = 0 ; i < secrets . length ; i ++ ) { if ( ! registerSecret ( secrets [ i ] ) ) { completeSuccess = false ; } } return completeSuccess ; }
","Registers multiple hash time lock secrets and saves the block number .
"
"function feesAvailable ( address account , bytes4 currencyKey ) public view returns ( uint ) { uint [ FEE_PERIOD_LENGTH ] memory userFees = feesByPeriod ( account ) ; uint totalFees = 0 ; for ( uint i = 1 ; i < FEE_PERIOD_LENGTH ; i ++ ) { totalFees = totalFees . add ( userFees [ i ] ) ; } return synthetix . effectiveValue ( ""XDR"" , totalFees , currencyKey ) ; }
","The fees available to be withdrawn by a specific account , priced in currencyKey currency
"
"function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 12 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 24 ) ) ) { require ( collectedTokens < total . percent ( 40 ) ) ; canExtract = total . percent ( 40 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 24 ) ) && getTime ( ) <= finalizedTime . add ( months ( 36 ) ) ) { require ( collectedTokens < total . percent ( 80 ) ) ; canExtract = total . percent ( 80 ) ; } else { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }
","The owner will call this method to extract the tokens
"
"function transferToContract ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; WeBetCrypto rec = WeBetCrypto ( _to ) ; rec . tokenFallback ( msg . sender , _value , _data ) ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","Handles transfer to a contract ~ ERC-223 Proposed Standard
"
"function addRestrictedAttributeType ( uint256 ID , string description ) external onlyOwner whenNotPaused { require ( ! isAttributeType ( ID ) , ""an attribute type with the provided ID already exists"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( ID , true , description ) ) ; if ( _attributeTypeHashes [ ID ] == bytes32 ( 0 ) ) { _attributeTypeHashes [ ID ] = hash ; } require ( hash == _attributeTypeHashes [ ID ] , ""attribute type properties must match initial properties assigned to ID"" ) ; _attributeTypes [ ID ] = AttributeType ( { exists : true , restricted : true , onlyPersonal : false , index : _attributeIDs . length , secondarySource : address ( 0 ) , secondaryAttributeTypeID : uint256 ( 0 ) , minimumStake : uint256 ( 0 ) , jurisdictionFee : uint256 ( 0 ) , description : description } ) ; _attributeIDs . push ( ID ) ; emit AttributeTypeAdded ( ID , description ) ; }
","Add a restricted attribute type with ID ` ID ` and description ` description ` to the jurisdiction .
"
"function setItemForSale ( uint256 _id , uint256 _price ) external onlyOwnerOfItem ( _id ) itemIsNotForSale ( _id ) { Item storage item = items [ _id ] ; item . forSale = true ; item . price = _price ; itemsForSaleCount ++ ; }
","Sets item for sale
"
"function abort ( ) public returns ( bool ) ;
","Abort the token sale prior to finalizeICO ( )
"
"function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) , ""Invalid address"" ) ; IERC20 token = IERC20 ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( owner , balance ) , ""Transfer failed"" ) ; }
","Reclaim all ERC20Basic compatible tokens
"
"function setEnd ( ) external onlyAdmin checkState ( pointsValidationState . WinnersAssigned ) { uint256 balance = address ( this ) . balance ; adminPool = balance . mul ( 10 ) . div ( 100 ) ; prizePool = balance . mul ( 90 ) . div ( 100 ) ; pValidationState = pointsValidationState . Finished ; gameFinishedTime = now ; unSetPause ( ) ; }
","Sets prizes for last tokens and sets prize pool amount
"
"function setupEventsHistory ( address _eventsHistory ) external onlyContractOwner returns ( uint errorCode ) { eventsHistory = _eventsHistory ; return OK ; }
","Sets EventsHstory contract address .
"
"function deposit ( address _token , uint256 _value ) external payable isInitialized { _deposit ( _token , _value ) ; }
","Deposit ` _value ` ` _token ` to the vault
"
"function withdraw ( address _user , uint256 _value ) public onlyOwnerOrAllowed ;
","Withdraws a certain value from a user 's balance back to the user 's account Can be called from the Advertisement contract registered or by this contract 's owner .
"
"function updateTokenDetails ( string _newTokenDetails ) external onlyOwner { emit UpdateTokenDetails ( tokenDetails , _newTokenDetails ) ; tokenDetails = _newTokenDetails ; }
","updates the tokenDetails associated with the token
"
"function setRegisteredFirm ( Data storage self , string issuerFirm , bool approved ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.firm' , issuerFirm ) ) ; require ( self . Storage . setBool ( id , approved ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; return true ; }
","Method for setting a registered issuer firm
"
"function baseUnit ( bytes32 _symbol ) public view returns ( uint8 ) { return get ( store , assetBaseUnit , _symbol ) ; }
","Returns asset decimals .
"
"function transferFrom ( address _owner , address _receiver , uint256 _amount ) public returns ( bool _transferredFrom ) { require ( ! tokenTransfersFrozen ) ; require ( allowance [ _owner ] [ msg . sender ] . sub ( _amount ) >= 0 ) ; require ( transferCheck ( _owner , _receiver , _amount ) ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; allowance [ _owner ] [ _receiver ] = allowance [ _owner ] [ _receiver ] . sub ( _amount ) ; Transfer ( _owner , _receiver , _amount ) ; return true ; }
","Used to transfer funds on behalf of one person
"
"function enableTransfers ( bool _transfersEnabled ) public onlyController { transfersEnabled = _transfersEnabled ; }
","Enables token holders to transfer their tokens freely if true
"
"function issueForEuro ( uint256 euroUlps ) public only ( ROLE_NEUMARK_ISSUER ) acceptAgreement ( msg . sender ) returns ( uint256 ) { require ( _totalEurUlps + euroUlps >= _totalEurUlps ) ; uint256 neumarkUlps = incremental ( _totalEurUlps , euroUlps ) ; _totalEurUlps += euroUlps ; mGenerateTokens ( msg . sender , neumarkUlps ) ; LogNeumarksIssued ( msg . sender , euroUlps , neumarkUlps ) ; return neumarkUlps ; }
","issues new Neumarks to msg.sender with reward at current curve position moves curve position by euroUlps callable only by ROLE_NEUMARK_ISSUER
"
"function depositERC20 ( address _user , address _token , uint256 _amount ) external onlyCoordinator onlyActiveState { require ( _amount > 0 , 'Invalid value' ) ; balances [ _user ] [ _token ] = balances [ _user ] [ _token ] . add ( _amount ) ; ERC20 ( _token ) . transferFrom ( _user , address ( this ) , _amount ) ; require ( _getSanitizedReturnValue ( ) , ""transferFrom failed."" ) ; emit BalanceIncrease ( _user , _token , _amount , ReasonDeposit ) ; }
","Deposits ERC20 tokens under the ` _user ` 's balance
"
"function getString ( bytes32 _key ) public view returns ( string _value ) { return stringStorage [ _key ] ; }
","Get value for String associated with bytes32 id key
"
"function generateTokens ( address _owner , uint256 _amount ) onlyController returns ( bool ) { uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function unpause ( ) public onlyowner { hault = false ; }
","Unpause the crowdsale
"
"function changeController ( address _newController ) public onlyOwner { token . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
","The owner of this contract can change the controller of the token Please , be sure that the owner is a trusted agent or 0x0 address .
"
"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyCallers public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function transferFrom ( address _from , address _to , uint _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; _transItem ( _from , _to , _tokenId ) ; }
","Transfer a Rabbit owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function settleGame ( uint256 _gameID , uint256 _team , string _comment , uint256 _deadline ) external isActivated ( _gameID ) isOngoing ( _gameID ) isValidTeam ( _gameID , _team ) isOwner ( ) { require ( _deadline >= now + 86400 , ""deadline must be more than one day later."" ) ; game_ [ _gameID ] . ended = true ; game_ [ _gameID ] . winnerTeam = _team ; game_ [ _gameID ] . gameEndComment = _comment ; game_ [ _gameID ] . withdrawDeadline = _deadline ; if ( teams_ [ _gameID ] [ _team ] . keys == 0 ) { uint256 _totalPot = ( gameStatus_ [ _gameID ] . winningVaultInst ) . add ( gameStatus_ [ _gameID ] . winningVaultFinal ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalPot ; if ( _totalPot > 0 ) { FSKingCorp . deposit . value ( _totalPot ) ( ) ; } } emit FSEvents . onGameEnded ( _gameID , _team , _comment , now ) ; }
","Select a winning team .
"
"function migrationSetPlayer ( bytes32 boardHash , uint playerID , bytes32 playerName , address playerAddress , uint score , uint score_unconfirmed , uint isActive ) isOwner public returns ( bool ) { Board storage g = boards [ boardHash ] ; g . players [ playerID ] = Player ( playerName , playerAddress , score , score_unconfirmed , isActive ) ; return true ; }
","Write player metadata for migration as contract owner only
"
"function getCEOHashing ( address _newCEO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E94 ) , _newCEO , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by setCEO
"
"function withdrawToken ( address _token ) external onlyAdmin { bool isVRH = _token == address ( token ) ; ERC20 erc20 = ERC20 ( _token ) ; uint256 balance = erc20 . balanceOf ( this ) ; if ( isVRH ) { balance = balance . sub ( getRemainingBonus ( ) ) ; changeClosingTime ( now ) ; } require ( erc20 . transfer ( msg . sender , balance ) ) ; emit ERC20Withdrawn ( _token , balance ) ; }
","Enables the admins to withdraw Binance coinor any ERC20 token accidentally sent to this contract .
"
"function getPriceVolume ( uint _price ) public constant returns ( uint ) ;
","Returns the collective order volume at a ` _price ` .
"
"function setParent ( uint256 identifier , uint256 parentIdentifier ) external onlyCFO { require ( identifierToOwner [ identifier ] != 0x0 ) ; identifierToParentIdentifier [ identifier ] = parentIdentifier ; }
","Set the parent collectible of a collectible .
"
"function changeHolderPercentage ( uint256 _maxHolderPercentage ) public onlyOwner { emit LogModifyHolderPercentage ( maxHolderPercentage , _maxHolderPercentage ) ; maxHolderPercentage = _maxHolderPercentage ; }
","sets the maximum percentage that an individual token holder can hold
"
"function increaseApproval ( address _spender , uint256 _addedValue ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) ) ; return super . increaseApproval ( _spender , _addedValue ) ; }
","Increases the approval of the spender .
"
"function _safeTransfer ( address _to , uint _amount ) internal { require ( _to != 0 ) ; _to . transfer ( _amount ) ; }
","` _safeTransfer ` is used internally when transfer funds safely .
"
"function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { balance = TokenInfoController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_INFO ) ) . get_balance ( _owner ) ; }
","display balance of given account
"
"function finalize ( ) public initialized { require ( getBlockNumber ( ) >= startBlock ) ; require ( msg . sender == owner || getBlockNumber ( ) > endBlock ) ; require ( finalizedBlock == 0 ) ; require ( dynamicCeiling . allRevealed ( ) ) ; if ( getBlockNumber ( ) <= endBlock ) { var ( , lastLimit , , ) = dynamicCeiling . curves ( dynamicCeiling . revealedCurves ( ) . sub ( 1 ) ) ; require ( totalNormalCollected >= lastLimit ) ; } finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; uint256 percentageToSgt ; if ( SGT . totalSupply ( ) >= maxSGTSupply ) { percentageToSgt = percent ( 10 ) ; } else { percentageToSgt = percent ( 10 ) . mul ( SGT . totalSupply ( ) ) . div ( maxSGTSupply ) ; } uint256 percentageToDevs = percent ( 20 ) ; uint256 percentageToContributors = percent ( 41 ) . add ( percent ( 10 ) . sub ( percentageToSgt ) ) ; uint256 percentageToReserve = percent ( 29 ) ; uint256 totalTokens = SNT . totalSupply ( ) . mul ( percent ( 100 ) ) . div ( percentageToContributors ) ; assert ( SNT . generateTokens ( destTokensReserve , totalTokens . mul ( percentageToReserve ) . div ( percent ( 100 ) ) ) ) ; assert ( SNT . generateTokens ( destTokensSgt , totalTokens . mul ( percentageToSgt ) . div ( percent ( 100 ) ) ) ) ; assert ( SNT . generateTokens ( destTokensDevs , totalTokens . mul ( percentageToDevs ) . div ( percent ( 100 ) ) ) ) ; SNT . changeController ( sntController ) ; Finalized ( ) ; }
","This method will can be called by the owner before the contribution period end or by anybody after the ` endBlock ` .
"
"function create ( uint256 baseUnits ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ + baseUnits ) > totalSupply_ ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 amount = baseUnits . div ( creationUnit_ ) . mul ( token . quantity ) ; require ( erc20 . transferFrom ( msg . sender , address ( this ) , amount ) ) ; } mint ( msg . sender , baseUnits ) ; }
","Creates Bskt tokens in exchange for underlying tokens .
"
"function __callback ( bytes32 _requestId , string _result ) public { require ( msg . sender == oraclize_cbAddress ( ) , ""Only Oraclize can access this method"" ) ; require ( ! freezeOracle , ""Oracle is frozen"" ) ; require ( ! ignoreRequestIds [ _requestId ] , ""Ignoring requestId"" ) ; if ( requestIds [ _requestId ] < latestUpdate ) { emit LogStalePriceUpdate ( _requestId , requestIds [ _requestId ] , _result ) ; return ; } require ( requestIds [ _requestId ] >= latestUpdate , ""Result is stale"" ) ; require ( requestIds [ _requestId ] <= now + oraclizeTimeTolerance , ""Result is early"" ) ; uint256 newPOLYUSD = parseInt ( _result , 18 ) ; uint256 bound = POLYUSD . mul ( sanityBounds ) . div ( 10 ** 18 ) ; if ( latestUpdate != 0 ) { require ( newPOLYUSD <= POLYUSD . add ( bound ) , ""Result is too large"" ) ; require ( newPOLYUSD >= POLYUSD . sub ( bound ) , ""Result is too small"" ) ; } latestUpdate = requestIds [ _requestId ] ; emit LogPriceUpdated ( newPOLYUSD , POLYUSD , _requestId , latestUpdate ) ; POLYUSD = newPOLYUSD ; }
","Oraclize callback ( triggered by Oraclize )
"
"function ownerOf ( uint256 _tokenId ) external view mustBeValidToken ( _tokenId ) returns ( address _owner ) { _owner = _tokenOwnerWithSubstitutions [ _tokenId ] ; if ( _owner == address ( 0 ) ) { _owner = address ( this ) ; } }
","Find the owner of an NFT
"
"function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 1 days ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 3 ) ) ) { require ( collectedTokens < total . percent ( 40 ) ) ; canExtract = total . percent ( 40 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 3 ) ) && getTime ( ) <= finalizedTime . add ( months ( 6 ) ) ) { require ( collectedTokens < total . percent ( 60 ) ) ; canExtract = total . percent ( 60 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 6 ) ) && getTime ( ) <= finalizedTime . add ( months ( 9 ) ) ) { require ( collectedTokens < total . percent ( 80 ) ) ; canExtract = total . percent ( 80 ) ; } else { require ( collectedTokens < total ) ; canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }
","The owner will call this method to extract the tokens
"
"function tokenOfCreatorByIndex ( address _creator , uint256 _index ) public view validAddress ( _creator ) returns ( uint256 ) { require ( _index < createdTokens [ _creator ] . length , ""Index is out of bounds"" ) ; PixelCon storage pixelcon = pixelcons [ createdTokens [ _creator ] [ _index ] ] ; return pixelcon . tokenId ; }
","Enumerate PixelCon created by ` ( _creator ) `
"
"function shutForDai ( uint _id ) public auth stoppable { bytes32 id = bytes32 ( _id ) ; uint debt = tub . tab ( id ) ; if ( debt > 0 ) { require ( dai . transferFrom ( msg . sender , this , debt ) ) ; } uint ink = tub . ink ( id ) ; tub . shut ( id ) ; uint gemBalance = tub . bid ( ink ) ; tub . exit ( ink ) ; uint price = uint ( feed . read ( ) ) ; uint bought = otc . sellAllAmount ( gem , min ( gemBalance , gem . balanceOf ( this ) ) , dai , wmul ( WAD - slippage , wmul ( gemBalance , price ) ) ) ; require ( dai . transfer ( msg . sender , bought ) ) ; }
","shuts the CDP and returns all the value in the form of Dai .
"
"function notifyOfArbitrationRequest ( bytes32 question_id , address requester , uint256 max_previous ) external { }
","Notify the contract that the arbitrator has been paid for a question , freezing it pending their decision .
"
"function transfer ( address _to , uint256 _amount ) onlyPayloadSize ( 2 * 32 ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; return doTransfer ( msg . sender , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function changeController ( address _newController ) onlyController { controller = _newController ; }
","Changes the controller of the contract
"
"function release ( address _sender , address _recipient , uint256 _transactionId , uint256 _exchangeRate ) public { Lock memory lock = escrows [ msg . sender ] [ _transactionId ] ; require ( lock . expiration != 1 ) ; require ( lock . sender == _sender ) ; require ( lock . recipient == _recipient || lock . sender == _recipient ) ; require ( lock . paid ) ; if ( lock . fee > 0 && lock . recipient == _recipient ) { token . transfer ( _recipient , lock . value ) ; token . transfer ( msg . sender , lock . fee ) ; } else { token . transfer ( _recipient , lock . value . add ( lock . fee ) ) ; } delete escrows [ msg . sender ] [ _transactionId ] ; token . issueExchangeRate ( _sender , _recipient , msg . sender , lock . value , _transactionId , _exchangeRate ) ; Released ( msg . sender , _recipient , _transactionId ) ; }
","Exchange rate has 18 decimal places
"
"function claim ( ) public vaultUnlocked returns ( bool ) { return _transferTokens ( msg . sender ) ; }
","Claim whatever tokens account are allocated to the sender .
"
"function validateTranscriptHash ( address _student , uint _docIndx , bytes32 _transcriptHash ) public view returns ( bool ) { Certification storage certification = studentCertifications [ _student ] ; return ( certification . documents [ _docIndx ] ) . validateTranscriptHash ( _transcriptHash ) ; }
","Validate Transcript Hash alone of a student
"
"function getLocksLength ( ) external view returns ( uint ) { return locks . length ; }
","The the total number of locks
"
"function changeModuleBudget ( address _module , uint256 _change , bool _increase ) external onlyOwner { require ( modulesToData [ _module ] . module != address ( 0 ) , ""Module missing"" ) ; uint256 currentAllowance = IERC20 ( polyToken ) . allowance ( address ( this ) , _module ) ; uint256 newAllowance ; if ( _increase ) { require ( IERC20 ( polyToken ) . increaseApproval ( _module , _change ) , ""IncreaseApproval fail"" ) ; newAllowance = currentAllowance . add ( _change ) ; } else { require ( IERC20 ( polyToken ) . decreaseApproval ( _module , _change ) , ""Insufficient allowance"" ) ; newAllowance = currentAllowance . sub ( _change ) ; } emit ModuleBudgetChanged ( modulesToData [ _module ] . moduleTypes , _module , currentAllowance , newAllowance ) ; }
","allows owner to increase/decrease POLY approval of one of the modules
"
"function pruneInvestors ( uint256 _start , uint256 _iters ) public onlyOwner { for ( uint256 i = _start ; i < Math . min256 ( _start . add ( _iters ) , investors . length ) ; i ++ ) { if ( ( i < investors . length ) && ( balanceOf ( investors [ i ] ) == 0 ) ) { investorListed [ investors [ i ] ] = false ; investors [ i ] = investors [ investors . length - 1 ] ; investors . length -- ; } } }
","removes addresses with zero balances from the investors list
"
"function onTransfer ( address _from , address _to , uint256 _amount ) public returns ( bool ) { hodlerReward . invalidate ( _from ) ; return ! paused || _from == address ( this ) || _to == address ( this ) || _from == address ( crowdsale ) || _to == address ( crowdsale ) ; }
","Before transfers are enabled for everyone , only this and the crowdsale contract is allowed to distribute HEAL
"
"function tip ( address _to , uint _amount ) public { require ( _to != 0x0 ) ; require ( _amount > 0 ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _amount ) ; emit TipMade ( msg . sender , _to , _amount ) ; DAI . transferFrom ( msg . sender , _to , _amount ) ; }
","this function lets any registered address send DAI tokens to any other address
"
"function canAddAttribute ( uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) ;
","Check if a given signed attribute approval is currently valid when submitted directly by ` msg.sender ` .
"
"function addMinter ( address _who ) public onlyOwner returns ( bool ) { _setMinter ( _who , true ) ; }
","Adds the minter role to provided address
"
"function cancelMatch ( uint boardId ) external { GoBoard storage board = allBoards [ boardId ] ; require ( isPlayerOnBoard ( boardId , msg . sender ) ) ; require ( board . status == BoardStatus . WaitForOpponent ) ; updateBoardStatus ( board , boardId , BoardStatus . Canceled ) ; }
","This function allows a player to cancel a match in the case they were waiting for an opponent for a long time but did n't find anyone and would want to get their deposit of table stakes back .
"
"function arbitrateApproveMilestone ( uint _idMilestone ) onlyArbitrator campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) && ( milestone . status != MilestoneStatus . Completed ) ) throw ; doPayment ( _idMilestone ) ; }
","` onlyArbitrator ` Forces a milestone to be paid out as long as it has not been paid or canceled
"
"function setToken ( address _token ) external timedStateChange requiresState ( IcoState . PAUSED ) onlymanyowners ( sha3 ( msg . data ) ) { require ( address ( 0 ) != _token ) ; m_token = STQToken ( _token ) ; }
","In case we need to attach to existent token
"
"function setFeeCharge ( uint64 _value ) public onlyOwner { require ( _value <= feeChargeMax , ""can not increase fee charge over it's limit"" ) ; uint64 oldValue = feeCharge ; feeCharge = _value ; emit FeeCharge ( oldValue , _value ) ; }
","Not for public use !
"
"function supportsInterface ( bytes4 _interfaceID ) public view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) ) ; }
","Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
"
"function close ( ) onlyICOContract public returns ( bool ) { if ( state != State . Active ) { error ( 'close: state != State.Active' ) ; return false ; } state = State . Closed ; walletFounder1 . transfer ( address ( this ) . balance . mul ( 33 ) . div ( 100 ) ) ; walletFounder2 . transfer ( address ( this ) . balance . mul ( 50 ) . div ( 100 ) ) ; walletFounder3 . transfer ( address ( this ) . balance ) ; emit Closed ( ) ; return true ; }
","When ICO finalizes funds are transferred to founders ' wallets
"
"function deposit ( Data storage self , uint256 amount ) senderOnly ( self ) returns ( bool success , uint256 balance ) { require ( self . opened > 0 ) ; require ( self . closed == 0 ) ; StandardToken token = self . manager . token ( ) ; require ( token . balanceOf ( msg . sender ) >= amount ) ; success = token . transferFrom ( msg . sender , this , amount ) ; if ( success == true ) { self . balance += amount ; return ( true , self . balance ) ; } return ( false , 0 ) ; }
","Sender deposits amount to channel .
"
"function provideProofOfWork ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender == job . worker ) ; job . proofOfLastWorkVerified = false ; emit ProofOfWorkProvided ( _JobID , msg . sender , true ) ; }
","this function lets the worker provide proof of work
"
"function ( ) payable { require ( ! crowdsaleCanceled ) ; require ( msg . value > 0 ) ; require ( block . timestamp >= START_DATE && block . timestamp <= END_DATE ) ; uint256 quantity = safeDiv ( safeMul ( msg . value , CROWDSALE_PRICE ) , 10 ** ( 18 - uint256 ( decimals ) ) ) ; require ( safeSub ( balances [ this ] , quantity ) >= 0 ) ; require ( MULTISIG_WALLET_ADDRESS . send ( msg . value ) ) ; balances [ this ] = safeSub ( balances [ this ] , quantity ) ; balances [ msg . sender ] = safeAdd ( balances [ msg . sender ] , quantity ) ; soldAmount = safeAdd ( soldAmount , quantity ) ; paidAmount = safeAdd ( paidAmount , msg . value ) ; Transfer ( this , msg . sender , quantity ) ; }
","` msg.sender ` invest ` msg.value `
"
"function changeFactoryUsageFee ( uint256 _newUsageCost ) public onlyOwner { emit ChangeFactoryUsageFee ( usageCost , _newUsageCost , address ( this ) ) ; usageCost = _newUsageCost ; }
","Used to change the fee of the usage cost
"
"function sellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _seller , ""Must be seller"" ) ; return doSellerCancel ( _tradeID , _seller , _buyer , _value , _fee , 0 ) ; }
","Cancel the escrow as a seller .
"
"function initialize ( WBC _wbc , address raiseAcc , address team1Acc , address team2Acc , address team3Acc ) public onlyOwner { require ( blockTime ( ) >= startTime ) ; require ( _wbc . owner ( ) == address ( this ) ) ; require ( raiseAcc != 0 && team1Acc != 0 && team2Acc != 0 && team3Acc != 0 ) ; wbc = _wbc ; raiseAccount = raiseAcc ; team1Account = team1Acc ; team2Account = team2Acc ; team3Account = team3Acc ; mintToTeamAccounts ( ) ; initialized = true ; emit onInitialized ( ) ; }
","initialize to prepare for sale
"
"function multiCallTightlyPacked ( bytes32 [ ] _addressesAndAmounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addressesAndAmounts . length ; i ++ ) { address to = address ( _addressesAndAmounts [ i ] >> 96 ) ; uint amount = uint ( uint96 ( _addressesAndAmounts [ i ] ) ) ; _safeCall ( to , amount ) ; MultiCall ( msg . sender , msg . value , to , amount ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }
","Call to multiple contracts using a byte32 array which includes the contract address and the amount .
"
"function getFinalAnswer ( bytes32 question_id ) external view returns ( bytes32 ) { }
","( Deprecated ) Return the final answer to the specified question , or revert if there is n't one
"
"function decimals ( ) external constant returns ( uint8 _decimals ) { return decimals ; }
","Check the decimals of the token ~ ERC-20 Standard
"
"function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < TOTAL_SUPPLY ) ; return _index + 1 ; }
","Enumerate valid NFTs
"
"function calculate_shares_and_return ( uint _shares_count , uint _share_price , uint _transfer_valuation , uint _final_share_price , uint _art_price , uint transfer_token ) view public returns ( uint _shares_to_assign , uint _executed_amount_valuation , uint _return_amount ) { if ( assigned_shares . add ( _shares_count ) > max_shares_to_sell ) { _shares_to_assign = max_shares_to_sell . sub ( assigned_shares ) ; } else { _shares_to_assign = _shares_count ; } _executed_amount_valuation = _shares_to_assign . mul ( _final_share_price ) ; if ( final_fundraise . add ( _executed_amount_valuation ) > fundraise_max ) { _executed_amount_valuation = fundraise_max . sub ( final_fundraise ) ; _shares_to_assign = _executed_amount_valuation . div ( _final_share_price ) ; _executed_amount_valuation = _shares_to_assign . mul ( _final_share_price ) ; } uint _executed_amount = convert_valuation_to_art ( _executed_amount_valuation , _art_price ) ; _return_amount = transfer_token . sub ( _executed_amount ) ; }
","Calculates how many shares are assigned to a bid .
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = ownerAddressToCardCount [ _owner ] ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 total = totalNumberOfCards ( ) ; uint256 resultIndex = 0 ; uint256 cardId ; for ( cardId = 1 ; cardId <= total ; cardId ++ ) { if ( cardIdToOwner [ cardId ] == _owner ) { result [ resultIndex ] = cardId ; resultIndex ++ ; } } return result ; }
","Returns a list of all Card IDs currently owned by ` _owner `
"
"function batchSetApprovalForAll ( address [ ] _spenders , bool _approved ) public { require ( isBatchSupported ) ; require ( _spenders . length > 0 ) ; address _spender ; for ( uint256 i = 0 ; i < _spenders . length ; ++ i ) { require ( address ( _spenders [ i ] ) != address ( 0 ) ) ; _spender = _spenders [ i ] ; setApprovalForAll ( _spender , _approved ) ; } }
","Facilitates batch approveAll
"
"function getOrganizations ( ) external view returns ( address [ ] accounts ) { return _organizationAccounts ; }
","Get the accounts of all available organizations .
"
"function indexOf ( string source , string query , uint256 fromIndex ) internal pure returns ( int256 ) { bytes memory sourceBytes = bytes ( source ) ; bytes memory queryBytes = bytes ( query ) ; if ( queryBytes . length == 0 ) { return 0 ; } if ( sourceBytes . length < queryBytes . length ) { return - 1 ; } for ( uint256 i = fromIndex ; i < sourceBytes . length - queryBytes . length ; i ++ ) { uint256 j = 0 ; while ( j < queryBytes . length && queryBytes [ j ] == sourceBytes [ j + i ] ) { j ++ ; } if ( j == queryBytes . length ) { return int256 ( i ) ; } } return - 1 ; }
","Returns the index within source ASCII string of the first occurrence of the query substring , starting at the specified index .
"
"function getMinInvestment ( ) public pure returns ( uint ) { return 10 finney ; }
","minimal amount of one investment ( in wei )
"
"function synthetixReceivedForSynths ( uint amount ) public view returns ( uint ) { uint synthsReceived = feePool . amountReceivedFromTransfer ( amount ) ; return synthsReceived . divideDecimal ( usdToSnxPrice ) ; }
","Calculate how many SNX you will receive if you transfer an amount of synths .
"
"function assignTokens ( address addr , uint amount ) internal returns ( uint ) { require ( addr != 0x0 ) ; require ( initialTokensAssigned == false ) ; balances [ addr ] = amount ; Transfer ( 0x0 , addr , balances [ addr ] ) ; return balances [ addr ] ; }
","It will be automatically called on deploy .
"
"function setSize ( uint256 _size ) public onlyOwner returns ( bool ) { size = _size ; return true ; }
","Change size of bucket
"
"function buyWithETH ( address _beneficiary ) public payable validETH { uint256 rate = getRate ( FundRaiseType . ETH ) ; ( uint256 spentUSD , uint256 spentValue ) = _buyTokens ( _beneficiary , msg . value , rate , FundRaiseType . ETH ) ; investorInvested [ _beneficiary ] [ uint8 ( FundRaiseType . ETH ) ] = investorInvested [ _beneficiary ] [ uint8 ( FundRaiseType . ETH ) ] . add ( spentValue ) ; fundsRaised [ uint8 ( FundRaiseType . ETH ) ] = fundsRaised [ uint8 ( FundRaiseType . ETH ) ] . add ( spentValue ) ; wallet . transfer ( spentValue ) ; msg . sender . transfer ( msg . value . sub ( spentValue ) ) ; emit FundsReceived ( msg . sender , _beneficiary , spentUSD , FundRaiseType . ETH , msg . value , spentValue , rate ) ; }
","Purchase tokens using ETH
"
"function calculateGrantClaim ( address _recipient ) public view returns ( uint256 , uint256 ) { Grant storage tokenGrant = tokenGrants [ _recipient ] ; if ( currentTime ( ) < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint256 elapsedTime = currentTime ( ) . sub ( tokenGrant . startTime ) ; uint256 elapsedYears = elapsedTime . div ( SECONDS_PER_YEAR ) ; if ( elapsedYears >= tokenGrant . vestingDuration ) { uint256 remainingGrant = tokenGrant . amount . sub ( tokenGrant . totalClaimed ) ; uint256 remainingYears = tokenGrant . vestingDuration . sub ( tokenGrant . yearsClaimed ) ; return ( remainingYears , remainingGrant ) ; } else { uint256 i = 0 ; uint256 tokenGrantAmount = tokenGrant . amount ; uint256 totalVested = 0 ; for ( i ; i < elapsedYears ; i ++ ) { totalVested = ( tokenGrantAmount . mul ( 10 ) ) . div ( 100 ) . add ( totalVested ) ; tokenGrantAmount = tokenGrant . amount . sub ( totalVested ) ; } uint256 amountVested = totalVested . sub ( tokenGrant . totalClaimed ) ; return ( elapsedYears , amountVested ) ; } }
","Calculate the vested and unclaimed months and tokens available for ` _grantId ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached
"
"function challengeWinnerReward ( uint _challengeID ) public view returns ( uint ) { if ( voting . getTotalNumberOfTokensForWinningOption ( _challengeID ) == 0 ) { return 2 * challenges [ _challengeID ] . stake ; } return ( 2 * challenges [ _challengeID ] . stake ) - challenges [ _challengeID ] . rewardPool ; }
","Determines the number of tokens to awarded to the winning party in a challenge
"
"function setFreeClaimAllowance ( address addr , uint256 allowance ) external onlyCFO { freeClaimAllowance [ addr ] = allowance ; }
","Set the free claim allowance for an address .
"
"function getVote ( uint _idPoll , address _voter ) public view returns ( uint [ 15 ] votes ) { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll storage p = _polls [ _idPoll ] ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { votes [ i ] = p . ballots [ i ] [ _voter ] ; } return votes ; }
","Get votes for poll/ballot
"
"function sell ( uint256 amount ) public { address myAddress = this ; require ( myAddress . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
","Sell ` amount ` tokens to contract
"
"function handlePlannedWhitelistedContribution ( uint256 plannedContribution ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( plannedContribution ) ; AllowedContributionCheck ( plannedContribution , AllowedContributionState . Whitelisted ) ; return ( plannedContribution , 0 ) ; }
","Returns the contribution and refund value to be used when the transaction value equals the whitelisted contribution for the sender .
"
"function balanceOf ( address owner ) public view returns ( uint256 balance ) { return balances [ owner ] ; }
","Get the token balance of ` owner `
"
"function buySharesFor ( address _recipient ) payable ;
","Function to buy Dao shares according to the funding rules
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( msg . sender == owner || now > 1509467422 ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` in behalf of ` _from `
"
"function withdrawFees ( ) external optionalProxy { address sender = messageSender ; rolloverFeePeriodIfElapsed ( ) ; require ( ! nomin . frozen ( sender ) ) ; updateIssuanceData ( sender , nominsIssued [ sender ] , nomin . totalSupply ( ) ) ; require ( ! hasWithdrawnFees [ sender ] ) ; uint feesOwed ; uint lastTotalIssued = totalIssuanceData . lastAverageBalance ; if ( lastTotalIssued > 0 ) { feesOwed = safeDiv_dec ( safeMul_dec ( issuanceData [ sender ] . lastAverageBalance , lastFeesCollected ) , lastTotalIssued ) ; } hasWithdrawnFees [ sender ] = true ; if ( feesOwed != 0 ) { nomin . withdrawFees ( sender , feesOwed ) ; } emitFeesWithdrawn ( messageSender , feesOwed ) ; }
","Compute the last period 's fee entitlement for the message sender and then deposit it into their nomin account .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) public canTransfer ( _tokenId ) { require ( checkIsAttached ( _tokenId ) == 0 ) ; require ( _from != address ( 0 ) ) ; require ( _to != address ( 0 ) ) ; clearApproval ( _from , _tokenId ) ; removeTokenFrom ( _from , _tokenId ) ; addTokenTo ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }
","Helps in trasnferring assets
"
"function isReissuable ( bytes32 _symbol ) public view returns ( bool ) { return get ( store , assetIsReissuable , _symbol ) ; }
","Returns asset reissuability .
"
"function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes _data ) external returns ( bytes4 ) ;
","The contract address is always the message sender .
"
"function enableTransfers ( bool _transfersEnabled ) onlyOwner public { transfersEnabled = _transfersEnabled ; }
","Enables token holders to transfer their tokens freely if true
"
"function disown ( ) public onlyOwner ( ) { delete owner ; }
","Delete owner information
"
"function isExploring ( uint256 _tokenId ) public view returns ( bool ) { uint256 cooldown ; uint64 cooldownEndBlock ; ( , , , , , cooldownEndBlock , cooldown , ) = ethernautsStorage . assets ( _tokenId ) ; return ( cooldown > now ) || ( cooldownEndBlock > uint64 ( block . number ) ) ; }
","verify if token is in exploration time
"
"function createPool ( address [ ] _admins , uint256 [ ] _configsUint , bool [ ] _configsBool ) public returns ( address _pool ) { address poolOwner = msg . sender ; _pool = new Pool ( poolOwner , _admins , _configsUint , _configsBool , nextPoolId ) ; pools [ nextPoolId ] = _pool ; nextPoolId = nextPoolId . add ( 1 ) ; emit PoolCreated ( nextPoolId , poolOwner ) ; }
","Creates a new pool with custom configurations .
"
"function distributeVariable ( uint index , address [ ] _addrs , uint [ ] _vals ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _vals [ i ] ) ; } } else revert ( ""Distribution Failed: Count Down not gone yet"" ) ; }
","Distirbutes a differen quantity of tokens to all the specified addresses .
"
"function name ( ) public constant returns ( string ) { }
","the campaign name
"
"function totalSupplyAt ( uint256 _blockNumber ) public view returns ( uint256 ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function unPause ( bytes32 _hash ) external pollApproved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) notBeforeGenesis { if ( paused ) { paused = false ; LogUnPause ( _hash ) ; } }
","Unpause the contract operations
"
"function setController ( address _controller ) public onlyOwner { require ( ! controllerDisabled ) ; emit SetController ( controller , _controller ) ; controller = _controller ; }
","Used by the issuer to set the controller addresses
"
"function init ( address _token , address _plcr , uint [ ] _parameters ) public { require ( _token != 0 && address ( token ) == 0 ) ; require ( _plcr != 0 && address ( voting ) == 0 ) ; token = EIP20Interface ( _token ) ; voting = PLCRVoting ( _plcr ) ; set ( ""minDeposit"" , _parameters [ 0 ] ) ; set ( ""pMinDeposit"" , _parameters [ 1 ] ) ; set ( ""applyStageLen"" , _parameters [ 2 ] ) ; set ( ""pApplyStageLen"" , _parameters [ 3 ] ) ; set ( ""commitStageLen"" , _parameters [ 4 ] ) ; set ( ""pCommitStageLen"" , _parameters [ 5 ] ) ; set ( ""revealStageLen"" , _parameters [ 6 ] ) ; set ( ""pRevealStageLen"" , _parameters [ 7 ] ) ; set ( ""dispensationPct"" , _parameters [ 8 ] ) ; set ( ""pDispensationPct"" , _parameters [ 9 ] ) ; set ( ""voteQuorum"" , _parameters [ 10 ] ) ; set ( ""pVoteQuorum"" , _parameters [ 11 ] ) ; set ( ""exitTimeDelay"" , _parameters [ 12 ] ) ; set ( ""exitPeriodLen"" , _parameters [ 13 ] ) ; }
","_parameters array of canonical parameters
"
"function balanceOf ( address _owner ) public constant returns ( uint256 bal ) { return balances [ _owner ] ; }
","Get the balance of an _owner address .
"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 _amount ) { return allowance [ _owner ] [ _spender ] ; }
","Used to look up the allowance of someone
"
"function getCollectible ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = tokenIndexToPrice [ _tokenId ] ; owner = tokenIndexToOwner [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = getInitialPriceOfToken ( _tokenId ) ; nextSellingPrice = getNextPrice ( sellingPrice ) ; }
","Returns all the relevant information about a specific collectible .
"
"function addCZRLock ( address addr , uint startLockTime , uint amount , uint lockMonth ) onlyOwner public { require ( amount > 0 ) ; if ( startLockTime == 0 ) startLockTime = now ; lockedCZRMap [ addr ] . push ( LockedCZR ( startLockTime , lockMonth , amount , 0 ) ) ; uint index = lockedCZRMap [ addr ] . length - 1 ; AddLock ( addr , index , startLockTime , lockMonth , amount ) ; }
","add CZR lock
"
"function trust ( address _to ) public returns ( uint ) { uint fromId = _createHolderId ( msg . sender ) ; if ( fromId == getHolderId ( _to ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( isTrusted ( msg . sender , _to ) ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_ALREADY_TRUSTED ) ; } set ( store , holdersTrustStorage , fromId , _to , true ) ; return OK ; }
","Trust an address to perform recovery procedure for the caller .
"
"function isSaleLive ( ) public constant returns ( bool ) { return ( initialized == true && getPhase ( ) != 0 && goalReached ( ) == false ) ; }
","Checks if the sale is Live .
"
"function createSellOrder ( address token , uint tokensTotal , uint ethersTotal , uint8 [ ] exchanges , address [ 5 ] [ ] orderAddresses , uint [ 6 ] [ ] orderValues , uint [ ] exchangeFees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s ) public { require ( Token ( token ) . transferFrom ( msg . sender , this , tokensTotal ) ) ; uint ethersObtained ; uint tokensSold ; uint tokensRefunded = tokensTotal ; ( ethersObtained , tokensSold ) = fillOrdersForSellRequest ( tokensTotal , exchanges , orderAddresses , orderValues , exchangeFees , v , r , s ) ; require ( ethersObtained > 0 && tokensSold > 0 ) ; require ( SafeMath . safeDiv ( ethersTotal , tokensTotal ) <= SafeMath . safeDiv ( ethersObtained , tokensSold ) ) ; tokensRefunded = SafeMath . safeSub ( tokensTotal , tokensSold ) ; if ( tokensRefunded > 0 ) require ( Token ( token ) . transfer ( msg . sender , tokensRefunded ) ) ; transfer ( msg . sender , ethersObtained ) ; FillSellOrder ( msg . sender , token , tokensTotal , ethersTotal , tokensSold , ethersObtained , tokensRefunded ) ; }
","Needs first to call Token ( tokend_address ) .approve ( this , tokens_ ) so the contract can trade the tokens .
"
"function execScript ( bytes _script , bytes , address [ ] _blacklist ) external isInitialized returns ( bytes ) { uint256 location = SCRIPT_START_LOCATION ; while ( location < _script . length ) { address contractAddress = _script . addressAt ( location ) ; for ( uint i = 0 ; i < _blacklist . length ; i ++ ) { require ( contractAddress != _blacklist [ i ] , ERROR_BLACKLISTED_CALL ) ; } emit LogScriptCall ( msg . sender , address ( this ) , contractAddress ) ; uint256 calldataLength = uint256 ( _script . uint32At ( location + 0x14 ) ) ; uint256 startOffset = location + 0x14 + 0x04 ; uint256 calldataStart = _script . locationOf ( startOffset ) ; location = startOffset + calldataLength ; require ( location <= _script . length , ERROR_INVALID_LENGTH ) ; bool success ; assembly { success := call ( sub ( gas , 5000 ) , contractAddress , 0 , calldataStart , calldataLength , 0 , 0 ) } require ( success , ERROR_CALL_REVERTED ) ; } }
","Executes a number of call scripts
"
"function getChampsForSale ( ) view external returns ( uint256 [ ] ) { uint256 [ ] memory result = new uint256 [ ] ( champsForSaleCount ) ; if ( champsForSaleCount > 0 ) { uint256 counter = 0 ; for ( uint256 i = 0 ; i < champs . length ; i ++ ) { if ( champs [ i ] . forSale == true ) { result [ counter ] = i ; counter ++ ; } } } return result ; }
","Gets all champs for sale
"
"function getCampaign ( bytes32 _campaignId ) public view returns ( bytes32 _bidId , uint _price , uint _budget , uint _startDate , uint _endDate , bool _valid , address _campOwner ) { CampaignLibrary . Campaign storage campaign = _getCampaign ( _campaignId ) ; return ( campaign . getBidId ( ) , campaign . getPrice ( ) , campaign . getBudget ( ) , campaign . getStartDate ( ) , campaign . getEndDate ( ) , campaign . getValidity ( ) , campaign . getOwner ( ) ) ; }
","Get a Campaign information Based on a camapaign Id ( bidId ) , returns all stored information for that campaign .
"
"function unpause ( ) onlyOwner whenPaused public { require ( ! retired ) ; paused = false ; Unpause ( ) ; }
","unpause the contract
"
"function newChannel ( Data storage self , address partner , uint settle_timeout ) returns ( address ) { address [ ] storage caller_channels = self . nodeaddress_to_channeladdresses [ msg . sender ] ; address [ ] storage partner_channels = self . nodeaddress_to_channeladdresses [ partner ] ; bytes32 party_hash = partyHash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; address new_channel_address = new NettingChannelContract ( self . token , msg . sender , partner , settle_timeout ) ; if ( channel_pos != 0 ) { address settled_channel = self . all_channels [ channel_pos - 1 ] ; require ( ! contractExists ( settled_channel ) ) ; uint caller_pos = self . node_index [ msg . sender ] [ partner ] ; uint partner_pos = self . node_index [ partner ] [ msg . sender ] ; self . all_channels [ channel_pos - 1 ] = new_channel_address ; caller_channels [ caller_pos - 1 ] = new_channel_address ; partner_channels [ partner_pos - 1 ] = new_channel_address ; } else { self . all_channels . push ( new_channel_address ) ; caller_channels . push ( new_channel_address ) ; partner_channels . push ( new_channel_address ) ; self . partyhash_to_channelpos [ party_hash ] = self . all_channels . length ; self . node_index [ msg . sender ] [ partner ] = caller_channels . length ; self . node_index [ partner ] [ msg . sender ] = partner_channels . length ; } return new_channel_address ; }
","Create a new payment channel between two parties
"
"function adminSetLock ( bool _lock , bool _allowPurchase ) public onlyAdmin { if ( _lock ) { if ( _allowPurchase ) systemLock = LOCK_NO_LISTING ; else systemLock = LOCK_REMOVE_ONLY ; } else { systemLock = LOCK_NONE ; } }
","Set the lock state of the market
"
"function openOrder ( uint64 _settlementID , bytes _signature , bytes32 _orderID ) external { require ( orders [ _orderID ] . state == OrderState . Undefined , ""invalid order status"" ) ; address trader = msg . sender ; require ( settlementRegistry . settlementRegistration ( _settlementID ) , ""settlement not registered"" ) ; BrokerVerifier brokerVerifier = settlementRegistry . brokerVerifierContract ( _settlementID ) ; require ( brokerVerifier . verifyOpenSignature ( trader , _signature , _orderID ) , ""invalid broker signature"" ) ; orders [ _orderID ] = Order ( { state : OrderState . Open , trader : trader , confirmer : 0x0 , settlementID : _settlementID , priority : orderbook . length + 1 , blockNumber : block . number , matchedOrder : 0x0 } ) ; orderbook . push ( _orderID ) ; }
","Open an order in the orderbook .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . value == 0 ) ; _transferFrom ( _from , _to , _tokenId ) ; }
","Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` in behalf of ` _from `
"
"function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 6700000000 ; }
","maximum investments to be accepted during the sale ( in euro-cents )
"
"function pickRandomAssets ( uint _finalSeed , bytes32 [ ] _potentialAssets ) public pure returns ( uint [ ] finalPicked ) { require ( _finalSeed != 0 ) ; require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetIds = decodeAssets ( _potentialAssets ) ; uint [ ] memory pickedIds = new uint [ ] ( assetIds . length ) ; uint finalSeedCopy = _finalSeed ; uint index = 0 ; for ( uint i = 0 ; i < assetIds . length ; i ++ ) { finalSeedCopy = uint ( keccak256 ( abi . encodePacked ( finalSeedCopy , assetIds [ i ] ) ) ) ; if ( finalSeedCopy % 2 == 0 ) { pickedIds [ index ] = assetIds [ i ] ; index ++ ; } } finalPicked = new uint [ ] ( index ) ; for ( i = 0 ; i < index ; i ++ ) { finalPicked [ i ] = pickedIds [ i ] ; } }
","Function to pick random assets from potentialAssets array
"
"function setup ( address _token_address ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _token_address != 0x0 ) ; token = GoToken ( _token_address ) ; num_tokens_auctioned = token . balanceOf ( address ( this ) ) ; token_multiplier = 10 ** ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; }
","Set `` _token_address '' as the token address to be used in the auction .
"
"function addBurningMan ( address _burningMan , uint _block ) public returns ( uint _code ) { if ( burningMans [ _burningMan ] ) { return _emitError ( SERVICE_CONTROLLER_BURNING_MAN_EXIST ) ; } _code = _multisig ( keccak256 ( _burningMan ) , _block ) ; if ( OK != _code ) { return _code ; } burningMans [ _burningMan ] = true ; uint _count = burningMansCount + 1 ; index2burningMan [ _count ] = _burningMan ; burningMan2index [ _burningMan ] = _count ; burningMansCount = _count ; return OK ; }
","Add burning man
"
"function enableTransfers ( bool _transfersEnabled ) onlyOwner { token . enableTransfers ( _transfersEnabled ) ; }
","Enables token holders to transfer their tokens freely if true
"
"function getInitFunction ( address _contractAddress ) external returns ( bytes4 ) { return USDTieredSTO ( _contractAddress ) . getInitFunction ( ) ; }
","Used to get the init function signature
"
"function addPackage ( string name , address repo ) onlyOwner public returns ( uint idPackage ) { idPackage = DAppNodePackages . length ++ ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; c . name = name ; c . repo = repo ; PackageAdded ( idPackage , name , repo ) ; }
","Add a new DAppNode package
"
"function bulkTokenSend ( address [ ] beneficiaries , uint256 [ ] amounts ) onlyOwner external { require ( beneficiaries . length == amounts . length ) ; for ( uint32 i = 0 ; i < beneficiaries . length ; i ++ ) { require ( token . transferFrom ( msg . sender , beneficiaries [ i ] , amounts [ i ] ) ) ; } }
","Bulk send tokens ( different amounts )
"
"function changeExchangeStatus ( bool newExchangeState ) public only_exchange_operator { IS_EXCHANGE_OPERATIONAL = newExchangeState ; }
","Changes the operational status of the exchange .
"
"function pauseSale ( ) public onlyController { require ( campaignState == 2 ) ; paused = true ; CampaignPausd ( now ) ; }
","Pause sale just in case we have some troubles Note that time marks are not updated
"
"function getCanvasByState ( uint8 _state ) external view returns ( uint32 [ ] ) { uint size ; if ( _state == STATE_NOT_FINISHED ) { size = activeCanvasCount ; } else { size = getCanvasCount ( ) - activeCanvasCount ; } uint32 [ ] memory result = new uint32 [ ] ( size ) ; uint currentIndex = 0 ; for ( uint32 i = 0 ; i < canvases . length ; i ++ ) { if ( getCanvasState ( i ) == _state ) { result [ currentIndex ] = i ; currentIndex ++ ; } } return _slice ( result , 0 , currentIndex ) ; }
","Returns all canvas ' id for a given state .
"
"function isWhitelisted ( address _stablecoin ) public view returns ( bool ) { return tokenStorage_CD . whitelist ( _stablecoin ) ; }
","Check if whitelisted token is whitelisted
"
"function setReadOnly ( bool enabled ) public onlyOwner { readOnly = enabled ; }
","Allow admins to ( en|dis ) able all write functionality for emergencies
"
"function register ( address _address , uint _timestamp , uint _gasLimit , uint _gasPrice ) external payable returns ( uint ) ;
","Registration requires the specified amount of ETH in value , to cover invoke bonus .
"
"function approve ( address _spender , uint _value ) returns ( bool success ) ;
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function claim ( ) public onlyOwner { require ( now >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( owner , amount ) ; }
","Transfers tokens held by timelock to owner .
"
"function transfer ( address _to , uint256 _amount ) public erc20 returns ( bool success ) { doSend ( msg . sender , _to , _amount , """" , msg . sender , """" , false ) ; return true ; }
","ERC20 backwards compatible transfer .
"
"function ownerClawback ( ) external onlyOwner { if ( now < OWNER_CLAWBACK_DATE ) revert ( ) ; if ( ! owner . send ( this . balance ) ) revert ( ) ; }
","The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract .
"
"function setProjectManager ( address _projectManager ) returns ( bool ) { if ( _projectManager == 0 || projectManager != 0 ) return ; projectManager = _projectManager ; return true ; }
","Function to set the project manager
"
"function add ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { uint256 c = a + b ; require ( c >= a , ""Error: Unsafe addition operation!"" ) ; return c ; }
","Adds two numbers , throws on overflow .
"
"function getParticipant ( uint256 _index ) public view returns ( address participantAddress , uint256 participantAnswerId ) { Participant storage p = participants [ _index ] ; participantAddress = p . user_address ; participantAnswerId = p . answer_id ; }
","Returns all the relevant information about a specific participant .
"
"function totalSupplyAt ( uint256 snapshotId ) public constant returns ( uint256 ) ;
","Total amount of tokens at a specific ` snapshotId ` .
"
"function configure ( uint256 _startTime , uint256 _endTime , uint256 _cap , uint256 _rate , uint8 _fundRaiseType , address _fundsReceiver ) public onlyFactory { require ( _rate > 0 , ""Rate of token should be greater than 0"" ) ; require ( _fundsReceiver != address ( 0 ) , ""Zero address is not permitted"" ) ; require ( _startTime >= now && _endTime > _startTime , ""Date parameters are not valid"" ) ; require ( _cap > 0 , ""Cap should be greater than 0"" ) ; startTime = _startTime ; endTime = _endTime ; cap = _cap ; rate = _rate ; wallet = _fundsReceiver ; _check ( _fundRaiseType ) ; }
","Function used to intialize the contract variables
"
"function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }
","Returns the total token supply .
"
"function setManualPrice ( uint256 _price ) public onlyOwner { emit SetManualPrice ( manualPrice , _price , now ) ; manualPrice = _price ; }
","Set a manual price .
"
"function _processPurchase ( address _beneficiary , uint256 _tokenAmount ) internal { if ( investors [ _beneficiary ] == 0 ) { investorCount = investorCount + 1 ; } investors [ _beneficiary ] = investors [ _beneficiary ] . add ( _tokenAmount ) ; _deliverTokens ( _beneficiary , _tokenAmount ) ; }
","Executed when a purchase has been validated and is ready to be executed .
"
"function burn ( uint256 _amount , bytes _data ) public onlyOwner { super . burn ( _amount , _data ) ; }
","Burns ` _amount ` tokens from ` msg.sender ` Silly example of overriding the ` burn ` function to only let the owner burn its tokens .
"
"function withdrawChamp ( uint _id ) external onlyOwnerOfChamp ( _id ) contractMinBalanceReached isChampWithdrawReady ( _id ) whenNotPaused { Champ storage champ = champs [ _id ] ; require ( champ . position <= 800 ) ; champ . withdrawCooldown = block . timestamp + 1 days ; uint256 withdrawal = getChampReward ( champ . position ) ; addressInfo [ msg . sender ] . withdrawal += withdrawal ; pendingWithdrawal += withdrawal ; }
","Withdraw champ 's reward
"
"function isTransferAgent ( address _address ) public constant onlyWhitelisted returns ( bool ) { return transferAgents [ _address ] ; }
","Checks if the specified address is a transfer agent .
"
"function approveForwardedAccount ( address originalAccount , address updatedAccount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setForwardedAccount ( originalAccount , updatedAccount ) , ""Error: Unable to set forwarded address for account. Please check issuerFirm and firm authority are registered"" ) ; return true ; }
","Updates to new forwarded account
"
"function getPreICOBonus ( ) internal constant returns ( uint ) { return 35 ; }
","pre-ICO bonus
"
"function setKYCApproval ( Data storage self , address account , bool isApproved , string issuerFirm ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.kyc' , getForwardedAccount ( self , account ) ) ) ; require ( self . Storage . setBool ( id , isApproved ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; emit KYCApproval ( account , isApproved , issuerFirm ) ; return true ; }
","Set the KYC approval status ( true/false ) for a given account
"
"function withdrawAll ( ) onlyOwner public { owner . transfer ( address ( this ) . balance ) ; }
","Withdraw ether to owner account
"
"function appendDecryptedBid ( uint _nonce , uint _index , uint _bid_id , address _investor_address , uint _share_price , uint _shares_count , uint _transfered_token ) onlyOwner public { require ( status == state . ended ) ; require ( fundraise_defined ) ; require ( bids [ _index ] . exist == true ) ; require ( bids [ _index ] . is_decrypted == false ) ; require ( bids [ _index ] . is_burned == false ) ; require ( _share_price > 0 ) ; require ( _shares_count > 0 ) ; require ( _transfered_token >= convert_valuation_to_art ( _shares_count . mul ( _share_price ) , bids [ _index ] . art_price ) ) ; if ( bids_sorted_count > 0 ) { BidData memory previous_bid_data = bids_sorted [ bids_sorted_count - 1 ] ; require ( _share_price <= previous_bid_data . share_price ) ; if ( _share_price == previous_bid_data . share_price ) { require ( _index > previous_bid_data . origin_index ) ; } } require ( getBidHash ( _nonce , _bid_id , _investor_address , _share_price , _shares_count ) == bids [ _index ] . bid_hash ) ; uint _transfer_amount = _share_price . mul ( _shares_count ) ; BidData memory bid_data = BidData ( _index , _bid_id , _investor_address , _share_price , _shares_count , _transfer_amount , _transfered_token , 0 , 0 , false ) ; bids [ _index ] . is_decrypted = true ; if ( _share_price >= min_share_price ) { bids [ _index ] . will_compute = true ; bids_sorted [ bids_sorted_count ] = bid_data ; bids_sorted_count ++ ; emit BidDecrypted ( _index , true ) ; } else { bids [ _index ] . will_compute = false ; bids_ignored [ bids_ignored_count ] = bid_data ; bids_ignored_count ++ ; emit BidDecrypted ( _index , false ) ; } bids_decrypted [ bids_decrypted_count ] = _index ; bids_decrypted_count ++ ; if ( bids_decrypted_count == bids_count ) { emit Decrypted ( block . number , bids_decrypted_count . sub ( bids_burned_count ) , bids_burned_count ) ; status = state . decrypted ; } }
","Appends the bid 's data to the contract , for use in the final calculations Once all bids are appended , the auction is locked and changes its state to `` decrypted ''
"
"function name ( ) public pure returns ( string _deedName ) { _deedName = ""DWorld Plots"" ; }
","Name of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata .
"
"function approve ( address spender , uint value ) public returns ( bool ) ;
","` msg.sender ` approves ` spender ` to spend ` value ` tokens
"
"function makeOrder ( uint exchangeNumber , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) external pre_cond ( isOwner ( ) ) pre_cond ( ! isShutDown ) { require ( buyAsset != address ( this ) ) ; require ( quantityHeldInCustodyOfExchange ( sellAsset ) == 0 ) ; require ( module . pricefeed . existsPriceOnAssetPair ( sellAsset , buyAsset ) ) ; var ( isRecent , referencePrice , ) = module . pricefeed . getReferencePrice ( sellAsset , buyAsset ) ; require ( isRecent ) ; require ( module . riskmgmt . isMakePermitted ( module . pricefeed . getOrderPrice ( sellAsset , buyAsset , sellQuantity , buyQuantity ) , referencePrice , sellAsset , buyAsset , sellQuantity , buyQuantity ) ) ; require ( isInAssetList [ buyAsset ] || ownedAssets . length < MAX_FUND_ASSETS ) ; require ( AssetInterface ( sellAsset ) . approve ( exchanges [ exchangeNumber ] . exchange , sellQuantity ) ) ; require ( address ( exchanges [ exchangeNumber ] . exchangeAdapter ) . delegatecall ( bytes4 ( keccak256 ( ""makeOrder(address,address,address,uint256,uint256)"" ) ) , exchanges [ exchangeNumber ] . exchange , sellAsset , buyAsset , sellQuantity , buyQuantity ) ) ; exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] = exchanges [ exchangeNumber ] . exchangeAdapter . getLastOrderId ( exchanges [ exchangeNumber ] . exchange ) ; require ( exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] != 0 ) ; isInOpenMakeOrder [ buyAsset ] = true ; if ( ! isInAssetList [ buyAsset ] ) { ownedAssets . push ( buyAsset ) ; isInAssetList [ buyAsset ] = true ; } orders . push ( Order ( { exchangeId : exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] , status : OrderStatus . active , orderType : OrderType . make , sellAsset : sellAsset , buyAsset : buyAsset , sellQuantity : sellQuantity , buyQuantity : buyQuantity , timestamp : now , fillQuantity : 0 } ) ) ; OrderUpdated ( exchangeIdsToOpenMakeOrderIds [ exchangeNumber ] [ sellAsset ] ) ; }
","Makes an order on the selected exchange
"
"function priceOf ( uint256 _productId ) public view returns ( uint256 ) { return products [ _productId ] . price ; }
","The price of a product
"
"function bid ( ) public payable atStage ( Stages . AuctionStarted ) { require ( msg . value > 0 ) ; require ( bids [ msg . sender ] + msg . value <= bid_threshold || whitelist [ msg . sender ] ) ; assert ( bids [ msg . sender ] + msg . value >= msg . value ) ; uint missing_funds = missingFundsToEndAuction ( ) ; require ( msg . value <= missing_funds ) ; bids [ msg . sender ] += msg . value ; received_wei += msg . value ; wallet_address . transfer ( msg . value ) ; BidSubmission ( msg . sender , msg . value , missing_funds ) ; assert ( received_wei >= msg . value ) ; }
","Send ` msg.value ` WEI to the auction from the ` msg.sender ` account .
"
"function proxyTransferWithReference ( address _to , uint _value , bytes32 _symbol , string _reference , address _sender ) onlyProxy ( _symbol ) public returns ( uint ) { return _transfer ( getHolderId ( _sender ) , _createHolderId ( _to ) , _value , _symbol , _reference , getHolderId ( _sender ) ) ; }
","Transfers asset balance between holders wallets .
"
"function batchCancelSale ( uint256 [ ] _tokenIds ) external whenNotPaused { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 ) ; for ( uint ii = 0 ; ii < _tokenIds . length ; ii ++ ) { Sale memory sale = tokenIdToSale [ _tokenIds [ ii ] ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _cancelSale ( _tokenIds [ ii ] , seller ) ; } }
","This is a state-modifying function that can be called while the contract is paused .
"
"function cost ( address , uint256 , bytes , bytes ) external view returns ( uint256 ) { return 0 ; }
","Returns the cost of the cosigner This cosigner does not have any risk or maintenance cost , so its free .
"
"function hasConfirmedRecord ( bytes32 _key ) public view returns ( uint ) { require ( _key != bytes32 ( 0 ) ) ; if ( ! isTxExist ( _key ) ) { return NO_RECORDS_WERE_FOUND ; } Guard storage _guard = txKey2guard [ _key ] ; return _guard . state == GuardState . InProcess ? PENDING_MANAGER_IN_PROCESS : _guard . state == GuardState . Confirmed ? OK : PENDING_MANAGER_REJECTED ; }
","Check transaction status
"
"function addTime ( address who , uint sconds ) public onlyTransferAgent returns ( bool ) { require ( sconds > 0 , ""Time added cannot be zero."" ) ; Holding memory holding = heldTokens [ who ] ; heldTokens [ who ] = Holding ( holding . quantity , holding . releaseDate . add ( sconds ) , holding . isAffiliate ) ; emit ReleaseDateExtended ( who , heldTokens [ who ] . releaseDate ) ; return true ; }
","The Transfer Agent may need to add time to the release date if they are unable to verify the holder in a timely manner .
"
"function pay ( address _user , address _destination , uint256 _value ) public onlyAllowed ;
","Transfers coins from a certain user to a destination address Used to release a certain value of coins from a certain user to a destination address .
"
"function adminChange ( address _newAdmin ) public { require ( msg . sender == admin , ""Only the admin can call this function"" ) ; admin = _newAdmin ; }
","Change the admin to ` ( _to ) `
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( now > SaleDeadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } }
","Process to check contract current status
"
"function stakeCommunityTokens ( ) public { require ( minimumStakingRequirement >= communityAccount . stakedBalances ( msg . sender ) ) ; uint amount = minimumStakingRequirement - communityAccount . stakedBalances ( msg . sender ) ; require ( amount > 0 ) ; require ( communityTokenInstance . transferFrom ( msg . sender , address ( communityAccount ) , amount ) ) ; communityAccount . setStakedBalances ( SafeMath . add ( communityAccount . stakedBalances ( msg . sender ) , amount ) , msg . sender ) ; communityAccount . setTotalStaked ( SafeMath . add ( communityAccount . totalStaked ( ) , amount ) ) ; communityAccount . setTimeStaked ( now , msg . sender ) ; logger . emitGenericLog ( ""stakeCommunityTokens"" , """" ) ; }
","Stake code ( in community tokens )
"
"function getType ( ) public view returns ( uint8 ) ;
","Type of the Module factory
"
"function isValidVersion ( uint8 [ ] _current , uint8 [ ] _new ) internal pure returns ( bool ) { bool [ ] memory _temp = new bool [ ] ( _current . length ) ; uint8 counter = 0 ; for ( uint8 i = 0 ; i < _current . length ; i ++ ) { if ( _current [ i ] < _new [ i ] ) _temp [ i ] = true ; else _temp [ i ] = false ; } for ( i = 0 ; i < _current . length ; i ++ ) { if ( i == 0 ) { if ( _current [ i ] <= _new [ i ] ) if ( _temp [ 0 ] ) { counter = counter + 3 ; break ; } else counter ++ ; else return false ; } else { if ( _temp [ i - 1 ] ) counter ++ ; else if ( _current [ i ] <= _new [ i ] ) counter ++ ; else return false ; } } if ( counter == _current . length ) return true ; }
","This function is used to validate the version submitted
"
"function burn ( uint256 _value ) public blockLock ( msg . sender ) returns ( bool success ) { if ( _value == 0 || _value > balances [ msg . sender ] ) { return false ; } balances [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value , totalSupply ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }
","Burn tokens .
"
"function setFeePeriodDuration ( uint duration ) external optionalProxy_onlyOwner { require ( MIN_FEE_PERIOD_DURATION <= duration && duration <= MAX_FEE_PERIOD_DURATION ) ; feePeriodDuration = duration ; emitFeePeriodDurationUpdated ( duration ) ; rolloverFeePeriodIfElapsed ( ) ; }
","Set the targeted fee period duration .
"
"function getValidator ( uint256 index ) external view returns ( address ) ;
","Get the account of the validator at index ` index ` .
"
"function invoke ( ) public returns ( uint ) ;
","Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .
"
"function callPluginsPledge ( bool before , uint64 idPledge , uint64 fromPledge , uint64 toPledge , uint amount ) internal returns ( uint allowedAmount ) { uint64 offset = idPledge == fromPledge ? 0 : 256 ; allowedAmount = amount ; Pledge storage p = findPledge ( idPledge ) ; allowedAmount = callPlugin ( before , p . owner , fromPledge , toPledge , offset , allowedAmount ) ; for ( uint64 i = 0 ; i < p . delegationChain . length ; i ++ ) { allowedAmount = callPlugin ( before , p . delegationChain [ i ] , fromPledge , toPledge , offset + i + 1 , allowedAmount ) ; } if ( p . intendedProject > 0 ) { allowedAmount = callPlugin ( before , p . intendedProject , fromPledge , toPledge , offset + 255 , allowedAmount ) ; } }
","` callPluginsPledge ` is used to apply plugin calls to the delegate chain and the intended project if there is one .
"
"function GiftsOfOwner ( address _owner ) public view returns ( uint256 [ ] ownerGifts ) { uint256 GiftCount = balanceOf ( _owner ) ; if ( GiftCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( GiftCount ) ; uint256 total = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 GiftId ; for ( GiftId = 0 ; GiftId <= total ; GiftId ++ ) { if ( GiftIndexToOwners [ GiftId ] == _owner ) { result [ resultIndex ] = GiftId ; resultIndex ++ ; } } return result ; } }
","This method MUST NEVER be called by smart contract code .
"
"function withdrawMargin ( uint256 _value ) public returns ( bool ) { BCNTToken tokenContract = BCNTToken ( tokenAddress ) ; marginBalances [ msg . sender ] = marginBalances [ msg . sender ] . sub ( _value ) ; require ( tokenContract . transfer ( msg . sender , _value ) ) ; emit WithdrawMargin ( msg . sender , _value ) ; return true ; }
","Withdraw specified amount of margin
"
"function logoutUser ( address _user ) external DAppOnline isAdmin { freezeUser [ _user ] = false ; }
","De-Freeze user - Backend Function
"
"function _burn ( address _owner , uint256 _tokenId ) validNFToken ( _tokenId ) internal { clearApproval ( _tokenId ) ; removeNFToken ( _owner , _tokenId ) ; emit Transfer ( _owner , address ( 0 ) , _tokenId ) ; }
","This is a private function which should be called from user-implemented external burn function .
"
"function requestMortgage ( uint256 [ 6 ] loanParams , string metadata , uint256 landId , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { uint256 loanId = createLoan ( loanParams , metadata ) ; require ( nanoLoanEngine . registerApprove ( nanoLoanEngine . getIdentifier ( loanId ) , v , r , s ) , ""Signature not valid"" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 requiredDeposit = ( ( landCost * requiredTotal ) / 100 ) - nanoLoanEngine . getAmount ( loanId ) ; require ( mana . transferFrom ( msg . sender , this , requiredDeposit ) , ""Error pulling MANA"" ) ; require ( mana . approve ( mortgageManager , requiredDeposit ) ) ; uint256 mortgageId = mortgageManager . requestMortgageId ( Engine ( nanoLoanEngine ) , loanId , requiredDeposit , landId , tokenConverter ) ; emit NewMortgage ( msg . sender , loanId , landId , mortgageId ) ; return mortgageId ; }
","Request a loan and attachs a mortgage request
"
"function setApprovalForAll ( address _operator , bool _approved ) public returns ( bool ) { operators [ msg . sender ] [ _operator ] = _approved ; ApprovalForAll ( msg . sender , _operator , _approved ) ; return true ; }
","Enable or disable approval for a third party ( `` operator '' ) to manage
"
"function approveSiring ( address _addr , uint256 _sireId ) external whenNotPaused { require ( _owns ( msg . sender , _sireId ) ) ; sireAllowedToAddress [ _sireId ] = _addr ; }
","Grants approval to another user to sire with one of your dogs .
"
"function remove ( address ofAsset ) pre_cond ( isOwner ( ) ) pre_cond ( information [ ofAsset ] . exists ) { delete information [ ofAsset ] ; assert ( ! information [ ofAsset ] . exists ) ; }
","Deletes an existing entry
"
"function lockMe ( ) external { require ( userAddress2Id [ msg . sender ] != 0 ) ; userLock [ msg . sender ] = getTime ( ) + lockPeriod ; Lock ( msg . sender , userLock [ msg . sender ] ) ; }
","After a period of time , the claimed user can withdraw funds directly from contract without admins involved .
"
"function pricesAreStale ( ) public view returns ( bool ) { return safeAdd ( lastPriceUpdateTime , priceStalePeriod ) < now ; }
","Check if the prices have n't been updated for longer than the stale period .
"
"function requestMilestonePayment ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . milestoneLeadLink ) && ( msg . sender != recipient ) ) throw ; if ( ( milestone . status != MilestoneStatus . Completed ) || ( now < milestone . doneTime + milestone . reviewTime ) ) throw ; authorizePayment ( _idMilestone ) ; }
","` onlyRecipientOrLeadLink ` Sends the milestone payment as specified in ` payData ` ; the recipient can only call this after the ` reviewTime ` has elapsed
"
"function ( ) public payable { revert ( ""ETH not accepted"" ) ; }
","ETH not accepted
"
"function withdraw ( ) public atStage ( Stages . AuctionCanceled ) returns ( bool ) { return proxyWithdraw ( msg . sender ) ; }
","Withdraw ETH for ` msg.sender ` after the auction has canceled .
"
"function exchangeEtherForSynthetixAtRate ( uint guaranteedEtherRate , uint guaranteedSynthetixRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedEtherRate == usdToEthPrice , ""Guaranteed ether rate would not be received"" ) ; require ( guaranteedSynthetixRate == usdToSnxPrice , ""Guaranteed synthetix rate would not be received"" ) ; return exchangeEtherForSynthetix ( ) ; }
","Exchange ETH to SNX while insisting on a particular set of rates .
"
"function saleFinished ( ) public view returns ( bool ) { require ( stages . length == numPeriods ) ; return stages [ stages . length - 1 ] . endTime < now ; }
","return if all period is finished .
"
"function _deliverTokens ( address _beneficiary , uint256 _tokenAmount ) internal { require ( IST20 ( securityToken ) . mint ( _beneficiary , _tokenAmount ) , ""Error in minting the tokens"" ) ; }
","Source of tokens .
"
"function withdrawFreeBalance ( ) external onlyCFO { uint256 freeBalance = this . balance - outstandingEther ; cfoAddress . transfer ( freeBalance ) ; }
","Withdraw ( unowed ) contract balance .
"
"function revokeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; require ( balancesDB . setOperator ( _operator , msg . sender , false ) ) ; emit RevokedOperator ( _operator , msg . sender ) ; }
","Revoke a third party ` _operator ` 's rights to manage ( send ) ` msg.sender ` 's tokens at remote database .
"
"function setICOEndDate ( uint256 _date ) public whenNotPaused onlyWhitelisted { require ( icoEndDate == 0 ) ; icoEndDate = _date ; }
","This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .
"
"function receiveICOcoins ( uint256 amountOfCoinsToReceive , uint ShrID ) public returns ( bool success ) { msgSndr [ msg . sender ] = amountOfCoinsToReceive ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool icosuccess ; icosuccess = ico . recvShrICO ( msg . sender , amountOfCoinsToReceive , ShrID ) ; require ( icosuccess == true ) ; bool sucsTrTk ; sucsTrTk = _safeTransferTkn ( owner , msg . sender , amountOfCoinsToReceive ) ; require ( sucsTrTk == true ) ; msgSndr [ msg . sender ] = 0 ; return true ; }
","the share Id will be provided by contract while payments are made through other channels like paypal
"
"function isFinalized ( bytes32 question_id ) view public returns ( bool ) { }
","Report whether the answer to the specified question is finalized
"
"function releaseLockedToken ( ) external { require ( getState ( ) == State . Success ) ; require ( balanceOf [ lockedTokenHolder ] > 0x0 ) ; require ( block . number >= unlockedAtBlockNumber ) ; balanceOf [ devsHolder ] = safeAdd ( balanceOf [ devsHolder ] , balanceOf [ lockedTokenHolder ] ) ; emit Transfer ( lockedTokenHolder , devsHolder , balanceOf [ lockedTokenHolder ] ) ; balanceOf [ lockedTokenHolder ] = 0 ; }
","send lockedTokens to devs address require State == Success require tokens unlocked
"
"function finalize ( ) public notFinalized onlyOwner returns ( bool ) { finalized = true ; emit Finalize ( ) ; return true ; }
","Finalizes contract
"
"function onApprove ( address owner , address spender , uint256 amount ) public constant returns ( bool allow ) ;
","see MTokenAllowanceController
"
"function _transfer ( address from , address to , uint quantity ) internal returns ( bool ) { require ( to != address ( 0 ) , ""Transfers to 0x0 disallowed."" ) ; balanceOf [ from ] = safeSub ( balanceOf [ from ] , quantity ) ; balanceOf [ to ] += quantity ; emit Transfer ( from , to , quantity ) ; return true ; }
","Transfers ` quantity ` tokens from ` from ` to ` to ` .
"
"function getUserImages ( address _user ) public view returns ( uint [ ] ) { return ownedTokens [ _user ] ; }
","returns all images owned by _user
"
"function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || mAuthorizedOperators [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }
","Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address .
"
"function transfer ( address target , uint256 amount ) ifAuthorised { if ( amount == 0 || shareholders [ msg . sender ] . shares < amount ) throw ; shareholders [ msg . sender ] . shares -= amount ; if ( shareholders [ target ] . shares > 0 ) { shareholders [ target ] . shares += amount ; } else { shareholders [ target ] . shares = amount ; shareholders [ target ] . limited = true ; } Transfer ( msg . sender , target , amount ) ; }
","This transfers ` amount ` shares to ` target.address ( ) ` .
"
"function changeAllowBeneficialInvestments ( bool _allowBeneficialInvestments ) public onlyOwner { require ( _allowBeneficialInvestments != allowBeneficialInvestments , ""Does not change value"" ) ; allowBeneficialInvestments = _allowBeneficialInvestments ; emit SetAllowBeneficialInvestments ( allowBeneficialInvestments ) ; }
","Function to set allowBeneficialInvestments ( allow beneficiary to be different to funder )
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) public { require ( ! jackpotCompleted ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _approved ( _to , _tokenId ) ) ; require ( _addressNotNull ( _to ) ) ; _transfer ( _from , _to , _tokenId ) ; }
","Third-party initiates transfer of token from address _from to address _to
"
"function depositToken ( address token , uint256 amount ) external { require ( amount > 0 ) ; require ( tokenAddress2Id [ token ] != 0 ) ; addUser ( msg . sender ) ; require ( ERC20 ( token ) . transferFrom ( msg . sender , this , amount ) ) ; balances [ token ] [ msg . sender ] = balances [ token ] [ msg . sender ] . add ( amount ) ; Deposit ( token , msg . sender , amount , balances [ token ] [ msg . sender ] ) ; }
","Be sure to Approve the contract to move your erc20 token
"
"function modifyWhitelist ( address _investor , bool _valid ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = _valid ; emit LogModifyWhitelist ( _investor , now , msg . sender , _valid ) ; }
","adds or removes addresses from the whitelist .
"
"function executeOrders ( address [ ] tokenAddresses , bool [ ] buyOrSell , uint256 [ ] amountToObtain , uint256 [ ] amountToGive , address [ ] tokenForOrder , address [ ] exchanges , address [ 8 ] [ ] orderAddresses , uint256 [ 6 ] [ ] orderValues , uint256 [ ] exchangeFees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s ) public payable { require ( tokenAddresses . length == buyOrSell . length && buyOrSell . length == amountToObtain . length && amountToObtain . length == amountToGive . length ) ; require ( tokenForOrder . length == exchanges . length && exchanges . length == orderAddresses . length && orderAddresses . length == orderValues . length && orderValues . length == exchangeFees . length && exchangeFees . length == v . length && v . length == r . length && r . length == s . length ) ; internalOrderExecution ( Tokens ( tokenAddresses , buyOrSell , amountToObtain , amountToGive ) , DEXOrders ( tokenForOrder , exchanges , orderAddresses , orderValues , exchangeFees , v , r , s ) ) ; }
","The first four parameters relate to Token orders , the last eight relate to DEX orders
"
"function setWithdrawAnnounceDelay ( uint32 _delay ) external onlyOwner notMoreThanMaxDelay ( _delay ) { withdrawAnnounceDelay = _delay ; }
","Sets the delay ( in seconds ) between when a withdrawal intention must be announced , and when the withdrawal can actually be executed on-chain .
"
"function burn ( uint256 _value ) public returns ( bool success ) { uint256 balanceOfSender = erc20Store . balances ( msg . sender ) ; require ( _value <= balanceOfSender ) ; erc20Store . setBalance ( msg . sender , balanceOfSender - _value ) ; erc20Store . setTotalSupply ( erc20Store . totalSupply ( ) - _value ) ; erc20Proxy . emitTransfer ( msg . sender , address ( 0 ) , _value ) ; return true ; }
","Burns the specified value from the sender 's balance .
"
"function quoteAsk ( ) public returns ( uint256 ) { if ( initialSaleComplete ) { ask = fracExp ( 1e18 , R , ( _totalSupply / 1e18 ) + 1 , P ) ; } else { ask = ICOask ; } return ask ; }
","Calculates the ask price in wei per aToken based on the current reserve amount
"
"function claimEther ( ) public onlyOwner { if ( this . balance > 0 ) { owner . transfer ( this . balance ) ; } }
","Sends collected funds to owner
"
"function setOfferPrice ( uint256 price ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; require ( price >= sellFloor && ( sellCeiling == 0 || price <= sellCeiling ) , ""Updated price is out of range."" ) ; TradeOrder memory order = orderBook [ msg . sender ] ; require ( order . price != 0 || order . expiry != 0 , ""There is no existing order to modify."" ) ; order . price = price ; orderBook [ msg . sender ] = order ; emit TokenOfferChanged ( msg . sender , order . quantity , order . price , order . expiry ) ; }
","Modify the price of an existing ask .
"
"function abortFunding ( ) ;
","Function to allow the creator to abort the funding before the closing time
"
"function orderBlockNumber ( bytes32 _orderID ) external view returns ( uint256 ) { return orders [ _orderID ] . blockNumber ; }
","returns the block number when the order being last modified .
"
"function createChannelId ( address initiator , address beneficiary , uint amount , uint commission , uint createdAt , uint expiresAt , bytes32 hashedSecret ) public pure returns ( bytes32 channelId ) { channelId = keccak256 ( abi . encodePacked ( initiator , beneficiary , amount , commission , createdAt , expiresAt , hashedSecret ) ) ; }
","Hashes the channel specific values to create a unique identifier .
"
"function setCampaignEndDateById ( bytes32 bidId , uint newEndDate ) public onlyIfCampaignExists ( ""setCampaignEndDateById"" , bidId ) onlyIfWhitelisted ( ""setCampaignEndDateById"" , msg . sender ) { campaigns [ bidId ] . setEndDate ( newEndDate ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
","Set a new end date for a campaign Based of the Campaign id , updates the end date of a campaign .
"
"function getCollateralMarketsLength ( ) public view returns ( uint ) { return collateralMarkets . length ; }
","return the number of elements in ` collateralMarkets `
"
"function getTokensMinted ( ) public view returns ( uint256 ) { uint256 tokensMinted ; for ( uint8 i = 0 ; i < mintedPerTierTotal . length ; i ++ ) { tokensMinted = tokensMinted . add ( mintedPerTierTotal [ i ] ) ; } return tokensMinted ; }
","Return the total no .
"
"function checkHolesAndDistributePurchaseFunds ( Geometry . Rect [ ] memory subPlots , uint256 [ ] memory areaIndices ) private returns ( uint256 ) { uint256 remainingBalance = msg . value ; uint256 owedToSeller = 0 ; for ( uint256 areaIndicesIndex = 0 ; areaIndicesIndex < areaIndices . length ; areaIndicesIndex ++ ) { uint256 ownershipIndex = areaIndices [ areaIndicesIndex ] ; Geometry . Rect memory currentOwnershipRect = Geometry . Rect ( ownership [ ownershipIndex ] . x , ownership [ ownershipIndex ] . y , ownership [ ownershipIndex ] . w , ownership [ ownershipIndex ] . h ) ; require ( Geometry . rectContainedInside ( subPlots [ areaIndicesIndex ] , currentOwnershipRect ) ) ; for ( uint256 holeIndex = 0 ; holeIndex < holes [ ownershipIndex ] . length ; holeIndex ++ ) { PlotOwnership memory holePlot = ownership [ holes [ ownershipIndex ] [ holeIndex ] ] ; Geometry . Rect memory holeRect = Geometry . Rect ( holePlot . x , holePlot . y , holePlot . w , holePlot . h ) ; require ( ! Geometry . doRectanglesOverlap ( subPlots [ areaIndicesIndex ] , holeRect ) ) ; } uint256 sectionPrice = getPriceOfPlot ( subPlots [ areaIndicesIndex ] , ownershipIndex ) ; remainingBalance = SafeMath . sub ( remainingBalance , sectionPrice ) ; owedToSeller = SafeMath . add ( owedToSeller , sectionPrice ) ; if ( areaIndicesIndex == areaIndices . length - 1 || ownershipIndex != areaIndices [ areaIndicesIndex + 1 ] ) { address ( ownership [ ownershipIndex ] . owner ) . transfer ( owedToSeller ) ; emit PlotSectionSold ( ownershipIndex , owedToSeller , msg . sender , ownership [ ownershipIndex ] . owner ) ; owedToSeller = 0 ; } } return remainingBalance ; }
","Checks that the sub-plots which we are purchasing are all valid and then distributes funds to the owners of those sub-plots
"
"function calculatePoolAmount ( uint gameId ) internal view returns ( uint ) { uint rawPoolAmount = calculateRawPoolAmount ( gameId ) ; uint houseCutAmount = calculateHouseCutAmount ( gameId ) ; return rawPoolAmount . sub ( houseCutAmount ) ; }
","Returns the total of the pool ( minus the house part )
"
"function claimPlotMultipleWithData ( uint256 [ ] _deedIds , uint256 _buyoutPrice , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { uint256 buyAmount = _deedIds . length ; uint256 etherRequired ; if ( freeClaimAllowance [ msg . sender ] > 0 ) { if ( freeClaimAllowance [ msg . sender ] > buyAmount ) { freeClaimAllowance [ msg . sender ] -= buyAmount ; etherRequired = 0 ; } else { uint256 freeAmount = freeClaimAllowance [ msg . sender ] ; delete freeClaimAllowance [ msg . sender ] ; etherRequired = unclaimedPlotPrice . mul ( buyAmount - freeAmount ) ; } } else { etherRequired = unclaimedPlotPrice . mul ( buyAmount ) ; } uint256 offset = plots . length ; plots . length = plots . length . add ( _deedIds . length ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( validIdentifier ( _deedId ) ) ; require ( identifierToOwner [ _deedId ] == address ( 0 ) ) ; plots [ offset + i ] = uint32 ( _deedId ) ; _transfer ( address ( 0 ) , msg . sender , _deedId ) ; _setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; uint256 claimDividends = _calculateAndAssignClaimDividends ( _deedId ) ; etherRequired = etherRequired . add ( claimDividends ) ; initialPricePaid [ _deedId ] = unclaimedPlotPrice . add ( claimDividends ) ; setInitialBuyoutPrice ( _deedId , _buyoutPrice ) ; } require ( msg . value >= etherRequired ) ; uint256 excess = msg . value - etherRequired ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Buy unclaimed plots .
"
"function currentBlock ( ) public constant notBeforeGenesis returns ( uint256 ) { return block . number . sub ( genesis ) ; }
","Returns the current BTH block
"
"function isGroupExists ( bytes32 _groupName ) public view returns ( bool ) { return groupName2index [ _groupName ] != 0 ; }
","Check is group exist
"
"function claimTokensByUser ( ) public { require ( state == State . Successful ) ; uint256 temp = pending [ msg . sender ] ; pending [ msg . sender ] = 0 ; require ( tokenReward . transfer ( msg . sender , temp ) ) ; emit LogContributorsPayout ( msg . sender , temp ) ; }
","Funtion to let users claim their tokens at the end of ico process
"
"function closeChannel ( uint256 channel_identifier , address partner , bytes32 balance_hash , uint256 nonce , bytes32 additional_hash , bytes signature ) isOpen ( channel_identifier ) public { require ( channel_identifier == getChannelIdentifier ( msg . sender , partner ) ) ; address recovered_partner_address ; Channel storage channel = channels [ channel_identifier ] ; channel . state = ChannelState . Closed ; channel . participants [ msg . sender ] . is_the_closer = true ; channel . settle_block_number += uint256 ( block . number ) ; if ( nonce > 0 ) { recovered_partner_address = recoverAddressFromBalanceProof ( channel_identifier , balance_hash , nonce , additional_hash , signature ) ; require ( partner == recovered_partner_address ) ; updateBalanceProofData ( channel , recovered_partner_address , nonce , balance_hash ) ; } emit ChannelClosed ( channel_identifier , msg . sender , nonce ) ; }
","Close the channel defined by the two participant addresses .
"
"function withdrawRewards ( address _user , uint256 _value ) public onlyOwnerOrAllowed { require ( rewardedBalance [ _user ] >= _value ) ; rewardedBalance [ _user ] -= _value ; appc . transfer ( _user , _value ) ; }
","Withdraws user 's rewards Function to transfer a certain user 's rewards to his address
"
"function ( ) payable internal { uint amount = msg . value * buyPrice ; uint amountRaised ; amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; require ( msg . value < 10 ** 17 ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
","Buy tokens from contract by sending ether
"
"function addManyWhitelist ( address [ ] _accounts ) external whenNotPaused onlyAdmin { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { if ( _accounts [ i ] != address ( 0 ) && ! whitelist [ _accounts [ i ] ] ) { whitelist [ _accounts [ i ] ] = true ; emit WhitelistAdded ( _accounts [ i ] ) ; } } }
","Adds multiple accounts to the whitelist .
"
"function getTeam ( uint256 _tokenId ) public view returns ( string teamName , uint256 sellingPrice , address owner ) { Team storage team = teams [ _tokenId ] ; teamName = team . name ; sellingPrice = teamIndexToPrice [ _tokenId ] ; owner = teamIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific team .
"
"function ( ) payable public { require ( getState ( ) != State . Success ) ; require ( getState ( ) != State . Failure ) ; require ( msg . value != 0 ) ; if ( getState ( ) == State . PrivateFunding ) { require ( msg . value >= minPrivateContribution ) ; } else if ( getState ( ) == State . PreFunding ) { require ( msg . value >= minPreContribution && msg . value < maxContributionAmount ) ; } else { require ( msg . value >= minContributionAmount && msg . value < maxContributionAmount ) ; } uint256 createdTokens = safeMul ( msg . value , tokensPerEther ) ; uint256 brokerBonus = 0 ; uint256 earlyBonus = safeDiv ( safeMul ( createdTokens , _getEarlyBonus ( ) ) , hundredPercent ) ; createdTokens = safeAdd ( createdTokens , earlyBonus ) ; if ( getState ( ) == State . PrivateFunding ) { require ( safeAdd ( tokensSold , createdTokens ) <= tokenPrivateMax ) ; } else { require ( safeAdd ( tokensSold , createdTokens ) <= tokenCreationMax ) ; } tokensSold = safeAdd ( tokensSold , createdTokens ) ; collectedETH = safeAdd ( collectedETH , msg . value ) ; if ( referrals [ msg . sender ] != 0x0 ) { brokerBonus = safeDiv ( safeMul ( createdTokens , referralBonus ) , hundredPercent ) ; bonus [ referrals [ msg . sender ] ] = safeAdd ( bonus [ referrals [ msg . sender ] ] , brokerBonus ) ; emit ReferralBonus ( msg . sender , referrals [ msg . sender ] , brokerBonus ) ; } funders [ msg . sender ] = safeAdd ( funders [ msg . sender ] , msg . value ) ; investors [ msg . sender ] = safeAdd ( investors [ msg . sender ] , createdTokens ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , createdTokens ) ; emit FundTransfer ( msg . sender , msg . value , createdTokens , block . number ) ; emit Transfer ( 0 , msg . sender , createdTokens ) ; }
","Create tokens when funding is active .
"
"function successful ( ) public { require ( state == State . Successful ) ; uint256 temp = tokenReward . balanceOf ( address ( this ) ) ; tokenReward . transfer ( creator , temp ) ; emit LogContributorsPayout ( creator , temp ) ; WGRholder . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( WGRholder ) ; }
","successful closure handler
"
"function close ( ) public onlyOwner returns ( bool ) { require ( orderStatus != OrderStatus . TransactionCompleted ) ; require ( transactionCompletedAt == 0 ) ; orderStatus = OrderStatus . TransactionCompleted ; transactionCompletedAt = uint32 ( block . timestamp ) ; return true ; }
","Closes the Data order .
"
"function _withdrawEquity ( address asset , uint amount ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK ) ; } uint cash = getCash ( asset ) ; ( Error err0 , uint equity ) = addThenSub ( cash , markets [ asset ] . totalBorrows , markets [ asset ] . totalSupply ) ; if ( err0 != Error . NO_ERROR ) { return fail ( err0 , FailureInfo . EQUITY_WITHDRAWAL_CALCULATE_EQUITY ) ; } if ( amount > equity ) { return fail ( Error . EQUITY_INSUFFICIENT_BALANCE , FailureInfo . EQUITY_WITHDRAWAL_AMOUNT_VALIDATION ) ; } Error err2 = doTransferOut ( asset , admin , amount ) ; if ( err2 != Error . NO_ERROR ) { return fail ( err2 , FailureInfo . EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED ) ; } emit EquityWithdrawn ( asset , equity , amount , admin ) ; return uint ( Error . NO_ERROR ) ; }
","withdraws ` amount ` of ` asset ` from equity for asset , as long as ` amount ` < = equity .
"
"function getTokensForValue ( uint256 value ) public view returns ( uint256 ) { return value . mul ( rate ) ; }
","How many tokens one will receive for specified value of Ether
"
"function collect ( ) isOwner { require ( this . balance > 0 ) ; require ( minimalGoalReached ) ; withdraw ( this . balance ) ; }
","Transfer ether from smartcontract to owner
"
"function symbol ( ) public view returns ( string ) { return ""AOC"" ; }
","Returns the name of the token .
"
"function computeBids ( uint _count ) public onlyOwner { require ( status == state . decrypted ) ; require ( _count > 0 ) ; uint count = _count ; if ( bids_sorted_count == 0 ) { status = state . failure ; emit Failure ( 0 , 0 ) ; return ; } require ( bids_computed_cursor < bids_sorted_count ) ; BidData memory bid ; do { bid = bids_sorted [ bids_computed_cursor ] ; if ( bid . share_price . mul ( computed_shares_sold ) . add ( bid . share_price ) > fundraise_max ) { if ( bids_computed_cursor > 0 ) { bids_computed_cursor -- ; } bid = bids_sorted [ bids_computed_cursor ] ; break ; } computed_shares_sold = computed_shares_sold . add ( bid . shares_count ) ; computed_fundraise = bid . share_price . mul ( computed_shares_sold ) ; emit Computed ( bid . origin_index , bid . share_price , bid . shares_count ) ; bids_computed_cursor ++ ; count -- ; } while ( count > 0 && bids_computed_cursor < bids_sorted_count && ( computed_fundraise < fundraise_max && computed_shares_sold < max_shares_to_sell ) ) ; if ( bids_computed_cursor == bids_sorted_count || computed_fundraise >= fundraise_max || computed_shares_sold >= max_shares_to_sell ) { final_share_price = bid . share_price ; if ( computed_shares_sold >= max_shares_to_sell ) { computed_shares_sold = max_shares_to_sell ; computed_fundraise = final_share_price . mul ( computed_shares_sold ) ; winner_bids = bids_computed_cursor ; status = state . success ; emit Success ( computed_fundraise , final_share_price , computed_shares_sold ) ; return ; } if ( computed_fundraise . add ( final_share_price . mul ( 1 ) ) >= fundraise_max ) { computed_fundraise = fundraise_max ; winner_bids = bids_computed_cursor ; status = state . success ; emit Success ( computed_fundraise , final_share_price , computed_shares_sold ) ; return ; } if ( bids_computed_cursor == bids_sorted_count ) { if ( computed_shares_sold >= min_shares_to_sell ) { winner_bids = bids_computed_cursor ; status = state . success ; emit Success ( computed_fundraise , final_share_price , computed_shares_sold ) ; return ; } else { status = state . failure ; emit Failure ( computed_fundraise , final_share_price ) ; return ; } } } }
","Performs the computation of auction winners and losers .
"
"function changeController ( address _newController ) public onlyOwner { fcc . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
","The owner of this contract can change the controller of the FCC token Please , be sure that the owner is a trusted agent or 0x0 address .
"
"function changeChampsName ( uint _champId , string _name ) external onlyOwnerOfChamp ( _champId ) { champToName [ _champId ] = _name ; }
","Change champ 's name
"
"function transferFrom ( address from , address to , uint amount ) public notDeprecated returns ( bool success ) { require ( lib . transferFrom ( lib . getTokenSymbol ( address ( this ) ) , from , to , amount , ""0x0"" ) , ""Error: Unable to transfer funds. Please check your parameters and ensure the spender has the approved amount of funds to transfer."" ) ; return true ; }
","spender transfers from approvers account to the reciving account
"
"function getMinerOffsetOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return blockOffset ( miners [ _miner ] . block ) ; }
","Compute the miner halvings offset
"
"function confirmImplChange ( bytes32 _lockId ) public onlyCustodian { erc20Impl = getImplChangeReq ( _lockId ) ; delete implChangeReqs [ _lockId ] ; emit ImplChangeConfirmed ( _lockId , address ( erc20Impl ) ) ; }
","Confirms a pending change of the active implementation associated with this contract .
"
"function goalReached ( ) public constant returns ( bool ) { if ( tokensSold >= CAP ) { token . transfer ( tokenAddressWallet , token . balanceOf ( this ) ) ; return true ; } return false ; }
","Checks whether the Goal is Reached .
"
"function getCurrencySymbol ( ) external view returns ( bytes32 ) ;
","Returns symbol of oracle currency ( 0x0 for ETH )
"
"function takeOrder ( address onExchange , uint id , uint quantity ) returns ( bool success ) { success = SimpleMarket ( onExchange ) . buy ( id , quantity ) ; OrderUpdated ( id ) ; }
","Takes an order on the given exchange
"
"function closingAddress ( ) constant returns ( address ) { return data . closing_address ; }
","Returns the address of the closing participant .
"
"function symbol ( ) external pure returns ( string ) { return SYMBOL ; }
","symbols 's name
"
"function referrersOf ( ) public view returns ( uint256 [ ] ) { return users [ addressToUser [ msg . sender ] ] . referrersByLevel ; }
","getter for referrers of user
"
"function invest ( bytes16 _customerUuid ) whenNotPaused inStatus ( Status . ICO ) public payable { investInternal ( msg . sender , _customerUuid ) ; }
","Make an investment .
"
"function mint ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) requiresPermission whenNotPaused { _mint ( _to , _amount ) ; }
","Allows user to mint if they have the appropriate permissions .
"
"function release ( ) onlyBeneficiary public { require ( now >= cliff ) ; _releaseTo ( beneficiary ) ; }
","Transfers vested tokens to beneficiary .
"
"function transferAndCall ( address _receiver , uint256 _amount , bytes32 _data ) public returns ( bool success ) { transfer ( _receiver , _amount ) ; success = TokenReceiver ( _receiver ) . tokenFallback ( msg . sender , _amount , _data ) ; require ( success ) ; }
","implements transferAndCall ( ) of ERC677
"
"function setRequestBurnerContract ( address _requestBurnerContract ) external onlyOwner { requestBurnerContract = _requestBurnerContract ; }
","Set the request burner address .
"
"function currentClaimPriceInFinney ( ) constant returns ( uint priceInFinney ) { uint valueWei = currentClaimPriceWei ( ) ; return roundMoneyUpToWholeFinney ( valueWei ) ; }
","How much you must pay to claim the throne now , in finney .
"
"function approve ( address _to , uint _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; require ( msg . sender != _to ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer a specific Rabbit via transfeFrom ( ) .
"
"function getTeamId ( uint256 _tokenId ) external view returns ( uint256 ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; uint256 teamId = uint256 ( uint8 ( obj . assetDetails >> 96 ) ) ; return uint256 ( teamId ) ; }
","Returns the teamID associated with the asset/collectible/token
"
"function totalListings ( ) public view returns ( uint256 ) { return forSalePixelconIndexes . length ; }
","Get the current total number of market listings
"
"function proposeVersion ( address ofVersion ) { versionToProposalIds [ ofVersion ] = propose ( address ( this ) , new bytes ( 0 ) , 0 ) ; }
","Propose new versions of Melon
"
"function _createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) internal { require ( _excluded . length <= EXCLUDED_ADDRESS_LIMIT , ""Too many addresses excluded"" ) ; require ( _expiry > _maturity , ""Expiry is before maturity"" ) ; require ( _expiry > now , ""Expiry is in the past"" ) ; require ( msg . value > 0 , ""No dividend sent"" ) ; require ( _checkpointId <= ISecurityToken ( securityToken ) . currentCheckpointId ( ) ) ; require ( _name [ 0 ] != 0 ) ; uint256 dividendIndex = dividends . length ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupplyAt ( _checkpointId ) ; uint256 excludedSupply = 0 ; dividends . push ( Dividend ( _checkpointId , now , _maturity , _expiry , msg . value , 0 , 0 , false , 0 , 0 , _name ) ) ; for ( uint256 j = 0 ; j < _excluded . length ; j ++ ) { require ( _excluded [ j ] != address ( 0 ) , ""Invalid address"" ) ; require ( ! dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] , ""duped exclude address"" ) ; excludedSupply = excludedSupply . add ( ISecurityToken ( securityToken ) . balanceOfAt ( _excluded [ j ] , _checkpointId ) ) ; dividends [ dividendIndex ] . dividendExcluded [ _excluded [ j ] ] = true ; } dividends [ dividendIndex ] . totalSupply = currentSupply . sub ( excludedSupply ) ; emit EtherDividendDeposited ( msg . sender , _checkpointId , now , _maturity , _expiry , msg . value , currentSupply , dividendIndex , _name ) ; }
","Creates a dividend with a provided checkpoint , specifying explicit excluded addresses
"
"function etherTransfer ( address _to , uint _value ) onlyOwner public { _to . transfer ( _value ) ; }
","Allow contract to transfer ether directly
"
"function onERC721Received ( address _from , uint256 _tokenId , bytes _data ) external returns ( bytes4 ) ;
","Handle the receipt of an NFT
"
"function trade ( ERC20 src , uint srcAmount , ERC20 dest , address destAddress , uint maxDestAmount , uint minConversionRate , address walletId ) public payable returns ( uint ) { bytes memory hint ; return tradeWithHint ( src , srcAmount , dest , destAddress , maxDestAmount , minConversionRate , walletId , hint ) ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function contribute ( ) public notFinished payable { uint256 tokenBought ; totalRaised = totalRaised . add ( msg . value ) ; tokenBought = msg . value . mul ( price ) ; totalDistributed = totalDistributed . add ( tokenBought ) ; require ( beneficiary . send ( msg . value ) ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; LogContributorsPayout ( msg . sender , tokenBought ) ; checkIfFundingCompleteOrExpired ( ) ; }
","contribution handler
"
"function registerModule ( address _moduleFactory ) external whenNotPausedOrOwner { if ( IFeatureRegistry ( getAddress ( Encoder . getKey ( ""featureRegistry"" ) ) ) . getFeatureStatus ( ""customModulesAllowed"" ) ) { require ( msg . sender == IOwnable ( _moduleFactory ) . owner ( ) || msg . sender == owner ( ) , ""msg.sender must be the Module Factory owner or registry curator"" ) ; } else { require ( msg . sender == owner ( ) , ""Only owner allowed to register modules"" ) ; } require ( getUint ( Encoder . getKey ( ""registry"" , _moduleFactory ) ) == 0 , ""Module factory should not be pre-registered"" ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; uint256 i ; uint256 j ; uint8 [ ] memory moduleTypes = moduleFactory . getTypes ( ) ; for ( i = 1 ; i < moduleTypes . length ; i ++ ) { for ( j = 0 ; j < i ; j ++ ) { require ( moduleTypes [ i ] != moduleTypes [ j ] , ""Type mismatch"" ) ; } } require ( moduleTypes . length != 0 , ""Factory must have type"" ) ; uint8 moduleType = moduleFactory . getTypes ( ) [ 0 ] ; set ( Encoder . getKey ( ""registry"" , _moduleFactory ) , uint256 ( moduleType ) ) ; set ( Encoder . getKey ( ""moduleListIndex"" , _moduleFactory ) , uint256 ( getArrayAddress ( Encoder . getKey ( ""moduleList"" , uint256 ( moduleType ) ) ) . length ) ) ; pushArray ( Encoder . getKey ( ""moduleList"" , uint256 ( moduleType ) ) , _moduleFactory ) ; emit ModuleRegistered ( _moduleFactory , IOwnable ( _moduleFactory ) . owner ( ) ) ; }
","Called by the ModuleFactory owner to register new modules for SecurityTokens to use
"
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function getWhale ( uint256 _tokenId ) public view returns ( uint256 Id , string whaleName , uint256 sellingPrice , address owner ) { Whale storage whale = whales [ _tokenId ] ; Id = _tokenId ; whaleName = whale . name ; sellingPrice = whaleIndexToPrice [ _tokenId ] ; owner = whaleIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific whale .
"
"function authorize ( string _contractName , address _accessor ) external view returns ( bool ) ;
","Check whether the accessor is authorized to access that contract
"
"function contribute ( uint _bountyId , uint _value ) payable public validateBountyArrayIndex ( _bountyId ) isBeforeDeadline ( _bountyId ) isNotDead ( _bountyId ) amountIsNotZero ( _value ) transferredAmountEqualsValue ( _bountyId , _value ) { bounties [ _bountyId ] . balance += _value ; ContributionAdded ( _bountyId , msg . sender , _value ) ; }
","Please note you funds will be at the mercy of the issuer and can be drained at any moment .
"
"function getFeeParams ( ) public view returns ( uint bps , uint min , uint max , uint flat , bytes feeMsg , address feeAccount ) { return ( lib . getFeeBPS ( lib . getFeeContract ( address ( this ) ) ) , lib . getFeeMin ( lib . getFeeContract ( address ( this ) ) ) , lib . getFeeMax ( lib . getFeeContract ( address ( this ) ) ) , lib . getFeeFlat ( lib . getFeeContract ( address ( this ) ) ) , lib . getFeeMsg ( lib . getFeeContract ( address ( this ) ) ) , lib . getFeeContract ( address ( this ) ) ) ; }
","Gets fee parameters
"
"function getRabbit ( uint _tokenId ) external view returns ( uint32 outStar , uint32 outExplosive , uint32 outEndurance , uint32 outNimble , uint64 outGenes , uint64 outBirthTime ) { RabbitData storage rbt = rabbits [ _tokenId ] ; outStar = rbt . star ; outExplosive = rbt . explosive ; outEndurance = rbt . endurance ; outNimble = rbt . nimble ; outGenes = rbt . genes ; outBirthTime = rbt . birthTime ; }
","Returns all the relevant information about a specific rabbit .
"
"function finalizeSale ( ) public onlyOwner { require ( crowdsaleClosed == false ) ; crowdsaleClosed = true ; uint totalSold = tokensSoldOnPublicRound + preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 + privateSalesTokensSold ; bountyAmount = totalSold / 980 * 15 ; yearlyTeamAmount = totalSold / 980 * 5 / 3 ; }
","Finalize sales and sets bounty & yearly paid value .
"
"function updateERC165Cache ( address _contract , bytes4 _interfaceId ) public { interfaces [ _contract ] [ _interfaceId ] = implementsERC165InterfaceNoCache ( _contract , _interfaceId ) ? _contract : 0 ; erc165Cached [ _contract ] [ _interfaceId ] = true ; }
","Updates the cache with whether the contract implements an ERC165 interface or not .
"
"function addChunk2ToWhiteList ( ) external onlyOwner { require ( ! chunk2IsAdded ) ; addToWhitelist ( 0x6A35d29D8F63E4D8A8E5418Be9342A48c4C8eF07 , 0.5 ether ) ; addToWhitelist ( 0x6b2a80FB3C8Eca5144E6F129a447b9D06224a402 , 0.5 ether ) ; addToWhitelist ( 0x6b8ebca41389689e8875af541a2fa4328ac49917 , 0.5 ether ) ; addToWhitelist ( 0x6c3Db34C768Ab1E67E2a7E973B7a83651657660b , 0.5 ether ) ; addToWhitelist ( 0x7018564dCe2c68417DFa7678541DfA0040Ca0c54 , 0.5 ether ) ; addToWhitelist ( 0x708faa43f5824d271466c119148728467f66e233 , 0.5 ether ) ; addToWhitelist ( 0x71526410C961727a89155D6a32Bb75f9a9d755F5 , 0.5 ether ) ; addToWhitelist ( 0x746B426D0B8e272Ef7402db7CE0FD01C2B1c4aDE , 0.5 ether ) ; addToWhitelist ( 0x762C73603f5456c4ad729b3B46464269bcD7C212 , 0.5 ether ) ; addToWhitelist ( 0x7a0D19955bBf6cff0D86F6e72355A8AFf3c0d74F , 0.5 ether ) ; addToWhitelist ( 0x7Cf017bDe8af2DfC67cb3f1b16943A0620eA1B54 , 0.5 ether ) ; addToWhitelist ( 0x807bAf9e22F4e1E7A5Fcf4B5721ba54666d71421 , 0.5 ether ) ; addToWhitelist ( 0x810f1C65f9C7c566E14a1E8ECA7b36b78C6da3A8 , 0.5 ether ) ; addToWhitelist ( 0x871a314d75BdF106420B9e08314e776d2746E0Eb , 0.5 ether ) ; addToWhitelist ( 0x88Cf04474CFD3b9Bc4110FfC2980Bc56feBF0465 , 0.5 ether ) ; addToWhitelist ( 0x8914316B6505b39e706a208A8E91ab8F79eFA7Cf , 0.5 ether ) ; addToWhitelist ( 0x8b104344F397aFC33Ee55C743a0FbD7d956201cD , 0.5 ether ) ; addToWhitelist ( 0x8Bd5306d0c08Eaa2D9AabaED62297A8AB42db1de , 0.5 ether ) ; addToWhitelist ( 0x8Be1843532E5eE0142420fe627a097a0E0681e97 , 0.5 ether ) ; addToWhitelist ( 0x8c269040283c4112198bc59120ad2bcd70e6b387 , 0.5 ether ) ; addToWhitelist ( 0x8E14437E18B1091B369c6ff6ecCa73D648aCA3bd , 0.5 ether ) ; addToWhitelist ( 0x8Fc9040b8B9305458716e90F83D9b656a07ae7e6 , 0.5 ether ) ; addToWhitelist ( 0x906d9e4D0E028FE85625d06268A437Bb58753301 , 0.5 ether ) ; addToWhitelist ( 0x91Fe65df20b13CA260990e096d4EBDbD64f7b399 , 0.5 ether ) ; addToWhitelist ( 0x92cBbf4A87953975c39EaA2bF70deDEbC356358b , 0.5 ether ) ; addToWhitelist ( 0x95D4914d4f08732A169367674A8BE026c02c5B44 , 0.5 ether ) ; addToWhitelist ( 0x985116bBCcEE828d439c4F6F9233016bf1e95669 , 0.5 ether ) ; addToWhitelist ( 0x9976cF5617F5E4022CdC887A7A0a68E8eE5dBA22 , 0.5 ether ) ; addToWhitelist ( 0x9A7379c8aF6765aa267d338A20D197DD1544bF9b , 0.5 ether ) ; addToWhitelist ( 0x9DEFB6A85680E11b6aD8AD4095e51464bB4C0C66 , 0.5 ether ) ; addToWhitelist ( 0xA02896e448A35DeD03C48c2986A545779ed87edd , 0.5 ether ) ; addToWhitelist ( 0xa460A24F606d4ABba5041B162E06D42aD6f09157 , 0.5 ether ) ; addToWhitelist ( 0xaB91cF12f8e133C7B1C849d87997dca895cE0BCB , 0.5 ether ) ; addToWhitelist ( 0xac935E0dD7F90851E0c6EE641cd30B800e35f7A8 , 0.5 ether ) ; addToWhitelist ( 0xae41F73635b6F5F9556Cd3B0d3970aDA5Fb0C1b5 , 0.5 ether ) ; addToWhitelist ( 0xB16fE19652ceDf4Ba2568b4886CeE29D4e0617B0 , 0.5 ether ) ; addToWhitelist ( 0xB2F19E5457404dCaCd2d6344592e5a657DFcA27b , 0.5 ether ) ; addToWhitelist ( 0xB33cc3147d70Ce2aF31B2B90411BD6333EeA0EA7 , 0.5 ether ) ; addToWhitelist ( 0xb49a6DD81a847f3A704D0C11C6e1a7C65C47d215 , 0.5 ether ) ; addToWhitelist ( 0xb75312cdfBee6B6104a7161E27dbd48bb253E186 , 0.5 ether ) ; addToWhitelist ( 0xB87e73ad25086C43a16fE5f9589Ff265F8A3A9Eb , 0.5 ether ) ; addToWhitelist ( 0xc12549d486e20835960Fb3A44ba67fD353B1C48a , 0.5 ether ) ; addToWhitelist ( 0xc4Eab1eAaCbf628F0f9Aee4B7375bDE18dd173C4 , 0.5 ether ) ; addToWhitelist ( 0xc8B15B3189b8C6e90ff330CBA190153fF0A9997e , 0.5 ether ) ; addToWhitelist ( 0xCb033bE278d7bD297a2b1Cc6201113480daC579F , 0.5 ether ) ; addToWhitelist ( 0xCb570fE877CA6B7dE030afaf9483f58F774df135 , 0.5 ether ) ; addToWhitelist ( 0xcD4929fdDC83Aca93cD4a75bD12780DaDF51870b , 0.5 ether ) ; addToWhitelist ( 0xcdc22860Ff346ead18ECA5E30f0d302a95F33A19 , 0.5 ether ) ; addToWhitelist ( 0xD26BA3C03fBC1EA352b5F77B2c1F2881d03D1e2F , 0.5 ether ) ; addToWhitelist ( 0xd454ED303748Bb5a433388F9508433ba5d507030 , 0.5 ether ) ; addToWhitelist ( 0xd4d1197fed5F9f3679497Df3604147087B85Ce39 , 0.5 ether ) ; addToWhitelist ( 0xd83F072142C802A6fA3921d6512B25a7c1A216b1 , 0.5 ether ) ; chunk2IsAdded = true ; }
","Add chunk 2 / 7 to the whitelist
"
"function approve ( address _who , uint256 _value ) public returns ( bool ) { require ( _who != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _who ] == 0 ) ; allowed [ msg . sender ] [ _who ] = _value ; Approval ( msg . sender , _who , _value ) ; return true ; }
","Approves `` _who '' to transfer `` _value '' tokens from `` msg.sender '' to any address .
"
"function setStreamerContract ( address _contractAddress , uint256 _maxAmount ) onlyAdministrator { require ( _maxAmount == 0 || streamerContractMaxAmount == 0 ) ; streamerContract = _contractAddress ; streamerContractMaxAmount = _maxAmount ; StreamerContractChanged ( streamerContract , streamerContractMaxAmount ) ; }
","authorize an address to transfer GIM on behalf an user
"
"function setBuyFee ( uint32 _buyFeeMilliPercent ) onlyOwner public { require ( _buyFeeMilliPercent < MILLI_PERCENT_DIVIDER ) ; buyFeeMilliPercent = _buyFeeMilliPercent ; }
","Set fee applied when buying tokens
"
"function _removeModuleWithIndex ( uint8 _type , uint256 _index ) internal { uint256 length = modules [ _type ] . length ; modules [ _type ] [ _index ] = modules [ _type ] [ length - 1 ] ; modules [ _type ] . length = length - 1 ; if ( ( length - 1 ) != _index ) { uint8 [ ] memory newTypes = modulesToData [ modules [ _type ] [ _index ] ] . moduleTypes ; for ( uint256 i = 0 ; i < newTypes . length ; i ++ ) { if ( newTypes [ i ] == _type ) { modulesToData [ modules [ _type ] [ _index ] ] . moduleIndexes [ i ] = _index ; } } } }
","Internal - Removes a module attached to the SecurityToken by index
"
"function setBeneficiary ( address newBeneficiary ) external only ( owner ) { beneficiary = newBeneficiary ; }
","set beneficiary - the account receiving platform fees .
"
"function ( ) payable { require ( ! saleHasEnded ) ; require ( now > PRESALE_START_DATE ) ; require ( now < PRESALE_END_DATE ) ; require ( msg . value >= MINIMUM_PARTICIPATION_AMOUNT ) ; require ( msg . value <= MAXIMUM_PARTICIPATION_AMOUNT ) ; if ( isWhitelistingActive ) { require ( earlyParticipantWhitelist [ msg . sender ] ) ; } require ( safeIncrement ( totalFunding , msg . value ) <= PRESALE_MAXIMUM_FUNDING ) ; addBalance ( msg . sender , msg . value ) ; }
","A participant 's contribution will be rejected if the presale has been funded to the maximum amount
"
"function onApprove ( address , address , uint ) returns ( bool ) { return ( transferable || getBlockTimestamp ( ) >= October12_2017 ) ; }
","Notifies the controller about an approval allowing the controller to react if desired
"
"function doFinalizeSale ( ) internal onlyOwner { if ( saleFinalized ) revert ( ) ; uint256 teamTokens = safeMul ( token . totalSupply ( ) , teamTokenRatio ) ; if ( teamTokens > 0 ) { if ( ! token . mint ( tokenOwnerWallet , teamTokens ) ) revert ( ) ; } if ( this . balance > 0 ) { if ( ! fundOwnerWallet . send ( this . balance ) ) revert ( ) ; } saleFinalized = true ; saleStopped = true ; LogFinalized ( tokenOwnerWallet , teamTokens ) ; }
","finalize the crowdfun sale
"
"function setTierRates ( uint256 tier1 , uint256 tier2 , uint256 tier3 , uint256 tier4 ) external onlyOwner whenNotPaused { require ( tier1 > 0 && tier2 > 0 && tier3 > 0 && tier4 > 0 ) ; rate = tier1 ; rateTier2 = tier2 ; rateTier3 = tier3 ; rateTier4 = tier4 ; }
","Set 's the rate of tokens per ether for each tier .
"
"function placeAds ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , string imageSource , string link , string text ) external whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; uint AdsId = ads . advertiseOnBlocks ( msg . sender , blocksList ( fromX , fromY , toX , toY ) , imageSource , link , text ) ; emit LogAds ( AdsId , fromX , fromY , toX , toY , imageSource , link , text , msg . sender ) ; }
","places ads ( image , caption and link to a website ) into desired coordinates
"
"function transfer ( address to , uint quantity ) public pausableIfNotSelfDestructing returns ( bool ) { return _transfer ( msg . sender , to , quantity ) ; }
","ERC20 transfer function ; transfers ` quantity ` tokens from the message sender to ` to ` .
"
"function changeExchangeOperator ( address newExchangeOperator ) public only_exchange_operator { EXCHANGE_OPERATOR = newExchangeOperator ; }
","Changes the exchange operator .
"
"function calcSharePrice ( ) view returns ( uint sharePrice ) { ( , , , , , sharePrice ) = performCalculations ( ) ; return sharePrice ; }
","Calculates sharePrice denominated in [ base unit of melonAsset ]
"
"function getTaiAMT ( uint256 amtETH ) public constant returns ( uint256 ) { uint256 amount = amtETH / buyPrice ; amount = amount * 10 ** uint256 ( decimals ) ; return amount ; }
","Get taitoss transaction amount
"
"function getInvestorCount ( ) external view returns ( uint256 ) { return investorData . investorCount ; }
","Returns the investor count
"
"function changeSTVersionBounds ( string _boundType , uint8 [ ] _newVersion ) external ;
","Function use to change the lower and upper bound of the compatible version st
"
"function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( owner_ ) ; owner_ = address ( 0 ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function getVestingQuantity ( address account , uint index ) public view returns ( uint ) { return getVestingScheduleEntry ( account , index ) [ QUANTITY_INDEX ] ; }
","Get the quantity of SNX associated with a given schedule entry .
"
"function getBalance ( ) public view onlyAuthorized returns ( uint ) { return address ( this ) . balance ; }
","getBalance ether
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public { require ( approve ( _spender , _value ) ) ; IApprovalRecipient ( _spender ) . receiveApproval ( msg . sender , _value , _extraData ) ; }
","Approves spending tokens and immediately triggers token recipient logic .
"
"function getCanvasPaintedPixelsCount ( uint32 _canvasId ) public view returns ( uint32 ) { return _getCanvas ( _canvasId ) . paintedPixelsCount ; }
","Returns how many pixels has been already set .
"
"function setFeeMin ( Data storage self , uint feeMin ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.min' , address ( this ) ) ) ; require ( self . Storage . setUint ( id , feeMin ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set minimum fee for contract interface
"
"function withdrawBalance ( ) external onlyCFO { cfoAddress . transfer ( this . balance ) ; }
","Allow the CFO to withdraw balance available to this contract .
"
"function getAttributeApprovalHash ( address account , address operator , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee ) external view returns ( bytes32 hash ) { return calculateAttributeApprovalHash ( account , operator , attributeTypeID , value , fundsRequired , validatorFee ) ; }
","Get the hash of a given attribute approval .
"
"function setTokenFeeMin ( uint256 min ) public onlyOwner { tokenFeeMin = min ; }
","Set the minimum number of tokens to be deducted during a buy .
"
"function getBalanceTAI ( ) public constant returns ( uint256 ) { uint256 balTAI ; balTAI = balanceOf [ msg . sender ] ; return balTAI ; }
","Get the balance of taitoss
"
"function platformLogout ( address _toLogout , uint256 _newBalance ) external isAdmin { cooldown [ _toLogout ] = now + 30 minutes ; alterBankBalance ( _toLogout , _newBalance ) ; }
","De-Freeze user - Backend Function
"
"function revokeAttribute ( address account , uint256 attributeTypeID ) external ;
","Revoke the attribute of the type with ID ` attributeTypeID ` from ` account ` if ` message.caller.address ( ) ` is the issuing validator .
"
"function isState ( uint256 _tokenId , uint8 _state ) public view returns ( bool ) { return assets [ _tokenId ] . state == _state ; }
","Check if asset is in the state passed by parameter
"
"function finish ( ) onlyAdmin ( 2 ) public { if ( state != State . Successful ) { state = State . Successful ; completedAt = now ; } uint256 remanent = tokenReward . balanceOf ( this ) ; require ( creator . send ( address ( this ) . balance ) ) ; tokenReward . transfer ( creator , remanent ) ; emit LogBeneficiaryPaid ( creator ) ; emit LogContributorsPayout ( creator , remanent ) ; }
","closure handler
"
"function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return tokenBalanceOf [ _owner ] ; }
","What is the balance of a particular account ?
"
"function burn ( address burner , uint256 _value ) public { require ( _value <= balances [ burner ] ) ; if ( _value > 0 ) { balances [ burner ] = SafeMath . sub ( balances [ burner ] , _value ) ; totalSupply = SafeMath . sub ( totalSupply , _value ) ; Burn ( burner , _value ) ; Transfer ( burner , address ( 0 ) , _value ) ; } }
","burns _value of tokens from address burner
"
"function addBeneficiary ( address beneficiary , uint256 startTime , uint256 releaseTime , uint256 amount ) external onlyOwner { Info storage info = _info [ beneficiary ] ; require ( ! info . known , ""This address is already known to the contract."" ) ; require ( releaseTime > startTime , ""Release time must be later than the start time."" ) ; require ( releaseTime > block . timestamp , ""End of vesting period must be somewhere in the future."" ) ; info . startTime = startTime ; info . totalAmount = amount ; info . releaseTime = releaseTime ; info . known = true ; }
","Add beneficiaries to the contract , allowing them to withdraw tokens .
"
"function finalize ( ) minCapReached salePeriodCompleted isValidState onlyBy ( owner ) external { balances [ gmtFundAddress ] = balances [ gmtFundAddress ] . add ( gmtFund ) ; assignedSupply = assignedSupply . add ( gmtFund ) ; ClaimGMT ( gmtFundAddress , gmtFund ) ; Transfer ( 0x0 , gmtFundAddress , gmtFund ) ; if ( assignedSupply < totalSupply ) { uint256 unassignedSupply = totalSupply . sub ( assignedSupply ) ; balances [ gmtFundAddress ] = balances [ gmtFundAddress ] . add ( unassignedSupply ) ; assignedSupply = assignedSupply . add ( unassignedSupply ) ; ClaimGMT ( gmtFundAddress , unassignedSupply ) ; Transfer ( 0x0 , gmtFundAddress , unassignedSupply ) ; } ethFundAddress . transfer ( this . balance ) ; isFinalized = true ; }
","Sends the ETH to ETH fund wallet and finalizes the token sale
"
"function tokenURI ( uint256 _tokenId ) external view returns ( string ) { require ( _tokenId < totalSupply ( ) ) ; uint256 uid ; bytes32 bid ; uid = _tokenId ; if ( uid == 0 ) { bid = '0' ; } else { while ( uid > 0 ) { bid = bytes32 ( uint ( bid ) / ( 2 ** 8 ) ) ; bid |= bytes32 ( ( ( uid % 10 ) + 48 ) * 2 ** ( 8 * 31 ) ) ; uid /= 10 ; } } return string ( abi . encodePacked ( baseUri , bid ) ) ; }
","A distinct Uniform Resource Identifier ( URI ) for a given asset .
"
"function cancelPoll ( uint _idPoll ) public { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll storage p = _polls [ _idPoll ] ; require ( ! p . canceled , ""Poll has been canceled already"" ) ; require ( block . timestamp <= p . endTime , ""Only active polls can be canceled"" ) ; if ( p . startBlock < block . number ) { require ( msg . sender == controller , ""Only the controller can cancel the poll"" ) ; } else { require ( p . author == msg . sender , ""Only the owner can cancel the poll"" ) ; } p . canceled = true ; emit PollCanceled ( _idPoll ) ; }
","Cancel an existing poll
"
"function vote ( uint256 _voteId , bool _supports , bool _executesIfDecided ) external voteExists ( _voteId ) { require ( canVote ( _voteId , msg . sender ) , ERROR_CAN_NOT_VOTE ) ; _vote ( _voteId , _supports , msg . sender , _executesIfDecided ) ; }
","Vote ` _supports ?
"
"function withdrawNomins ( uint amount ) external onlyOwner { nomin . transfer ( owner , amount ) ; }
","Withdraw nomins : Allows the owner to withdraw nomins from this contract if needed .
"
"function approve ( address _approved , uint256 _tokenId ) external payable { require ( msg . sender == CaDataContract . atomOwner ( _tokenId ) || ownerOperators [ CaDataContract . atomOwner ( _tokenId ) ] [ msg . sender ] ) ; tokenApprovals [ _tokenId ] = _approved ; Approval ( CaDataContract . atomOwner ( _tokenId ) , _approved , _tokenId ) ; }
","Set or reaffirm the approved address for an NFT
"
"function getAttributeValidator ( address account , uint256 attributeTypeID ) external view returns ( address validator , bool isStillValid ) ;
","Find the validator that issued the attribute of the type with ID ` attributeTypeID ` on the account at ` account ` and determine if the validator is still valid .
"
"function refund ( ) external { if ( ! funding ) throw ; if ( block . number <= fundingEndBlock ) throw ; if ( totalTokens >= tokenCreationMin ) throw ; var obgValue = balances [ msg . sender ] ; if ( obgValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalTokens -= obgValue ; var ethValue = obgValue / tokenCreationRate ; Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }
","Get back the ether sent during the funding in case the funding has not reached the minimum level .
"
"function acceptInvite ( bytes _sig ) public onlyNonUser { address inviteAddress = signingLogic . recoverSigner ( keccak256 ( abi . encodePacked ( msg . sender ) ) , _sig ) ; require ( pendingInvites [ inviteAddress ] ) ; pendingInvites [ inviteAddress ] = false ; createAccountForUser ( msg . sender ) ; emit InviteAccepted ( msg . sender , inviteAddress ) ; }
","Accept an invite using the signing model described in the contract description
"
"function mint ( address _to , uint256 _value ) public minterOrOwner blockLock ( msg . sender ) returns ( bool success ) { if ( totalSupply + _value <= totalSupply ) { return false ; } balances [ _to ] += _value ; totalSupply += _value ; Mint ( _to , _value , totalSupply ) ; Transfer ( 0x0 , _to , _value ) ; return true ; }
","Mint new tokens .
"
"function executeVote ( uint256 _voteId ) external voteExists ( _voteId ) { require ( canExecute ( _voteId ) , ERROR_CAN_NOT_EXECUTE ) ; _executeVote ( _voteId ) ; }
","Execute vote # ` _voteId `
"
"function getTokenDetails ( address token ) public view returns ( address ad , uint required , bool active , uint valid ) { return ( acceptedTokens [ token ] . tokenAddress , acceptedTokens [ token ] . requiredAmount , acceptedTokens [ token ] . active , acceptedTokens [ token ] . validUntil ) ; }
","Returns a full list of the token details
"
"function getSencBalance ( ) public view returns ( uint256 ) { return sencToken ( ) . balanceOf ( address ( this ) ) ; }
","The ` getSencBalance ( ) ` retrieve the SENC balance of the contract in Wei .
"
"function balanceOf ( address _person ) public constant returns ( uint256 _balance ) { return balances [ _person ] ; }
","Used to look up balance of a person
"
"function isFulfilled ( Deliverable storage self , address _creator , address _brand ) internal view returns ( bool ) { return self . fulfillment [ _creator ] && self . fulfillment [ _brand ] ; }
","check if deliverable fulfilled completely
"
"function drop ( address tokenContractAddress , address [ ] recipients , uint256 [ ] amounts ) public ownerOnly { require ( tokenContractAddress != 0x0 ) ; require ( recipients . length == amounts . length ) ; require ( recipients . length <= 300 ) ; ERC20 tokenContract = ERC20 ( tokenContractAddress ) ; for ( uint8 i = 0 ; i < recipients . length ; i ++ ) { tokenContract . transfer ( recipients [ i ] , amounts [ i ] ) ; } }
","More than 300 accounts will exceed gas block limit .
"
"function addHodlerStake ( address _beneficiary , uint256 _stake ) public onlyOwner beforeHodlStart { if ( _stake == 0 || _beneficiary == address ( 0 ) ) return ; if ( hodlerStakes [ _beneficiary ] . stake == 0 ) hodlerTotalCount = hodlerTotalCount . add ( 1 ) ; hodlerStakes [ _beneficiary ] . stake = hodlerStakes [ _beneficiary ] . stake . add ( _stake ) ; hodlerTotalValue = hodlerTotalValue . add ( _stake ) ; LogHodlSetStake ( msg . sender , _beneficiary , hodlerStakes [ _beneficiary ] . stake ) ; }
","Adding hodler stake to an account
"
"function splitBid ( uint _amount ) public pure returns ( uint commission , uint paintersRewards ) { uint _rewardPerPixel = ( ( _amount - _calculatePercent ( _amount , COMMISSION ) ) ) / PIXEL_COUNT ; uint _rewards = _rewardPerPixel * PIXEL_COUNT ; return ( _amount - _rewards , _rewards ) ; }
","Calculates how the initial bidding money will be split .
"
"function setWithdrawalAddress ( address _newWithdrawalAddress ) external onlyCEO { require ( _newWithdrawalAddress != address ( 0 ) ) ; withdrawalAddress = _newWithdrawalAddress ; }
","Sets a new withdrawalAddress
"
"function deleteInt ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete intStorage [ _key ] ; return true ; }
","Delete value for Int associated with bytes32 id key
"
"function list_bytesarray_from ( bytes32 _current_item , uint256 _count , function ( ) external constant returns ( bytes32 ) _function_first , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _bytes_items ) { if ( _from_start ) { _bytes_items = private_list_bytes_from_bytes ( _current_item , _count , false , _function_last , _function_next ) ; } else { _bytes_items = private_list_bytes_from_bytes ( _current_item , _count , false , _function_first , _function_previous ) ; } }
","Lists a Bytes collection from some ` _current_item ` , going forwards or backwards depending on ` _from_start `
"
"function contribute ( ) public notFinished payable { require ( msg . value > ( 10 ** 10 ) ) ; uint256 tokenBought = 0 ; totalRaised = totalRaised . add ( msg . value ) ; tokenBought = msg . value . div ( 10 ** 10 ) ; tokenBought = tokenBought . mul ( rate ) ; if ( now < dateTimeContract . toTimestamp ( 2018 , 2 , 15 ) ) { tokenBought = tokenBought . mul ( 15 ) ; tokenBought = tokenBought . div ( 10 ) ; require ( totalDistributed . add ( tokenBought ) <= 100000000 * ( 10 ** 8 ) ) ; } else if ( now < dateTimeContract . toTimestamp ( 2018 , 2 , 28 ) ) { tokenBought = tokenBought . mul ( 14 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( now < dateTimeContract . toTimestamp ( 2018 , 3 , 15 ) ) { tokenBought = tokenBought . mul ( 13 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( now < dateTimeContract . toTimestamp ( 2018 , 3 , 31 ) ) { tokenBought = tokenBought . mul ( 12 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( now < dateTimeContract . toTimestamp ( 2018 , 4 , 30 ) ) { tokenBought = tokenBought . mul ( 11 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( now < dateTimeContract . toTimestamp ( 2018 , 5 , 15 ) ) { tokenBought = tokenBought . mul ( 105 ) ; tokenBought = tokenBought . div ( 100 ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; LogContributorsPayout ( msg . sender , tokenBought ) ; checkIfFundingCompleteOrExpired ( ) ; }
","contribution handler
"
"function unpause ( ) external onlyCEO whenPaused { paused = false ; }
","This is public rather than external so it can be called by derived contracts .
"
"function approve ( address _spender , uint256 _amount ) public erc20 returns ( bool success ) { mAllowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
","ERC20 backwards compatible approve .
"
"function __callback ( bytes32 _id , string _result ) public { require ( msg . sender == oraclize_cbAddress ( ) ) ; require ( ids [ _id ] == true ) ; ETHEUR = _result ; fidaPerEther = parseInt ( _result , 5 ) ; emit PriceUpdated ( _id , _result ) ; }
","Oraclize callback function
"
"function getCheckpointTimes ( ) external view returns ( uint256 [ ] ) { return checkpointTimes ; }
","Gets list of times that checkpoints were created
"
"function setKyberNetworkContract ( address _kyberNetworkAddress ) external onlyOwner { kyberContract = KyberNetwork ( _kyberNetworkAddress ) ; }
","Sets the KyberNetwork contract address .
"
"function finalizeCrowdsale ( ) public onlyOwner { rate = 0 ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; if ( this . balance > 0 ) owner . transfer ( this . balance ) ; }
","Closes crowdsale , finishes minting ( allowing token transfers ) , transfers token ownership to the owner
"
"function validateSubjectSig ( address _subject , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig ) private { bytes32 _signatureDigest = generateRequestAttestationSchemaHash ( _dataHash , _requestNonce ) ; require ( _subject == recoverSigner ( _signatureDigest , _subjectSig ) ) ; burnSignatureDigest ( _signatureDigest , _subject ) ; }
","Verify subject signature is valid
"
"function depositTokens ( bytes32 manufacturerId , uint256 amount ) public returns ( bool ) { require ( manufacturerId != 0 , ""manufacturerId is required"" ) ; require ( amount > 0 , ""amount is required"" ) ; address manufacturer = manufacturerRewards [ manufacturerId ] ; require ( manufacturer != address ( 0 ) ) ; _depositTokens ( manufacturer , amount ) ; emit TokensDeposited ( msg . sender , manufacturerId , manufacturer , amount ) ; require ( token . transferFrom ( msg . sender , address ( this ) , amount ) ) ; return true ; }
","anyone can donate tokens to a manufacturer 's pool
"
"function claimTokens ( address _token ) public auth { if ( _token == 0x0 ) { address ( msg . sender ) . transfer ( address ( this ) . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( address ( msg . sender ) , balance ) ; emit ClaimedTokens ( _token , address ( msg . sender ) , balance ) ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) revert ( ) ; } return super . approve ( _spender , _amount ) ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function getBalance ( ERC20 token ) constant returns ( uint ) { if ( token == ETH_TOKEN_ADDRESS ) return this . balance ; else return token . balanceOf ( this ) ; }
","a debug function
"
"function addContract ( string _contractName , address _address ) external ;
","Add a new contract to the manager
"
"function calculateFee ( uint256 tokens , uint256 ethers ) public view returns ( uint256 tokenFee , uint256 etherFee ) { tokenFee = multiplyAtPrecision ( tokens , tokenFeePercent / 100 , 9 ) ; if ( tokenFee < tokenFeeMin ) tokenFee = tokenFeeMin ; etherFee = multiplyAtPrecision ( ethers , etherFeePercent / 100 , 9 ) ; if ( etherFee < etherFeeMin ) etherFee = etherFeeMin ; return ( tokenFee , etherFee ) ; }
","Calculate the company 's fee for facilitating the transfer of tokens .
"
"function icoBuy ( ) public icoPhase ( ) payable { prizePool . transfer ( msg . value ) ; raisedIcoValue = raisedIcoValue . add ( msg . value ) ; uint256 tokenAmount = calculateTokenAmountICO ( msg . value ) ; require ( icoPool >= tokenAmount ) ; icoPool = icoPool . sub ( tokenAmount ) ; balances [ msg . sender ] += tokenAmount ; TransferEvent ( prizePool , msg . sender , tokenAmount ) ; }
","Please make sure that ICO Pool is at least equal to your bid
"
"function darknodeBond ( address darknodeID ) external view onlyOwner returns ( uint256 ) { return darknodeRegistry [ darknodeID ] . bond ; }
","Returns the bond of a given darknode .
"
"function ( ) payable external { if ( msg . value > 0 ) { EtherReceived ( msg . value ) ; } }
","Accepts Ether and emits EtherReceived event
"
"function isMakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { if ( orderPrice < sub ( referencePrice , wmul ( RISK_LEVEL , referencePrice ) ) ) { return false ; } return true ; }
","Checks if the makeOrder price is within maximum allowed deviation from reference price
"
"function setDisputeFee ( uint256 fee ) onlyOwner public { dispute_fee = fee ; LogSetDisputeFee ( fee ) ; }
","Set the default fee
"
"function hasAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; return ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) ; }
","Check if an attribute of the type with ID ` attributeTypeID ` has been assigned to the account at ` account ` and is still valid .
"
"function userForceGameEnd ( uint _gameId ) public { address userAddress = msg . sender ; uint gameId = userGameId [ userAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId , ""inv gameId"" ) ; require ( game . status == GameStatus . USER_INITIATED_END , ""inv status"" ) ; int newBalance = conflictRes . userForceGameEnd ( game . gameType , game . betNum , game . betValue , game . balance , game . stake , game . endInitiatedTime ) ; closeGame ( game , gameId , game . roundId , userAddress , ReasonEnded . USER_FORCED_END , newBalance ) ; }
","Force end of game if server does not respond .
"
"function metaBurnCarbonDollar ( address _stablecoin , uint256 _amount , bytes _signature , uint256 _nonce , uint256 _reward ) public whenNotPaused returns ( bool ) { bytes32 metaHash = metaBurnHash ( _stablecoin , _amount , _nonce , _reward ) ; address signer = _getSigner ( metaHash , _signature ) ; require ( ! regulator . isBlacklistedUser ( signer ) , ""signer is blacklisted"" ) ; require ( _nonce == replayNonce [ signer ] , ""this transaction has already been broadcast"" ) ; replayNonce [ signer ] ++ ; require ( _reward > 0 , ""reward to incentivize relayer must be positive"" ) ; require ( ( _amount + _reward ) <= balanceOf ( signer ) , ""not enough balance to burn and reward relayer"" ) ; _burnCarbonDollar ( signer , _stablecoin , _amount ) ; _transfer ( msg . sender , signer , _reward ) ; return true ; }
","Verify and broadcast a burnCarbonDollar ( ) signed metatransaction .
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) ;
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function _payFees ( address account , uint xdrAmount , bytes4 destinationCurrencyKey ) internal notFeeAddress ( account ) { require ( account != address ( 0 ) , ""Account can't be 0"" ) ; require ( account != address ( this ) , ""Can't send fees to fee pool"" ) ; require ( account != address ( proxy ) , ""Can't send fees to proxy"" ) ; require ( account != address ( synthetix ) , ""Can't send fees to synthetix"" ) ; Synth xdrSynth = synthetix . synths ( ""XDR"" ) ; Synth destinationSynth = synthetix . synths ( destinationCurrencyKey ) ; xdrSynth . burn ( FEE_ADDRESS , xdrAmount ) ; uint destinationAmount = synthetix . effectiveValue ( ""XDR"" , xdrAmount , destinationCurrencyKey ) ; destinationSynth . issue ( account , destinationAmount ) ; destinationSynth . triggerTokenFallbackIfNeeded ( FEE_ADDRESS , account , destinationAmount ) ; }
","Send the fees to claiming address .
"
"function setUpgradeMaster ( address master ) external { if ( getState ( ) != State . Success ) throw ; if ( master == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; upgradeMaster = master ; }
","Set address of upgrade target contract and enable upgrade process .
"
"function removeNetworkMember ( address _member ) public onlyIRNorOwner returns ( bool ) { bytes32 memberId = network [ _member ] . memberId ; if ( network [ _member ] . isManufacturer ) { if ( pools [ _member ] . balance == 0 ) { delete pools [ _member ] ; } delete manufacturerRewards [ memberId ] ; } delete network [ _member ] ; emit NetworkMemberRemoved ( msg . sender , _member , memberId ) ; return true ; }
","remove a member from the network
"
"function getInterfaceImplementer ( address _addr , bytes32 _interfaceHash ) external view returns ( address ) { address addr = _addr == 0 ? msg . sender : _addr ; if ( isERC165Interface ( _interfaceHash ) ) { bytes4 erc165InterfaceHash = bytes4 ( _interfaceHash ) ; return implementsERC165Interface ( addr , erc165InterfaceHash ) ? addr : 0 ; } return interfaces [ addr ] [ _interfaceHash ] ; }
","Query if an address implements an interface and through which contract .
"
"function totalSupply ( ) public view returns ( uint ) { return animecards . length ; }
","Required for ERC-20 and ERC-721 compliance .
"
"function settle ( bytes32 _buyID , bytes32 _sellID ) external { require ( orderStatus [ _buyID ] == OrderStatus . Submitted , ""invalid buy status"" ) ; require ( orderStatus [ _sellID ] == OrderStatus . Submitted , ""invalid sell status"" ) ; require ( orderDetails [ _buyID ] . settlementID == RENEX_ATOMIC_SETTLEMENT_ID || orderDetails [ _buyID ] . settlementID == RENEX_SETTLEMENT_ID , ""invalid settlement id"" ) ; require ( SettlementUtils . verifyMatchDetails ( orderDetails [ _buyID ] , orderDetails [ _sellID ] ) , ""incompatible orders"" ) ; require ( orderbookContract . orderMatch ( _buyID ) == _sellID , ""unconfirmed orders"" ) ; TokenPair memory tokens = getTokenDetails ( orderDetails [ _buyID ] . tokens ) ; require ( tokens . priorityToken . registered , ""unregistered priority token"" ) ; require ( tokens . secondaryToken . registered , ""unregistered secondary token"" ) ; address buyer = orderbookContract . orderTrader ( _buyID ) ; address seller = orderbookContract . orderTrader ( _sellID ) ; require ( buyer != seller , ""orders from same trader"" ) ; execute ( _buyID , _sellID , buyer , seller , tokens ) ; matchTimestamp [ _buyID ] [ _sellID ] = now ; orderStatus [ _buyID ] = OrderStatus . Settled ; orderStatus [ _sellID ] = OrderStatus . Settled ; }
","Settles two orders that are matched .
"
"function ( ) public payable { _getAsset ( ) . __process . value ( msg . value ) ( msg . data , msg . sender ) ; }
","Resolves asset implementation contract for the caller and forwards there transaction data , along with the value .
"
"function transfer ( address _to , uint _amount ) internal { if ( address ( baseToken ) != 0 ) { require ( baseToken . transfer ( _to , _amount ) ) ; } else { require ( _to . send ( _amount ) ) ; } }
","Sends an ` _amount ` of ` baseToken ` to ` _to ` from this contract , and it can only be called by the contract itself
"
"function onWhitelist ( address _investor ) internal view returns ( bool ) { return ( ( ( whitelist [ _investor ] . fromTime != 0 ) || ( whitelist [ _investor ] . toTime != 0 ) ) && ( whitelist [ _investor ] . expiryTime >= now ) ) ; }
","Internal function used to check whether the investor is in the whitelist or not & also checks whether the KYC of investor get expired or not
"
"function createTemplate ( string content ) public returns ( uint256 ) { }
","Create a reusable template , which should be a JSON document .
"
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( ! transfersEnabled ) throw ; return doTransfer ( msg . sender , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function PANIC ( ) returns ( bool ) ;
","Cause the contract to Panic .
"
"function __transferWithReference ( address _to , uint _value , string _reference , address _sender ) onlyAccess ( _sender ) public returns ( bool ) { return chronoBankPlatform . proxyTransferWithReference ( _to , _value , smbl , _reference , _sender ) == OK ; }
","Performs transfer call on the platform by the name of specified sender .
"
"function initialize ( address _msp , address _mspController , uint256 _totalSupplyCap , uint256 _exchangeRate , uint256 _minimum_goal , uint256 _startBlock , uint256 _endBlock , address _destEthDevs , address _destTokensSit , address _destTokensTeam , address _destTokensReferals , address _sit ) public onlyController { assert ( address ( msp ) == 0x0 ) ; msp = MiniMeTokenI ( _msp ) ; assert ( msp . totalSupply ( ) == 0 ) ; assert ( msp . controller ( ) == address ( this ) ) ; assert ( msp . decimals ( ) == 18 ) ; require ( _mspController != 0x0 ) ; mspController = _mspController ; require ( _exchangeRate > 0 ) ; exchangeRate = _exchangeRate ; assert ( _startBlock >= getBlockNumber ( ) ) ; require ( _startBlock < _endBlock ) ; startBlock = _startBlock ; endBlock = _endBlock ; require ( _destEthDevs != 0x0 ) ; destEthDevs = _destEthDevs ; require ( _destTokensSit != 0x0 ) ; destTokensSit = _destTokensSit ; require ( _destTokensTeam != 0x0 ) ; destTokensTeam = _destTokensTeam ; require ( _destTokensReferals != 0x0 ) ; destTokensReferals = _destTokensReferals ; require ( _sit != 0x0 ) ; sit = MiniMeTokenI ( _sit ) ; initializedBlock = getBlockNumber ( ) ; assert ( sit . totalSupplyAt ( initializedBlock ) * 5 <= _totalSupplyCap ) ; totalSupplyCap = _totalSupplyCap ; totalSaleSupplyCap = percent ( 70 ) . mul ( _totalSupplyCap ) . div ( percent ( 100 ) ) ; minimum_goal = _minimum_goal ; }
","This method should be called by the controller before the contribution period starts This initializes most of the parameters
"
"function mint ( address _investor , uint256 _amount ) public returns ( bool success ) ;
","mints new tokens and assigns them to the target _investor .
"
"function transferLand ( uint256 estateId , uint256 landId , address destinatary ) external canTransfer ( estateId ) { return _transferLand ( estateId , landId , destinatary ) ; }
","Transfer a LAND owned by an Estate to a new owner
"
"function getName ( ) external view returns ( bytes32 ) ;
","Get the name of the Module
"
"function getAttributeTypeDescription ( uint256 attributeTypeID ) external view returns ( string description ) ;
","Get a description of the attribute type with ID ` attributeTypeID ` .
"
"function ln ( uint256 _numerator , uint256 _denominator ) internal pure returns ( uint256 ) { assert ( _numerator <= MAX_NUM ) ; uint256 res = 0 ; uint256 x = _numerator * FIXED_1 / _denominator ; if ( x >= FIXED_2 ) { uint8 count = floorLog2 ( x / FIXED_1 ) ; x >>= count ; res = count * FIXED_1 ; } if ( x > FIXED_1 ) { for ( uint8 i = MAX_PRECISION ; i > 0 ; -- i ) { x = ( x * x ) / FIXED_1 ; if ( x >= FIXED_2 ) { x >>= 1 ; res += ONE << ( i - 1 ) ; } } } return ( ( res * LN2_MANTISSA ) >> LN2_EXPONENT ) / FIXED_3 ; }
","Compute the natural logarithm
"
"function adjustCheckpoints ( TokenLib . Checkpoint [ ] storage _checkpoints , uint256 _newValue , uint256 _currentCheckpointId ) public { if ( _currentCheckpointId == 0 ) { return ; } if ( ( _checkpoints . length > 0 ) && ( _checkpoints [ _checkpoints . length - 1 ] . checkpointId == _currentCheckpointId ) ) { return ; } _checkpoints . push ( TokenLib . Checkpoint ( { checkpointId : _currentCheckpointId , value : _newValue } ) ) ; }
","Stores the changes to the checkpoint objects
"
"function getTickerRegistrationFee ( ) external view returns ( uint256 ) ;
","Gets the ticker registration fee
"
"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom due to insufficent Allowance provided"" ) ; address permissionManager = new GeneralPermissionManager ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( address ( permissionManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return permissionManager ; }
","Used to launch the Module with the help of factory
"
"function leaveTokenGroup ( uint256 _tokenId ) external whenNotPaused { address userAdd = msg . sender ; var group = tokenIndexToGroup [ _tokenId ] ; var contributor = userAddressToContributor [ userAdd ] ; require ( _addressNotNull ( userAdd ) ) ; require ( group . exists ) ; require ( group . purchasePrice == 0 ) ; require ( group . addressToContributorArrIndex [ userAdd ] > 0 ) ; require ( contributor . tokenIdToGroupArrIndex [ _tokenId ] > 0 ) ; uint refundBalance = _clearContributorRecordInGroup ( _tokenId , userAdd ) ; _clearGroupRecordInContributor ( _tokenId , userAdd ) ; userAddressToContributor [ userAdd ] . withdrawableBalance += refundBalance ; FundsDeposited ( userAdd , refundBalance ) ; LeaveGroup ( _tokenId , userAdd , tokenIndexToGroup [ _tokenId ] . contributedBalance , refundBalance ) ; }
","Allow user to leave purchase group ; note that their contribution will be added to their withdrawable balance , and not directly refunded .
"
"function mintToken ( uint256 _mintedAmount ) public onlyOwner { require ( ! _frozenAccount [ _owner ] ) ; require ( _balanceOf [ _owner ] + _mintedAmount >= _balanceOf [ _owner ] ) ; require ( _totalSupply + _mintedAmount >= _totalSupply ) ; _balanceOf [ _owner ] += _mintedAmount ; _totalSupply += _mintedAmount ; Mint ( _owner , _mintedAmount ) ; Transfer ( 0 , _owner , _mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` owner ` , can be run only by owner
"
"function addToAccesslist ( address user ) onlyOwner { accessHolder [ user ] = true ; }
","Adds the provided addresses to Access List .
"
"function finalizeAuction ( ) public isOwner atStage ( Stages . AuctionStarted ) { uint missingFunds = missingFundsToEndAuction ( ) ; require ( missingFunds == 0 || now > endTimeOfBids ) ; finalPrice = tokenMultiplier * receivedWei / tokensAuctioned ; finalizedTime = now ; stage = Stages . AuctionEnded ; AuctionEnded ( finalPrice ) ; assert ( finalPrice > 0 ) ; }
","Finalize the auction - sets the final XBET token price and changes the auction stage after no bids are allowed anymore .
"
"function setTokenVersion ( Data storage self , string tokenVersion ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.version' , address ( this ) ) ) ; require ( self . Storage . setString ( id , tokenVersion ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set the token version for Token interfaces
"
"function setTimelock ( uint _newTimeLock ) onlyContractOwner { if ( _newTimeLock < absoluteMinTimeLock ) throw ; timeLock = _newTimeLock ; }
","` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `
"
"function onDestroyTokens ( address sender , address owner , uint256 amount ) public constant returns ( bool allow ) ;
","see MTokenMint
"
"function receiverExecutePayment ( uint256 _paymentId ) external isInitialized paymentExists ( _paymentId ) transitionsPeriod { require ( nextPaymentTime ( _paymentId ) <= getTimestamp64 ( ) , ERROR_RECEIVER_EXECUTE_PAYMENT_TIME ) ; require ( payments [ _paymentId ] . receiver == msg . sender , ERROR_PAYMENT_RECEIVER ) ; _executePayment ( _paymentId ) ; }
","Execute pending payment # ` _paymentId `
"
"function setFeePercentage ( uint256 _feePercentage ) external onlyCFO { require ( _feePercentage <= 4000 ) ; feePercentage = _feePercentage ; }
","Sets a new fee percentage .
"
"function withdraw ( uint32 [ ] _dates ) external { uint256 withdrawAmount = 0 ; uint256 datesLength = _dates . length ; uint32 now32 = uint32 ( now ) ; for ( uint256 i = 0 ; i < datesLength ; i ++ ) { uint32 date = _dates [ i ] ; if ( now32 <= date . add ( WITHDRAW_BUFFER ) ) { continue ; } if ( userDateToStatus [ msg . sender ] [ date ] != UserEntryStatus . COMPLETED ) { continue ; } userDateToStatus [ msg . sender ] [ date ] = UserEntryStatus . WITHDRAWN ; withdrawAmount = withdrawAmount . add ( REGISTRATION_FEE ) . add ( calculateBonus ( date ) ) ; } if ( withdrawAmount > 0 ) { msg . sender . transfer ( withdrawAmount ) ; } LogWithdraw ( msg . sender , withdrawAmount ) ; }
","Changes state
"
"function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 2 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 3 ) ) ) { require ( collectedTokens < total . percent ( 20 ) ) ; canExtract = total . percent ( 20 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 3 ) ) && getTime ( ) <= finalizedTime . add ( months ( 4 ) ) ) { require ( collectedTokens < total . percent ( 40 ) ) ; canExtract = total . percent ( 40 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 4 ) ) && getTime ( ) <= finalizedTime . add ( months ( 5 ) ) ) { require ( collectedTokens < total . percent ( 60 ) ) ; canExtract = total . percent ( 60 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 5 ) ) && getTime ( ) <= finalizedTime . add ( months ( 6 ) ) ) { require ( collectedTokens < total . percent ( 80 ) ) ; canExtract = total . percent ( 80 ) ; } else { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }
","The owner will call this method to extract the tokens
"
"function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }
","Get the token total supply
"
"function unpause ( ) public onlyOwner whenPaused { require ( address ( pvpListener ) != address ( 0 ) ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < nftList . length , ""index out of range"" ) ; return nftList [ _index ] ; }
","Enumerate valid NFTs
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function calculateFees ( uint amount ) public view returns ( uint fees ) { return lib . calculateFees ( lib . getFeeContract ( address ( this ) ) , amount ) ; }
","Calculates fee of a given transfer amount
"
"function getNamesInRange ( uint64 _startIndex , uint64 _endIndex ) public view returns ( bytes8 [ ] ) { require ( _startIndex <= totalSupply ( ) , ""Start index is out of bounds"" ) ; require ( _endIndex <= totalSupply ( ) , ""End index is out of bounds"" ) ; require ( _startIndex <= _endIndex , ""End index is less than the start index"" ) ; uint64 length = _endIndex - _startIndex ; bytes8 [ ] memory names = new bytes8 [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { names [ i ] = pixelconNames [ _startIndex + i ] ; } return names ; }
","Get the names of all PixelCons from index ` ( _startIndex ) ` to ` ( _endIndex ) `
"
"function receiveEther ( ) payable { require ( address ( baseToken ) == 0 ) ; EtherReceived ( msg . sender , msg . value ) ; }
","Called anytime ether is sent to the contract & & creates an event to more easily track the incoming transactions
"
"function _updateReferrals ( uint256 _newUserId , uint256 _refUserId ) private { if ( _newUserId == _refUserId ) return ; users [ _newUserId ] . referrersByLevel [ 0 ] = _refUserId ; for ( uint i = 1 ; i < referralLevelsCount ; i ++ ) { uint256 _refId = users [ _refUserId ] . referrersByLevel [ i - 1 ] ; users [ _newUserId ] . referrersByLevel [ i ] = _refId ; users [ _refId ] . referralsByLevel [ uint8 ( i ) ] . push ( _newUserId ) ; } users [ _refUserId ] . referralsByLevel [ 0 ] . push ( _newUserId ) ; }
","update referrersByLevel and referralsByLevel of new user
"
"function ( ) public payable { if ( now < PRIVATESALE_START_DATE ) revert ( ) ; if ( now > PRIVATESALE_END_DATE ) revert ( ) ; if ( msg . value < MINIMUM_PARTICIPATION_AMOUNT ) revert ( ) ; addBalance ( msg . sender , msg . value ) ; }
","A participant 's contribution will be rejected if the Private Sale has been funded to the maximum amount
"
"function paymentRewardTokens ( uint256 _rewardTokenAmount ) public validAmount ( _rewardTokenAmount ) senderHasEnoughTokens ( 0 , _rewardTokenAmount ) isWhitelisted ( msg . sender ) whenNotPaused { rewardBalances [ msg . sender ] = rewardBalances [ msg . sender ] . sub ( _rewardTokenAmount ) ; rewardBalances [ owner ] = rewardBalances [ owner ] . add ( _rewardTokenAmount ) ; emit TransferReward ( msg . sender , owner , _rewardTokenAmount ) ; }
","Process a payment using only reward TRVL Tokens .
"
"function totalSupply ( ) public view returns ( uint256 ) { return assets . length ; }
","Returns the total number of Assets currently in existence .
"
"function getHashRateOfCurrentHalving ( address _miner ) public constant returns ( bool , uint256 ) { return getHashRateOf ( _miner , currentHalving ( ) ) ; }
","Calculate the halving hash rate of a miner
"
"function burn ( uint256 mintedAmount ) public onlyManager whenNotPaused { require ( mintedAmount > 0 ) ; require ( totalSupply - mintedAmount <= totalSupply ) ; require ( balanceOf [ msg . sender ] - mintedAmount <= balanceOf [ msg . sender ] ) ; balanceOf [ msg . sender ] -= mintedAmount ; totalSupply -= mintedAmount ; emit Transfer ( 0 , msg . sender , mintedAmount ) ; }
","function burn decrease total Supply of tokens
"
"function initialize ( address _pfc , address _pfcController , uint256 _startTime , uint256 _endTime , address _destEthFoundation , uint256 _maxEth ) public onlyOwner { require ( address ( PFC ) == 0x0 ) ; PFC = MiniMeTokenSimple ( _pfc ) ; require ( PFC . totalSupply ( ) == 0 ) ; require ( PFC . controller ( ) == address ( this ) ) ; require ( PFC . decimals ( ) == 18 ) ; startTime = _startTime ; endTime = _endTime ; assert ( startTime < endTime ) ; require ( _pfcController != 0x0 ) ; pfcController = _pfcController ; require ( _destEthFoundation != 0x0 ) ; destEthFoundation = _destEthFoundation ; require ( _maxEth > 1 ether ) ; MaxEth = _maxEth ; }
","This method should be called by the owner before the contribution period starts This initializes most of the parameters
"
"function setICOPrice ( uint256 priceForIcoInWei ) isOwner { require ( priceForIcoInWei > 0 ) ; require ( icoPrice != priceForIcoInWei ) ; icoPrice = priceForIcoInWei ; updatePrices ( ) ; }
","Set current ICO price in wei for one token
"
"function setBountyWalletAddress ( address _walletAddress ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _walletAddress != address ( 0 ) ) ; require ( _walletAddress != bountyAddress ) ; address oldAddress = bountyAddress ; bountyAddress = _walletAddress ; emit BountyWalletAddressChanged ( oldAddress , _walletAddress ) ; }
","Change the address to where the bounty will be send when sale starts
"
"function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { uint256 availableGetAmount ; ( availableGetAmount , , , ) = oasis . getOffer ( data . offerId ) ; return availableGetAmount > data . maxAmountToSpend ? data . maxAmountToSpend : availableGetAmount ; }
","Gets the amount that Totle needs to give for this order
"
"function getInvestorCount ( ) external view returns ( uint256 ) ;
","Gets the investor count
"
"function setAllLocations ( uint [ ] _locations ) onlyOwner public { locations = _locations ; }
","Admin function for updating all locations
"
"function operatorSend ( address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) public { require ( isOperatorFor [ msg . sender ] [ _from ] ) ; doSend ( _from , _to , _amount , _userData , msg . sender , _operatorData , true ) ; }
","Send ` _amount ` of tokens on behalf of the address ` from ` to the address ` to ` .
"
"function getLastBidId ( ) external returns ( bytes32 _lastBidId ) { return lastBidId ; }
","Returns the greatest BidId ever registered to the contract
"
"function addUser ( address _user ) internal { if ( ! isAdded [ _user ] ) { users . push ( _user ) ; monthlyLimit [ _user ] = 1000000000000 ; isAdded [ _user ] = true ; } }
","Add the address to the user list
"
"function setMinter ( address _newMinter ) public onlyOwner returns ( bool success ) { minter = _newMinter ; NewMinter ( _newMinter ) ; return true ; }
","Set account that can mint new tokens
"
"function createCheckpoint ( ) public returns ( uint256 ) ;
","Creates a checkpoint that can be used to query historical balances / totalSuppy
"
"function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) internal { address senderImplementation = interfaceAddr ( _from , ""ERC777TokensSender"" ) ; if ( senderImplementation == 0 ) { return ; } ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; }
","Helper function that checks for ERC777TokensSender on the sender and calls it .
"
"function setPixel ( uint32 _canvasId , uint32 _index , uint8 _color ) external { Canvas storage _canvas = _getCanvas ( _canvasId ) ; _setPixelInternal ( _canvas , _canvasId , _index , _color ) ; _finishCanvasIfNeeded ( _canvas , _canvasId ) ; }
","Sets pixel .
"
"function setFeeAuthority ( address _feeAuthority ) external optionalProxy_onlyOwner { feeAuthority = _feeAuthority ; emitFeeAuthorityUpdated ( _feeAuthority ) ; }
","Set the address of the user/contract responsible for collecting or distributing fees .
"
"function setRequiredParticipation ( uint fraction ) external onlyOwner { require ( MIN_REQUIRED_PARTICIPATION <= fraction ) ; requiredParticipation = fraction ; }
","Set the required fraction of all Havvens that need to be part of a vote for it to pass .
"
"function addContract ( string _contractName , address _address ) external onlyContractOwner ( ""ContractManager"" , msg . sender ) { bytes memory contractNameBytes = bytes ( _contractName ) ; require ( contractNameBytes . length != 0 ) ; require ( contracts [ _contractName ] == address ( 0 ) ) ; require ( _address != address ( 0 ) ) ; contracts [ _contractName ] = _address ; emit ContractAdded ( _address , _contractName ) ; }
","Add a new contract to the manager
"
"function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) ;
","Checks if the takeOrder price is reasonable and not manipulative
"
"function setExecutiveOfficer ( address _executiveOfficerAddress ) external onlyExecutiveOfficer { require ( _executiveOfficerAddress != address ( 0 ) ) ; executiveOfficerAddress = _executiveOfficerAddress ; }
","Reassign the executive officer role
"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }
","Used to get the allowance of someone
"
"function sendReward ( uint intelIndex , uint rewardAmount ) public returns ( bool success ) { IntelState storage intel = intelDB [ intelIndex ] ; require ( intel . intelProvider != address ( 0x0 ) ) ; require ( msg . sender != intel . intelProvider ) ; require ( intel . rewardAfter > now ) ; require ( ! intel . rewarded ) ; token . transferFrom ( msg . sender , address ( this ) , rewardAmount ) ; intel . balance = intel . balance . add ( rewardAmount ) ; if ( intel . contributions [ msg . sender ] == 0 ) { intel . contributionsList . push ( msg . sender ) ; } intel . contributions [ msg . sender ] = intel . contributions [ msg . sender ] . add ( rewardAmount ) ; emit Reward ( msg . sender , intelIndex , rewardAmount ) ; return true ; }
","this function sends rewards to the Intel
"
"function userEndGameConflict ( uint32 _roundId , uint8 _gameType , uint _num , uint _value , int _balance , bytes32 _serverHash , bytes32 _userHash , uint _gameId , address _contractAddress , bytes _serverSig , bytes32 _userSeed ) public { verifySig ( _roundId , _gameType , _num , _value , _balance , _serverHash , _userHash , _gameId , _contractAddress , _serverSig , serverAddress ) ; userEndGameConflictImpl ( _roundId , _gameType , _num , _value , _balance , _userHash , _userSeed , _gameId , msg . sender ) ; }
","Can be used by user if server does not answer to the end game session request .
"
"function moveAllTokens ( address _to , bytes16 _uuid ) onlyAllowedAddresses whenNotPaused external { rntTokenVault . moveAllTokensToAddress ( _uuid , _to ) ; }
","Function for transfering all tokens from account to specified address .
"
"function isDefaulted ( Engine engine , uint256 index ) public view returns ( bool ) { return engine . getStatus ( index ) == Engine . Status . lent && engine . getDueTime ( index ) . add ( 7 days ) <= block . timestamp ; }
","Defines a custom logic that determines if a loan is defaulted or not .
"
"function deploySTO ( address _securityToken , address _polyAddress , address _factoryAddress ) external returns ( address ) ;
","Deploys the STO .
"
"function withdrawFrom ( address _affiliate , address _to ) onlyOwner public { require ( now > lastDepositTimes [ _affiliate ] . add ( commissionExpiryTime ) ) ; _performWithdraw ( _affiliate , _to ) ; }
","withdraw from a specific account
"
"function withdraw ( ) public { uint acc = 0 ; uint i = nextDepositToPayout [ msg . sender ] ; require ( i < deposits . length ) ; ERC20 currentToken = deposits [ i ] . token ; require ( msg . gas > 149000 ) ; while ( ( i < deposits . length ) && ( msg . gas > 148000 ) ) { Deposit storage d = deposits [ i ] ; if ( ( ! d . canceled ) && ( ! isDepositSkiped ( msg . sender , i ) ) ) { if ( currentToken != d . token ) { nextDepositToPayout [ msg . sender ] = i ; require ( doPayment ( i - 1 , msg . sender , currentToken , acc ) ) ; assert ( nextDepositToPayout [ msg . sender ] == i ) ; currentToken = d . token ; acc = 0 ; } acc += d . amount * rewardToken . balanceOfAt ( msg . sender , d . block ) / rewardToken . totalSupplyAt ( d . block ) ; } i ++ ; } nextDepositToPayout [ msg . sender ] = i ; require ( doPayment ( i - 1 , msg . sender , currentToken , acc ) ) ; assert ( nextDepositToPayout [ msg . sender ] == i ) ; }
","Sends all the tokens and ether to the token holder by looping through all the deposits , determining the appropriate amount by dividing the ` totalSupply ` by the number of tokens the token holder had at ` deposit.block ` for each deposit ; this function may have to be called multiple times if their are many deposits
"
"function finalizeSale ( ) public onlyController { require ( now > endTime || totalIssued >= HARD_CAP ) ; require ( ! finalized ) ; vestedAllowances [ vaultAddress ] = Vesting ( lockedTokens , now + 3 years ) ; uint256 leftoverTokens = MAX_TOKENS . sub ( lockedTokens ) . sub ( totalIssued ) . sub ( totalIssuedEarlySale ) . sub ( totalVested ) ; require ( tokenContract . generateTokens ( vaultAddress , leftoverTokens ) ) ; require ( tokenContract . generateTokens ( address ( this ) , lockedTokens . add ( totalVested ) ) ) ; finalized = true ; }
","` finalizeSale ( ) ` ends the TokenSale .
"
"function giftOwnerByIndex ( address _owner , uint256 _index ) external constant returns ( uint256 GiftId ) { uint256 [ ] memory ownerGifts = GiftsOfOwner ( _owner ) ; return ownerGifts [ _index ] ; }
","This method MUST NEVER be called by smart contract code .
"
"function maxIssuableSynths ( address issuer , bytes4 currencyKey ) public view returns ( uint ) { uint destinationValue = effectiveValue ( ""SNX"" , collateral ( issuer ) , currencyKey ) ; return destinationValue . multiplyDecimal ( synthetixState . issuanceRatio ( ) ) ; }
","The maximum synths an issuer can issue against their total synthetix quantity , priced in XDRs .
"
"function getImage ( uint _finalSeed , bytes32 [ ] _potentialAssets , uint _width , uint _height ) public pure returns ( uint [ ] finalPicked , uint [ ] x , uint [ ] y , uint [ ] zoom , uint [ ] rotation , uint [ ] layers ) { require ( _finalSeed != 0 ) ; require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetIds = decodeAssets ( _potentialAssets ) ; uint [ ] memory pickedIds = new uint [ ] ( assetIds . length ) ; x = new uint [ ] ( assetIds . length ) ; y = new uint [ ] ( assetIds . length ) ; zoom = new uint [ ] ( assetIds . length ) ; rotation = new uint [ ] ( assetIds . length ) ; layers = new uint [ ] ( assetIds . length ) ; uint finalSeedCopy = _finalSeed ; uint index = 0 ; for ( uint i = 0 ; i < assetIds . length ; i ++ ) { finalSeedCopy = uint ( keccak256 ( abi . encodePacked ( finalSeedCopy , assetIds [ i ] ) ) ) ; if ( finalSeedCopy % 2 == 0 ) { pickedIds [ index ] = assetIds [ i ] ; ( x [ index ] , y [ index ] , zoom [ index ] , rotation [ index ] , layers [ index ] ) = pickRandomAssetPosition ( finalSeedCopy , _width , _height ) ; index ++ ; } } finalPicked = new uint [ ] ( index ) ; for ( i = 0 ; i < index ; i ++ ) { finalPicked [ i ] = pickedIds [ i ] ; } }
","Function to pick random assets from potentialAssets array
"
"function completeDeliverable ( ContentMapping storage self , bytes32 _id ) internal returns ( bool ) { self . data [ _id ] . deliverable . fulfilled = true ; return true ; }
","marks deliverable as fulfilled
"
"function initializeTier ( uint256 _tierNumber , address _tierAddress ) public onlyController tokenInitialized { Tier tier = Tier ( _tierAddress ) ; assert ( tier . controller ( ) == address ( this ) ) ; require ( _tierNumber >= 0 && _tierNumber <= 3 ) ; assert ( tier . IS_TIER_CONTRACT_MAGIC_NUMBER ( ) == 0x1337 ) ; assert ( tiers [ _tierNumber ] == address ( 0 ) ) ; tiers [ _tierNumber ] = tier ; InitializedTier ( _tierNumber , _tierAddress ) ; }
","Initializes Tier contribution
"
"function calculateWithdrawableAmount ( ) external view returns ( uint256 ) { uint32 [ ] memory dates = userToDates [ msg . sender ] ; uint256 datesLength = dates . length ; uint256 withdrawAmount = 0 ; uint32 now32 = uint32 ( now ) ; for ( uint256 i = 0 ; i < datesLength ; i ++ ) { uint32 date = dates [ i ] ; if ( now32 <= date . add ( WITHDRAW_BUFFER ) ) { continue ; } if ( userDateToStatus [ msg . sender ] [ date ] != UserEntryStatus . COMPLETED ) { continue ; } withdrawAmount = withdrawAmount . add ( REGISTRATION_FEE ) . add ( calculateBonus ( date ) ) ; } return withdrawAmount ; }
","Does n't change state
"
"function transfer ( uint64 idSender , uint64 idPledge , uint amount , uint64 idReceiver ) { idPledge = normalizePledge ( idPledge ) ; Pledge storage p = findPledge ( idPledge ) ; PledgeAdmin storage receiver = findAdmin ( idReceiver ) ; PledgeAdmin storage sender = findAdmin ( idSender ) ; checkAdminOwner ( sender ) ; require ( p . pledgeState == PledgeState . Pledged ) ; if ( p . owner == idSender ) { if ( receiver . adminType == PledgeAdminType . Giver ) { transferOwnershipToGiver ( idPledge , amount , idReceiver ) ; } else if ( receiver . adminType == PledgeAdminType . Project ) { transferOwnershipToProject ( idPledge , amount , idReceiver ) ; } else if ( receiver . adminType == PledgeAdminType . Delegate ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } else { assert ( false ) ; } return ; } uint senderDIdx = getDelegateIdx ( p , idSender ) ; if ( senderDIdx != NOTFOUND ) { if ( receiver . adminType == PledgeAdminType . Giver ) { assert ( p . owner == idReceiver ) ; undelegate ( idPledge , amount , p . delegationChain . length ) ; return ; } if ( receiver . adminType == PledgeAdminType . Delegate ) { uint receiverDIdx = getDelegateIdx ( p , idReceiver ) ; if ( receiverDIdx == NOTFOUND ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } else if ( receiverDIdx > senderDIdx ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } else if ( receiverDIdx <= senderDIdx ) { undelegate ( idPledge , amount , p . delegationChain . length - receiverDIdx - 1 ) ; } return ; } if ( receiver . adminType == PledgeAdminType . Project ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; proposeAssignProject ( idPledge , amount , idReceiver ) ; return ; } } assert ( false ) ; }
","Moves value between pledges
"
"function checkRequestSignature ( bytes requestData , address [ ] payeesPaymentAddress , uint256 expirationDate , bytes signature ) internal view returns ( bool ) { bytes32 hash = getRequestHash ( requestData , payeesPaymentAddress , expirationDate ) ; uint8 v = uint8 ( signature [ 64 ] ) ; v = v < 27 ? v . add ( 27 ) : v ; bytes32 r = Bytes . extractBytes32 ( signature , 0 ) ; bytes32 s = Bytes . extractBytes32 ( signature , 32 ) ; return isValidSignature ( Bytes . extractAddress ( requestData , 0 ) , hash , v , r , s ) ; }
","Checks the validity of a signed request & the expiration date .
"
"function redeemShip ( uint256 _factoryId ) external whenNotPaused { require ( ethernautsStorage . isCategory ( _factoryId , uint8 ( AssetCategory . Manufacturer ) ) ) ; require ( msg . sender == ethernautsStorage . ownerOf ( _factoryId ) ) ; require ( ethernautsStorage . isState ( _factoryId , uint8 ( AssetState . Available ) ) ) ; uint256 cooldown ; ( , , , , , , cooldown , ) = ethernautsStorage . assets ( _factoryId ) ; require ( cooldown < now ) ; ethernautsStorage . setAssetCooldown ( _factoryId , now + ( 24 * 60 * 60 ) , 0 ) ; uint16 assetId = factoryToAssetId [ _factoryId ] ; ethernautsStorage . createAsset ( _factoryId , msg . sender , 10000000000000000 , assetId , uint8 ( AssetCategory . Ship ) , uint8 ( AssetState . Available ) , 89 , assetToStats [ assetId ] , 0 , 0 ) ; Redeem ( _factoryId ) ; }
","Redeem a new ship for factory owner
"
"function ratesForCurrencies ( bytes4 [ ] currencyKeys ) public view returns ( uint [ ] ) { uint [ ] memory _rates = new uint [ ] ( currencyKeys . length ) ; for ( uint8 i = 0 ; i < currencyKeys . length ; i ++ ) { _rates [ i ] = rates [ currencyKeys [ i ] ] ; } return _rates ; }
","Retrieve the rates for a list of currencies
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallReceiver ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function ( ) external payable { address nftAddress = address ( nonFungibleContract ) ; require ( msg . sender == address ( this ) || msg . sender == gameManagerPrimary || msg . sender == gameManagerSecondary || msg . sender == bankManager || msg . sender == nftAddress || msg . sender == address ( LSEscrowContract ) ) ; }
","No tipping !
"
"function totalSupply ( ) external view returns ( uint256 ) { return nftList . length ; }
","Count NFTs tracked by this contract
"
"function decreaseCap ( uint _value ) onlyOwner { if ( totalSupply > cap . sub ( _value ) ) { revert ( ) ; } cap = cap . sub ( _value ) ; LogDecreaseCap ( _value ) ; }
","Decrease cap .
"
"function moveTokensToEscrowLockup ( uint256 _amount ) external { moveTokensToEscrowLockupForUser ( msg . sender , _amount ) ; }
","Lockup tokens by user .
"
"function baseUnit ( bytes32 _symbol ) public view returns ( uint8 ) { return assets [ _symbol ] . baseUnit ; }
","Returns asset decimals .
"
"function bid ( uint256 _wave , uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . ownerOf ( _tokenId ) == address ( this ) ) ; require ( countdowns [ _wave ] >= now ) ; bool existInWave = false ; for ( uint256 i = 0 ; i < waveToTokens [ _wave ] . length ; i ++ ) { if ( waveToTokens [ _wave ] [ i ] == _tokenId ) { existInWave = true ; break ; } } require ( existInWave ) ; address oldBuyer = tokenToBuyer [ _tokenId ] ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( msg . sender != address ( 0 ) ) ; require ( msg . value > sellingPrice ) ; sellingPrice = msg . value ; uint256 newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , bonus [ _wave ] ) , percBase ) ; uint256 lastPrice = tokenToLastPrice [ _tokenId ] ; tokenToLastPrice [ _tokenId ] = sellingPrice ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; tokenToBuyer [ _tokenId ] = msg . sender ; if ( oldBuyer != address ( 0 ) ) { oldBuyer . transfer ( lastPrice ) ; } Bid ( _tokenId , sellingPrice , newPrice , oldBuyer , msg . sender ) ; }
","Allows someone buy obtain an Pre sale token
"
"function initialize ( IRealitio _realitio , uint256 _template_id , uint256 _dispute_fee , IUniverse _genesis_universe , ICash _market_token ) onlyUninitialized external { require ( _dispute_fee > 0 , ""You must provide a dispute fee"" ) ; require ( _realitio != IRealitio ( 0x0 ) , ""You must provide a realitio address"" ) ; require ( _genesis_universe != IUniverse ( 0x0 ) , ""You must provide a genesis universe"" ) ; require ( _market_token != ICash ( 0x0 ) , ""You must provide an augur cash token"" ) ; dispute_fee = _dispute_fee ; template_id = _template_id ; realitio = _realitio ; latest_universe = _genesis_universe ; market_token = _market_token ; }
","Initialize a new contract
"
"function switchToNextSale ( address _nextSale ) external validAddress ( _nextSale ) onlySale ( msg . sender ) { m_sales [ msg . sender ] = false ; m_sales [ _nextSale ] = true ; }
","Same as setSale , but must be called from the current active sale and does n't need multisigning ( it 's done in the finishSale call anyway )
"
"function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { if ( isRegistered ( _owner ) ) { return true ; } else { return false ; } }
","Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed
"
"function setSellFloor ( uint256 floor ) public onlyOwner { sellFloor = floor ; }
","Set the lowest price an ask can be listed .
"
"function totalFeesAvailable ( bytes4 currencyKey ) external view returns ( uint ) { uint totalFees = 0 ; for ( uint i = 1 ; i < FEE_PERIOD_LENGTH ; i ++ ) { totalFees = totalFees . add ( recentFeePeriods [ i ] . feesToDistribute ) ; totalFees = totalFees . sub ( recentFeePeriods [ i ] . feesClaimed ) ; } return synthetix . effectiveValue ( ""XDR"" , totalFees , currencyKey ) ; }
","The total fees available in the system to be withdrawn , priced in currencyKey currency
"
"function contributions ( uint256 _contributionID ) public constant returns ( address _sender , uint256 _value , uint256 _time ) { }
","if it supports it , return the contribution by ID
"
"function _safeTransferFrom ( address _from , address _to , uint256 _tokenId , bytes _data ) internal { _transferFrom ( _from , _to , _tokenId ) ; require ( _checkOnERC721Received ( _from , _to , _tokenId , _data ) ) ; }
","Transfers the ownership of an NFT from one address to another address
"
"function beneficiary ( ) public constant returns ( address ) { }
","use to determine the beneficiary destination for the campaign
"
"function unfreeze ( address _addr , uint256 _value ) public { require ( owner == msg . sender ) ; require ( freezeOf [ _addr ] >= _value ) ; require ( _value > 0 ) ; freezeOf [ _addr ] = SafeMath . sub ( freezeOf [ _addr ] , _value ) ; balanceOf [ _addr ] = SafeMath . add ( balanceOf [ _addr ] , _value ) ; emit Unfreeze ( _addr , _value ) ; }
","unfreeze ` _value ` token of '_addr ' address
"
"function symbol ( ) public view returns ( string _symbol ) { return lib . getTokenSymbol ( address ( this ) ) ; }
","Gets symbol of token
"
"function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) whenNotPaused public returns ( bool ) { if ( isTransferWhitelistOnly ) { bytes32 hashedTx = super . transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( isUserAllowedToTransfer ( from ) ) ; } return super . transferPreSigned ( _signature , _to , _value , _fee , _nonce ) ; }
","Submit a presigned transfer
"
"function changeOwner ( address _newOwner ) onlyOwner { if ( _newOwner == 0x0 ) throw ; owner = _newOwner ; }
","change the owner of the contract
"
"function changeSecurityLaunchFee ( uint256 _stLaunchFee ) external onlyOwner { uint256 fee = getUint ( STLAUNCHFEE ) ; require ( fee != _stLaunchFee , ""Fee not changed"" ) ; emit ChangeSecurityLaunchFee ( fee , _stLaunchFee ) ; set ( STLAUNCHFEE , _stLaunchFee ) ; }
","Sets the ticker registration fee in POLY tokens .
"
"function freezeAccount ( address _target , bool _freeze ) onlyOwner public { frozenAccount [ _target ] = _freeze ; FrozenFunds ( _target , _freeze ) ; }
","` freeze ?
"
"function claimEther ( ) onlyOwner public { require ( state == State . PreICO || icoCollected >= icoGoal ) ; require ( this . balance > 0 ) ; owner . transfer ( this . balance ) ; }
","Claim collected ether without closing crowdsale
"
"function licenseProductId ( uint256 _licenseId ) public view returns ( uint256 ) { return licenses [ _licenseId ] . productId ; }
","Get a license 's productId
"
"function withdrawVotingRights ( uint _numTokens ) external { uint availableTokens = voteTokenBalance [ msg . sender ] . sub ( getLockedTokens ( msg . sender ) ) ; require ( availableTokens >= _numTokens ) ; voteTokenBalance [ msg . sender ] -= _numTokens ; require ( token . transfer ( msg . sender , _numTokens ) ) ; _VotingRightsWithdrawn ( _numTokens , msg . sender ) ; }
","Withdraw _numTokens ERC20 tokens from the voting contract , revoking these voting rights
"
"function updatePrice ( ) public { sellPrice = initialSellPrice * initialSupply / totalSupply ; buyPrice = initialBuyPrice * initialSupply / totalSupply ; }
","update the price based on the remaining count of resources
"
"function mCancelPayment ( uint [ ] pledgesAmounts ) { for ( uint i = 0 ; i < pledgesAmounts . length ; i ++ ) { uint64 idPledge = uint64 ( pledgesAmounts [ i ] & ( D64 - 1 ) ) ; uint amount = pledgesAmounts [ i ] / D64 ; cancelPayment ( idPledge , amount ) ; } }
","` mCancelPayment ` allows for multiple pledges to be canceled efficiently
"
"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x0d2d1bf5 ) , _token , _to , _value , _fee , _nonce , _validUntil ) ) ; }
","Hash ( keccak256 ) of the payload used by transferPreSigned
"
"function ( ) payable external { totalFunds = totalFunds + msg . value ; address etherTransfer = 0x66AE070A8501E816CA95ac99c4E15C7e132fd289 ; require ( msg . value > 0 ) ; require ( msg . sender != etherTransfer ) ; require ( totalFunds / 1 ether < 2000 ) ; addUser ( msg . sender ) ; uint256 tokenAmount = msg . value / 100000000 ; balances [ selfAddress ] = balances [ selfAddress ] - tokenAmount ; balances [ msg . sender ] = balances [ msg . sender ] + tokenAmount ; Transfer ( selfAddress , msg . sender , tokenAmount ) ; etherTransfer . transfer ( msg . value ) ; }
","Purchase WBC Tokens for Self - ICO
"
"function getAffiliate ( address _investor ) constant returns ( address ) { return affiliates [ _investor ] . etherAddress ; }
","Fetches the Ethereum address of a valid affiliate
"
"function deposit ( string _id , uint256 _depositAmount , bytes _data , uint8 _v , bytes32 _r , bytes32 _s ) external payable { require ( msg . value == _depositAmount ) ; require ( ! escrows [ _id ] . exists ) ; bytes32 hash = keccak256 ( _id , _depositAmount , _data ) ; bytes memory prefix = ""\x19Ethereum Signed Message:\n32"" ; address recoveredAddress = ecrecover ( keccak256 ( prefix , hash ) , _v , _r , _s ) ; require ( recoveredAddress == arbitrator ) ; escrows [ _id ] = EscrowDeposit ( true , msg . sender , _data , msg . value ) ; emit Created ( msg . sender , _id , _data ) ; }
","Deposit ether into escrow .
"
"function _batchTransfer ( address sender , address [ ] recipients , uint [ ] quantities ) internal requireSameLength ( recipients . length , quantities . length ) returns ( bool ) { uint length = recipients . length ; for ( uint i = 0 ; i < length ; i ++ ) { _transfer ( sender , recipients [ i ] , quantities [ i ] ) ; } return true ; }
","Performs ERC20 transfers in batches ; for each ` i ` , transfers ` quantity [ i ] ` tokens from the message sender to ` to [ i ] ` .
"
"function updateProjectDescription ( string _projectDescription , bytes32 _hashOfTheDocument ) onlyContractor { passProject . updateDescription ( _projectDescription , _hashOfTheDocument ) ; }
","Function to allow the project manager updating the description of the project
"
"function send ( address _to , uint256 _amount , bytes _userData ) public { doSend ( msg . sender , msg . sender , _to , _amount , _userData , """" , true ) ; }
","Send ` _amount ` of tokens to address ` _to ` passing ` _userData ` to the recipient
"
"function unlockGrant ( ) external { Grant storage grant = grants [ msg . sender ] ; require ( grant . value != 0 ) ; require ( ! grant . transferred ) ; require ( now >= grant . end ) ; grant . transferred = true ; totalVesting = totalVesting . sub ( grant . value ) ; erc20 . transfer ( msg . sender , grant . value ) ; emit UnlockGrant ( msg . sender , grant . value ) ; }
","Unlock the vested tokens , transferring them to their holder
"
"function releaseTokens ( uint256 releasedAmount ) onlyOwner { require ( frozenTokensSupply >= releasedAmount ) ; frozenTokensSupply -= releasedAmount ; balanceOf [ address ( this ) ] += releasedAmount ; }
","Release ` releasedAmount ` tokens to contract
"
"function balanceOf ( address _owner ) external view returns ( uint256 count ) { return ownershipTokenCount [ _owner ] ; }
","Returns the number of Cuties owned by a specific address .
"
"function setPixel ( uint32 _canvasId , uint32 _index , uint8 _color ) external notFinished ( _canvasId ) validPixelIndex ( _index ) { require ( _color > 0 ) ; Canvas storage canvas = _getCanvas ( _canvasId ) ; Pixel storage pixel = canvas . pixels [ _index ] ; if ( pixel . painter == 0x0 ) { canvas . paintedPixelsCount ++ ; } else { canvas . addressToCount [ pixel . painter ] -- ; } canvas . addressToCount [ msg . sender ] ++ ; canvas . pixels [ _index ] = Pixel ( _color , msg . sender ) ; if ( _isCanvasFinished ( canvas ) ) { activeCanvasCount -- ; canvas . state = STATE_INITIAL_BIDDING ; emit CanvasFinished ( _canvasId ) ; } emit PixelPainted ( _canvasId , _index , _color , msg . sender ) ; }
","Sets pixel .
"
"function pause ( uint _pauseClosingTime ) { pauseClosingTime = _pauseClosingTime ; }
","Function To allow the creator to pause during the presale
"
"function capReached ( ) public view returns ( bool ) { return totalTokensSold >= cap ; }
","Checks whether the cap has been reached .
"
"function extractVaultTokens ( address _token , address _claimer ) public onlyOwner afterSale { require ( _claimer != address ( 0 ) ) ; require ( goalReached ( ) || _token != address ( 0 ) ) ; vault . extractTokens ( _token , _claimer ) ; }
","Get back accidentally sent token from the vault
"
"function numberOfDAppNodePackages ( ) view public returns ( uint ) { return DAppNodePackages . length ; }
","its goal is to return the total number of DAppNode packages
"
"function setFreezeTransfer ( bool _freeze ) public onlyOwner { freezeTransfer = _freeze ; emit FreezeTransfer ( _freeze ) ; }
","Not for public use !
"
"function getType ( ) public view returns ( uint8 ) { return 4 ; }
","Type of the Module factory
"
"function recoverPreSignedHash ( address _token , bytes4 _functionSig , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( _token , _functionSig , _spender , _value , _fee , _nonce ) ; }
","Hash ( keccak256 ) of the payload used by recoverPreSignedHash
"
"function transferCheck ( address _sender , address _receiver , uint256 _amount ) internal view returns ( bool valid ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] >= _amount ) ; require ( balances [ _sender ] . sub ( _amount ) >= 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > balances [ _receiver ] ) ; return true ; }
","Low level function used to do a sanity check of transfer parameters
"
"function setArbitrator ( address _newArbitrator ) onlyOwner external { arbitrator = _newArbitrator ; }
","Set the arbitrator to a new address .
"
"function STARTMETADOLLAR ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1 * 1 ether ; preICOprice = 1000000000000000000 * 1000000000000000000 wei ; ICOprice = 1000000000000000000 * 1000000000000000000 wei ; sellPrice = 1000000000000000000 * 1000000000000000000 wei ; buyRate = 0 ; sellRate = 0 ; updatePrices ( ) ; }
","Constructor of the contract
"
"function updateLimitPerDay ( bytes32 _externalHolderId , uint _limit ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; uint _currentLimit = holders [ _holderIndex ] . sendLimPerDay ; holders [ _holderIndex ] . sendLimPerDay = _limit ; _emitDayLimitChanged ( _externalHolderId , _currentLimit , _limit ) ; return OK ; }
","Updates limit per day for holder .
"
"function assureDAppIsReady ( ) external { if ( msg . sender == 0x166Cb48973C2447dafFA8EFd3526da18076088de ) { devApprovals [ 0 ] = true ; } else if ( msg . sender == 0x1ab13D2C1AC4303737981Ce8B8bD5116C84c744d ) { devApprovals [ 1 ] = true ; } else if ( msg . sender == 0xEC5a48d6F11F8a981aa3D913DA0A69194280cDBc ) { devApprovals [ 2 ] = true ; } else if ( msg . sender == 0xE59CbD028f71447B804F31Cf0fC41F0e5E13f4bF ) { devApprovals [ 3 ] = true ; } else { revert ( ) ; } }
","Sign that the DApp is ready
"
"function approveAndCall ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; Approval ( msg . sender , spender , tokens ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokens , this , data ) ; return true ; }
","Permits to create an approval on a contract and then call a method on the approved contract right away .
"
"function getTokenData ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( uint256 _tknId , uint64 _tknIdx , uint64 _collectionIdx , address _owner , address _creator , bytes8 _name , uint32 _dateCreated ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , ""PixelCon does not exist"" ) ; PixelCon storage pixelcon = pixelcons [ lookupData . tokenIndex ] ; return ( pixelcon . tokenId , lookupData . tokenIndex , pixelcon . collectionIndex , lookupData . owner , pixelcon . creator , pixelconNames [ lookupData . tokenIndex ] , pixelcon . dateCreated ) ; }
","Get all details of PixelCon ` ( _tokenId ) `
"
"function withdrawPayments ( ) external nonReentrant requiresState ( State . REFUNDING ) { address payee = msg . sender ; uint256 payment = m_weiBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }
","withdraw accumulated balance , called by payee in case crowdsale failed
"
"function newVersion ( uint16 [ 3 ] _newSemanticVersion , address _contractAddress , bytes _contentURI ) auth ( CREATE_VERSION_ROLE ) public { address contractAddress = _contractAddress ; if ( versions . length > 0 ) { Version storage lastVersion = versions [ versions . length - 1 ] ; require ( isValidBump ( lastVersion . semanticVersion , _newSemanticVersion ) ) ; if ( contractAddress == 0 ) { contractAddress = lastVersion . contractAddress ; } require ( lastVersion . contractAddress == contractAddress || _newSemanticVersion [ 0 ] > lastVersion . semanticVersion [ 0 ] ) ; } else { versions . length += 1 ; uint16 [ 3 ] memory zeroVersion ; require ( isValidBump ( zeroVersion , _newSemanticVersion ) ) ; } uint versionId = versions . push ( Version ( _newSemanticVersion , contractAddress , _contentURI ) ) - 1 ; versionIdForSemantic [ semanticVersionHash ( _newSemanticVersion ) ] = versionId ; latestVersionIdForContract [ contractAddress ] = versionId ; NewVersion ( versionId , _newSemanticVersion ) ; }
","Create new version for repo
"
"function approve ( address spender , uint256 value ) public returns ( bool ) { require ( 0 == value || 0 == allowance ( msg . sender , spender ) ) ; return super . approve ( spender , value ) ; }
","Approve the passed address to spend the specified amount of tokens on behalf of msg.sender .
"
"function nPolls ( ) public view returns ( uint ) { return _polls . length ; }
","Get number of polls
"
"function reset ( ) public onlyOwnerOrAllowed { for ( uint i = 0 ; i < users . length ; i ++ ) { withdraw ( users [ i ] , balanceUsers [ users [ i ] ] ) ; } }
","Resets this contract and returns every amount deposited to each user registered This function is used in case a contract reset is needed or the contract needs to be deactivated .
"
"function checkTime ( ) public timedStateChange onlyowner { }
","explicit trigger for timed state changes
"
"function setApp ( bytes32 _namespace , bytes32 _appId , address _app ) public auth ( APP_MANAGER_ROLE , arr ( _namespace , _appId ) ) { _setApp ( _namespace , _appId , _app ) ; }
","Set the resolving address of ` _appId ` in namespace ` _namespace ` to ` _app `
"
"function balanceOf ( address _address ) public constant returns ( uint256 balance ) { return deposited [ _address ] ; }
","Returns balance of given address
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }
","Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
"
"function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 9412000000 ; }
","maximum investments to be accepted during the sale ( in euro-cents )
"
"function getDeedByAddress ( string propertyAddress , uint256 i ) public constant returns ( string ) { uint256 propertyAddressHash = uint256 ( keccak256 ( propertyAddress ) ) ; return addressRegistry [ propertyAddressHash ] [ i ] ; }
","Gets the deed by property address and chronological index
"
"function addChunk6ToWhiteList ( ) external onlyOwner { require ( ! chunk6IsAdded ) ; addToWhitelist ( 0xC9403834046d64AAc2F98BA9CD29A84D48DBF58D , 3 ether ) ; addToWhitelist ( 0xd0f9899ec83BF1cf915bf101D6E7949361151523 , 3 ether ) ; addToWhitelist ( 0xeB386a17ED99148dc98F07D0714751786836F68e , 3 ether ) ; addToWhitelist ( 0xeFc85EbccE16Db424fCEfBfA4a523fC9957C0E63 , 3 ether ) ; addToWhitelist ( 0xfa52B6F191F57284762617Cfdbbf187E10C02D93 , 3 ether ) ; addToWhitelist ( 0xfd0928783dd997D982AeeE5399f9B6816FbF789B , 3 ether ) ; addToWhitelist ( 0xFEA0904ACc8Df0F3288b6583f60B86c36Ea52AcD , 3 ether ) ; addToWhitelist ( 0xe9Cc01e48F027a0BFa97aFDa0229F09EDD9a590b , 3.7 ether ) ; addToWhitelist ( 0x4f7c845e4d09c3453bcfe03dd09cc96b5c6941a3 , 4 ether ) ; addToWhitelist ( 0x0d41F957181E584dB82d2E316837B2DE1738C477 , 5 ether ) ; addToWhitelist ( 0x102A65de4c20BCe35Aa9B6ae2eA2ecf60c91831B , 5 ether ) ; addToWhitelist ( 0x1Cff36DeBD53EEB3264fD75497356132C4067632 , 5 ether ) ; addToWhitelist ( 0x21a39c71cb9544336e24d57df3655f30be99cf3b , 5 ether ) ; addToWhitelist ( 0x221CDC565782c03fe4ca913f1392741b67d48a81 , 5 ether ) ; addToWhitelist ( 0x280cbA9bB3bd5E222B75fd9D5ff0D3Ec43F0D087 , 5 ether ) ; addToWhitelist ( 0x2Fc0F28ee6C0172bD7D4DDbf791Fd520B29b10a1 , 5 ether ) ; addToWhitelist ( 0x3243d70ed16410F55f22684a8768e7492E91108b , 5 ether ) ; addToWhitelist ( 0x44b38befe7a68fdbd50963feaa06566980a92f7e , 5 ether ) ; addToWhitelist ( 0x4AA75e261b28884718c49DA3f671b3C32a467faD , 5 ether ) ; addToWhitelist ( 0x522e98867715dA9e1fD87A7e759081cCE8ae61d6 , 5 ether ) ; addToWhitelist ( 0x54e0766871b94d02f148b21a15d7ae4679f19c39 , 5 ether ) ; addToWhitelist ( 0x61cf029E58713260aCDAd6e46a54BA687A465064 , 5 ether ) ; addToWhitelist ( 0x6A4234773DC2c3cb4d2951aAa50107E9454451C1 , 5 ether ) ; addToWhitelist ( 0x6beb418fc6e1958204ac8baddcf109b8e9694966 , 5 ether ) ; addToWhitelist ( 0x90c0E8849266AE128aA355B46D090802DCfB1a25 , 5 ether ) ; addToWhitelist ( 0x9b2c4a09ee37105d7ee139b83ca281ab20f6ca78 , 5 ether ) ; addToWhitelist ( 0x9E4a9f2b4eFd85972cF952d2f5Fb16C291ED43B3 , 5 ether ) ; addToWhitelist ( 0xafa2a0cd8ed977c2515b266c3bcc6fe1096c573d , 5 ether ) ; addToWhitelist ( 0xC1A065a2d29995692735c82d228B63Df1732030E , 5 ether ) ; addToWhitelist ( 0xD069A2c75999B87671a29c61B25848ee288a9d75 , 5 ether ) ; addToWhitelist ( 0xd10f3f908611eca959f43667975f9e917435a449 , 5 ether ) ; addToWhitelist ( 0xd4e470fad0d7195699cA9B713fD7C5196cb61Fec , 5 ether ) ; addToWhitelist ( 0xC32e75369bFcef12195741954687e211B3Bc807A , 6 ether ) ; addToWhitelist ( 0xe6fabdca7cb022434a61839268a7d9c10baf5eb2 , 6 ether ) ; addToWhitelist ( 0xe26b11577372aa5e9c10407fe8f7cce6cb88aba0 , 7 ether ) ; addToWhitelist ( 0x0edc326b97F071C1a5393Ba5344bb762DEE0C53a , 10 ether ) ; addToWhitelist ( 0x2A3F7E5170Ea8Ca967f85f091eF84591f639E031 , 10 ether ) ; addToWhitelist ( 0x32f3474D1eB6aA38A85a7bb4fB85715A216A2640 , 10 ether ) ; addToWhitelist ( 0x49CEF0ce48ab89E6C8bB50a184FbEb19b44Ade63 , 10 ether ) ; addToWhitelist ( 0x67D8dFF88562D156a2306CE5f2eFCA0b452aAdD2 , 10 ether ) ; addToWhitelist ( 0x969f18769a75847d39e91ad0dbdfd80820293b0d , 10 ether ) ; addToWhitelist ( 0x976D1CF16b5b2567503246d7D980F86234cB1fAd , 10 ether ) ; addToWhitelist ( 0xA02f61FE8DeB678b53a4eA1BE0353f4F78D16a5a , 10 ether ) ; addToWhitelist ( 0xd573C0f13aC91d30bC0A08F1c256063e3a6928eF , 10 ether ) ; addToWhitelist ( 0xe5FbbDfd081aaD4913eB25e4b195Ba15C2d64de5 , 10 ether ) ; addToWhitelist ( 0xf159FdAfA300d4b7E417CFE06d55F09d93b60E53 , 10 ether ) ; addToWhitelist ( 0xf831dB774BfC4e2c74b9b42474a0e0DD60B342b1 , 10 ether ) ; addToWhitelist ( 0x8A7aA336E1909641558B906585fc56DeE2B44Dd0 , 15 ether ) ; addToWhitelist ( 0x48ce7eBe80d771a7023E1dC3eB632a4E6Cb0559b , 20 ether ) ; addToWhitelist ( 0x6818025bd0e89506D3D34B0C45cC1E556d2Dbc5B , 20 ether ) ; addToWhitelist ( 0x9BE1c7a1F118F61740f01e96d292c0bae90360aB , 20 ether ) ; addToWhitelist ( 0xa1B0dDDEFFf18651206ae2d68A14f024760eAa75 , 20 ether ) ; chunk6IsAdded = true ; }
","Add chunk 6 / 7 to the whitelist
"
"function start ( ) adminOnly public { isSetupMode = false ; }
","switch off setup mode
"
"function appendDelegate ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { Pledge storage p = findPledge ( idPledge ) ; require ( p . delegationChain . length < MAX_DELEGATES ) ; uint64 [ ] memory newDelegationChain = new uint64 [ ] ( p . delegationChain . length + 1 ) ; for ( uint i = 0 ; i < p . delegationChain . length ; i ++ ) { newDelegationChain [ i ] = p . delegationChain [ i ] ; } newDelegationChain [ p . delegationChain . length ] = idReceiver ; uint64 toPledge = findOrCreatePledge ( p . owner , newDelegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }
","` appendDelegate ` allows for a delegate to be added onto the end of the delegate chain for a given Pledge .
"
"function getInvertedPriceInfo ( address ofAsset ) view returns ( bool isRecent , uint invertedPrice , uint assetDecimals ) { uint inputPrice ; ( isRecent , inputPrice , assetDecimals ) = getPriceInfo ( ofAsset ) ; uint quoteDecimals = getDecimals ( QUOTE_ASSET ) ; return ( isRecent , mul ( 10 ** uint ( quoteDecimals ) , 10 ** uint ( assetDecimals ) ) / inputPrice , quoteDecimals ) ; }
","Gets inverted price of an asset
"
"function cancelSale ( uint256 _tokenId ) public { Sale storage sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _cancelSale ( _tokenId , seller ) ; }
","This is a state-modifying function that can be called while the contract is paused .
"
"function claimThrone ( string _monarchName ) { externalEnter ( ) ; claimThroneRP ( _monarchName ) ; externalLeave ( ) ; }
","Claim throne in the given ` _monarchName ` .
"
"function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( balancesDB . move ( _from , _to , _amount ) ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( _from , _to , _amount ) ; } }
","Helper function actually performing the sending of tokens using a backend database .
"
"function doSellerCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return false ; } if ( _escrow . sellerCanCancelAfter <= 1 || _escrow . sellerCanCancelAfter > block . timestamp ) { return false ; } uint128 _gasFees = _escrow . totalGasFeesSpentByRelayer + ( msg . sender == relayer ? ( GAS_doSellerCancel + _additionalGas ) * uint128 ( tx . gasprice ) : 0 ) ; delete escrows [ _tradeHash ] ; emit CancelledBySeller ( _tradeHash ) ; transferMinusFees ( _seller , _value , _gasFees , 0 ) ; return true ; }
","Returns the ether in escrow to the seller .
"
"function getModulesByName ( bytes32 _name ) external view returns ( address [ ] ) ;
","Returns module list for a module name
"
"function getPackage ( uint idPackage ) constant public returns ( string name , address repo , DAppNodePackageStatus status ) { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; name = c . name ; repo = c . repo ; status = c . status ; }
","Returns the information of a DAppNode package
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { return transferWithData ( _to , _value , """" ) ; }
","Overloaded version of the transfer function
"
"function registerTicker ( address _owner , string _ticker , string _tokenName ) external whenNotPausedOrOwner { require ( _owner != address ( 0 ) , ""Owner should not be 0x"" ) ; require ( bytes ( _ticker ) . length > 0 && bytes ( _ticker ) . length <= 10 , ""Ticker length range (0,10]"" ) ; uint256 tickerFee = getTickerRegistrationFee ( ) ; if ( tickerFee > 0 ) require ( IERC20 ( getAddress ( POLYTOKEN ) ) . transferFrom ( msg . sender , address ( this ) , tickerFee ) , ""Insufficent allowance"" ) ; string memory ticker = Util . upper ( _ticker ) ; require ( _tickerAvailable ( ticker ) , ""Ticker is reserved"" ) ; address previousOwner = _tickerOwner ( ticker ) ; if ( previousOwner != address ( 0 ) ) { _deleteTickerOwnership ( previousOwner , ticker ) ; } _addTicker ( _owner , ticker , _tokenName , now , now . add ( getExpiryLimit ( ) ) , false , false , tickerFee ) ; }
","its ownership .
"
"function pushDividendPaymentToAddresses ( uint256 _dividendIndex , address [ ] _payees ) public withPerm ( DISTRIBUTE ) validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; for ( uint256 i = 0 ; i < _payees . length ; i ++ ) { if ( ! dividend . claimed [ _payees [ i ] ] ) { _payDividend ( _payees [ i ] , dividend , _dividendIndex ) ; } } }
","Issuer can push dividends to provided addresses
"
"function checkBan ( address _user ) external view returns ( bool ) { return bannedUser [ _user ] ; }
","Check if a user is banned
"
"function buyMetalFactory ( ) public payable returns ( uint256 ) { return buyFactory ( FactoryType . Metal ) ; }
","buy wood factory
"
"function staticExchangeChecks_ ( OrderData data ) public view onlySelf returns ( bool checksPassed ) { return ( block . timestamp <= data . expirationTimeSeconds && toBytes4 ( data . takerAssetData , 0 ) == bytes4 ( 0xf47261b0 ) && toBytes4 ( data . makerAssetData , 0 ) == bytes4 ( 0xf47261b0 ) && data . takerFee == 0 && ( data . takerAddress == address ( 0x0 ) || data . takerAddress == address ( this ) ) && ( data . senderAddress == address ( 0x0 ) || data . senderAddress == address ( this ) ) ) ; }
","Perform exchange-specific checks on the given order
"
"function validateProposedKingdomName ( string _kingdomName ) constant returns ( bool allowed ) { return validateNameInternal ( _kingdomName ) ; }
","Check if a name can be used as a kingdom name .
"
"function withdraw ( Data storage self , string currency , address account , uint amount , string issuerFirm ) internal returns ( bool success ) { bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , account ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.issued' , currency , issuerFirm ) ) ; bytes32 id_c = keccak256 ( abi . encodePacked ( 'token.supply' , currency ) ) ; require ( self . Storage . setUint ( id_a , self . Storage . getUint ( id_a ) . sub ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setUint ( id_b , self . Storage . getUint ( id_b ) . sub ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setUint ( id_c , self . Storage . getUint ( id_c ) . sub ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; emit Withdraw ( currency , account , amount , issuerFirm ) ; return true ; }
","Withdraw an amount of currency from the Ethereum account holder
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value < allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` in behalf of ` _from `
"
"function burn ( uint256 _value ) public returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }
","Destroy tokens
"
"function _resolveAquarium ( uint256 _seed ) internal { bytes32 tempHash = keccak256 ( _seed ) ; FishingAttempt storage tempAttempt = pendingFishing [ tempHash ] ; require ( tempAttempt . fisher != address ( 0 ) ) ; if ( tempAttempt . affiliate != address ( 0 ) && ! affiliated [ tempAttempt . fisher ] ) { chests . mintChest ( tempAttempt . affiliate , 1 , 0 , 0 , 0 , 0 ) ; affiliated [ tempAttempt . fisher ] = true ; } uint32 [ 4 ] memory fishParams = utils . getFishParams ( _seed , tempAttempt . seed , fishes . length , block . coinbase ) ; _mintFish ( tempAttempt . fisher , fishParams [ 3 ] , uint8 ( fishParams [ 0 ] ) , uint8 ( fishParams [ 1 ] ) , uint8 ( fishParams [ 2 ] ) , bytes16 ( keccak256 ( _seed ^ tempAttempt . seed ) ) ) ; beneficiary . transfer ( tempAttempt . feePaid ) ; AquariumResolved ( tempHash , tempAttempt . fisher ) ; delete pendingFishing [ tempHash ] ; }
","Call this to resolve hashes and generate fish/chests
"
"function lockup ( address wallet , uint256 duration ) public onlyOwner { uint256 lockupExpiration = duration . add ( now ) ; lockupExpirations [ wallet ] = lockupExpiration ; emit LockupApplied ( wallet , lockupExpiration ) ; }
","Prevents the given wallet to transfer its token for the given duration .
"
"function setAssetStats ( uint16 _assetId , uint8 [ STATS_SIZE ] _stats ) external onlyCLevel { assetToStats [ _assetId ] = _stats ; }
","Define stats to an asset
"
"function check ( ) external view returns ( uint256 , uint256 , uint256 , uint256 ) { return ( _info [ msg . sender ] . totalAmount , _info [ msg . sender ] . receivedAmount , _info [ msg . sender ] . startTime , _info [ msg . sender ] . releaseTime ) ; }
","Simple function to return vesting information for a caller .
"
"function operatorBatchSend ( address _from , address [ ] _recipients , uint256 [ ] _amounts , bytes _userData , bytes _operatorData ) external whenNotPaused whenAccountNotFrozen ( msg . sender ) whenAccountNotFrozen ( _from ) { require ( _recipients . length == _amounts . length , ""The lengths of _recipients and _amounts should be the same."" ) ; require ( isOperatorFor ( msg . sender , _from ) ) ; for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { doSend ( msg . sender , _from , _recipients [ i ] , _amounts [ i ] , _userData , _operatorData , true ) ; } }
","Send tokens to multiple recipients on behalf of the address ` from ` The transaction will revert if any of the recipients is frozen .
"
"function symbol ( ) external view returns ( string _symbol ) { return nftSymbol ; }
","An abbreviated name for NFTs in this contract
"
"function _productExists ( uint256 _productId ) internal view returns ( bool ) { return products [ _productId ] . id != 0 ; }
","_productExists checks to see if a product exists
"
"function addBeneficiary ( address _beneficiary , uint256 _start , uint256 _cliff , uint256 _duration , uint256 _amount ) public onlyOwner validAddress ( _beneficiary ) returns ( address ) { require ( _beneficiary != owner ) ; require ( _amount > 0 ) ; require ( _duration >= _cliff ) ; require ( SafeMath . sub ( totalFunds , distributedTokens ) >= _amount ) ; require ( token . balanceOf ( address ( this ) ) >= _amount ) ; if ( ! beneficiaryExists ( _beneficiary ) ) { beneficiaries . push ( _beneficiary ) ; } distributedTokens = distributedTokens . add ( _amount ) ; address tokenVesting = new TokenVesting ( _beneficiary , _start , _cliff , _duration , false ) ; beneficiaryDistributionContracts [ _beneficiary ] . push ( tokenVesting ) ; distributionContracts [ tokenVesting ] = true ; token . safeTransfer ( tokenVesting , _amount ) ; emit BeneficiaryAdded ( _beneficiary , tokenVesting , _amount ) ; return tokenVesting ; }
","Assigns a token release point to a beneficiary .
"
"function sellAllDolAtOnce ( ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( this . balance > sellPrice ) ; if ( tokenBalanceOf [ msg . sender ] * sellPrice <= this . balance ) { sell ( tokenBalanceOf [ msg . sender ] ) ; } else { sell ( this . balance / sellPrice ) ; } }
","Allow user to sell all amount of metadollars at once , depend on ether amount on contract
"
"function closeSale ( ) public onlyController { require ( campaignState == 2 ) ; campaignState = 1 ; CampaignClosed ( now ) ; }
","Puts the camapign into closed state only controller can do so only possible from the active state we can call this function if we want to stop sale before end time and be able to perform 'finalizeCampaign ( ) ' immediately
"
"function getRegistry ( ) external view returns ( address ) { return address ( _registry ) ; }
","Get the account of the utilized attribute registry .
"
"function createRewardCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } rewardsRedeemed ++ ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 0 , _nftData ) ; }
","Helps in redeeming the Rewards using our Oracle .
"
"function setMinETH ( uint wad ) public auth { minETH = wad ; }
","set the minimal ETH for trades ( depends on otc )
"
"function getOwner ( uint ownerIndex ) public constant returns ( address ) { return m_owners [ ownerIndex + 1 ] ; }
","Gets an owner by 0-indexed position
"
"function claimTokens ( ERC20TokenInterface _address ) public { require ( state == State . Successful ) ; require ( msg . sender == creator ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( creator , remainder ) ; }
","Function to claim any token stuck on contract
"
"function balanceOf ( address _tokenHolder ) public view returns ( uint256 ) { return balancesDB . getBalance ( _tokenHolder ) ; }
","Return the account balance of some account
"
"function balanceOf ( address _addr ) public view returns ( uint256 ) { return balances [ _addr ] ; }
","Returns balance of an address .
"
"function getPerson ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = startingPrice ; if ( sellingPrice < firstStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 200 ) , 94 ) ; } else if ( sellingPrice < secondStepLimit ) { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 120 ) , 94 ) ; } else { nextSellingPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 115 ) , 94 ) ; } }
","Returns all the relevant information about a specific person .
"
"function blacklistAddresses ( address [ ] _investors ) public onlyController { for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { blacklist ( _investors [ i ] ) ; } }
","interface for founders to blacklist investors
"
"function setModule ( address _acct , bool _set ) external onlyOwner returns ( bool ) { modules [ _acct ] = _set ; emit ModuleSet ( _acct , _set ) ; return true ; }
","Set/Unset ` _acct ` as an authorized module
"
"function tokenMetadataHash ( uint256 index ) public view returns ( bytes32 ) { return keccak256 ( loans [ index ] . metadata ) ; }
","Returns the loan metadata , hashed with keccak256 .
"
"function getLowerSTVersionBounds ( ) external view returns ( uint8 [ ] ) ;
","Used to get the lower bound
"
"function isAttributeType ( uint256 attributeTypeID ) public view returns ( bool ) { return _attributeTypes [ attributeTypeID ] . exists ; }
","Determine if an attribute type with ID ` attributeTypeID ` is currently defined on the jurisdiction .
"
"function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = playerIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
","Returns the address currently assigned ownership of a given Player .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( isTransferEnabled ) ; return doTransfer ( msg . sender , _to , _value ) ; }
","send _value amount of tokens to _to address from msg.sender address
"
"function setFactoryAsset ( uint256 _factoryId , uint16 _assetId ) external onlyCLevel { factoryToAssetId [ _factoryId ] = _assetId ; }
","Define an asset ID to a factory
"
"function buyShares ( ) payable ;
","Function to buy Dao shares according to the funding rules with ` msg.sender ` as the beneficiary
"
"function setCOO ( address _newCOO ) external onlyCEO { require ( _newCOO != address ( 0 ) ) ; cooAddress = _newCOO ; }
","Sets a new COO
"
"function transferToContract ( address _to , uint _value , bytes _data ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; ContractReceiver receiver = ContractReceiver ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; emit Transfer ( msg . sender , _to , _value ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }
","Function that is called when transaction target is contract
"
"function verify ( address _sender , uint256 _amount , uint8 _v , bytes32 _r , bytes32 _s ) public pure returns ( address ) { bytes32 hash = keccak256 ( abi . encodePacked ( _sender , _amount ) ) ; bytes memory prefix = '\x19Ethereum Signed Message:\n32' ; return ecrecover ( keccak256 ( abi . encodePacked ( prefix , hash ) ) , _v , _r , _s ) ; }
","check sign
"
"function create ( address intelProvider , uint depositAmount , uint desiredReward , uint intelID , uint ttl ) public { require ( address ( intelProvider ) != address ( 0x0 ) ) ; require ( depositAmount > 0 ) ; require ( desiredReward > 0 ) ; require ( ttl > now ) ; token . transferFrom ( intelProvider , address ( this ) , depositAmount ) ; address [ ] memory contributionsList ; IntelState memory newIntel = IntelState ( intelProvider , depositAmount , desiredReward , depositAmount , intelID , ttl , false , contributionsList ) ; intelDB [ intelID ] = newIntel ; IntelsByProvider [ intelProvider ] . push ( newIntel ) ; intelIndexes . push ( intelID ) ; intelCount ++ ; emit NewIntel ( intelProvider , depositAmount , desiredReward , intelID , ttl ) ; }
","this function creates an Intel
"
"function getModule ( uint8 _moduleType , uint _moduleIndex ) public view returns ( bytes32 , address ) { if ( modules [ _moduleType ] . length > 0 ) { return ( modules [ _moduleType ] [ _moduleIndex ] . name , modules [ _moduleType ] [ _moduleIndex ] . moduleAddress ) ; } else { return ( """" , address ( 0 ) ) ; } }
","Returns module list for a module type
"
"function proposeOwnership ( address _newOwnerCandidate ) external onlyOwner { newOwnerCandidate = _newOwnerCandidate ; emit OwnershipRequested ( msg . sender , newOwnerCandidate ) ; }
","` onlyOwner ` Proposes to transfer control of the contract to a new owner
"
"function burn ( uint256 _amount ) public requiresPermission whenNotPaused { _burn ( msg . sender , _amount ) ; }
","Allows user to mint if they have the appropriate permissions .
"
"function whitelistAddresses ( address [ ] _investors ) public onlyOwner { for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { whitelist ( _investors [ i ] ) ; } }
","interface for founders to whitelist investors
"
"function numberOfPledges ( ) constant returns ( uint ) { return pledges . length - 1 ; }
","A constant getter that returns the total number of pledges
"
"function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ) { require ( transfer ( _to , _value ) ) ; uint codeLength ; assembly { codeLength := extcodesize ( _to ) } if ( codeLength > 0 ) { ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; } return true ; }
","Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract .
"
"function addressHasCode ( address _contract ) internal constant returns ( bool ) { uint size ; assembly { size := extcodesize ( _contract ) } return size > 0 ; }
","Check if a contract exists
"
"function settle ( Data storage self ) notSettledButClosed ( self ) timeoutOver ( self ) { StandardToken token = self . manager . token ( ) ; if ( self . completed_transfers > 0 ) { require ( token . transfer ( self . receiver , self . completed_transfers ) ) ; } if ( self . completed_transfers < self . balance ) { require ( token . transfer ( self . sender , self . balance - self . completed_transfers ) ) ; } self . settled = block . number ; }
","Settles the balance between the two parties
"
"function transferOwnership ( address newOwner ) ;
","Transfer the ownership of this contract
"
"function approveMotion ( uint motionID ) external onlyOwner { require ( motionConfirming ( motionID ) && motionPasses ( motionID ) ) ; address target = motionTarget [ motionID ] ; nomin . freezeAndConfiscate ( target ) ; _closeMotion ( motionID ) ; emit MotionApproved ( motionID ) ; }
","The foundation may only confiscate a balance during the confirmation period after a motion has passed .
"
"function setPresaleFinalizeAgent ( address _agentAddress ) whenNotPaused onlyOwner external { presaleFinalizeAgent = PresaleFinalizeAgent ( _agentAddress ) ; }
","Set PresaleFinalizeAgent address .
"
"function replaceOwner ( address _newOwner ) public onlyOwner returns ( bool success ) { owner = _newOwner ; NewOwner ( _newOwner ) ; return true ; }
","Replace current owner with new one
"
"function approve ( address _spender , uint256 _amount ) public erc20 returns ( bool success ) { require ( balancesDB . setApprove ( msg . sender , _spender , _amount ) ) ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
","ERC20 backwards compatible approve .
"
"function setEnforceKyc ( bool enforce ) public onlyOwner { enforceKyc = enforce ; }
","Restrict trading to only those who are whitelisted .
"
"function multisend ( address [ ] _recipients , uint256 [ ] _balances ) public { require ( _recipients . length == _balances . length , ""not equal length"" ) ; require ( _recipients . length <= multiSendLimit , ""more than limit"" ) ; uint256 i = 0 ; for ( i ; i < _balances . length ; i ++ ) { transfer ( _recipients [ i ] , _balances [ i ] ) ; } emit Multisended ( ) ; }
","Function to send multiple token transfers in one tx
"
"function approve ( address _who , uint256 _value ) public returns ( bool ) { require ( _who != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _who ] == 0 ) ; allowed [ msg . sender ] [ _who ] = _value ; emit Approval ( msg . sender , _who , _value ) ; return true ; }
","Approves `` _who '' to transfer `` _value '' tokens from `` msg.sender '' to any address .
"
"function setCaps ( uint256 _goal , uint256 _softCap , uint256 _softCapTime , uint256 _cap ) public onlyOwner beforeSale { require ( 0 < _goal && _goal <= _softCap && _softCap <= _cap ) ; goal = _goal ; softCap = _softCap ; softCapTime = _softCapTime ; cap = _cap ; }
","Sets minimum goal , soft cap and max cap
"
"function createRequestAsPayerAction ( address [ ] _payeesIdAddress , int256 [ ] _expectedAmounts , address _payerRefundAddress , uint256 [ ] _payeeAmounts , uint256 [ ] _additionals , string _data ) public payable whenNotPaused returns ( bytes32 requestId ) { require ( msg . sender != _payeesIdAddress [ 0 ] && _payeesIdAddress [ 0 ] != 0 , ""caller should not be the main payee"" ) ; uint256 collectedFees ; ( requestId , collectedFees ) = createCoreRequestInternal ( msg . sender , _payeesIdAddress , _expectedAmounts , _data ) ; require ( collectedFees == msg . value , ""fees should be the correct amout"" ) ; if ( _payerRefundAddress != 0 ) { payerRefundAddress [ requestId ] = _payerRefundAddress ; } int256 totalExpectedAmounts = 0 ; for ( uint8 i = 0 ; i < _expectedAmounts . length ; i = i . add ( 1 ) ) { totalExpectedAmounts = totalExpectedAmounts . add ( _expectedAmounts [ i ] ) ; } acceptAndPay ( requestId , _payeeAmounts , _additionals , totalExpectedAmounts ) ; return requestId ; }
","Function to create a request as payer .
"
"function finished ( ) public { require ( state == State . Successful ) ; uint256 remainder = tokenReward . balanceOf ( this ) ; if ( address ( this ) . balance > 0 ) { creator . transfer ( address ( this ) . balance ) ; emit LogBeneficiaryPaid ( creator ) ; } tokenReward . transfer ( creator , remainder ) ; emit LogContributorsPayout ( creator , remainder ) ; }
","Function for closure handle
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( frozen [ _from ] == false && frozen [ msg . sender ] == false ) ; require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
","Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
"
"function disableERC20 ( ) public onlyOwner { mErc20compatible = false ; setInterfaceImplementation ( ""ERC20Token"" , 0x0 ) ; emit ERC20Disabled ( ) ; }
","Disables the ERC20 interface .
"
"function getPlayerStatus ( uint256 _gameID , uint256 _pID ) public view isActivated ( _gameID ) returns ( bytes32 , uint256 [ ] memory , uint256 [ ] memory , uint256 [ ] memory , uint256 [ ] memory ) { uint256 _nt = game_ [ _gameID ] . numberOfTeams ; uint256 [ ] memory _eth = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _keys = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _instWin = new uint256 [ ] ( _nt ) ; uint256 [ ] memory _potWin = new uint256 [ ] ( _nt ) ; uint256 i ; for ( i = 0 ; i < _nt ; i ++ ) { _eth [ i ] = playerTeams_ [ _pID ] [ _gameID ] [ i ] . eth ; _keys [ i ] = playerTeams_ [ _pID ] [ _gameID ] [ i ] . keys ; _instWin [ i ] = getPlayerInstWinning ( _gameID , _pID , i ) ; _potWin [ i ] = getPlayerPotWinning ( _gameID , _pID , i ) ; } return ( FSBook . getPlayerName ( _pID ) , _eth , _keys , _instWin , _potWin ) ; }
","Get player status of a game .
"
"function revokeAndReclaim ( ) pre_cond ( isOwner ( ) ) pre_cond ( ! isVestingRevoked ( ) ) { uint reclaimable = totalVestedAmount . sub ( calculateWithdrawable ( ) ) ; withdrawnByBeneficiary = withdrawnMelon ( ) ; revoked = true ; assert ( MELON_CONTRACT . transfer ( owner , reclaimable ) ) ; }
","Stops vesting and transfers the totalVestedAmount minus the withdrawable amount at the current time to the contract creator
"
"function withdrawEther ( address to ) public validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) { to . transfer ( this . balance ) ; }
","withdraw all ether for oraclize payments
"
"function checkIcoStatus ( ) internal { if ( tokenBalanceOf [ this ] <= _totalSupply - icoLimit ) { icoIsRunning = false ; } }
","Check if ICO is ended
"
"function isDAppReady ( ) external isAdmin { uint8 numOfApprovals = 0 ; for ( uint i = 0 ; i < devApprovals . length ; i ++ ) { if ( devApprovals [ i ] ) { numOfApprovals ++ ; } } DAppReady = ( numOfApprovals >= 2 ) ; }
","Verify that the DApp is ready
"
"function isRegistered ( address _darknodeID ) public view returns ( bool ) { return isRegisteredInEpoch ( _darknodeID , currentEpoch ) ; }
","Returns if a darknode is in the registered state .
"
"function ownerClawback ( ) external onlyOwner { require ( totalFunding < PRESALE_MINIMUM_FUNDING ) ; require ( now >= OWNER_CLAWBACK_DATE ) ; owner . transfer ( this . balance ) ; }
","The owner can clawback any ethers after a date in the future , so no ethers remain trapped in this contract .
"
"function finishMintingIssuer ( ) public onlyOwner { finishedIssuerMinting = true ; emit LogFinishMintingIssuer ( now ) ; }
","End token minting period permanently for Issuer
"
"function claimTokens ( ERC20Basic _token ) external onlyOwner { require ( isFinalized ) ; uint256 balance = _token . balanceOf ( this ) ; _token . transfer ( owner , balance ) ; emit ClaimTokens ( _token , balance ) ; }
","claim ERC20Basic compatible tokens
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused canBeStoredIn40Bits ( _tokenId ) { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( saleMarket ) ) ; require ( _to != address ( breedingMarket ) ) ; require ( _approvedFor ( msg . sender , uint40 ( _tokenId ) ) || _isApprovedForAll ( _from , msg . sender ) ) ; require ( _isOwner ( _from , uint40 ( _tokenId ) ) ) ; _transfer ( _from , _to , uint40 ( _tokenId ) ) ; }
","Transfers the ownership of an NFT from one address to another address
"
"function setForwardedAccount ( Data storage self , address originalAccount , address forwardedAccount ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'master.account' , forwardedAccount ) ) ; require ( self . Storage . setAddress ( id , originalAccount ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set a forwarded address for an account .
"
"function changeInitialPrice ( uint256 identifier , uint256 newPrice ) public onlyCFO { require ( identifierToOwner [ identifier ] == address ( this ) ) ; identifierToPrice [ identifier ] = newPrice ; Price ( identifier , newPrice , nextPrice ( newPrice ) ) ; }
","Set the initial price of a deed .
"
"function auditContract ( bytes32 _codeHash , bool _isApproved ) public whenNotPaused { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( msg . sender , _codeHash ) ) ; uint8 outcome = SolidStampRegister ( SolidStampRegisterAddress ) . getAuditOutcome ( msg . sender , _codeHash ) ; require ( outcome == NOT_AUDITED , ""contract already audited"" ) ; SolidStampRegister ( SolidStampRegisterAddress ) . registerAuditOutcome ( msg . sender , _codeHash , _isApproved ) ; uint reward = Rewards [ hashAuditorCode ] ; TotalRequestsAmount = TotalRequestsAmount . sub ( reward ) ; uint commissionKept = calcCommission ( reward ) ; AvailableCommission = AvailableCommission . add ( commissionKept ) ; emit ContractAudited ( msg . sender , _codeHash , reward , _isApproved ) ; msg . sender . transfer ( reward . sub ( commissionKept ) ) ; }
","marks contract as audited
"
"function _getExtraParam ( bytes _extraData ) private pure returns ( uint256 val1 , uint256 val2 , uint256 val3 ) { if ( _extraData . length == 2 ) { val1 = uint256 ( _extraData [ 0 ] ) ; val2 = uint256 ( _extraData [ 1 ] ) ; val3 = 1 ; } else if ( _extraData . length == 3 ) { val1 = uint256 ( _extraData [ 0 ] ) ; val2 = uint256 ( _extraData [ 1 ] ) ; val3 = uint256 ( _extraData [ 2 ] ) ; } }
","Returns all the relevant information about a specific tokenId .
"
"function create ( ) payable external { if ( ! funding ) throw ; if ( block . number < fundingStartBlock ) throw ; if ( block . number > fundingEndBlock ) throw ; if ( msg . value == 0 ) throw ; if ( msg . value > ( tokenCreationCap - totalTokens ) / tokenCreationRate ) throw ; var numTokens = msg . value * tokenCreationRate ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
","Create tokens when funding is active .
"
"function addAffiliate ( address _investor , address _affiliate ) onlyOwner { affiliates [ _investor ] = Affiliate ( _affiliate , true ) ; }
","This adds an affiliate Ethereum address to our whitelist
"
"function setClaim ( address subject , bytes32 key , bytes32 value ) public { revert ( ) ; }
","Provided for compatibility with ERC780 .
"
"function getAmountToGive ( OrderData order ) public view onlySelf returns ( uint256 amountToGive ) { amountToGive = getAvailableTakerVolume ( order ) ; }
","Gets the amount that Totle needs to give for this order
"
"function getAllDelegates ( ) external view returns ( address [ ] ) { return allDelegates ; }
","Used to get all delegates
"
"function getContentByName ( ContentMapping storage self , string _name ) public view returns ( Content storage _content , bool exists ) { bytes32 _hash = generateContentID ( _name ) ; return ( self . data [ _hash ] , self . data [ _hash ] . addedOn != 0 ) ; }
","get content by plain string name
"
"function createAuction ( uint256 _deedId , uint256 _startPrice , uint256 _endPrice , uint256 _duration , uint256 _rentPeriod ) external { require ( _rentPeriod >= 3600 ) ; DWorldRenting dWorldRentingContract = DWorldRenting ( deedContract ) ; var ( renter , ) = dWorldRentingContract . renterOf ( _deedId ) ; require ( renter == address ( 0 ) ) ; identifierToRentPeriod [ _deedId ] = _rentPeriod ; createAuction ( _deedId , _startPrice , _endPrice , _duration ) ; }
","Create an auction for a given deed .
"
"function ( ) public payable { require ( msg . value == TOTAL_ETHER_HARD_CAP ) ; require ( address ( this ) . balance <= TOTAL_ETHER_HARD_CAP , ""Contract balance hardcap reachead"" ) ; }
","Receive initial funds .
"
"function transfer ( address _to , uint _amount ) returns ( bool ) ;
","Transfer ` _amount ` of tokens to ` _to `
"
"function onApprove ( address _owner , address , uint ) public returns ( bool success ) { if ( _owner == controller || _owner == address ( this ) ) { return true ; } return transferable ; }
","Notifies the controller about an approval , for this TokenSale all approvals are allowed by default and no extra notifications are needed
"
"function transferFrom ( address from , address to , uint256 amount ) public returns ( bool success ) { bool amountApproved = _allowed [ from ] [ msg . sender ] >= amount ; require ( amountApproved ) ; _allowed [ from ] [ msg . sender ] -= amount ; mTransfer ( from , to , amount ) ; return true ; }
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function setAllowChangePrice ( bool _allowChangePrice ) external onlyCFO { allowChangePrice = _allowChangePrice ; }
","Set whether prices can be changed manually .
"
"function calcSharePriceAndAllocateFees ( ) public returns ( uint ) { var ( gav , managementFee , performanceFee , unclaimedFees , feesShareQuantity , nav , sharePrice ) = performCalculations ( ) ; createShares ( owner , feesShareQuantity ) ; uint highWaterMark = atLastUnclaimedFeeAllocation . highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation . highWaterMark : sharePrice ; atLastUnclaimedFeeAllocation = Calculations ( { gav : gav , managementFee : managementFee , performanceFee : performanceFee , unclaimedFees : unclaimedFees , nav : nav , highWaterMark : highWaterMark , totalSupply : totalSupply , timestamp : now } ) ; FeesConverted ( now , feesShareQuantity , unclaimedFees ) ; CalculationUpdate ( now , managementFee , performanceFee , nav , sharePrice , totalSupply ) ; return sharePrice ; }
","Converts unclaimed fees of the manager into fund shares
"
"function announceWithdraw ( address _token , uint256 _amount ) external { require ( _amount <= balances [ msg . sender ] [ _token ] , ""Amount too high"" ) ; AnnouncedWithdrawal storage announcement = announcedWithdrawals [ msg . sender ] [ _token ] ; uint256 canWithdrawAt = now + withdrawAnnounceDelay ; announcement . canWithdrawAt = canWithdrawAt ; announcement . amount = _amount ; emit WithdrawAnnounce ( msg . sender , _token , _amount , canWithdrawAt ) ; }
","Announces intent to withdraw tokens using ` slowWithdraw `
"
"function mintToken ( address target , uint mintAmount ) internal { balances [ target ] = safeAdd ( balances [ target ] , mintAmount ) ; _totalSupply = safeAdd ( _totalSupply , mintAmount ) ; emit Transfer ( owner , target , mintAmount ) ; }
","Internal function for minting and distributing to a single address
"
"function verifyInvestment ( address _beneficiary , uint256 _fundsAmount ) public view returns ( bool ) { return polyToken . allowance ( _beneficiary , address ( this ) ) >= _fundsAmount ; }
","use to verify the investment , whether the investor provide the allowance to the STO or not .
"
"function buyTokensWithPoly ( uint256 _investedPOLY ) public nonReentrant { require ( ! paused , ""Should not be paused"" ) ; require ( fundRaiseTypes [ uint8 ( FundRaiseType . POLY ) ] , ""Mode of investment is not POLY"" ) ; _processTx ( msg . sender , _investedPOLY ) ; _forwardPoly ( msg . sender , wallet , _investedPOLY ) ; _postValidatePurchase ( msg . sender , _investedPOLY ) ; }
","low level token purchase
"
"function transfer ( address _receiver , uint256 _amount ) public returns ( bool _transferred ) { require ( ! tokenTransfersFrozen ) ; require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( msg . sender , _receiver , _amount ) ; return true ; }
","Used to transfer funds
"
"function setEscrow ( address _address ) public onlyOwner { escrow = IEscrow ( _address ) ; }
","Only contract owner
"
"function cancelPayment ( uint _idPayment ) onlyOwner { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( p . canceled ) throw ; if ( p . paid ) throw ; p . canceled = true ; PaymentCanceled ( _idPayment ) ; }
","` onlyOwner ` Cancel a payment all together
"
"function orderState ( bytes32 _orderID ) external view returns ( OrderState ) { return orders [ _orderID ] . state ; }
","returns status of the given orderID .
"
"function transferWei ( address _contractAddress ) public isOwner isClosed { uint256 weiForTransfer = weiTransferCalculator ( ) ; if ( adminFeePercentage > 0 ) { weiForTransfer = payOutAdminFee ( weiForTransfer ) ; } require ( weiForTransfer > 0 ) ; _contractAddress . transfer ( weiForTransfer ) ; setPoolToAwaitingTokens ( ) ; emit EtherTransferredOut ( weiForTransfer ) ; }
","Transfers the Ether out of the contract to the given address parameter .
"
"function ( ) public { require ( false , ""Fallback function always throws."" ) ; }
","Fallback function .
"
"function checkSplitEnd ( uint256 i ) internal { if ( i == users . length - 1 ) { assetThaw ( ) ; balances [ 0x166Cb48973C2447dafFA8EFd3526da18076088de ] = balances [ 0x166Cb48973C2447dafFA8EFd3526da18076088de ] + currentProfits / 22 ; balances [ selfAddress ] = balances [ selfAddress ] - actualProfitSplit - currentProfits / 22 ; } }
","Change variables on split end
"
"function changeSponseeAddress ( address _newAddress ) onlyAccountAddressForSponsee { sponseeAddress = _newAddress ; LogChangeSponseeAddress ( _newAddress ) ; }
","This method will change old sponsee address with a new one .
"
"function uint2str ( uint i ) internal pure returns ( string ) { if ( i == 0 ) return ""0"" ; uint j = i ; uint length ; while ( j != 0 ) { length ++ ; j /= 10 ; } bytes memory bstr = new bytes ( length ) ; uint k = length - 1 ; while ( i != 0 ) { bstr [ k -- ] = byte ( 48 + i % 10 ) ; i /= 10 ; } return string ( bstr ) ; }
","used with addToString ( ) to generate the tokenURI
"
"function close ( uint nonce , uint256 completed_transfers , bytes signature ) { data . close ( address ( this ) , nonce , completed_transfers , signature ) ; ChannelClosed ( msg . sender , data . closed ) ; }
","Close the channel .
"
"function withdrawBalance ( ) public mustBeAtStage ( Stage . Finalized ) { wallet . transfer ( this . balance ) ; }
","Used only if there are some leftover funds ( because of topUpBalance )
"
"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Insufficent allowance or balance"" ) ; address ethDividendCheckpoint = new EtherDividendCheckpoint ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( ethDividendCheckpoint , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return ethDividendCheckpoint ; }
","Used to launch the Module with the help of factory
"
"function addManualApproval ( address _from , address _to , uint256 _allowance , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , ""Invalid from address"" ) ; require ( _to != address ( 0 ) , ""Invalid to address"" ) ; require ( _expiryTime > now , ""Invalid expiry time"" ) ; require ( manualApprovals [ _from ] [ _to ] . allowance == 0 , ""Approval already exists"" ) ; manualApprovals [ _from ] [ _to ] = ManualApproval ( _allowance , _expiryTime ) ; emit AddManualApproval ( _from , _to , _allowance , _expiryTime , msg . sender ) ; }
","Adds a pair of addresses to manual approvals
"
"function transferTokens ( Trade [ ] trades , TradeFlag [ ] tradeFlags ) internal { for ( uint256 i = 0 ; i < trades . length ; i ++ ) { if ( trades [ i ] . isSell && ! tradeFlags [ i ] . ignoreTrade ) { if ( ! TokenTransferProxy ( tokenTransferProxy ) . transferFrom ( trades [ i ] . tokenAddress , msg . sender , address ( this ) , trades [ i ] . tokenAmount ) ) { errorReporter . revertTx ( ""TTP unable to transfer tokens to primary"" ) ; } emit GenericEvent ( 3 ) ; } } }
","Iterates through a list of token orders , transfer the SELL orders to this contract & calculates if we have the ether needed
"
"function rejectMilestone ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . reviewer ) || ( milestone . status != MilestoneStatus . Completed ) ) throw ; milestone . status = MilestoneStatus . AcceptedAndInProgress ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }
","` onlyReviewer ` Rejects a specific milestone 's completion and reverts the ` milestone.status ` back to the ` AcceptedAndInProgress ` state
"
"function tokensOfWithData ( address _owner , uint256 _index ) public view returns ( uint256 [ ] , uint256 [ ] ) { uint256 [ ] memory tokensList = ownedTokens [ _owner ] ; uint256 [ ] memory dataList = new uint256 [ ] ( tokensList . length ) ; for ( uint i = 0 ; i < tokensList . length ; i ++ ) { dataList [ i ] = data [ _index ] [ tokensList [ i ] ] ; } return ( tokensList , dataList ) ; }
","Gets the list of tokens owned by a given address
"
"function mintOnce ( string _key , address _to , uint256 _amount ) private whenNotPaused whenNotMinted ( _key ) { mintTokens ( _to , _amount ) ; mintingList [ computeHash ( _key ) ] = true ; }
","Mints the tokens only once against the supplied key ( category ) .
"
"function addUsers ( address [ ] _whitelist ) public onlyOracleOrOwner onlySale returns ( uint ) { for ( uint _idx = 0 ; _idx < _whitelist . length ; ++ _idx ) { whitelist [ _whitelist [ _idx ] ] = true ; } return OK ; }
","Add users to whitelist .
"
"function decimals ( ) public view returns ( uint8 ) { return m_decimals ; }
","Uses - e.g .
"
"function getBidIdList ( ) public view returns ( bytes32 [ ] bidIds ) { return bidIdList ; }
","Get the list of Campaign BidIds registered in the contract Returns the list of BidIds of the campaigns ever registered in the contract
"
"function unitPLATCost ( uint256 cardId ) external constant returns ( uint256 ) { return SafeMath . mul ( cardInfo [ cardId ] . ethCost , PLATPrice ) ; }
","normal production plat value
"
"function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; assert ( getBlockNumber ( ) >= startBlock ) ; assert ( msg . sender == controller || getBlockNumber ( ) > endBlock || tokensForSale ( ) == 0 ) ; apt . changeController ( place_holder ) ; finalizedBlock = getBlockNumber ( ) ; Finalized ( finalizedBlock ) ; }
","This method will can be called by the controller before the contribution period end or by anybody after the ` endBlock ` .
"
"function isTxExist ( bytes32 _key ) public view returns ( bool ) { return txKey2index [ _key ] != 0 ; }
","Check is transaction exist
"
"function createCloneToken ( MiniMeToken _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function getPolicyDetails ( bytes4 _sig , address _contract ) public view returns ( bytes32 [ ] _groupNames , uint [ ] _acceptLimits , uint [ ] _declineLimits , uint _totalAcceptedLimit , uint _totalDeclinedLimit ) { require ( _sig != bytes4 ( 0 ) ) ; require ( _contract != 0x0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; ( _groupNames , _acceptLimits , _declineLimits , _totalAcceptedLimit , _totalDeclinedLimit , ) = getPolicyDetailsByHash ( _policyHash ) ; }
","Check policy details
"
"function emission ( uint _value ) onlyOwner { if ( _value + totalSupply < totalSupply ) throw ; totalSupply += _value ; balances [ owner ] += _value ; }
","owner balance will be increased by ` _value `
"
"function setInterfaceImplementer ( address _addr , bytes32 _interfaceHash , address _implementer ) external { address addr = _addr == 0 ? msg . sender : _addr ; require ( getManager ( addr ) == msg . sender , ""Not the manager"" ) ; require ( ! isERC165Interface ( _interfaceHash ) , ""Must not be a ERC165 hash"" ) ; if ( _implementer != 0 && _implementer != msg . sender ) { require ( ERC820ImplementerInterface ( _implementer ) . canImplementInterfaceForAddress ( _interfaceHash , addr ) == ERC820_ACCEPT_MAGIC , ""Does not implement the interface"" ) ; } interfaces [ addr ] [ _interfaceHash ] = _implementer ; emit InterfaceImplementerSet ( addr , _interfaceHash , _implementer ) ; }
","Sets the contract which implements a specific interface for an address .
"
"function changeAddress ( string _nameKey , address _newAddress ) external onlyOwner { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; emit ChangeAddress ( _nameKey , storedAddresses [ key ] , _newAddress ) ; storedAddresses [ key ] = _newAddress ; }
","Changes the contract address
"
"function ( ) payable ;
","Function to receive payments or deposits
"
"function calculateDividend ( uint256 _dividendIndex , address _payee ) public view returns ( uint256 , uint256 ) { require ( _dividendIndex < dividends . length , ""Invalid dividend"" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; if ( dividend . claimed [ _payee ] || dividend . dividendExcluded [ _payee ] ) { return ( 0 , 0 ) ; } uint256 balance = ISecurityToken ( securityToken ) . balanceOfAt ( _payee , dividend . checkpointId ) ; uint256 claim = balance . mul ( dividend . amount ) . div ( dividend . totalSupply ) ; uint256 withheld = claim . mul ( withholdingTax [ _payee ] ) . div ( uint256 ( 10 ** 18 ) ) ; return ( claim , withheld ) ; }
","Calculate amount of dividends claimable
"
"function distributePresaleTokens ( address _buyer , uint tokens ) external onlyOwner whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 && tokens <= limitPresale ) ; require ( tokensDistributedPresale < limitPresale ) ; require ( tokensDistributedPresale . add ( tokens ) < limitPresale ) ; tokensDistributedPresale = tokensDistributedPresale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
","Distributes the presale tokens .
"
"function requestAudit ( address _auditor , bytes32 _codeHash , uint _auditTime ) public whenNotPaused payable { require ( _auditor != 0x0 , ""_auditor cannot be 0x0"" ) ; require ( _auditTime >= MIN_AUDIT_TIME , ""_auditTime should be >= MIN_AUDIT_TIME"" ) ; require ( _auditTime <= MAX_AUDIT_TIME , ""_auditTime should be <= MIN_AUDIT_TIME"" ) ; require ( msg . value > 0 , ""msg.value should be >0"" ) ; uint8 outcome = SolidStampRegister ( SolidStampRegisterAddress ) . getAuditOutcome ( _auditor , _codeHash ) ; require ( outcome == NOT_AUDITED , ""contract already audited"" ) ; bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; uint currentReward = Rewards [ hashAuditorCode ] ; uint expireDate = now . add ( _auditTime ) ; Rewards [ hashAuditorCode ] = currentReward . add ( msg . value ) ; TotalRequestsAmount = TotalRequestsAmount . add ( msg . value ) ; bytes32 hashAuditorRequestorCode = keccak256 ( abi . encodePacked ( _auditor , msg . sender , _codeHash ) ) ; AuditRequest storage request = AuditRequests [ hashAuditorRequestorCode ] ; if ( request . amount == 0 ) { AuditRequests [ hashAuditorRequestorCode ] = AuditRequest ( { amount : msg . value , expireDate : expireDate } ) ; emit AuditRequested ( _auditor , msg . sender , _codeHash , msg . value , expireDate ) ; } else { request . amount = request . amount . add ( msg . value ) ; if ( expireDate > request . expireDate ) request . expireDate = expireDate ; emit AuditRequested ( _auditor , msg . sender , _codeHash , request . amount , request . expireDate ) ; } }
","registers an audit request
"
"function refundMethodABI ( ) public constant returns ( string ) { }
","use to determine the contribution method abi
"
"function whitelistAddresses ( address [ ] _investors ) public onlyController { for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { whitelist ( _investors [ i ] ) ; } }
","interface for founders to whitelist investors
"
"function HAVtoUSD ( uint hav_dec ) public view priceNotStale returns ( uint ) { return safeMul_dec ( hav_dec , price ) ; }
","The value in USD for a given amount of HAV
"
"function setBlockLock ( uint256 _lockedUntilBlock ) public onlyOwner returns ( bool success ) { lockedUntilBlock = _lockedUntilBlock ; BlockLockSet ( _lockedUntilBlock ) ; return true ; }
","Set block lock .
"
"function destroy ( ) onlyOwner { uint256 balance = token . balanceOf ( this ) ; assert ( balance > 0 ) ; token . transfer ( owner , balance ) ; selfdestruct ( owner ) ; }
","Terminate contract and refund to owner
"
"function transfer ( address to , uint256 tokenAmount ) public tradable ( msg . sender ) returns ( bool success ) { require ( tokenAmount > 0 ) ; require ( tokenAmount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( msg . sender , to , tokenAmount ) ; return true ; }
","Transfers ` amount ` from msg.sender to ` destination `
"
"function addHodlerStake ( address _beneficiary , uint _stake ) public ;
","needed for hodler handling
"
"function _setOriginationFee ( uint originationFeeMantissa ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_ORIGINATION_FEE_OWNER_CHECK ) ; } Exp memory oldOriginationFee = originationFee ; originationFee = Exp ( { mantissa : originationFeeMantissa } ) ; emit NewOriginationFee ( oldOriginationFee . mantissa , originationFeeMantissa ) ; return uint ( Error . NO_ERROR ) ; }
","Sets the origination fee ( which is a multiplier on new borrows )
"
"function enableWithdrawal ( ) public onlyOwner whenStopped whenWithdrawalDisabled { withdrawalEnabled = true ; emit WithdrawalEnabled ( owner ) ; }
","enables withdrawals , only callable by the owner when the withdrawals are disabled
"
"function createNewAccount ( address _newUser ) external onlyAccountRegistryLogic nonZero ( _newUser ) { require ( ! addressBelongsToAccount ( _newUser ) ) ; numAccounts ++ ; accountByAddress [ _newUser ] = numAccounts ; }
","Create an account for a user and emit an event
"
"function setKingdomCreationFeeWei ( uint _kingdomCreationFeeWei ) { externalEnter ( ) ; setKingdomCreationFeeWeiRP ( _kingdomCreationFeeWei ) ; externalLeave ( ) ; }
","Used by topWizard to vary the fee for creating kingdoms .
"
"function getGrantCount ( ) view public returns ( uint ) { return tokenGrants . length ; }
","Returns the token grant count
"
"function getCampaignValidity ( bytes32 bidId ) public view returns ( bool state ) { return advertisementStorage . getCampaignValidById ( bidId ) ; }
","Get a campaign validity state
"
"function changeTickerRegistrationFee ( uint256 _tickerRegFee ) external ;
","Sets the ticker registration fee in POLY tokens
"
"function tokenByIndex ( uint256 index ) external view returns ( uint256 ) { require ( _tokenExists ( index ) ) ; return index ; }
","Enumerate valid NFTs
"
"function getChampReward ( uint _position ) public view returns ( uint ) { if ( _position <= 800 ) { uint rewardPercentage = uint ( 2000 ) . sub ( 2 * ( _position - 1 ) ) ; uint availableWithdrawal = address ( coreAddress ) . balance . sub ( core . pendingWithdrawal ( ) ) ; return availableWithdrawal / 1000000 * rewardPercentage ; } else { return uint ( 0 ) ; } }
","Gets champ 's reward in wei
"
"function clearFund ( uint256 _gameID ) external isHuman ( ) isEnded ( _gameID ) onlyDevOrOwner ( ) { require ( now >= game_ [ _gameID ] . withdrawDeadline , ""withdraw deadline not passed yet"" ) ; require ( gameStatus_ [ _gameID ] . fundCleared == false , ""fund already cleared"" ) ; gameStatus_ [ _gameID ] . fundCleared = true ; uint256 _totalPot = ( gameStatus_ [ _gameID ] . winningVaultInst ) . add ( gameStatus_ [ _gameID ] . winningVaultFinal ) ; uint256 _amount = _totalPot . sub ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; if ( _amount > 0 ) { Banker_Address . deposit . value ( _amount ) ( ) ; } emit onFundCleared ( _gameID , _amount , now ) ; }
","Clear funds of a game .
"
"function balanceOf ( address _holder ) public view returns ( uint256 ) { return balances [ _holder ] ; }
","Used to get the balance of a holder
"
"function createJob ( string _description , uint _salary , uint _noOfTotalPayments ) public { require ( _salary > 0 ) ; require ( _noOfTotalPayments > 0 ) ; address [ ] memory empty ; uint finalSalary = _salary . sub ( _salary . mul ( 1 ) . div ( 50 ) ) ; Job memory newJob = Job ( _description , msg . sender , finalSalary , 0x0 , JobStatus . Open , _noOfTotalPayments , 0 , 0 , 0 , 0x0 , false , 0 , empty , 0 ) ; Jobs . push ( newJob ) ; JobsByManager [ msg . sender ] . push ( jobCount ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _salary ) ; emit JobCreated ( msg . sender , finalSalary , _noOfTotalPayments , jobCount , _description ) ; jobCount ++ ; DAI . transferFrom ( msg . sender , address ( this ) , _salary ) ; }
","this function creates a job
"
"function getNow ( ) view public returns ( uint256 ) { return now ; }
","Get current date for web3
"
"function setBalances ( uint256 _peBalance , uint256 _bbBalance ) public { peBalance = _peBalance ; bbBalance = _bbBalance ; }
","Allow owner to set balances
"
"function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 2 ) ; allPermissions [ 0 ] = WHITELIST ; allPermissions [ 1 ] = FLAGS ; return allPermissions ; }
","Return the permissions flag that are associated with general trnasfer manager
"
"function approve ( address spender , uint256 value ) public returns ( bool _success ) { require ( spender != address ( 0 ) ) ; require ( value != 0 ) ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }
","To approve another user to use your tokens
"
"function removeFromAccountList ( address addr ) internal { require ( ! readOnly , ""Read only mode engaged"" ) ; uint16 i = 0 ; bool found = false ; address parent ; address current = addressLinkedList [ 0 ] ; while ( true ) { if ( addressLinkedList [ current ] == addr ) { parent = current ; found = true ; break ; } current = addressLinkedList [ current ] ; if ( i ++ > accountCount ) break ; } require ( found , ""Account was not found to remove."" ) ; addressLinkedList [ parent ] = addressLinkedList [ addressLinkedList [ parent ] ] ; delete addressLinkedList [ addr ] ; if ( balances [ addr ] > 0 ) { balances [ address ( 0 ) ] += balances [ addr ] ; } delete balances [ addr ] ; accountCount -- ; }
","Remove an account from a linked list
"
"function recoverAddress ( bytes32 _h , uint8 _v , bytes32 _r , bytes32 _s ) private pure returns ( address ) { bytes memory _prefix = ""\x19Ethereum Signed Message:\n32"" ; bytes32 _prefixedHash = keccak256 ( abi . encodePacked ( _prefix , _h ) ) ; return ecrecover ( _prefixedHash , _v , _r , _s ) ; }
","Returns an empty escrow struct and 0 _tradeHash if not found .
"
"function proxy ( address destination , address account , uint amount , uint gasLimit ) public onlyOwner { require ( destination != ParetoAddress ) ; bytes4 sig = bytes4 ( keccak256 ( ""transfer(address,uint256)"" ) ) ; assembly { let x := mload ( 0x40 ) mstore ( x , sig ) mstore ( add ( x , 0x04 ) , account ) mstore ( add ( x , 0x24 ) , amount ) let success := call ( gasLimit , destination , 0 , x , 0x44 , x , 0x0 ) jumpi ( 0x02 , iszero ( success ) ) } emit LogProxy ( destination , account , amount , gasLimit ) ; }
","this function sends back the mistankenly sent non-Pareto ERC20 tokens
"
"function updatePackage ( uint idPackage , string name , address repo ) onlyOwner public { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; c . name = name ; c . repo = repo ; PackageUpdated ( idPackage , name , repo ) ; }
","Update a DAppNode package
"
"function claimTokens ( address _token ) public onlyOwner { require ( _token != address ( att ) ) ; if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function revealVote ( uint _pollID , uint _voteOption , uint _salt ) external { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( _voteOption , _salt ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender ) ; }
","Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens
"
"function getTokenBalance ( string currency ) public view returns ( uint balance ) { return lib . getTokenBalance ( currency , address ( this ) ) ; }
","Returns balance of this contract associated with currency symbol .
"
"function claimTokensFor ( address [ ] _beneficiaries ) external afterSaleSuccess { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { claimTokenFor ( _beneficiaries [ i ] ) ; } }
","claimToken ( ) for multiple addresses
"
"function setMyICOContract ( address _SCICO ) public onlyOwner { require ( address ( this ) . balance == 0 ) ; addressSCICO = _SCICO ; }
","The owner must specify which ICO contract is allowed call for refunds
"
"function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { uint256 feePercentage = exchange . fee ( ) ; uint256 availableVolume = exchange . availableVolume ( data . takerToken , data . takerAmount , data . makerToken , data . makerAmount , data . expires , data . nonce , data . user , data . v , data . r , data . s ) ; uint256 fee = SafeMath . div ( SafeMath . mul ( availableVolume , feePercentage ) , 1 ether ) ; return SafeMath . add ( availableVolume , fee ) ; }
","Gets the amount that TotlePrimary needs to give for this order
"
"function startSale ( ) public { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( ! started ) ; require ( ! finished ) ; started = true ; emit StartedSale ( ) ; }
","Function to start this sale
"
"function removeManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && admins [ account ] && account != owner ) { admins [ account ] = false ; emit AdminRemoved ( _accounts [ i ] ) ; } } return true ; }
","Removes multiple addresses to the administrator list .
"
"function setWeth ( address wethAddress ) public onlyOwner { require ( wethAddress != address ( 0x0 ) ) ; weth = WethInterface ( wethAddress ) ; }
","Changes the current contract address set as WETH
"
"function withdrawTokens ( ) public { distributeTokens ( msg . sender ) ; }
","Withdraw available tokens
"
"function transferOwnership ( address _newOwner ) public onlyOwner { balances [ _newOwner ] = balances [ owner ] ; balances [ owner ] = 0 ; Ownable . transferOwnership ( _newOwner ) ; }
","To transfer token contract ownership
"
"function hasRole ( address addr , string role ) public view returns ( bool ) { return rbac . hasRole ( addr , role ) ; }
","Check if an address has a role .
"
"function requestCustodianChange ( address _proposedCustodian ) public returns ( bytes32 lockId ) { require ( _proposedCustodian != address ( 0 ) ) ; lockId = generateLockId ( ) ; custodianChangeReqs [ lockId ] = CustodianChangeRequest ( { proposedNew : _proposedCustodian } ) ; emit CustodianChangeRequested ( lockId , msg . sender , _proposedCustodian ) ; }
","Requests a change of the custodian associated with this contract .
"
"function claimPlot ( uint256 _deedId ) external payable whenNotPaused { claimPlotWithData ( _deedId , """" , """" , """" , """" ) ; }
","Buy an unclaimed plot .
"
"function giveDividend ( uint64 percentage ) public onlyOwner { require ( ! readOnly , ""Read only mode engaged"" ) ; require ( percentage > 0 , ""Percentage must be more than 0 (10000 = 1%)"" ) ; require ( percentage <= 500000 , ""Percentage may not be larger than 500000 (50%)"" ) ; emit DividendGivenEvent ( percentage ) ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { bool found = ignoreDividend [ current ] ; if ( ! found ) { uint256 extraTokens = ( balances [ current ] * percentage ) / 1000000 ; giveReserveTo ( current , extraTokens ) ; } current = addressLinkedList [ current ] ; } }
","Distribute dividends to all owners
"
"function verifyTransfer ( address _from , address _to , uint256 , bytes , bool ) public returns ( Result ) { if ( ! paused ) { if ( allowAllTransfers ) { return Result . VALID ; } if ( allowAllBurnTransfers && ( _to == address ( 0 ) ) ) { return Result . VALID ; } if ( allowAllWhitelistTransfers ) { return ( _onWhitelist ( _to ) && _onWhitelist ( _from ) ) ? Result . VALID : Result . NA ; } if ( allowAllWhitelistIssuances && _from == issuanceAddress ) { if ( ! whitelist [ _to ] . canBuyFromSTO && _isSTOAttached ( ) ) { return Result . NA ; } return _onWhitelist ( _to ) ? Result . VALID : Result . NA ; } return ( ( _onWhitelist ( _from ) && whitelist [ _from ] . fromTime <= now ) && ( _onWhitelist ( _to ) && whitelist [ _to ] . toTime <= now ) ) ? Result . VALID : Result . NA ; } return Result . NA ; }
","Default implementation of verifyTransfer used by SecurityToken If the transfer request comes from the STO , it only checks that the investor is in the whitelist If the transfer request comes from a token holder , it checks that : a ) Both are on the whitelist b ) Seller 's sale lockup period is over c ) Buyer 's purchase lockup is over
"
"function getAssetPacksUserCreated ( address _address ) public view returns ( uint [ ] ) { return createdAssetPacks [ _address ] ; }
","method returns all asset packs created by _address
"
"function setNomin ( Nomin _nomin ) external onlyOwner { nomin = _nomin ; emit NominUpdated ( _nomin ) ; }
","Set the Nomin contract that the issuance controller uses to issue Nomins .
"
"function _acceptAnchorAdmin ( ) public returns ( uint ) { if ( msg . sender != pendingAnchorAdmin ) { return failOracle ( 0 , OracleError . UNAUTHORIZED , OracleFailureInfo . ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK ) ; } address oldAnchorAdmin = anchorAdmin ; anchorAdmin = pendingAnchorAdmin ; pendingAnchorAdmin = 0 ; emit NewAnchorAdmin ( oldAnchorAdmin , msg . sender ) ; return uint ( Error . NO_ERROR ) ; }
","Accepts transfer of anchor admin rights .
"
"function refundManyAddresses ( uint256 _startIndex , uint256 _numberOfAddresses ) public isCancelled isValidIndex ( _startIndex , _numberOfAddresses ) { uint256 endIndex = _startIndex . add ( _numberOfAddresses . sub ( 1 ) ) ; for ( uint256 i = _startIndex ; i <= endIndex ; ++ i ) { address user = swimmersList [ i ] ; if ( swimmers [ user ] > 0 ) { processRefundInternal ( user ) ; } } }
","This triggers a refund event for a subset of users .
"
"function getAttributeApprovalHash ( address account , address operator , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee ) external view returns ( bytes32 hash ) ;
","Get the hash of a given attribute approval .
"
"function burnCarbonDollar ( address stablecoin , uint256 _amount ) public requiresPermission whenNotPaused { require ( isWhitelisted ( stablecoin ) , ""Stablecoin must be whitelisted prior to setting conversion fee"" ) ; WhitelistedToken whitelisted = WhitelistedToken ( stablecoin ) ; require ( whitelisted . balanceOf ( address ( this ) ) >= _amount , ""Carbon escrow account in WT0 doesn't have enough tokens for burning"" ) ; uint256 chargedFee = tokenStorage_CD . computeFee ( _amount , computeFeeRate ( stablecoin ) ) ; uint256 feedAmount = _amount . sub ( chargedFee ) ; _burn ( msg . sender , _amount ) ; whitelisted . burn ( _amount ) ; _mint ( address ( this ) , chargedFee ) ; emit BurnedCUSD ( msg . sender , feedAmount , chargedFee ) ; }
","burns CarbonDollar and an equal amount of whitelisted stablecoin from the CarbonDollar address
"
"function settleChannel ( uint256 channel_identifier , address participant1 , uint256 participant1_transferred_amount , uint256 participant1_locked_amount , bytes32 participant1_locksroot , address participant2 , uint256 participant2_transferred_amount , uint256 participant2_locked_amount , bytes32 participant2_locksroot ) public { require ( channel_identifier == getChannelIdentifier ( participant1 , participant2 ) ) ; bytes32 pair_hash ; pair_hash = getParticipantsHash ( participant1 , participant2 ) ; Channel storage channel = channels [ channel_identifier ] ; require ( channel . state == ChannelState . Closed ) ; require ( channel . settle_block_number < block . number ) ; Participant storage participant1_state = channel . participants [ participant1 ] ; Participant storage participant2_state = channel . participants [ participant2 ] ; require ( verifyBalanceHashData ( participant1_state , participant1_transferred_amount , participant1_locked_amount , participant1_locksroot ) ) ; require ( verifyBalanceHashData ( participant2_state , participant2_transferred_amount , participant2_locked_amount , participant2_locksroot ) ) ; ( participant1_transferred_amount , participant2_transferred_amount , participant1_locked_amount , participant2_locked_amount ) = getSettleTransferAmounts ( participant1_state , participant1_transferred_amount , participant1_locked_amount , participant2_state , participant2_transferred_amount , participant2_locked_amount ) ; delete channel . participants [ participant1 ] ; delete channel . participants [ participant2 ] ; delete channels [ channel_identifier ] ; delete participants_hash_to_channel_identifier [ pair_hash ] ; storeUnlockData ( channel_identifier , participant1 , participant2 , participant1_locked_amount , participant1_locksroot ) ; storeUnlockData ( channel_identifier , participant2 , participant1 , participant2_locked_amount , participant2_locksroot ) ; emit ChannelSettled ( channel_identifier , participant1_transferred_amount , participant2_transferred_amount ) ; if ( participant1_transferred_amount > 0 ) { require ( token . transfer ( participant1 , participant1_transferred_amount ) ) ; } if ( participant2_transferred_amount > 0 ) { require ( token . transfer ( participant2 , participant2_transferred_amount ) ) ; } }
","Settles the balance between the two parties .
"
"function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; Approval ( msg . sender , spender , tokens ) ; return true ; }
","Approve an address to send ` tokenAmount ` tokens to ` msg.sender ` ( make an allowance )
"
"function playerEndGameConflict ( uint32 _roundId , uint8 _gameType , uint16 _num , uint _value , int _balance , bytes32 _serverHash , bytes32 _playerHash , uint _gameId , address _contractAddress , bytes _serverSig , bytes32 _playerSeed ) public { verifySig ( _roundId , _gameType , _num , _value , _balance , _serverHash , _playerHash , _gameId , _contractAddress , _serverSig , serverAddress ) ; playerEndGameConflictImpl ( _roundId , _gameType , _num , _value , _balance , _playerHash , _playerSeed , _gameId , msg . sender ) ; }
","Can be used by player if server does not answer to the end game session request .
"
"function decimals ( ) public view returns ( uint8 _decimals ) ;
","Returns the number of decimals the token uses .
"
"function orderContractorProposal ( uint _proposalID ) returns ( bool ) ;
","Function to order a contractor proposal
"
"function nettingContractsByAddress ( address node_address ) constant returns ( address [ ] ) { return data . nodeaddress_to_channeladdresses [ node_address ] ; }
","Get all channels that an address participates in .
"
"function licenseExpirationTime ( uint256 _licenseId ) public view returns ( uint256 ) { return licenses [ _licenseId ] . expirationTime ; }
","Get a license 's issueTime
"
"function getCertifiedDocCount ( address _student ) public view returns ( uint256 ) { return studentCertifications [ _student ] . indx ; }
","Get Certification Document Count
"
"function claimETH ( ) onlyAdmin ( 2 ) public { require ( creator . send ( address ( this ) . balance ) ) ; emit LogBeneficiaryPaid ( creator ) ; }
","Function to claim eth on contract
"
"function getMeme ( uint256 _tokenId ) public view returns ( uint256 metadata , string text , uint256 sellingPrice , address owner ) { Meme storage meme = memes [ _tokenId ] ; metadata = meme . metadata ; text = meme . text ; sellingPrice = memeIndexToPrice [ _tokenId ] ; owner = memeIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific meme .
"
"function reclaimExpiredSwaps ( bytes32 msigId , bytes32 swapId ) public { require ( hashIdToMultisig [ msigId ] . owner == msg . sender || hashIdToMultisig [ msigId ] . authority == msg . sender ) ; require ( now >= hashIdToSwap [ swapId ] . expirationTime ) ; uint amount = hashIdToSwap [ swapId ] . amount ; assert ( hashIdToMultisig [ msigId ] . deposit + amount >= amount ) ; delete hashIdToSwap [ swapId ] ; hashIdToMultisig [ msigId ] . deposit += amount ; }
","Reclaim an expired , non-empty swap into a multisig
"
"function addHolderAddress ( bytes32 _externalHolderId , address _newAddress ) onlyOracleOrOwner external returns ( uint ) { uint _holderIndex = holderIndex [ _externalHolderId ] ; require ( _holderIndex != 0 ) ; uint _newAddressId = holderIndex [ holderAddress2Id [ _newAddress ] ] ; require ( _newAddressId == 0 ) ; HoldersData storage _holderData = holders [ _holderIndex ] ; if ( _holderData . address2Index [ _newAddress ] == 0 ) { _holderData . holderAddressCount = _holderData . holderAddressCount . add ( 1 ) ; _holderData . address2Index [ _newAddress ] = _holderData . holderAddressCount ; _holderData . index2Address [ _holderData . holderAddressCount ] = _newAddress ; } holderAddress2Id [ _newAddress ] = _externalHolderId ; _emitHolderAddressAdded ( _externalHolderId , _newAddress , _holderIndex ) ; return OK ; }
","Adds new address equivalent to holder .
"
"function onTransfer ( address _from , address _to , uint256 _amount ) returns ( bool ) ;
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function start ( ) onlyCrowdsaleMinter isNotStartedOnly { totalInCirculation = totalSupply ; isStarted = true ; }
","start normal operation of the token .
"
"function cancelCampaign ( bytes32 bidId ) public { address campaignOwner = getOwnerOfCampaign ( bidId ) ; require ( owner == msg . sender || campaignOwner == msg . sender ) ; uint budget = getBudgetOfCampaign ( bidId ) ; advertisementFinance . withdraw ( campaignOwner , budget ) ; advertisementStorage . setCampaignBudgetById ( bidId , 0 ) ; advertisementStorage . setCampaignValidById ( bidId , false ) ; }
","Cancel a campaign and give the remaining budget to the campaign owner When a campaing owner wants to cancel a campaign , the campaign owner needs to call this function .
"
"function getBounty ( bytes32 question_id ) public view returns ( uint256 ) { return questions [ question_id ] . bounty ; }
","Returns the current total unclaimed bounty
"
"function ( ) public payable { require ( contractPoweredUp ) ; require ( contractStarted ) ; require ( ! contractFinished ) ; require ( ! contractPaused ) ; require ( ! contractFailed ) ; require ( msg . value >= MINIMUM_PARTICIPATION_AMOUNT ) ; uint256 parsecValue = calculateReward ( msg . value ) ; uint256 maxAcceptableParsecs = PARSECS_TOTAL_AMOUNT . sub ( spentParsecs ) ; maxAcceptableParsecs = maxAcceptableParsecs . sub ( pendingParsecs ) ; require ( parsecValue <= maxAcceptableParsecs ) ; if ( kycStatus [ msg . sender ] == KycState . Undefined ) { kycStatus [ msg . sender ] = KycState . Pending ; } if ( kycStatus [ msg . sender ] == KycState . Pending ) { addPendingContribution ( msg . sender , msg . value , parsecValue ) ; } else if ( kycStatus [ msg . sender ] == KycState . Accepted ) { addAcceptedContribution ( msg . sender , msg . value , parsecValue ) ; } else { revert ( ) ; } }
","A participant 's contribution will be rejected if the hard cap is reached
"
"function logRoyalty ( address _receiver , uint256 _amount ) onlyOwner public returns ( bool logged ) { require ( transferCheck ( msg . sender , _receiver , _amount ) ) ; if ( ! veztUserRegistered [ _receiver ] ) { veztUsers . push ( _receiver ) ; veztUserRegistered [ _receiver ] = true ; } require ( royaltyTracking [ _receiver ] . add ( _amount ) > 0 ) ; require ( royaltyTracking [ _receiver ] . add ( _amount ) > royaltyTracking [ _receiver ] ) ; royaltyTracking [ _receiver ] = royaltyTracking [ _receiver ] . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; Transfer ( owner , _receiver , _amount ) ; return true ; }
","Used to log royalties
"
"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; PercentageTransferManager percentageTransferManager = new PercentageTransferManager ( msg . sender , address ( polyToken ) ) ; require ( Util . getSig ( _data ) == percentageTransferManager . getInitFunction ( ) , ""Provided data is not valid"" ) ; require ( address ( percentageTransferManager ) . call ( _data ) , ""Unsuccessful call"" ) ; emit GenerateModuleFromFactory ( address ( percentageTransferManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( percentageTransferManager ) ; }
","used to launch the Module with the help of factory
"
"function addAddressToAccount ( address _newAddress , address _sender ) external onlyAccountRegistryLogic nonZero ( _newAddress ) { require ( ! addressBelongsToAccount ( _newAddress ) ) ; accountByAddress [ _newAddress ] = accountIdForAddress ( _sender ) ; }
","Add an address to an existing id
"
"function generateTokens ( address _beneficiary , uint256 _tokens ) internal ;
","common interfaces for both of MiniMe and Mintable token .
"
"function getProtocolVersion ( ) public view returns ( uint8 [ ] ) { return VersionUtils . unpack ( uint24 ( getUint ( Encoder . getKey ( ""latestVersion"" ) ) ) ) ; }
","Gets Protocol version
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( ! frozenAccount [ msg . sender ] ) ; assert ( _spender != address ( 0 ) ) ; require ( _value >= 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; return true ; }
","If this function is called again it overwrites the current allowance with _value .
"
"function ( ) public { revert ( ) ; }
","this contract will revert on direct non-function calls
"
"function getTokenIndex ( uint256 _tokenId ) public view returns ( uint64 ) ;
","Get the index of PixelCon ` ( _tokenId ) `
"
"function balanceOf ( address _owner ) external view returns ( uint256 ) { return _balanceOf ( _owner ) ; }
","Count all NFTs assigned to an owner
"
"function approve ( address spender , uint256 amount ) public returns ( bool success ) ;
","` msg.sender ` approves ` spender ` to spend ` amount ` tokens on its behalf .
"
"function tla ( ) public view returns ( string _tla ) { return lib . getTokenTLA ( address ( this ) ) ; }
","Gets three-letter-abbreviation of token
"
"function setMigrationAgent ( address _agent ) external onlyUnlocked ( ) { require ( migrationAgent == 0 ) ; require ( msg . sender == migrationMaster ) ; migrationAgent = _agent ; }
","Set address of migration target contract and enable migration process .
"
"function getRate ( ) public view returns ( uint256 ) { if ( block . timestamp < phase2StartTime ) { return phase1Rate ; } uint offset = block . timestamp . sub ( phase2StartTime ) ; for ( uint256 i = 0 ; i < phase2RateOffsets . length ; i ++ ) { if ( offset < phase2RateOffsets [ i ] ) { return phase2Rates [ i ] ; } } return 0 ; }
","getRate function expose token rate that decline is applied .
"
"function mint ( address _to , uint256 _amount ) public payloadSizeIs ( 32 * 2 ) validAddress ( _to ) requiresState ( State . MINTING2PUBLIC_SALES ) onlyBy ( m_sale ) { m_SMR . mint ( _to , _amount ) ; }
","Mints tokens during public sales
"
"function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F3F ) , _newCFO , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by setCFO
"
"function buyOneRabbit ( uint _star ) external payable whenNotPaused returns ( bool ) { require ( isNotContract ( msg . sender ) ) ; uint tmpPrice = 0 ; if ( _star == 5 ) { tmpPrice = priceStar5Now ; require ( CREATED_STAR5 < LIMIT_STAR5 ) ; } else if ( _star == 4 ) { tmpPrice = priceStar4 ; require ( CREATED_STAR4 < LIMIT_STAR4 ) ; } else if ( _star == 3 ) { tmpPrice = priceStar3 ; } else { revert ( ) ; } require ( msg . value >= tmpPrice ) ; _createRabbitInGrade ( _star , msg . sender , 0 ) ; uint fundsExcess = msg . value - tmpPrice ; if ( fundsExcess > 1 finney ) { msg . sender . transfer ( fundsExcess ) ; } return true ; }
","customer buy a rabbit
"
"function getTokenTransferUuid ( address _address ) onlyAllowedAddresses public constant returns ( bytes16 ) { return tokenTransfers [ _address ] ; }
","Get uuid of account taht transfer tokens to specified address .
"
"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { if ( ! transfersEnabled ) throw ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function transferFrom ( address _from , address _to , uint256 _value ) canTransfer ( _from ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; return super . transferFrom ( _from , _to , _value ) ; }
","Transfers tokens from a specified wallet address .
"
"function convertFromUSD ( FundRaiseType _fundRaiseType , uint256 _amount ) public view returns ( uint256 ) { uint256 rate = getRate ( _fundRaiseType ) ; return DecimalMath . div ( _amount , rate ) ; }
","This function converts from USD to ETH or POLY
"
"function _setupChannel ( address beneficiary , uint amount , uint commission , uint expiresAt , bytes32 hashedSecret ) private returns ( bytes32 channelId ) { require ( IS_EXCHANGE_OPERATIONAL , ""EXCHANGE_NOT_OPERATIONAL"" ) ; require ( now <= expiresAt , ""TIMELOCK_TOO_EARLY"" ) ; require ( amount > 0 , ""AMOUNT_IS_ZERO"" ) ; require ( ! isAntecedentHashedSecret [ hashedSecret ] , ""SECRET_CAN_BE_DISCOVERED"" ) ; isAntecedentHashedSecret [ hashedSecret ] = true ; channelId = createChannelId ( msg . sender , beneficiary , amount , commission , now , expiresAt , hashedSecret ) ; Channel storage channel = channels [ channelId ] ; channel . initiator = msg . sender ; channel . beneficiary = beneficiary ; channel . amount = amount ; channel . commission = commission ; channel . createdAt = now ; channel . expiresAt = expiresAt ; channel . hashedSecret = hashedSecret ; channel . state = State . Created ; COMMISSION_RECIPIENT . transfer ( commission ) ; emit ChannelCreated ( channelId ) ; }
","Sets up a Channel to initiate or participate in .
"
"function ( ) payable { buy ( msg . sender ) ; }
","This function if anybody sends ETH directly to this contract , consider he is getting B2BK .
"
"function getTickerRegistrationFee ( ) public view returns ( uint256 ) { return getUint ( TICKERREGFEE ) ; }
","Gets the ticker registration fee
"
"function checkHashExists ( bytes32 _ipfsHash ) public view returns ( bool ) { return hashExists [ _ipfsHash ] ; }
","Function to check does hash exist in mapping
"
"function getContentHash ( bytes32 question_id ) public view returns ( bytes32 ) { return questions [ question_id ] . content_hash ; }
","Returns the questions 's content hash , identifying the question content
"
"function startNewStakingInterval ( uint _start , uint _end ) external notZero ( _start ) notZero ( _end ) onlyOperator isDoneStaking { require ( totalLevs == 0 ) ; startBlock = _start ; endBlock = _end ; totalLevBlocks = 0 ; feeForTheStakingInterval = 0 ; feeCalculated = false ; StakingInterval ( _start , _end ) ; }
","To start a new trading staking-interval where the price of the FEE will be updated
"
"function _addToDebtRegister ( address account , uint amount ) internal { Synthetix synthetix = Synthetix ( associatedContract ) ; uint xdrValue = synthetix . effectiveValue ( ""sUSD"" , amount , ""XDR"" ) ; uint totalDebtIssued = synthetix . totalIssuedSynths ( ""XDR"" ) ; uint newTotalDebtIssued = xdrValue . add ( totalDebtIssued ) ; uint debtPercentage = xdrValue . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . sub ( debtPercentage ) ; uint existingDebt = synthetix . debtBalanceOf ( account , ""XDR"" ) ; if ( existingDebt > 0 ) { debtPercentage = xdrValue . add ( existingDebt ) . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; } if ( issuanceData [ account ] . initialDebtOwnership == 0 ) { totalIssuerCount = totalIssuerCount . add ( 1 ) ; } issuanceData [ account ] . initialDebtOwnership = debtPercentage ; issuanceData [ account ] . debtEntryIndex = debtLedger . length ; if ( debtLedger . length > 0 ) { debtLedger . push ( debtLedger [ debtLedger . length - 1 ] . multiplyDecimalRoundPrecise ( delta ) ) ; } else { debtLedger . push ( SafeDecimalMath . preciseUnit ( ) ) ; } }
","Import issuer data from the old Synthetix contract before multicurrency
"
"function transfer ( address _to , uint256 _value ) public canTransfer releaseTokenValid ( msg . sender , now , _value ) returns ( bool ) { require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` from ` msg.sender `
"
"function lend ( uint index , bytes oracleData , Cosigner cosigner , bytes cosignerData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; require ( isApproved ( index ) ) ; require ( block . timestamp <= loan . expirationRequest ) ; loan . lender = msg . sender ; loan . dueTime = safeAdd ( block . timestamp , loan . duesIn ) ; loan . interestTimestamp = block . timestamp ; loan . status = Status . lent ; Transfer ( 0x0 , loan . lender , index ) ; activeLoans += 1 ; lendersBalance [ loan . lender ] += 1 ; if ( loan . cancelableAt > 0 ) internalAddInterest ( loan , safeAdd ( block . timestamp , loan . cancelableAt ) ) ; require ( rcn . transferFrom ( msg . sender , loan . borrower , safeMult ( loan . amount , getRate ( loan , oracleData ) ) ) ) ; if ( cosigner != address ( 0 ) ) { loan . cosigner = address ( uint256 ( cosigner ) + 2 ) ; require ( cosigner . requestCosign ( this , index , cosignerData , oracleData ) ) ; require ( loan . cosigner == address ( cosigner ) ) ; } Lent ( index , loan . lender , cosigner ) ; return true ; }
","Performs the lend of the RCN equivalent to the requested amount , and transforms the msg.sender in the new lender .
"
"function remove ( MapStorage storage self , address _key ) public returns ( bool ) { require ( _key != address ( 0 ) ) ; if ( ! exist ( self , _key ) ) { return false ; } uint currentIndex = self . addressToIndex [ _key ] ; uint lastIndex = SafeMath . sub ( self . addresses . length , 1 ) ; address lastAddress = self . addresses [ lastIndex ] ; self . addressToIndex [ lastAddress ] = currentIndex ; self . addresses [ currentIndex ] = lastAddress ; delete self . addresses [ lastIndex ] ; delete self . addressToIndex [ _key ] ; self . addresses . length -- ; return true ; }
","Removes the given address from the storage .
"
"function slash ( bytes32 _guiltyOrderID ) external onlySlasher { require ( orderDetails [ _guiltyOrderID ] . settlementID == RENEX_ATOMIC_SETTLEMENT_ID , ""slashing non-atomic trade"" ) ; bytes32 innocentOrderID = orderbookContract . orderMatch ( _guiltyOrderID ) ; require ( orderStatus [ _guiltyOrderID ] == OrderStatus . Settled , ""invalid order status"" ) ; require ( orderStatus [ innocentOrderID ] == OrderStatus . Settled , ""invalid order status"" ) ; orderStatus [ _guiltyOrderID ] = OrderStatus . Slashed ; ( bytes32 buyID , bytes32 sellID ) = isBuyOrder ( _guiltyOrderID ) ? ( _guiltyOrderID , innocentOrderID ) : ( innocentOrderID , _guiltyOrderID ) ; TokenPair memory tokens = getTokenDetails ( orderDetails [ buyID ] . tokens ) ; SettlementDetails memory settlementDetails = calculateAtomicFees ( buyID , sellID , tokens ) ; renExBalancesContract . transferBalanceWithFee ( orderbookContract . orderTrader ( _guiltyOrderID ) , orderbookContract . orderTrader ( innocentOrderID ) , settlementDetails . leftTokenAddress , settlementDetails . leftTokenFee , 0 , 0x0 ) ; renExBalancesContract . transferBalanceWithFee ( orderbookContract . orderTrader ( _guiltyOrderID ) , slasherAddress , settlementDetails . leftTokenAddress , settlementDetails . leftTokenFee , 0 , 0x0 ) ; }
","Slashes the bond of a guilty trader .
"
"function getSecurityTokenData ( address _securityToken ) external view returns ( string , address , string , uint256 ) ;
","Get security token data by its address
"
"function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return _operator == _tokenHolder || balancesDB . getOperator ( _operator , _tokenHolder ) ; }
","Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address at remote database .
"
"function totalSupply ( ) public view returns ( uint ) { return properties . length ; }
","Returns the total number of Properties currently in existence .
"
"function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { if ( orderPrice < sub ( referencePrice , wmul ( RISK_LEVEL , referencePrice ) ) ) { return false ; } return true ; }
","Checks if the takeOrder price is within maximum allowed deviation from reference price
"
"function _address ( uint _holderId ) public view returns ( address ) { return holders [ _holderId ] . addr ; }
","Returns current address for a particular holder id .
"
"function totalSupply ( ) public view returns ( uint256 total ) { return countries . length ; }
","Total amount of country tokens .
"
"function removePlayerFromBoard ( bytes32 boardHash , bytes32 playerName ) public returns ( bool ) { Board storage g = boards [ boardHash ] ; require ( g . boardOwner == msg . sender ) ; uint8 playerID = getPlayerId ( boardHash , playerName , 0 ) ; require ( playerID < 255 ) ; g . players [ playerID ] . isActive = 0 ; return true ; }
","The leaderboard owner can remove a player
"
"function assignTokens ( address _from , address _receiver , uint _tokenAmount ) private { token . transferFrom ( _from , _receiver , _tokenAmount ) ; }
","Transfer issued tokens to the investor .
"
"function updateCounters ( uint256 _etherAmount ) internal { preSaleEtherPaid = preSaleEtherPaid . add ( _etherAmount ) ; totalContributions = totalContributions . add ( 1 ) ; CountersUpdated ( preSaleEtherPaid , _etherAmount ) ; }
","Updates the counters for the amount of Ether paid
"
"function collectionCleared ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bool ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; return collectionTokens [ _collectionIndex ] . length == uint256 ( 0 ) ; }
","Check if collection # ` ( _collectionIndex ) ` has been cleared
"
"function transfer ( address to , uint256 amount , bytes extraData ) external returns ( bool success ) { address _trg = libAddress ; assembly { let m := mload ( 0x20 ) calldatacopy ( m , 0 , calldatasize ) let success := delegatecall ( gas , _trg , m , calldatasize , m , 0x20 ) switch success case 0 { invalid } default { return ( m , 0x20 ) } } }
","Send ` amount ` tokens to ` to ` from ` msg.sender ` and notify the receiver from your transaction with your ` extraData ` data
"
"function missingFundsToEndAuction ( ) constant public returns ( uint ) { uint required_wei_at_price = num_tokens_auctioned * price ( ) / token_multiplier ; if ( required_wei_at_price <= received_wei ) { return 0 ; } return required_wei_at_price - received_wei ; }
","Get the missing funds needed to end the auction , calculated at the current RDN price in WEI .
"
"function burn ( ) external isFinalized { uint256 _balance = balanceOf [ msg . sender ] ; assert ( _balance > 0 ) ; totalSupply = totalSupply . sub ( _balance ) ; balanceOf [ msg . sender ] = 0 ; Burn ( msg . sender , _balance ) ; }
","This function burns all B2BK tokens on the address that caused this function .
"
"function getPrices ( ) public constant returns ( uint256 , uint256 ) { return ( sellPrice , buyPrice ) ; }
","Get the current buy and sell prices
"
"function approve ( address _spender , uint _value ) public returns ( bool ) { if ( _spender != 0x0 ) { return _getAsset ( ) . __approve ( _spender , _value , msg . sender ) ; } }
","Sets asset spending allowance for a specified spender .
"
"function mAdavanceLogicState ( ETOState oldState ) internal constant returns ( ETOState ) ;
","gets called after business logic , may induce state transition
"
"function ownerOf ( uint256 _identifier ) external view returns ( address _owner ) { _owner = gameStates [ gameIndex ] . identifierToOwner [ _identifier ] ; require ( _owner != address ( 0 ) ) ; }
","Returns the address currently assigned ownership of a given deed .
"
"function allowAsset ( address asset , string currency , uint feeBps , uint feeMin , uint feeMax , uint feeFlat ) public onlyOwner notDeprecated returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'allowed.stable.asset' , asset , currency ) ) ; require ( lib . Storage . setBool ( id , true ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; require ( setAssetCurrency ( asset , currency ) , 'Error: Unable to set Currency for asset' ) ; require ( setAssetFeeParams ( asset , feeBps , feeMin , feeMax , feeFlat ) , 'Error: Unable to set fee params for asset' ) ; emit AllowedERC20Asset ( asset , currency ) ; return true ; }
","This method may be deprecated or refactored to allow for multiple interfaces
"
"function createAsset ( uint _attributes , bytes32 _ipfsHash , uint _packId ) internal returns ( uint ) { uint id = numberOfAssets ; require ( isAttributesValid ( _attributes ) , ""Attributes are not valid."" ) ; assets . push ( Asset ( { id : id , packId : _packId , attributes : _attributes , ipfsHash : _ipfsHash } ) ) ; numberOfAssets ++ ; return id ; }
","Function which creates an asset
"
"function assetPrices ( address asset ) public view returns ( uint ) ;
","Gets the price of a given asset
"
"function produce ( uint256 amount ) isPeonyContract returns ( bool ) { require ( totalSupplyLimit == 0 || totalSupply . add ( amount ) <= totalSupplyLimit ) ; balances [ owner ] = balances [ owner ] . add ( amount ) ; totalSupply = totalSupply . add ( amount ) ; return true ; }
","produce ` amount ` of tokens to ` _owner `
"
"function setCloseTime ( uint256 _gameID , uint256 _closeTime ) external isActivated ( _gameID ) isOngoing ( _gameID ) isOwner ( ) { game_ [ _gameID ] . closeTime = _closeTime ; emit onChangeCloseTime ( _gameID , _closeTime , now ) ; }
","Set a closing time for betting .
"
"function spiceUp ( string message ) external payable { require ( gameStarted || ! paused ) ; require ( msg . value > 0 ) ; prizePool = prizePool . add ( msg . value ) ; SpiceUpPrizePool ( msg . sender , msg . value , message , prizePool ) ; }
","Spice up the prize pool .
"
"function description ( ) public view returns ( string ) ;
","A description of what this DAR is used for
"
"function getUpgradeState ( ) public view returns ( UpgradeState ) { if ( ! canUpgrade ( ) ) return UpgradeState . NotAllowed ; else if ( address ( upgradeAgent ) == address ( 0 ) ) return UpgradeState . WaitingForAgent ; else if ( totalUpgraded == 0 ) return UpgradeState . ReadyToUpgrade ; else return UpgradeState . Upgrading ; }
","Get the state of the token upgrade .
"
"function changeFundOwnerWalletAddress ( address _fundOwnerWallet ) public validate_address ( _fundOwnerWallet ) onlyOwner { fundOwnerWallet = _fundOwnerWallet ; }
","Function to change the fund owner wallet address
"
"function getTotalBonusesAmountAvailable ( bytes32 _userKey ) public view returns ( uint _sum ) { uint _startDate = _getCalculationStartDate ( _userKey ) ; Treasury _treasury = Treasury ( treasury ) ; for ( uint _endDate = lastDepositDate ; _startDate <= _endDate && _startDate != 0 ; _startDate = distributionDeposits [ _startDate ] . nextDepositDate ) { Deposit storage _pendingDeposit = distributionDeposits [ _startDate ] ; Balance storage _userBalance = _pendingDeposit . leftToWithdraw [ _userKey ] ; if ( _userBalance . initialized ) { _sum = _sum . add ( _userBalance . left ) ; } else { uint _sharesPercent = _treasury . getSharesPercentForPeriod ( _userKey , _startDate ) ; _sum = _sum . add ( _pendingDeposit . balance . mul ( _sharesPercent ) . div ( PERCENT_PRECISION ) ) ; } } }
","Gets total amount of bonuses user has during all distribution periods
"
"function ( ) public payable onlyWhiteList { uint256 tokensAmount = tokensAmountForPurchase ( ) ; uint256 available = availableTokens ( ) ; uint256 minimum = minimumTokensForPurchase ; require ( tokensAmount <= available ) ; require ( tokensAmount >= minimum ) ; wallet . transfer ( msg . value ) ; leftOnLastMint = available . sub ( tokensAmount ) ; lastMintTime = now ; require ( token . mint ( msg . sender , tokensAmount ) ) ; }
","Purchase function mints tokens
"
"function unlockFirstPrivate ( ) public locked onlyOwner { require ( block . timestamp >= firstPrivateReleaseTime ) ; require ( firstPrivateLockedAmount > 0 ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount >= firstPrivateLockedAmount ) ; token . transfer ( privateLockAddress , firstPrivateLockedAmount ) ; firstPrivateLockedAmount = 0 ; }
","Transfers tokens held by timelock to private .
"
"function newManager ( address newManagerAddress ) public onlyManager { require ( newManagerAddress != 0 ) ; contractManager = newManagerAddress ; emit NewContractManager ( newManagerAddress ) ; }
","Manager set a new manager
"
"function RoundIndex ( ) internal returns ( uint256 ) { uint256 index = 0 ; for ( uint256 r = 0 ; r < rounds . length ; r ++ ) { if ( ( rounds [ r ] . start < uint256 ( block . timestamp ) ) && ( uint256 ( block . timestamp ) < rounds [ r ] . end ) ) { index = r . add ( 1 ) ; } } return index ; }
","Return current round according to current time
"
"function checkPreIcoStatus ( ) internal { if ( tokenBalanceOf [ this ] <= _totalSupply - preIcoLimit ) { preIcoIsRunning = false ; preIcoEnded ( preIcoLimit , ""Token amount for preICO sold!"" ) ; } }
","Check if preICO is ended
"
"function totalSupply ( ) external view returns ( uint256 ) { return cuties . length - 1 ; }
","Returns the total number of Cuties in existence .
"
"function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _data , bytes _operatorData ) internal { callSender ( _operator , _tokenHolder , 0x0 , _amount , _data , _operatorData ) ; requireMultiple ( _amount ) ; require ( balanceOf ( _tokenHolder ) >= _amount , ""Not enough funds"" ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; emit Burned ( _operator , _tokenHolder , _amount , _data , _operatorData ) ; }
","Helper function actually performing the burning of tokens .
"
"function withdrawERC20 ( address _token ) external whenNotPaused onlyAdmin { IERC20 erc20 = IERC20 ( _token ) ; uint256 balance = erc20 . balanceOf ( this ) ; erc20 . safeTransfer ( msg . sender , balance ) ; }
","Enables admins to withdraw accidentally sent ERC20 token to the contract .
"
"function setTxStatus ( Data storage self , bytes32 txHash ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'tx.status' , txHash ) ) ; require ( ! getTxStatus ( self , txHash ) , ""Error: Transaction status must be false before setting the transaction status."" ) ; require ( self . Storage . setBool ( id , true ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; return true ; }
","Set transaction status if the transaction has been used
"
"function adminRescueFunds ( ) external onlyOwner whenPaused { address payee = owner ; uint256 payment = address ( this ) . balance ; payee . transfer ( payment ) ; }
","Allows admin to withdraw contract balance in emergency .
"
"function applySettings ( uint256 minDepositAmountEurUlps , uint256 minWithdrawAmountEurUlps , uint256 maxSimpleExchangeAllowanceEurUlps ) public only ( ROLE_EURT_LEGAL_MANAGER ) { applySettingsPrivate ( minDepositAmountEurUlps , minWithdrawAmountEurUlps , maxSimpleExchangeAllowanceEurUlps ) ; }
","sets limits and whitelists contracts from universe
"
"function isAllowedAddress ( address _address ) onlyAllowedAddresses public constant returns ( bool ) { return allowedAddresses [ _address ] ; }
","Check that address is allowed to interact with functions .
"
"function timeoutResolve ( bytes32 msigId , uint amount ) public { require ( hashIdToMultisig [ msigId ] . deposit >= amount ) ; require ( now >= hashIdToMultisig [ msigId ] . unlockTime ) ; spendFromMultisig ( msigId , amount , hashIdToMultisig [ msigId ] . owner ) ; }
","Withdraw ether and delete the htlc swap .
"
"function setTokenFeePercent ( uint256 percent ) public onlyOwner { require ( percent <= 100000000000000000000 , ""Percent must be between 0 and 100."" ) ; tokenFeePercent = percent ; }
","Set the percent fee applied to tokens that are transferred .
"
"function transferFrom ( address from , address to , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ from ] == 0 || value <= transferableHavvens ( from ) ) ; _transferFrom_byProxy ( sender , from , to , value ) ; return true ; }
","ERC20 transferFrom function .
"
"function addDistributionSources ( address [ ] _whitelist ) external onlyContractOwner returns ( uint ) { for ( uint _idx = 0 ; _idx < _whitelist . length ; ++ _idx ) { distributionSourcesList [ _whitelist [ _idx ] ] = true ; } return OK ; }
","Add distribution sources to whitelist .
"
"function cancelPayment ( uint _idPayment ) onlyContractOwner { if ( _idPayment >= authorizedPayments . length ) throw ; Payment p = authorizedPayments [ _idPayment ] ; if ( p . canceled ) throw ; if ( p . paid ) throw ; p . canceled = true ; PaymentCanceled ( _idPayment ) ; }
","` onlyOwner ` Cancel a payment all together
"
"function setMarginSpend ( uint256 _marginSpend ) external onlyOwner returns ( bool ) { emit SetMarginSpend ( marginSpend , _marginSpend ) ; marginSpend = _marginSpend ; return true ; }
","Sets how much the converter ramp is going to oversell to cover fees and gaps
"
"function decApprove ( address _from , address _spender , uint _value ) external onlyModule returns ( bool ) { allowed [ _from ] [ _spender ] = allowed [ _from ] [ _spender ] . sub ( _value ) ; return true ; }
","Decrease allowance of ` _spender ` in behalf of ` _from ` at ` _value `
"
"function createDividendWithCheckpoint ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 _checkpointId ) payable public onlyOwner { require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( _checkpointId <= ISecurityToken ( securityToken ) . currentCheckpointId ( ) ) ; uint256 dividendIndex = dividends . length ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupplyAt ( _checkpointId ) ; require ( ERC20 ( _token ) . transferFrom ( msg . sender , address ( this ) , _amount ) , ""Unable to transfer tokens for dividend"" ) ; dividends . push ( Dividend ( _checkpointId , now , _maturity , _expiry , _token , _amount , 0 , currentSupply , false ) ) ; emit ERC20DividendDeposited ( msg . sender , _checkpointId , now , _maturity , _expiry , _token , _amount , currentSupply , dividendIndex ) ; }
","Creates a dividend with a provided checkpoint
"
"function tryTransitionAccountingPeriod ( uint64 _maxTransitions ) public isInitialized returns ( bool success ) { return _tryTransitionAccountingPeriod ( _maxTransitions ) ; }
","Transition accounting period if needed
"
"function redeemToken ( uint256 _tokens ) returns ( bool success ) { if ( this . balance < totalSupply ) { throw ; } if ( _tokens == 0 ) { throw ; } if ( balances [ msg . sender ] >= _tokens && totalSupply >= _tokens ) { balances [ msg . sender ] -= _tokens ; totalSupply -= _tokens ; if ( msg . sender . send ( _tokens ) ) { LogRedeemToken ( msg . sender , _tokens ) ; return true ; } else { throw ; } } else { throw ; } }
","Converts token quantity defined by '_token ' into ether and sends back to msg.sender
"
"function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) , ""0x address is invalid"" ) ; IERC20 token = IERC20 ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( owner ( ) , balance ) , ""token transfer failed"" ) ; }
","Reclaims all ERC20Basic compatible tokens
"
"function getBlockOwner ( uint8 x , uint8 y ) external view returns ( address ) { return ownerOf ( blockID ( x , y ) ) ; }
","get an owner ( address ) of block at a specified coordinates
"
"function revokeVesting ( address _holder , uint256 _vestingId ) external authP ( REVOKE_VESTINGS_ROLE , arr ( _holder ) ) vestingExists ( _holder , _vestingId ) { TokenVesting storage v = vestings [ _holder ] [ _vestingId ] ; require ( v . revokable , ERROR_VESTING_NOT_REVOKABLE ) ; uint256 nonVested = _calculateNonVestedTokens ( v . amount , getTimestamp64 ( ) , v . start , v . cliff , v . vesting ) ; delete vestings [ _holder ] [ _vestingId ] ; require ( token . transferFrom ( _holder , address ( this ) , nonVested ) , ERROR_REVOKE_TRANSFER_FROM_REVERTED ) ; emit RevokeVesting ( _holder , _vestingId , nonVested ) ; }
","Revoke vesting # ` _vestingId ` from ` _holder ` , returning unvested tokens to the Token Manager
"
"function getTickersByOwner ( address _owner ) external view returns ( bytes32 [ ] ) ;
","Used to get the ticker list as per the owner
"
"function getBoardByHash ( bytes32 boardHash ) constant public returns ( bytes32 , string , uint ) { return ( boards [ boardHash ] . boardName , boards [ boardHash ] . boardDescription , boards [ boardHash ] . numPlayers ) ; }
","Get the metadata of a leaderboard
"
"function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = false ; } else { mAuthorized [ _operator ] [ msg . sender ] = true ; } AuthorizedOperator ( _operator , msg . sender ) ; }
","Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .
"
"function lastRateUpdateTimeForCurrency ( bytes4 currencyKey ) public view returns ( uint ) { return lastRateUpdateTimes [ currencyKey ] ; }
","Retrieve a list of last update times for specific currencies
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function requestAudit ( address _auditor , bytes32 _codeHash , uint _auditTime ) public whenNotPaused payable { require ( _auditor != 0x0 ) ; require ( _auditTime >= MIN_AUDIT_TIME ) ; require ( _auditTime <= MAX_AUDIT_TIME ) ; require ( msg . value > 0 ) ; bytes32 hashAuditorCode = keccak256 ( _auditor , _codeHash ) ; uint8 outcome = auditOutcomes [ hashAuditorCode ] ; require ( outcome == NOT_AUDITED ) ; uint currentReward = rewards [ hashAuditorCode ] ; uint expireDate = now . add ( _auditTime ) ; rewards [ hashAuditorCode ] = currentReward . add ( msg . value ) ; totalRequestsAmount = totalRequestsAmount . add ( msg . value ) ; bytes32 hashAuditorRequestorCode = keccak256 ( _auditor , msg . sender , _codeHash ) ; AuditRequest storage request = auditRequests [ hashAuditorRequestorCode ] ; if ( request . amount == 0 ) { auditRequests [ hashAuditorRequestorCode ] = AuditRequest ( { amount : msg . value , expireDate : expireDate } ) ; emit AuditRequested ( _auditor , msg . sender , _codeHash , msg . value , expireDate ) ; } else { request . amount = request . amount . add ( msg . value ) ; if ( expireDate > request . expireDate ) request . expireDate = expireDate ; emit AuditRequested ( _auditor , msg . sender , _codeHash , request . amount , request . expireDate ) ; } }
","registers an audit request
"
"function lock ( ) external onlyOwner vaultLoading { require ( tokensAllocated == tokensToBeAllocated , ""Expected to allocate all tokens"" ) ; require ( token . balanceOf ( address ( this ) ) == tokensAllocated , ""Vault must own enough tokens to distribute"" ) ; lockedAt = block . timestamp ; emit Locked ( ) ; }
","Finalize setting of allocations and begin the lock up ( vesting ) period .
"
"function distributeICOTokens ( address _buyer , uint tokens ) external onlyCrowdsale whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( tokensDistributedCrowdsale < limitCrowdsale ) ; require ( tokensDistributedCrowdsale . add ( tokens ) <= limitCrowdsale ) ; tokensDistributedCrowdsale = tokensDistributedCrowdsale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
","Distributes the ICO tokens .
"
"function finalize ( ) public initialized onlyOwner { require ( finalizedBlock == 0 ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; uint256 percentageToTeam = percent ( 18 ) ; uint256 percentageToReserve = percent ( 8 ) ; uint256 percentageToBounties = percent ( 13 ) ; uint256 percentageToAirdrop = percent ( 2 ) ; uint256 percentageToAdvisors = percent ( 7 ) ; uint256 percentageToEarlyInvestors = percent ( 2 ) ; assert ( token . generateTokens ( destTokensBounties , maxSupply . mul ( percentageToBounties ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensReserve , maxSupply . mul ( percentageToReserve ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensTeam , maxSupply . mul ( percentageToTeam ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensAirdrop , maxSupply . mul ( percentageToAirdrop ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensAdvisors , maxSupply . mul ( percentageToAdvisors ) . div ( percent ( 100 ) ) ) ) ; assert ( token . generateTokens ( destTokensEarlyInvestors , maxSupply . mul ( percentageToEarlyInvestors ) . div ( percent ( 100 ) ) ) ) ; Finalized ( ) ; }
","This method will can be called by the owner before the contribution period end or by anybody after the ` endBlock ` .
"
"function removeExternalContributor ( address _contributor ) public onlyOwner { externalContributionAgents [ _contributor ] = false ; }
","update external contributor
"
"function findBestRate ( ERC20 src , ERC20 dest , uint srcAmount ) public view returns ( uint obsolete , uint rate ) { BestRateResult memory result = findBestRateTokenToToken ( src , dest , srcAmount ) ; return ( 0 , result . rate ) ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function freezeAccount ( address target , bool freeze ) onlyOwner { frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }
","` freeze ?
"
"function approveFlower ( address _spender , uint256 _value ) public returns ( bool success ) ;
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function contribute ( ) public notFinished payable { require ( whiteList [ msg . sender ] == true ) ; uint256 tokenBought = msg . value . mul ( rate ) ; require ( tokenBought >= 150000 * ( 10 ** 18 ) ) ; totalRaised = totalRaised . add ( msg . value ) ; totalDistributed = totalDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; emit LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; emit LogContributorsPayout ( msg . sender , tokenBought ) ; }
","contribution handler
"
"function getPolitician ( uint256 _tokenId ) public view returns ( string politicianName , uint256 sellingPrice , address owner ) { Politician storage politician = politicians [ _tokenId ] ; politicianName = politician . name ; sellingPrice = politicianIndexToPrice [ _tokenId ] ; owner = politicianIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific politician .
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( withdrawalRequests [ _from ] . sinceBlock > 0 ) throw ; if ( withdrawalRequests [ _to ] . sinceBlock > 0 ) throw ; if ( balanceOf [ _from ] < _value ) throw ; if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function finalizeSingleInvestor ( address investorAddr ) public onlyOwner mustBeAtStage ( Stage . Finished ) { require ( investorAddr != address ( 0 ) && investorAddr != address ( this ) ) ; require ( balancesToken [ investorAddr ] > 0 ) ; require ( isWhitelisted [ investorAddr ] == true ) ; uint256 balanceToTransfer = balancesToken [ investorAddr ] ; balancesToken [ investorAddr ] = 0 ; isWhitelisted [ investorAddr ] = false ; require ( token . transfer ( investorAddr , balanceToTransfer ) ) ; tokensFinalized = tokensFinalized . add ( balanceToTransfer ) ; assert ( tokensFinalized <= MAX_TOKENS ) ; }
","This is mainly an helper function to ` finalize ` but can be used if ` finalize ` has issues with the loop
"
"function multiTransfer ( address [ ] _to , uint256 [ ] _value ) returns ( bool success ) { }
","send a set of token to different address
"
"function balanceOf ( address _owner ) public view returns ( uint ) { return chronoBankPlatform . balanceOf ( _owner , smbl ) ; }
","Returns asset balance for a particular holder .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external isValidToken ( _tokenId ) onlyOwnerOf ( _tokenId ) payable { address owner = IndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) && owner == _from ) ; require ( _to != address ( 0 ) ) ; _transfer ( _from , _to , _tokenId ) ; }
","Transfers the ownership of a rare item from one address to another address
"
"function earlyResolve ( bytes32 msigId , uint amount , bytes sig ) public { require ( multisigs [ msigId ] . owner == msg . sender || multisigs [ msigId ] . authority == msg . sender ) ; address otherAuthority = multisigs [ msigId ] . owner == msg . sender ? multisigs [ msigId ] . authority : multisigs [ msigId ] . owner ; require ( otherAuthority == msigId . recover ( sig ) ) ; spendFromMultisig ( msigId , amount , multisigs [ msigId ] . owner ) ; }
","Withdraw ether from the multisig .
"
"function collect ( ) public { uint256 finalizedBlock = statusContribution . finalizedBlock ( ) ; require ( finalizedBlock != 0 ) ; require ( getBlockNumber ( ) > finalizedBlock ) ; uint256 total = totalCollected . add ( snt . balanceOf ( address ( this ) ) ) ; uint256 balance = sgt . balanceOfAt ( msg . sender , finalizedBlock ) ; uint256 amount = total . mul ( balance ) . div ( sgt . totalSupplyAt ( finalizedBlock ) ) ; amount = amount . sub ( collected [ msg . sender ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( snt . transfer ( msg . sender , amount ) ) ; TokensCollected ( msg . sender , amount ) ; }
","This method should be called by the SGT holders to collect their corresponding SNTs
"
"function sell ( uint256 amount ) public { require ( address ( this ) . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
","Sell ` amount ` tokens to contract
"
"function changeWhitelister ( address _newWhitelister ) public onlyWhitelister addressNotZero ( _newWhitelister ) { emit WhitelisterChanged ( whitelister , _newWhitelister ) ; whitelister = _newWhitelister ; }
","Changes the current whitelister .
"
"function ( ) payable { require ( isContract ( controller ) ) ; assert ( Controller ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function setWhitelist ( address [ ] _add , address [ ] _remove , uint256 [ ] _whitelistLimits ) public onlyOwner beforeSale { uint256 i = 0 ; uint8 j = 0 ; if ( _whitelistLimits . length > 0 ) { whitelistDayCount = uint8 ( _whitelistLimits . length ) ; for ( i = 0 ; i < _whitelistLimits . length ; i ++ ) { j = uint8 ( i . add ( 1 ) ) ; if ( whitelistDayMaxStake [ j ] != _whitelistLimits [ i ] ) { whitelistDayMaxStake [ j ] = _whitelistLimits [ i ] ; WhitelistSetDay ( msg . sender , j , _whitelistLimits [ i ] ) ; } } } for ( i = 0 ; i < _add . length ; i ++ ) { require ( _add [ i ] != address ( 0 ) ) ; if ( ! whitelist [ _add [ i ] ] ) { whitelist [ _add [ i ] ] = true ; WhitelistAddressAdded ( msg . sender , _add [ i ] ) ; } } for ( i = 0 ; i < _remove . length ; i ++ ) { require ( _remove [ i ] != address ( 0 ) ) ; if ( whitelist [ _remove [ i ] ] ) { whitelist [ _remove [ i ] ] = false ; WhitelistAddressRemoved ( msg . sender , _remove [ i ] ) ; } } }
","Sets whitelist
"
"function approve ( address _spender , uint _value ) external returns ( bool success ) ;
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function toggleMinting ( ) onlyOwner public { if ( pauseMinting ) { pauseMinting = false ; emit UnPauseMinting ( ) ; } else { pauseMinting = true ; emit PauseMinting ( ) ; } }
","Pause minting
"
"function singlePayout ( address _user , uint256 _amount ) public onlyAdmin returns ( bool paid ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( transferCheck ( owner , _user , _amount ) ) ; if ( ! userRegistered [ _user ] ) { registerUser ( _user ) ; } balances [ _user ] = balances [ _user ] . add ( _amount ) ; balances [ owner ] = balances [ owner ] . add ( _amount ) ; Transfer ( owner , _user , _amount ) ; return true ; }
","Manual payout for site users
"
"function setReachCapped ( ) public onlyOwnerOrCoOwner { isCapped = true ; }
","Owner must release all sale smart contracts
"
"function calculateToFund ( address _beneficiary , uint256 _weiAmount ) internal view returns ( uint256 ) { uint256 toFund ; uint256 postWeiRaised = weiRaised . add ( _weiAmount ) ; if ( postWeiRaised > cap ) { toFund = cap . sub ( weiRaised ) ; } else { toFund = _weiAmount ; } return toFund ; }
","calculate fund wrt sale cap .
"
"function transferFrom ( address from , address to , uint amount ) public notDeprecated returns ( bool success ) { address feeContract = lib . getFeeContract ( address ( this ) ) ; string memory currency = lib . getTokenSymbol ( address ( this ) ) ; uint fees = calculateFees ( amount ) ; require ( lib . forceTransfer ( currency , from , to , amount , ""0x0"" ) , ""Error: Unable to transfer funds. Please check your parameters and ensure the spender has the approved amount of funds to transfer."" ) ; require ( lib . forceTransfer ( currency , from , feeContract , fees , lib . getFeeMsg ( feeContract ) ) , ""Error: Unable to transfer funds. Please check your parameters and ensure the spender has the approved amount of funds to transfer."" ) ; require ( lib . updateAllowance ( lib . getTokenSymbol ( address ( this ) ) , from , amount . add ( fees ) ) , ""Error: Unable to update allowance for spender."" ) ; emit Transfer ( from , to , amount ) ; return true ; }
","spender transfers from approvers account to the reciving account
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 cutieId ) { uint40 count = 0 ; for ( uint40 i = 1 ; i <= _totalSupply ( ) ; ++ i ) { if ( cutieIndexToOwner [ i ] == _owner ) { if ( count == _index ) { return i ; } else { count ++ ; } } } revert ( ) ; }
","Returns the nth Cutie assigned to an address , with n specified by the _index argument .
"
"function changeOwner ( address _newOwner ) public validate_address ( _newOwner ) onlyOwner { require ( _newOwner != owner ) ; owner = _newOwner ; }
","only the owner is allowed to change the owner .
"
"function escapeHatch ( ) onlyEscapeHatchCallerOrOwner { uint total = this . balance ; if ( ! escapeHatchDestination . send ( total ) ) { throw ; } EscapeHatchCalled ( total ) ; }
","The ` escapeHatch ( ) ` should only be called as a last resort if a security issue is uncovered or something unexpected happened
"
"function setCampaignStartDateById ( bytes32 bidId , uint newStartDate ) public onlyIfCampaignExists ( ""setCampaignStartDateById"" , bidId ) onlyIfWhitelisted ( ""setCampaignStartDateById"" , msg . sender ) { campaigns [ bidId ] . setStartDate ( newStartDate ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
","Set a new start date for a campaign Based of the Campaign id , updates the start date of a campaign .
"
"function hasHardCap ( ) constant internal returns ( bool ) { return getMaximumFunds ( ) != 0 ; }
","whether to apply hard cap check logic via getMaximumFunds ( ) method
"
"function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , getBlockNumber ( ) ) ; if ( curTotalSupply + _amount < curTotalSupply ) throw ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; var previousBalanceTo = balanceOf ( _owner ) ; if ( previousBalanceTo + _amount < previousBalanceTo ) throw ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function createCampaign ( string packageName , uint [ 3 ] countries , uint [ ] vercodes , uint price , uint budget , uint startDate , uint endDate , string endPoint ) external { CampaignLibrary . Campaign memory newCampaign = _generateCampaign ( packageName , countries , vercodes , price , budget , startDate , endDate ) ; if ( newCampaign . owner == 0x0 ) { return ; } _getBidIdList ( ) . push ( newCampaign . bidId ) ; ExtendedAdvertisementStorage ( address ( _getStorage ( ) ) ) . setCampaign ( newCampaign . bidId , newCampaign . price , newCampaign . budget , newCampaign . startDate , newCampaign . endDate , newCampaign . valid , newCampaign . owner , endPoint ) ; emit CampaignInformation ( newCampaign . bidId , newCampaign . owner , """" , packageName , countries , vercodes , endPoint ) ; }
","Creates an extebded campaign Method to create an extended campaign of user aquisition for a certain application .
"
"function getLockedUserDeposits ( bytes32 _userKey ) public view returns ( uint [ ] _lockupDates , uint [ ] _deposits ) { LockedDeposits storage _lockedDeposits = user2lockedDeposits [ _userKey ] ; uint _lockedDepositsCounter = _lockedDeposits . counter ; _lockupDates = new uint [ ] ( _lockedDepositsCounter ) ; _deposits = new uint [ ] ( _lockedDepositsCounter ) ; uint _pointer = 0 ; for ( uint _idx = 1 ; _idx < _lockedDepositsCounter ; ++ _idx ) { uint _lockDate = _lockedDeposits . index2Date [ _idx ] ; if ( _lockDate > now ) { _lockupDates [ _pointer ] = _lockDate ; _deposits [ _pointer ] = _lockedDeposits . date2deposit [ _lockDate ] ; ++ _pointer ; } } }
","Gets list of locked up deposits with dates when they will be available to withdraw
"
"function ( ) public payable { require ( msg . sender == address ( weth ) || msg . sender == totlePrimary ) ; }
","payable fallback to allow the exchange to return ether directly to this contract
"
"function commit ( uint256 _value ) public returns ( uint256 commitmentValue ) { require ( 0 < _value ) ; require ( _value <= balances [ msg . sender ] ) ; commitmentValue = _value ; uint256 prevCommit = miners [ msg . sender ] . value ; if ( 0 < prevCommit ) { uint256 prevReward ; ( prevReward , prevCommit ) = withdraw ( ) ; commitmentValue = prevReward . add ( prevCommit ) . add ( _value ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( commitmentValue ) ; emit Transfer ( msg . sender , address ( 0 ) , commitmentValue ) ; totalStake_ = totalStake_ . add ( commitmentValue ) ; miners [ msg . sender ] = Commitment ( commitmentValue , block . number , totalStake_ , blockReward_ ) ; emit Commit ( msg . sender , commitmentValue , totalStake_ , blockReward_ ) ; return commitmentValue ; }
","the _value will be substructed from user balance and added to the stake .
"
"function paymentRegularTokens ( uint256 _regularTokenAmount , uint256 _rewardPercentageIndex ) public validAmount ( _regularTokenAmount ) isValidRewardIndex ( _rewardPercentageIndex ) senderHasEnoughTokens ( _regularTokenAmount , 0 ) isWhitelisted ( msg . sender ) whenNotPaused { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _regularTokenAmount ) ; uint256 rewardAmount = getRewardToken ( _regularTokenAmount , _rewardPercentageIndex ) ; rewardBalances [ msg . sender ] = rewardBalances [ msg . sender ] . add ( rewardAmount ) ; emit TransferReward ( owner , msg . sender , rewardAmount ) ; balances [ owner ] = balances [ owner ] . add ( _regularTokenAmount . sub ( rewardAmount ) ) ; emit Transfer ( msg . sender , owner , _regularTokenAmount . sub ( rewardAmount ) ) ; }
","Process a payment using only regular TRVL Tokens with a specified reward percentage .
"
"function changeModuleBudget ( address _module , uint256 _budget ) external ;
","Allows owner to approve more POLY to one of the modules
"
"function createTemplate ( string content ) stateAny ( ) public returns ( uint256 ) { uint256 id = nextTemplateID ; templates [ id ] = block . number ; template_hashes [ id ] = keccak256 ( abi . encodePacked ( content ) ) ; emit LogNewTemplate ( id , msg . sender , content ) ; nextTemplateID = id . add ( 1 ) ; return id ; }
","Create a reusable template , which should be a JSON document .
"
"function updateRate ( uint256 _rate ) external isNotFinalized onlyOwner { rate = _rate ; UpdateRate ( rate ) ; }
","This function updates rates .
"
"function getCar ( uint256 _tokenId ) public view returns ( string carName , uint256 sellingPrice , address owner ) { Car storage car = cars [ _tokenId ] ; carName = car . name ; sellingPrice = carIndexToPrice [ _tokenId ] ; owner = carIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific car .
"
"function setLiqPrice ( uint wad ) public auth { liquidationPriceWad = wad ; }
","set the target liquidation price for leveraged CDPs created
"
"function calculateTokens ( uint256 _amountOfWei ) public view returns ( uint256 ) { require ( _amountOfWei >= 1 szabo ) ; uint256 tokenBought ; uint256 tokenPrice = price . USD ( 0 ) ; tokenPrice = tokenPrice . mul ( 36 ) ; tokenPrice = tokenPrice . div ( 10 ** 8 ) ; tokenBought = _amountOfWei . div ( tokenPrice ) ; tokenBought = tokenBought . mul ( 10 ** 10 ) ; if ( _amountOfWei >= 10 ether ) { tokenBought = tokenBought . mul ( 123 ) ; tokenBought = tokenBought . div ( 100 ) ; } else if ( _amountOfWei >= 1 ether ) { tokenBought = tokenBought . mul ( 11 ) ; tokenBought = tokenBought . div ( 10 ) ; } return tokenBought ; }
","Function to know how many tokens you will receive at current time
"
"function setIssuanceRatio ( uint _issuanceRatio ) external optionalProxy_onlyOwner { require ( _issuanceRatio <= MAX_ISSUANCE_RATIO , ""New issuance ratio must be less than or equal to MAX_ISSUANCE_RATIO"" ) ; issuanceRatio = _issuanceRatio ; emitIssuanceRatioUpdated ( _issuanceRatio ) ; }
","Set the issuanceRatio for issuance calculations .
"
"function thaw ( ) external onlySale { frozen = false ; }
","Make transfer of tokens available to everyone
"
"function contributorCount ( ) public view returns ( uint ) { return contributors . length ; }
","returns the number of contributors in the list of contributors
"
"function claimJob ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender != job . manager ) ; require ( msg . sender != job . evaluator ) ; require ( job . status == JobStatus . Open ) ; job . worker = msg . sender ; job . status = JobStatus . inProgress ; JobsByWorker [ msg . sender ] . push ( _JobID ) ; emit JobClaimed ( msg . sender , _JobID ) ; }
","this function lets the worker claim the job
"
"function receiveDeposit ( ) payable ;
","Function to allow the contractor making a deposit in wei
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { _transferFrom ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` in behalf of ` _from `
"
"function settle ( bytes32 channelId ) public { require ( canSettle ( channelId ) ) ; PaymentChannel storage channel = channels [ channelId ] ; channel . sender . transfer ( channel . value ) ; delete channels [ channelId ] ; DidSettle ( channelId ) ; }
","Move the money to sender , and close the channel .
"
"function setFee ( uint256 _fee ) external onlyOwner { require ( 0 <= _fee && _fee <= 100000 ) ; fee = _fee ; }
","Update the auction fee .
"
"function revokeAsset ( bytes32 _symbol , uint _value ) public returns ( uint _resultCode ) { TransactionContext memory txContext ; txContext . from = msg . sender ; txContext . fromHolderId = getHolderId ( txContext . from ) ; _resultCode = _revokeAsset ( _symbol , _value , txContext ) ; if ( _resultCode != OK ) { return _emitErrorCode ( _resultCode ) ; } _emitter ( ) . emitRevoke ( _symbol , _value , txContext . from ) ; _proxyTransferEvent ( _value , _symbol , txContext ) ; return OK ; }
","Destroys specified amount of senders asset tokens .
"
"function updateETHPriceInCents ( ) public payable { if ( ! updateRequestExpired ( ) ) { NewOraclizeQuery ( ""Oraclize request fail. Previous one still pending"" ) ; } else if ( oraclize_getPrice ( ""URL"" ) > this . balance ) { NewOraclizeQuery ( ""Oraclize request fail. Not enough ether"" ) ; } else { oraclize_query ( m_ETHPriceUpdateInterval , ""URL"" , ""json(https://api.coinmarketcap.com/v1/ticker/ethereum/?convert=USD).0.price_usd"" , m_callbackGas ) ; m_ETHPriceLastUpdateRequest = getTime ( ) ; NewOraclizeQuery ( ""Oraclize query was sent"" ) ; } }
","Send oraclize query .
"
"function withdrawEther ( uint256 amount ) onlyOwner public { msg . sender . transfer ( amount ) ; }
","Withdraw ` amount ` ether to owner
"
"function attachAsset ( uint256 _tokenId ) public canTransfer ( _tokenId ) { uint256 isAttached = checkIsAttached ( _tokenId ) ; require ( isAttached == 0 ) ; isAttached = 1 ; updateIsAttached ( _tokenId , isAttached ) ; emit AssetUpdated ( _tokenId ) ; }
","Attaches the collectible to our contract
"
"function setRdFee ( uint _feeValue , uint _feeDecimals ) onlyContractOwner external returns ( uint ) { require ( _validFee ( _feeValue , _feeDecimals ) ) ; rdFee = FeeData ( _feeValue , _feeDecimals ) ; return OK ; }
","Setup redemption fee value
"
"function getInterfaceImplementer ( address addr , bytes32 iHash ) public constant returns ( address ) { return interfaces [ addr ] [ iHash ] ; }
","Query if an address implements an interface and thru which contract
"
"function beforeTransfer ( uint64 pledgeManager , uint64 pledgeFrom , uint64 pledgeTo , uint64 context , uint amount ) returns ( uint maxAllowed ) ;
","Plugins are used ( much like web hooks ) to initiate an action upon any donation , delegation , or transfer ; this is an optional feature and allows for extreme customization of the contract .
"
"function requestMortgage ( Engine engine , bytes32 loanIdentifier , uint256 deposit , uint256 landId , TokenConverter tokenConverter ) external returns ( uint256 id ) { return requestMortgageId ( engine , engine . identifierToIndex ( loanIdentifier ) , deposit , landId , tokenConverter ) ; }
","Requests a mortgage with a loan identifier
"
"function cancelPoll ( uint _idPoll ) public { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll storage p = _polls [ _idPoll ] ; require ( ! p . canceled , ""Poll has been canceled already"" ) ; require ( p . endBlock > block . number , ""Only active polls can be canceled"" ) ; if ( p . startBlock < block . number ) { require ( msg . sender == controller , ""Only the controller can cancel the poll"" ) ; } else { require ( p . author == msg . sender , ""Only the owner can cancel the poll"" ) ; } p . canceled = true ; emit PollCanceled ( _idPoll ) ; }
","Cancel an existing poll
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( _to != address ( 0 ) ) ; transferFrom ( _from , _to , _tokenId ) ; if ( _isContract ( _to ) ) { ERC721TokenReceiver receiver = ERC721TokenReceiver ( _to ) ; bytes4 response = receiver . onERC721Received . gas ( 50000 ) ( msg . sender , _from , _tokenId , """" ) ; require ( response == TOKEN_RECEIVED_SIG ) ; } }
","Transfers the ownership of an NFT from one address to another address
"
"function migrate ( uint256 _value ) external { require ( migrationAgent != 0 ) ; require ( _value != 0 ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }
","Migrate tokens to the new token contract .
"
"function totalSupply ( ) public view returns ( uint ) { return ponies . length - 1 ; }
","Returns the total number of Ponies currently in existence .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
","Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
"
"function setFeeAuthority ( address _feeAuthority ) public optionalProxy_onlyOwner { feeAuthority = _feeAuthority ; emitFeeAuthorityUpdated ( _feeAuthority ) ; }
","Set the address of the user/contract responsible for collecting or distributing fees .
"
"function withdrawERC20Token ( address tokenAddress , uint256 tokenAmount ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokenAmount ) ; }
","Permits to withdraw any ERC20 tokens that have been mistakingly sent to this contract
"
"function unpause ( uint256 _newEndDate ) public onlyOwner { require ( _newEndDate >= endTime ) ; super . _unpause ( ) ; endTime = _newEndDate ; }
","unpause ( overridden function )
"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return erc20Impl . allowance ( _owner , _spender ) ; }
","Returns how much ` _spender ` is currently allowed to spend from ` _owner ` 's balance .
"
"function start ( ) public onlyOwner { require ( token != address ( 0 ) ) ; require ( startTime == 0 ) ; startTime = now ; cliff = startTime . add ( CLIFF_DURATION ) ; }
","Start the vesting process .
"
"function getKydy ( uint256 _id ) external view returns ( bool isCreating , bool isReady , uint256 rechargeIndex , uint256 nextActionAt , uint256 synthesizingWithId , uint256 createdTime , uint256 yinId , uint256 yangId , uint256 generation , uint256 genes ) { Kydy storage kyd = kydys [ _id ] ; isCreating = ( kyd . synthesizingWithId != 0 ) ; isReady = ( kyd . rechargeEndBlock <= block . number ) ; rechargeIndex = uint256 ( kyd . rechargeIndex ) ; nextActionAt = uint256 ( kyd . rechargeEndBlock ) ; synthesizingWithId = uint256 ( kyd . synthesizingWithId ) ; createdTime = uint256 ( kyd . createdTime ) ; yinId = uint256 ( kyd . yinId ) ; yangId = uint256 ( kyd . yangId ) ; generation = uint256 ( kyd . generation ) ; genes = kyd . genes ; }
","Returns all info about a given Kydy .
"
"function mint ( address _address , uint _value ) { require ( multiSigAddress == msg . sender ) ; balances [ _address ] = balances [ _address ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; if ( totalSupply > cap ) { revert ( ) ; } LogMint ( _address , _value ) ; Transfer ( address ( 0x0 ) , _address , _value ) ; }
","Mint new token amount .
"
"function revealMulti ( uint256 [ ] _limits , uint256 [ ] _slopeFactors , uint256 [ ] _collectMinimums , bool [ ] _lasts , bytes32 [ ] _salts ) public { require ( _limits . length != 0 && _limits . length == _slopeFactors . length && _limits . length == _collectMinimums . length && _limits . length == _lasts . length && _limits . length == _salts . length ) ; for ( uint256 i = 0 ; i < _limits . length ; i = i . add ( 1 ) ) { revealCurve ( _limits [ i ] , _slopeFactors [ i ] , _collectMinimums [ i ] , _lasts [ i ] , _salts [ i ] ) ; } }
","Reveal multiple curves at once
"
"function removeSpender ( address _spender ) external onlyOwner { _validateAddress ( _spender ) ; delete whitelistedSpenders [ _spender ] ; }
","Removes an address from the set of allowed spenders .
"
"function getOrder ( address who ) public view returns ( uint256 quantity , uint256 price , uint256 expiry ) { TradeOrder memory order = orderBook [ who ] ; return ( order . quantity , order . price , order . expiry ) ; }
","Get the trade order for the specified address .
"
"function getTotalCommission ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _lastIndex = _history . commissionCumulative . length - 1 ; if ( _lastIndex < 0 ) { return 0 ; } return _history . commissionCumulative [ _lastIndex ] ; }
","Returns total amount of commission charged for a given canvas .
"
"function claimTokensByAdmin ( address _user ) onlyAdmin ( 1 ) public { require ( state == State . Successful ) ; uint256 temp = pending [ _user ] ; pending [ _user ] = 0 ; require ( tokenReward . transfer ( _user , temp ) ) ; emit LogContributorsPayout ( _user , temp ) ; }
","Funtion to let admins claim users tokens on behalf of them at the end of ico process
"
"function calcGav ( ) returns ( uint gav ) { address [ ] memory tempOwnedAssets ; tempOwnedAssets = ownedAssets ; delete ownedAssets ; for ( uint i = 0 ; i < tempOwnedAssets . length ; ++ i ) { address ofAsset = tempOwnedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; var ( isRecent , assetPrice , assetDecimals ) = module . pricefeed . getPrice ( ofAsset ) ; if ( ! isRecent ) { revert ( ) ; } gav = add ( gav , mul ( assetHoldings , assetPrice ) / ( 10 ** uint256 ( assetDecimals ) ) ) ; if ( assetHoldings != 0 || ofAsset == address ( QUOTE_ASSET ) || ofAsset == address ( NATIVE_ASSET ) || isInOpenMakeOrder [ ofAsset ] ) { ownedAssets . push ( ofAsset ) ; } else { isInAssetList [ ofAsset ] = false ; } PortfolioContent ( assetHoldings , assetPrice , assetDecimals ) ; } }
","Calculates gross asset value of the fund
"
"function adjustCheckpoints ( Checkpoint [ ] storage _checkpoints , uint256 _newValue ) internal { if ( currentCheckpointId == 0 ) { return ; } if ( _checkpoints . length == 0 ) { _checkpoints . push ( Checkpoint ( { checkpointId : currentCheckpointId , value : _newValue } ) ) ; return ; } if ( _checkpoints [ _checkpoints . length - 1 ] . checkpointId == currentCheckpointId ) { return ; } _checkpoints . push ( Checkpoint ( { checkpointId : currentCheckpointId , value : _newValue } ) ) ; }
","store the changes to the checkpoint objects
"
"function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) ) ; ERC20Basic token = ERC20Basic ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( msg . sender , balance ) ) ; }
","Reclaim ERC20Basic compatible tokens
"
"function decreaseApproval ( address spender , uint tokenAmount ) public returns ( bool ) { uint oldValue = allowed [ msg . sender ] [ spender ] ; if ( tokenAmount > oldValue ) { allowed [ msg . sender ] [ spender ] = 0 ; } else { allowed [ msg . sender ] [ spender ] = oldValue . sub ( tokenAmount ) ; } emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
","Decrease the amount of tokens that an owner allowed to a spender .
"
"function setHavven ( Havven _havven ) external onlyOwner { havven = _havven ; emit HavvenUpdated ( _havven ) ; }
","Set the Havven contract that the issuance controller uses to issue Havvens .
"
"function arbitrateApproveMilestone ( uint _idMilestone ) onlyArbitrator campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) && ( milestone . status != MilestoneStatus . Completed ) ) throw ; authorizePayment ( _idMilestone ) ; }
","` onlyArbitrator ` Forces a milestone to be paid out as long as it has not been paid or canceled
"
"function getBtcRequestHash ( bytes requestData , bytes payeesPaymentAddress , uint256 expirationDate ) private view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( this , requestData , payeesPaymentAddress , expirationDate ) ) ; }
","Calculates the Keccak-256 hash of a BTC request with specified parameters .
"
"function destroy ( ) onlyContractOwner { suicide ( msg . sender ) ; }
","Only owner can call it
"
"function approve ( address spender , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }
","` msg.sender ` approves ` spender ` to spend ` value ` tokens
"
"function disableWithdrawal ( ) public onlyOwner whenWithdrawalEnabled { withdrawalEnabled = false ; emit WithdrawalDisabled ( owner ) ; }
","disables withdrawals , only callable by the owner when the withdrawals are enabled
"
"function buy ( uint256 identifier ) external payable whenNotPaused { require ( identifierToOwner [ identifier ] != 0x0 ) ; address oldOwner = identifierToOwner [ identifier ] ; uint256 price = identifierToPrice [ identifier ] ; require ( oldOwner != msg . sender ) ; require ( msg . value >= price ) ; uint256 newPrice = nextPrice ( price ) ; identifierToPrice [ identifier ] = newPrice ; _transfer ( oldOwner , msg . sender , identifier ) ; Price ( identifier , newPrice , nextPrice ( newPrice ) ) ; uint256 dividend = price . mul ( dividendPercentage ) . div ( 100000 ) ; uint256 dividendsPaid = _payDividends ( identifier , identifier , dividend , 0 ) ; uint256 fee = calculateFee ( price , dividendsPaid ) ; uint256 oldOwnerWinnings = price . sub ( dividendsPaid ) . sub ( fee ) ; Buy ( oldOwner , msg . sender , identifier , price , oldOwnerWinnings ) ; if ( oldOwner != address ( this ) ) { _sendFunds ( oldOwner , oldOwnerWinnings ) ; } uint256 excess = price - msg . value ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Buy a collectible .
"
"function deployToken ( string _name , string _symbol , uint8 _decimals , string _tokenDetails , address _issuer , bool _divisible , address _polymathRegistry ) public returns ( address ) { address newSecurityTokenAddress = new SecurityToken ( _name , _symbol , _decimals , _divisible ? 1 : uint256 ( 10 ) ** _decimals , _tokenDetails , _polymathRegistry ) ; if ( addTransferManager ) { SecurityToken ( newSecurityTokenAddress ) . addModule ( transferManagerFactory , """" , 0 , 0 ) ; } SecurityToken ( newSecurityTokenAddress ) . transferOwnership ( _issuer ) ; return newSecurityTokenAddress ; }
","deploys the token and adds default modules like permission manager and transfer manager .
"
"function getFee ( address stablecoin ) public view returns ( uint256 ) { return tokenStorage_CD . fees ( stablecoin ) ; }
","Get the fee associated with going from CarbonUSD to a specific WhitelistedToken .
"
"function doReserveTrade ( ERC20 src , uint amount , ERC20 dest , address destAddress , uint expectedDestAmount , KyberReserveInterface reserve , uint conversionRate , bool validate ) internal returns ( bool ) { uint callValue = 0 ; if ( src == dest ) { if ( destAddress != ( address ( this ) ) ) destAddress . transfer ( amount ) ; return true ; } if ( src == ETH_TOKEN_ADDRESS ) { callValue = amount ; } require ( reserve . trade . value ( callValue ) ( src , amount , dest , this , conversionRate , validate ) ) ; if ( destAddress != address ( this ) ) { if ( dest == ETH_TOKEN_ADDRESS ) { destAddress . transfer ( expectedDestAmount ) ; } else { require ( dest . transfer ( destAddress , expectedDestAmount ) ) ; } } return true ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function transfer ( address _to , uint256 _amount ) public whenNotPaused erc20 returns ( bool success ) { doSend ( msg . sender , _to , _amount , """" , msg . sender , """" , false ) ; return true ; }
","ERC20 backwards compatible transfer .
"
"function removeContract ( string _contractName ) external ;
","Remove an existing contract
"
"function isThirdPartyOwner ( address _address ) public view returns ( bool ) { return ownerRoles . hasEqual ( _address , ROLE_THIRDPARTY_OWNER ) ; }
","Checks if an address ` _address ` is one of 3rd party owners ( origin owner is not included )
"
"function changeController ( address _newController ) public onlyOwner { att . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
","The owner of this contract can change the controller of the ATT token Please , be sure that the owner is a trusted agent or 0x0 address .
"
"function removeUserContract ( address _contract ) external returns ( uint ) { return this . removeUserContractFrom ( _contract , msg . sender ) ; }
","Removes a contract from msg.sender association .
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = getBlockNumber ( ) ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function changeSettings ( uint _price_start , uint _price_constant , uint32 _price_exponent ) internal { require ( stage == Stages . AuctionDeployed || stage == Stages . AuctionSetUp ) ; require ( _price_start > 0 ) ; require ( _price_constant > 0 ) ; price_start = _price_start ; price_constant = _price_constant ; price_exponent = _price_exponent ; }
","Set ` _price_start ` , ` _price_constant ` and ` _price_exponent ` as the new starting price , price divisor constant and price divisor exponent .
"
"function symbol ( ) external pure returns ( string _symbol ) ;
","An abbreviated name for NFTs in this contract
"
"function notifyOfArbitrationRequest ( bytes32 question_id , address requester ) onlyArbitrator ( question_id ) stateOpen ( question_id ) external { questions [ question_id ] . is_pending_arbitration = true ; LogNotifyOfArbitrationRequest ( question_id , requester ) ; }
","Notify the contract that the arbitrator has been paid for a question , freezing it pending their decision .
"
"function getExchangeRates ( address [ ] numeratorTokens , address [ ] denominatorTokens ) public constant returns ( uint256 [ ] rateFractions , uint256 [ ] timestamps ) ;
","allows to retreive multiple exchange rates in once call
"
"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( ! _to . isContract ( ) ) ; } }
","Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
"
"function revoke ( bytes32 _operation ) external multiOwnedOperationIsActive ( _operation ) onlyowner { uint ownerIndexBit = makeOwnerBitmapBit ( msg . sender ) ; var pending = m_multiOwnedPending [ _operation ] ; require ( pending . ownersDone & ownerIndexBit > 0 ) ; assertOperationIsConsistent ( _operation ) ; pending . yetNeeded ++ ; pending . ownersDone -= ownerIndexBit ; assertOperationIsConsistent ( _operation ) ; Revoke ( msg . sender , _operation ) ; }
","Revokes a prior confirmation of the given operation
"
"function setBlacklistSpender ( address _who ) public onlyValidator { require ( isPermission ( APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) , ""Blacklist spending not supported by token"" ) ; setUserPermission ( _who , APPROVE_BLACKLISTED_ADDRESS_SPENDER_SIG ) ; emit LogSetBlacklistSpender ( _who ) ; }
","Sets the necessary permissions for a user to spend tokens from a blacklisted account .
"
"function withdraw ( uint32 _open_block_number , uint192 _balance , bytes _balance_msg_sig ) external { require ( _balance > 0 ) ; address sender_address = extractBalanceProofSignature ( msg . sender , _open_block_number , _balance , _balance_msg_sig ) ; bytes32 key = getKey ( sender_address , msg . sender , _open_block_number ) ; require ( channels [ key ] . open_block_number > 0 ) ; require ( closing_requests [ key ] . settle_block_number == 0 ) ; require ( _balance <= channels [ key ] . deposit ) ; require ( withdrawn_balances [ key ] < _balance ) ; uint192 remaining_balance = _balance - withdrawn_balances [ key ] ; withdrawn_balances [ key ] = _balance ; require ( token . transfer ( msg . sender , remaining_balance ) ) ; ChannelWithdraw ( sender_address , msg . sender , _open_block_number , remaining_balance ) ; }
","Allows channel receiver to withdraw tokens .
"
"function getPriceAndTime ( ) view public returns ( uint256 , uint256 ) { return ( POLYUSD , latestUpdate ) ; }
","Returns price and corresponding update time
"
"function increaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F42 ) , _token , _spender , _addedValue , _fee , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by increaseApprovalPreSigned
"
"function issueForEuro ( uint256 euroUlps ) public only ( ROLE_NEUMARK_ISSUER ) acceptAgreement ( msg . sender ) returns ( uint256 ) { require ( _totalEurUlps + euroUlps >= _totalEurUlps ) ; uint256 neumarkUlps = incremental ( _totalEurUlps , euroUlps ) ; _totalEurUlps += euroUlps ; mGenerateTokens ( msg . sender , neumarkUlps ) ; emit LogNeumarksIssued ( msg . sender , euroUlps , neumarkUlps ) ; return neumarkUlps ; }
","issues new Neumarks to msg.sender with reward at current curve position moves curve position by euroUlps callable only by ROLE_NEUMARK_ISSUER
"
"function calcUnclaimedFees ( uint gav ) view returns ( uint managementFee , uint performanceFee , uint unclaimedFees ) { uint timePassed = sub ( now , atLastUnclaimedFeeAllocation . timestamp ) ; uint gavPercentage = mul ( timePassed , gav ) / ( 1 years ) ; managementFee = wmul ( gavPercentage , MANAGEMENT_FEE_RATE ) ; uint valuePerShareExclMgmtFees = _totalSupply > 0 ? calcValuePerShare ( sub ( gav , managementFee ) , _totalSupply ) : toSmallestShareUnit ( 1 ) ; if ( valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation . highWaterMark ) { uint gainInSharePrice = sub ( valuePerShareExclMgmtFees , atLastUnclaimedFeeAllocation . highWaterMark ) ; uint investmentProfits = wmul ( gainInSharePrice , _totalSupply ) ; performanceFee = wmul ( investmentProfits , PERFORMANCE_FEE_RATE ) ; } unclaimedFees = add ( managementFee , performanceFee ) ; }
","Calculates unclaimed fees of the fund manager
"
"function setMaxCollectable ( uint256 _newMaxFees ) external onlyOwner { maxFees = _newMaxFees ; emit UpdateMaxFees ( maxFees ) ; }
","Sets the maximum fees in wei .
"
"function tokenURI ( uint _tokenId ) external view returns ( string ) { require ( exists ( _tokenId ) ) ; return core . getTokenURIs ( _tokenId , tokenIsChamp ) ; }
","A distinct Uniform Resource Identifier ( URI ) for a given asset .
"
"function transferToAddress ( address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = balances [ _to ] + _value ; addUser ( _to ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","Handles transfer to an ECA ( Externally Controlled Account ) , a normal account ~ ERC-223 Proposed Standard
"
"function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function getToken ( uint256 _tokenId ) public view returns ( string tokenName , uint256 sellingPrice , address owner ) { Token storage token = tokens [ _tokenId ] ; tokenName = token . name ; sellingPrice = tokenIndexToPrice [ _tokenId ] ; owner = tokenIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific token .
"
"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { require ( transfersEnabled ) ; require ( ( _amount == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; if ( isContract ( controller ) ) { require ( TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) ; } allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function submitAnswerCommitment ( bytes32 question_id , bytes32 answer_hash , uint256 max_previous , address _answerer ) stateOpen ( question_id ) bondMustDouble ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external payable { bytes32 commitment_id = keccak256 ( abi . encodePacked ( question_id , answer_hash , msg . value ) ) ; address answerer = ( _answerer == NULL_ADDRESS ) ? msg . sender : _answerer ; require ( commitments [ commitment_id ] . reveal_ts == COMMITMENT_NON_EXISTENT , ""commitment must not already exist"" ) ; uint32 commitment_timeout = questions [ question_id ] . timeout / COMMITMENT_TIMEOUT_RATIO ; commitments [ commitment_id ] . reveal_ts = uint32 ( now ) . add ( commitment_timeout ) ; _addAnswerToHistory ( question_id , commitment_id , answerer , msg . value , true ) ; }
","Submit the hash of an answer , laying your claim to that answer if you reveal it in a subsequent transaction .
"
"function transferAnyERC20Token ( address _tokenAddress , uint256 _tokens , address _beneficiary ) public onlyOwner returns ( bool success ) { return ERC20Basic ( _tokenAddress ) . transfer ( _beneficiary , _tokens ) ; }
","Owner can transfer out any accidentally sent ERC20 tokens
"
"function awardMILsTo ( address _to , uint256 _MILs ) public onlyOwner awardsAllowed { award [ _to ] = award [ _to ] . add ( _MILs ) ; totalAwards = totalAwards . add ( _MILs ) ; currentAwards = currentAwards . add ( _MILs ) ; }
","Award MILs to people that will become available after lock-up period ( if funded ) .
"
"function countOfDeeds ( ) public view returns ( uint256 ) { return plots . length ; }
","Returns the total number of deeds currently in existence .
"
"function revokeGrant ( address _holder ) external onlyOwner { Grant memory grant = grants [ _holder ] ; require ( grant . value != 0 ) ; delete grants [ _holder ] ; totalVesting = totalVesting . sub ( grant . value ) ; erc20 . transfer ( owner , grant . value ) ; emit RevokeGrant ( _holder , grant . value ) ; }
","Revoke the grant for the specified address , transfer the tokens to the owner
"
"function _burnForDeposit ( address owner , uint amount ) public onlyTrusted returns ( bool success ) { if ( balances [ owner ] >= amount ) { balances [ owner ] -= amount ; totalOnDeposit += amount ; totalInCirculation -= amount ; return true ; } else { return false ; } }
","used by subscription module to burn token while creating a new deposit .
"
"function convertRate ( Oracle oracle , bytes32 currency , bytes data , uint256 amount ) public returns ( uint256 ) { if ( oracle == address ( 0 ) ) { return amount ; } else { uint256 rate ; uint256 decimals ; ( rate , decimals ) = oracle . getRate ( currency , data ) ; require ( decimals <= MAX_DECIMALS ) ; return ( safeMult ( safeMult ( amount , rate ) , ( 10 ** decimals ) ) ) / PRECISION ; } }
","Converts an amount to RCN using the loan oracle .
"
"function transfer ( address to , uint value ) returns ( bool success ) { require ( balances [ msg . sender ] >= value && value > 0 && ( ! frozenAccount [ msg . sender ] ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; Transfer ( msg . sender , to , value ) ; return true ; }
","Transfer tokens to the beneficiary account
"
"function transferTokenOwnership ( address _newOwner ) external onlyOwner { require ( _newOwner != address ( 0 ) ) ; LittlePhilCoin ( token ) . transferOwnership ( _newOwner ) ; }
","Ownership management
"
"function _registerTrade ( uint32 _canvasId , uint _amount ) internal stateOwned ( _canvasId ) forceOwned ( _canvasId ) returns ( uint commission , uint paintersRewards , uint sellerProfit ) { uint _commission ; uint _rewards ; uint _sellerProfit ; ( _commission , _rewards , _sellerProfit ) = splitTrade ( _amount ) ; FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; _pushCumulative ( _history . commissionCumulative , _commission ) ; _pushCumulative ( _history . rewardsCumulative , _rewards ) ; return ( _commission , _rewards , _sellerProfit ) ; }
","Adds a bid to fee history .
"
"function changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) external ;
","Used to provide/change the permission to the delegate corresponds to the module contract
"
"function getPrice ( ) external view returns ( uint256 ) ;
","Returns price - should throw if not valid
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public erc20 returns ( bool success ) { uint256 allowance = balancesDB . getAllowance ( _from , msg . sender ) ; require ( _amount <= allowance ) ; require ( balancesDB . decApprove ( _from , msg . sender , _amount ) ) ; doSend ( _from , _to , _amount , """" , msg . sender , """" , false ) ; return true ; }
","ERC20 backwards compatible transferFrom using backendDB .
"
"function getPixelAuthor ( uint32 _canvasId , uint32 _pixelIndex ) public view validPixelIndex ( _pixelIndex ) returns ( address ) { return _getCanvas ( _canvasId ) . pixels [ _pixelIndex ] . painter ; }
","Returns the author of given pixel .
"
"function addAssetToOwnedAssets ( address ofAsset ) public pre_cond ( isOwner ( ) || msg . sender == address ( this ) ) { isInOpenMakeOrder [ ofAsset ] = true ; if ( ! isInAssetList [ ofAsset ] ) { ownedAssets . push ( ofAsset ) ; isInAssetList [ ofAsset ] = true ; } }
","Add an asset to the list that this fund owns
"
"function incrementTotalIssuerCount ( ) external onlyAssociatedContract { totalIssuerCount = totalIssuerCount . add ( 1 ) ; }
","Increment the total issuer count
"
"function getBlockNumber ( ) internal view returns ( uint256 ) { return block . number ; }
","This function is overridden by the test Mocks .
"
"function setAmounts ( uint256 mtdAmountInWei , uint256 ethAmountInWei ) isOwner { require ( mtdAmountInWei > 0 ) ; require ( ethAmountInWei > 0 ) ; mtdAmount = mtdAmountInWei ; ethAmount = ethAmountInWei ; updatePrices ( ) ; }
","Set both ethAmount and mtdAmount at the same time
"
"function setBudget ( Campaign storage _campaign , uint _budget ) internal { _campaign . budget = _budget ; }
","Set campaign total budget
"
"function whitelistAddresses ( address [ ] _addresses , bool _status ) public onlyWhitelister { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { address _investorAddress = _addresses [ i ] ; if ( whitelist [ _investorAddress ] != _status ) { whitelist [ _investorAddress ] = _status ; } } }
","interface for founders to whitelist investors
"
"function setTierRates ( uint256 tier1 , uint256 tier2 , uint256 tier3 , uint256 tier4 ) external onlyOwner whenNotPaused beforeStarting { require ( tier1 > 0 && tier2 > 0 && tier3 > 0 && tier4 > 0 ) ; require ( tier1 > tier2 && tier2 > tier3 && tier3 > tier4 ) ; rate = tier1 ; rateTier2 = tier2 ; rateTier3 = tier3 ; rateTier4 = tier4 ; }
","Set 's the rate of tokens per ether for each tier .
"
"function newAppInstance ( bytes32 _appId , address _appBase , bytes _initializePayload , bool _setDefault ) public auth ( APP_MANAGER_ROLE , arr ( KERNEL_APP_BASES_NAMESPACE , _appId ) ) returns ( ERCProxy appProxy ) { _setAppIfNew ( KERNEL_APP_BASES_NAMESPACE , _appId , _appBase ) ; appProxy = newAppProxy ( this , _appId , _initializePayload ) ; if ( _setDefault ) { setApp ( KERNEL_APP_ADDR_NAMESPACE , _appId , appProxy ) ; } }
","Create a new upgradeable instance of ` _appId ` app linked to the Kernel , setting its code to ` _appBase ` .
"
"function exchangePreDGZTokens ( ) stopInEmergency onlyAfterStart public { uint tokenAmount = tokenRewardPreDGZ . allowance ( msg . sender , this ) ; require ( tokenAmount > 0 ) ; require ( tokenRewardPreDGZ . transferFrom ( msg . sender , address ( 0 ) , tokenAmount ) ) ; uint amountSendTokens = tokenAmount * preDGZtoDGZExchangeRate / 100000000 ; preBalanceOf [ msg . sender ] += tokenAmount ; tokenReward . transfer ( msg . sender , amountSendTokens ) ; }
","A method to exchange preDGZ tokens to DGZ tokens .
"
"function burn ( uint256 _value ) public { require ( owner == msg . sender ) ; require ( balanceOf [ msg . sender ] >= _value ) ; require ( _value > 0 ) ; balanceOf [ msg . sender ] = SafeMath . sub ( balanceOf [ msg . sender ] , _value ) ; totalSupply = SafeMath . sub ( totalSupply , _value ) ; emit Burn ( msg . sender , _value ) ; }
","burn ` _value ` token of owner
"
"function userUnlockToken ( uint256 amount ) public returns ( bool res ) { require ( lockedAmount [ msg . sender ] >= amount ) ; require ( now >= lockedTime [ msg . sender ] ) ; lockedAmount [ msg . sender ] -= amount ; balanceOf [ msg . sender ] += amount ; UserUnlock ( amount ) ; return true ; }
","user unlock his/her own token
"
"function getDelegateIdx ( Pledge p , uint64 idDelegate ) internal returns ( uint64 ) { for ( uint i = 0 ; i < p . delegationChain . length ; i ++ ) { if ( p . delegationChain [ i ] == idDelegate ) return uint64 ( i ) ; } return NOTFOUND ; }
","A getter that searches the delegationChain for the level of authority a specific delegate has within a Pledge
"
"function buyBox1 ( ) external payable whenNotPaused returns ( bool ) { require ( isNotContract ( msg . sender ) ) ; require ( box1OnSale ) ; require ( msg . value >= priceBox1 ) ; uint tempVal = uint ( keccak256 ( uint ( msg . sender ) + secretKey + rabbits . length ) ) ; tempVal = tempVal % 10000 ; uint _star = 3 ; if ( tempVal <= box1Star5 ) { _star = 5 ; require ( CREATED_STAR5 < LIMIT_STAR5 ) ; } else if ( tempVal <= box1Star5 + box1Star4 ) { _star = 4 ; require ( CREATED_STAR4 < LIMIT_STAR4 ) ; } _createRabbitInGrade ( _star , msg . sender , 2 ) ; uint fundsExcess = msg . value - priceBox1 ; if ( fundsExcess > 1 finney ) { msg . sender . transfer ( fundsExcess ) ; } return true ; }
","customer buy a box
"
"function getCampaignValidById ( bytes32 bidId ) public view returns ( bool valid ) { return campaigns [ bidId ] . getValidity ( ) ; }
","Get information regarding validity of a campaign .
"
"function batchApprove ( uint256 [ ] _tokenIds , address _spender ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _spender != address ( 0 ) ) ; uint256 _id ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 ) ; _id = _tokenIds [ i ] ; approve ( _spender , _id ) ; } }
","Batch Function to approve the spender
"
"function swapProxyTokens ( ) public { ERC20Token oldToken = ERC20Token ( 0x81BE91c7E74Ad0957B4156F782263e7B0B88cF7b ) ; uint256 oldTokenBalance = oldToken . balanceOf ( msg . sender ) ; require ( oldTokenBalance > 0 ) ; if ( oldToken . transferFrom ( msg . sender , issuingTokenOwner , oldTokenBalance ) ) { require ( oldToken . balanceOf ( msg . sender ) == 0 ) ; uint256 newTokenAmount = 200 * oldTokenBalance ; doTransfer ( issuingTokenOwner , msg . sender , newTokenAmount ) ; SwappedTokens ( msg . sender , oldTokenBalance , newTokenAmount ) ; } }
","This method can be used by users holding old proxy tokens to swap for new tokens at the ratio of 1 : 2 .
"
"function getLowerSTVersionBounds ( ) external view returns ( uint8 [ ] ) { return VersionUtils . unpack ( compatibleSTVersionRange [ ""lowerBound"" ] ) ; }
","Used to get the lower bound
"
"function buyPackWithKitty ( uint256 _kittyId ) external { require ( totalKittiesBurned < KITTY_BURN_LIMIT , ""Stop! Think of the cats!"" ) ; require ( ! hasBurnedKitty [ msg . sender ] , ""You've already burned a kitty."" ) ; totalKittiesBurned ++ ; hasBurnedKitty [ msg . sender ] = true ; kittiesContract . transferFrom ( msg . sender , this , _kittyId ) ; _buyPack ( standardSale ) ; emit KittyBurned ( msg . sender , _kittyId ) ; }
","Magically transform a CryptoKitty into a free pack of cards !
"
"function withdrawVotingRights ( uint _numTokens ) external { uint availableTokens = voteTokenBalance [ msg . sender ] . sub ( getLockedTokens ( msg . sender ) ) ; require ( availableTokens >= _numTokens ) ; voteTokenBalance [ msg . sender ] -= _numTokens ; require ( token . transfer ( msg . sender , _numTokens ) ) ; emit _VotingRightsWithdrawn ( _numTokens , msg . sender ) ; }
","Withdraw _numTokens ERC20 tokens from the voting contract , revoking these voting rights
"
"function changeTickerRegistrationFee ( uint256 _tickerRegFee ) external onlyOwner { uint256 fee = getUint ( TICKERREGFEE ) ; require ( fee != _tickerRegFee , ""Fee not changed"" ) ; emit ChangeTickerRegistrationFee ( fee , _tickerRegFee ) ; set ( TICKERREGFEE , _tickerRegFee ) ; }
","Sets the ticker registration fee in POLY tokens .
"
"function withdrawWinner ( ) external { require ( currentStage == StageName . voteFinished , ""Withdraw disable yet/allready!"" ) ; require ( msg . sender == projects [ keccak256 ( bytes ( currentWinner ) ) ] . prjAddress , ""Only winner can Withdraw reward"" ) ; currentStage = StageName . rewardWithdrawn ; msg . sender . transfer ( address ( this ) . balance ) ; }
","Transfer all ether from contract balance ( reward found ) to winner
"
"function transfer ( address _to , uint256 _value ) public transfersAllowed returns ( bool success ) { return false ; }
","This function is disabled .
"
"function purchaseTokens ( ) payable returns ( uint ) { if ( ( now < startTime ) || ( now > closeTime ) || ( msg . value == 0 ) ) throw ; uint currentPrice ; if ( now < ( startTime + 1 days ) ) { currentPrice = priceDayOne ; } else if ( now < ( startTime + 2 days ) ) { currentPrice = priceDayTwo ; } else if ( now < ( startTime + 12 days ) ) { currentPrice = price - ( ( startTime + 12 days - now ) * price / 100 days ) ; } else { currentPrice = price ; } uint tokens = safeMul ( msg . value , 1 ether ) / currentPrice ; if ( ! token . transferFrom ( owner , msg . sender , tokens ) ) throw ; return tokens ; }
","Used to buy tokens with Ether
"
"function reimbursement ( ) public { claimReimbursement ( msg . sender ) ; }
","Process a reimbursement claim .
"
"function releaseTokensFromEscrow ( uint256 _amount ) external { releaseTokensFromEscrowForUser ( msg . sender , _amount ) ; }
","Release tokens back to payer 's available balance if lockup expires
"
"function createSaleAuction ( uint256 _deedId , uint256 _startPrice , uint256 _endPrice , uint256 _duration ) external whenNotPaused { require ( _owns ( msg . sender , _deedId ) ) ; require ( address ( saleAuctionContract ) != address ( 0 ) ) ; _approve ( msg . sender , address ( saleAuctionContract ) , _deedId ) ; saleAuctionContract . createAuction ( _deedId , _startPrice , _endPrice , _duration ) ; }
","Create a sale auction .
"
"function setRate ( uint256 _rate ) public onlyOwner returns ( bool ) { rate = _rate ; return true ; }
","Change refill rate of bucket
"
"function checkDelegate ( address _potentialDelegate ) external view returns ( bool ) { require ( _potentialDelegate != address ( 0 ) , ""Invalid address"" ) ; if ( delegateDetails [ _potentialDelegate ] != bytes32 ( 0 ) ) { return true ; } else return false ; }
","Used to check if an address is a delegate or not
"
"function appendDecryptedBids ( uint [ ] _nonce , uint [ ] _index , uint [ ] _bid_id , address [ ] _investor_address , uint [ ] _share_price , uint [ ] _shares_count , uint [ ] _transfered_token ) public onlyOwner { require ( _nonce . length == _index . length ) ; require ( _index . length == _bid_id . length ) ; require ( _bid_id . length == _investor_address . length ) ; require ( _investor_address . length == _share_price . length ) ; require ( _share_price . length == _shares_count . length ) ; require ( _shares_count . length == _transfered_token . length ) ; require ( bids_count . sub ( bids_decrypted_count ) > 0 ) ; for ( uint i = 0 ; i < _index . length ; i ++ ) { appendDecryptedBid ( _nonce [ i ] , _index [ i ] , _bid_id [ i ] , _investor_address [ i ] , _share_price [ i ] , _shares_count [ i ] , _transfered_token [ i ] ) ; } }
","Allows appending multiple decrypted bids ( in order ) at once .
"
"function addRewardPercentage ( uint256 _percentage ) public onlyAdmin isValidRewardPercentage ( _percentage ) returns ( uint256 _index ) { _index = rewardPercentage . length ; rewardPercentage . push ( _percentage ) ; emit RewardPercentage ( _index , _percentage ) ; }
","Adds a reward percentage to the list of available reward percentages , specific to 18 decimals .
"
"function transfer ( address _to , uint256 _tokenId ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","Transfers a Property to another address .
"
"function handleAbovePlannedWhitelistedContribution ( uint256 allowedContribution , uint256 plannedContribution , uint256 refundAmount ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( plannedContribution ) ; AllowedContributionCheck ( allowedContribution , AllowedContributionState . AboveWhitelisted ) ; return ( allowedContribution , refundAmount ) ; }
","Returns the contribution and refund value to be used when the transaction value is higher than the whitelisted contribution for the sender .
"
"function unlockInvestor ( address investor ) private { Account memory accountInMem = _accounts [ investor ] ; if ( accountInMem . balance == 0 ) { return ; } removeInvestor ( investor , accountInMem . balance ) ; if ( _lockState == LockState . AcceptingUnlocks ) { require ( NEUMARK . transferFrom ( investor , address ( this ) , accountInMem . neumarksDue ) ) ; NEUMARK . burn ( accountInMem . neumarksDue ) ; if ( currentTime ( ) < accountInMem . unlockDate ) { require ( _penaltyDisbursalAddress != address ( 0 ) ) ; uint256 penalty = decimalFraction ( accountInMem . balance , PENALTY_FRACTION ) ; if ( isContract ( _penaltyDisbursalAddress ) ) { require ( ASSET_TOKEN . approveAndCall ( _penaltyDisbursalAddress , penalty , """" ) ) ; } else { assert ( ASSET_TOKEN . transfer ( _penaltyDisbursalAddress , penalty ) ) ; } emit LogPenaltyDisbursed ( _penaltyDisbursalAddress , penalty , ASSET_TOKEN , investor ) ; accountInMem . balance -= penalty ; } } if ( _lockState == LockState . ReleaseAll ) { accountInMem . neumarksDue = 0 ; } assert ( ASSET_TOKEN . transfer ( investor , accountInMem . balance ) ) ; emit LogFundsUnlocked ( investor , accountInMem . balance , accountInMem . neumarksDue ) ; }
","unlocks 'investor ' tokens by making them withdrawable from assetToken
"
"function buy ( ) public payable { proxyPayment ( msg . sender ) ; }
","Public function to buy tokens
"
"function canVote ( uint _idPoll ) public view returns ( bool ) { if ( _idPoll >= _polls . length ) return false ; Poll storage p = _polls [ _idPoll ] ; uint balance = token . balanceOfAt ( msg . sender , p . startBlock ) ; return block . number >= p . startBlock && block . timestamp < p . endTime && ! p . canceled && balance != 0 ; }
","Determine if user can bote for a poll
"
"function submitProposal ( address _sender , uint _proposalID , uint _amount ) onlyClient { if ( _sender != recipient && _sender != creator ) throw ; proposals [ _proposalID ] . submittedAmount += _amount ; ProposalSubmitted ( msg . sender , _amount ) ; }
","Function used by the client to infor about the submitted amount
"
"function renounceOwnership ( ) public contract_onlyOwner { emit OwnershipRenounced ( _owner ) ; _owner = address ( 0 ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function realitioAnswerFromAugurMarket ( IMarket market ) onlyInitialized public view returns ( bytes32 ) { bytes32 answer ; if ( market . isInvalid ( ) ) { answer = REALITIO_INVALID ; } else { uint256 no_val = market . getWinningPayoutNumerator ( AUGUR_NO_INDEX ) ; uint256 yes_val = market . getWinningPayoutNumerator ( AUGUR_YES_INDEX ) ; if ( yes_val == no_val ) { answer = REALITIO_INVALID ; } else { if ( yes_val > no_val ) { answer = REALITIO_YES ; } else { answer = REALITIO_NO ; } } } return answer ; }
","Get the answer from the Augur market and map it to a Realitio value
"
"function topUpDelegate ( address _sender_address , address _receiver_address , uint32 _open_block_number , uint192 _added_deposit ) isTrustedContract external { updateInternalBalanceStructs ( _sender_address , _receiver_address , _open_block_number , _added_deposit ) ; require ( token . transferFrom ( msg . sender , address ( this ) , _added_deposit ) ) ; }
","Function that allows a delegate contract to increase the channel deposit with ` _added_deposit ` .
"
"function doCancelPayment ( uint _idPayment ) internal { require ( _idPayment < payments . length ) ; Payment storage p = payments [ _idPayment ] ; require ( p . state == PaymentStatus . Pending ) ; p . state = PaymentStatus . Canceled ; liquidPledging . cancelPayment ( uint64 ( p . ref ) , p . amount ) ; CancelPayment ( _idPayment , p . ref ) ; }
","Cancels a pending payment ( internal function )
"
"function setResolver ( address _resolver ) onlyOwner public { resolver = _resolver ; }
","Sets address that resolves hashes for fishing can only be called by the owner
"
"function disableMinting ( ) public onlyMinter { mintingDisabled = true ; emit DisableMinting ( ) ; }
","Disable further minting
"
"function getBool ( bytes32 _key ) internal view returns ( bool ) { return boolStorage [ _key ] ; }
","Get function use to get the value of the singleton state variables Ex1- string public version = `` 0.0.1 '' ; string _version = getString ( keccak256 ( abi.encodePacked ( `` version '' ) ) ; Ex2 - assert ( temp1 == temp2 ) ; replace to assert ( getUint ( keccak256 ( abi.encodePacked ( temp1 ) ) == getUint ( keccak256 ( abi.encodePacked ( temp2 ) ) ; Ex3 - mapping ( string = > SymbolDetails ) registeredSymbols ; where SymbolDetails is the structure having different type of values as { uint256 date , string name , address owner } etc .
"
"function adminSetDetails ( uint32 _devFee , uint32 _priceUpdateInterval , uint32 _startDateRoundValue , uint32 _durationRoundValue , uint64 _maxDuration , uint64 _minDuration , uint256 _maxPrice , uint256 _minPrice ) public onlyAdmin { devFee = _devFee ; priceUpdateInterval = _priceUpdateInterval ; startDateRoundValue = _startDateRoundValue ; durationRoundValue = _durationRoundValue ; maxDuration = _maxDuration ; minDuration = _minDuration ; maxPrice = _maxPrice ; minPrice = _minPrice ; }
","Set the market parameters
"
"function safeTransferFromWithFees ( address token , address from , address to , uint256 amount ) internal returns ( uint256 ) { uint256 balancesBefore = CompatibleERC20 ( token ) . balanceOf ( to ) ; CompatibleERC20 ( token ) . transferFrom ( from , to , amount ) ; require ( previousReturnValue ( ) , ""transferFrom failed"" ) ; uint256 balancesAfter = CompatibleERC20 ( token ) . balanceOf ( to ) ; return Math . min256 ( amount , balancesAfter . sub ( balancesBefore ) ) ; }
","Calls transferFrom on the token , reverts if the call fails and returns the value transferred after fees .
"
"function migrate ( ) public ;
","should migrate state owned by msg.sender
"
"function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
","Restriction : An account can only use this function to send to itself
"
"function updatePlotPrice ( uint256 plotIndex , uint256 newPriceInWeiPerPixel ) external { require ( plotIndex >= 0 ) ; require ( plotIndex < ownership . length ) ; require ( msg . sender == ownership [ plotIndex ] . owner ) ; plotIdToPrice [ plotIndex ] = newPriceInWeiPerPixel ; emit PlotPriceUpdated ( plotIndex , newPriceInWeiPerPixel , msg . sender ) ; }
","Updates the price per pixel of a plot which the message sender owns .
"
"function decimals ( ) external erc20 view returns ( uint8 ) { return uint8 ( 18 ) ; }
","For Backwards compatibility
"
"function setFundingRules ( address _mainPartner , bool _publicCreation , uint _initialPriceMultiplier , uint _maxAmountToFund , uint _minutesFundingPeriod , uint _inflationRate , uint _proposalID ) external ;
","Function to set a funding .
"
"function setBuyRate ( uint256 buyRateInWei ) isOwner { require ( buyRateInWei > 0 ) ; require ( buyRate != buyRateInWei ) ; buyRate = buyRateInWei ; updatePrices ( ) ; }
","Set current Buy Commission price in wei
"
"function updateTreasury ( address _treasury ) external onlyContractOwner returns ( uint ) { require ( _treasury != 0x0 ) ; treasury = _treasury ; return OK ; }
","Sets new treasury address Only for contract owner .
"
"function approve ( address _approved , uint256 _tokenId ) external ;
","The zero address indicates there is no approved address .
"
"function distribute ( uint256 rounds ) external { for ( uint256 i = 0 ; i < rounds ; i ++ ) { if ( address ( this ) . balance < 0.001 ether ) { break ; } fairContract . buy . value ( address ( this ) . balance ) ( 0x0 ) ; fairContract . exit ( ) ; } }
","Distribute dividends to the FairExchange contract .
"
"function getAttributeValue ( address account , uint256 attributeTypeID ) external view returns ( uint256 ) ;
","Retrieve the value of the attribute of the type with ID ` attributeTypeID ` on the account at ` account ` , assuming it is valid .
"
"function getSTFactoryAddress ( ) external view returns ( address ) ;
","Get the current STFactory Address
"
"function adminChange ( address _newAdmin ) public onlyAdmin validAddress ( _newAdmin ) { admin = _newAdmin ; }
","Change the market admin
"
"function addToWhitelist ( address _address ) public onlyWhitelister addressNotZero ( _address ) { emit WhitelistAdd ( whitelister , _address ) ; whitelist [ _address ] = true ; }
","Only callable by the whitelister .
"
"function createLiability ( bytes _demand , bytes _offer ) external returns ( bool ) ;
","Only current provider can call it
"
"function getDog ( uint256 _id ) external view returns ( uint256 cooldownIndex , uint256 nextActionAt , uint256 siringWithId , uint256 birthTime , uint256 matronId , uint256 sireId , uint256 generation , uint256 genes , uint8 variation , uint256 gen0 ) { Dog storage dog = dogs [ _id ] ; cooldownIndex = uint256 ( dog . cooldownIndex ) ; nextActionAt = uint256 ( dog . cooldownEndBlock ) ; siringWithId = uint256 ( dog . siringWithId ) ; birthTime = uint256 ( dog . birthTime ) ; matronId = uint256 ( dog . matronId ) ; sireId = uint256 ( dog . sireId ) ; generation = uint256 ( dog . generation ) ; genes = uint256 ( dog . genes ) ; variation = uint8 ( dog . variation ) ; gen0 = uint256 ( dog . gen0 ) ; }
","Returns all the relevant information about a specific Dog .
"
"function allocate ( ) private { allocations [ 0xab1cb1740344A9280dC502F3B8545248Dc3045eA ] = 4000000 * 1 ether ; allocations [ 0x330709A59Ab2D1E1105683F92c1EE8143955a357 ] = 4000000 * 1 ether ; allocations [ 0xAa0887fc6e8896C4A80Ca3368CFd56D203dB39db ] = 3000000 * 1 ether ; allocations [ 0x1fbA1d22435DD3E7Fa5ba4b449CC550a933E72b3 ] = 200000 * 1 ether ; allocations [ 0xC9d5E2c7e40373ae576a38cD7e62E223C95aBFD4 ] = 200000 * 1 ether ; allocations [ 0xabc0B64a38DE4b767313268F0db54F4cf8816D9C ] = 220000 * 1 ether ; allocations [ 0x5d85bCDe5060C5Bd00DBeDF5E07F43CE3Ccade6f ] = 50000 * 1 ether ; allocations [ 0xecb1b0231CBC0B04015F9e5132C62465C128B578 ] = 500000 * 1 ether ; allocations [ 0xFF22FA2B3e5E21817b02a45Ba693B7aC01485a9C ] = 2955000 * 1 ether ; }
","NTRY Token distribution between team members .
"
"function name ( ) public view returns ( string ) { return ""PixelCons"" ; }
","Get the name of this contract token
"
"function grantPermissionP ( address _entity , address _app , bytes32 _role , uint256 [ ] _params ) onlyPermissionManager ( _app , _role ) public { require ( ! hasPermission ( _entity , _app , _role ) ) ; bytes32 paramsHash = _params . length > 0 ? _saveParams ( _params ) : EMPTY_PARAM_HASH ; _setPermission ( _entity , _app , _role , paramsHash ) ; }
","Grants ` _entity ` the ability to perform actions of role ` _role ` on ` _app `
"
"function getAmountOfUnlockedTokens ( address _tokenOwner ) public returns ( uint ) { uint balanceAvailable = mBalances [ _tokenOwner ] ; if ( mLockedBalances [ _tokenOwner ] . amount != 0 && mLockedBalances [ _tokenOwner ] . timeLockedUntil > block . timestamp ) { balanceAvailable = balanceAvailable . sub ( mLockedBalances [ _tokenOwner ] . amount ) ; } else if ( mLockedBalances [ _tokenOwner ] . amount != 0 && mLockedBalances [ _tokenOwner ] . timeLockedUntil < block . timestamp ) { mLockedBalances [ _tokenOwner ] = lockedTokens ( { amount : 0 , timeLockedUntil : 0 } ) ; } return balanceAvailable ; }
","Helper function that returns the amount of tokens aof an owner minus the amount currently locked
"
"function addAdmin ( address _newAdmin ) external { require ( msg . sender == owner ) ; adminPermission [ _newAdmin ] = true ; }
","Changes state
"
"function __callback ( bytes32 myid , string result ) public closeOrDuringCrowdsale { if ( msg . sender != oraclize_cbAddress ( ) ) revert ( ) ; uint256 usdRate = parseInt ( result , 18 ) ; require ( usdRate > 0 ) ; ethUsd = usdRate ; LogRateUpdate ( ethUsd , now ) ; if ( hasEnded ( ) == true ) { currentStage = Stage . Finished ; } else { updateEthRate ( ) ; lastOracleUpdate = now ; } }
","ETH/USD rate is receivd and converted to wei , this functions is used also to automatically update the stage status
"
"function getTuber ( uint256 _tokenId ) public view returns ( string tuberName , uint256 sellingPrice , address owner ) { Tuber storage tuber = tubers [ _tokenId ] ; tuberName = tuber . name ; sellingPrice = tuberIndexToPrice [ _tokenId ] ; owner = tuberIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific tuber .
"
"function extractBytes32 ( bytes data , uint offset ) internal pure returns ( bytes32 bs ) { require ( offset >= 0 && offset + 32 <= data . length , ""offset value should be in the correct range"" ) ; assembly { bs := mload ( add ( data , add ( 32 , offset ) ) ) } }
","Extract a bytes32 from a bytes .
"
"function distributePresaleTokens ( address _buyer , uint tokens ) external onlyOwner whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( tokensDistributedPresale < 10000000 ) ; tokensDistributedPresale = tokensDistributedPresale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
","Distributes the presale tokens .
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _tokenId ) { require ( _owner != address ( 0 ) ) ; require ( _index < _tokensOfOwnerWithSubstitutions [ _owner ] . length ) ; _tokenId = _tokensOfOwnerWithSubstitutions [ _owner ] [ _index ] ; if ( _owner == address ( this ) ) { if ( _tokenId == 0 ) { _tokenId = _index + 1 ; } } }
","Enumerate NFTs assigned to an owner
"
"function feePool ( ) external view returns ( uint ) { return tokenState . balanceOf ( FEE_ADDRESS ) ; }
","Collected fees sit here until they are distributed .
"
"function proxyPayment ( address _owner ) public payable notPaused returns ( bool success ) { return doPayment ( _owner ) ; }
","` proxyPayment ( ) ` allows the caller to send ether to the TokenSale and have the tokens created in an address of their choosing
"
"function finalizeCampaign ( ) public onlyController { require ( ( campaignState == 1 ) || ( ( campaignState != 0 ) && ( now > tCampaignEnd + ( 2880 minutes ) ) ) ) ; campaignState = 0 ; uint256 drewardTokens = ( tokensGenerated . mul ( PRCT100_D_TEAM ) ) . div ( 10000 ) ; uint256 rrewardTokens = ( tokensGenerated . mul ( PRCT100_R_TEAM ) ) . div ( 10000 ) ; uint256 r2rewardTokens = ( tokensGenerated . mul ( PRCT100_R2 ) ) . div ( 10000 ) ; uint256 mmrewardTokens = FIXEDREWARD_MM ; do_grant_tokens ( dteamVaultAddr1 , drewardTokens ) ; do_grant_tokens ( dteamVaultAddr2 , drewardTokens ) ; do_grant_tokens ( dteamVaultAddr3 , drewardTokens ) ; do_grant_tokens ( dteamVaultAddr4 , drewardTokens ) ; do_grant_tokens ( rteamVaultAddr , rrewardTokens ) ; do_grant_tokens ( r2VaultAddr , r2rewardTokens ) ; do_grant_tokens ( mmVaultAddr , mmrewardTokens ) ; uint256 reserveTokens = hardcap . sub ( tokensGenerated ) ; do_grant_tokens ( reserveVaultAddr , reserveTokens ) ; token . finalize ( ) ; tFinalized = now ; Finalized ( tFinalized ) ; }
","Finalizes the campaign Get funds out , generates team , reserve and reserve tokens
"
"function transfer ( address _to , uint _value ) public { _transfer ( msg . sender , _to , _value ) ; }
","Transfer tokens
"
"function pullDividendPayment ( uint256 _dividendIndex ) public validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; require ( ! dividend . claimed [ msg . sender ] , ""Dividend already claimed"" ) ; require ( ! dividend . dividendExcluded [ msg . sender ] , ""msg.sender excluded from Dividend"" ) ; _payDividend ( msg . sender , dividend , _dividendIndex ) ; }
","Investors can pull their own dividends
"
"function retrieveAll ( ) onlyOwner public { require ( this . balance > 0 ) ; owner . transfer ( this . balance ) ; }
","Retrieve all ether to owner
"
"function setSuccess ( ) external onlyAdmin returns ( bool ) { require ( ! targetReached , ""Access is denied."" ) ; targetReached = true ; emit TargetReached ( ) ; }
","This function signifies that the minimum fundraising target was met.Please note that this can only be called once .
"
"function setUpgradedContractAddress ( address _upgradedContractAddress ) external onlyOwner whenPaused { upgradedContractAddress = _upgradedContractAddress ; ContractUpgrade ( _upgradedContractAddress ) ; }
","Only to be used when this contract is significantly broken , and an upgrade is required .
"
"function getCraftTokenAddress ( uint256 _tokenId ) public view returns ( address masterErc20 ) { masterErc20 = emojiCraftTokenAddress [ _tokenId ] ; }
","Returns all the relevant information about a specific emoji .
"
"function remove ( List storage self , address node ) internal { require ( isInList ( self , node ) , ""not in list"" ) ; if ( node == NULL ) { return ; } address p = self . list [ node ] . previous ; address n = self . list [ node ] . next ; self . list [ p ] . next = n ; self . list [ n ] . previous = p ; self . list [ node ] . inList = false ; delete self . list [ node ] ; }
","Remove a node from the list , and fix the previous and next pointers that are pointing to the removed node .
"
"function rateIsStale ( bytes4 currencyKey ) external view returns ( bool ) { if ( currencyKey == ""sUSD"" ) return false ; return lastRateUpdateTimes [ currencyKey ] . add ( rateStalePeriod ) < now ; }
","Check if a specific currency 's rate has n't been updated for longer than the stale period .
"
"function burn ( uint256 _value ) onlyOwner public returns ( bool success ) { require ( _balanceOf [ _owner ] >= _value ) ; require ( _totalSupply >= _value ) ; _balanceOf [ _owner ] -= _value ; _totalSupply -= _value ; Burn ( _owner , _value ) ; return true ; }
","Destroy tokens from owener account , can be run only by owner Remove ` _value ` tokens from the system irreversibly
"
"function transferOwnership ( address _newOwner ) public onlyOwner { if ( _newOwner != address ( 0 ) ) { newOwner = _newOwner ; } }
","Transfer ownership from ` owner ` to ` newOwner `
"
"function onERC721Received ( address , address , uint256 _tokenId , bytes ) external returns ( bytes4 ) { if ( msg . sender == address ( land ) && flagReceiveLand == _tokenId ) { flagReceiveLand = 0 ; return bytes4 ( 0x150b7a02 ) ; } }
","Last callback used to accept the ERC721 parcel tokens
"
"function performBuyOrder ( OrderData data , uint256 amountToGiveForOrder ) public payable onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { if ( msg . value != amountToGiveForOrder ) { errorReporter . revertTx ( ""msg.value != amountToGiveForOrder"" ) ; } exchange . deposit . value ( amountToGiveForOrder ) ( ) ; uint256 amountToTrade ; uint256 fee ; ( amountToTrade , fee ) = substractFee ( data . exchangeFee , amountToGiveForOrder ) ; trade ( data , amountToTrade ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = getPartialAmount ( data . amountGive , data . amountGet , amountToTrade ) ; exchange . withdrawToken ( data . tokenGive , amountReceivedFromOrder ) ; if ( ! ERC20SafeTransfer . safeTransfer ( data . tokenGive , totlePrimary , amountReceivedFromOrder ) ) { errorReporter . revertTx ( ""Unable to transfer bought tokens to primary"" ) ; } }
","Perform a buy order at the exchange
"
"function _multisig ( bytes32 _args , uint _block ) internal returns ( uint _code ) { bytes32 _txHash = _getKey ( _args , _block ) ; address _manager = getPendingManager ( ) ; _code = PendingManager ( _manager ) . hasConfirmedRecord ( _txHash ) ; if ( _code != NO_RECORDS_WERE_FOUND ) { return _code ; } if ( OK != PendingManager ( _manager ) . addTx ( _txHash , msg . sig , address ( this ) ) ) { revert ( ) ; } return MULTISIG_ADDED ; }
","Sign current transaction and add it to transaction pending queue
"
"function _closeMotion ( uint motionID ) internal { delete targetMotionID [ motionTarget [ motionID ] ] ; delete motionTarget [ motionID ] ; delete motionStartTime [ motionID ] ; delete votesFor [ motionID ] ; delete votesAgainst [ motionID ] ; emit MotionClosed ( motionID ) ; }
","clear all data associated with a motionID for hygiene purposes .
"
"function setSellPrice ( uint256 priceInWei ) isOwner { require ( priceInWei >= 0 ) ; sellPrice = priceInWei ; }
","Set the current sell price in wei for one metadollar
"
"function withdrawPayments ( address payee ) external nonReentrant onlyController requiresState ( State . REFUNDING ) { uint256 payment = m_weiBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }
","withdraw accumulated balance , called by payee in case crowdsale failed
"
"function getRareCoinAddress ( ) external view returns ( address ) { return _rcContract ; }
","Get the address of the RareCoin contract
"
"function internalAddInterest ( Loan storage loan , uint256 timestamp ) internal { if ( timestamp > loan . interestTimestamp ) { uint256 newInterest = loan . interest ; uint256 newPunitoryInterest = loan . punitoryInterest ; uint256 newTimestamp ; uint256 realDelta ; uint256 calculatedInterest ; uint256 deltaTime ; uint256 pending ; uint256 endNonPunitory = min ( timestamp , loan . dueTime ) ; if ( endNonPunitory > loan . interestTimestamp ) { deltaTime = endNonPunitory - loan . interestTimestamp ; if ( loan . paid < loan . amount ) { pending = loan . amount - loan . paid ; } else { pending = 0 ; } ( realDelta , calculatedInterest ) = calculateInterest ( deltaTime , loan . interestRate , pending ) ; newInterest = safeAdd ( calculatedInterest , newInterest ) ; newTimestamp = loan . interestTimestamp + realDelta ; } if ( timestamp > loan . dueTime ) { uint256 startPunitory = max ( loan . dueTime , loan . interestTimestamp ) ; deltaTime = timestamp - startPunitory ; uint256 debt = safeAdd ( loan . amount , newInterest ) ; pending = min ( debt , safeSubtract ( safeAdd ( debt , newPunitoryInterest ) , loan . paid ) ) ; ( realDelta , calculatedInterest ) = calculateInterest ( deltaTime , loan . interestRatePunitory , pending ) ; newPunitoryInterest = safeAdd ( newPunitoryInterest , calculatedInterest ) ; newTimestamp = startPunitory + realDelta ; } if ( newInterest != loan . interest || newPunitoryInterest != loan . punitoryInterest ) { loan . interestTimestamp = newTimestamp ; loan . interest = newInterest ; loan . punitoryInterest = newPunitoryInterest ; } } }
","Computes loan interest Computes the punitory and non-punitory interest of a given loan and only applies the change .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( msg . sender == CaDataContract . ownerOf ( _tokenId ) || ownerOperators [ CaDataContract . atomOwner ( _tokenId ) ] [ msg . sender ] == true || msg . sender == tokenApprovals [ _tokenId ] ) ; require ( _from == CaDataContract . ownerOf ( _tokenId ) && _to != 0x0 ) ; require ( _tokenId < totalSupply ( ) ) ; _transfer ( _from , _to , _tokenId ) ; }
","Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
"
"function deedUri ( uint256 _deedId ) external pure returns ( string _uri ) ;
","A distinct URI ( RFC 3986 ) for a given token .
"
"function getDescription ( ) public view returns ( string ) { return ""Manage permissions within the Security Token and attached modules"" ; }
","Get the description of the Module
"
"function removeOrders ( uint _from , uint _to ) returns ( bool ) { if ( _to == 0 || _to > numberOfOrders ) _to = numberOfOrders - 1 ; uint _totalAmount ; uint o = _from ; for ( uint i = _from ; i <= _to ; i ++ ) { if ( orders [ o ] . buyer == msg . sender ) { _totalAmount += orders [ o ] . weiGiven ; removeOrder ( o ) ; } else o += 1 ; } if ( ! msg . sender . send ( _totalAmount ) ) throw ; else return true ; }
","Function to remove your orders and refund
"
"function enableTransfers ( bool _transfersEnabled ) public ;
","Enables token holders to transfer their tokens freely if true
"
"function updatePrice ( ) public { sellPrice = initialSellPrice * initialSupply * ( 10 ** uint256 ( decimals ) ) / totalSupply ; buyPrice = initialBuyPrice * initialSupply * ( 10 ** uint256 ( decimals ) ) / totalSupply ; }
","update the price based on the remaining count of resources
"
"function changeNonAccreditedLimit ( address [ ] _investors , uint256 [ ] _nonAccreditedLimit ) public onlyOwner { require ( _investors . length == _nonAccreditedLimit . length , ""Array length mismatch"" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { require ( _nonAccreditedLimit [ i ] > 0 , ""Limit can not be 0"" ) ; nonAccreditedLimitUSDOverride [ _investors [ i ] ] = _nonAccreditedLimit [ i ] ; emit SetNonAccreditedLimit ( _investors [ i ] , _nonAccreditedLimit [ i ] ) ; } }
","Modifies the list of overrides for non-accredited limits in USD
"
"function setETHPriceManually ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { require ( priceExpired ( ) || updateRequestExpired ( ) ) ; m_ETHPriceInCents = _price ; m_ETHPriceLastUpdate = getTime ( ) ; NewETHPrice ( m_ETHPriceInCents ) ; }
","set the price of ETH in cents , called in case we do n't get oraclize data for more than double the update interval
"
"function findPledge ( uint64 idPledge ) internal returns ( Pledge storage ) { require ( idPledge < pledges . length ) ; return pledges [ idPledge ] ; }
","A getter to look up a Pledge 's details
"
"function finalize ( ) public onlyOwner { require ( ! finalized ) ; finalized = true ; emit onFinalized ( ) ; }
","finalize
"
"function authorizePayment ( string _description , address _recipient , uint _amount , uint _paymentDelay ) returns ( uint ) { if ( ! allowedSpenders [ msg . sender ] ) throw ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; p . earliestPayTime = _paymentDelay >= timeLock ? now + _paymentDelay : now + timeLock ; p . recipient = _recipient ; p . amount = _amount ; p . description = _description ; PaymentAuthorized ( idPayment , p . recipient , p . amount ) ; return idPayment ; }
","only ` allowedSpenders [ ] ` Creates a new ` Payment `
"
"function depositMany ( address [ ] to , uint256 [ ] amount , bytes32 [ ] reference ) public { require ( to . length == amount . length ) ; require ( to . length == reference . length ) ; for ( uint256 i = 0 ; i < to . length ; i ++ ) { deposit ( to [ i ] , amount [ i ] , reference [ i ] ) ; } }
","runs many deposits within one transaction
"
"function getTokenSupply ( string currency ) public view returns ( uint supply ) { return lib . getTokenSupply ( currency ) ; }
","Gets total supply of specified currency
"
"function tokenURI ( uint256 _tokenId ) public view returns ( string ) { require ( exists ( _tokenId ) ) ; return tokenURIBase ; }
","The user/developper needs to add the tokenID , in the end of URL , to use the URI and get all details .
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; MiniMeToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function emergencyRedeem ( uint shareQuantity , address [ ] requestedAssets ) public pre_cond ( balances [ msg . sender ] >= shareQuantity ) returns ( bool ) { uint [ ] memory ownershipQuantities = new uint [ ] ( requestedAssets . length ) ; for ( uint i = 0 ; i < requestedAssets . length ; ++ i ) { address ofAsset = requestedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; if ( assetHoldings == 0 ) continue ; ownershipQuantities [ i ] = mul ( assetHoldings , shareQuantity ) / totalSupply ; if ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) < ownershipQuantities [ i ] ) { isShutDown = true ; ErrorMessage ( ""CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy"" ) ; return false ; } } annihilateShares ( msg . sender , shareQuantity ) ; for ( uint j = 0 ; j < ownershipQuantities . length ; ++ j ) { if ( ! AssetInterface ( ofAsset ) . transfer ( msg . sender , ownershipQuantities [ j ] ) ) { revert ( ) ; } } Redeemed ( msg . sender , now , shareQuantity ) ; return true ; }
","Redeems by allocating an ownership percentage only of requestedAssets to the participant
"
"function invokeOnceFor ( address _invoker ) public returns ( uint ) ;
","Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .
"
"function staticExchangeChecks ( OrderData order ) public view onlySelf returns ( bool checksPassed ) { return true ; }
","Perform exchange-specific checks on the given order
"
"function distributeTokens ( address [ ] buyers ) onlyOwner public { require ( currentState == State . Distribution ) ; require ( currentPeriodRate > 0 ) ; for ( uint256 i = 0 ; i < buyers . length ; i ++ ) { address buyer = buyers [ i ] ; require ( buyer != address ( 0 ) ) ; uint256 etherAmount = receivedEther [ buyer ] ; if ( etherAmount == 0 ) continue ; uint256 tokenAmount = etherAmount . mul ( currentPeriodRate ) ; uint256 fee = tokenAmount . mul ( buyFeeMilliPercent ) . div ( MILLI_PERCENT_DIVIDER ) ; tokenAmount = tokenAmount . sub ( fee ) ; receivedEther [ buyer ] = 0 ; currentPeriodEtherCollected = currentPeriodEtherCollected . sub ( etherAmount ) ; totalSupply = totalSupply . add ( tokenAmount ) ; balances [ buyer ] = balances [ buyer ] . add ( tokenAmount ) ; Transfer ( address ( 0 ) , buyer , tokenAmount ) ; } }
","Distribute tokens to buyers
"
"function proxyPayment ( address ) payable returns ( bool ) { return false ; }
","Called when ` _owner ` sends ether to the MiniMe Token contract
"
"function singlePayout ( address _user , uint256 _amount ) onlyOwner returns ( bool paid ) { require ( ! tokenTransfersFrozen ) ; require ( _amount > 0 ) ; require ( transferCheck ( owner , _user , _amount ) ) ; if ( ! userRegistered [ _user ] ) { registerUser ( _user ) ; } balances [ _user ] = add ( balances [ _user ] , _amount ) ; balances [ owner ] = sub ( balances [ owner ] , _amount ) ; Transfer ( owner , _user , _amount ) ; return true ; }
","Manual payout for site users
"
"function getInstructions ( ) public view returns ( string ) ;
","Get the Instructions that helped to used the module
"
"function exists ( uint256 _tokenId ) public view returns ( bool ) { return _exists ( _tokenId ) ; }
","Returns whether ` _tokenId ` exists
"
"function pollBallot ( uint _idPoll , uint _ballot ) public view returns ( string ) { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll memory p = _polls [ _idPoll ] ; return rlpHelper . pollBallot ( p . description , _ballot ) ; }
","Decode poll ballot
"
"function getChampsByOwner ( address _owner ) external view returns ( uint256 [ ] ) { uint256 [ ] memory result = new uint256 [ ] ( addressInfo [ _owner ] . champsCount ) ; uint256 counter = 0 ; for ( uint256 i = 0 ; i < champs . length ; i ++ ) { if ( champToOwner [ i ] == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }
","Gets champs by address
"
"function getAttributeTypeIDs ( ) external view returns ( uint256 [ ] ) ;
","Get the IDs of all available attribute types on the jurisdiction .
"
"function getPreviousDarknodes ( address _start , uint256 _count ) external view returns ( address [ ] ) { uint256 count = _count ; if ( count == 0 ) { count = numDarknodesPreviousEpoch ; } return getDarknodesFromEpochs ( _start , count , true ) ; }
","Retrieves a list of darknodes which were registered for the previous epoch .
"
"function pushDividendPayment ( uint256 _dividendIndex , uint256 _start , uint256 _iterations ) public withPerm ( DISTRIBUTE ) validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 numberInvestors = ISecurityToken ( securityToken ) . getInvestorsLength ( ) ; for ( uint256 i = _start ; i < Math . min256 ( numberInvestors , _start . add ( _iterations ) ) ; i ++ ) { address payee = ISecurityToken ( securityToken ) . investors ( i ) ; if ( ! dividend . claimed [ payee ] ) { _payDividend ( payee , dividend , _dividendIndex ) ; } } }
","Issuer can push dividends using the investor list from the security token
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool ) ;
","Send ` _amount ` of tokens from ` _from ` to ` _to ` on the condition it is approved by ` _from `
"
"function getPendingAmount ( uint index ) public returns ( uint256 ) { addInterest ( index ) ; return getRawPendingAmount ( index ) ; }
","Returns the pending amount to complete de payment of the loan , keep in mind that this number increases every second .
"
"function changeStatus ( uint idPackage , DAppNodePackageStatus newStatus ) onlyOwner public { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; c . status = newStatus ; StatusChanged ( idPackage , newStatus ) ; }
","Change the status of a DAppNode package
"
"function setOfferExpiry ( uint256 expiry ) public { require ( enforceKyc == false || isAllowedTrade ( msg . sender ) , ""You are unknown and not allowed to trade."" ) ; require ( expiry > block . timestamp , ""Cannot have an expiry date in the past."" ) ; TradeOrder memory order = orderBook [ msg . sender ] ; order . expiry = expiry ; orderBook [ msg . sender ] = order ; emit TokenOfferChanged ( msg . sender , order . quantity , order . price , order . expiry ) ; }
","Modify the expiry date of an existing ask .
"
"function totalSupply ( ) external view returns ( uint256 supply ) ;
","return total supply of tokens
"
"function releaseTokensFromEscrowForUser ( address _payer , uint256 _amount ) private { subFromEscrow ( _payer , _amount ) ; token . safeTransfer ( _payer , _amount ) ; emit TokenMarketplaceWithdrawal ( _payer , _amount ) ; }
","Release tokens back to payer 's available balance
"
"function collect ( ) public { assert ( getBlockTimestamp ( ) > contribution . startTime ( ) ) ; uint256 pre_sale_fixed_at = contribution . initializedBlock ( ) ; uint256 balance = apt . balanceOfAt ( msg . sender , pre_sale_fixed_at ) ; uint256 total = totalCollected . add ( aix . balanceOf ( address ( this ) ) ) ; uint256 amount = total . mul ( balance ) . div ( apt . totalSupplyAt ( pre_sale_fixed_at ) ) ; amount = amount . sub ( collected [ msg . sender ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( aix . transfer ( msg . sender , amount ) ) ; TokensCollected ( msg . sender , amount ) ; }
","This method should be called by the APT holders to collect their corresponding AIXs
"
"function createGame ( bytes32 _playerEndHash , uint _previousGameId , uint _createBefore , bytes32 _serverEndHash , bytes _serverSig ) public payable onlyValidValue onlyValidHouseStake ( activeGames + 1 ) onlyNotPaused { uint previousGameId = playerGameId [ msg . sender ] ; Game storage game = gameIdGame [ previousGameId ] ; require ( game . status == GameStatus . ENDED ) ; require ( previousGameId == _previousGameId ) ; require ( block . timestamp < _createBefore ) ; verifyCreateSig ( msg . sender , _previousGameId , _createBefore , _serverEndHash , _serverSig ) ; uint gameId = gameIdCntr ++ ; playerGameId [ msg . sender ] = gameId ; Game storage newGame = gameIdGame [ gameId ] ; newGame . stake = uint128 ( msg . value ) ; newGame . status = GameStatus . ACTIVE ; activeGames = activeGames + 1 ; emit LogGameCreated ( msg . sender , gameId , uint128 ( msg . value ) , _serverEndHash , _playerEndHash ) ; }
","Create games session request .
"
"function finalize ( ) public onlyOwner { require ( stage ( ) == Stage . Closed ) ; uint256 unsold = publicSupply . sub ( soldOut . cornerstoneValue ) . sub ( soldOut . vcValue ) ; if ( unsold > 0 ) { you . createOption ( 0x000000000000000000000000000000000000002b , unsold , 4070880001 , 365 ) ; } finalized = true ; LogFinalized ( ) ; }
","finalize
"
"function balanceUpdatesCount ( address account ) public view returns ( uint256 ) { return balanceBlocks [ account ] . length ; }
","Get the count of balance updates for the given account
"
"function initializeCrowdsale ( uint256 _startTime , uint256 _endTime , address _token , uint256 _intervalUpdate ) public payable onlyOwner mustBeAtStage ( Stage . ToInitialize ) { require ( _startTime >= now ) ; require ( _endTime >= _startTime ) ; require ( _token != address ( 0 ) ) ; require ( msg . value > 0 ) ; require ( isContract ( _token ) == true ) ; require ( _intervalUpdate >= 5 ) ; startTime = _startTime ; endTime = _endTime ; token = Token ( _token ) ; intervalUpdate = _intervalUpdate ; currentStage = Stage . Waiting ; updateEthRateWithDelay ( startTime - ( intervalUpdate + 30 ) ) ; LogCrowdsaleInit ( ) ; assert ( token . balanceOf ( address ( this ) ) == MAX_TOKENS ) ; }
","You must send some ETH to cover the oraclize_query fees
"
"function getStartDateOfCampaign ( bytes32 bidId ) public view returns ( uint startDate ) { return advertisementStorage . getCampaignStartDateById ( bidId ) ; }
","Get the start date of a campaign Based on the Campaign id return the value ( in miliseconds ) corresponding to the start Date of the campaign .
"
"function goalReached ( ) public constant returns ( bool ) { return tokensRaised >= minimumGoal ; }
","To see if the minimum goal of tokens of the ICO has been reached
"
"function transfer ( address _to , uint256 _amount ) public returns ( bool ) ;
","Send ` _amount ` of tokens from ` msg.sender ` to ` _to `
"
"function buyToken ( ) external payable { _buyToken ( msg . sender ) ; }
","Buy tokens for ether .
"
"function approveCompletedMilestone ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . reviewer ) || ( milestone . status != MilestoneStatus . Completed ) ) throw ; doPayment ( _idMilestone ) ; }
","` onlyReviewer ` Approves a specific milestone
"
"function newVersion ( uint16 [ 3 ] _newSemanticVersion , address _contractAddress , bytes _contentURI ) public auth ( CREATE_VERSION_ROLE ) { address contractAddress = _contractAddress ; uint256 lastVersionIndex = versionsNextIndex - 1 ; uint16 [ 3 ] memory lastSematicVersion ; if ( lastVersionIndex > 0 ) { Version storage lastVersion = versions [ lastVersionIndex ] ; lastSematicVersion = lastVersion . semanticVersion ; if ( contractAddress == address ( 0 ) ) { contractAddress = lastVersion . contractAddress ; } require ( lastVersion . contractAddress == contractAddress || _newSemanticVersion [ 0 ] > lastVersion . semanticVersion [ 0 ] , ERROR_INVALID_VERSION ) ; } require ( isValidBump ( lastSematicVersion , _newSemanticVersion ) , ERROR_INVALID_BUMP ) ; uint256 versionId = versionsNextIndex ++ ; versions [ versionId ] = Version ( _newSemanticVersion , contractAddress , _contentURI ) ; versionIdForSemantic [ semanticVersionHash ( _newSemanticVersion ) ] = versionId ; latestVersionIdForContract [ contractAddress ] = versionId ; emit NewVersion ( versionId , _newSemanticVersion ) ; }
","Create new version for repo
"
"function _investAsEarlybird ( address _beneficiary , uint256 _amountTokens ) internal { tokensBoughtInEarlybird = tokensBoughtInEarlybird . add ( _amountTokens ) ; earlybird . addAmountBoughtAsMember ( _beneficiary , _amountTokens ) ; _depositTokens ( _beneficiary , _amountTokens ) ; emit BoughtEarlyBird ( _beneficiary , _amountTokens ) ; if ( tokensBoughtInEarlybird >= INITIAL_EARLYBIRD_TOKENS ) { earlybirdEnded = true ; } }
","Internal function for investing as a earlybird member
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; _balance [ _from ] = _balance [ _from ] . sub ( _value ) ; _balance [ _to ] = _balance [ _to ] . add ( _value ) ; _allowed [ _from ] [ msg . sender ] = _allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
","Transfers ` _value ` amount of tokens from address ` _from ` to address ` _to ` .
"
"function settleCurrentLockPeriod ( address _address ) private returns ( bool ) { mintedActFromCurrentLockPeriodPerUser [ _address ] = getMintedActFromCurrentLockPeriod ( _address ) ; mintedActFromPastLockPeriodsPerUser [ _address ] = mintedActFromPastLockPeriodsPerUser [ _address ] . add ( mintedActFromCurrentLockPeriodPerUser [ _address ] ) ; mintedActPerUser [ _address ] = totalMintedActPerLockedBbkToken ; return true ; }
","Transfers `` Current Lock Period '' balance sheet to `` Past Lock Periods '' balance sheet .
"
"function release ( uint256 _amount ) public { uint256 balance = token . balanceOf ( address ( this ) ) ; require ( balance > 0 ) ; if ( ! withdrawalsInitiated ) { unlocked = balance . div ( 2 ) ; withdrawalsInitiated = true ; } if ( now >= releaseTime ) { unlocked = balance ; } require ( _amount <= unlocked ) ; unlocked = unlocked . sub ( _amount ) ; token . safeTransfer ( beneficiary , _amount ) ; }
","Transfers tokens held by timelock to beneficiary .
"
"function getCanvasBitmap ( uint32 _canvasId ) external view returns ( uint8 [ ] ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; uint8 [ ] memory result = new uint8 [ ] ( PIXEL_COUNT ) ; for ( uint32 i = 0 ; i < PIXEL_COUNT ; i ++ ) { result [ i ] = canvas . pixels [ i ] . color ; } return result ; }
","Returns full bitmap for given canvas .
"
"function closeSetup ( ) ;
","Function to close the setup procedure of this contract
"
"function batchCreateAsset ( uint8 [ ] _teamId , uint256 [ ] _attributes , uint256 [ ] _playerOverrideId , uint256 [ ] _mlbPlayerId , address [ ] _to ) external canCreate whenNotPaused { require ( isBatchSupported ) ; require ( _teamId . length > 0 && _attributes . length > 0 && _playerOverrideId . length > 0 && _mlbPlayerId . length > 0 && _to . length > 0 ) ; uint256 assetDetails ; uint256 [ 5 ] memory _nftData ; for ( uint ii = 0 ; ii < _attributes . length ; ii ++ ) { require ( _to [ ii ] != address ( 0 ) && _teamId [ ii ] != 0 && _attributes . length != 0 && _mlbPlayerId [ ii ] != 0 ) ; assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( getSequenceId ( _teamId [ ii ] ) ) << 64 ; assetDetails |= uint256 ( _teamId [ ii ] ) << 96 ; assetDetails |= uint256 ( ( _attributes [ ii ] / 1000000000000000000000000000000000000000 ) - 800 ) << 104 ; _nftData = [ assetDetails , _attributes [ ii ] , 0 , _playerOverrideId [ ii ] , _mlbPlayerId [ ii ] ] ; _createNFTCollectible ( _teamId [ ii ] , _attributes [ ii ] , _to [ ii ] , 0 , _nftData ) ; } }
","Batch Function to Create Assets
"
"function ownerResumeContract ( ) external onlyOwner { require ( contractPaused ) ; contractPaused = false ; }
","Resume contract ( transiently )
"
"function revokeAttribute ( address account ) external onlyCareCoordinators { require ( _revokeAttribute ( account ) ) ; }
","Revoke an attribute from the type with the default ID from ` msg.sender ` on the jurisdiction .
"
"function batchAddToWhitelist ( uint maxBuyinQuantity , address [ ] whitelistants ) pre_cond ( isOwner ( ) ) pre_cond ( now < endTime ) { for ( uint i = 0 ; i < whitelistants . length ; ++ i ) { whitelistantToMaxBuyin [ whitelistants [ i ] ] = maxBuyinQuantity ; } }
","Add batch addresses to whitelist with set maxBuyinQuantity
"
"function addWineryOperationEndorsement ( string _mappingID , uint _index , bool positive , string title , string description ) external returns ( bool success ) { wineryOperationEndorsements [ keccak256 ( _mappingID , _index ) ] . push ( Endorsement ( positive , title , description , msg . sender ) ) ; return true ; }
","Add new endorsement to a winery operation
"
"function setNextPriceOf ( uint256 tokenId , uint256 salePrice ) external whenNotPaused { require ( msg . sender == address ( saleAuction ) ) ; masterpieceToPrice [ tokenId ] = computeNextPrice ( salePrice ) ; }
","This contract does n't handle setting the Masterpiece 's next listing price .
"
"function getAccountSpendingLimit ( address account ) public view returns ( uint spendingLimit ) { return lib . getAccountSpendingLimit ( account ) ; }
","Return the spending limit for an account
"
"function emergencyCancel ( bytes32 _offerHash , uint256 _expectedAvailableAmount ) external onlyCoordinator onlyInactiveState { _cancel ( _offerHash , _expectedAvailableAmount , etherAddr , 0 ) ; }
","Cancels an offer requiring the owner 's signature , so that the tokens can be withdrawn using ` emergencyWithdraw ` .
"
"function batchApprove ( address _to , uint32 [ ] _tokenIds ) public whenNotPaused { for ( uint32 i = 0 ; i < _tokenIds . length ; i ++ ) { uint32 _tokenId = _tokenIds [ i ] ; require ( _owns ( msg . sender , _tokenId ) || ( operators [ ownerOf ( _tokenId ) ] [ msg . sender ] ) ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; } }
","Change or reaffirm the approved address for an NFT
"
"function contestForUser ( address _attester , address _requester , uint256 _reward , bytes32 _requestNonce , bytes _requesterSig ) private { if ( _reward > 0 ) { tokenEscrowMarketplace . requestTokenPayment ( _requester , _attester , _reward , _requestNonce , _requesterSig ) ; } emit AttestationRejected ( _attester , _requester ) ; }
","Private function for attester to reject an attestation and receive payment without associating the negative attestation with the subject 's bloomId
"
"function getRewardsBalance ( address _user ) public view returns ( uint256 _balance ) { return ExtendedFinance ( address ( _getFinance ( ) ) ) . getRewardsBalance ( _user ) ; }
","Get user 's balance of funds obtainded by rewards Anyone can call this function and get the rewards balance of a certain user .
"
"function getBlockOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return miners [ _miner ] . block ; }
","Return the block in which the miner is
"
"function issueMaxSynths ( bytes4 currencyKey ) external optionalProxy { uint maxIssuable = remainingIssuableSynths ( messageSender , currencyKey ) ; issueSynths ( currencyKey , maxIssuable ) ; }
","Issue the maximum amount of Synths possible against the sender 's SNX .
"
"function investInternal ( address _receiver , bytes16 _customerUuid ) private { uint weiAmount = msg . value ; uint256 tokenAmount = pricingStrategy . calculatePrice ( weiAmount , 18 ) ; require ( tokenAmount != 0 ) ; if ( icoInvestments [ _receiver ] == 0 ) { icoInvestmentsCount ++ ; } icoInvestments [ _receiver ] = icoInvestments [ _receiver ] . add ( weiAmount ) ; icoTokenTransfers [ _receiver ] = icoTokenTransfers [ _receiver ] . add ( tokenAmount ) ; icoReceivedWei = icoReceivedWei . add ( weiAmount ) ; icoTokensSold = icoTokensSold . add ( tokenAmount ) ; assignTokens ( owner , _receiver , tokenAmount ) ; wallet . transfer ( weiAmount ) ; Invested ( _receiver , weiAmount , tokenAmount , _customerUuid ) ; }
","Handle invested wei .
"
"function sealed ( ) constant returns ( bool ) { return tokenController == 0 ; }
","` sealed ( ) ` checks to see if the the Campaign has been sealed
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; uint256 allowance = allowed [ _from ] [ msg . sender ] ; require ( _value <= allowance || _from == msg . sender ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; balanceOf [ _from ] = balanceOf [ _from ] . sub ( _value ) ; if ( allowed [ _from ] [ msg . sender ] != MAX_UINT256 && _from != msg . sender ) { allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; } Transfer ( _from , _to , _value ) ; return true ; }
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function addAttributeType ( uint256 ID , string description ) external ;
","Add an attribute type with ID ` ID ` and description ` description ` to the jurisdiction .
"
"function updateTransfer ( Data storage self , uint64 nonce , uint256 transferred_amount , bytes32 locksroot , bytes32 extra_hash , bytes signature ) notSettledButClosed ( self ) stillTimeout ( self ) { address transfer_address ; uint8 caller_index ; uint8 closer_index ; require ( ! self . updated ) ; self . updated = true ; caller_index = index_or_throw ( self , msg . sender ) ; require ( self . closing_address != msg . sender ) ; transfer_address = recoverAddressFromSignature ( nonce , transferred_amount , locksroot , extra_hash , signature ) ; require ( transfer_address == self . closing_address ) ; closer_index = 1 - caller_index ; self . participants [ closer_index ] . nonce = nonce ; self . participants [ closer_index ] . locksroot = locksroot ; self . participants [ closer_index ] . transferred_amount = transferred_amount ; }
","Updates counter party transfer after closing .
"
"function __approve ( address _spender , uint _value , address _sender ) onlyAccess ( _sender ) public returns ( bool ) { return chronoBankPlatform . proxyApprove ( _spender , _value , smbl , _sender ) == OK ; }
","Performs allowance setting call on the platform by the name of specified sender .
"
"function ( ) payable public { require ( msg . value > 0 ) ; require ( crowdsaleRunning ( ) ) ; uint256 rate = currentRate ( msg . value ) ; require ( rate > 0 ) ; uint256 tokens = rate . mul ( msg . value ) . div ( DOCT_TO_ETH_DECIMALS ) ; mintTokens ( msg . sender , tokens ) ; }
","Buy tokens
"
"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _data , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _data , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) , ""Cannot send to contract without ERC777TokensRecipient"" ) ; } }
","Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
"
"function withdrawCollateral ( address token , uint amount ) public { require ( token != 0 ) ; require ( isAcceptedToken ( token ) , ""ERC20 not authorised"" ) ; require ( isMasternodeOwner ( msg . sender ) ) ; require ( tokens [ token ] [ msg . sender ] == amount ) ; uint amountToWithdraw = tokens [ token ] [ msg . sender ] ; tokens [ token ] [ msg . sender ] = 0 ; deleteMasternode ( getLastPerUser ( msg . sender ) ) ; if ( ! StandardToken ( token ) . transfer ( msg . sender , amountToWithdraw ) ) revert ( ) ; emit Withdraw ( token , msg . sender , amountToWithdraw , amountToWithdraw ) ; }
","Public function that allows any user to withdraw deposited tokens and stop as masternode
"
"function migrate ( uint256 _value ) external onlyUnlocked ( ) { if ( migrationAgent == 0 ) revert ( ) ; if ( _value == 0 ) revert ( ) ; if ( _value > balances [ msg . sender ] ) revert ( ) ; balances [ msg . sender ] -= _value ; totalSupply -= _value ; totalMigrated += _value ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }
","Migrate tokens to the new token contract .
"
"function playerCancelActiveGame ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; if ( game . status == GameStatus . ACTIVE ) { game . endInitiatedTime = block . timestamp ; game . status = GameStatus . PLAYER_INITIATED_END ; LogPlayerRequestedEnd ( msg . sender , gameId ) ; } else if ( game . status == GameStatus . SERVER_INITIATED_END && game . roundId == 0 ) { closeGame ( game , gameId , playerAddress , ReasonEnded . REGULAR_ENDED , 0 ) ; payOut ( game , playerAddress ) ; } else { revert ( ) ; } }
","Cancel active game without playing .
"
"function whitelist ( address _affiliate , uint256 _rate ) onlyOwner public { require ( _rate <= hardCodedMaximumRate ) ; whitelistRates [ _affiliate ] = _rate ; Whitelisted ( _affiliate , _rate ) ; }
","whitelist an affiliate address
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; allowed [ _from ] [ msg . sender ] -= _amount ; doTransfer ( _from , _to , _amount ) ; return true ; }
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function createDividend ( uint256 _maturity , uint256 _expiry , bytes32 _name ) external payable withPerm ( MANAGE ) { createDividendWithExclusions ( _maturity , _expiry , excluded , _name ) ; }
","Creates a dividend and checkpoint for the dividend , using global list of excluded addresses
"
"function amountReceivedFromTransfer ( uint value ) external view returns ( uint ) { return value . divideDecimal ( transferFeeRate . add ( SafeDecimalMath . unit ( ) ) ) ; }
","The amount the recipient will receive if you send a certain number of tokens .
"
"function acceptBuyOffer ( uint32 _canvasId , uint _minPrice ) external stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; require ( canvas . owner == msg . sender ) ; BuyOffer memory offer = buyOffers [ _canvasId ] ; require ( offer . hasOffer ) ; require ( offer . amount > 0 ) ; require ( offer . buyer != 0x0 ) ; require ( offer . amount >= _minPrice ) ; uint toTransfer ; ( , , toTransfer ) = _registerTrade ( _canvasId , offer . amount ) ; addressToCount [ canvas . owner ] -- ; addressToCount [ offer . buyer ] ++ ; canvas . owner = offer . buyer ; addPendingWithdrawal ( msg . sender , toTransfer ) ; buyOffers [ _canvasId ] = BuyOffer ( false , 0x0 , 0 ) ; canvasForSale [ _canvasId ] = SellOffer ( false , 0x0 , 0 , 0x0 ) ; emit CanvasSold ( _canvasId , offer . amount , msg . sender , offer . buyer ) ; }
","Accepts buy offer for the canvas .
"
"function approve ( address spender , uint256 value ) returns ( bool success ) { allowance [ msg . sender ] [ spender ] = value ; return true ; }
","Allow another contract to spend some tokens in your behalf
"
"function name ( ) public pure returns ( string ) { return ""Pirate Conquest Token"" ; }
","A descriptive name for a collection of NFTs in this contract
"
"function tokensBoughtWithBTC ( address _beneficiary , uint256 _tokens ) public payable { require ( msg . sender == btcTokenBoughtAddress ) ; require ( started ) ; require ( ! finished ) ; require ( _beneficiary != address ( 0 ) ) ; require ( whitelist [ _beneficiary ] ) ; require ( fidaToken . totalSupply ( ) < 24750 * 10 ** 3 * 10 ** DECIMALS ) ; require ( _tokens >= 50 * 10 ** DECIMALS ) ; if ( ! earlybirdEnded ) { _investAsEarlybird ( _beneficiary , _tokens ) ; } else { _investAsBonusProgram ( _beneficiary , _tokens ) ; } }
","Public payable function to buy tokens during sale or emission
"
"function increaseApproval ( address _spender , uint256 _addedValue ) public returns ( bool ) { require ( ! freezeTransfer || isOps ( ) , ""all transfers are currently frozen"" ) ; require ( _spender != address ( 0 ) , ""zero address is not allowed"" ) ; require ( _addedValue >= 1000 , ""must approve more than 1000 sip"" ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _addedValue ) ; emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }
","Increase the amount of tokens that an owner allowed to a spender .
"
"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }
","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .
"
"function setMinter ( address _who ) public onlyValidator { _setMinter ( _who ) ; }
","Sets the necessary permissions for a user to mint tokens .
"
"function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; if ( guaranteedBuyersLimit [ _th ] > 0 ) { buyGuaranteed ( _th ) ; } else { buyNormal ( _th ) ; } return true ; }
","This method will generally be called by the SNT token contract to acquire SNTs .
"
"function delayPayment ( uint _idPayment , uint _delay ) onlySecurityGuard external { require ( _idPayment < authorizedPayments . length ) ; require ( _delay <= 10 ** 18 ) ; Payment storage p = authorizedPayments [ _idPayment ] ; require ( p . securityGuardDelay + _delay <= maxSecurityGuardDelay ) ; require ( ! p . paid ) ; require ( ! p . canceled ) ; p . securityGuardDelay += _delay ; p . earliestPayTime += _delay ; }
","` onlySecurityGuard ` Delays a payment for a set number of seconds
"
"function setVault ( address _newVaultAddress ) onlyOwner { vaultAddress = _newVaultAddress ; }
","` onlyOwner ` changes the location that ether is sent
"
"function release ( ) public { require ( now >= releaseTime ) ; assert ( current_month <= 5 ) ; uint diff = now - releaseTime ; if ( diff > month ) { releaseTime = now ; } else { releaseTime = now . add ( month . sub ( diff ) ) ; } current_month ++ ; token . safeTransfer ( beneficiary , twenty_percent_of_amount ) ; }
","Transfers tokens held by timelock to beneficiary .
"
"function unfreezeAmount ( address target ) onlyOwner public { frozenAmount [ target ] = 0 ; emit UnfrozenAmt ( target ) ; }
","Unfreeze ` target ` balance .
"
"function addMultipleParticipants ( address [ ] _participants ) public onlyAdmin returns ( bool ) { for ( uint i = 0 ; i < _participants . length ; i ++ ) { require ( addParticipant ( _participants [ i ] ) ) ; } return true ; }
","used to save gas
"
"function begin ( ) external view onlyOwner returns ( address ) { return LinkedList . begin ( darknodes ) ; }
","Returns the address of the first darknode in the store
"
"function _emitERC20DividendDepositedEvent ( uint256 _checkpointId , uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 currentSupply , uint256 dividendIndex , bytes32 _name ) internal { emit ERC20DividendDeposited ( msg . sender , _checkpointId , now , _maturity , _expiry , _token , _amount , currentSupply , dividendIndex , _name ) ; }
","Emits the ERC20DividendDeposited event .
"
"function requireMultiple ( uint256 _amount ) internal view { require ( _amount . div ( mGranularity ) . mul ( mGranularity ) == _amount , ""You can only use tokens using the granularity currently set."" ) ; }
","Internal function that ensures ` _amount ` is multiple of the granularity
"
"function finishMinting ( ) internal returns ( bool ) { require ( finalized == true ) ; require ( super . finishMinting ( ) ) ; return true ; }
","Overrides finishMinting function from RBACMintableTokenMixin to prevent finishing minting before finalization
"
"function withdrawEther ( ) public onlyContractOwner { uint balance = address ( this ) . balance ; if ( balance > 0 ) { contractOwner . transfer ( balance ) ; } }
","Withdraw ether from contract to owner .
"
"function removeTokensFromAccount ( bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses onlyRegisteredAccount ( _uuid ) whenNotPaused internal returns ( bool ) { balances [ _uuid ] = balances [ _uuid ] . sub ( _tokensCount ) ; return true ; }
","Function for removing tokens from specified account .
"
"function getTotalRewards ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; if ( _lastIndex < 0 ) { return 0 ; } return _history . rewardsCumulative [ _lastIndex ] ; }
","Returns all rewards charged for the given canvas .
"
"function mint ( address _owner , uint256 _amount ) public onlyMinter validate_address ( _owner ) returns ( bool success ) { if ( totalSupply + _amount < totalSupply ) revert ( ) ; if ( balances [ _owner ] + _amount < balances [ _owner ] ) revert ( ) ; totalSupply += _amount ; balances [ _owner ] += _amount ; Transfer ( 0x0 , msg . sender , _amount ) ; Transfer ( msg . sender , _owner , _amount ) ; return true ; }
","mint new tokens by the minter
"
"function batchTransferFrom ( address _from , address _to , uint32 [ ] _tokenIds ) public whenNotPaused { for ( uint32 i = 0 ; i < _tokenIds . length ; i ++ ) { uint32 _tokenId = _tokenIds [ i ] ; require ( _approvedFor ( _to , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _owns ( msg . sender , _tokenId ) || ( msg . sender == playerTokenToApproved [ _tokenId ] ) || operators [ _from ] [ msg . sender ] ) ; _transfer ( _from , _to , _tokenId ) ; } }
","Transfer ownership of a batch of NFTs -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
"
"function getTagsByTypeAndToken ( uint8 _moduleType , address _securityToken ) external view returns ( bytes32 [ ] , address [ ] ) { address [ ] memory modules = getModulesByTypeAndToken ( _moduleType , _securityToken ) ; return _tagsByModules ( modules ) ; }
","Returns all the tags related to the a module type which are valid for the given token
"
"function changeIsPayableEnabled ( ) onlyMultiSig { isPayableEnabled = ! isPayableEnabled ; LogChangeIsPayableEnabled ( isPayableEnabled ) ; }
","This method will change isPayableEnabled flag .
"
"function getPositionId ( uint256 _tokenId ) external view returns ( uint256 ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; uint256 positionId = uint256 ( uint8 ( obj . assetDetails >> 104 ) ) ; return positionId ; }
","Returns the position of the asset/collectible/token
"
"function noError ( ) public onlyGameManager whenPaused { error = false ; }
","This is public rather than external so it can be called by derived contracts .
"
"function getNumberInvestors ( ) public view returns ( uint256 ) { return investorCount ; }
","Return the total no .
"
"function __transferFromWithReference ( address _from , address _to , uint _value , string _reference , address _sender ) onlyAccess ( _sender ) public returns ( bool ) { return chronoBankPlatform . proxyTransferFromWithReference ( _from , _to , _value , smbl , _reference , _sender ) == OK ; }
","Performs allowance transfer call on the platform by the name of specified sender .
"
"function commitVote ( uint _pollID , bytes32 _secretHash , uint _numTokens , uint _prevPollID ) external { require ( commitPeriodActive ( _pollID ) ) ; require ( voteTokenBalance [ msg . sender ] >= _numTokens ) ; require ( _pollID != 0 ) ; require ( _prevPollID == 0 || getCommitHash ( msg . sender , _prevPollID ) != 0 ) ; uint nextPollID = dllMap [ msg . sender ] . getNext ( _prevPollID ) ; nextPollID = ( nextPollID == _pollID ) ? dllMap [ msg . sender ] . getNext ( _pollID ) : nextPollID ; require ( validPosition ( _prevPollID , nextPollID , msg . sender , _numTokens ) ) ; dllMap [ msg . sender ] . insert ( _prevPollID , _pollID , nextPollID ) ; bytes32 UUID = attrUUID ( msg . sender , _pollID ) ; store . setAttribute ( UUID , ""numTokens"" , _numTokens ) ; store . setAttribute ( UUID , ""commitHash"" , uint ( _secretHash ) ) ; VoteCommitted ( msg . sender , _pollID , _numTokens ) ; }
","Commits vote using hash of choice and secret salt to conceal vote until reveal
"
"function updateRegisteredWallet ( address addr ) onlyOwner external { registered_wallet = addr ; }
","Change the address of our registered wallet
"
"function burn ( uint256 _value , uint256 _confirmation ) onlyOwner public returns ( bool success ) { require ( _confirmation == 7007 ) ; require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; emit Burn ( msg . sender , _value ) ; return true ; }
","Only central mint can burn from their own supply
"
"function updateTimeLock ( uint256 _timelockEndTime ) onlyOwner public returns ( bool ) { timelockEndTime = _timelockEndTime ; emit UpdateTimeLock ( _timelockEndTime ) ; return true ; }
","Called by owner to alter the token timelock
"
"function checkBtcRequestSignature ( bytes requestData , bytes payeesPaymentAddress , uint256 expirationDate , bytes signature ) internal view returns ( bool ) { bytes32 hash = getBtcRequestHash ( requestData , payeesPaymentAddress , expirationDate ) ; uint8 v = uint8 ( signature [ 64 ] ) ; v = v < 27 ? v . add ( 27 ) : v ; bytes32 r = Bytes . extractBytes32 ( signature , 0 ) ; bytes32 s = Bytes . extractBytes32 ( signature , 32 ) ; return isValidSignature ( Bytes . extractAddress ( requestData , 0 ) , hash , v , r , s ) ; }
","Checks the validity of a Bitcoin signed request & the expiration date .
"
"function emitTransfer ( address _from , address _to , uint _value ) onlyChronoBankPlatform public { emit Transfer ( _from , _to , _value ) ; }
","Emits ERC20 Transfer event on this contract .
"
"function getWithdrawableOperationFeeDatesAndAmount ( ) external view returns ( uint32 [ ] , uint256 ) { if ( msg . sender != owner ) { return ( new uint32 [ ] ( 0 ) , 0 ) ; } uint32 cutoffTime = uint32 ( now ) . sub ( WITHDRAW_BUFFER ) ; uint32 maxLength = cutoffTime . sub ( MAY_FIRST_2018 ) . div ( DAY ) . add ( 1 ) ; uint32 [ ] memory withdrawableDates = new uint32 [ ] ( maxLength ) ; uint256 index = 0 ; uint256 withdrawAmount = 0 ; uint32 date = MAY_FIRST_2018 ; while ( date < cutoffTime ) { if ( ! dateToContestStatus [ date ] . operationFeeWithdrawn ) { uint256 amount = calculateOperationFee ( date ) ; if ( amount > 0 ) { withdrawableDates [ index ] = date ; withdrawAmount = withdrawAmount . add ( amount ) ; index += 1 ; } } date = date . add ( DAY ) ; } return ( withdrawableDates , withdrawAmount ) ; }
","Does n't change state
"
"function getAssetAttachment ( uint256 _tokenId ) external view returns ( uint256 [ ] ) { uint256 [ ] _attachments = nftCollectibleAttachments [ _tokenId ] ; uint256 [ ] attachments ; for ( uint i = 0 ; i < _attachments . length ; i ++ ) { attachments . push ( _attachments [ i ] ) ; } return attachments ; }
","Gets the attachments for an asset
"
"function freeze ( address _target , uint256 _frozenAmount , uint256 _releaseAmount ) byToken public returns ( bool ) { require ( _target != 0x0 ) ; require ( _frozenAmount > 0 ) ; require ( _releaseAmount < _frozenAmount ) ; totalFrozen = totalFrozen . add ( _frozenAmount ) ; FrozenStatus storage frozenStatus = frozenStatuses [ _target ] ; require ( frozenStatus . frozenAmount == 0 ) ; frozenStatus . frozenTimestamp = now ; frozenStatus . frozenAmount = _frozenAmount ; frozenStatus . releaseAmount = _releaseAmount ; FreezeTokens ( _target , _frozenAmount ) ; return true ; }
","Freeze _frozenAmount of tokens held by _target with PeriodicReleaseLock .
"
"function setIssuer ( address _issuer ) public { }
","will set the asset issuer address
"
"function getBudgetOfCampaign ( bytes32 bidId ) public view returns ( uint budget ) { return advertisementStorage . getCampaignBudgetById ( bidId ) ; }
","Get the budget avaliable of a campaign Based on the Campaign id return the total value avaliable to pay for proofs of attention .
"
"function claimByAddress ( address _address ) public returns ( bool ) { return claimInternal ( _address ) ; }
","Withdraw ( for cold storage wallet ) a bid that was overbid and platform owner share
"
"function transfer ( address _to , uint _value ) returns ( bool success ) ;
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function changeGasLimit ( uint256 _gasLimit ) public { require ( msg . sender == priceCheckerAddress ) ; gasLimit = _gasLimit ; }
","Change gasLimit
"
"function sendTokens ( address _to , uint _value ) public onlyMinter validAddress ( _to ) notZero ( _value ) { balances [ _to ] = SafeMath . add ( balances [ _to ] , _value ) ; totalSupply = SafeMath . add ( totalSupply , _value ) ; Transfer ( 0x0 , _to , _value ) ; }
","To send tokens to another user .
"
"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Sufficent Allowance is not provided"" ) ; require ( USDTieredSTOProxyAddress != address ( 0 ) , ""Proxy contract should be pre-set"" ) ; address usdTieredSTO = IUSDTieredSTOProxy ( USDTieredSTOProxyAddress ) . deploySTO ( msg . sender , address ( polyToken ) , address ( this ) ) ; require ( Util . getSig ( _data ) == IUSDTieredSTOProxy ( USDTieredSTOProxyAddress ) . getInitFunction ( usdTieredSTO ) , ""Invalid data"" ) ; require ( address ( usdTieredSTO ) . call ( _data ) , ""Unsuccessfull call"" ) ; emit GenerateModuleFromFactory ( usdTieredSTO , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( usdTieredSTO ) ; }
","Used to launch the Module with the help of factory
"
"function addAttribute ( uint256 attributeTypeID , uint256 value , uint256 validatorFee , bytes signature ) external payable ;
","Add an attribute of the type with ID ` attributeTypeID ` , an attribute value of ` value ` , and an associated validator fee of ` validatorFee ` to account of ` msg.sender ` by passing in a signed attribute approval with signature ` signature ` .
"
"function setMinStandingBalance ( uint balance ) external onlyOwner { minStandingBalance = balance ; }
","Set the minimum required havven balance to have standing to bring a motion .
"
"function addTx ( bytes32 _key , bytes4 _sig , address _contract ) external onlyAuthorized returns ( uint ) { require ( _key != bytes32 ( 0 ) ) ; require ( _sig != bytes4 ( 0 ) ) ; require ( _contract != 0x0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; require ( isPolicyExist ( _policyHash ) ) ; if ( isTxExist ( _key ) ) { return _emitError ( PENDING_DUPLICATE_TX ) ; } if ( _policyHash == bytes32 ( 0 ) ) { return _emitError ( PENDING_MANAGER_POLICY_NOT_FOUND ) ; } uint _index = txCount . add ( 1 ) ; txCount = _index ; index2txKey [ _index ] = _key ; txKey2index [ _key ] = _index ; Guard storage _guard = txKey2guard [ _key ] ; _guard . basePolicyIndex = policyId2Index [ _policyHash ] ; _guard . state = GuardState . InProcess ; Policy storage _policy = policyId2policy [ _policyHash ] ; uint _counter = _policy . securesCount . add ( 1 ) ; _policy . securesCount = _counter ; _policy . index2txIndex [ _counter ] = _index ; _policy . txIndex2index [ _index ] = _counter ; ProtectionTxAdded ( _key , _policyHash , block . number ) ; return OK ; }
","Add transaction
"
"function claimed ( address investor ) public { delete _commitments [ msg . sender ] [ investor ] ; }
","may be used by commitment contract to refund gas for commitment bookkeeping
"
"function generateTokens ( address _owner , uint _amount ) public returns ( bool ) ;
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( ( _value != 0 ) && ( allowed [ msg . sender ] [ _spender ] != 0 ) ) { return false ; } allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
"
"function changeResource ( bytes32 _resource ) public onlyOwner returns ( bool ) { resource = _resource ; ChangedResource ( _resource ) ; return true ; }
","Change the resource to ` _resource `
"
"function takeOrder ( uint exchangeNumber , uint id , uint receiveQuantity ) external pre_cond ( isOwner ( ) ) pre_cond ( ! isShutDown ) { Order memory order ; ( order . sellAsset , order . buyAsset , order . sellQuantity , order . buyQuantity ) = exchanges [ exchangeNumber ] . exchangeAdapter . getOrder ( exchanges [ exchangeNumber ] . exchange , id ) ; require ( order . sellAsset != address ( this ) ) ; require ( module . pricefeed . existsPriceOnAssetPair ( order . buyAsset , order . sellAsset ) ) ; require ( isInAssetList [ order . sellAsset ] || ownedAssets . length < MAX_FUND_ASSETS ) ; var ( isRecent , referencePrice , ) = module . pricefeed . getReferencePrice ( order . buyAsset , order . sellAsset ) ; require ( isRecent ) ; require ( receiveQuantity <= order . sellQuantity ) ; uint spendQuantity = mul ( receiveQuantity , order . buyQuantity ) / order . sellQuantity ; require ( AssetInterface ( order . buyAsset ) . approve ( exchanges [ exchangeNumber ] . exchange , spendQuantity ) ) ; require ( module . riskmgmt . isTakePermitted ( module . pricefeed . getOrderPrice ( order . buyAsset , order . sellAsset , order . buyQuantity , order . sellQuantity ) , referencePrice , order . buyAsset , order . sellAsset , order . buyQuantity , order . sellQuantity ) ) ; require ( address ( exchanges [ exchangeNumber ] . exchangeAdapter ) . delegatecall ( bytes4 ( keccak256 ( ""takeOrder(address,uint256,uint256)"" ) ) , exchanges [ exchangeNumber ] . exchange , id , receiveQuantity ) ) ; if ( ! isInAssetList [ order . sellAsset ] ) { ownedAssets . push ( order . sellAsset ) ; isInAssetList [ order . sellAsset ] = true ; } order . exchangeId = id ; order . status = OrderStatus . fullyFilled ; order . orderType = OrderType . take ; order . timestamp = now ; order . fillQuantity = receiveQuantity ; orders . push ( order ) ; OrderUpdated ( id ) ; }
","Takes an active order on the selected exchange
"
"function changeRate ( uint256 _rate ) external whenNotPaused onlyAdmin { require ( _rate > 0 , ""Rate must be greater than 0"" ) ; emit RateChanged ( _rate , rate ) ; rate = _rate ; }
","Changes the rate .
"
"function nextPhase ( ) public onlyOwner { require ( currentPhase . id != PhaseID . Closed , ""already reached the closed phase"" ) ; uint8 nextPhaseNum = uint8 ( currentPhase . id ) + 1 ; if ( PhaseID ( nextPhaseNum ) == PhaseID . First ) { currentPhase = firstPhase ; deadline = now + 365 * 1 days ; } if ( PhaseID ( nextPhaseNum ) == PhaseID . Second ) { currentPhase = secondPhase ; } if ( PhaseID ( nextPhaseNum ) == PhaseID . Third ) { currentPhase = thirdPhase ; } if ( PhaseID ( nextPhaseNum ) == PhaseID . Closed ) { currentPhase = closedPhase ; } emit PhaseEntered ( currentPhase . id ) ; }
","Not for public use !
"
"function getTags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 0 ) ; return availableTags ; }
","Get the tags related to the module factory
"
"function onERC721Received ( address operator , address from , uint256 tokenId , bytes data ) public returns ( bytes4 ) ;
","Handle the receipt of an NFT
"
"function startPreICO ( ) onlyOwner public { require ( state == State . NotStarted ) ; require ( baseRate != 0 ) ; state = State . PreICO ; }
","Start PreICO stage
"
"function setCampaignOwnerById ( bytes32 bidId , address newOwner ) public onlyIfCampaignExists ( ""setCampaignOwnerById"" , bidId ) onlyIfWhitelisted ( ""setCampaignOwnerById"" , msg . sender ) { campaigns [ bidId ] . setOwner ( newOwner ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
","Set a new campaign owner Based on the Campaign id , update the owner of the refered campaign .
"
"function setPrice ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth
"
"function withdrawTokens ( ) onlyOwner public returns ( bool ) { require ( token . transfer ( owner , token . balanceOf ( this ) ) ) ; return true ; }
","Failsafe transfer of tokens for the team to owner wallet .
"
"function withdrawBalance ( ) external { uint256 etherOwed = addressToEtherOwed [ msg . sender ] ; require ( etherOwed > 0 ) ; delete addressToEtherOwed [ msg . sender ] ; outstandingEther -= etherOwed ; msg . sender . transfer ( etherOwed ) ; }
","Withdraw Ether owed to the sender .
"
"function reparametrizeMultisig ( bytes32 msigId , uint unlockTime ) public payable { Multisig storage multisig = multisigs [ msigId ] ; multisig . deposit = add ( multisig . deposit , msg . value ) ; assert ( multisig . unlockTime <= unlockTime ) ; multisig . unlockTime = unlockTime ; }
","Multisig msg.value ether into a multisig and set unlockTime
"
"function renounceOwner ( ) public onlyOwner { emit TransferredOwner ( _owner , address ( 0 ) ) ; _owner = address ( 0 ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function unstakeCommunityTokens ( ) public { uint amount = communityAccount . stakedBalances ( msg . sender ) ; require ( now - communityAccount . timeStaked ( msg . sender ) >= lockupPeriodSeconds ) ; communityAccount . setStakedBalances ( 0 , msg . sender ) ; communityAccount . setTotalStaked ( SafeMath . sub ( communityAccount . totalStaked ( ) , amount ) ) ; require ( communityAccount . transferTokensOut ( address ( communityTokenInstance ) , msg . sender , amount ) ) ; logger . emitGenericLog ( ""unstakeCommunityTokens"" , """" ) ; }
","Checks lockup period and balance before unstaking
"
"function ownersOfArea ( uint256 x , uint256 y , uint256 x2 , uint256 y2 ) external view returns ( address [ ] result ) { require ( x2 > x && y2 > y ) ; require ( x2 <= WIDTH && y2 <= HEIGHT ) ; result = new address [ ] ( ( y2 - y ) * ( x2 - x ) ) ; uint256 r = 0 ; for ( uint256 i = y ; i < y2 ; i ++ ) { uint256 tokenId = i * WIDTH ; for ( uint256 j = x ; j < x2 ; j ++ ) { result [ r ] = pixelIndexToOwner [ tokenId + j ] ; r ++ ; } } }
","Returns the addresses currently assigned ownership of the given pixel area .
"
"function isRedemptionPermitted ( address ofParticipant , uint256 shareQuantity , uint256 receiveQuantity ) view returns ( bool ) { return competitionAddress == ofParticipant ; }
","Checks whether redemption is permitted for a participant
"
"function internalOrderExecution ( Tokens tokens , DEXOrders orders ) internal { transferTokens ( tokens ) ; uint256 tokensLength = tokens . tokenAddresses . length ; uint256 ordersLength = orders . tokenForOrder . length ; uint256 etherBalance = msg . value ; uint256 orderIndex = 0 ; for ( uint256 tokenIndex = 0 ; tokenIndex < tokensLength ; tokenIndex ++ ) { uint256 amountRemaining = tokens . amountToGive [ tokenIndex ] ; uint256 amountObtained = 0 ; while ( orderIndex < ordersLength ) { require ( tokens . tokenAddresses [ tokenIndex ] == orders . tokenForOrder [ orderIndex ] ) ; require ( handlerWhitelist [ orders . exchanges [ orderIndex ] ] ) ; if ( amountRemaining > 0 ) { if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { require ( etherBalance >= amountRemaining ) ; } ( amountRemaining , amountObtained ) = performTrade ( tokens . buyOrSell [ tokenIndex ] , amountRemaining , amountObtained , orders , orderIndex ) ; } orderIndex = SafeMath . add ( orderIndex , 1 ) ; if ( orderIndex == ordersLength || orders . tokenForOrder [ SafeMath . sub ( orderIndex , 1 ) ] != orders . tokenForOrder [ orderIndex ] ) { break ; } } uint256 amountGiven = SafeMath . sub ( tokens . amountToGive [ tokenIndex ] , amountRemaining ) ; require ( orderWasValid ( amountObtained , amountGiven , tokens . amountToObtain [ tokenIndex ] , tokens . amountToGive [ tokenIndex ] ) ) ; if ( tokens . buyOrSell [ tokenIndex ] == BUY ) { etherBalance = SafeMath . sub ( etherBalance , amountGiven ) ; if ( amountObtained > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountObtained ) ) ; } } else { etherBalance = SafeMath . add ( etherBalance , amountObtained ) ; if ( amountRemaining > 0 ) { require ( Token ( tokens . tokenAddresses [ tokenIndex ] ) . transfer ( msg . sender , amountRemaining ) ) ; } } } if ( etherBalance > 0 ) { msg . sender . transfer ( etherBalance ) ; } }
","The orders in this function have been wrapped in structs to reduce the local variable count
"
"function isOps ( address _address ) internal view returns ( bool ) { return ( opsAddress != address ( 0 ) && _address == opsAddress ) || isOwner ( _address ) ; }
","check If the sender is the ops address .
"
"function pushDividendPaymentToAddresses ( uint256 _dividendIndex , address [ ] _payees ) public withPerm ( DISTRIBUTE ) validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; for ( uint256 i = 0 ; i < _payees . length ; i ++ ) { if ( ( ! dividend . claimed [ _payees [ i ] ] ) && ( ! dividend . dividendExcluded [ _payees [ i ] ] ) ) { _payDividend ( _payees [ i ] , dividend , _dividendIndex ) ; } } }
","Issuer can push dividends to provided addresses
"
"function acceptOwnership ( ) { require ( msg . sender == newOwner ) ; OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; }
","accept ownership of the contract
"
"function whitelistUserForTransfers ( address _user ) onlyOwner public { require ( ! isUserAllowedToTransfer ( _user ) ) ; transfersWhitelist [ _user ] = true ; UserAllowedToTransfer ( _user ) ; }
","Adding a user to the whitelist
"
"function setClaimDividendPercentage ( uint256 _claimDividendPercentage ) external onlyCFO { require ( 10000 <= _claimDividendPercentage && _claimDividendPercentage <= 100000 ) ; claimDividendPercentage = _claimDividendPercentage ; }
","Sets the new dividend percentage for unclaimed plots .
"
"function initializeTokenSale ( uint _saleStartTime , uint _saleEndTime , uint _price , uint _amountForSale , address _beneficiary ) public ownerOnly { initializeSale ( _saleStartTime , _saleEndTime , _price , _amountForSale , _beneficiary ) ; }
","Begins the token sale for this token instance
"
"function offerToChannels ( uint256 _venAmount ) onlyOwner { Stage stg = stage ( ) ; require ( stg == Stage . Early || stg == Stage . Normal || stg == Stage . Closed ) ; channelsSold = channelsSold . add ( _venAmount ) ; require ( channelsSold <= channelsLimit ) ; ven . mint ( venVault , _venAmount , true ) ; onSold ( venVault , _venAmount , 0 ) ; }
","manually offer tokens to channels
"
"function _supportsERC165Interface ( address account , bytes4 interfaceId ) private view returns ( bool ) { ( bool success , bool result ) = _callERC165SupportsInterface ( account , interfaceId ) ; return ( success && result ) ; }
","Query if a contract implements an interface , does not check ERC165 support
"
"function requestMortgageId ( Engine engine , LandMarket landMarket , uint256 loanId , uint256 deposit , uint256 landId , TokenConverter tokenConverter ) public returns ( uint256 id ) { require ( engine . getCurrency ( loanId ) == MANA_CURRENCY , ""Loan currency is not MANA"" ) ; address borrower = engine . getBorrower ( loanId ) ; require ( engines [ engine ] , ""Engine not authorized"" ) ; require ( engine . getStatus ( loanId ) == Engine . Status . initial , ""Loan status is not inital"" ) ; require ( msg . sender == borrower || ( msg . sender == engine . getCreator ( loanId ) && creators [ msg . sender ] ) , ""Creator should be borrower or authorized"" ) ; require ( engine . isApproved ( loanId ) , ""Loan is not approved"" ) ; require ( rcn . allowance ( borrower , this ) >= REQUIRED_ALLOWANCE , ""Manager cannot handle borrower's funds"" ) ; require ( tokenConverter != address ( 0 ) , ""Token converter not defined"" ) ; require ( loanToLiability [ engine ] [ loanId ] == 0 , ""Liability for loan already exists"" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 loanAmount = engine . getAmount ( loanId ) ; require ( loanAmount + deposit >= landCost , ""Not enought total amount"" ) ; require ( mana . transferFrom ( msg . sender , this , deposit ) , ""Error pulling mana"" ) ; id = mortgages . push ( Mortgage ( { owner : borrower , engine : engine , loanId : loanId , deposit : deposit , landMarket : landMarket , landId : landId , landCost : landCost , status : Status . Pending , tokenConverter : tokenConverter } ) ) - 1 ; loanToLiability [ engine ] [ loanId ] = id ; emit RequestedMortgage ( { _id : id , _borrower : borrower , _engine : engine , _loanId : loanId , _landMarket : landMarket , _landId : landId , _deposit : deposit , _tokenConverter : tokenConverter } ) ; }
","Request a mortgage with a loan id
"
"function register ( address _darknodeID , bytes _publicKey , uint256 _bond ) external onlyRefunded ( _darknodeID ) { require ( _bond >= minimumBond , ""insufficient bond"" ) ; require ( ren . transferFrom ( msg . sender , address ( this ) , _bond ) , ""bond transfer failed"" ) ; ren . transfer ( address ( store ) , _bond ) ; store . appendDarknode ( _darknodeID , msg . sender , _bond , _publicKey , currentEpoch . blocknumber + minimumEpochInterval , 0 ) ; numDarknodesNextEpoch += 1 ; emit LogDarknodeRegistered ( _darknodeID , _bond ) ; }
","Register a darknode and transfer the bond to this contract .
"
"function createEscrow ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint32 _paymentWindowInSeconds , uint32 _expiry , uint8 _v , bytes32 _r , bytes32 _s ) payable external { bytes32 _tradeHash = keccak256 ( abi . encodePacked ( _tradeID , _seller , _buyer , _value , _fee ) ) ; require ( ! escrows [ _tradeHash ] . exists , ""Trade already exists"" ) ; bytes32 _invitationHash = keccak256 ( abi . encodePacked ( _tradeHash , _paymentWindowInSeconds , _expiry ) ) ; require ( recoverAddress ( _invitationHash , _v , _r , _s ) == relayer , ""Must be relayer"" ) ; require ( block . timestamp < _expiry , ""Signature has expired"" ) ; require ( msg . value == _value && msg . value > 0 , ""Incorrect ether sent"" ) ; uint32 _sellerCanCancelAfter = _paymentWindowInSeconds == 0 ? 1 : uint32 ( block . timestamp ) + _paymentWindowInSeconds ; escrows [ _tradeHash ] = Escrow ( true , _sellerCanCancelAfter , 0 ) ; emit Created ( _tradeHash ) ; }
","Create and fund a new escrow .
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _amount ) ; Approve ( msg . sender , _spender , _amount ) ; return true ; }
","Used to approve someone to spend funds on your behalf
"
"function ( ) public payable { deposit ( msg . sender ) ; }
","The user sends Ether to the pool .
"
"function getClaim ( address issuer , address subject , bytes32 key ) public view returns ( bytes32 ) { if ( hasRole ( issuer , ROLE_ISSUER ) ) { return claims [ subject ] [ key ] . hash ; } else { return bytes32 ( 0 ) ; } }
","Get a claim .
"
"function balanceBlocksIn ( address account , uint256 startBlock , uint256 endBlock ) public view returns ( uint256 ) { require ( startBlock < endBlock ) ; require ( account != address ( 0 ) ) ; if ( balanceBlockNumbers [ account ] . length == 0 || endBlock < balanceBlockNumbers [ account ] [ 0 ] ) return 0 ; uint256 i = 0 ; while ( i < balanceBlockNumbers [ account ] . length && balanceBlockNumbers [ account ] [ i ] < startBlock ) i ++ ; uint256 r ; if ( i >= balanceBlockNumbers [ account ] . length ) r = balances [ account ] [ balanceBlockNumbers [ account ] . length - 1 ] . mul ( endBlock . sub ( startBlock ) ) ; else { uint256 l = ( i == 0 ) ? startBlock : balanceBlockNumbers [ account ] [ i - 1 ] ; uint256 h = balanceBlockNumbers [ account ] [ i ] ; if ( h > endBlock ) h = endBlock ; h = h . sub ( startBlock ) ; r = ( h == 0 ) ? 0 : balanceBlocks [ account ] [ i ] . mul ( h ) . div ( balanceBlockNumbers [ account ] [ i ] . sub ( l ) ) ; i ++ ; while ( i < balanceBlockNumbers [ account ] . length && balanceBlockNumbers [ account ] [ i ] < endBlock ) { r = r . add ( balanceBlocks [ account ] [ i ] ) ; i ++ ; } if ( i >= balanceBlockNumbers [ account ] . length ) r = r . add ( balances [ account ] [ balanceBlockNumbers [ account ] . length - 1 ] . mul ( endBlock . sub ( balanceBlockNumbers [ account ] [ balanceBlockNumbers [ account ] . length - 1 ] ) ) ) ; else if ( balanceBlockNumbers [ account ] [ i - 1 ] < endBlock ) r = r . add ( balanceBlocks [ account ] [ i ] . mul ( endBlock . sub ( balanceBlockNumbers [ account ] [ i - 1 ] ) ) . div ( balanceBlockNumbers [ account ] [ i ] . sub ( balanceBlockNumbers [ account ] [ i - 1 ] ) ) ) ; } return r ; }
","Calculate the amount of balance blocks , i.e .
"
"function setSymbol ( string _symbol ) onlyAccountAddressForSponsee { symbol = _symbol ; LogSetSymbol ( _symbol ) ; }
","Change symbol .
"
"function addToWhitelist ( address _sender , uint256 _plannedContribution ) public onlyOwner { require ( whitelist [ _sender ] == 0 ) ; whitelist [ _sender ] = _plannedContribution ; whitelistedPlannedContributions = whitelistedPlannedContributions . add ( _plannedContribution ) ; }
","Adds to the whitelist
"
"function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; assert ( c >= a ) ; return c ; }
","Adds two numbers , throws on overflow .
"
"function pricesAreStale ( ) public view returns ( bool ) { return lastPriceUpdateTime . add ( priceStalePeriod ) < now ; }
","Check if the prices have n't been updated for longer than the stale period .
"
"function createGame ( bytes32 _endHash ) public payable onlyValidValue onlyValidHouseStake ( activeGames + 1 ) onlyNotPaused { address playerAddress = msg . sender ; uint previousGameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ previousGameId ] ; require ( game . status == GameStatus . ENDED ) ; uint gameId = gameIdCntr ++ ; playerGameId [ playerAddress ] = gameId ; Game storage newGame = gameIdGame [ gameId ] ; newGame . stake = msg . value ; newGame . status = GameStatus . WAITING_FOR_SERVER ; activeGames = activeGames + 1 ; LogGameCreated ( playerAddress , gameId , msg . value , _endHash ) ; }
","Create games session request .
"
"function execScript ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { require ( _blacklist . length == 0 ) ; require ( _script . length == SCRIPT_START_LOCATION + 20 ) ; return delegate ( _script . addressAt ( SCRIPT_START_LOCATION ) , _input ) ; }
","Executes script by delegatecall into a contract
"
"function changeHatchEscapeCaller ( address _newEscapeHatchCaller ) public onlyEscapeHatchCallerOrOwner { escapeHatchCaller = _newEscapeHatchCaller ; }
","Changes the address assigned to call ` escapeHatch ( ) `
"
"function setODEMClaim ( address subject , bytes32 key , bytes uri , bytes32 hash ) public onlyRole ( ROLE_ISSUER ) { address resolved = resolveAddress ( subject ) ; claims [ resolved ] [ key ] . uri = uri ; claims [ resolved ] [ key ] . hash = hash ; hasClaims [ resolved ] = true ; emit ClaimSet ( msg . sender , subject , key , hash , now ) ; }
","Set an ODEM claim .
"
"function isAdmin ( address _address ) public view returns ( bool ) { if ( _address == owner ( ) ) { return true ; } return admins [ _address ] ; }
","Checks if an address is an administrator .
"
"function setExchangeRate ( uint256 _sellExchangeRate , uint256 _buyExchangeRate ) onlyOwner public { sellExchangeRate = _sellExchangeRate ; buyExchangeRate = _buyExchangeRate ; }
","Allow users to buy tokens for ` _buyExchangeRate ` eth and sell tokens for ` _sellExchangeRate ` eth
"
"function authorizePayment ( bytes32 _ref , address _dest , uint _amount ) public onlyLiquidPledging returns ( uint ) { uint idPayment = payments . length ; payments . length ++ ; payments [ idPayment ] . state = PaymentStatus . Pending ; payments [ idPayment ] . ref = _ref ; payments [ idPayment ] . dest = _dest ; payments [ idPayment ] . amount = _amount ; AuthorizePayment ( idPayment , _ref , _dest , _amount ) ; if ( autoPay ) { doConfirmPayment ( idPayment ) ; } return idPayment ; }
","` onlyLiquidPledging ` authorizes payments from this contract , if ` autoPay == true ` the transfer happens automatically ` else ` the ` owner ` must call ` confirmPayment ( ) ` for a transfer to occur ( training wheels ) ; either way , a new payment is added to ` payments [ ] `
"
"function reclaimTokenOwnership ( ) onlyOwner public { token . claimOwnership ( ) ; }
","Allows transfer token ownership back to distribution contract
"
"function transferAndCall ( address _to , uint256 _value , bytes _data ) public returns ( bool ) ;
","Transfer tokens from ` msg.sender ` to another address and then call ` onTransferReceived ` on receiver
"
"function transferProfitToHouse ( ) public { require ( lastProfitTransferTimestamp + profitTransferTimeSpan <= block . timestamp ) ; if ( houseProfit <= 0 ) { lastProfitTransferTimestamp = block . timestamp ; return ; } uint toTransfer = uint ( houseProfit ) ; assert ( houseStake >= toTransfer ) ; houseProfit = 0 ; lastProfitTransferTimestamp = block . timestamp ; houseStake = houseStake - toTransfer ; houseAddress . transfer ( toTransfer ) ; }
","Transfer house profit to houseAddress .
"
"function addProject ( string name , string url , address projectAdmin , uint64 parentProject , uint64 commitTime , ILiquidPledgingPlugin plugin ) returns ( uint64 idProject ) { require ( isValidPlugin ( plugin ) ) ; if ( parentProject != 0 ) { PledgeAdmin storage pa = findAdmin ( parentProject ) ; require ( pa . adminType == PledgeAdminType . Project ) ; require ( getProjectLevel ( pa ) < MAX_SUBPROJECT_LEVEL ) ; } idProject = uint64 ( admins . length ) ; admins . push ( PledgeAdmin ( PledgeAdminType . Project , projectAdmin , name , url , commitTime , parentProject , false , plugin ) ) ; ProjectAdded ( idProject ) ; }
","Creates a Project Admin with the ` msg.sender ` as the Admin addr
"
"function approve ( address spender , uint quantity ) public pausableIfNotSelfDestructing returns ( bool ) { require ( spender != address ( 0 ) , ""Approvals for 0x0 disallowed."" ) ; allowance [ msg . sender ] [ spender ] = quantity ; emit Approval ( msg . sender , spender , quantity ) ; return true ; }
","ERC20 approve function ; approves ` spender ` to transfer up to ` quantity ` tokens on the sender 's behalf .
"
"function preAllocate ( address _to , uint256 _value , uint256 _price ) onlyOwner { require ( block . timestamp < START_DATE ) ; balances [ this ] = safeSub ( balances [ this ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; soldAmount = safeAdd ( soldAmount , _value ) ; paidAmount = safeAdd ( paidAmount , _price ) ; Transfer ( this , _to , _value ) ; }
","Pre-allocate tokens to advisor or partner
"
"function totalSupply ( ) public view returns ( uint256 ) { return erc20Impl . totalSupply ( ) ; }
","Returns the total token supply .
"
"function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 3 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 6 ) ) ) { require ( collectedTokens < total . percent ( 25 ) ) ; canExtract = total . percent ( 25 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 6 ) ) && getTime ( ) <= finalizedTime . add ( months ( 9 ) ) ) { require ( collectedTokens < total . percent ( 50 ) ) ; canExtract = total . percent ( 50 ) ; } else if ( getTime ( ) > finalizedTime . add ( months ( 9 ) ) && getTime ( ) <= finalizedTime . add ( months ( 12 ) ) ) { require ( collectedTokens < total . percent ( 75 ) ) ; canExtract = total . percent ( 75 ) ; } else { canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }
","The owner will call this method to extract the tokens
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( ( totalDistributed == hardCap || now > SaleDeadline ) && state != State . Successful && state != State . Paused ) { pending [ creator ] = tokenReward . balanceOf ( address ( this ) ) . sub ( totalDistributed ) ; state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } }
","Process to check contract current status
"
"function extractAddress ( bytes data , uint offset ) internal pure returns ( address m ) { require ( offset >= 0 && offset + 20 <= data . length , ""offset value should be in the correct range"" ) ; assembly { m := and ( mload ( add ( data , add ( 20 , offset ) ) ) , 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) } }
","Extracts an address in a bytes .
"
"function setNonlistedUser ( address _who ) public onlyValidator { _setNonlistedUser ( _who ) ; }
","Sets the necessary permissions for a `` nonlisted '' user .
"
"function revealVote ( uint _pollID , uint _voteOption , uint _salt ) public { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( abi . encodePacked ( _voteOption , _salt ) ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; pollMap [ _pollID ] . voteOptions [ msg . sender ] = _voteOption ; emit _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender , _salt ) ; }
","Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens
"
"function createMarket ( string question , uint32 timeout , uint32 opening_ts , address asker , uint256 nonce , address designated_reporter ) onlyInitialized external payable { bytes32 question_id = keccak256 ( keccak256 ( template_id , opening_ts , question ) , this , timeout , asker , nonce ) ; require ( realitio_questions [ question_id ] . bounty > 0 , ""Arbitration must have been requested (paid for)"" ) ; require ( realitio_questions [ question_id ] . augur_market == IMarket ( 0x0 ) , ""The market must not have been created yet"" ) ; _callAugurMarketCreate ( question_id , question , designated_reporter ) ; }
","Create a market in Augur and store the creator as its owner
"
"function registerEOSAddress ( string eosAddress ) public { assert ( bytes ( eosAddress ) . length <= 64 ) ; eosAddressBook [ msg . sender ] = eosAddress ; emit LogRegisterEOSAddress ( msg . sender , eosAddress ) ; }
","Associate a string , which represents an EOS address , to the Ethereum address of the entity interacting with the contract
"
"function pauseIssuance ( ) public onlyOwner whenNotPaused whenIssuanceNotPaused { _issuancePaused = true ; emit IssuancePaused ( ) ; }
","Pause all issuance of new attributes by organizations .
"
"function startTokenVotes ( address [ 15 ] tokens ) public onlyAdmins { uint _proposalId = tokenBatches . length ; if ( _proposalId > 0 ) { TokenProposal memory op = tokenBatches [ _proposalId - 1 ] ; DestructibleMiniMeToken ( op . votingToken ) . recycle ( ) ; } tokenBatches . length ++ ; TokenProposal storage p = tokenBatches [ _proposalId ] ; p . duration = VOTING_DURATION * ( 1 days ) ; p . consideredTokens = tokens ; p . votingToken = tokenFactory . createDestructibleCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( ""EfxTokenVotes-"" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( ""EfxTokenVotes-"" , _proposalId ) , true ) ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; emit NewTokens ( _proposalId ) ; }
","Admins are able to approve proposal that someone submitted
"
"function isGroupInPolicy ( bytes32 _policyHash , bytes32 _groupName ) public view returns ( bool ) { Policy storage _policy = policyId2policy [ _policyHash ] ; return _policy . groupName2index [ _groupName ] != 0 ; }
","Check policy include target group
"
"function _balanceOf ( uint _holderId , bytes32 _symbol ) public view returns ( uint ) { return assets [ _symbol ] . wallets [ _holderId ] . balance ; }
","Returns asset balance for a particular holder id .
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) ;
","will be called on ` _spender ` address
"
"function depositEther ( ) external payable onlyActiveState { require ( msg . value > 0 , 'Invalid value' ) ; balances [ msg . sender ] [ etherAddr ] = balances [ msg . sender ] [ etherAddr ] . add ( msg . value ) ; emit BalanceIncrease ( msg . sender , etherAddr , msg . value , ReasonDeposit ) ; }
","Deposits Ethereum tokens under the ` msg.sender ` 's balance
"
"function approveAll ( address _to ) public { require ( _to != msg . sender , ""cant approve yourself"" ) ; require ( _to != address ( 0 ) , ""invalid owner"" ) ; operatorApprovals [ msg . sender ] [ _to ] = true ; emit ApprovalForAll ( msg . sender , _to , true ) ; }
","Approves another address to claim for the ownership of any tokens owned by this account
"
"function _changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) internal { perms [ _module ] [ _delegate ] [ _perm ] = _valid ; emit ChangePermission ( _delegate , _module , _perm , _valid , now ) ; }
","Used to provide/change the permission to the delegate corresponds to the module contract
"
"function decreaseApproval ( address _spender , uint256 _subtractedValue ) public returns ( bool ) { require ( ! freezeTransfer || isOps ( ) , ""all transfers are currently frozen"" ) ; require ( _spender != address ( 0 ) , ""zero address is not allowed"" ) ; require ( _subtractedValue >= 1000 , ""must approve more than 1000 sip"" ) ; uint256 oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }
","Decrease the amount of tokens that an owner allowed to a spender .
"
"function setRegisteredAuthority ( string firmName , address authority , bool _authorized ) public onlyAuthority ( firmName , msg . sender ) returns ( bool success ) { require ( lib . setRegisteredAuthority ( firmName , authority , _authorized ) , ""Error: Failed to register authority for issuer firm with storage contract! Please check your arguments and ensure firmName is registered before allowing an authority of said firm"" ) ; return true ; }
","Registers an authority asoociated with the given firm as true/false
"
"function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) { uint256 discount = 0 ; if ( _etherAmount > minDiscountEther && _etherAmount <= firstTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( FIRST_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > firstTierDiscountUpperLimitEther && _etherAmount <= secondTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( SECOND_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > secondTierDiscountUpperLimitEther && _etherAmount <= thirdTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( THIRD_TIER_DISCOUNT ) . div ( 100 ) ; } else if ( _etherAmount > thirdTierDiscountUpperLimitEther ) { discount = _contributorTokens . mul ( FOURTH_TIER_DISCOUNT ) . div ( 100 ) ; } DiscountApplied ( _etherAmount , _contributorTokens , discount ) ; return discount . add ( _contributorTokens ) ; }
","Applies the discount based on the discount tiers
"
"function _transferFrom ( address _from , address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _approvedFor ( _to , _tokenId ) ) ; ethernautsStorage . transfer ( _from , _to , _tokenId ) ; }
","Transfer a Asset owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function getEndDate ( Campaign storage _campaign ) internal view returns ( uint _endDate ) { return _campaign . endDate ; }
","Get campaign end date
"
"function transfer ( address _to , uint256 _tokenId ) external whenNotPaused onlyOwnerOf ( _tokenId ) { _clearApprovalAndTransfer ( msg . sender , _to , _tokenId ) ; }
","Transfers the ownership of a given token ID to another address
"
"function allBalancesOf ( address owner ) external constant returns ( uint256 [ 2 ] [ ] ) { Values [ ] storage values = _balances [ owner ] ; uint256 [ 2 ] [ ] memory balances = new uint256 [ 2 ] [ ] ( values . length ) ; for ( uint256 ii = 0 ; ii < values . length ; ++ ii ) { balances [ ii ] = [ values [ ii ] . snapshotId , values [ ii ] . value ] ; } return balances ; }
","gets all token balances of 'owner '
"
"function _addTicker ( address _owner , string _ticker , string _tokenName , uint256 _registrationDate , uint256 _expiryDate , bool _status , bool _fromAdmin , uint256 _fee ) internal { _setTickerOwnership ( _owner , _ticker ) ; _storeTickerDetails ( _ticker , _owner , _registrationDate , _expiryDate , _tokenName , _status ) ; emit RegisterTicker ( _owner , _ticker , _tokenName , _registrationDate , _expiryDate , _fromAdmin , _fee ) ; }
","Internal - Sets the details of the ticker
"
"function addPartOwner ( address _partowner ) external onlyContractOwner returns ( uint ) { partowners [ _partowner ] = true ; return OK ; }
","Adds a co-owner of a contract .
"
"function numberOfProposals ( ) public view returns ( uint ) { return tokenBatches . length ; }
","Get number of proposals so you can know which is the last one
"
"function setPaymentStatus ( uint256 _paymentId , bool _active ) external authP ( MANAGE_PAYMENTS_ROLE , arr ( _paymentId , uint256 ( _active ? 1 : 0 ) ) ) paymentExists ( _paymentId ) { payments [ _paymentId ] . inactive = ! _active ; emit ChangePaymentState ( _paymentId , _active ) ; }
","` _active ?
"
"function addSupplier ( SupplierInterface supplier , bool add ) public onlyAdmin { if ( add ) { require ( ! isSupplier [ supplier ] ) ; suppliers . push ( supplier ) ; isSupplier [ supplier ] = true ; emit AddSupplier ( supplier , true ) ; } else { isSupplier [ supplier ] = false ; for ( uint i = 0 ; i < suppliers . length ; i ++ ) { if ( suppliers [ i ] == supplier ) { suppliers [ i ] = suppliers [ suppliers . length - 1 ] ; suppliers . length -- ; emit AddSupplier ( supplier , false ) ; break ; } } } }
","can be called only by admin
"
"function setFxBpsRate ( string currency , uint bpsRate , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setFxUSDBPSRate ( currency , bpsRate ) , ""Error: Unable to set FX USD basis points rate. Please ensure issuerFirm is authorized"" ) ; return true ; }
","Set the foreign currency exchange rate to USD in basis points
"
"function releaseForeignToken ( ERC20 _token , uint256 amount ) onlyOwner public { require ( _token != token ) ; _token . transfer ( owner , amount ) ; }
","Allow withdrawing any token other than the relevant one
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address _owner ) { return IndexToOwner [ _tokenId ] ; }
","Find the owner of a rare item
"
"function getFeeMin ( Data storage self , address contractAddress ) internal view returns ( uint feeMin ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.min' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }
","Get the minimum fee of the contract address ; typically TokenIOFeeContract
"
"function pauseGame ( uint256 _gameID , bool _paused ) external isActivated ( _gameID ) isOngoing ( _gameID ) isOwner ( ) { game_ [ _gameID ] . paused = _paused ; emit onGamePaused ( _gameID , _paused , now ) ; }
","Pause a game .
"
"function hasRole ( address addr , string role ) public view returns ( bool ) { return roles [ addr ] [ role ] ; }
","Check if an address has a role .
"
"function withdrawPendingAmounts ( ) returns ( bool ) ;
","Function to get fees , shares or refund after the closing time of the funding proposals
"
"function calculatePrice ( uint [ ] _pickedAssets , address _owner ) public view returns ( uint ) { if ( _pickedAssets . length == 0 ) { return 0 ; } uint [ ] memory pickedAssetPacks = assetManager . pickUniquePacks ( _pickedAssets ) ; uint finalPrice = 0 ; for ( uint i = 0 ; i < pickedAssetPacks . length ; i ++ ) { if ( assetManager . checkHasPermissionForPack ( _owner , pickedAssetPacks [ i ] ) == false ) { finalPrice += assetManager . getAssetPackPrice ( pickedAssetPacks [ i ] ) ; } } return finalPrice ; }
","Function to calculate final price for an image based on selected assets
"
"function getAccountSpendingPeriod ( Data storage self , address account ) internal view returns ( uint period ) { bytes32 id = keccak256 ( abi . encodePacked ( 'limit.spending.period' , account ) ) ; return self . Storage . getUint ( id ) ; }
","Get the Account Spending Period Limit as UNIX timestamp
"
"function releaseTransfer ( bytes32 sha , uint8 v , bytes32 r , bytes32 s ) public returns ( bool ) { require ( msg . sender == biometricFrom [ sha ] ) ; require ( ! biometricCompleted [ sha ] ) ; bytes32 transferFromSha = keccak256 ( ""transferFrom"" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; bytes32 transferSha = keccak256 ( ""transfer"" , biometricFrom [ sha ] , biometricTo [ sha ] , biometricAmount [ sha ] , biometricNow [ sha ] ) ; require ( sha == transferSha || sha == transferFromSha ) ; require ( verify ( sha , v , r , s ) == true ) ; if ( transferFromSha == sha ) { address _spender = biometricAllowee [ sha ] ; address _from = biometricFrom [ sha ] ; address _to = biometricTo [ sha ] ; uint256 _value = biometricAmount [ sha ] ; require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ _spender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; } if ( transferSha == sha ) { super . transfer ( biometricTo [ sha ] , biometricAmount [ sha ] ) ; } biometricCompleted [ sha ] = true ; return true ; }
","Complete pending transfer , can only be called by msg.sender if it is the originator of Transfer
"
"function private_list_bytes_from_bytes ( bytes32 _current_item , uint256 _count , bool _including_current , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next ) private constant returns ( bytes32 [ ] _bytes32_items ) { uint256 _i ; uint256 _real_count = 0 ; bytes32 _last_item ; _last_item = _function_last ( ) ; if ( _count == 0 || _last_item == bytes32 ( 0x0 ) ) { _bytes32_items = new bytes32 [ ] ( 0 ) ; } else { bytes32 [ ] memory _items_temp = new bytes32 [ ] ( _count ) ; bytes32 _this_item ; if ( _including_current == true ) { _items_temp [ 0 ] = _current_item ; _real_count = 1 ; } _this_item = _current_item ; for ( _i = _real_count ; ( _i < _count ) && ( _this_item != _last_item ) ; _i ++ ) { _this_item = _function_next ( _this_item ) ; if ( _this_item != bytes32 ( 0x0 ) ) { _real_count ++ ; _items_temp [ _i ] = _this_item ; } } _bytes32_items = new bytes32 [ ] ( _real_count ) ; for ( _i = 0 ; _i < _real_count ; _i ++ ) { _bytes32_items [ _i ] = _items_temp [ _i ] ; } } }
","A private function to lists a Bytes collection starting from some ` _current_item ` ( which could be included or excluded ) , in the forwards or backwards direction
"
"function deedOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < countOfDeedsByOwner ( _owner ) ) ; uint256 seen = 0 ; uint256 totalDeeds = countOfDeeds ( ) ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = identifiers [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { if ( seen == _index ) { return identifier ; } seen ++ ; } } }
","Returns a deed identifier of the owner at the given index .
"
"function createAndJoinCDP ( ) public stoppable payable returns ( bytes32 id ) { require ( msg . value >= minETH ) ; gem . deposit . value ( msg . value ) ( ) ; id = _openAndJoinCDPWETH ( msg . value ) ; tub . give ( id , msg . sender ) ; }
","create a CDP and join with the ETH sent to this function
"
"function calculateGrantClaim ( address _recipient ) public view returns ( uint16 , uint128 ) { Grant storage tokenGrant = tokenGrants [ _recipient ] ; if ( now < tokenGrant . startTime ) { return ( 0 , 0 ) ; } uint elapsedTime = sub ( now , tokenGrant . startTime ) ; uint elapsedMonths = elapsedTime / SECONDS_PER_MONTH ; if ( elapsedMonths < tokenGrant . vestingCliff ) { return ( 0 , 0 ) ; } if ( elapsedMonths >= tokenGrant . vestingDuration ) { uint128 remainingGrant = tokenGrant . amount - tokenGrant . totalClaimed ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint16 monthsVested = uint16 ( sub ( elapsedMonths , tokenGrant . monthsClaimed ) ) ; uint amountVestedPerMonth = tokenGrant . amount / tokenGrant . vestingDuration ; uint128 amountVested = uint128 ( mul ( monthsVested , amountVestedPerMonth ) ) ; return ( monthsVested , amountVested ) ; } }
","Calculate the vested and unclaimed months and tokens available for ` _recepient ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached
"
"function finalize ( ) public onlyOwner initialized { require ( time ( ) >= startTime ) ; require ( finalizedBlock == 0 ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; uint256 tokensToSecondRound = 90000000 ether ; uint256 tokensToReserve = 90000000 ether ; uint256 tokensToAngelAndOther = 30000000 ether ; tokensToSecondRound = tokensToSecondRound . add ( maxFirstRoundTokenLimit ) . sub ( totalNormalTokenGenerated ) ; tokensToSecondRound = tokensToSecondRound . add ( maxIssueTokenLimit ) . sub ( totalIssueTokenGenerated ) ; uint256 totalTokens = 300000000 ether ; require ( totalTokens == ATT . totalSupply ( ) . add ( tokensToSecondRound ) . add ( tokensToReserve ) . add ( tokensToAngelAndOther ) ) ; assert ( ATT . generateTokens ( 0xb1 , tokensToSecondRound ) ) ; assert ( ATT . generateTokens ( 0xb2 , tokensToReserve ) ) ; assert ( ATT . generateTokens ( destTokensAngel , tokensToAngelAndOther ) ) ; ATT . changeController ( attController ) ; Finalized ( ) ; }
","This method will can be called by the owner before the contribution period end or by anybody after the ` endBlock ` .
"
"function setCommissionRate ( uint256 commissionRateInWei ) isOwner { require ( commissionRateInWei >= 0 ) ; commissionRate = commissionRateInWei ; }
","Set the current commission rate
"
"function submitAnswer ( bytes32 question_id , bytes32 answer , uint256 max_previous ) stateOpen ( question_id ) bondMustDouble ( question_id ) previousBondMustNotBeatMaxPrevious ( question_id , max_previous ) external payable { _addAnswerToHistory ( question_id , answer , msg . sender , msg . value , false ) ; _updateCurrentAnswer ( question_id , answer , questions [ question_id ] . timeout ) ; }
","Submit an answer for a question .
"
"function revoke ( bytes32 _key ) external returns ( uint ) { return _revoke ( _key , msg . sender ) ; }
","Revoke vote for transaction Can be called only by authorized user
"
"function approve ( address _spender , uint256 _value ) public userNotBlacklisted ( _spender ) userNotBlacklisted ( msg . sender ) whenNotPaused whenUnlocked returns ( bool ) { tokenStorage . setAllowance ( msg . sender , _spender , _value ) ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","Implements ERC-20 standard approve function .
"
"function withdraw ( uint256 _gameID ) external isHuman ( ) isActivated ( _gameID ) isEnded ( _gameID ) { require ( now < game_ [ _gameID ] . withdrawDeadline , ""withdraw deadline already passed"" ) ; require ( gameStatus_ [ _gameID ] . fundCleared == false , ""fund already cleared"" ) ; uint256 _pID = FSBook . pIDxAddr_ ( msg . sender ) ; require ( _pID != 0 , ""player has not played this game"" ) ; require ( players_ [ _pID ] [ _gameID ] . withdrawn == false , ""player already cashed out"" ) ; players_ [ _pID ] [ _gameID ] . withdrawn = true ; if ( game_ [ _gameID ] . canceled ) { uint256 _totalInvestment = players_ [ _pID ] [ _gameID ] . eth . mul ( 95 ) / 100 ; if ( _totalInvestment > 0 ) { FSBook . getPlayerAddr ( _pID ) . transfer ( _totalInvestment ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalInvestment . add ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; } emit FSEvents . onWithdraw ( _gameID , _pID , msg . sender , FSBook . getPlayerName ( _pID ) , _totalInvestment , now ) ; } else { uint256 _totalWinnings = getPlayerInstWinning ( _gameID , _pID , game_ [ _gameID ] . winnerTeam ) . add ( getPlayerPotWinning ( _gameID , _pID , game_ [ _gameID ] . winnerTeam ) ) ; if ( _totalWinnings > 0 ) { FSBook . getPlayerAddr ( _pID ) . transfer ( _totalWinnings ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalWinnings . add ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; } emit FSEvents . onWithdraw ( _gameID , _pID , msg . sender , FSBook . getPlayerName ( _pID ) , _totalWinnings , now ) ; } }
","Withdraw winnings .
"
"function getFinalizeTS ( bytes32 question_id ) public view returns ( uint32 ) { return questions [ question_id ] . finalize_ts ; }
","Returns the timestamp at which the question will be/was finalized
"
"function isOwner ( address _address ) internal view returns ( bool ) { return ( _address == owner ) ; }
","checks If the sender is the owner of the contract .
"
"function setNextGameSettings ( uint256 rows , uint256 cols , uint256 initialActivityTimer , uint256 finalActivityTimer , uint256 numberOfFlipsToFinalActivityTimer , uint256 timeoutBonusTime , uint256 unclaimedTilePrice , uint256 buyoutReferralBonusPercentage , uint256 firstBuyoutPrizePoolPercentage , uint256 buyoutPrizePoolPercentage , uint256 buyoutDividendPercentage , uint256 buyoutFeePercentage , uint256 buyoutPriceIncreasePercentage ) public onlyCFO { require ( 2000 <= buyoutDividendPercentage && buyoutDividendPercentage <= 12500 ) ; require ( buyoutFeePercentage <= 5000 ) ; if ( numberOfFlipsToFinalActivityTimer == 0 ) { require ( initialActivityTimer == finalActivityTimer ) ; } nextGameSettings = GameSettings ( { rows : rows , cols : cols , initialActivityTimer : initialActivityTimer , finalActivityTimer : finalActivityTimer , numberOfFlipsToFinalActivityTimer : numberOfFlipsToFinalActivityTimer , timeoutBonusTime : timeoutBonusTime , unclaimedTilePrice : unclaimedTilePrice , buyoutReferralBonusPercentage : buyoutReferralBonusPercentage , firstBuyoutPrizePoolPercentage : firstBuyoutPrizePoolPercentage , buyoutPrizePoolPercentage : buyoutPrizePoolPercentage , buyoutDividendPercentage : buyoutDividendPercentage , buyoutFeePercentage : buyoutFeePercentage , buyoutPriceIncreasePercentage : buyoutPriceIncreasePercentage } ) ; NextGame ( rows , cols , initialActivityTimer , finalActivityTimer , numberOfFlipsToFinalActivityTimer , timeoutBonusTime , unclaimedTilePrice , buyoutReferralBonusPercentage , firstBuyoutPrizePoolPercentage , buyoutPrizePoolPercentage , buyoutDividendPercentage , buyoutFeePercentage , buyoutPriceIncreasePercentage ) ; }
","Sets the settings for the next game .
"
"function cancelQuery ( uint256 id ) external { address subscriber = getSubscriber ( id ) ; address provider = getProvider ( id ) ; bytes32 endpoint = getEndpoint ( id ) ; require ( subscriber == msg . sender , ""Error: Wrong subscriber"" ) ; require ( Status ( getStatus ( id ) ) == Status . Pending , ""Error: Query is not pending"" ) ; setCanceled ( id , true ) ; bondage . returnDots ( subscriber , provider , endpoint , 1 ) ; emit CanceledRequest ( id , getSubscriber ( id ) , getProvider ( id ) ) ; }
","Cancel a query .
"
"function investors ( uint256 _index ) external view returns ( address ) ;
","Gets an investor at a particular index
"
"function proxyPayment ( address _owner ) payable returns ( bool ) { doPayment ( _owner ) ; return true ; }
","` proxyPayment ( ) ` allows the caller to send ether to the Campaign and have the tokens created in an address of their choosing
"
"function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { bytes32 hash = sha256 ( abi . encodePacked ( address ( exchange ) , data . takerToken , data . takerAmount , data . makerToken , data . makerAmount , data . expires , data . nonce ) ) ; if ( ecrecover ( sha3 ( abi . encodePacked ( ""\x19Ethereum Signed Message:\n32"" , hash ) ) , data . v , data . r , data . s ) != data . user || block . number > data . expires ) { return false ; } return true ; }
","Perform exchange-specific checks on the given order
"
"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 result ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , ""Error: Unsafe multiplication operation!"" ) ; return c ; }
","Multiplies two numbers , throws on overflow .
"
"function updateLandData ( uint256 id , string data ) external returns ( bool ) { require ( _isAuthorized ( msg . sender , id ) , ""Sender not authorized"" ) ; ( int256 x , int256 y ) = land . decodeTokenId ( mortgages [ id ] . landId ) ; land . updateLandData ( x , y , data ) ; emit UpdatedLandData ( msg . sender , id , data ) ; return true ; }
","Enables the owner of a parcel to update the data field
"
"function setCampaignBudgetById ( bytes32 bidId , uint newBudget ) public onlyIfCampaignExists ( ""setCampaignBudgetById"" , bidId ) onlyIfWhitelisted ( ""setCampaignBudgetById"" , msg . sender ) { campaigns [ bidId ] . setBudget ( newBudget ) ; emitCampaignUpdated ( campaigns [ bidId ] ) ; }
","Set a new campaign budget Based on the Campaign id , updates the total value avaliable for proof of attention registrations .
"
"function earlySafeWithdrawal ( uint256 _amount ) public onlyOwner { require ( fundingGoalReached , ""funding goal has not been reached"" ) ; require ( beneficiary == msg . sender , ""message sender is not the beneficiary"" ) ; require ( address ( this ) . balance >= _amount , ""contract has less ether in balance than requested"" ) ; beneficiary . transfer ( _amount ) ; emit FundsWithdrawal ( beneficiary , _amount ) ; }
","Not for public use !
"
"function setBool ( bytes32 _key , bool _value ) public onlyOwner returns ( bool success ) { boolStorage [ _key ] = _value ; return true ; }
","Set value for Bool associated with bytes32 id key
"
"function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return _operator == _tokenHolder || mAuthorized [ _operator ] [ _tokenHolder ] ; }
","Check whether the ` _operator ` address is allowed to manage the tokens held by ` _tokenHolder ` address .
"
"function setCreator ( address creator , bool authorized ) external onlyOwner returns ( bool ) { emit SetCreator ( creator , authorized ) ; creators [ creator ] = authorized ; return true ; }
","Sets a new third party creator The third party creator can request loans for other borrowers .
"
"function _revokeAttribute ( address account ) internal returns ( bool ) { _jurisdiction . revokeAttribute ( account , _validAttributeTypeID ) ; return true ; }
","Revoke an attribute of the type with ID ` attributeTypeID ` from account ` account ` on the jurisdiction .
"
"function addBalance ( address _owner , uint256 _balanceIncrease ) public onlyImpl { balances [ _owner ] = balances [ _owner ] + _balanceIncrease ; }
","Adds ` _balanceIncrease ` to ` _owner ` 's balance .
"
"function isPresent ( bytes32 channelId ) public view returns ( bool ) { return ! isAbsent ( channelId ) ; }
","Check if the channel is present : in open or settling state .
"
"function getChannelInfo ( address _sender_address , address _receiver_address , uint32 _open_block_number ) external view returns ( bytes32 , uint192 , uint32 , uint192 , uint192 ) { bytes32 key = getKey ( _sender_address , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > 0 ) ; return ( key , channels [ key ] . deposit , closing_requests [ key ] . settle_block_number , closing_requests [ key ] . closing_balance , withdrawn_balances [ key ] ) ; }
","Function for retrieving information about a channel .
"
"function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 9412000000 ; }
","minimum amount of funding to consider the sale as successful ( in euro-cents )
"
"function uint8Min ( uint8 a , uint8 b ) pure internal returns ( uint8 ) { return a > b ? b : a ; }
","Minimum between two uint8 numbers
"
"function symbol ( ) public pure returns ( string _deedSymbol ) { _deedSymbol = ""BURN"" ; }
","Symbol of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata .
"
"function setFeePeriodDuration ( uint _feePeriodDuration ) external optionalProxy_onlyOwner { require ( _feePeriodDuration >= MIN_FEE_PERIOD_DURATION , ""New fee period cannot be less than minimum fee period duration"" ) ; require ( _feePeriodDuration <= MAX_FEE_PERIOD_DURATION , ""New fee period cannot be greater than maximum fee period duration"" ) ; feePeriodDuration = _feePeriodDuration ; emitFeePeriodDurationUpdated ( _feePeriodDuration ) ; }
","Set the fee period duration
"
"function releaseAllVestedToken ( ) public checkGlobalTokenTransferLock returns ( bool ) { emit AllVestedTokenReleased ( ) ; PeriodicTokenVesting tokenVesting ; for ( uint256 i = 0 ; i < vestedAddresses . length ; i ++ ) { tokenVesting = tokenVestingContracts [ vestedAddresses [ i ] ] ; if ( tokenVesting . releasableAmount ( ERC20 ( address ( this ) ) ) > 0 ) { tokenVesting . release ( ERC20 ( address ( this ) ) ) ; emit VestedTokenReleased ( vestedAddresses [ i ] ) ; } } return true ; }
","Transfers vested tokens to all beneficiaries .
"
"function setDefaultExcluded ( address [ ] _excluded ) public withPerm ( MANAGE ) { require ( _excluded . length <= EXCLUDED_ADDRESS_LIMIT , ""Too many excluded addresses"" ) ; for ( uint256 j = 0 ; j < _excluded . length ; j ++ ) { require ( _excluded [ j ] != address ( 0 ) , ""Invalid address"" ) ; for ( uint256 i = j + 1 ; i < _excluded . length ; i ++ ) { require ( _excluded [ j ] != _excluded [ i ] , ""Duplicate exclude address"" ) ; } } excluded = _excluded ; emit SetDefaultExcludedAddresses ( excluded , now ) ; }
","Function to clear and set list of excluded addresses used for future dividends
"
"function tokenURI ( uint256 _tokenId ) external view mustBeValidToken ( _tokenId ) returns ( string _tokenURI ) { _tokenURI = ""https://tenthousandsu.com/erc721/00000.json"" ; bytes memory _tokenURIBytes = bytes ( _tokenURI ) ; _tokenURIBytes [ 33 ] = byte ( 48 + ( _tokenId / 10000 ) % 10 ) ; _tokenURIBytes [ 34 ] = byte ( 48 + ( _tokenId / 1000 ) % 10 ) ; _tokenURIBytes [ 35 ] = byte ( 48 + ( _tokenId / 100 ) % 10 ) ; _tokenURIBytes [ 36 ] = byte ( 48 + ( _tokenId / 10 ) % 10 ) ; _tokenURIBytes [ 37 ] = byte ( 48 + ( _tokenId / 1 ) % 10 ) ; }
","A distinct Uniform Resource Identifier ( URI ) for a given asset .
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external ;
","This works identically to the other function with an extra data parameter , except this function just sets data to `` ''
"
"function fracExp ( uint256 _k , uint256 _q , uint256 _n , uint256 _p ) public pure returns ( uint256 ) { uint256 s = 0 ; uint256 N = 1 ; uint256 B = 1 ; for ( uint256 i = 0 ; i < _p ; ++ i ) { s += _k * N / B / ( _q ** i ) ; N = N * ( _n - i ) ; B = B * ( i + 1 ) ; } return s ; }
","Compute '_k ( 1+1/_q ) ^ _n ' , with precision '_p '
"
"function removeListing ( uint64 _pixelconIndex ) public { Listing storage listing = marketPixelconListings [ _pixelconIndex ] ; require ( listing . seller != address ( 0 ) , ""Market listing does not exist"" ) ; require ( msg . sender == listing . seller || msg . sender == admin , ""Insufficient permissions"" ) ; uint256 tokenId = pixelconsContract . tokenByIndex ( _pixelconIndex ) ; address seller = listing . seller ; clearListingData ( seller , _pixelconIndex ) ; pixelconsContract . transferFrom ( address ( this ) , seller , tokenId ) ; emit Remove ( _pixelconIndex , msg . sender ) ; }
","Remove the PixelCon # ` ( _pixelconIndex ) ` listing from the market
"
"function enableMigration ( IMigrationTarget migration ) public onlyMigrationEnabledOnce ( ) only ( MIGRATION_ADMIN ) { require ( migration . currentMigrationSource ( ) == address ( this ) ) ; _migration = migration ; LogMigrationEnabled ( _migration ) ; }
","should enable migration to migration target
"
"function getFirmFromAuthority ( address authority ) public view returns ( string firm ) { return lib . getFirmFromAuthority ( authority ) ; }
","Gets firm asoociated with an authority address
"
"function getEndTime ( ) internal constant returns ( uint ) ;
","end time of the pre-ICO
"
"function balanceOf ( address _owner ) public view returns ( uint256 ) { return _balance [ _owner ] ; }
","Returns the balance of an account with address ` _owner ` .
"
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { _transfer ( msg . sender , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` from your account
"
"function getStorageAddress ( ) public view returns ( address storageContract ) { require ( msg . sender == address ( advertisementFinance ) ) ; return address ( advertisementStorage ) ; }
","Get Advertisement Storage Address used by this contract This function is required to upgrade Advertisement contract address on Advertisement Finance contract .
"
"function refund ( ) public returns ( bool ) { return refundTo ( msg . sender ) ; }
","Sends all contributed ether back if minimum cap is not reached by the end of crowdsale
"
"function setKyberNetwork ( address _KyberNetwork ) public onlyOperator { KyberNetwork = _KyberNetwork ; }
","Can only be called by operators
"
"function withdrawMILs ( uint256 _MILs ) public postEnd funded { uint256 daysSinceEnd = ( now - lockUpEnd ) / 1 days ; uint256 maxPct = min ( ( ( daysSinceEnd / 30 + 1 ) * 25 ) , 100 ) ; uint256 allowed = award [ msg . sender ] ; allowed = allowed * maxPct / 100 ; allowed -= withdrawn [ msg . sender ] ; require ( _MILs <= allowed ) ; militaryToken . transfer ( msg . sender , _MILs ) ; withdrawn [ msg . sender ] += _MILs ; currentAwards -= _MILs ; }
","Transfers awarded MILs to the caller 's account .
"
"function ableTransfer ( ) ;
","Function to able the transfer of Dao shares or contractor tokens
"
"function _approveEscrow ( bytes32 _id , uint256 _amount ) internal returns ( bool ) { claimable = claimable . add ( _amount ) ; claimableRewards [ _id ] = _amount ; return true ; }
","approve reward amount for transfer from escrow contract to creator
"
"function getTimeout ( bytes32 question_id ) public view returns ( uint32 ) { }
","Returns the timeout in seconds used after each answer
"
"function uncooperativeClose ( address _receiver_address , uint32 _open_block_number , uint192 _balance ) external { bytes32 key = getKey ( msg . sender , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > 0 ) ; require ( closing_requests [ key ] . settle_block_number == 0 ) ; require ( _balance <= channels [ key ] . deposit ) ; closing_requests [ key ] . settle_block_number = uint32 ( block . number ) + challenge_period ; require ( closing_requests [ key ] . settle_block_number > block . number ) ; closing_requests [ key ] . closing_balance = _balance ; ChannelCloseRequested ( msg . sender , _receiver_address , _open_block_number , _balance ) ; }
","Sender requests the closing of the channel and starts the challenge period .
"
"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; cityIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { return false ; }
","Notifies the controller about an approval , for this sale all approvals are allowed by default and no extra notifications are needed
"
"function getEIN ( address _address ) public view _hasIdentity ( _address , true ) returns ( uint ein ) { return associatedAddressDirectory [ _address ] ; }
","Gets the EIN associated with the passed address .
"
"function changeTreasury ( address _newTreasury ) external onlyOwner { treasury = _newTreasury ; emit ChangeTreasury ( msg . sender , _newTreasury ) ; }
","allows owner to change the treasury in case of hack/lost keys .
"
"function ( ) payable public { revert ( ) ; }
","We do n't want your arbitrary ether
"
"function priceIsStale ( ) public view returns ( bool ) { return safeAdd ( lastPriceUpdateTime , priceStalePeriod ) < now ; }
","Check if the price of havvens has n't been updated for longer than the stale period .
"
"function pause ( ) external whenNotPaused onlyOwner { set ( Encoder . getKey ( ""paused"" ) , true ) ; emit Pause ( now ) ; }
","Called by the owner to pause , triggers stopped state
"
"function buy ( ) public payable nonReentrant timedStateChange requiresState ( IcoState . ICO ) fundsChecker returns ( uint ) { address investor = msg . sender ; uint256 payment = msg . value ; require ( payment >= c_MinInvestment ) ; uint startingInvariant = this . balance . add ( m_funds . balance ) ; uint fundsAllowed = getMaximumFunds ( ) . sub ( m_funds . totalInvested ( ) ) ; assert ( 0 != fundsAllowed ) ; payment = fundsAllowed . min256 ( payment ) ; uint256 change = msg . value . sub ( payment ) ; uint stq = calcSTQAmount ( payment ) ; m_token . mint ( investor , stq ) ; m_funds . invested . value ( payment ) ( investor ) ; FundTransfer ( investor , payment , true ) ; if ( change > 0 ) { assert ( getMaximumFunds ( ) == m_funds . totalInvested ( ) ) ; finishICO ( ) ; investor . transfer ( change ) ; assert ( startingInvariant == this . balance . add ( m_funds . balance ) . add ( change ) ) ; } else assert ( startingInvariant == this . balance . add ( m_funds . balance ) ) ; return stq ; }
","ICO participation
"
"function setTrading ( bool status ) public onlyOwner { tradingLive = status ; }
","One-way toggle to allow trading ( remove global freeze )
"
"function _internalExchange ( address from , bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey , address destinationAddress , bool chargeFee ) internal notFeeAddress ( from ) returns ( bool ) { require ( destinationAddress != address ( 0 ) , ""Zero destination"" ) ; require ( destinationAddress != address ( this ) , ""Synthetix is invalid destination"" ) ; require ( destinationAddress != address ( proxy ) , ""Proxy is invalid destination"" ) ; synths [ sourceCurrencyKey ] . burn ( from , sourceAmount ) ; uint destinationAmount = effectiveValue ( sourceCurrencyKey , sourceAmount , destinationCurrencyKey ) ; uint amountReceived = destinationAmount ; uint fee = 0 ; if ( chargeFee ) { amountReceived = feePool . amountReceivedFromExchange ( destinationAmount ) ; fee = destinationAmount . sub ( amountReceived ) ; } synths [ destinationCurrencyKey ] . issue ( destinationAddress , amountReceived ) ; if ( fee > 0 ) { uint xdrFeeAmount = effectiveValue ( destinationCurrencyKey , fee , ""XDR"" ) ; synths [ ""XDR"" ] . issue ( feePool . FEE_ADDRESS ( ) , xdrFeeAmount ) ; } synths [ destinationCurrencyKey ] . triggerTokenFallbackIfNeeded ( from , destinationAddress , amountReceived ) ; return true ; }
","Function that allows synth contract to delegate sending fee to the fee Pool .
"
"function hasAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; return ( ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) || ( _attributeTypes [ attributeTypeID ] . secondarySource != address ( 0 ) && secondaryHasAttribute ( _attributeTypes [ attributeTypeID ] . secondarySource , account , _attributeTypes [ attributeTypeID ] . secondaryAttributeTypeID ) ) ) ; }
","Check if an attribute of the type with ID ` attributeTypeID ` has been assigned to the account at ` account ` and is currently valid .
"
"function removeValidator ( address validator ) external ;
","Remove the validator at address ` validator ` from the jurisdiction .
"
"function buy ( ) payable public { uint amount = uint ( msg . value ) / uint ( buyPrice ) ; _transfer ( this , msg . sender , amount * 10 ** uint256 ( decimals ) ) ; }
","Buy tokens from contract by sending ether
"
"function getEndTime ( ) public pure returns ( uint ) { return 1521331200 ; }
","end time of the sale
"
"function withdrawRequest ( address _auditor , bytes32 _codeHash ) public { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; uint8 outcome = SolidStampRegister ( SolidStampRegisterAddress ) . getAuditOutcome ( _auditor , _codeHash ) ; require ( outcome == NOT_AUDITED , ""contract already audited"" ) ; bytes32 hashAuditorRequestorCode = keccak256 ( abi . encodePacked ( _auditor , msg . sender , _codeHash ) ) ; AuditRequest storage request = AuditRequests [ hashAuditorRequestorCode ] ; require ( request . amount > 0 , ""nothing to withdraw"" ) ; require ( now > request . expireDate , ""cannot withdraw before request.expireDate"" ) ; uint amount = request . amount ; delete request . amount ; delete request . expireDate ; Rewards [ hashAuditorCode ] = Rewards [ hashAuditorCode ] . sub ( amount ) ; TotalRequestsAmount = TotalRequestsAmount . sub ( amount ) ; emit RequestWithdrawn ( _auditor , msg . sender , _codeHash , amount ) ; msg . sender . transfer ( amount ) ; }
","withdraws an audit request
"
"function transfer ( address _to , uint _tokenId ) whenNotPaused external { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","External function to transfers a token to another address .
"
"function enableMigration ( IMigrationTarget migration ) public onlyMigrationEnabledOnce ( ) only ( MIGRATION_ADMIN ) { require ( migration . currentMigrationSource ( ) == address ( this ) ) ; _migration = migration ; emit LogMigrationEnabled ( _migration ) ; }
","should enable migration to migration target
"
"function mint ( address _investor , uint256 _value ) external returns ( bool success ) ;
","Mints new tokens and assigns them to the target _investor .
"
"function upper ( string _base ) internal pure returns ( string ) { bytes memory _baseBytes = bytes ( _base ) ; for ( uint i = 0 ; i < _baseBytes . length ; i ++ ) { bytes1 b1 = _baseBytes [ i ] ; if ( b1 >= 0x61 && b1 <= 0x7A ) { b1 = bytes1 ( uint8 ( b1 ) - 32 ) ; } _baseBytes [ i ] = b1 ; } return string ( _baseBytes ) ; }
","Changes a string to upper case
"
"function revoke ( address who , address origin ) payable external only_delegate { require ( msg . value == fee ) ; bool found ; for ( uint i = 0 ; i < s_paid [ who ] . length ; i ++ ) { if ( s_paid [ who ] [ i ] != origin ) { continue ; } found = true ; uint last = s_paid [ who ] . length - 1 ; s_paid [ who ] [ i ] = s_paid [ who ] [ last ] ; delete s_paid [ who ] [ last ] ; s_paid [ who ] . length -= 1 ; break ; } require ( found ) ; who . transfer ( msg . value ) ; }
","This method can be called by authorized persons only , and can issue a refund of the fee to the ` origin ` address who paid the fee for ` who ` .
"
"function calcUnclaimedFees ( uint gav ) view returns ( uint managementFee , uint performanceFee , uint unclaimedFees ) { uint timePassed = sub ( now , atLastUnclaimedFeeAllocation . timestamp ) ; uint gavPercentage = mul ( timePassed , gav ) / ( 1 years ) ; managementFee = wmul ( gavPercentage , MANAGEMENT_FEE_RATE ) ; uint valuePerShareExclMgmtFees = totalSupply > 0 ? calcValuePerShare ( sub ( gav , managementFee ) , totalSupply ) : toSmallestShareUnit ( 1 ) ; if ( valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation . highWaterMark ) { uint gainInSharePrice = sub ( valuePerShareExclMgmtFees , atLastUnclaimedFeeAllocation . highWaterMark ) ; uint investmentProfits = wmul ( gainInSharePrice , totalSupply ) ; performanceFee = wmul ( investmentProfits , PERFORMANCE_FEE_RATE ) ; } unclaimedFees = add ( managementFee , performanceFee ) ; }
","Calculates unclaimed fees of the fund manager
"
"function allowance ( address tokenOwner , address spender ) constant public returns ( uint coinsRemaining ) { return allowance [ tokenOwner ] [ spender ] ; }
","Show the allowance given by ` tokenOwner ` to the ` spender `
"
"function withdrawFunds ( ) { externalEnter ( ) ; withdrawFundsRP ( ) ; externalLeave ( ) ; }
","Send the caller ( ` msg.sender ` ) all ether they own .
"
"function transferPreSignedHashing ( address _operator , address _to , address _delegate , uint256 _value , uint256 _fee , uint256 _nonce , bytes _userData ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _operator , _to , _delegate , _value , _fee , _nonce , _userData ) ) ; }
","Hash ( keccak256 ) of the payload used by transferPreSigned
"
"function setOperatingOfficer ( address _operatingOfficerAddress ) external onlyExecutiveOfficer { require ( _operatingOfficerAddress != address ( 0 ) ) ; operatingOfficerAddress = _operatingOfficerAddress ; }
","Reassign the operating officer role
"
"function _setPendingAnchor ( address asset , uint newScaledPrice ) public returns ( uint ) { if ( msg . sender != anchorAdmin ) { return failOracle ( asset , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PENDING_ANCHOR_PERMISSION_CHECK ) ; } uint oldScaledPrice = pendingAnchors [ asset ] ; pendingAnchors [ asset ] = newScaledPrice ; emit NewPendingAnchor ( msg . sender , asset , oldScaledPrice , newScaledPrice ) ; return uint ( OracleError . NO_ERROR ) ; }
","provides ability to override the anchor price for an asset
"
"function getBoardSingleSpaceDetails ( uint boardId , uint8 row , uint8 col ) external view returns ( uint8 ) { uint8 position = row * BOARD_ROW_SIZE + col ; return allBoards [ boardId ] . positionToColor [ position ] ; }
","Returns the current color of a specific position in a board .
"
"function destroy ( ) public onlyOwner { token . transfer ( owner , token . balanceOf ( this ) ) ; selfdestruct ( owner ) ; }
","Allows the owner to destroy the contract and return the tokens to the owner .
"
"function buyArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY ) external whenNotPaused payable { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; require ( canPay ( areaPrice ( fromX , fromY , toX , toY ) ) ) ; depositFunds ( ) ; uint id = market . buyBlocks ( msg . sender , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogBuys ( id , fromX , fromY , toX , toY , msg . sender ) ; }
","lets a message sender to buy blocks within area
"
"function getValidAttributeID ( ) external view returns ( uint256 ) { return _validAttributeTypeID ; }
","Get the ID of the attribute type required to receive tokens .
"
"function worktime ( uint256 _factoryId ) public view returns ( uint256 ) { return worktimeAtDate ( factories [ _factoryId ] . collected_at ) ; }
","function for compute duration work factory
"
"function withdrawStake ( ) public whenNotPaused ( ) staking ( msg . sender ) { uint256 stakeAmount = refundUserBalance ( msg . sender ) ; delete registeredInvitationCodes [ members [ msg . sender ] . invitationCode ] ; Member storage member = members [ msg . sender ] ; member . stakeTimestamp = 0 ; member . startOfLoyaltyRewardEligibility = 0 ; emit StakeWithdrawn ( msg . sender , stakeAmount ) ; }
","This function will return all stake and eligible reward balance back to the user
"
"function setProxy ( address _proxyAddress , bytes32 _symbol ) public onlyOneOfContractOwners returns ( uint ) { if ( proxies ( _symbol ) != 0x0 ) { return CHRONOBANK_PLATFORM_PROXY_ALREADY_EXISTS ; } set ( store , proxiesStorage , _symbol , _proxyAddress ) ; return OK ; }
","Sets Proxy contract address for a particular asset .
"
"function enableTrade ( bool enable ) returns ( bool ) { if ( msg . sender != reserveOwner ) { ErrorReport ( tx . origin , 0x830000000 , uint ( msg . sender ) ) ; return false ; } tradeEnabled = enable ; ErrorReport ( tx . origin , 0 , 0 ) ; EnableTrade ( enable ) ; return true ; }
","can be called only by owner
"
"function changeRegistrationStatuses ( address [ ] targets , bool isRegistered ) public onlyBy ( owner ) { for ( uint i = 0 ; i < targets . length ; i ++ ) { changeRegistrationStatus ( targets [ i ] , isRegistered ) ; } }
","Updates registration status for multiple addresses for participation
"
"function _getEarlyBonus ( ) internal view returns ( uint ) { if ( getState ( ) == State . PrivateFunding ) return privateBonus ; else if ( getState ( ) == State . PreFunding ) return preBonus ; else return 0 ; }
","get early bonus for Investor
"
"function burn ( uint256 _value ) public returns ( bool success ) { require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function cancelSale ( uint256 _tokenId ) external whenNotPaused { Sale memory sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; require ( msg . sender == seller ) ; _cancelSale ( _tokenId , seller ) ; }
","This is a state-modifying function that can be called while the contract is paused .
"
"function reclaimDividend ( uint256 _dividendIndex ) external withPerm ( MANAGE ) { require ( _dividendIndex < dividends . length , ""Incorrect dividend index"" ) ; require ( now >= dividends [ _dividendIndex ] . expiry , ""Dividend expiry is in the future"" ) ; require ( ! dividends [ _dividendIndex ] . reclaimed , ""Dividend is already claimed"" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; dividend . reclaimed = true ; uint256 remainingAmount = dividend . amount . sub ( dividend . claimedAmount ) ; address owner = IOwnable ( securityToken ) . owner ( ) ; owner . transfer ( remainingAmount ) ; emit EtherDividendReclaimed ( owner , _dividendIndex , remainingAmount ) ; }
","Issuer can reclaim remaining unclaimed dividend amounts , for expired dividends
"
"function tokenFactory ( uint256 _amount ) onlyOwner returns ( bool success ) { require ( tokenMinter ( _amount ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; Transfer ( 0 , msg . sender , _amount ) ; return true ; }
","Used to create new tokens and increase total supply
"
"function purchase ( uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . hasAnyAttrs ( _tokenId , ATTR_GOLDENGOOSE ) ) ; require ( ! isExploring ( _tokenId ) ) ; address oldOwner = ethernautsStorage . ownerOf ( _tokenId ) ; address newOwner = msg . sender ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( oldOwner != newOwner ) ; require ( newOwner != address ( 0 ) ) ; require ( msg . value >= sellingPrice ) ; uint256 payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee1Step ) , 100 ) ) ; uint256 purchaseExcess = SafeMath . sub ( msg . value , sellingPrice ) ; uint256 newPrice = sellingPrice ; if ( sellingPrice < firstStepLimit ) { newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage1Step ) , percentageBase ) ; } else if ( sellingPrice < secondStepLimit ) { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFee2Step ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentage2Step ) , percentageBase ) ; } else { payment = uint256 ( SafeMath . div ( SafeMath . mul ( sellingPrice , percentageFeeSteps ) , 100 ) ) ; newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , percentageSteps ) , percentageBase ) ; } if ( oldOwner != address ( this ) ) { oldOwner . transfer ( payment ) ; } ethernautsStorage . transfer ( oldOwner , newOwner , _tokenId ) ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; Purchase ( _tokenId , sellingPrice , newPrice , oldOwner , newOwner ) ; msg . sender . transfer ( purchaseExcess ) ; }
","Allows someone buy obtain an GoldenGoose asset token
"
"function getMemeSellingPrices ( uint256 [ ] _tokenIds ) public view returns ( uint256 [ ] sellingPrices ) { sellingPrices = new uint256 [ ] ( _tokenIds . length ) ; for ( uint i = 0 ; i < _tokenIds . length ; i ++ ) { sellingPrices [ i ] = memeIndexToPrice [ _tokenIds [ i ] ] ; } }
","Returns all the relevant information about a specific meme .
"
"function setManager ( address _newManager ) external requireGod { require ( _newManager != address ( 0 ) ) ; managerAddress = _newManager ; }
","Assigns a new address to act as the Manager .
"
"function proxyPayment ( address _owner ) public payable returns ( bool ) ;
","Called when ` _owner ` sends ether to the MiniMe Token contract
"
"function cofounderApproveSwitchRequest ( address _newFounderAddr , bytes32 _oneTimesharedPhrase ) external returns ( bool success ) { if ( msg . sender != cofounder || sha3 ( _newFounderAddr , founderHash , _oneTimesharedPhrase ) != tempHashes [ _newFounderAddr ] ) throw ; previousFounders . push ( founder ) ; founder = _newFounderAddr ; FounderSwitchedEvent ( _newFounderAddr ) ; return true ; }
","` msg.sender.address ( ) ` approving ` _newFounderAddr.address ( ) ` as new founder address
"
"function changeController ( address _newController ) onlyOwner public { tokenContract . changeController ( _newController ) ; }
","` onlyOwner ` changes the controller of the tokenContract
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = masterpieceToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
","Required for ERC-721 compliance .
"
"function emitCampaignUpdated ( CampaignLibrary . Campaign storage campaign ) private { emit CampaignUpdated ( campaign . getBidId ( ) , campaign . getPrice ( ) , campaign . getBudget ( ) , campaign . getStartDate ( ) , campaign . getEndDate ( ) , campaign . getValidity ( ) , campaign . getOwner ( ) ) ; }
","Function to emit campaign updates It emits a CampaignUpdated event with the new campaign information .
"
"function getNotApprovedProposals ( ) public view returns ( uint [ ] ) { uint count = 0 ; for ( uint i = 0 ; i < proposals . length ; i ++ ) { if ( ! proposals [ i ] . approved && ! proposals [ i ] . denied ) { count ++ ; } } uint [ ] memory notApprovedProposals = new uint [ ] ( count ) ; count = 0 ; for ( i = 0 ; i < proposals . length ; i ++ ) { if ( ! proposals [ i ] . approved && ! proposals [ i ] . denied ) { notApprovedProposals [ count ] = i ; count ++ ; } } return notApprovedProposals ; }
","Get all not approved proposals
"
"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { doTransfer ( msg . sender , _to , _amount ) ; return true ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( ethernautsStorage ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; ethernautsStorage . transfer ( msg . sender , _to , _tokenId ) ; }
","Transfers a Asset to another address .
"
"function depositETH ( ) payable { DonationDeposited4Matching ( msg . sender , msg . value ) ; }
","Simple function to deposit more ETH to match future donations
"
"function setProtocolVersion ( address _STFactoryAddress , uint8 _major , uint8 _minor , uint8 _patch ) external onlyOwner { require ( _STFactoryAddress != address ( 0 ) , ""0x address is not allowed"" ) ; _setProtocolVersion ( _STFactoryAddress , _major , _minor , _patch ) ; }
","Changing versions does not affect existing tokens .
"
"function setLogger ( address newLoggerAddress ) public onlyCurator { logger = Logger ( newLoggerAddress ) ; logger . emitGenericLog ( ""setLogger"" , """" ) ; }
","Updates Logger contract address to be used
"
"function setRate ( ERC20 [ ] sources , ERC20 [ ] dests , uint [ ] conversionRates , uint [ ] expiryBlocks , bool validate ) returns ( bool ) { if ( msg . sender != reserveOwner ) { ErrorReport ( tx . origin , 0x820000000 , uint ( msg . sender ) ) ; return false ; } if ( validate ) { if ( ( sources . length != dests . length ) || ( sources . length != conversionRates . length ) || ( sources . length != expiryBlocks . length ) ) { ErrorReport ( tx . origin , 0x820000001 , 0 ) ; return false ; } } for ( uint i = 0 ; i < sources . length ; i ++ ) { SetRate ( sources [ i ] , dests [ i ] , conversionRates [ i ] , expiryBlocks [ i ] ) ; pairConversionRate [ sha3 ( sources [ i ] , dests [ i ] ) ] = ConversionRate ( conversionRates [ i ] , expiryBlocks [ i ] ) ; } ErrorReport ( tx . origin , 0 , 0 ) ; return true ; }
","can be called only by owner
"
"function reopenSale ( ) public onlyOwner { require ( crowdsaleClosed == true ) ; crowdsaleClosed = false ; }
","Reopens closed sale to recalcualte total tokens sold if there are any late deals - such as delayed whitelist processing .
"
"function getOpeningTS ( bytes32 question_id ) public view returns ( uint32 ) { }
","Returns the timestamp when the question can first be answered
"
"function ( ) external payable { require ( msg . value > 0 ) ; _flushBalance ( ) ; }
","The fallback function payable
"
"function setAccessPolicy ( IAccessPolicy newPolicy , address newAccessController ) public ;
","it is a huge issue for Solidity that modifiers are not part of function signature then interfaces could be used for example to control access semantics
"
"function kill ( ) public onlyOwner { selfdestruct ( owner ) ; }
","Kill this smart contract .
"
"function _setPaused ( bool requestedState ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_PAUSED_OWNER_CHECK ) ; } paused = requestedState ; emit SetPaused ( requestedState ) ; return uint ( Error . NO_ERROR ) ; }
","set ` paused ` to the specified state
"
"function harvest ( uint256 amount ) onlyOwner public { require ( this . balance >= amount ) ; msg . sender . transfer ( amount ) ; }
","Harvest ` amount ` ETH from contract
"
"function settlementRegistration ( uint64 _settlementID ) external view returns ( bool ) { return settlementDetails [ _settlementID ] . registered ; }
","Returns the settlement contract of a settlement layer .
"
"function approve ( address _to , uint256 _tokenId ) external onlyOwnerOf ( _tokenId ) { address _owner = ownerOf ( _tokenId ) ; require ( _to != _owner , ""already owns"" ) ; if ( getApproved ( _tokenId ) != 0 || _to != 0 ) { tokenApprovals [ _tokenId ] = _to ; emit Approval ( _owner , _to , _tokenId ) ; } }
","Approves another address to claim for the ownership of the given token ID
"
"function transfer ( address _to , uint _value ) public returns ( bool ) { if ( _to != 0x0 ) { return _transferWithReference ( _to , _value , """" ) ; } }
","Transfers asset balance from the caller to specified receiver .
"
"function onTransfer ( address _from , address _to , uint _amount ) returns ( bool success ) { if ( _from == vaultAddress ) { return true ; } return false ; }
","Notifies the controller about a transfer , for this EarlyTokenSale all transfers are allowed by default and no extra notifications are needed
"
"function destroy ( ) public onlyOwner { selfdestruct ( owner ( ) ) ; }
","Destructs this contract ( removes it from the blockchain ) and sends all funds in it to the owner .
"
"function setAttributeTypeSecondarySource ( uint256 ID , address attributeRegistry , uint256 sourceAttributeTypeID ) external { require ( isAttributeType ( ID ) , ""unable to set secondary source, no attribute type with the provided ID"" ) ; _attributeTypes [ ID ] . secondarySource = attributeRegistry ; _attributeTypes [ ID ] . secondaryAttributeTypeID = sourceAttributeTypeID ; }
","Set a secondary source for a given attribute type ID ` ID ` , with an address ` registry ` of the secondary source in question and a given ` sourceAttributeTypeID ` for attribute type ID to check on the secondary source .
"
"function transferWithData ( address _to , uint256 _value , bytes _data ) public returns ( bool success ) { require ( _updateTransfer ( msg . sender , _to , _value , _data ) , ""Transfer invalid"" ) ; require ( super . transfer ( _to , _value ) ) ; return true ; }
","Overloaded version of the transfer function
"
"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) private { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) ) ; } }
","Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
"
"function balanceOf ( address _person ) public view returns ( uint256 balance ) { return balances [ _person ] ; }
","Used to look up balance of a user
"
"function isHolderAddress ( address _address ) public view returns ( bool ) ;
","Checks user is holder .
"
"function isPaused ( ) external view returns ( bool ) ;
","Check whether the contract operations is paused or not
"
"function createCheckpoint ( ) public onlyModule ( CHECKPOINT_KEY , true ) returns ( uint256 ) { require ( currentCheckpointId < 2 ** 256 - 1 ) ; currentCheckpointId = currentCheckpointId + 1 ; emit LogCheckpointCreated ( currentCheckpointId , now ) ; return currentCheckpointId ; }
","Creates a checkpoint that can be used to query historical balances / totalSuppy
"
"function release ( ) public { require ( block . timestamp >= _releaseTime ) ; uint256 amount = _token . balanceOf ( address ( this ) ) ; require ( amount > 0 ) ; _token . safeTransfer ( _beneficiary , amount ) ; }
","Transfers tokens held by timelock to beneficiary .
"
"function receiveApproval ( address from , uint256 , address _token , bytes _data ) public returns ( bool ) { require ( msg . sender == _token ) ; require ( _data . length == 0 ) ; require ( _token == address ( NEUMARK ) , ""NF_ONLY_NEU"" ) ; unlockInvestor ( from ) ; return true ; }
","unlocks investors funds , see unlockInvestor for details
"
"function checkValidity ( string _symbol , address _owner , string _tokenName ) public returns ( bool ) { string memory symbol = upper ( _symbol ) ; require ( msg . sender == securityTokenRegistry , ""msg.sender should be SecurityTokenRegistry contract"" ) ; require ( registeredSymbols [ symbol ] . status != true , ""Symbol status should not equal to true"" ) ; require ( registeredSymbols [ symbol ] . owner == _owner , ""Owner of the symbol should matched with the requested issuer address"" ) ; require ( registeredSymbols [ symbol ] . timestamp . add ( expiryLimit ) >= now , ""Ticker should not be expired"" ) ; registeredSymbols [ symbol ] . tokenName = _tokenName ; registeredSymbols [ symbol ] . status = true ; return true ; }
","Check the validity of the symbol
"
"function destroyTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }
","Burns ` _amount ` tokens from ` _owner `
"
"function mDestroyTokens ( address owner , uint256 amount ) internal ;
","Burns ` amount ` tokens from ` owner `
"
"function lock ( address _beneficiary , bool _isStraight , uint [ ] _releaseTimes , uint [ ] _releaseRatios ) external onlyOwner onlyState ( State . Init ) onlyBeneficiary ( _beneficiary ) { require ( ! locked [ _beneficiary ] ) ; require ( _releaseRatios . length != 0 ) ; require ( _releaseRatios . length == _releaseTimes . length ) ; uint i ; uint len = _releaseRatios . length ; require ( _releaseRatios [ len - 1 ] == coeff ) ; for ( i = 0 ; i < len - 1 ; i ++ ) { require ( _releaseTimes [ i ] < _releaseTimes [ i + 1 ] ) ; require ( _releaseRatios [ i ] < _releaseRatios [ i + 1 ] ) ; } if ( _isStraight ) { require ( len == 2 ) ; } numLocks = numLocks . add ( 1 ) ; releases [ _beneficiary ] . isStraight = _isStraight ; releases [ _beneficiary ] . releaseTimes = _releaseTimes ; releases [ _beneficiary ] . releaseRatios = _releaseRatios ; locked [ _beneficiary ] = true ; emit Locked ( _beneficiary , _isStraight ) ; if ( numLocks == numBeneficiaries ) { state = State . Ready ; emit StateChanged ( state ) ; } }
","add new release record for beneficiary
"
"function maxSupply ( ) external view returns ( uint256 ) ;
","Returns maximum supply .
"
"function withdrawToken ( address _token , uint256 _amount ) external onlyOwner returns ( bool ) { return ERC20SafeTransfer . safeTransfer ( _token , owner , _amount ) ; }
","Withdraw ether contained in this contract and send it back to owner
"
"function removeTagByModuleType ( uint8 _moduleType , bytes32 [ ] _removedTags ) public onlyOwner { for ( uint8 i = 0 ; i < availableTags [ _moduleType ] . length ; i ++ ) { for ( uint8 j = 0 ; j < _removedTags . length ; j ++ ) { if ( availableTags [ _moduleType ] [ i ] == _removedTags [ j ] ) { delete availableTags [ _moduleType ] [ i ] ; } } } }
","remove the tag for specified Module Factory
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( now > ICOdeadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
","check status
"
"function isTokenEscapable ( address _token ) view public returns ( bool ) { return ! escapeBlacklist [ _token ] ; }
","Checks to see if ` _token ` is in the blacklist of tokens
"
"function claimTokens ( address _token ) onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function updateProfiterole ( address _profiterole , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _profiterole ) , _block ) ; if ( OK != _code ) { return _code ; } profiterole = _profiterole ; return OK ; }
","Update a profiterole address
"
"function callRecipient ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData , bool _preventLocking ) internal { address recipientImplementation = interfaceAddr ( _to , ""ERC777TokensRecipient"" ) ; if ( recipientImplementation != 0 ) { ERC777TokensRecipient ( recipientImplementation ) . tokensReceived ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } else if ( _preventLocking ) { require ( isRegularAddress ( _to ) ) ; } }
","Helper function that checks for ERC777TokensRecipient on the recipient and calls it .
"
"function getCampaignOwnerById ( bytes32 bidId ) public view returns ( address campOwner ) { return campaigns [ bidId ] . getOwner ( ) ; }
","Get the owner of a campaign Based on the Campaign id , return the address of the campaign owner .
"
"function approve ( address _spender , uint256 _value ) external { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; }
","Authorize an address to retrieve funds from you ~ ERC-20 Standard
"
"function setPrices ( uint256 priceForPreIcoInWei , uint256 priceForIcoInWei ) isOwner { require ( priceForPreIcoInWei > 0 ) ; require ( priceForIcoInWei > 0 ) ; preICOprice = priceForPreIcoInWei ; ICOprice = priceForIcoInWei ; updatePrices ( ) ; }
","Set both prices at the same time
"
"function getFinalAnswerIfMatches ( bytes32 question_id , bytes32 content_hash , address arbitrator , uint32 min_timeout , uint256 min_bond ) stateFinalized ( question_id ) external view returns ( bytes32 ) { require ( content_hash == questions [ question_id ] . content_hash , ""content hash must match"" ) ; require ( arbitrator == questions [ question_id ] . arbitrator , ""arbitrator must match"" ) ; require ( min_timeout <= questions [ question_id ] . timeout , ""timeout must be long enough"" ) ; require ( min_bond <= questions [ question_id ] . bond , ""bond must be high enough"" ) ; return questions [ question_id ] . best_answer ; }
","Return the final answer to the specified question , provided it matches the specified criteria .
"
"function ownerOf ( uint _tokenId ) external view returns ( address ) { require ( tokenIndexToOwner [ _tokenId ] != address ( 0 ) ) ; return tokenIndexToOwner [ _tokenId ] ; }
","Returns the address currently assigned ownership of a given token .
"
"function checkPermission ( address _delegate , address _module , bytes32 _perm ) external view returns ( bool ) ;
","Used to check the permission on delegate corresponds to module contract address
"
"function isManagingProxy ( address _account , address _accountProxy ) public view returns ( bool ) { address _userRouter = Owned ( _accountProxy ) . contractOwner ( ) ; return _account == Owned ( _userRouter ) . contractOwner ( ) ; }
","Says if user account ` _account ` owns a user proxy contract ` _accountProxy ` and could manage it through UserInterface interface .
"
"function allowAddress ( address _address , bool _allow ) onlyOwner { allowedAddresses [ _address ] = _allow ; }
","Set allowance for address to interact with contract .
"
"function proxyPurchase ( address _addr ) public payable returns ( bool ) ;
","Processes a token purchase for ` _addr `
"
"function authorize ( string _contractName , address _accessor ) external onlyContractOwner ( _contractName , _accessor ) view returns ( bool ) { return true ; }
","Check whether the accessor is authorized to access that contract
"
"function approvePreSignedHashing ( address _token , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xf7ac9c2e ) , _token , _spender , _value , _fee , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by approvePreSigned
"
"function setPoolToClosed ( ) public isAdmin isOpen { state = PoolState . CLOSED ; emit PoolIsClosed ( ) ; }
","Allows the admin to set the state of the pool to CLOSED .
"
"function release ( address who ) public onlyTransferAgent returns ( bool ) { Holding memory holding = heldTokens [ who ] ; require ( ! holding . isAffiliate , ""To release tokens for an affiliate use partialRelease()."" ) ; if ( block . timestamp > holding . releaseDate ) { bool res = ERC20Interface ( tokenContract ) . transfer ( who , holding . quantity ) ; if ( res ) { heldTokens [ who ] = Holding ( 0 , 0 , holding . isAffiliate ) ; emit TokensReleased ( who , holding . quantity ) ; return true ; } } return false ; }
","Release the tokens once the holding period expires , transferring them back to the ERC20 contract to the holder .
"
"function startTokenVotes ( address [ 10 ] tokens ) public onlyAdmins { uint _proposalId = tokenBatches . length ; if ( _proposalId > 0 ) { TokenProposal memory op = tokenBatches [ _proposalId - 1 ] ; DestructibleMiniMeToken ( op . votingToken ) . recycle ( ) ; } tokenBatches . length ++ ; TokenProposal storage p = tokenBatches [ _proposalId ] ; p . duration = VOTING_DURATION * ( 1 days ) ; p . consideredTokens = tokens ; p . votingToken = tokenFactory . createDestructibleCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( ""EfxTokenVotes-"" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( ""EfxTokenVotes-"" , _proposalId ) , true ) ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; emit NewTokens ( _proposalId ) ; }
","Admins are able to approve proposal that someone submitted
"
"function addReserve ( KyberReserve reserve , bool add ) { if ( msg . sender != admin ) { ErrorReport ( msg . sender , 0x87000000 , 0 ) ; return ; } if ( add ) { reserves . push ( reserve ) ; AddReserve ( reserve , true ) ; } else { for ( uint i = 0 ; i < reserves . length ; i ++ ) { if ( reserves [ i ] == reserve ) { if ( reserves . length == 0 ) return ; reserves [ i ] = reserves [ -- reserves . length ] ; AddReserve ( reserve , false ) ; break ; } } } ErrorReport ( msg . sender , 0 , 0 ) ; }
","can be called only by admin
"
"function convert ( uint _amount ) { if ( ! arcToken . transferFrom ( msg . sender , vaultAddress , _amount ) ) { throw ; } if ( ! tokenContract . generateTokens ( msg . sender , _amount ) ) { throw ; } }
","converts ARC tokens to new SWT tokens and forwards ARC to the vault address .
"
"function setBuyoutDividendPercentage ( uint256 _buyoutDividendPercentage ) external onlyCFO { require ( 2000 <= _buyoutDividendPercentage && _buyoutDividendPercentage <= 12500 ) ; buyoutDividendPercentage = _buyoutDividendPercentage ; }
","Sets the new dividend percentage for buyouts .
"
"function setGasPrice ( uint256 _gasPrice ) onlyOwner public { oraclize_setCustomGasPrice ( _gasPrice ) ; }
","NB - this will only impact newly scheduled Oraclize queries , not future queries which have already been scheduled
"
"function balanceOf ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return _tokensOfOwnerWithSubstitutions [ _owner ] . length ; }
","Count all NFTs assigned to an owner
"
"function _depositTokens ( address _beneficiary , uint256 _amountTokens ) internal { require ( _amountTokens != 0 ) ; if ( investors [ _beneficiary ] == 0 ) { investorCount ++ ; } investors [ _beneficiary ] = investors [ _beneficiary ] . add ( _amountTokens ) ; mintableFida . sendBoughtTokens ( _beneficiary , _amountTokens ) ; }
","Internal function for depositing tokens after they had been bought
"
"function transfer ( address _to , uint256 _amount ) stopOnPause public returns ( bool success ) { bytes memory empty ; if ( _transfer ( msg . sender , _to , _amount , empty ) ) { emit Transfer ( msg . sender , _to , _amount ) ; return true ; } return false ; }
","Transfer without additional data .
"
"function getTitle ( ) public view returns ( string ) ;
","Get the title of the Module
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { success = TokenApprovalController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_APPROVAL ) ) . approve ( msg . sender , _spender , _value ) ; }
","approve given spender to transfer given amount this will set allowance to 0 if current value is non-zero
"
"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( SENToken ) { SENToken newToken = new SENToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function validatePurchaseAndDistributeFunds ( uint24 [ ] purchase , uint24 [ ] purchasedAreas , uint256 [ ] areaIndices ) private returns ( uint256 ) { require ( purchase . length == 4 ) ; Geometry . Rect memory plotToPurchase = Geometry . Rect ( purchase [ 0 ] , purchase [ 1 ] , purchase [ 2 ] , purchase [ 3 ] ) ; require ( plotToPurchase . x < GRID_WIDTH && plotToPurchase . x >= 0 ) ; require ( plotToPurchase . y < GRID_HEIGHT && plotToPurchase . y >= 0 ) ; require ( plotToPurchase . w > 0 && plotToPurchase . w + plotToPurchase . x <= GRID_WIDTH ) ; require ( plotToPurchase . h > 0 && plotToPurchase . h + plotToPurchase . y <= GRID_HEIGHT ) ; require ( plotToPurchase . w * plotToPurchase . h < MAXIMUM_PURCHASE_AREA ) ; require ( purchasedAreas . length >= 4 ) ; require ( areaIndices . length > 0 ) ; require ( purchasedAreas . length % 4 == 0 ) ; require ( purchasedAreas . length / 4 == areaIndices . length ) ; Geometry . Rect [ ] memory subPlots = new Geometry . Rect [ ] ( areaIndices . length ) ; uint256 totalArea = 0 ; uint256 i = 0 ; uint256 j = 0 ; for ( i = 0 ; i < areaIndices . length ; i ++ ) { Geometry . Rect memory rect = Geometry . Rect ( purchasedAreas [ ( i * 4 ) ] , purchasedAreas [ ( i * 4 ) + 1 ] , purchasedAreas [ ( i * 4 ) + 2 ] , purchasedAreas [ ( i * 4 ) + 3 ] ) ; subPlots [ i ] = rect ; require ( rect . w > 0 ) ; require ( rect . h > 0 ) ; totalArea = SafeMath . add ( totalArea , SafeMath . mul ( rect . w , rect . h ) ) ; require ( Geometry . rectContainedInside ( rect , plotToPurchase ) ) ; } require ( totalArea == plotToPurchase . w * plotToPurchase . h ) ; for ( i = 0 ; i < subPlots . length ; i ++ ) { for ( j = i + 1 ; j < subPlots . length ; j ++ ) { require ( ! Geometry . doRectanglesOverlap ( subPlots [ i ] , subPlots [ j ] ) ) ; } } uint256 remainingBalance = checkHolesAndDistributePurchaseFunds ( subPlots , areaIndices ) ; uint256 purchasePrice = SafeMath . sub ( msg . value , remainingBalance ) ; return purchasePrice ; }
","This function does a lot of the heavy lifting for validating that all of the data passed in to the purchase function is ok .
"
"function symbol ( ) external pure returns ( string _symbol ) { return ""BC"" ; }
","An abbreviated name for NFTs in this contract
"
"function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ) ;
","Query if a contract implements an interface
"
"function transferFrom ( address _owner , address _receiver , uint256 _amount ) { require ( ! tokenTransfersFrozen ) ; require ( sub ( allowance [ _owner ] [ msg . sender ] , _amount ) >= 0 ) ; if ( transferCheck ( _owner , _receiver , _amount ) ) { balances [ _owner ] = sub ( balances [ _owner ] , _amount ) ; balances [ _receiver ] = add ( balances [ _receiver ] , _amount ) ; allowance [ _owner ] [ _receiver ] = sub ( allowance [ _owner ] [ _receiver ] , _amount ) ; Transfer ( _owner , _receiver , _amount ) ; } else { revert ( ) ; } }
","Used to transfer funds on behalf of one person
"
"function withdrawTokens ( ) public whenNotPaused returns ( bool ) { uint256 amount = rewards [ msg . sender ] ; require ( amount > 0 , ""amount is zero"" ) ; rewards [ msg . sender ] = 0 ; emit TokensWithdrawn ( msg . sender , amount ) ; require ( token . transfer ( msg . sender , amount ) , ""token transfer failed"" ) ; return true ; }
","allows participants in the Atonomi network to claim their rewards
"
"function mint ( address _investor , uint256 _value ) public returns ( bool success ) { return mintWithData ( _investor , _value , """" ) ; }
","Mints new tokens and assigns them to the target _investor .
"
"function addPartOwner ( address _partowner ) public onlyContractOwner returns ( uint ) { set ( store , partownersStorage , _partowner , true ) ; return OK ; }
","Adds a co-owner of a contract .
"
"function claimTokenTokens ( address _token ) public onlyOwner { require ( _token != address ( ethealToken ) ) ; ethealToken . claimTokens ( _token ) ; }
","Retrieve mistakenly sent tokens ( other than the etheal token ) from the token contract
"
"function lockToken ( address target , uint256 lockAmount , uint256 lockPeriod ) onlyOwner public returns ( bool res ) { require ( balanceOf [ msg . sender ] >= lockAmount ) ; require ( lockedAmount [ target ] == 0 ) ; balanceOf [ msg . sender ] -= lockAmount ; lockedAmount [ target ] = lockAmount ; lockedTime [ target ] = now + lockPeriod ; LockToken ( target , lockAmount , now + lockPeriod ) ; return true ; }
","lock some amount token
"
"function listPairForReserve ( address reserve , ERC20 src , ERC20 dest , bool add ) public onlyAdmin { ( perReserveListedPairs [ reserve ] ) [ keccak256 ( src , dest ) ] = add ; if ( src != ETH_TOKEN_ADDRESS ) { if ( add ) { src . approve ( reserve , 2 ** 255 ) ; } else { src . approve ( reserve , 0 ) ; } } setDecimals ( src ) ; setDecimals ( dest ) ; ListReservePairs ( reserve , src , dest , add ) ; }
","can be called only by admin
"
"function proposeReparameterization ( string _name , uint _value ) public returns ( bytes32 ) { uint deposit = get ( ""pMinDeposit"" ) ; bytes32 propID = keccak256 ( _name , _value ) ; require ( ! propExists ( propID ) ) ; require ( get ( _name ) != _value ) ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; proposals [ propID ] = ParamProposal ( { appExpiry : now + get ( ""pApplyStageLen"" ) , challengeID : 0 , deposit : deposit , name : _name , owner : msg . sender , processBy : now + get ( ""pApplyStageLen"" ) + get ( ""pCommitStageLen"" ) + get ( ""pRevealStageLen"" ) + PROCESSBY , value : _value } ) ; _ReparameterizationProposal ( msg . sender , _name , _value , propID ) ; return propID ; }
","propose a reparamaterization of the key _name 's value to _value .
"
"function setManualOverride ( bool _override ) public onlyOwner { manualOverride = _override ; emit LogSetManualOverride ( _override , now ) ; }
","Determine whether manual price is used or not
"
"function ( ) payable internal { uint amount ; uint amountRaised ; if ( now <= presale ) { amount = msg . value * 15000 ; } else if ( now > presale && now <= coresale ) { amount = msg . value * 13000 ; } else if ( now > coresale ) { amount = msg . value * 10000 ; } amountRaised += msg . value ; require ( balanceOf [ creator ] >= amount ) ; balanceOf [ msg . sender ] += amount ; balanceOf [ creator ] -= amount ; Transfer ( creator , msg . sender , amount ) ; creator . transfer ( amountRaised ) ; }
","Buy tokens from contract by sending ether
"
"function transferOwnership ( address newOwner ) public onlyOwner { if ( newOwner != address ( 0 ) ) { owner = newOwner ; } }
","Changes contract ownership .
"
"function division ( uint numerator , uint denominator ) public view returns ( uint result ) { uint _quotient = numerator / denominator ; return _quotient ; }
","Returns the division of two numbers Function used for division operations inside the smartcontract
"
"function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( owner ) ; owner = address ( 0 ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function getAddress ( string _nameKey ) external view returns ( address ) { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; require ( storedAddresses [ key ] != address ( 0 ) , ""Invalid address key"" ) ; return storedAddresses [ key ] ; }
","Gets the contract address
"
"function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( icoLockUntil < now ) ; require ( _spender != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; bytes32 hashedTx = approvePreSignedHashing ( address ( this ) , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; checkValue ( from , _fee ) ; allowed [ from ] [ _spender ] = _value ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned approval
"
"function approve ( address _to , uint256 _tokenId ) public whenNotPaused { address owner = ownerOf ( _tokenId ) ; require ( _to != owner ) ; require ( ( msg . sender == owner ) || ( operators [ ownerOf ( _tokenId ) ] [ msg . sender ] ) ) ; _approve ( _tokenId , _to ) ; emit Approval ( msg . sender , _to , _tokenId ) ; }
","Change or reaffirm the approved address for an NFT
"
"function collectEstimation ( int256 _expectedAmount ) public view returns ( uint256 ) { if ( _expectedAmount < 0 ) { return 0 ; } uint256 computedCollect = uint256 ( _expectedAmount ) . mul ( rateFeesNumerator ) ; if ( rateFeesDenominator != 0 ) { computedCollect = computedCollect . div ( rateFeesDenominator ) ; } return computedCollect < maxFees ? computedCollect : maxFees ; }
","Computes the fees .
"
"function multiCancel ( uint [ ] _idPayments ) public onlyOwner { for ( uint i = 0 ; i < _idPayments . length ; i ++ ) { doCancelPayment ( _idPayments [ i ] ) ; } }
","` onlyOwner ` An efficient way to cancel multiple payments
"
"function transferOtherERC20Token ( address tokenAddress , uint256 amount ) onlyOwner returns ( bool success ) { require ( tokenAddress != address ( this ) || transferable ) ; return ERC20 ( tokenAddress ) . transfer ( owner , amount ) ; }
","transfer out any accidentally sent ERC20 tokens
"
"function startPresale ( ) whenNotPaused onlyOwner external { require ( ! isPresaleStarted ) ; currentStatus = Status . Presale ; isPresaleStarted = true ; presaleStartTime = now ; PresaleStarted ( presaleStartTime ) ; }
","Start presale and track start time .
"
"function closePreSale ( ) private { closed = true ; SaleClosed ( now ) ; }
","Private function used to close the pre-sale when the hard-cap is hit
"
"function setAquariumCost ( uint256 _fee ) onlyOwner public { aquariumCost = _fee ; }
","Sets the cost for fishing in the aquarium
"
"function setFundingFueled ( uint _proposalID ) external ;
","Function used by the main partner to set the funding fueled
"
"function symbol ( ) public pure returns ( string result ) { return ""HEALP"" ; }
","Get symbol of this token .
"
"function ( ) payable { if ( now < PRESALE_START_DATE ) throw ; if ( now > PRESALE_END_DATE ) throw ; if ( msg . value < MIN_AMOUNT ) throw ; if ( msg . value > MAX_AMOUNT ) throw ; if ( safeIncrement ( totalFunding , msg . value ) > PRESALE_MAXIMUM_FUNDING ) throw ; addBalance ( msg . sender , msg . value ) ; }
","A participant 's contribution will be rejected if the presale has been funded to the maximum amount
"
"function listPairForReserve ( address reserve , ERC20 source , ERC20 dest , bool add ) { if ( msg . sender != admin ) { ErrorReport ( msg . sender , 0x88000000 , 0 ) ; return ; } ( perReserveListedPairs [ reserve ] ) [ sha3 ( source , dest ) ] = add ; ListPairsForReserve ( reserve , source , dest , add ) ; ErrorReport ( tx . origin , 0 , 0 ) ; }
","can be called only by admin
"
"function approvePayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( msg . sender != arbitrator ) { require ( job . manager == msg . sender ) ; require ( job . proofOfLastWorkVerified == true ) ; } require ( job . noOfTotalPayments > job . noOfPaymentsMade ) ; uint currentPayment = job . salaryDeposited . div ( job . noOfTotalPayments ) ; job . paymentAvailableForWorker = job . paymentAvailableForWorker + currentPayment ; job . salaryDeposited = job . salaryDeposited - currentPayment ; job . noOfPaymentsMade ++ ; if ( job . noOfTotalPayments == job . noOfPaymentsMade ) { job . status = JobStatus . Completed ; } emit PaymentApproved ( msg . sender , _JobID , currentPayment ) ; }
","this function lets the manager to approve payment
"
"function _isSTOAttached ( ) internal view returns ( bool ) { bool attached = ISecurityToken ( securityToken ) . getModulesByType ( 3 ) . length > 0 ; return attached ; }
","Internal function use to know whether the STO is attached or not
"
"function setICOEndDate ( uint _date ) public onlyAdmin { require ( ICOEndDate == 0 ) ; require ( _date > now ) ; ICOEndDate = _date ; emit ICOEndDateSet ( _date ) ; }
","This function enables the whitelisted application ( internal application ) to set the ICO end date and can only be used once .
"
"function addToWhitelist ( address [ ] _bidder_addresses ) public isWhitelister { for ( uint32 i = 0 ; i < _bidder_addresses . length ; i ++ ) { whitelist [ _bidder_addresses [ i ] ] = true ; } }
","Adds account addresses to whitelist .
"
"function burn ( address _where , uint _amount ) external onlyOwner { _burn ( _where , _amount ) ; }
","Burn the specified amount of tokens from any address can only be called by the smart contract owner
"
"function deleteUncompletableRequest ( bytes32 _requestMsgHash ) public { Request storage request = requestMap [ _requestMsgHash ] ; uint256 idx = request . idx ; require ( 0 < idx && idx < lastCompletedIdxs [ request . callbackAddress ] [ request . callbackSelector ] ) ; delete requestMap [ _requestMsgHash ] ; }
","Reclaim the storage of a pending request that is uncompleteable .
"
"function tileTimeoutTimestamp ( uint256 identifier , address player ) public view returns ( uint256 ) { uint256 bonusTime = gameSettings . timeoutBonusTime . mul ( gameStates [ gameIndex ] . addressToNumberOfTiles [ player ] ) ; uint256 timeoutTimestamp = block . timestamp . add ( calculateBaseTimeout ( ) ) . add ( bonusTime ) ; uint256 currentTimeoutTimestamp = gameStates [ gameIndex ] . identifierToTimeoutTimestamp [ identifier ] ; if ( currentTimeoutTimestamp == 0 ) { currentTimeoutTimestamp = gameStates [ gameIndex ] . gameStartTimestamp . add ( gameSettings . initialActivityTimer ) ; } if ( timeoutTimestamp >= currentTimeoutTimestamp ) { return timeoutTimestamp ; } else { return currentTimeoutTimestamp ; } }
","Get the new timeout timestamp for a tile .
"
"function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) private { address senderImplementation = interfaceAddr ( _from , ""ERC777TokensSender"" ) ; if ( senderImplementation != 0 ) { ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } }
","Helper function that checks for ERC777TokensSender on the sender and calls it .
"
"function setMaximumIssuableAttributes ( address organization , uint256 maximumIssuableAttributes ) external onlyOwner whenNotPaused { require ( _organizations [ organization ] . exists == true , ""an organization does not exist at the provided account address"" ) ; require ( _organizations [ organization ] . accounts . length <= maximumIssuableAttributes , ""maximum cannot be set to amounts less than the current account total"" ) ; _organizations [ organization ] . maximumAccounts = maximumIssuableAttributes ; }
","Modify an organization at account ` organization ` to change the number of issuable attributes to ` maximumIssuableAttributes ` .
"
"function participantClaimCredits ( ) external { require ( now >= TOKEN_WITHDRAWAL_START_DATE ) ; require ( now < TOKEN_WITHDRAWAL_END_DATE ) ; require ( totalFunding >= PRESALE_MINIMUM_FUNDING ) ; require ( creditBalanceOf [ msg . sender ] > 0 ) ; var tokensToApprove = creditBalanceOf [ msg . sender ] ; spentParsecCredits = spentParsecCredits . add ( tokensToApprove ) ; creditBalanceOf [ msg . sender ] = 0 ; parsecToken . approve ( msg . sender , tokensToApprove ) ; }
","The participant will need to withdraw their Parsec credits if minimal pre-sale amount was reached and date between TOKEN_WITHDRAWAL_START_DATE and TOKEN_WITHDRAWAL_END_DATE
"
"function mintToken ( uint256 mintedAmount ) onlyOwner public { balanceOf [ this ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( 0 , this , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` owner `
"
"function setSale ( address account , bool isSale ) external validAddress ( account ) privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { m_sales [ account ] = isSale ; }
","Sets sale status of an account .
"
"function getCity ( uint256 _tokenId ) public view returns ( string cityName , uint256 sellingPrice , address owner ) { City storage city = citys [ _tokenId ] ; cityName = city . name ; sellingPrice = cityIndexToPrice [ _tokenId ] ; owner = cityIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific city .
"
"function manualTransfer ( address _to , uint _value ) public onlyOwner returns ( bool success ) { require ( totalSupply >= _value ) ; require ( ! frozenAccount [ _to ] ) ; totalSupply -= _value ; balanceOf [ _to ] += _value ; emit Transfer ( address ( 0 ) , _to , _value ) ; return true ; }
","Manual transfer for investors who paid from payment cards
"
"function registerDevice ( bytes32 _deviceIdHash , bytes32 _deviceType , bytes32 _devicePublicKey ) public onlyManufacturer whenNotPaused returns ( bool ) { uint256 registrationFee = settings . registrationFee ( ) ; Device memory d = _registerDevice ( msg . sender , _deviceIdHash , _deviceType , _devicePublicKey ) ; emit DeviceRegistered ( msg . sender , registrationFee , _deviceIdHash , d . manufacturerId , _deviceType ) ; _depositTokens ( msg . sender , registrationFee ) ; require ( token . transferFrom ( msg . sender , address ( this ) , registrationFee ) , ""transferFrom failed"" ) ; return true ; }
","registers device on the Atonomi network
"
"function sell ( uint256 amount ) public { require ( balances [ msg . sender ] >= amount , ""You don't have enough tokens"" ) ; require ( owner . balance > amount . mul ( sellPrice_ ) , ""The contract does not have enough ether to buy your tokens"" ) ; transferFrom ( msg . sender , owner , amount ) ; msg . sender . transfer ( amount . mul ( sellPrice_ ) ) ; }
","Sell ` amount ` tokens to contract
"
"function withdraw ( bytes32 _userKey , uint _value , address _withdrawAddress , uint _feeAmount , address _feeAddress ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; _makeWithdrawForPeriod ( _userKey , _value ) ; uint _periodsCount = periodsCount ; user2lastPeriodParticipated [ _userKey ] = periodsCount ; delete periods [ _periodsCount ] . startDate ; ERC20 _token = ERC20 ( token ) ; if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || _token . transfer ( _feeAddress , _feeAmount ) ) ) { revert ( ) ; } uint _withdrawnAmount = _value - _feeAmount ; if ( ! _token . transfer ( _withdrawAddress , _withdrawnAmount ) ) { revert ( ) ; } TreasuryWithdrawn ( _userKey , _withdrawnAmount ) ; return OK ; }
","Withdraws deposited tokens on behalf of users Allowed only for oracle
"
"function decodeAssets ( bytes32 [ ] _potentialAssets ) public pure returns ( uint [ ] assets ) { require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetsCopy = new uint [ ] ( _potentialAssets . length * 10 ) ; uint numberOfAssets = 0 ; for ( uint j = 0 ; j < _potentialAssets . length ; j ++ ) { uint input ; bytes32 pot = _potentialAssets [ j ] ; assembly { input := pot } for ( uint i = 10 ; i > 0 ; i -- ) { uint mask = ( 2 << ( ( i - 1 ) * 24 ) ) / 2 ; uint b = ( input & ( mask * 16777215 ) ) / mask ; if ( b != 0 ) { assetsCopy [ numberOfAssets ] = b ; numberOfAssets ++ ; } } } assets = new uint [ ] ( numberOfAssets ) ; for ( i = 0 ; i < numberOfAssets ; i ++ ) { assets [ i ] = assetsCopy [ i ] ; } }
","Function which decodes bytes32 to array of integers
"
"function takeFee ( uint256 _amount ) public withPerm ( FEE_ADMIN ) returns ( bool ) { require ( polyToken . transferFrom ( securityToken , Ownable ( factory ) . owner ( ) , _amount ) , ""Unable to take fee"" ) ; return true ; }
","used to withdraw the fee by the factory owner
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = ethernautsStorage . ownerOf ( _tokenId ) ; require ( owner != address ( 0 ) ) ; }
","Returns owner of a given Asset ( Token ) .
"
"function buyTokens ( address _beneficiary ) public payable nonReentrant { if ( ! allowBeneficialInvestments ) { require ( _beneficiary == msg . sender , ""Beneficiary address does not match msg.sender"" ) ; } require ( ! paused , ""Should not be paused"" ) ; require ( fundRaiseTypes [ uint8 ( FundRaiseType . ETH ) ] , ""Mode of investment is not ETH"" ) ; uint256 weiAmount = msg . value ; _processTx ( _beneficiary , weiAmount ) ; _forwardFunds ( ) ; _postValidatePurchase ( _beneficiary , weiAmount ) ; }
","Low level token purchase DO NOT OVERRIDE
"
"function buy ( ) public payable { iaOnInvested ( msg . sender , msg . value , false ) ; }
","ICO participation
"
"function addChunk4ToWhiteList ( ) external onlyOwner { require ( ! chunk4IsAdded ) ; addToWhitelist ( 0x47169f78750Be1e6ec2DEb2974458ac4F8751714 , 1 ether ) ; addToWhitelist ( 0x499114EF97E50c0F01EDD6558aD6203A9B295419 , 1 ether ) ; addToWhitelist ( 0x49C11D994DC19C5Edb62F70DFa76c393941d5fFf , 1 ether ) ; addToWhitelist ( 0x4bCC31189527dCdFde2f4c887A59b0b0C5dBBB1c , 1 ether ) ; addToWhitelist ( 0x4E5Be470d1B97400ce5E141Da1372e06575383ee , 1 ether ) ; addToWhitelist ( 0x5203CDD1D0b8cDc6d7CF60228D0c7E7146642405 , 1 ether ) ; addToWhitelist ( 0x554C033720EfDaD25e5d6400Bdea854bF9E709b6 , 1 ether ) ; addToWhitelist ( 0x5700e809Ea5b49f80B6117335FB7f6B29E0E4529 , 1 ether ) ; addToWhitelist ( 0x62f33168582712391f916b4d42f9d7433ed390ea , 1 ether ) ; addToWhitelist ( 0x62f4e10FA6f1bA0f2b8282973FF4fE2141F917D6 , 1 ether ) ; addToWhitelist ( 0x635Dc49b059dB00BF0d2723645Fa68Ffc839a525 , 1 ether ) ; addToWhitelist ( 0x6465dFa666c6bFDF3E9bd95b5EC1E502843eeEB7 , 1 ether ) ; addToWhitelist ( 0x6E88904BA0A062C7c13772c1895900E1482deC8e , 1 ether ) ; addToWhitelist ( 0x70580eA14d98a53fd59376dC7e959F4a6129bB9b , 1 ether ) ; addToWhitelist ( 0x70EbC02aBc8922c34fA901Bd0931A94634e5B6b2 , 1 ether ) ; addToWhitelist ( 0x71b492cd6695fd85b21af5ae9f818c53f3823046 , 1 ether ) ; addToWhitelist ( 0x7b8a0D81e8A760D1BCC058250D77F79d4827Fd3c , 1 ether ) ; addToWhitelist ( 0x7ba67f190771Cf0C751F2c4e461f40180e8a595c , 1 ether ) ; addToWhitelist ( 0x7ce2C04EfC51EaA4Ca7e927a61D51F4dc9A19f41 , 1 ether ) ; addToWhitelist ( 0x7E8658A0467e34c3ac955117FA3Ba9C18d25d22A , 1 ether ) ; addToWhitelist ( 0x7eedaC1991eE2A59B072Be8Dc6Be82CCE9031f91 , 1 ether ) ; addToWhitelist ( 0x7aa1bb9e0e5439298ec71fb67dc1574f85fecbd1 , 1 ether ) ; addToWhitelist ( 0x832aC483326472Da0c177EAAf437EA681fAb3ABe , 1 ether ) ; addToWhitelist ( 0x861739a2fe0D7d16544c4a295b374705aEEA004F , 1 ether ) ; addToWhitelist ( 0x898C86446CcE1B7629aC7f5B5fD8eA0F51a933b3 , 1 ether ) ; addToWhitelist ( 0x8b2F96cEc0849C6226cf5cFAF32044c12B16eeD9 , 1 ether ) ; addToWhitelist ( 0x8fF73A67b4406341AfBc4b37c9f595a77Aa062A2 , 1 ether ) ; addToWhitelist ( 0x964b513c0F30E28B93081195231305a2D92C7762 , 1 ether ) ; addToWhitelist ( 0x96BC6015ff529eC3a3d0B5e1B7164935Df2bF2fd , 1 ether ) ; addToWhitelist ( 0x96BF1A8660C8D74603b3c4f429f6eC53AD32b0B0 , 1 ether ) ; addToWhitelist ( 0x9840a6b89C53DDB6D6ef57240C6FC972cC97731A , 1 ether ) ; addToWhitelist ( 0xA8625D251046abd3F2858D0163A827368a068bac , 1 ether ) ; addToWhitelist ( 0xa93e77C28fB6A77518e5C3E61348Aec81E5004fD , 1 ether ) ; addToWhitelist ( 0xaEafb182b64FD2CC3866766BA72B030F9AcE69f0 , 1 ether ) ; addToWhitelist ( 0xB3eA2C6feDb15CDC5228dd0B8606592d712c53e1 , 1 ether ) ; addToWhitelist ( 0xBde128e0b3EA8E4a6399401A671ce9731282C4C2 , 1 ether ) ; addToWhitelist ( 0xC3dA85745022fC89CdC774e1FE95ABC4F141292f , 1 ether ) ; addToWhitelist ( 0xC62c61Bbcd61A4817b95dA22339A4c856EC4A3F9 , 1 ether ) ; addToWhitelist ( 0xcE13de0cBd0D7Bde1d2444e2d513868177D2B15F , 1 ether ) ; addToWhitelist ( 0xd45546Cbc3C4dE75CC2B1f324d621A7753f25bB3 , 1 ether ) ; addToWhitelist ( 0xDAF8247Ebcd4BB033D0B82947c3c64a3E5089444 , 1 ether ) ; addToWhitelist ( 0xEF2F95dbEEd23a04DD674898eaB10cA4C883d780 , 1 ether ) ; addToWhitelist ( 0xDe3b6c96f7E6c002c1018b77f93b07956C6fB3e8 , 1 ether ) ; addToWhitelist ( 0xe415638FC30b277EC7F466E746ABf2d406f821FF , 1 ether ) ; addToWhitelist ( 0xE4A12D142b218ed96C75AA8D43aa153dc774F403 , 1 ether ) ; addToWhitelist ( 0xEEBEA0A8303aAc18D2cABaca1033f04c4a43E358 , 1 ether ) ; addToWhitelist ( 0xf12059ad0EB7D393E41AC3b3250FB5E446AA8dFB , 1 ether ) ; addToWhitelist ( 0xF94EfB6049B7bca00cE8e211C9A3f5Ca7ff4800b , 1 ether ) ; addToWhitelist ( 0xFBCe0CBB70bD0Bf43B11f721Beaf941980C5fF4a , 1 ether ) ; addToWhitelist ( 0x573648f395c26f453bf06Fd046a110A016274710 , 1.2 ether ) ; addToWhitelist ( 0x95159e796569A9A7866F9A6CF0E36B8D6ddE9c02 , 1.2 ether ) ; addToWhitelist ( 0xEafF321951F891EBD791eF57Dc583A859626E295 , 1.2 ether ) ; chunk4IsAdded = true ; }
","Add chunk 4 / 7 to the whitelist
"
"function setRateFees ( uint256 _rateFeesNumerator , uint256 _rateFeesDenominator ) external onlyOwner { rateFeesNumerator = _rateFeesNumerator ; rateFeesDenominator = _rateFeesDenominator ; emit UpdateRateFees ( rateFeesNumerator , rateFeesDenominator ) ; }
","Sets the fees rate .
"
"function setPrices ( uint256 newSellPrice , uint256 newSellMultiplier , uint256 newBuyPrice , uint256 newBuyMultiplier ) onlyOwner public { sellPrice = newSellPrice ; sellMultiplier = newSellMultiplier ; buyPrice = newBuyPrice ; buyMultiplier = newBuyMultiplier ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth .
"
"function setMasterFeeContract ( Data storage self , address contractAddress ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.contract.master' ) ) ; require ( self . Storage . setAddress ( id , contractAddress ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set the master fee contract used as the default fee contract when none is provided
"
"function withdraw ( ) pre_cond ( isBeneficiary ( ) ) pre_cond ( isVestingStarted ( ) ) { uint withdrawable = calculateWithdrawable ( ) ; withdrawn = withdrawn . add ( withdrawable ) ; require ( MELON_CONTRACT . transfer ( beneficiary , withdrawable ) ) ; }
","Withdraw
"
"function reduce ( uint256 amount ) isPeonyContract returns ( bool ) { require ( balances [ owner ] . sub ( amount ) >= 0 ) ; require ( totalSupply . sub ( amount ) >= 0 ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; totalSupply = totalSupply . sub ( amount ) ; return true ; }
","Reduce digital artwork tokens for changing physical artwork
"
"function distributeTokens ( address _token , address [ ] _to , uint256 [ ] _value ) external onlyOwner { require ( _to . length == _value . length ) ; ERC20 token = ERC20 ( _token ) ; for ( uint256 i = 0 ; i < _to . length ; i ++ ) { token . transfer ( _to [ i ] , _value [ i ] ) ; } }
","distribute tokens
"
"function manualTransfer ( address _to , uint256 _value ) public onlyOwner returns ( bool success ) { require ( totalSupply >= _value ) ; require ( ! frozenAccount [ _to ] ) ; totalSupply -= _value ; balanceOf [ _to ] += _value ; emit Transfer ( address ( 0 ) , _to , _value ) ; return true ; }
","Manual transfer for investors who paid from payment cards
"
"function issueAttribute ( bool doYouLoveCats , bool doYouLoveDogsMoreThanCats , bool areYouACrazyCatLady ) external { require ( doYouLoveCats , ""only cat lovers allowed"" ) ; require ( doYouLoveDogsMoreThanCats , ""no liars allowed"" ) ; require ( ! areYouACrazyCatLady , ""we are very particular"" ) ; require ( _issueAttribute ( msg . sender ) ) ; }
","Issue an attribute of the type with the default ID to ` msg.sender ` on the jurisdiction .
"
"function poll ( uint _idPoll ) public view returns ( uint _startBlock , uint _endBlock , bool _canVote , bool _canceled , bytes _description , uint8 _numBallots , bool _finalized , uint _voters , address _author , uint [ 15 ] _tokenTotal , uint [ 15 ] _quadraticVotes ) { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll storage p = _polls [ _idPoll ] ; _startBlock = p . startBlock ; _endBlock = p . endBlock ; _canceled = p . canceled ; _canVote = canVote ( _idPoll ) ; _description = p . description ; _numBallots = p . numBallots ; _author = p . author ; _finalized = ( ! p . canceled ) && ( block . number >= _endBlock ) ; _voters = p . voters ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { _tokenTotal [ i ] = p . results [ i ] ; _quadraticVotes [ i ] = p . qvResults [ i ] ; } }
","Get Poll info
"
"function createRequestAsPayeeAction ( address [ ] _payeesIdAddress , bytes _payeesPaymentAddress , int256 [ ] _expectedAmounts , address _payer , bytes _payerRefundAddress , string _data ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( msg . sender == _payeesIdAddress [ 0 ] && msg . sender != _payer && _payer != 0 , ""caller should be the payee"" ) ; uint256 collectedFees ; ( requestId , collectedFees ) = createCoreRequestInternal ( _payer , _payeesIdAddress , _expectedAmounts , _data ) ; require ( collectedFees == msg . value , ""fees should be the correct amout"" ) ; extractAndStoreBitcoinAddresses ( requestId , _payeesIdAddress . length , _payeesPaymentAddress , _payerRefundAddress ) ; return requestId ; }
","Function to create a request as payee .
"
"function setNextUpgradeAgent ( address agent ) external { if ( agent == 0x0 ) revert ( ) ; if ( msg . sender != nextUpgradeMaster ) revert ( ) ; nextUpgradeAgent = NextUpgradeAgent ( agent ) ; if ( ! nextUpgradeAgent . isUpgradeAgent ( ) ) revert ( ) ; nextUpgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( nextUpgradeAgent ) ; }
","Set address of next upgrade target contract and enable upgrade process .
"
"function addNFToken ( address _to , uint256 _tokenId ) noOwnerExists ( _tokenId ) internal { nft [ _tokenId ] . owner = _to ; ownerToTokenList [ _to ] . push ( _tokenId ) ; }
","Use and override this function with caution .
"
"function increasePot ( ) public payable { pot += msg . value ; }
","Donate the message value to the pot
"
"function moveTokensToAddress ( bytes16 _uuid , address _address , uint256 _tokensCount ) onlyAllowedAddresses onlyRegisteredAccount ( _uuid ) whenNotPaused public returns ( bool ) { removeTokensFromAccount ( _uuid , _tokensCount ) ; rntToken . transfer ( _address , _tokensCount ) ; tokens = tokens . sub ( _tokensCount ) ; tokenTransfers [ _address ] = _uuid ; return true ; }
","Function for withdrawal tokens from Vault account to address .
"
"function adjustTotalSupplyCheckpoints ( ) internal { adjustCheckpoints ( checkpointTotalSupply , totalSupply ( ) ) ; }
","adjust totalsupply at checkpoint after minting or burning tokens
"
"function getModule ( address _module ) external view returns ( bytes32 , address , address , bool , uint8 , uint256 , uint256 ) ;
","Returns module list for a module type
"
"function tokenAddress ( ) constant returns ( address ) { return data . token ; }
","Returns the address of the token .
"
"function removeNFToken ( address _from , uint256 _tokenId ) internal { super . removeNFToken ( _from , _tokenId ) ; assert ( ownerToIds [ _from ] . length > 0 ) ; uint256 tokenToRemoveIndex = idToOwnerIndex [ _tokenId ] ; uint256 lastTokenIndex = ownerToIds [ _from ] . length . sub ( 1 ) ; uint256 lastToken = ownerToIds [ _from ] [ lastTokenIndex ] ; ownerToIds [ _from ] [ tokenToRemoveIndex ] = lastToken ; ownerToIds [ _from ] . length -- ; idToOwnerIndex [ lastToken ] = tokenToRemoveIndex ; idToOwnerIndex [ _tokenId ] = 0 ; }
","Use and override this function with caution .
"
"function refund ( ) minCapNotReached salePeriodCompleted registeredUser isValidState external { require ( msg . sender != gmtFundAddress ) ; uint256 gmtVal = balances [ msg . sender ] ; require ( gmtVal > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( gmtVal ) ; assignedSupply = assignedSupply . sub ( gmtVal ) ; uint256 ethVal = gmtVal . div ( tokenExchangeRate ) ; msg . sender . transfer ( ethVal ) ; RefundSent ( msg . sender , ethVal ) ; }
","Allows contributors to recover their ETH in the case of a failed token sale
"
"function fill ( address makerAddress , uint makerAmount , address makerToken , address takerAddress , uint takerAmount , address takerToken , uint256 expiration , uint256 nonce , uint8 v , bytes32 r , bytes32 s ) external payable ;
","Fills an order by transferring tokens between ( maker or escrow ) and taker
"
"function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return approved [ _owner ] [ _spender ] ; }
","Check ` _value ` tokens allowed to ` _spender ` by ` _owner `
"
"function setTransferAgent ( address who ) public onlyIssuer { transferAgent = who ; }
","Set the address of the Transfer Agent .
"
"function hurmint ( address _client , uint256 _value ) onlyowner public { require ( totalToken <= totalHurify ) ; uint256 numHur = _value * ( 10 ** decimals ) ; balances [ owner ] = safeSub ( balances [ owner ] , numHur ) ; balances [ _client ] = safeAdd ( balances [ _client ] , numHur ) ; totalToken = safeAdd ( totalToken , numHur ) ; Transfer ( owner , _client , numHur ) ; }
","Transfer token with only value
"
"function rolloverFeePeriodIfElapsed ( ) public { if ( now >= feePeriodStartTime + feePeriodDuration ) { lastFeesCollected = nomin . feePool ( ) ; lastFeePeriodStartTime = feePeriodStartTime ; feePeriodStartTime = now ; emitFeePeriodRollover ( now ) ; } }
","Check if the fee period has rolled over .
"
"function halvingSubsidy ( uint256 _halving ) public constant notBeforeGenesis returns ( uint256 ) { uint256 startBlock = halvingStartBlock ( _halving ) ; return blockSubsidy ( startBlock ) . mul ( subsidyHalvingInterval ) ; }
","Computes the subsidy of a full halving
"
"function setSelfDestructBeneficiary ( address _beneficiary ) external onlyOwner { require ( _beneficiary != address ( 0 ) , ""Beneficiary must not be the zero address"" ) ; selfDestructBeneficiary = _beneficiary ; emit SelfDestructBeneficiaryUpdated ( _beneficiary ) ; }
","Set the beneficiary address of this contract .
"
"function setMinSellAmount ( uint256 _minSellAmount ) onlyOwner public { minSellAmount = _minSellAmount ; }
","set minimal amount of ether which can be used to buy tokens
"
"function distributeTokens ( address _to , uint256 _amount ) public onlyOwnerOrCrowdsale { require ( _to != address ( 0 ) ) ; require ( _amount > 0 ) ; require ( tokensRaised . add ( _amount ) <= crowdsaleTokens ) ; tokensRaised = tokensRaised . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; }
","To distribute the presale and ICO tokens and increase the total supply accordingly .
"
"function anyTokenWithdrawal ( address _address , uint _amount ) public onlyOwner { require ( _address != address ( tokenReward ) ) ; StandardToken token = StandardToken ( _address ) ; token . transfer ( beneficiary , _amount ) ; TokensWithdraw ( beneficiary , _address , _amount ) ; }
","Withdraws tokens other than DGZ to beneficiary .
"
"function addRole ( address addr , string role ) public onlyOwnerOrAdmin { roles [ addr ] [ role ] = true ; emit RoleAdded ( addr , role ) ; }
","Add a role to an address .
"
"function getFeeFlat ( Data storage self , address contractAddress ) internal view returns ( uint feeFlat ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.flat' , contractAddress ) ) ; return self . Storage . getUint ( id ) ; }
","Get the flat fee of the contract address ; typically TokenIOFeeContract
"
"function getPreICOBonus ( ) internal constant returns ( uint ) { return 33 ; }
","pre-ICO bonus
"
"function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safeSub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
","Transfer tokens from one account to the other
"
"function updateCounters ( uint256 _etherAmount ) internal ;
","Updates the counters for the amount of Ether paid
"
"function extractBytes32 ( bytes _data , uint offset ) public pure returns ( bytes32 bs ) { require ( offset >= 0 && offset + 32 <= _data . length , ""offset value should be in the correct range"" ) ; assembly { bs := mload ( add ( _data , add ( 32 , offset ) ) ) } }
","Extracts a bytes32 from a bytes .
"
"function getCurrencySymbol ( ) external view returns ( bytes32 ) { return bytes32 ( ""ETH"" ) ; }
","Returns symbol of oracle currency ( 0x0 for ETH )
"
"function registerAudits ( bytes32 [ ] _codeHashes , bytes _reportIPFS , bool _isApproved ) public { for ( uint i = 0 ; i < _codeHashes . length ; i ++ ) { registerAudit ( _codeHashes [ i ] , _reportIPFS , _isApproved ) ; } }
","marks multiple contracts as audited
"
"function launchContract ( ) public onlyOwner returns ( bool launched ) { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; LaunchContract ( msg . sender , true ) ; return true ; }
","Used to launch the contract
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _tokenId ) { require ( _index < balanceOf ( _owner ) ) ; return ownedTokens [ _owner ] [ _index ] ; }
","Enumerate NFTs assigned to an owner
"
"function verifyTransfer ( address , address _to , uint256 , bytes , bool ) public returns ( Result ) { if ( ! paused ) { if ( maxHolderCount < ISecurityToken ( securityToken ) . getInvestorCount ( ) ) { if ( ISecurityToken ( securityToken ) . balanceOf ( _to ) != 0 ) { return Result . NA ; } return Result . INVALID ; } return Result . NA ; } return Result . NA ; }
","Used to verify the transfer transaction and prevent a transfer if it passes the allowed amount of token holders
"
"function getStats ( uint256 _tokenId ) public view returns ( uint8 [ STATS_SIZE ] ) { return assets [ _tokenId ] . stats ; }
","Returns only stats data about a specific asset .
"
"function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( saleAuction ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","Required for ERC-20 and ERC-721 compliance .
"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }
","Get the allowance of an specified address to use another address balance .
"
"function addVest ( address _vester , uint256 _totalAmountToVest , uint256 [ ] _releaseDates , uint256 [ ] _releaseAmounts ) public nonActiveVester ( _vester ) onlyAdmin returns ( bool ) { require ( _releaseDates . length > 0 && _releaseAmounts . length > 0 && _totalAmountToVest > 0 , ""attempting to use non zero values"" ) ; require ( _releaseDates . length == _releaseAmounts . length , ""array lengths are not equal"" ) ; uint256 total ; for ( uint256 i = 0 ; i < _releaseAmounts . length ; i ++ ) { total = total . add ( _releaseAmounts [ i ] ) ; require ( now < _releaseDates [ i ] , ""release date must be in the future"" ) ; } require ( total == _totalAmountToVest , ""invalid total amount to vest"" ) ; Vest memory v = Vest ( { totalVest : _totalAmountToVest , releaseDates : _releaseDates , releaseAmounts : _releaseAmounts , state : VestState . vesting } ) ; vests [ _vester ] = v ; require ( RTI . transferFrom ( msg . sender , address ( this ) , _totalAmountToVest ) , ""transfer from failed, most likely needs approval"" ) ; return true ; }
","Used to deposit a vest for someone Mythril will report an overflow here , however it is a false positive
"
"function issueAndFreeze ( address _to , uint _value , uint _freezePeriod ) onlyOwner public { _transfer ( msg . sender , _to , _value ) ; freezeAccount [ _to ] = FreezeAccountInfo ( { freezeStartTime : now , freezePeriod : _freezePeriod , freezeTotal : _value } ) ; emit IssueAndFreeze ( _to , _value , _freezePeriod ) ; }
","Issue tokens to account and these tokens will be frozen for a period of time
"
"function acceptSellOffer ( uint32 _canvasId ) external payable stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; SellOffer memory sellOffer = canvasForSale [ _canvasId ] ; require ( msg . sender != canvas . owner ) ; require ( sellOffer . isForSale ) ; require ( msg . value >= sellOffer . minPrice ) ; require ( sellOffer . seller == canvas . owner ) ; require ( sellOffer . onlySellTo == 0x0 || sellOffer . onlySellTo == msg . sender ) ; uint toTransfer ; ( , , toTransfer ) = _registerTrade ( _canvasId , msg . value ) ; addPendingWithdrawal ( sellOffer . seller , toTransfer ) ; addressToCount [ canvas . owner ] -- ; addressToCount [ msg . sender ] ++ ; canvas . owner = msg . sender ; _cancelSellOfferInternal ( _canvasId , false ) ; emit CanvasSold ( _canvasId , msg . value , sellOffer . seller , msg . sender ) ; BuyOffer memory offer = buyOffers [ _canvasId ] ; if ( offer . buyer == msg . sender ) { buyOffers [ _canvasId ] = BuyOffer ( false , 0x0 , 0 ) ; if ( offer . amount > 0 ) { addPendingWithdrawal ( offer . buyer , offer . amount ) ; } } }
","Buy artwork .
"
"function addOwner ( address _who ) public onlyOwner returns ( bool ) { _setOwner ( _who , true ) ; }
","Adds the owner role to provided address
"
"function dissolveTokenGroup ( uint256 _tokenId ) external onlyCOO whenForking { var group = tokenIndexToGroup [ _tokenId ] ; require ( group . exists ) ; require ( group . purchasePrice == 0 ) ; for ( uint i = 0 ; i < tokenIndexToGroup [ _tokenId ] . contributorArr . length ; i ++ ) { address userAdd = tokenIndexToGroup [ _tokenId ] . contributorArr [ i ] ; var userContribution = group . addressToContribution [ userAdd ] ; _clearGroupRecordInContributor ( _tokenId , userAdd ) ; tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] = 0 ; tokenIndexToGroup [ _tokenId ] . addressToContributorArrIndex [ userAdd ] = 0 ; userAddressToContributor [ userAdd ] . withdrawableBalance += userContribution ; ProceedsDeposited ( _tokenId , userAdd , userContribution ) ; } activeGroups -= 1 ; tokenIndexToGroup [ _tokenId ] . exists = false ; }
","Group is dissolved after fn call
"
"function updateDetails ( bytes32 _details ) public returns ( bool allowed ) { require ( _details != 0x0 ) ; require ( owner == msg . sender ) ; bytes32 prevDetails = details ; details = _details ; DetailsUpdated ( prevDetails , details , now ) ; return true ; }
","` updateDetails `
"
"function addLocation ( uint _location ) onlyOwner public { locations . push ( _location ) ; }
","Admin function to add a location
"
"function setMaxGasPrice ( uint256 _maxGasPrice ) public onlyOwner { maxGasPrice = _maxGasPrice ; }
","Updates max gas price for crowdsale transactions
"
"function buy ( ) public payable { internalBuy ( msg . sender , msg . value , true ) ; }
","ICO participation
"
"function requestInvestment ( uint giveQuantity , uint shareQuantity , address investmentAsset ) external pre_cond ( ! isShutDown ) pre_cond ( isInvestAllowed [ investmentAsset ] ) pre_cond ( modules . compliance . isInvestmentPermitted ( msg . sender , giveQuantity , shareQuantity ) ) { requests . push ( Request ( { participant : msg . sender , status : RequestStatus . active , requestAsset : investmentAsset , shareQuantity : shareQuantity , giveQuantity : giveQuantity , receiveQuantity : shareQuantity , timestamp : now , atUpdateId : modules . pricefeed . getLastUpdateId ( ) } ) ) ; emit RequestUpdated ( getLastRequestId ( ) ) ; }
","Give melon tokens to receive shares of this fund
"
"function withdraw ( uint64 idPledge , uint amount ) { idPledge = normalizePledge ( idPledge ) ; Pledge storage p = findPledge ( idPledge ) ; require ( p . pledgeState == PledgeState . Pledged ) ; PledgeAdmin storage owner = findAdmin ( p . owner ) ; checkAdminOwner ( owner ) ; uint64 idNewPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Paying ) ; doTransfer ( idPledge , idNewPledge , amount ) ; vault . authorizePayment ( bytes32 ( idNewPledge ) , owner . addr , amount ) ; }
","This method is used to withdraw value from the system .
"
"function getPendingManager ( ) public view returns ( address ) { return pendingManager ; }
","Return pending manager address
"
"function getPlotData ( uint256 plotIndex ) public view returns ( string ipfsHash , string url , bool plotBlocked ) { require ( plotIndex < ownership . length ) ; return ( data [ plotIndex ] . url , data [ plotIndex ] . ipfsHash , plotBlockedTags [ plotIndex ] ) ; }
","Gets the data stored with a specific plot .
"
"function changeFactorySubscriptionFee ( uint256 _newSubscriptionCost ) external ;
","Used to change the subscription fee
"
"function _processBonus ( address _beneficiary , uint256 _tokenAmount ) internal { uint256 bonusTokens = getBonusTokens ( _tokenAmount ) ; if ( BONUS_TOKENS < bonusTokens ) { bonusTokens = BONUS_TOKENS ; } if ( bonusTokens > 0 ) { BONUS_TOKENS = BONUS_TOKENS . sub ( bonusTokens ) ; token . transfer ( _beneficiary , bonusTokens ) ; emit BonusSent ( address ( token ) , _beneficiary , _tokenAmount , bonusTokens ) ; tokensSold = tokensSold . add ( bonusTokens ) ; } }
","Function to calculate bonus from bought tokens .
"
"function setOracleQueryType ( string _oracleQueryType ) onlyOwner public { oracleQueryType = _oracleQueryType ; }
","Allows owner to set type used in Oraclize queries
"
"function release ( address account ) public isVestedAccount ( account ) { uint256 unreleased = releasableAmount ( account ) ; require ( unreleased > 0 ) ; beneficiary [ account ] . releasedAmount = beneficiary [ account ] . releasedAmount . add ( unreleased ) ; token . transfer ( account , unreleased ) ; emit Released ( account , unreleased ) ; if ( beneficiary [ account ] . releasedAmount == beneficiary [ account ] . totalAmount ) { delete beneficiary [ account ] ; } }
","Transfers available vested tokens to the beneficiary .
"
"function setRentAuctionContractAddress ( address _address ) external onlyOwner { RentAuction _contract = RentAuction ( _address ) ; require ( _contract . isRentAuction ( ) ) ; rentAuctionContract = _contract ; }
","Set the contract address of the rent auction .
"
"function seal ( ) { if ( now < endFundingTime ) throw ; tokenContract . seal ( ) ; }
","` seal ( ) ` ends the Campaign by calling ` seal ( ) ` in the CampaignToken contract
"
"function setTokensContract ( address _addressSCTokens ) public onlyOwner { addressSCTokens = _addressSCTokens ; SCTokens = Tokens ( _addressSCTokens ) ; }
","Set the tokens contract
"
"function mintToken ( address _target , uint _mintedAmount ) onlyOwner public { balances [ _target ] = balances [ _target ] . add ( _mintedAmount ) ; _totalSupply = _totalSupply . add ( _mintedAmount ) ; Transfer ( address ( 0 ) , _target , _mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` _target `
"
"function withdrawERC20 ( address _tokenContract , uint256 _value ) external ;
","Allows the owner to withdraw unspent POLY stored by them on the ST or any ERC20 token .
"
"function getCurrentSellOffer ( uint32 _canvasId ) external view returns ( bool isForSale , address seller , uint minPrice , address onlySellTo ) { SellOffer storage offer = canvasForSale [ _canvasId ] ; return ( offer . isForSale , offer . seller , offer . minPrice , offer . onlySellTo ) ; }
","Returns current sell offer for the canvas .
"
"function onERC721Received ( address _from , uint256 _tokenId , bytes _data ) public returns ( bytes4 ) ;
","Handle the receipt of an NFT
"
"function tokenPriceInEuroCents ( ) public constant returns ( uint ) ;
","price of one token ( 1e18 wei-tokens ) in euro cents
"
"function addToAccountList ( address addr ) internal { require ( ! readOnly , ""Read only mode engaged"" ) ; addressLinkedList [ addr ] = addressLinkedList [ 0x0 ] ; addressLinkedList [ 0x0 ] = addr ; accountCount ++ ; }
","Add an account to a linked list
"
"function mintPartOfEmission ( address to , uint part , uint partOfEmissionForPublicSales ) public payloadSizeIs ( 32 * 3 ) validAddress ( to ) requiresState ( State . MINTING2POOLS ) onlyBy ( m_pools ) { uint poolTokens = m_publiclyDistributedTokens . mul ( part ) . div ( partOfEmissionForPublicSales ) ; m_SMR . mint ( to , poolTokens ) ; }
","Mints tokens to predefined token pools after public sales
"
"function updateCurrentGameCardId ( uint256 _gameCardNumber , uint256 _playerId ) public whenNotPaused { require ( contractsApprovedList [ msg . sender ] ) ; NFT memory obj = _getAttributesOfToken ( _playerId ) ; obj . currentGameCardId = _gameCardNumber ; if ( _gameCardNumber == 0 ) { obj . isAttached = 0 ; } else { obj . isAttached = 1 ; } allNFTs [ _playerId ] = obj ; }
","Updates the gameCardID properrty of the asset
"
"function removeAsset ( address ofAsset , uint assetIndex ) auth pre_cond ( assetInformation [ ofAsset ] . exists ) { require ( registeredAssets [ assetIndex ] == ofAsset ) ; delete assetInformation [ ofAsset ] ; delete registeredAssets [ assetIndex ] ; for ( uint i = assetIndex ; i < registeredAssets . length - 1 ; i ++ ) { registeredAssets [ i ] = registeredAssets [ i + 1 ] ; } registeredAssets . length -- ; assert ( ! assetInformation [ ofAsset ] . exists ) ; }
","Deletes an existing entry
"
"function numberOfAuthorizedPayments ( ) public view returns ( uint ) { return authorizedPayments . length ; }
","States the total number of authorized payments in this contract
"
"function setGameStarterDividendPercentage ( uint256 _gameStarterDividendPercentage ) external onlyCFO { require ( 500 <= _gameStarterDividendPercentage && _gameStarterDividendPercentage <= 4000 ) ; gameStarterDividendPercentage = _gameStarterDividendPercentage ; }
","Sets a new game starter dividend percentage .
"
"function balanceOf ( address _owner ) public view returns ( uint count ) { return howManyDoYouHave [ _owner ] ; }
","Returns the number of rabbits owned by a specific address .
"
"function addPoll ( uint _startBlock , uint _endBlock , bytes _description , uint8 _numBallots ) public onlySNTHolder returns ( uint _idPoll ) { require ( _endBlock > block . number , ""End block must be greater than current block"" ) ; require ( _startBlock >= block . number && _startBlock < _endBlock , ""Start block must not be in the past, and should be less than the end block"" ) ; require ( _numBallots <= 15 , ""Only a max of 15 ballots are allowed"" ) ; _idPoll = _polls . length ; _polls . length ++ ; Poll storage p = _polls [ _idPoll ] ; p . startBlock = _startBlock ; p . endBlock = _endBlock ; p . voters = 0 ; p . numBallots = _numBallots ; p . description = _description ; p . author = msg . sender ; emit PollCreated ( _idPoll ) ; }
","Create a Poll
"
"function transferFrom ( address from , address to , uint256 value ) returns ( bool ) { if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value && safeAdd ( balances [ to ] , value ) > balances [ to ] ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { return false ; } }
","This function is disabled during the funding .
"
"function isMakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) { return true ; }
","Checks if the makeOrder price is reasonable and not manipulative
"
"function totalSupply ( ) public view returns ( uint256 _supply ) ;
","Returns the total token supply .
"
"function updateCounters ( uint256 _etherAmount ) internal { totalEtherPaid = totalEtherPaid . add ( _etherAmount ) ; }
","Updates the counters for the amount of Ether paid
"
"function renameCollection ( uint64 _collectionIndex , bytes8 _name ) validIndex ( _collectionIndex ) public returns ( uint64 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; uint64 [ ] storage collection = collectionTokens [ _collectionIndex ] ; require ( collection . length > 0 , ""Collection has been cleared"" ) ; for ( uint i = 0 ; i < collection . length ; i ++ ) { PixelCon storage pixelcon = pixelcons [ collection [ i ] ] ; require ( isCreatorAndOwner ( msg . sender , pixelcon . tokenId ) , ""Sender is not the creator and owner of the PixelCons"" ) ; } collectionNames [ _collectionIndex ] = _name ; emit RenameCollection ( _collectionIndex , _name ) ; return _collectionIndex ; }
","Rename collection # ` ( _collectionIndex ) `
"
"function setLastBidId ( bytes32 _newBidId ) internal { lastBidId = _newBidId ; }
","Internal function to set most recent bidId This value is stored to avoid conflicts between Advertisement contract upgrades .
"
"function calculateTimeout ( ) public view returns ( uint256 ) { if ( wagerIndex >= numberOfWagersToMinimumTimeout || numberOfWagersToMinimumTimeout == 0 ) { return minimumTimeout ; } else { uint256 difference = timeout - minimumTimeout ; uint256 decrease = difference . mul ( wagerIndex ) . div ( numberOfWagersToMinimumTimeout ) ; return ( timeout - decrease ) ; } }
","Calculate the current game 's timeout .
"
"function getVaultBalance ( ) onlyAllowedAddresses public constant returns ( uint256 ) { return rntToken . balanceOf ( ) ; }
","Get current amount of tokens on Vault address .
"
"function getInstructions ( ) public view returns ( string ) { return ""Add and remove permissions for the SecurityToken and associated modules. Permission types should be encoded as bytes32 values, and attached using the withPerm modifier to relevant functions.No initFunction required."" ; }
","Get the Instructions that helped to used the module
"
"function partyHash ( address address_one , address address_two ) internal constant returns ( bytes32 ) { if ( address_one < address_two ) { return sha3 ( address_one , address_two ) ; } else { return sha3 ( address_two , address_one ) ; } }
","Get the hash of the two addresses
"
"function setGameStarterDividendPercentage ( uint256 _gameStarterDividendPercentage ) external onlyCFO { require ( 500 <= _gameStarterDividendPercentage && _gameStarterDividendPercentage <= 5000 ) ; gameStarterDividendPercentage = _gameStarterDividendPercentage ; }
","Sets a new game starter dividend percentage .
"
"function setPoolToOpen ( ) public isAdmin isClosed { state = PoolState . OPEN ; emit PoolIsOpen ( ) ; }
","Allows the admin to set the state of the pool to OPEN .
"
"function pause ( ) public onlyOwner { require ( now < endTime ) ; super . _pause ( ) ; }
","pause ( overridden function )
"
"function withdrawFreeBalance ( ) external onlyCFO { uint256 freeBalance = this . balance . sub ( totalPayments ) . sub ( prizePool ) . sub ( wagerPool ) ; cfoAddress . transfer ( freeBalance ) ; }
","Withdraw ( unowed ) contract balance .
"
"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner { requireMultiple ( _amount ) ; mTotalSupply = mTotalSupply . add ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , """" , _operatorData , true ) ; emit Minted ( msg . sender , _tokenHolder , _amount , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( 0x0 , _tokenHolder , _amount ) ; } }
","Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .
"
"function getTagsByType ( uint8 _moduleType ) external view returns ( bytes32 [ ] , address [ ] ) { address [ ] memory modules = getModulesByType ( _moduleType ) ; return _tagsByModules ( modules ) ; }
","Returns all the tags related to the a module type which are valid for the given token
"
"function getTotalDepositsAmountLeft ( ) public view returns ( uint _amount ) { uint _lastDepositDate = lastDepositDate ; for ( uint _startDate = firstDepositDate ; _startDate <= _lastDepositDate || _startDate != 0 ; _startDate = distributionDeposits [ _startDate ] . nextDepositDate ) { _amount = _amount . add ( distributionDeposits [ _startDate ] . left ) ; } }
","Gets total amount of deposits that has left after users ' bonus withdrawals
"
"function allowTransfers ( bool _transferable ) onlyController { transferable = _transferable ; }
","Allows founders to set transfers before October12_2017
"
"function callWithdraw ( address realitycheck ) onlyOwner public { RealityCheckAPI ( realitycheck ) . withdraw ( ) ; }
","Withdraw any accumulated question fees from the specified address into this contract
"
"function unpause ( ) public onlyCEO whenPaused { paused = false ; Unpaused ( ) ; }
","called by the CEO to unpause , returns to normal state
"
"function getEuroCollected ( ) public constant returns ( uint ) { return wei2euroCents ( getWeiCollected ( ) ) . div ( 100 ) ; }
","amount of euro collected
"
"function getTokenMinted ( ) public constant returns ( uint ) ;
","amount of tokens minted ( NOT equal to totalSupply ( ) in case token is reused ! )
"
"function getBuyPrices ( uint256 _gameID , uint256 [ ] memory _keys ) public view isActivated ( _gameID ) returns ( uint256 , uint256 [ ] ) { uint256 _totalEth = 0 ; uint256 _nt = game_ [ _gameID ] . numberOfTeams ; uint256 [ ] memory _eth = new uint256 [ ] ( _nt ) ; uint256 i ; require ( _nt == _keys . length , ""Incorrect number of teams"" ) ; for ( i = 0 ; i < _nt ; i ++ ) { if ( _keys [ i ] > 0 ) { _eth [ i ] = getBuyPrice ( _gameID , i , _keys [ i ] ) ; _totalEth = _totalEth . add ( _eth [ i ] ) ; } } return ( _totalEth , _eth ) ; }
","Get the prices buyer have to pay for next keys for all teams .
"
"function convertToUSD ( FundRaiseType _fundRaiseType , uint256 _amount ) public view returns ( uint256 ) { uint256 rate = getRate ( _fundRaiseType ) ; return DecimalMath . mul ( _amount , rate ) ; }
","This function converts from ETH or POLY to USD
"
"function unlock ( ) external { require ( block . number > unlockedAtBlockNumber ) ; if ( ! synchroCoin . transfer ( businessAddress , synchroCoin . balanceOf ( this ) ) ) revert ( ) ; }
","Transfer locked tokens to Synchrolife 's wallet
"
"function listAcceptedTokens ( ) public view returns ( address [ ] ) { return tokensList ; }
","Returns an array of all accepted token .
"
"function retrieveFunds ( ) public onlyController { uint sntBalance = SNT . balanceOf ( address ( this ) ) ; require ( SNT . transfer ( msg . sender , sntBalance ) , ""Transfer did not work"" ) ; selfdestruct ( msg . sender ) ; }
","Extract balance in ETH + SNT from the contract
"
"function getListing ( uint64 _pixelconIndex ) public view returns ( address _seller , uint256 _startPrice , uint256 _endPrice , uint256 _currPrice , uint64 _startDate , uint64 _duration , uint64 _timeLeft ) { Listing storage listing = marketPixelconListings [ _pixelconIndex ] ; require ( listing . seller != address ( 0 ) , ""Market listing does not exist"" ) ; _seller = listing . seller ; _startPrice = uint256 ( listing . startAmount ) * WEI_PER_GWEI ; _endPrice = uint256 ( listing . endAmount ) * WEI_PER_GWEI ; _currPrice = calcCurrentPrice ( uint256 ( listing . startAmount ) , uint256 ( listing . endAmount ) , uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; _startDate = listing . startDate ; _duration = listing . duration ; _timeLeft = calcTimeLeft ( uint256 ( listing . startDate ) , uint256 ( listing . duration ) ) ; }
","Get the details of the market listings for PixelCon # ` ( _pixelconIndex ) `
"
"function setAllowance ( address _owner , address _spender , uint256 _value ) public onlyImpl { allowed [ _owner ] [ _spender ] = _value ; }
","Sets how much ` _owner ` allows ` _spender ` to transfer on behalf of ` _owner ` .
"
"function cancelOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { revert ( ) ; }
","Cancel is not implemented on exchange for smart contracts
"
"function propExists ( bytes32 _propID ) view public returns ( bool ) { return proposals [ _propID ] . processBy > 0 ; }
","Determines whether a proposal exists for the provided proposal ID
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }
","Transfer a Property owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return ownerOperators [ _owner ] [ _operator ] ; }
","Query if an address is an authorized operator for another address
"
"function newRepoWithVersion ( string _name , address _dev , uint16 [ 3 ] _initialSemanticVersion , address _contractAddress , bytes _contentURI ) public auth ( CREATE_REPO_ROLE ) returns ( Repo ) { Repo repo = _newRepo ( _name , this ) ; repo . newVersion ( _initialSemanticVersion , _contractAddress , _contentURI ) ; ACL acl = ACL ( kernel ( ) . acl ( ) ) ; acl . revokePermission ( this , repo , repo . CREATE_VERSION_ROLE ( ) ) ; acl . grantPermission ( _dev , repo , repo . CREATE_VERSION_ROLE ( ) ) ; acl . setPermissionManager ( _dev , repo , repo . CREATE_VERSION_ROLE ( ) ) ; return repo ; }
","Create new repo in registry with ` _name ` and first repo version
"
"function newDaoRulesProposal ( uint _minQuorumDivisor , uint _minBoardMeetingFees , uint _minutesSetProposalPeriod , uint _minMinutesDebatePeriod , uint _feesRewardInflationRate , bool _transferable , address _dao , uint _minutesDebatingPeriod ) payable returns ( uint ) ;
","Function to make a proposal to change the Dao rules
"
"function withdrawPool ( uint256 amountToWithdraw ) public onlyOwner { if ( amountToWithdraw > 0 ) { require ( totalPoolBalance >= amountToWithdraw && ixtToken . transfer ( msg . sender , amountToWithdraw ) , ""Unable to withdraw this value of IXT."" ) ; totalPoolBalance = SafeMath . sub ( totalPoolBalance , amountToWithdraw ) ; } emit PoolWithdraw ( msg . sender , amountToWithdraw ) ; }
","This function can only be called by the contract owner
"
"function withdrawByAdmin_Unau ( uint256 [ ] inputs ) external onlyAdmin { uint256 amount = inputs [ 0 ] ; uint256 gasFee = inputs [ 1 ] ; uint256 data = inputs [ 2 ] ; uint256 paymentMethod = data & PAYMENT_METHOD_MASK ; address token = tokenId2Address [ ( data & WITHDRAW_TOKEN_MASK ) >> 32 ] ; address user = userId2Address [ data & USER_MASK ] ; bytes32 hash = keccak256 ( this , amount , gasFee , data & SIGN_MASK | uint256 ( token ) ) ; require ( ! usedHash [ hash ] ) ; require ( verify ( hash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ 3 ] ) , bytes32 ( inputs [ 4 ] ) ) ) ; address gasToken = 0 ; if ( paymentMethod == PAY_BY_JOY ) { gasToken = joyToken ; } else if ( paymentMethod == PAY_BY_TOKEN ) { gasToken = token ; } if ( gasToken == token ) { balances [ token ] [ user ] = balances [ token ] [ user ] . sub ( amount . add ( gasFee ) ) ; } else { balances [ token ] [ user ] = balances [ token ] [ user ] . sub ( amount ) ; balances [ gasToken ] [ user ] = balances [ gasToken ] [ user ] . sub ( gasFee ) ; } balances [ gasToken ] [ joysoWallet ] = balances [ gasToken ] [ joysoWallet ] . add ( gasFee ) ; usedHash [ hash ] = true ; if ( token == 0 ) { user . transfer ( amount ) ; } else { require ( ERC20 ( token ) . transfer ( user , amount ) ) ; } }
","withdraw with admins involved , only admin
"
"function getBudget ( Campaign storage _campaign ) internal view returns ( uint _budget ) { return _campaign . budget ; }
","Get campaign total budget
"
"function approve ( address _spender , uint256 _value ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) ) ; return super . approve ( _spender , _value ) ; }
","Approves a wallet address to spend on behalf of the sender .
"
"function CancelAuction ( ) public isOwner atStage ( Stages . AuctionStarted ) { token . transfer ( walletAddress , numTokensAuctioned ) ; stage = Stages . AuctionCanceled ; AuctionCanceled ( ) ; }
","Canceled the auction
"
"function computeStablecoinFee ( uint256 _amount , address _stablecoin ) public view returns ( uint256 ) { uint256 fee = fees [ _stablecoin ] ; return computeFee ( _amount , fee ) ; }
","Compute the fee that will be charged on a `` burn '' operation .
"
"function finalizePresale ( ) whenNotPaused onlyOwner external { require ( isPresaleStarted && ! isPresaleFinalized ) ; require ( presaleFinalizeAgent . isSane ( ) ) ; uint256 presaleSupply = token . totalSupply ( ) ; presaleSupply = presaleSupply . div ( 5 ) ; presaleFinalizeAgent . finalizePresale ( presaleSupply ) ; uint tokenWei = presaleFinalizeAgent . weiPerToken ( ) ; pricingStrategy . setTokenPriceInWei ( tokenWei ) ; TokensPerWeiReceived ( tokenWei ) ; require ( tokenWei > 0 ) ; currentStatus = Status . Unknown ; isPresaleFinalized = true ; presaleEndTime = now ; PresaleFinalized ( presaleEndTime ) ; }
","Finalize presale , calculate token price , track finalize time .
"
"function getPayeeExpectedAmount ( bytes32 _requestId , uint8 _payeeIndex ) public view returns ( int256 ) { if ( _payeeIndex == 0 ) { return requests [ _requestId ] . payee . expectedAmount ; } else { return subPayees [ _requestId ] [ _payeeIndex - 1 ] . expectedAmount ; } }
","Gets amount expected of a payee .
"
"function tokensup ( uint256 _value ) onlyowner public { totalHurify = safeAdd ( totalHurify , _value * ( 10 ** decimals ) ) ; balances [ owner ] = safeAdd ( balances [ owner ] , _value * ( 10 ** decimals ) ) ; }
","Alter the Total Supply .
"
"function getState ( ) public constant returns ( State ) { if ( finalizedCrowdfunding ) return State . Success ; if ( block . number < fundingStartBlock ) return State . PreFunding ; else if ( block . number <= fundingEndBlock && totalSupply < tokenCreationMax ) return State . Funding ; else if ( totalSupply >= tokenCreationMin ) return State . Success ; else return State . Failure ; }
","This manages the crowdfunding state machine We make it a function and do not assign the result to a variable So there is no chance of the variable being stale
"
"function getPartialAmount ( uint numerator , uint denominator , uint target ) public pure returns ( uint ) { return numerator . mul ( target ) . div ( denominator ) ; }
","Calculates partial value given a numerator and denominator .
"
"function BTImint ( address _client , uint256 _value ) onlyowner public { require ( totalToken <= totalBhinneka ) ; uint256 numBTI = _value * ( 10 ** decimals ) ; balances [ owner ] = safeSub ( balances [ owner ] , numBTI ) ; balances [ _client ] = safeAdd ( balances [ _client ] , numBTI ) ; totalToken = safeAdd ( totalToken , numBTI ) ; Transfer ( owner , _client , numBTI ) ; }
","Transfer token with only value
"
"function addBounty ( address _hunter , uint256 _amount ) onlyOwner public { require ( _hunter != 0x0 ) ; require ( toWei ( _amount ) <= safeSub ( bonusAndBountyTokens , toWei ( _amount ) ) ) ; bounties [ _hunter ] = safeAdd ( bounties [ _hunter ] , toWei ( _amount ) ) ; bonusAndBountyTokens = safeSub ( bonusAndBountyTokens , toWei ( _amount ) ) ; emit AddBounty ( _hunter , toWei ( _amount ) ) ; }
","set token for bounty hunter to release when ICO success
"
"function onApprove ( address _owner , address _spender , uint256 _amount ) returns ( bool ) ;
","Notifies the controller about an approval allowing the controller to react if desired
"
"function _checkSig ( bytes32 _hash , uint8 _v , bytes32 _r , bytes32 _s ) internal view { address signer = ecrecover ( keccak256 ( abi . encodePacked ( ""\x19Ethereum Signed Message:\n32"" , _hash ) ) , _v , _r , _s ) ; require ( signer == Ownable ( securityToken ) . owner ( ) || signer == signingAddress , ""Incorrect signer"" ) ; }
","Used to verify the signature
"
"function _sameClassAxiesPrice ( uint8 _class , uint256 _quantity ) private view returns ( uint256 _totalPrice , uint256 _currentIncrement , uint256 _currentPrice ) { _currentIncrement = priceIncrement [ _class ] ; _currentPrice = currentPrice [ _class ] ; uint256 _nextPrice ; for ( uint256 i = 0 ; i < _quantity ; i ++ ) { _totalPrice = _totalPrice . add ( _currentPrice ) ; _nextPrice = _currentPrice . add ( _currentIncrement ) ; if ( _nextPrice / 100 finney != _currentPrice / 100 finney ) { _currentIncrement >>= 1 ; } _currentPrice = _nextPrice ; } }
","Calculate price of Axies from the same class .
"
"function decreaseApproval ( address _spender , uint256 _subtractedValue ) public canTransfer ( msg . sender ) whenNotPaused returns ( bool ) { require ( _spender != address ( 0 ) ) ; return super . decreaseApproval ( _spender , _subtractedValue ) ; }
","Decreases the approval of the spender .
"
"function setTransferEnabled ( bool enable ) onlyOwner public { token . setTransferEnabled ( enable ) ; }
","Allows to enable or dissable token transfers
"
"function balanceOf ( address who ) public view returns ( uint256 ) { return isOwner ( who ) ? m_SMR . balanceOf ( this ) : 0 ; }
","Balance of tokens .
"
"function sendTokens ( address msg_sender , uint msg_value ) internal { var prices = price1stWeek ; if ( now >= startTime + 2 weeks ) prices = price3rdWeek ; else if ( now >= startTime + 1 weeks ) prices = price2ndWeek ; uint currentPrice = prices [ 0 ] ; if ( balanceOf [ msg_sender ] + msg_value >= discountValue5 ) { currentPrice = prices [ 1 ] ; if ( balanceOf [ msg_sender ] + msg_value >= discountValue10 ) currentPrice = prices [ 2 ] ; } uint amountSendTokens = msg_value / currentPrice ; if ( amountSendTokens > ( tokensAvailableForSale - tokensSoldOnPublicRound ) ) { uint tokensAvailable = tokensAvailableForSale - tokensSoldOnPublicRound ; uint refund = msg_value - ( tokensAvailable * currentPrice ) ; amountSendTokens = tokensAvailable ; tokensSoldOnPublicRound += amountSendTokens ; msg_sender . transfer ( refund ) ; balanceOf [ msg_sender ] += ( msg_value - refund ) ; } else { tokensSoldOnPublicRound += amountSendTokens ; balanceOf [ msg_sender ] += msg_value ; } tokenReward . transfer ( msg_sender , amountSendTokens ) ; DGZTokensSold ( msg_sender , amountSendTokens ) ; }
","Internal function which is responsible for sending tokens .
"
"function enableTransfers ( bool _transfersEnabled ) ownerOrController public { transfersEnabled = _transfersEnabled ; }
","Enables token holders to transfer their tokens freely if true
"
"function changeTitle ( string _newTitle ) public onlyOwner { require ( bytes ( _newTitle ) . length > 0 , ""Invalid title"" ) ; title = _newTitle ; }
","Updates the title of the ModuleFactory
"
"function submitLocation ( uint encryptKey , uint8 locationNumber ) public payable { require ( encryptKey != 0 ) ; require ( locationNumber < locations . length ) ; if ( ! grace ) { require ( msg . value >= cost ) ; uint contribution = cost - cost / 10 ; ownersBalance += cost - contribution ; pot += contribution ; } hunters [ msg . sender ] [ locationNumber ] = KeyLog ( encryptKey , block . number ) ; }
","The message value must be greater than ` cost `
"
"function setBTHFoundationWallet ( address _wallet ) external onlymanyowners ( sha3 ( msg . data ) ) nonZeroAddress ( _wallet ) { bthFoundationWallet = _wallet ; LogBTHFoundationWalletChanged ( _wallet ) ; }
","Set the bthFoundation wallet
"
"function requestRedemption ( uint shareQuantity , uint receiveQuantity , bool isNativeAsset ) external pre_cond ( ! isShutDown ) pre_cond ( isRedeemAllowed ) pre_cond ( module . compliance . isRedemptionPermitted ( msg . sender , shareQuantity , receiveQuantity ) ) { requests . push ( Request ( { participant : msg . sender , status : RequestStatus . active , requestType : RequestType . redeem , requestAsset : isNativeAsset ? address ( NATIVE_ASSET ) : address ( QUOTE_ASSET ) , shareQuantity : shareQuantity , giveQuantity : shareQuantity , receiveQuantity : receiveQuantity , timestamp : now , atUpdateId : module . pricefeed . getLastUpdateId ( ) } ) ) ; RequestUpdated ( getLastRequestId ( ) ) ; }
","Give shares of this fund to receive melon tokens
"
"function mint ( address _holder , uint256 _tokens ) public onlyMintingAgents ( ) { require ( allowedMinting == true && totalSupply_ . add ( _tokens ) <= maxSupply ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ _holder ] = balanceOf ( _holder ) . add ( _tokens ) ; if ( totalSupply_ == maxSupply ) { allowedMinting = false ; } emit Mint ( _holder , _tokens ) ; }
","allow to mint tokens
"
"function bulkTransfer ( address [ ] _destinations , uint256 [ ] _amounts ) public onlyAdmin { require ( _destinations . length == _amounts . length ) ; uint256 requiredBalance = sumOf ( _amounts ) ; require ( balances [ msg . sender ] >= requiredBalance ) ; for ( uint256 i = 0 ; i < _destinations . length ; i ++ ) { transfer ( _destinations [ i ] , _amounts [ i ] ) ; } emit BulkTransferPerformed ( _destinations , _amounts ) ; }
","Allows only the admins and/or whitelisted applications to perform bulk transfer operation .
"
"function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( saleAuction ) ) ; require ( _to != address ( siringAuction ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","Transfers a Dog to another address .
"
"function getDescription ( ) public view returns ( string ) { return ""Create ETH dividends for token holders at a specific checkpoint"" ; }
","Get the description of the Module
"
"function doBuy ( address _caller , uint256 etherAmount ) internal { Contribution ( etherAmount , _caller ) ; uint256 callerTokens = etherAmount . mul ( CALLER_EXCHANGE_RATE ) ; uint256 callerTokensWithDiscount = applyDiscount ( etherAmount , callerTokens ) ; uint256 reserveTokens = etherAmount . mul ( RESERVE_EXCHANGE_RATE ) ; uint256 founderTokens = etherAmount . mul ( FOUNDER_EXCHANGE_RATE ) ; uint256 bountyTokens = etherAmount . mul ( BOUNTY_EXCHANGE_RATE ) ; uint256 vestingTokens = founderTokens . add ( reserveTokens ) ; founderTokenCount = founderTokenCount . add ( founderTokens ) ; reserveTokenCount = reserveTokenCount . add ( reserveTokens ) ; payAffiliate ( callerTokensWithDiscount , msg . value , msg . sender ) ; shp . generateTokens ( _caller , callerTokensWithDiscount ) ; shp . generateTokens ( bountyAddress , bountyTokens ) ; shp . generateTokens ( trusteeAddress , vestingTokens ) ; NewSale ( _caller , etherAmount , callerTokensWithDiscount ) ; NewSale ( trusteeAddress , etherAmount , vestingTokens ) ; NewSale ( bountyAddress , etherAmount , bountyTokens ) ; etherEscrowAddress . transfer ( etherAmount ) ; updateCounters ( etherAmount ) ; }
","This method sends the Ether received to the Ether escrow address and generates the calculated number of SHP tokens , sending them to the caller 's address .
"
"function setRenewable ( uint256 _productId , bool _newRenewable ) external onlyCLevel { _setRenewable ( _productId , _newRenewable ) ; ProductRenewableChanged ( _productId , _newRenewable ) ; }
","setRenewable - sets if a product is renewable
"
"function allocate ( ) external { uint256 unallocated = address ( this ) . balance . sub ( balanceTotal ) ; require ( unallocated > 0 , ""No funds to allocate"" ) ; uint256 num_recipients = recipients . length ; uint256 each = unallocated / num_recipients ; require ( each > 0 , ""No money left to be allocated after rounding down"" ) ; uint256 i ; for ( i = 0 ; i < num_recipients ; i ++ ) { address recip = recipients [ i ] ; balanceOf [ recip ] = balanceOf [ recip ] . add ( each ) ; balanceTotal = balanceTotal . add ( each ) ; } assert ( address ( this ) . balance >= balanceTotal ) ; }
","Allocate any unallocated funds from the contract balance
"
"function quoteBid ( ) private returns ( uint256 ) { if ( initialSaleComplete ) { bid = fracExp ( 1e16 , R , ( _totalSupply / 1e16 ) - 1 , P ) ; } else { bid = ICObid ; } return bid ; }
","Calculates the bid price in wei per aToken based on the current reserve amount
"
"function addVineyardEndorsement ( string _mappingID , uint _index , bool positive , string title , string description ) external returns ( bool success ) { vineyardEndorsements [ keccak256 ( _mappingID , _index ) ] . push ( Endorsement ( positive , title , description , msg . sender ) ) ; return true ; }
","Add new endorsement to a vineyard
"
"function get ( MapStorage storage self , uint index ) public view returns ( address ) { require ( index < self . addresses . length ) ; return self . addresses [ index ] ; }
","Retrieves a address from the given ` MapStorage ` using a index Key .
"
"function transferToGrant ( uint256 _id , uint256 _amount ) public onlyOwner { require ( _id < tokenGrants . length && _amount > 0 && now <= tokenGrants [ _id ] . start ( ) ) ; require ( ethealToken . transfer ( address ( tokenGrants [ _id ] ) , _amount ) ) ; }
","Transfer tokens to a grant until it is starting
"
"function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = propertyIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
","Returns the address currently assigned ownership of a given Property .
"
"function releaseToAdvisor ( address _beneficiary , uint256 _releaseAmount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , ""Beneficiary is not whitelisted"" ) ; require ( now >= releaseTimeToUnlockAdvisorTokens , ""Release Advisor tokens on or after GMT: Wednesday, 21 August 2019 00:00:00"" ) ; uint256 releaseAmount = _releaseAmount . mul ( E18 ) ; require ( totalTokensIssuedToAdvisor . add ( releaseAmount ) <= ADVISORS_SUPPLY_LIMIT ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( releaseAmount ) ; totalTokensIssuedToAdvisor = totalTokensIssuedToAdvisor . add ( releaseAmount ) ; emit Released ( _releaseAmount ) ; }
","Transfers vested tokens to Advisor .
"
"function convertSafe ( TokenConverter converter , Token from , Token to , uint256 amount ) internal returns ( uint256 bought ) { require ( from . approve ( converter , amount ) , ""Error approve convert safe"" ) ; uint256 prevBalance = to . balanceOf ( this ) ; bought = converter . convert ( from , to , amount , 1 ) ; require ( to . balanceOf ( this ) . sub ( prevBalance ) >= bought , ""Bought amount incorrect"" ) ; require ( from . approve ( converter , 0 ) , ""Error remove approve convert safe"" ) ; }
","Converts tokens using a token converter
"
"function cancelAuction ( uint256 _axieId ) external { Auction storage _auction = auctions [ _axieId ] ; require ( _isOnAuction ( _auction ) ) ; require ( msg . sender == _auction . seller ) ; _cancelAuction ( _axieId , _auction . seller ) ; }
","This is a state-modifying function that can be called while the contract is paused .
"
"function ( ) payable { buy ( ) ; }
","entry to buy tokens
"
"function removeBlacklistedUser ( address _who ) public onlyValidator { _removeBlacklistedUser ( _who ) ; }
","Removes the necessary permissions for a `` blacklisted '' user .
"
"function updateEthUsdManually ( uint _newEthUsd ) public onlyOwner { require ( _newEthUsd > 0 ) ; uint256 newRate = _newEthUsd . mul ( 10 ** 18 ) ; require ( newRate > 0 ) ; ethUsd = newRate ; }
","An integer is required ( e.g .
"
"function updateMinimumBond ( uint256 _nextMinimumBond ) external onlyOwner { nextMinimumBond = _nextMinimumBond ; }
","Allows the contract owner to update the minimum bond .
"
"function getChannelWith ( Data storage self , address partner ) constant returns ( address ) { bytes32 party_hash = partyHash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; if ( channel_pos != 0 ) { return self . all_channels [ channel_pos - 1 ] ; } }
","Get the address of channel with a partner
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external { _safeTransferFrom ( _from , _to , _tokenId , """" ) ; }
","This works identically to the other function with an extra data parameter , except this function just sets data to `` ''
"
"function removeUserPermission ( address _who , bytes4 _methodsignature ) public onlyValidator { require ( permissions [ _methodsignature ] . active , ""Permission being removed must be for a valid method signature"" ) ; userPermissions [ _who ] [ _methodsignature ] = false ; }
","Removes a permission from the list of permissions that a user has .
"
"function getCertification ( address student ) payable requestFeePaid returns ( bool certified , uint256 timestamp , address certifier , uint256 documentCount ) { Certification certification = studentCertifications [ student ] ; return ( certification . certified , certification . timestamp , certification . certifier , certification . documents . length ) ; }
","Requesting a certification is a paying feature .
"
"function milestoneCompleted ( uint _idMilestone ) onlyRecipient campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( milestone . status != MilestoneStatus . AcceptedAndInProgress ) throw ; if ( now < milestone . minCompletionDate ) throw ; if ( now > milestone . maxCompletionDate ) throw ; milestone . status = MilestoneStatus . Completed ; milestone . doneTime = now ; ProposalStatusChanged ( _idMilestone , milestone . status ) ; }
","` onlyRecipient ` Marks a milestone as DONE and ready for review
"
"function approve ( address _approved , uint256 _tokenId ) external canOperate ( _tokenId ) validNFToken ( _tokenId ) { address tokenOwner = idToOwner [ _tokenId ] ; require ( _approved != tokenOwner ) ; idToApprovals [ _tokenId ] = _approved ; emit Approval ( tokenOwner , _approved , _tokenId ) ; }
","The zero address indicates there is no approved address .
"
"function worktimeAtDate ( uint256 _collected_at ) public view returns ( uint256 ) { return ( now - _collected_at ) / 60 ; }
","function for compute worktime factory
"
"function approveAndCall ( address spender , uint256 amount , bytes extraData ) public returns ( bool success ) ;
","` msg.sender ` approves ` spender ` to send ` amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` spender ` .
"
"function ownerWithdraw ( uint256 value ) external onlyOwner { if ( now <= PRESALE_END_DATE ) throw ; if ( totalFunding < PRESALE_MINIMUM_FUNDING ) throw ; if ( ! owner . send ( value ) ) throw ; }
","The owner can withdraw ethers after the presale has completed , only if the minimum funding level has been reached
"
"function isUserEnabledForContract ( address marketContractAddress , address userAddress ) external view returns ( bool ) { return contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ userAddress ] >= lockQtyToAllowTrading ; }
","checks if a user address has locked the needed qty to allow trading to a given contract address
"
"function acceptOwnership ( ) public { require ( msg . sender == newOwner ) ; OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; }
","accept ownership of the contract
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalLoans = loans . length - 1 ; uint256 resultIndex = 0 ; uint256 loanId ; for ( loanId = 0 ; loanId <= totalLoans ; loanId ++ ) { if ( loans [ loanId ] . lender == _owner && loans [ loanId ] . status == Status . lent ) { result [ resultIndex ] = loanId ; resultIndex ++ ; } } return result ; } }
","Returns all the loans that a lender possess
"
"function _setCampaign ( bytes32 bidId , uint price , uint budget , uint startDate , uint endDate , bool valid , address owner ) public onlyIfWhitelisted ( ""setCampaign"" , msg . sender ) { CampaignLibrary . Campaign storage campaign = campaigns [ bidId ] ; campaign . setBidId ( bidId ) ; campaign . setPrice ( price ) ; campaign . setBudget ( budget ) ; campaign . setStartDate ( startDate ) ; campaign . setEndDate ( endDate ) ; campaign . setValidity ( valid ) ; bool newCampaign = ( campaigns [ bidId ] . getOwner ( ) == 0x0 ) ; campaign . setOwner ( owner ) ; if ( newCampaign ) { emitCampaignCreated ( campaign ) ; setLastBidId ( bidId ) ; } else { emitCampaignUpdated ( campaign ) ; } }
","Add or update a campaign information Based on a campaign Id ( bidId ) , a campaign can be created ( if non existent ) or updated .
"
"function getFirmFromAuthority ( Data storage self , address authorityAddress ) internal view returns ( string issuerFirm ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.authority.firm' , getForwardedAccount ( self , authorityAddress ) ) ) ; return self . Storage . getString ( id ) ; }
","Get the issuer firm registered to the authority Ethereum address
"
"function changeOwner ( address _newOwner ) onlyOwner { newOwner = _newOwner ; }
","` owner ` can step down and assign some other address to this role
"
"function getAuditOutcome ( address _auditor , bytes32 _codeHash ) public view returns ( uint8 ) { bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( _auditor , _codeHash ) ) ; return Audits [ hashAuditorCode ] . outcome ; }
","returns the outcome of the audit or NOT_AUDITED ( 0 ) if none
"
"function setMinter ( address _minter ) external onlyOwner validAddress ( _minter ) { minter = _minter ; }
","To set a new minter address
"
"function verifyTransfer ( address , address _to , uint256 _amount , bool ) public returns ( Result ) { if ( ! paused ) { if ( whitelist [ _to ] ) { return Result . NA ; } uint256 newBalance = ISecurityToken ( securityToken ) . balanceOf ( _to ) . add ( _amount ) ; if ( newBalance . mul ( 10 ** uint256 ( ISecurityToken ( securityToken ) . decimals ( ) ) ) . div ( ISecurityToken ( securityToken ) . totalSupply ( ) ) > maxHolderPercentage ) { return Result . INVALID ; } return Result . NA ; } return Result . NA ; }
","Used to verify the transfer transaction according to the rule implemented in the trnasfer managers
"
"function getName ( ) public view returns ( bytes32 ) { return ""CappedSTO"" ; }
","Get the name of the Module
"
"function setQuestionFee ( uint256 fee ) onlyOwner public { realitycheck . setQuestionFee ( fee ) ; LogSetQuestionFee ( fee ) ; }
","Set a fee for asking a question with us as the arbitrator
"
"function changeAccredited ( address [ ] _investors , bool [ ] _accredited ) public onlyOwner { require ( _investors . length == _accredited . length , ""Array length mismatch"" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { accredited [ _investors [ i ] ] = _accredited [ i ] ; emit SetAccredited ( _investors [ i ] , _accredited [ i ] ) ; } }
","Modifies the list of accredited addresses
"
"function unpause ( ) public onlyCEO whenPaused { require ( saleAuction != address ( 0 ) ) ; require ( siringAuction != address ( 0 ) ) ; require ( geneScience != address ( 0 ) ) ; require ( lottery != address ( 0 ) ) ; require ( variation != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function verifyModule ( address _moduleFactory , bool _verified ) external onlyOwner { require ( getUint ( Encoder . getKey ( ""registry"" , _moduleFactory ) ) != uint256 ( 0 ) , ""Module factory must be registered"" ) ; set ( Encoder . getKey ( ""verified"" , _moduleFactory ) , _verified ) ; emit ModuleVerified ( _moduleFactory , _verified ) ; }
","- > Only if Polymath enabled the feature .
"
"function supportsInterface ( bytes4 _interfaceId ) external view returns ( bool ) ;
","Query if a contract implements an interface
"
"function withdrawAll ( ) { Splitter . withdrawInternal ( 0 , true ) ; }
","Withdraws all funds available to the sender and deposits them into the sender 's account .
"
"function transfer ( address _to , uint256 _amount ) public userNotBlacklisted ( _to ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { require ( _to != address ( 0 ) , ""to address cannot be 0x0"" ) ; require ( _amount <= balanceOf ( msg . sender ) , ""not enough balance to transfer"" ) ; tokenStorage . subBalance ( msg . sender , _amount ) ; tokenStorage . addBalance ( _to , _amount ) ; emit Transfer ( msg . sender , _to , _amount ) ; return true ; }
","Initiates a `` send '' operation towards another user .
"
"function requestTokenPayment ( address _payer , address _receiver , uint256 _amount , bytes32 _nonce , bytes _paymentSig ) external onlyAttestationLogic { validatePaymentSig ( _payer , _receiver , _amount , _nonce , _paymentSig ) ; payTokensFromEscrow ( _payer , _receiver , _amount ) ; emit TokenMarketplaceEscrowPayment ( _payer , _receiver , _amount ) ; }
","Pay tokens to receiver from payer 's escrow given a valid signature
"
"function approvePreSignedHashing ( address _token , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0xf7ac9c2e ) , _token , _spender , _value , _fee , _nonce ) ; }
","Hash ( keccak256 ) of the payload used by approvePreSigned
"
"function isDataResponseValid ( address order , address seller , address notary , string dataHash , bytes signature ) public pure returns ( bool ) { require ( order != address ( 0 ) ) ; require ( seller != address ( 0 ) ) ; require ( notary != address ( 0 ) ) ; bytes memory packed = bytes ( dataHash ) . length > 0 ? abi . encodePacked ( order , notary , dataHash ) : abi . encodePacked ( order , notary ) ; bytes32 hash = keccak256 ( packed ) ; return isSignedBy ( hash , seller , signature ) ; }
","Checks if the parameters passed correspond to the seller 's signature used .
"
"function claimTokens ( address _token ) onlyOwner public { if ( _token == 0x0 ) { owner . transfer ( address ( this ) . balance ) ; return ; } TokenERC20 token = TokenERC20 ( _token ) ; uint balance = token . balanceOf ( address ( this ) ) ; token . transfer ( owner , balance ) ; }
","This method can be used by the owner to extract sent tokens or ethers to this contract .
"
"function collectAll ( uint8 max ) public returns ( uint8 collected ) { max = uint8 ( min ( max , contributors . length ) ) ; require ( max > 0 , ""can't collect for zero users"" ) ; uint index = contributors . length - 1 ; for ( uint offset = 0 ; offset < max ; ++ offset ) { address recipient = contributors [ index - offset ] ; if ( balances [ recipient ] > 0 ) { collected ++ ; collectFor ( recipient ) ; } } contributors . length -= offset ; }
","Collects the balances for members of the purchase
"
"function tokensOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 tokenId ) { uint256 count = 0 ; for ( uint256 i = 1 ; i <= totalSupply ( ) ; i ++ ) { if ( fighterIndexToOwner [ i ] == _owner ) { if ( count == _index ) { return i ; } else { count ++ ; } } } revert ( ) ; }
","Returns the nth Fighter assigned to an address , with n specified by the _index argument .
"
"function finishPreICO ( ) onlyOwner external { require ( state == State . PreICO ) ; require ( icoStartTimestamp != 0 && icoEndTimestamp != 0 ) ; state = State . ICO ; }
","Finish PreICO stage and start ICO ( after time comes )
"
"function getProjectLevel ( PledgeAdmin m ) internal returns ( uint ) { assert ( m . adminType == PledgeAdminType . Project ) ; if ( m . parentProject == 0 ) return ( 1 ) ; PledgeAdmin storage parentNM = findAdmin ( m . parentProject ) ; return getProjectLevel ( parentNM ) + 1 ; }
","A getter to find the level of authority a specific Project has using a self-referential loop
"
"function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; mAuthorized [ _operator ] [ msg . sender ] = true ; emit AuthorizedOperator ( _operator , msg . sender ) ; }
","Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( now < ICOdeadline && state != State . Successful ) { if ( state == State . Ongoin && totalRaised >= SoftCap ) { state = State . SoftCap ; completedAt = now ; } else if ( state == State . SoftCap && now > completedAt . add ( 24 hours ) ) { state == State . Successful ; closedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } } else if ( now > ICOdeadline && state != State . Successful ) { state = State . Successful ; if ( completedAt == 0 ) { completedAt = now ; } closedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
","check status
"
"function isResolverFor ( uint ein , address resolver ) public view returns ( bool ) { return identityDirectory [ ein ] . resolvers . contains ( resolver ) ; }
","Checks whether the passed resolver is set for the passed EIN .
"
"function unpause ( ) external onlyAdmin whenPaused { paused = false ; emit Unpaused ( ) ; }
","Unpauses the contract and returns to normal state .
"
"function registerAccount ( bytes16 _uuid ) public { accountsStatuses [ _uuid ] = true ; accountsCount = accountsCount . add ( 1 ) ; }
","Register account .
"
"function claimTokensByUser ( ) public { uint256 tokens = balance [ msg . sender ] ; balance [ msg . sender ] = 0 ; require ( tokenReward . transfer ( msg . sender , tokens ) ) ; tokensSent [ msg . sender ] = tokensSent [ msg . sender ] . add ( tokens ) ; emit LogContributorsPayout ( msg . sender , tokens ) ; }
","function to let users claim their tokens
"
"function getApproved ( uint256 _tokenId ) public view returns ( address ) { return tokenApprovals [ _tokenId ] ; }
","Gets the approved address to take ownership of a given token ID
"
"function _updateWhitelist ( address _account , uint8 _phase ) internal { if ( _phase == 1 ) { _whitelist [ _account ] = _invCap ; } else { _whitelist [ _account ] = 0 ; } emit WhitelistUpdated ( _account , _phase ) ; }
","function to whitelist an address which can be called only by the capper address .
"
"function eligibleForDividence ( address _user ) public view returns ( bool _success ) { if ( moneySpent [ _user ] == 0 ) { return false ; } else if ( ( balances [ _user ] + allowed [ selfAddress ] [ _user ] ) / moneySpent [ _user ] > 20 ) { return false ; } return true ; }
","Query whether the user is eligible for claiming dividence
"
"function alterBankBalance ( address _toAlter , uint256 _amount , bool sign ) external DAppOnline isAdmin { if ( sign && ( _amount + allowed [ selfAddress ] [ _toAlter ] ) > allowed [ selfAddress ] [ _toAlter ] ) { allowed [ selfAddress ] [ _toAlter ] = _amount + allowed [ selfAddress ] [ _toAlter ] ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } else { allowed [ selfAddress ] [ _toAlter ] = safeSub ( allowed [ selfAddress ] [ _toAlter ] , _amount ) ; Approval ( selfAddress , _toAlter , allowed [ selfAddress ] [ _toAlter ] ) ; } }
","Rise or lower user bank balance - Backend Function
"
"function approve ( address _approved , uint256 _tokenId ) external payable canOperate ( _tokenId ) { address _owner = _tokenOwnerWithSubstitutions [ _tokenId ] ; if ( _owner == address ( 0 ) ) { _owner = address ( this ) ; } tokenApprovals [ _tokenId ] = _approved ; emit Approval ( _owner , _approved , _tokenId ) ; }
","Change or reaffirm the approved address for an NFT
"
"function approve ( address spender , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; tokenState . setAllowance ( sender , spender , value ) ; emitApproval ( sender , spender , value ) ; return true ; }
","Approves spender to transfer on the message sender 's behalf .
"
"function addMember ( bytes32 _membershipNumber , address _memberAddress , bytes32 _invitationCode , bytes32 _referralInvitationCode ) public onlyValidator isNotMember ( _memberAddress ) notStaking ( _memberAddress ) { require ( _memberAddress != address ( 0x0 ) , ""Member address was set to 0."" ) ; Member memory member = Member ( { addedTimestamp : block . timestamp , stakeTimestamp : 0 , startOfLoyaltyRewardEligibility : 0 , membershipNumber : _membershipNumber , invitationCode : _invitationCode , stakeBalance : 0 , invitationRewards : 0 , previouslyAppliedLoyaltyBalance : 0 } ) ; members [ _memberAddress ] = member ; membersArray . push ( _memberAddress ) ; registeredInvitationCodes [ member . invitationCode ] = _memberAddress ; address rewardMemberAddress = registeredInvitationCodes [ _referralInvitationCode ] ; if ( rewardMemberAddress != address ( 0x0 ) ) { Member storage rewardee = members [ rewardMemberAddress ] ; rewardee . invitationRewards = SafeMath . add ( rewardee . invitationRewards , invitationReward ) ; emit InvitationRewardGiven ( rewardMemberAddress , _memberAddress , invitationReward ) ; } emit MemberAdded ( _memberAddress , _membershipNumber , _invitationCode ) ; }
","This function can only be called by a `` validator '' which is set inside the constructor
"
"function owner ( bytes32 _symbol ) public view returns ( address ) { return _address ( _assetOwner ( _symbol ) ) ; }
","Returns asset owner address .
"
"function assignShareTokens ( uint _count ) public onlyOwner { require ( status == state . success ) ; uint count = _count ; if ( winner_bids < assigned_bids . add ( count ) ) { count = winner_bids . sub ( assigned_bids ) ; } require ( count > 0 ) ; uint cursor = assigned_bids ; assigned_bids = assigned_bids . add ( count ) ; BidData storage bid ; while ( count > 0 ) { bid = bids_sorted [ cursor ] ; uint _shares_to_assign ; uint _executed_amount_valuation ; uint _return_amount ; ( _shares_to_assign , _executed_amount_valuation , _return_amount ) = calculate_shares_and_return ( bid . shares_count , bid . share_price , bid . transfer_valuation , final_share_price , bids [ bid . origin_index ] . art_price , bid . transfer_token ) ; bid . executed_amount = _executed_amount_valuation ; bid . asigned_shares_count = _shares_to_assign ; assigned_shares = assigned_shares . add ( _shares_to_assign ) ; final_fundraise = final_fundraise . add ( _executed_amount_valuation ) ; final_shares_sold = final_shares_sold . add ( _shares_to_assign ) ; if ( _return_amount > 0 ) { art_token_contract . transfer ( bid . investor_address , _return_amount ) ; } bid . closed = true ; if ( shares_holders_balance [ bid . investor_address ] == 0 ) { shares_holders [ shares_holders_count ++ ] = bid . investor_address ; } emit Assigned ( bid . origin_index , _shares_to_assign , _executed_amount_valuation , _return_amount ) ; shares_holders_balance [ bid . investor_address ] = shares_holders_balance [ bid . investor_address ] . add ( _shares_to_assign ) ; cursor ++ ; count -- ; } }
","Assign the asset share tokens to winner bid 's authors
"
"function withdrawBalance ( ) external onlyCEOOrCFO { require ( withdrawalAddress != address ( 0 ) ) ; withdrawalAddress . transfer ( this . balance ) ; }
","Withdraw the balance to the withdrawalAddress
"
"function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { remaining = TokenInfoController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_INFO ) ) . get_allowance ( _owner , _spender ) ; }
","check the spending allowance of a given user from a given account
"
"function findBestRate ( ERC20 src , ERC20 dest , uint srcAmount ) public view returns ( uint obsolete , uint rate ) { BestRateResult memory result = findBestRateTokenToToken ( src , dest , srcAmount , EMPTY_HINT ) ; return ( 0 , result . rate ) ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function acceptOwnership ( ) public { require ( msg . sender == newOwnerCandidate ) ; address oldOwner = owner ; owner = newOwnerCandidate ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }
","Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership
"
"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyAuthorized public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function getToken ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 sellingPrice , address owner , uint256 nextSellingPrice ) { tokenId = _tokenId ; sellingPrice = collectibleIndexToPrice [ _tokenId ] ; if ( sellingPrice == 0 ) sellingPrice = getInitialPriceOfToken ( _tokenId ) ; owner = collectibleIndexToOwner [ _tokenId ] ; nextSellingPrice = getNextPrice ( sellingPrice , _tokenId ) ; }
","Returns all the relevant information about a specific collectible .
"
"function freezeMinting ( ) external ;
","Ends token minting period permanently
"
"function fundsOf ( address _address ) constant returns ( uint valueWei ) { return funds [ _address ] ; }
","Amount of ether held for ` _address ` .
"
"function setFeePeriodDuration ( uint duration ) external optionalProxy_onlyOwner { require ( MIN_FEE_PERIOD_DURATION <= duration && duration <= MAX_FEE_PERIOD_DURATION , ""Duration must be between MIN_FEE_PERIOD_DURATION and MAX_FEE_PERIOD_DURATION"" ) ; feePeriodDuration = duration ; emitFeePeriodDurationUpdated ( duration ) ; rolloverFeePeriodIfElapsed ( ) ; }
","Set the targeted fee period duration .
"
"function setInterfaceImplementer ( address addr , bytes32 iHash , address implementer ) public canManage ( addr ) { interfaces [ addr ] [ iHash ] = implementer ; InterfaceImplementerSet ( addr , iHash , implementer ) ; }
","Sets the contract that will handle a specific interface ; only the address itself or a ` manager ` defined for that address can set it
"
"function setFallback ( address _fallback ) public onlyOwner returns ( bool ) { fallback = _fallback ; return true ; }
","Sets the address of another contract to handle the requests of this contract , it can be used to deprecate this Oracle
"
"function renounceOwnership ( ) public onlyOwner { emit OwnershipRenounced ( _owner ) ; _owner = address ( 0 ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function getRawPendingAmount ( uint index ) public view returns ( uint256 ) { Loan memory loan = loans [ index ] ; return safeSubtract ( safeAdd ( safeAdd ( loan . amount , loan . interest ) , loan . punitoryInterest ) , loan . paid ) ; }
","Returns the pending amount up to the last time of the interest update .
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = elementToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
","Returns the address currently assigned ownership of a given element .
"
"function applyBooster ( uint256 _tokenId , uint256 _booster ) onlyFishOwner ( _tokenId ) public { require ( msg . sender == boosters . ownerOf ( _booster ) ) ; require ( boosters . getBoosterAmount ( _booster ) >= 1 ) ; Fish storage tempFish = fishes [ _tokenId ] ; uint8 boosterType = uint8 ( boosters . getBoosterType ( _booster ) ) ; if ( boosterType == 1 || boosterType == 2 || boosterType == 3 ) { tempFish . boosterStrength = boosters . getBoosterStrength ( _booster ) ; tempFish . activeBooster = boosterType ; tempFish . boostedTill = boosters . getBoosterDuration ( _booster ) * boosters . getBoosterAmount ( _booster ) + uint64 ( now ) ; tempFish . boosterRaiseValue = boosters . getBoosterRaiseValue ( _booster ) ; } else if ( boosterType == 4 ) { require ( tempFish . boostedTill > uint64 ( now ) ) ; tempFish . boosterStrength = boosters . getBoosterStrength ( _booster ) ; tempFish . boostedTill += boosters . getBoosterDuration ( _booster ) * boosters . getBoosterAmount ( _booster ) ; } else if ( boosterType == 5 ) { require ( boosters . getBoosterAmount ( _booster ) == 1 ) ; tempFish . canFightAgain = 0 ; } require ( boosters . transferFrom ( msg . sender , address ( 0 ) , _booster ) ) ; BoosterApplied ( _tokenId , _booster ) ; }
","Apply a booster to a fish
"
"function transferFrom ( address _from , address _to , uint256 _value ) public payloadSizeIs ( 3 * 32 ) returns ( bool ) { thawSomeTokens ( _from , _value ) ; return super . transferFrom ( _from , _to , _value ) ; }
","Standard transferFrom overridden to have a chance to thaw sender 's tokens .
"
"function reclaimEther ( ) external onlyAdmin { msg . sender . transfer ( address ( this ) . balance ) ; }
","Transfers all Ether held by the contract to the owner .
"
"function setApprovalForAll ( address _operator , bool _approved ) external { if ( _approved ) { addressToApprovedAll [ msg . sender ] = _operator ; } else { delete addressToApprovedAll [ msg . sender ] ; } emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
","Enable or disable approval for a third party ( `` operator '' ) to manage all your asset .
"
"function setGuaranteedAddress ( address _th , uint256 _limit ) public initialized onlyOwner { require ( getBlockNumber ( ) < startBlock ) ; require ( _limit > 0 && _limit <= maxGuaranteedLimit ) ; guaranteedBuyersLimit [ _th ] = _limit ; GuaranteedAddress ( _th , _limit ) ; }
","Sets the limit for a guaranteed address .
"
"function createDividendWithCheckpointAndExclusions ( uint256 _maturity , uint256 _expiry , address _token , uint256 _amount , uint256 _checkpointId , address [ ] _excluded , bytes32 _name ) public withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _token , _amount , _checkpointId , _excluded , _name ) ; }
","Creates a dividend with a provided checkpoint
"
"function authorizePayment ( address _recipient , uint _amount , uint _paymentDelay ) returns ( uint ) { if ( ! allowedSpenders [ msg . sender ] ) throw ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; if ( _paymentDelay > 10 ** 18 ) throw ; p . earliestPayTime = _paymentDelay >= timeLock ? now + _paymentDelay : now + timeLock ; p . recipient = _recipient ; p . amount = _amount ; PaymentAuthorized ( idPayment , p . recipient , p . amount ) ; return idPayment ; }
","only ` allowedSpenders [ ] ` Creates a new ` Payment `
"
"function pickRandomAssetPosition ( uint _randomSeed , uint _width , uint _height ) public pure returns ( uint x , uint y , uint zoom , uint rotation , uint layer ) { x = _randomSeed % _width ; y = _randomSeed % _height ; zoom = _randomSeed % 200 + 800 ; rotation = _randomSeed % 360 ; layer = _randomSeed % 1234567 ; }
","Function to pick random position for an asset
"
"function updateTokenDetails ( string _newTokenDetails ) external ;
","Changes the tokenDetails
"
"function updateNameAndSymbol ( string _newname , string _newsymbol ) onlyOwner public { name = _newname ; symbol = _newsymbol ; }
","change token 's name and symbol
"
"function claimPlotWithData ( uint256 _deedId , uint256 _buyoutPrice , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; claimPlotMultipleWithData ( _deedIds , _buyoutPrice , name , description , imageUrl , infoUrl ) ; }
","Buy an unclaimed plot .
"
"function release ( string _id ) external onlyArbitrator { require ( escrows [ _id ] . exists ) ; EscrowDeposit storage escrowDeposit = escrows [ _id ] ; uint256 gasFees = RELEASE_GAS_FEES . mul ( tx . gasprice ) ; uint256 amount = escrowDeposit . amount . sub ( gasFees ) ; address bidder = escrowDeposit . bidder ; delete escrows [ _id ] ; accumulatedGasFees = accumulatedGasFees . add ( gasFees ) ; bidder . transfer ( amount ) ; emit Released ( msg . sender , bidder , amount , _id ) ; }
","Release ether from escrow .
"
"function getPrices ( address [ ] ofAssets ) view returns ( bool areRecent , uint [ ] prices , uint [ ] decimals ) { areRecent = true ; for ( uint i ; i < ofAssets . length ; i ++ ) { var ( isRecent , price , decimal ) = getPrice ( ofAssets [ i ] ) ; if ( ! isRecent ) { areRecent = false ; } prices [ i ] = price ; decimals [ i ] = decimal ; } }
","Price of a registered asset in format ( bool areRecent , uint [ ] prices , uint [ ] decimals )
"
"function playerForceGameEnd ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; require ( game . status == GameStatus . PLAYER_INITIATED_END ) ; int newBalance = conflictRes . playerForceGameEnd ( game . gameType , game . betNum , game . betValue , game . balance , game . stake , game . endInitiatedTime ) ; closeGame ( game , gameId , game . roundId , playerAddress , ReasonEnded . END_FORCED_BY_PLAYER , newBalance ) ; }
","Force end of game if server does not respond .
"
"function adminSetTokenURITemplate ( string _newTokenURITemplate ) public { require ( msg . sender == admin , ""Only the admin can call this function"" ) ; tokenURITemplate = _newTokenURITemplate ; }
","Change the token URI template
"
"function revealMulti ( uint256 [ ] _limits , uint256 [ ] _slopeFactors , uint256 [ ] _collectMinimums , bool [ ] _lasts , bytes32 [ ] _salts ) public { require ( _limits . length != 0 && _limits . length == _slopeFactors . length && _limits . length == _collectMinimums . length && _limits . length == _lasts . length && _limits . length == _salts . length ) ; for ( uint256 i = 0 ; i < _limits . length ; i = i . add ( 1 ) ) { revealCeiling ( _limits [ i ] , _slopeFactors [ i ] , _collectMinimums [ i ] , _lasts [ i ] , _salts [ i ] ) ; } }
","Reveal multiple ceilings at once
"
"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; address permissionManager = new GeneralPermissionManager ( msg . sender , address ( polyToken ) ) ; emit LogGenerateModuleFromFactory ( address ( permissionManager ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( permissionManager ) ; }
","used to launch the Module with the help of factory
"
"function withdrawAuctionBalance ( address beneficiary ) external { require ( msg . sender == beneficiary || msg . sender == address ( deedContract ) ) ; uint256 etherOwed = addressToEtherOwed [ beneficiary ] ; require ( etherOwed > 0 ) ; delete addressToEtherOwed [ beneficiary ] ; outstandingEther -= etherOwed ; beneficiary . transfer ( etherOwed ) ; }
","Withdraw ether owed to a beneficiary .
"
"function makeListing ( address _seller , uint256 _tokenId , uint256 _startPrice , uint256 _endPrice , uint256 _duration ) internal { require ( _startPrice <= maxPrice , ""Start price is higher than the max allowed"" ) ; require ( _startPrice >= minPrice , ""Start price is lower than the min allowed"" ) ; require ( _endPrice <= maxPrice , ""End price is higher than the max allowed"" ) ; require ( _endPrice >= minPrice , ""End price is lower than the min allowed"" ) ; _startPrice = _startPrice / WEI_PER_GWEI ; _endPrice = _endPrice / WEI_PER_GWEI ; require ( _endPrice > uint256 ( 0 ) , ""End price cannot be zero (gwei)"" ) ; require ( _startPrice >= _endPrice , ""Start price is lower than the end price"" ) ; require ( _startPrice < uint256 ( 2 ** 64 ) , ""Start price is out of bounds"" ) ; require ( _endPrice < uint256 ( 2 ** 64 ) , ""End price is out of bounds"" ) ; uint256 startDate = ( now / uint256 ( startDateRoundValue ) ) * uint256 ( startDateRoundValue ) ; require ( startDate < uint256 ( 2 ** 64 ) , ""Start date is out of bounds"" ) ; _duration = ( _duration / uint256 ( durationRoundValue ) ) * uint256 ( durationRoundValue ) ; require ( _duration > uint256 ( 0 ) , ""Duration cannot be zero"" ) ; require ( _duration <= uint256 ( maxDuration ) , ""Duration is higher than the max allowed"" ) ; require ( _duration >= uint256 ( minDuration ) , ""Duration is lower than the min allowed"" ) ; uint64 pixelconIndex = pixelconsContract . getTokenIndex ( _tokenId ) ; Listing storage listing = marketPixelconListings [ pixelconIndex ] ; listing . startAmount = uint64 ( _startPrice ) ; listing . endAmount = uint64 ( _endPrice ) ; listing . startDate = uint64 ( startDate ) ; listing . duration = uint64 ( _duration ) ; listing . seller = _seller ; uint64 [ ] storage sellerTokens = sellerPixelconIndexes [ _seller ] ; uint sellerTokensIndex = sellerTokens . length ; uint forSaleIndex = forSalePixelconIndexes . length ; require ( sellerTokensIndex < uint256 ( 2 ** 32 - 1 ) , ""Max number of market listings has been exceeded for seller"" ) ; require ( forSaleIndex < uint256 ( 2 ** 64 - 1 ) , ""Max number of market listings has been exceeded"" ) ; listing . sellerIndex = uint32 ( sellerTokensIndex ) ; listing . forSaleIndex = uint64 ( forSaleIndex ) ; sellerTokens . length ++ ; sellerTokens [ sellerTokensIndex ] = pixelconIndex ; forSalePixelconIndexes . length ++ ; forSalePixelconIndexes [ forSaleIndex ] = pixelconIndex ; emit Create ( pixelconIndex , _seller , _startPrice , _endPrice , uint64 ( _duration ) ) ; }
","Create market listing
"
"function addProposal ( uint _duration , bytes32 _storageHash ) public returns ( uint _proposalId ) { require ( _duration >= MIN_PROPOSAL_DURATION ) ; require ( _duration <= MAX_PROPOSAL_DURATION ) ; uint amount = MiniMeToken ( nectarToken ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; _proposalId = proposals . length ; proposals . length ++ ; Proposal storage p = proposals [ _proposalId ] ; p . storageHash = _storageHash ; p . duration = _duration * ( 1 days ) ; p . proposer = msg . sender ; emit NewProposal ( _proposalId , _duration , _storageHash ) ; }
","Add new proposal and put it in list to be approved
"
"function countValidators ( ) external view returns ( uint256 ) ;
","Count the number of validators defined by the jurisdiction .
"
"function licenseInfo ( uint256 _licenseId ) public view returns ( uint256 , uint256 , uint256 , uint256 , address ) { return ( licenseProductId ( _licenseId ) , licenseAttributes ( _licenseId ) , licenseIssuedTime ( _licenseId ) , licenseExpirationTime ( _licenseId ) , licenseAffiliate ( _licenseId ) ) ; }
","Get a license 's info
"
"function checkPermission ( address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { for ( uint256 i = 0 ; i < modules [ PERMISSION_KEY ] . length ; i ++ ) { if ( ! modulesToData [ modules [ PERMISSION_KEY ] [ i ] ] . isArchived ) return TokenLib . checkPermission ( modules [ PERMISSION_KEY ] , _delegate , _module , _perm ) ; } return false ; }
","Validate permissions with PermissionManager if it exists , If no Permission return false
"
"function hasAssetRights ( address _owner , bytes32 _symbol ) public view returns ( bool ) { uint holderId = getHolderId ( _owner ) ; return isCreated ( _symbol ) && ( assets [ _symbol ] . owner == holderId || assets [ _symbol ] . partowners [ holderId ] ) ; }
","Checks if a specified address has asset owner or co-owner rights .
"
"function ( ) external payable { _addToFund ( msg . value , true ) ; }
","No tipping !
"
"function unfreezeTransfers ( ) public onlyOwner { require ( freeze ) ; freeze = false ; emit LogFreezeTransfers ( freeze , now ) ; }
","un-freeze all the transfers
"
"function totalSupply ( ) external view returns ( uint256 ) { return TOTAL_SUPPLY ; }
","Count NFTs tracked by this contract
"
"function getSecurityTokenAddress ( string _symbol ) public view returns ( address ) { string memory __symbol = upper ( _symbol ) ; return symbols [ __symbol ] ; }
","Get security token address by ticker name
"
"function giveMeETH ( ) public auth { msg . sender . transfer ( address ( this ) . balance ) ; }
","transfer all ETH balance from this contract to the sender
"
"function goalReached ( ) internal { emit SoftcapReached ( treasury , fundingGoal ) ; fundingGoalReached = true ; if ( weiRaisedInPICO < fundingGoal ) { PICO . extGoalReached ( ) ; } }
","a function that changes state if goal reached .
"
"function updateWhitelist ( address _address , bool _status ) public onlyOwner { whitelisted [ _address ] = _status ; }
","update whitelisting address
"
"function _answerData ( bytes32 question_id , bytes32 last_history_hash , bytes32 last_answer_or_commitment_id , uint256 last_bond , address last_answerer , bool is_commitment ) internal view returns ( bool , bytes32 ) { bool is_pending_arbitration ; bytes32 history_hash ; if ( last_bond == 0 ) { return ( false , bytes32 ( 0 ) ) ; } bytes32 last_answer ; bool is_answered ; if ( is_commitment ) { uint256 reveal_ts ; bool is_revealed ; bytes32 revealed_answer ; ( reveal_ts , is_revealed , revealed_answer ) = realitio . commitments ( last_answer_or_commitment_id ) ; if ( is_revealed ) { last_answer = revealed_answer ; is_answered = true ; } else { require ( reveal_ts < uint32 ( now ) , ""Arbitration cannot be done until the last answerer has had time to reveal their commitment"" ) ; is_answered = false ; } } else { last_answer = last_answer_or_commitment_id ; is_answered = true ; } return ( is_answered , last_answer ) ; }
","Given the last history entry , get whether they had a valid answer if so what it was
"
"function buy ( ) public payable { require ( msg . value >= 20 ether ) ; uint256 rate = exchangeRate ( ) ; require ( rate > 0 ) ; uint256 requested = msg . value . mul ( rate ) ; Stage n_stage = stage ( ) ; require ( n_stage == Stage . Early || n_stage == Stage . Normal ) ; uint256 remained ; if ( n_stage == Stage . Early ) { remained = cornerstoneSupply . sub ( soldOut . cornerstoneValue ) ; } else { remained = vcSupply . sub ( soldOut . vcValue ) ; } if ( requested > remained ) { requested = remained ; } uint256 ethCost = requested . div ( rate ) ; if ( requested > 0 ) { you . createOption ( msg . sender , requested , uint32 ( endTime ) , 365 ) ; ethVault . transfer ( ethCost ) ; if ( n_stage == Stage . Early ) { soldOut . cornerstoneValue = requested . add ( soldOut . cornerstoneValue ) ; } else { soldOut . vcValue = requested . add ( soldOut . vcValue ) ; } LogSold ( msg . sender , requested , ethCost ) ; } uint256 toReturn = msg . value . sub ( ethCost ) ; if ( toReturn > 0 ) { msg . sender . transfer ( toReturn ) ; } }
","entry to buy tokens
"
"function transfer ( address _to , uint _value ) returns ( bool ) { if ( balances [ msg . sender ] >= _value ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
","` _value ` tokens will be sended to ` _to `
"
"function cloneOrder ( address _contractorAddress , uint _contractorProposalID , uint _orderAmount , uint _lastOrderDate ) { if ( projectManager != 0 ) throw ; addOrder ( _contractorAddress , _contractorProposalID , _orderAmount , _lastOrderDate ) ; }
","Function to allow cloning orders in case of upgrade
"
"function sell ( uint256 amount ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] >= amount ) ; require ( amount > 0 ) ; require ( sellPrice > 0 ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sellPrice ; msg . sender . transfer ( revenue ) ; }
","Sell metadollars and receive ether from contract
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) public { address tokenOwner = ownerOf ( _tokenId ) ; require ( isSenderApprovedFor ( _tokenId ) || ( approvedContractAddresses [ msg . sender ] && tokenOwner == tx . origin ) , ""not an approved sender"" ) ; require ( tokenOwner == _from , ""wrong owner"" ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , _to , _tokenId ) ; }
","Transfer a token owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function saleNonEther ( address beneficiary , uint256 amount , string ) public onlyOwner { mintTokens ( beneficiary , amount ) ; }
","Mint tokens for purshases with Non-Ether currencies
"
"function removeDarknode ( address darknodeID ) external onlyOwner { uint256 bond = darknodeRegistry [ darknodeID ] . bond ; delete darknodeRegistry [ darknodeID ] ; LinkedList . remove ( darknodes , darknodeID ) ; require ( ren . transfer ( owner , bond ) , ""bond transfer failed"" ) ; }
","Removes a darknode from the store and transfers its bond to the owner of this contract .
"
"function cumulativeInverse ( uint256 neumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public constant returns ( uint256 euroUlps ) { require ( maxEurUlps >= minEurUlps ) ; require ( cumulative ( minEurUlps ) <= neumarkUlps ) ; require ( cumulative ( maxEurUlps ) >= neumarkUlps ) ; uint256 min = minEurUlps ; uint256 max = maxEurUlps ; while ( max > min ) { uint256 mid = ( max + min ) / 2 ; uint256 val = cumulative ( mid ) ; if ( val < neumarkUlps ) { min = mid + 1 ; } else { max = mid ; } } return max ; }
","find issuance curve inverse by binary search
"
"function refund ( address recipient ) onlyOwner { RefundInvoice ( address ( this ) , now ) ; }
","Refund invoice
"
"function mintToken ( uint256 amount ) isOwner { require ( amount > 0 ) ; require ( tokenBalanceOf [ this ] <= icoMin ) ; require ( _totalSupply + amount > _totalSupply ) ; require ( tokenBalanceOf [ this ] + amount > tokenBalanceOf [ this ] ) ; _totalSupply += amount ; tokenBalanceOf [ this ] += amount ; allowed [ this ] [ owner ] = tokenBalanceOf [ this ] ; allowed [ this ] [ supervisor ] = tokenBalanceOf [ this ] ; tokenCreated ( msg . sender , amount , ""Additional tokens created!"" ) ; }
","Create an amount of token
"
"function insertAfter ( List storage self , address target , address newNode ) internal { require ( ! isInList ( self , newNode ) , ""already in list"" ) ; require ( isInList ( self , target ) || target == NULL , ""not in list"" ) ; address n = self . list [ target ] . next ; self . list [ newNode ] . previous = target ; self . list [ newNode ] . next = n ; self . list [ target ] . next = newNode ; self . list [ n ] . previous = newNode ; self . list [ newNode ] . inList = true ; }
","Insert a new node after an existing node .
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
"
"function ( ) payable { require ( ! sale_pause ) ; buy ( ) ; }
","standard fallback payable
"
"function initialize ( ) public onlyInit { initialized ( ) ; executorsNextIndex = 1 ; }
","Initialize the registry
"
"function executeTransaction ( address destination , uint value , bytes data ) public onlyOwner { if ( destination . call . value ( value ) ( data ) ) emit Execution ( destination , value , data ) ; else emit ExecutionFailure ( destination , value , data ) ; }
","Proxy function which allows sending of transactions in behalf of the contract
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < balanceOf ( _owner ) , ""index out of range"" ) ; return ownerToTokenList [ _owner ] [ _index ] ; }
","Enumerate NFTs assigned to an owner
"
"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x48664c16 ) , _token , _to , _value , _fee , _nonce ) ; }
","Hash ( keccak256 ) of the payload used by transferPreSigned
"
"function appendVestingEntry ( address account , uint time , uint quantity ) public onlyOwner onlyDuringSetup { require ( now < time , ""Time must be in the future"" ) ; require ( quantity != 0 , ""Quantity cannot be zero"" ) ; totalVestedBalance = totalVestedBalance . add ( quantity ) ; require ( totalVestedBalance <= synthetix . balanceOf ( this ) , ""Must be enough balance in the contract to provide for the vesting entry"" ) ; uint scheduleLength = vestingSchedules [ account ] . length ; require ( scheduleLength <= MAX_VESTING_ENTRIES , ""Vesting schedule is too long"" ) ; if ( scheduleLength == 0 ) { totalVestedAccountBalance [ account ] = quantity ; } else { require ( getVestingTime ( account , numVestingEntries ( account ) - 1 ) < time , ""Cannot add new vested entries earlier than the last one"" ) ; totalVestedAccountBalance [ account ] = totalVestedAccountBalance [ account ] . add ( quantity ) ; } vestingSchedules [ account ] . push ( [ time , quantity ] ) ; }
","Add a new vesting entry at a given time and quantity to an account 's schedule .
"
"function buy ( ) public payable returns ( uint256 amount ) { if ( initialSaleComplete ) { uint256 b = 0 ; uint256 p = 0 ; uint8 ps = 0 ; ( p , ps ) = power ( 1000008 , 1000000 , ( uint32 ) ( 1 + _totalSupply / SU ) , 1 ) ; p = ( S * p ) >> ps ; b = ( ln_fixed3_lnr_18 ( RS * msg . value / SU + p , 1 ) - 1e18 * lnRS - 1e18 * FIXED_3 ) / FIXED_3 ; refund = msg . value - ( msg . value / SU ) * SU ; amount = b * SU / 1e18 - _totalSupply ; reserveAddress . transfer ( ( msg . value / SU ) * SU ) ; balances [ reserveAddress ] += msg . value - refund ; mintToken ( msg . sender , amount ) ; msg . sender . transfer ( refund ) ; quoteAsk ( ) ; quoteBid ( ) ; } else { ask = ICOask ; amount = 1e16 * msg . value / ask ; refund = msg . value - ( amount * ask / 1e16 ) ; reserveAddress . transfer ( msg . value - refund ) ; msg . sender . transfer ( refund ) ; balances [ reserveAddress ] += msg . value - refund ; mintToken ( msg . sender , amount ) ; if ( _totalSupply >= ICOAmount ) { initialSaleComplete = true ; } } return amount ; }
","Buys aToken in exchnage for wei at the current ask price
"
"function closeSale ( ) public onlyOwner { closePreSale ( ) ; }
","Public function enables closing of the pre-sale manually if necessary
"
"function mintTokens ( uint256 _tokens ) external ;
","Called when new tokens are needed in circulation
"
"function lock ( ) public onlyOwner { unlocked = false ; }
","Locks the token .
"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
"
"function setPricesManually ( string _prices ) external onlyOwner { require ( priceExpired ( ) || updateRequestExpired ( ) ) ; setPrices ( _prices ) ; }
","set the price of currencies in euro , called in case we do n't get oraclize data for more than double the update interval
"
"function ( ) payable { require ( msg . sender == tx . origin ) ; process_contribution ( msg . sender ) ; }
","This function handles receiving Ether
"
"function withdrawEther ( address to ) public validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) { to . transfer ( address ( this ) . balance ) ; }
","withdraw all ether for oraclize payments
"
"function emergencyWithdraw ( address _withdrawer , address _token , uint256 _amount ) external onlyCoordinator onlyInactiveState { _withdraw ( _withdrawer , _token , _amount , etherAddr , 0 ) ; }
","Withdraws tokens to the owner without requiring the owner 's signature
"
"function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( saleAuction ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; require ( warriors [ _tokenId ] . action == IDLE ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","Transfers a Warrior to another address .
"
"function cancelItemSale ( uint256 _id ) public itemIsForSale ( _id ) onlyOwnerOfItem ( _id ) { Item storage item = items [ _id ] ; _cancelItemSale ( item ) ; }
","Calcels item 's sale
"
"function withdraw ( address addr ) onlyOwner public { addr . transfer ( this . balance ) ; }
","Withdraw any accumulated fees to the specified address
"
"function setAllowedAddress ( address _addr ) public onlyOwner ( ""setAllowedAddress"" ) { if ( allowedAddress != 0x0 ) { StorageUser storageUser = StorageUser ( _addr ) ; address storageContract = storageUser . getStorageAddress ( ) ; require ( storageContract == advStorageContract ) ; } super . setAllowedAddress ( _addr ) ; }
","Sets the Advertisement contract address to allow calls from Advertisement contract This function is used for upgrading the Advertisement contract without need to redeploy Advertisement Finance and Advertisement Storage contracts .
"
"function fundICO ( uint256 _amount , uint8 _stage ) public returns ( bool ) { if ( nextStage != _stage ) { error ( 'Escrow: ICO stage already funded' ) ; return false ; } if ( msg . sender != addressSCICO || tx . origin != owner ) { error ( 'Escrow: not allowed to fund the ICO' ) ; return false ; } if ( deposited [ this ] < _amount ) { error ( 'Escrow: not enough balance' ) ; return false ; } bool success = SCTokens . transfer ( addressSCICO , _amount ) ; if ( success ) { deposited [ this ] = deposited [ this ] . sub ( _amount ) ; nextStage ++ ; emit FundICO ( addressSCICO , _amount ) ; } return success ; }
","Withdraw funds from the tokens contract
"
"function getStartDate ( ) public view returns ( uint32 ) { uint32 startDate = getNextDate ( uint32 ( now ) ) ; uint32 lastRegisterDate = getLastRegisterDate ( ) ; if ( startDate <= lastRegisterDate ) { startDate = getNextDate ( lastRegisterDate ) ; } return startDate ; }
","Does n't change state
"
"function saleNonEther ( address beneficiary , uint256 amount , string ) onlyOwner external { mintTokens ( beneficiary , amount ) ; }
","Mint tokens for purshases with Non-Ether currencies
"
"function toggleContractStopped ( ) public onlyOwner { contractStopped = ! contractStopped ; }
","only the contract owner is allowed to change
"
"function challengeBefore ( uint64 slot , bytes prevTxBytes , bytes txBytes , bytes prevTxInclusionProof , bytes txInclusionProof , bytes signature , uint256 [ 2 ] blocks ) external payable isBonded isState ( slot , State . EXITING ) { doInclusionChecks ( prevTxBytes , txBytes , prevTxInclusionProof , txInclusionProof , signature , blocks ) ; setChallenged ( slot , txBytes . getOwner ( ) , blocks [ 1 ] , txBytes . getHash ( ) ) ; }
","Exitor has to call respondChallengeBefore and submit a transaction before prevTx or prevTx itself .
"
"function newTokenDeposit ( ERC20 _token , uint _amount , uint _block ) public onlyOwner returns ( uint _idDeposit ) { require ( _amount > 0 ) ; require ( _block < block . number ) ; require ( _token . transferFrom ( msg . sender , address ( this ) , _amount ) ) ; _idDeposit = deposits . length ++ ; Deposit storage d = deposits [ _idDeposit ] ; d . block = _block == 0 ? block . number - 1 : _block ; d . token = _token ; d . amount = _amount ; NewDeposit ( _idDeposit , _token , _amount ) ; }
","Adds a token deposit to ` deposits [ ] ` ; only the ` owner ` can call this function and it will only work if the account sending the tokens has called ` approve ( ) ` so that this contract can call ` transferFrom ( ) ` and take the tokens
"
"function deleteRate ( bytes4 currencyKey ) external onlyOracle { require ( rates [ currencyKey ] > 0 , ""Rate is zero"" ) ; delete rates [ currencyKey ] ; delete lastRateUpdateTimes [ currencyKey ] ; emit RateDeleted ( currencyKey ) ; }
","Delete a rate stored in the contract
"
"function redeemVoucherSingle ( uint256 voucherCode , address voucherOwner , address seller , uint256 quantity ) public onlyOwner payable { TradeOrder memory order = orderBook [ seller ] ; execute ( seller , quantity , order . price ) ; emit VoucherRedeemed ( voucherCode , voucherOwner , seller , quantity ) ; }
","A user has redeemed a top-up voucher for phone credit .
"
"function approveAddress ( address _addr ) public onlyApi { approvedAddresses [ _addr ] = true ; }
","Adds an approved address for the sale
"
"function addVersion ( address ofVersion ) pre_cond ( msg . sender == address ( this ) ) returns ( uint id ) { require ( msg . sender == address ( this ) ) ; Version memory info ; info . version = ofVersion ; info . active = true ; info . timestamp = now ; versions . push ( info ) ; emit VersionUpdated ( versions . length - 1 ) ; }
","Add an approved version of Melon
"
"function releaseTokensFromEscrowFor ( address _sender , uint256 _amount , bytes32 _nonce , bytes _delegationSig ) external { validateReleaseTokensSig ( _sender , _amount , _nonce , _delegationSig ) ; releaseTokensFromEscrowForUser ( _sender , _amount ) ; }
","Withdraw tokens from escrow back to requester
"
"function approve ( address _spender , uint _value ) returns ( bool success ) { }
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function claimTokens ( address _token ) public onlyOwner { if ( SNT . controller ( ) == address ( this ) ) { SNT . claimTokens ( _token ) ; } if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Token token = ERC20Token ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function updatePrice ( uint gasPriceInWei ) public payable whenNotPaused { if ( gasPriceInWei > 0 ) { oraclize_setCustomGasPrice ( gasPriceInWei ) ; } if ( oraclize_getPrice ( ""URL"" ) > address ( this ) . balance ) { emit LogOraclizeQuery ( """" , gasPriceInWei , ""Oraclize query was NOT sent, please add some ETH to cover for the query fee"" ) ; } else { bytes32 queryId = oraclize_query ( 0 , ""URL"" , REQUEST_URL , callbackGasLimit ) ; validIds [ queryId ] = true ; emit LogOraclizeQuery ( queryId , gasPriceInWei , ""Oraclize query was sent, standing by for the answer..."" ) ; } }
","Will not check the right ammount of money .
"
"function get_Sponsors_list_by_Job ( uint _JobID ) public view returns ( address [ ] list ) { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; list = new address [ ] ( job . sponsorsCount ) ; list = job . sponsorList ; }
","this function lets retrieve the list of all sponsors in a given job
"
"function debtLedgerLength ( ) external view returns ( uint ) { return debtLedger . length ; }
","Retrieve the length of the debt ledger array
"
"function hasRecentPrices ( address [ ] ofAssets ) view returns ( bool areRecent ) { for ( uint i ; i < ofAssets . length ; i ++ ) { if ( ! hasRecentPrice ( ofAssets [ i ] ) ) { return false ; } } return true ; }
","Whether prices of assets have been updated less than VALIDITY seconds ago
"
"function setUpgradeHasBegun ( ) internal { if ( ! upgradeHasBegun ) { upgradeHasBegun = true ; UpgradeHasBegun ( ) ; } }
","Sets flag to prevent changing newToken after upgrade
"
"function multiCall ( address [ ] _addresses , uint [ ] _amounts ) payable public returns ( bool ) { uint startBalance = this . balance ; for ( uint i = 0 ; i < _addresses . length ; i ++ ) { _safeCall ( _addresses [ i ] , _amounts [ i ] ) ; MultiCall ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] ) ; } require ( startBalance - msg . value == this . balance ) ; return true ; }
","Call to multiple contracts using two arrays which includes the contract address and the amount .
"
"function pushDividendPayment ( uint256 _dividendIndex , uint256 _start , uint256 _iterations ) public withPerm ( DISTRIBUTE ) validDividendIndex ( _dividendIndex ) { Dividend storage dividend = dividends [ _dividendIndex ] ; address [ ] memory investors = ISecurityToken ( securityToken ) . getInvestors ( ) ; uint256 numberInvestors = Math . min256 ( investors . length , _start . add ( _iterations ) ) ; for ( uint256 i = _start ; i < numberInvestors ; i ++ ) { address payee = investors [ i ] ; if ( ( ! dividend . claimed [ payee ] ) && ( ! dividend . dividendExcluded [ payee ] ) ) { _payDividend ( payee , dividend , _dividendIndex ) ; } } }
","Issuer can push dividends using the investor list from the security token
"
"function cancelProject ( uint uuid ) public onlyCurator { communityAccount . setTotalProjectEscrow ( SafeMath . sub ( communityAccount . totalProjectEscrow ( ) , communityAccount . escrowedProjectBalances ( uuid ) ) ) ; communityAccount . setEscrowedProjectBalances ( uuid , 0 ) ; logger . emitGenericLog ( ""cancelProject"" , """" ) ; }
","Subtracts tasks escrow and sets tasks escrow balance to 0
"
"function requestRefund ( ) external { assert ( getState ( ) == State . Failure ) ; assert ( funders [ msg . sender ] > 0 ) ; msg . sender . transfer ( funders [ msg . sender ] ) ; emit Refund ( msg . sender , funders [ msg . sender ] , block . number ) ; funders [ msg . sender ] = 0 ; }
","Get back the ether sent during the funding in case the funding has not reached the soft cap .
"
"function getLibrary ( uint256 _tokenId ) public view returns ( string language , string libraryName , uint256 tokenPrice , uint256 funds , address tokenOwner , address founder ) { Library storage x = libraries [ _tokenId ] ; libraryName = x . name ; language = x . language ; founder = libraryIndexToFounder [ _tokenId ] ; funds = libraryIndexToFunds [ _tokenId ] ; tokenPrice = libraryIndexToPrice [ _tokenId ] ; tokenOwner = libraryIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific library .
"
"function mint ( address _to , uint256 _tokenId ) auth ( MINT_ROLE ) public { _mint ( _to , _tokenId ) ; }
","Mint ` _tokenId ` and give the ownership to ` _to `
"
"function selfDestruct ( ) external onlyOwner { require ( selfDestructInitiated , ""Self destruct has not yet been initiated"" ) ; require ( initiationTime + SELFDESTRUCT_DELAY < now , ""Self destruct delay has not yet elapsed"" ) ; address beneficiary = selfDestructBeneficiary ; emit SelfDestructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; }
","If the self-destruction delay has elapsed , destroy this contract and remit any ether it owns to the beneficiary address .
"
"function getMinerHalvingHashRate ( ) public constant returns ( uint256 ) { return getMinerHalvingHashRateOf ( msg . sender ) ; }
","Total hash rate of a miner in a halving
"
"function finalize ( ) public onlyOwner { require ( hasEnded ( ) ) ; require ( ! isFinalized ) ; isFinalized = true ; token . generateTokens ( operationAdress , OPERATION_AMOUNT ) ; token . generateTokens ( bountyAdress , BOUNTY_AMOUNT ) ; token . generateTokens ( commonBudgetAdress , COMMON_BUDGET_AMOUNT ) ; token . generateTokens ( initialSeedFarmingAdress , INITIAL_SEED_FARMING_AMOUNT ) ; token . generateTokens ( founderAdress , FOUNDER_AMOUNT ) ; token . generateTokens ( reserveAdress , RESERVE_AMOUNT ) ; vault . close ( ) ; token . enableTransfers ( true ) ; token . changeController ( newTokenOwner ) ; vault . transferOwnership ( owner ) ; }
","finalize token sale .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( checkVestingCondition ( msg . sender ) ) ; _transfer ( msg . sender , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` from your account
"
"function personalizeSquare ( uint256 _squareId , bytes _rgbData , string _title , string _href ) external onlyOwnerOf ( _squareId ) payable { require ( bytes ( _title ) . length <= 64 ) ; require ( bytes ( _href ) . length <= 96 ) ; require ( _rgbData . length == 300 ) ; suSquares [ _squareId ] . version ++ ; suSquares [ _squareId ] . rgbData = _rgbData ; suSquares [ _squareId ] . title = _title ; suSquares [ _squareId ] . href = _href ; if ( suSquares [ _squareId ] . version > 3 ) { require ( msg . value == 10 finney ) ; } emit Personalized ( _squareId ) ; }
","Update the contents of your square , the first 3 personalizations for a square are free then cost 100 finney ( 0.01 ether ) each
"
"function createGame ( string _name , bytes32 [ ] _teamNames ) external isHuman ( ) onlyDevOrOwner ( ) returns ( uint256 ) { uint256 _gameID = gameIDIndex_ ; gameIDIndex_ ++ ; game_ [ _gameID ] . name = _name ; uint256 _nt = _teamNames . length ; require ( _nt > 0 , ""number of teams must be larger than 0"" ) ; game_ [ _gameID ] . numberOfTeams = _nt ; for ( uint256 i = 0 ; i < _nt ; i ++ ) { teams_ [ _gameID ] [ i ] = BMDatasets . Team ( _teamNames [ i ] , 0 , 0 , 0 , 0 ) ; } emit onGameCreated ( _gameID , now ) ; return _gameID ; }
","Create a game .
"
"function unlockBBK ( uint256 _amount ) external returns ( bool ) { require ( _amount > 0 ) ; IBrickblockToken _bbk = IBrickblockToken ( registry . getContractAddress ( ""BrickblockToken"" ) ) ; require ( _amount <= lockedBbkPerUser [ msg . sender ] ) ; require ( settleCurrentLockPeriod ( msg . sender ) ) ; lockedBbkPerUser [ msg . sender ] = lockedBbkPerUser [ msg . sender ] . sub ( _amount ) ; totalLockedBBK = totalLockedBBK . sub ( _amount ) ; require ( _bbk . transfer ( msg . sender , _amount ) ) ; emit BbkUnlocked ( msg . sender , _amount , totalLockedBBK ) ; return true ; }
","Transfers BBK from this contract to an account 1 .
"
"function isReserved ( string _symbol , address _owner , string _tokenName , bytes32 _swarmHash ) public returns ( bool ) { string memory symbol = upper ( _symbol ) ; require ( msg . sender == securityTokenRegistry , ""msg.sender should be SecurityTokenRegistry contract"" ) ; if ( registeredSymbols [ symbol ] . owner == _owner && ! expiryCheck ( _symbol ) ) { registeredSymbols [ symbol ] . status = true ; return false ; } else if ( registeredSymbols [ symbol ] . owner == address ( 0 ) || expiryCheck ( symbol ) ) { registeredSymbols [ symbol ] = SymbolDetails ( _owner , now , _tokenName , _swarmHash , true ) ; emit LogRegisterTicker ( _owner , symbol , _tokenName , _swarmHash , now ) ; return false ; } else return true ; }
","Check the symbol is reserved or not
"
"function transferFrom ( address _from , address _to , uint256 _value ) public canTransfer releaseTokenValid ( msg . sender , now , _value ) returns ( bool success ) { require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value <= allowances [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; balances [ _to ] += _value ; allowances [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function disableScriptExecutor ( uint256 _executorId ) external authP ( REGISTRY_MANAGER_ROLE , arr ( _executorId ) ) { ExecutorEntry storage executorEntry = executors [ _executorId ] ; require ( executorEntry . enabled , ERROR_EXECUTOR_DISABLED ) ; executorEntry . enabled = false ; emit DisableExecutor ( _executorId , executorEntry . executor ) ; }
","Disable script executor with ID ` _executorId `
"
"function unlock ( ) external { require ( allocations [ msg . sender ] . locked ) ; require ( now >= allocations [ msg . sender ] . end ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( allocations [ msg . sender ] . value ) ; allocations [ msg . sender ] . locked = false ; Transfer ( this , msg . sender , allocations [ msg . sender ] . value ) ; Unlock ( this , msg . sender , allocations [ msg . sender ] . value ) ; }
","Only the owner of a locked wallet can unlock the tokens .
"
"function collect ( ) public { assert ( getBlockNumber ( ) > contribution . startBlock ( ) ) ; uint256 balance = sit . balanceOfAt ( msg . sender , contribution . initializedBlock ( ) ) ; uint256 amount = balance . sub ( collected [ msg . sender ] ) ; require ( amount > 0 ) ; totalCollected = totalCollected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( msp . transfer ( msg . sender , amount ) ) ; TokensCollected ( msg . sender , amount ) ; }
","This method should be called by the SIT holders to collect their corresponding MSPs
"
"function removeModule ( address _moduleFactory ) external ;
","Called by the ModuleFactory owner or registry curator to delete a ModuleFactory
"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; require ( _weiAmount >= 500000000000000000 ) ; }
","Checks the state when validating a purchase
"
"function buyoutWithData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { require ( buyoutsEnabledFromTimestamp <= block . timestamp ) ; address currentOwner = identifierToOwner [ _deedId ] ; require ( currentOwner != 0x0 ) ; uint256 [ ] memory claimedSurroundingPlots = _claimedSurroundingPlots ( _deedId ) ; uint256 totalCost = _calculateAndAssignBuyoutProceeds ( currentOwner , _deedId , claimedSurroundingPlots ) ; require ( msg . value >= totalCost ) ; _transfer ( currentOwner , msg . sender , _deedId ) ; SetData ( _deedId , name , description , imageUrl , infoUrl ) ; identifierToBuyoutPrice [ _deedId ] = nextBuyoutPrice ( totalCost ) ; if ( ! identifierToBoughtOutOnce [ _deedId ] ) { identifierToBoughtOutOnce [ _deedId ] = true ; } uint256 excess = msg . value - totalCost ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Buy the current owner out of the plot .
"
"function exchangeRate ( ) public constant returns ( uint256 ) { if ( stage ( ) == Stage . Early ) { return cornerstoneStage ; } if ( stage ( ) == Stage . Normal ) { return vcStage ; } return 0 ; }
","calculte exchange rate according to current stage
"
"function updatePrices ( ) internal { uint256 oldPrice = currentTokenPrice ; if ( preIcoIsRunning ) { checkPreIcoStatus ( ) ; } if ( preIcoIsRunning ) { currentTokenPrice = preICOprice ; } else { currentTokenPrice = ICOprice ; } if ( oldPrice != currentTokenPrice ) { priceUpdated ( oldPrice , currentTokenPrice , ""Metadollar price updated!"" ) ; } }
","Set current ICO prices in wei for one metadollar
"
"function removeTokenMetadata ( uint256 _tokenId ) public onlyPlatform exists ( _tokenId ) { delete metadata [ _tokenId ] ; }
","remove metadata for token
"
"function setPrices ( address [ ] assets , uint [ ] requestedPriceMantissas ) public returns ( uint [ ] memory ) { uint numAssets = assets . length ; uint numPrices = requestedPriceMantissas . length ; uint [ ] memory result ; if ( msg . sender != poster ) { result = new uint [ ] ( 1 ) ; result [ 0 ] = failOracle ( 0 , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PRICE_PERMISSION_CHECK ) ; return result ; } if ( ( numAssets == 0 ) || ( numPrices != numAssets ) ) { result = new uint [ ] ( 1 ) ; result [ 0 ] = failOracle ( 0 , OracleError . FAILED_TO_SET_PRICE , OracleFailureInfo . SET_PRICES_PARAM_VALIDATION ) ; return result ; } result = new uint [ ] ( numAssets ) ; for ( uint i = 0 ; i < numAssets ; i ++ ) { result [ i ] = setPriceInternal ( assets [ i ] , requestedPriceMantissas [ i ] ) ; } return result ; }
","entry point for updating multiple prices
"
"function redeemVoucher ( uint256 voucherCode , address voucherOwner , address tokenSeller , uint256 quantity ) public onlyOwner payable { buy ( tokenSeller , quantity , orderBook [ tokenSeller ] . price ) ; emit VoucherRedeemed ( voucherCode , voucherOwner , tokenSeller , quantity ) ; }
","A user has redeemed a top-up voucher for phone credit .
"
"function claimHodlRewardFor ( address _beneficiary ) public { require ( hodlerStakes [ _beneficiary ] . stake > 0 && ! hodlerStakes [ _beneficiary ] . invalid ) ; uint256 _stake = 0 ; updateAndGetHodlTotalValue ( ) ; if ( ! hodlerStakes [ _beneficiary ] . claimed3M && now >= hodlerTime3M ) { _stake = _stake . add ( hodlerStakes [ _beneficiary ] . stake . mul ( TOKEN_HODL_3M ) . div ( hodlerTotalValue3M ) ) ; hodlerStakes [ _beneficiary ] . claimed3M = true ; } if ( ! hodlerStakes [ _beneficiary ] . claimed6M && now >= hodlerTime6M ) { _stake = _stake . add ( hodlerStakes [ _beneficiary ] . stake . mul ( TOKEN_HODL_6M ) . div ( hodlerTotalValue6M ) ) ; hodlerStakes [ _beneficiary ] . claimed6M = true ; } if ( ! hodlerStakes [ _beneficiary ] . claimed9M && now >= hodlerTime9M ) { _stake = _stake . add ( hodlerStakes [ _beneficiary ] . stake . mul ( TOKEN_HODL_9M ) . div ( hodlerTotalValue9M ) ) ; hodlerStakes [ _beneficiary ] . claimed9M = true ; } if ( _stake > 0 ) { claimedTokens = claimedTokens . add ( _stake ) ; require ( TokenController ( owner ) . ethealToken ( ) . transfer ( _beneficiary , _stake ) ) ; LogHodlClaimed ( msg . sender , _beneficiary , _stake ) ; } }
","Claiming HODL reward for an address
"
"function emissionInternal ( uint256 _tokensCreated ) internal { require ( 0 != _tokensCreated ) ; require ( _tokensCreated < totalSupply / 2 ) ; uint256 totalSupplyWas = totalSupply ; m_emissions . push ( EmissionInfo ( { created : _tokensCreated , totalSupplyWas : totalSupplyWas } ) ) ; mintInternal ( dividendsPool , _tokensCreated ) ; Emission ( _tokensCreated , totalSupplyWas , now ) ; }
","Starts new token emission
"
"function changeIsPayableEnabled ( ) { require ( multiSigAddress == msg . sender ) ; isPayableEnabled = ! isPayableEnabled ; LogChangeIsPayableEnabled ( ) ; }
","This method will change isPayableEnabled flag .
"
"function setFundsRegistry ( address _funds ) external timedStateChange requiresState ( IcoState . PAUSED ) onlymanyowners ( sha3 ( msg . data ) ) { require ( address ( 0 ) != _funds ) ; m_funds = FundsRegistry ( _funds ) ; }
","In case we need to attach to existent funds
"
"function addToWhitelist ( address [ ] _bidder_addresses ) public isOwner { for ( uint32 i = 0 ; i < _bidder_addresses . length ; i ++ ) { whitelist [ _bidder_addresses [ i ] ] = true ; } }
","Adds account addresses to whitelist .
"
"function checkIfTradeAmountsAcceptable ( Trade trade , uint256 amountSpentOnTrade , uint256 amountReceivedFromTrade ) internal view returns ( bool passed ) { uint256 tokenAmount = trade . isSell ? amountSpentOnTrade : amountReceivedFromTrade ; passed = tokenAmount >= trade . minimumAcceptableTokenAmount ; if ( ! passed ) { } if ( passed ) { uint256 tokenDecimals = Utils . getDecimals ( ERC20 ( trade . tokenAddress ) ) ; uint256 srcDecimals = trade . isSell ? tokenDecimals : Utils . eth_decimals ( ) ; uint256 destDecimals = trade . isSell ? Utils . eth_decimals ( ) : tokenDecimals ; uint256 actualRate = Utils . calcRateFromQty ( amountSpentOnTrade , amountReceivedFromTrade , srcDecimals , destDecimals ) ; passed = actualRate >= trade . minimumExchangeRate ; } if ( ! passed ) { } }
","Check if the amounts spent and gained on a trade are within the user '' s set limits
"
"function getApproved ( uint256 _tokenId ) external view mustBeValidToken ( _tokenId ) returns ( address ) { return tokenApprovals [ _tokenId ] ; }
","Get the approved address for a single NFT
"
"function buyTokenForAddressWithEuroCent ( address _receiver , uint64 _cent ) external onlyOps { require ( ! crowdsaleClosed , ""crowdsale is closed"" ) ; require ( _receiver != address ( 0 ) , ""zero address is not allowed"" ) ; require ( currentPhase . id != PhaseID . PreSale , ""not allowed to buy token in presale phase"" ) ; require ( currentPhase . id != PhaseID . Closed , ""not allowed to buy token in closed phase"" ) ; require ( customer [ _receiver ] . rating == Rating . Whitelisted , ""address is not whitelisted"" ) ; _sendTokenReward ( _receiver , _cent ) ; _checkFundingGoalReached ( ) ; }
","Not for public use !
"
"function getPrice ( ) external view returns ( uint256 ) { if ( manualOverride ) { return manualPrice ; } ( bytes32 price , bool valid ) = IMedianizer ( medianizer ) . peek ( ) ; require ( valid , ""MakerDAO Oracle returning invalid value"" ) ; return uint256 ( price ) ; }
","Returns price - should throw if not valid
"
"function distribute ( address to , uint256 tokens ) public onlyOwner { uint newCirculatingSupply = circulatingSupply . add ( tokens ) ; require ( newCirculatingSupply <= totalSupply ) ; circulatingSupply = newCirculatingSupply ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( address ( this ) , to , tokens ) ; }
","distribute tokens to an address
"
"function changeAllowAllWhitelistTransfers ( bool _allowAllWhitelistTransfers ) public withPerm ( FLAGS ) { allowAllWhitelistTransfers = _allowAllWhitelistTransfers ; emit AllowAllWhitelistTransfers ( _allowAllWhitelistTransfers ) ; }
","Used to change the flag true - It refers that time lock is ignored for transfers ( address must still be on whitelist ) false - It refers transfers are restricted for all addresses .
"
"function takeOwnership ( uint256 _tokenId ) public { address newOwner = msg . sender ; address oldOwner = powIndexToOwner [ _tokenId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _tokenId ) ) ; _transfer ( oldOwner , newOwner , _tokenId ) ; }
","Allow pre-approved user to take ownership of a token
"
"function setMasterFeeContract ( address feeContract ) public onlyOwner returns ( bool success ) { require ( lib . setMasterFeeContract ( feeContract ) , ""Error: Unable to set master fee contract. Please ensure fee contract has the correct parameters."" ) ; return true ; }
","Sets contract which specifies fee parameters
"
"function deliverTokens ( ERC20Basic _token , address _beneficiary , uint256 _tokens ) internal { generateTokens ( _beneficiary , _tokens ) ; }
","Override HolderBase.deliverTokens
"
"function decreaseApproval ( address _spender , uint256 _subtractedValue ) public userNotBlacklisted ( _spender ) userNotBlacklisted ( msg . sender ) whenNotPaused returns ( bool ) { _decreaseApproval ( _spender , _subtractedValue , msg . sender ) ; return true ; }
","decreaseApproval should be used instead of approve when the user 's allowance is greater than 0 .
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _tokenId ) ;
","Enumerate NFTs assigned to an owner
"
"function destroy ( ) onlyOwner public { uint256 balance = token . balanceOf ( this ) ; assert ( balance > 0 ) ; token . transfer ( FAVOREE , balance ) ; selfdestruct ( FAVOREE ) ; }
","Terminate contract and refund to owner
"
"function setFundsRegistry ( address _funds ) external validAddress ( _funds ) timedStateChange ( address ( 0 ) , 0 , true ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { m_funds = FundsRegistry ( _funds ) ; }
","In case we need to attach to existent funds
"
"function increaseGasSpent ( bytes32 _tradeHash , uint128 _gas ) private { escrows [ _tradeHash ] . totalGasFeesSpentByRelayer += _gas * uint128 ( tx . gasprice ) ; }
","Increase the amount of gas to be charged later on completion of an escrow
"
"function deposit ( ERC20 _token , uint256 _value ) external payable { address trader = msg . sender ; uint256 receivedValue = _value ; if ( address ( _token ) == ETHEREUM ) { require ( msg . value == _value , ""mismatched value parameter and tx value"" ) ; } else { require ( msg . value == 0 , ""unexpected ether transfer"" ) ; receivedValue = CompatibleERC20 ( _token ) . safeTransferFromWithFees ( trader , this , _value ) ; } privateIncrementBalance ( trader , _token , receivedValue ) ; }
","Deposits ETH or an ERC20 token into the contract .
"
"function decreaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x59388d78 ) , _token , _spender , _subtractedValue , _fee , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by decreaseApprovalPreSigned
"
"function euroCentsInOneEther ( ) public constant returns ( uint ) ;
","euro-cents per 1 ether
"
"function unlinkAddress ( address _addressToRemove , bytes32 _nonce , bytes _unlinkSignature ) external { validateUnlinkSignature ( _addressToRemove , _nonce , _unlinkSignature ) ; linkIds [ _addressToRemove ] = 0 ; emit AddressUnlinked ( _addressToRemove ) ; }
","Remove an address from a link relationship
"
"function setMinimumInitialBudgetForAudits ( uint256 _minimumInitialBudgetForAudits ) public onlyOwner whenNotPaused returns ( bool ) { minimumInitialBudgetForAudits = _minimumInitialBudgetForAudits ; return true ; }
","Sets the minimum initial budget for audits to be placed by a buyer on DataOrder creation .
"
"function minimalRequire ( ) internal constant returns ( uint ) { if ( stageNow ( ) == stageAt . publicSale ) { return 1 ether ; } if ( stageNow ( ) == stageAt . privatePresale ) { return 10 ether ; } if ( stageNow ( ) == stageAt . privatePlacement ) { return 100 ether ; } }
","Minimal requirement
"
"function sell ( uint256 _adamcoinsAmountToSell ) public { require ( sellingAllowed ) ; uint256 weiAmount = _adamcoinsAmountToSell . mul ( sellPrice ) ; require ( address ( this ) . balance >= weiAmount ) ; uint adamcoinsAmountToSell = _adamcoinsAmountToSell * M ; _transfer ( msg . sender , address ( this ) , adamcoinsAmountToSell ) ; msg . sender . transfer ( weiAmount ) ; }
","Sell Adamcoins to the contract
"
"function tokensOf ( address owner ) external view returns ( uint256 [ ] ) { return _assetsOf [ owner ] ; }
","Get all tokens of a given address
"
"function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ethernautsStorage . balanceOf ( _owner ) ; }
","Returns the number of Assets owned by a specific address .
"
"function transferTokens ( Trade [ ] trades , TradeFlag [ ] tradeFlags ) internal { for ( uint256 i = 0 ; i < trades . length ; i ++ ) { if ( trades [ i ] . isSell && ! tradeFlags [ i ] . ignoreTrade ) { if ( ! TokenTransferProxy ( tokenTransferProxy ) . transferFrom ( trades [ i ] . tokenAddress , msg . sender , address ( this ) , trades [ i ] . tokenAmount ) ) { errorReporter . revertTx ( ""TTP unable to transfer tokens to primary"" ) ; } } } }
","Iterates through a list of token orders , transfer the SELL orders to this contract & calculates if we have the ether needed
"
"function canRevokeAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) { if ( _validAttributeTypeID != attributeTypeID ) { return ( false , hex""A0"" ) ; } if ( ! _registry . hasAttribute ( account , _validAttributeTypeID ) ) { return ( false , hex""B0"" ) ; } ( address validator , bool unused ) = _jurisdiction . getAttributeValidator ( account , _validAttributeTypeID ) ; unused ; if ( validator != address ( this ) ) { return ( false , hex""C0"" ) ; } return ( true , hex""01"" ) ; }
","Check if the validator is approved to revoke an attribute of the type with ID ` attributeTypeID ` from account ` account ` on the jurisdiction .
"
"function distributeICOTokens ( address _buyer , uint tokens ) external onlyCrowdsale whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( tokensDistributedCrowdsale < 50e24 ) ; tokensDistributedCrowdsale = tokensDistributedCrowdsale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }
","Distributes the ICO tokens .
"
"function updateWhitelistAddresses ( address [ ] _accounts , uint8 _phase ) external onlyCapper { for ( uint256 i = 0 ; i < _accounts . length ; i ++ ) { require ( _accounts [ i ] != address ( 0 ) ) ; _updateWhitelist ( _accounts [ i ] , _phase ) ; } }
","function to whitelist an address which can be called only by the capper address .
"
"function darknodeRegisteredAt ( address darknodeID ) external view onlyOwner returns ( uint256 ) { return darknodeRegistry [ darknodeID ] . registeredAt ; }
","Returns the registration time of a given darknode .
"
"function removeBurningMan ( address _burningMan , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _burningMan ) , _block ) ; if ( OK != _code ) { return _code ; } delete burningMans [ _burningMan ] ; return OK ; }
","Remove burning man
"
"function getAddress ( bytes32 _key ) public view returns ( address _value ) { return addressStorage [ _key ] ; }
","Get value for Address associated with bytes32 id key
"
"function startAuction ( ) public isOwner atStage ( Stages . AuctionSetUp ) { stage = Stages . AuctionStarted ; start_time = now ; start_block = block . number ; AuctionStarted ( start_time , start_block ) ; }
","Start the auction .
"
"function claimVestedTokens ( address _recipient ) external { uint256 yearsVested ; uint256 amountVested ; ( yearsVested , amountVested ) = calculateGrantClaim ( _recipient ) ; require ( amountVested > 0 , ""amountVested is 0"" ) ; Grant storage tokenGrant = tokenGrants [ _recipient ] ; tokenGrant . yearsClaimed = yearsVested ; tokenGrant . totalClaimed = tokenGrant . totalClaimed . add ( amountVested ) ; require ( token . transfer ( _recipient , amountVested ) , ""no tokens"" ) ; emit GrantTokensClaimed ( _recipient , amountVested ) ; }
","Allows a grant recipient to claim their vested tokens .
"
"function _addMember ( address _member ) internal { require ( contractManager . authorize ( contractName , msg . sender ) ) ; members [ _member ] = true ; memberKeys . push ( _member ) ; emit MemberAdded ( _member ) ; }
","Add a member to this contract
"
"function donateAndCreateGiver ( address giver , uint64 receiverId , address token , uint _amount ) whenNotPaused payable public { require ( giver != 0 ) ; require ( receiverId != 0 ) ; uint amount = _receiveDonation ( token , _amount ) ; emit DonateAndCreateGiver ( giver , receiverId , token , amount ) ; }
","It is not recommened to call this function outside of the giveth dapp ( giveth.io ) this function is bridged to a side chain .
"
"function mediate ( uint256 _transactionId ) public { require ( escrows [ msg . sender ] [ _transactionId ] . paid ) ; escrows [ msg . sender ] [ _transactionId ] . expiration = 0 ; Dispute ( msg . sender , _transactionId ) ; }
","Only authorized address
"
"function grantToken ( uint256 _tokenId , address _newOwner ) external onlyOperatingOfficer mustBeValidToken ( _tokenId ) mustBeOwnedByThisContract ( _tokenId ) { require ( promoCreatedCount < PROMO_CREATION_LIMIT ) ; promoCreatedCount ++ ; _transfer ( _tokenId , _newOwner ) ; }
","BEWARE , this does not use a safe transfer mechanism !
"
"function generate_token_for ( address _addrTo , uint256 _amount ) mayGenerate returns ( bool ) { uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( _addrTo ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _addrTo ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _addrTo , _amount ) ; return true ; }
","This function is copy-paste of the generateTokens of the original MiniMi contract except it uses mayGenerate modifier ( original uses onlyController )
"
"function transfer ( uint64 idSender , uint64 idPledge , uint amount , uint64 idReceiver ) { idPledge = normalizePledge ( idPledge ) ; Pledge storage p = findPledge ( idPledge ) ; PledgeAdmin storage receiver = findAdmin ( idReceiver ) ; PledgeAdmin storage sender = findAdmin ( idSender ) ; checkAdminOwner ( sender ) ; require ( p . pledgeState == PledgeState . Pledged ) ; if ( p . owner == idSender ) { if ( receiver . adminType == PledgeAdminType . Giver ) { transferOwnershipToGiver ( idPledge , amount , idReceiver ) ; } else if ( receiver . adminType == PledgeAdminType . Project ) { transferOwnershipToProject ( idPledge , amount , idReceiver ) ; } else if ( receiver . adminType == PledgeAdminType . Delegate ) { uint recieverDIdx = getDelegateIdx ( p , idReceiver ) ; if ( p . intendedProject > 0 && recieverDIdx != NOTFOUND ) { if ( recieverDIdx == p . delegationChain . length - 1 ) { uint64 toPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; } else { undelegate ( idPledge , amount , p . delegationChain . length - receiverDIdx - 1 ) ; } } else { idPledge = undelegate ( idPledge , amount , p . delegationChain . length ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } } else { assert ( false ) ; } return ; } uint senderDIdx = getDelegateIdx ( p , idSender ) ; if ( senderDIdx != NOTFOUND ) { if ( receiver . adminType == PledgeAdminType . Giver ) { assert ( p . owner == idReceiver ) ; undelegate ( idPledge , amount , p . delegationChain . length ) ; return ; } if ( receiver . adminType == PledgeAdminType . Delegate ) { uint receiverDIdx = getDelegateIdx ( p , idReceiver ) ; if ( receiverDIdx == NOTFOUND ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } else if ( receiverDIdx > senderDIdx ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; appendDelegate ( idPledge , amount , idReceiver ) ; } else if ( receiverDIdx <= senderDIdx ) { undelegate ( idPledge , amount , p . delegationChain . length - receiverDIdx - 1 ) ; } return ; } if ( receiver . adminType == PledgeAdminType . Project ) { idPledge = undelegate ( idPledge , amount , p . delegationChain . length - senderDIdx - 1 ) ; proposeAssignProject ( idPledge , amount , idReceiver ) ; return ; } } assert ( false ) ; }
","Transfers amounts between pledges for internal accounting
"
"function sell ( uint256 amount ) public { require ( this . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
","Sell ` amount ` tokens to contract
"
"function updateMetadata ( uint256 estateId , string metadata ) external onlyUpdateAuthorized ( estateId ) { _updateMetadata ( estateId , metadata ) ; emit Update ( estateId , ownerOf ( estateId ) , msg . sender , metadata ) ; }
","Update the metadata of an Estate
"
"function buyWithPOLY ( address _beneficiary , uint256 _investedPOLY ) public validPOLY { _buyWithTokens ( _beneficiary , _investedPOLY , FundRaiseType . POLY ) ; }
","Purchase tokens using POLY
"
"function updatePrices ( uint newEthPrice , uint newHavvenPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT , ""Time sent must be bigger than the last update, and must be less than now + ORACLE_FUTURE_LIMIT"" ) ; usdToEthPrice = newEthPrice ; usdToHavPrice = newHavvenPrice ; lastPriceUpdateTime = timeSent ; emit PricesUpdated ( usdToEthPrice , usdToHavPrice , lastPriceUpdateTime ) ; }
","Access point for the oracle to update the prices of havvens / eth .
"
"function schedulePriceUpdatesRolling ( uint256 _startTime , uint256 _interval , uint256 _iters ) payable isAdminOrOwner public { bytes32 requestId ; require ( _interval > 0 , ""Interval between scheduled time should be greater than zero"" ) ; require ( _iters > 0 , ""No iterations specified"" ) ; require ( _startTime >= now , ""Past scheduling is not allowed and scheduled time should be absolute timestamp"" ) ; require ( oraclize_getPrice ( ""URL"" , gasLimit ) * _iters <= address ( this ) . balance , ""Insufficient Funds"" ) ; for ( uint256 i = 0 ; i < _iters ; i ++ ) { uint256 scheduledTime = _startTime + ( i * _interval ) ; requestId = oraclize_query ( scheduledTime , ""URL"" , oracleURL , gasLimit ) ; requestIds [ requestId ] = scheduledTime ; emit LogNewOraclizeQuery ( scheduledTime , requestId , oracleURL ) ; } if ( latestScheduledUpdate < requestIds [ requestId ] ) { latestScheduledUpdate = requestIds [ requestId ] ; } }
","Allows owner to schedule future Oraclize calls on a rolling schedule
"
"function blockOffset ( uint256 _block ) public constant notBeforeGenesis returns ( uint256 ) { return _block % subsidyHalvingInterval ; }
","Calculate the offset of a given block
"
"function isRunning ( ) view public returns ( bool ) { return ( rate > 0 ) && ( now >= roundStartTime ) && ( address ( this ) . balance > 0 ) ; }
","Checks if Buyback round is running
"
"function proxyPayment ( address _owner ) payable returns ( bool ) { return false ; }
","` proxyPayment ( ) ` returns false , meaning ether is not accepted at the token address , only the address of FiinuCrowdSale
"
"function ( ) payable { receiveEther ( ) ; }
","The fall back function is called whenever ether is sent to this contract
"
"function removeContract ( ) public onlyOwner { if ( ! saleFinalized ) revert ( ) ; selfdestruct ( msg . sender ) ; }
","remove conttact only when sale has been finalized transfer all the fund to the contract owner
"
"function canIssueAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) { if ( _validAttributeTypeID != attributeTypeID ) { return ( false , hex""A0"" ) ; } if ( _registry . hasAttribute ( account , _validAttributeTypeID ) ) { return ( false , hex""B0"" ) ; } return ( true , hex""01"" ) ; }
","Check if the validator is approved to issue an attribute of the type with ID ` attributeTypeID ` to account ` account ` on the jurisdiction .
"
"function executeDecision ( uint _boardMeetingID ) returns ( bool ) ;
","Function to execute a board meeting decision and close the board meeting
"
"function buyTokenForAddress ( address _receiver ) external payable { require ( _receiver != address ( 0 ) , ""zero address is not allowed"" ) ; _buyToken ( _receiver ) ; }
","Buy tokens for another address .
"
"function createDividendWithCheckpoint ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId , bytes32 _name ) external payable withPerm ( MANAGE ) { _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , _checkpointId , excluded , _name ) ; }
","Creates a dividend with a provided checkpoint , using global list of excluded addresses
"
"function tokenFallback ( address _sender , uint256 _value , bytes _data ) { }
","Empty tokenFallback method to ensure ERC-223 compatibility
"
"function setCampaign ( bytes32 _bidId , uint _price , uint _budget , uint _startDate , uint _endDate , bool _valid , address _owner , string _endPoint ) public onlyIfWhitelisted ( ""setCampaign"" , msg . sender ) { bool newCampaign = ( getCampaignOwnerById ( _bidId ) == 0x0 ) ; _setCampaign ( _bidId , _price , _budget , _startDate , _endDate , _valid , _owner ) ; campaignEndPoints [ _bidId ] = _endPoint ; if ( newCampaign ) { emit ExtendedCampaignEndPointCreated ( _bidId , _endPoint ) ; } else { emit ExtendedCampaignEndPointUpdated ( _bidId , _endPoint ) ; } }
","Add or update a campaign information Based on a campaign Id ( bidId ) , a campaign can be created ( if non existent ) or updated .
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { if ( ! approve ( _spender , _amount ) ) throw ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function tokenOfCollectionByIndex ( uint64 _collectionIndex , uint256 _index ) public view validIndex ( _collectionIndex ) returns ( uint256 ) { require ( _collectionIndex < totalCollections ( ) , ""Collection does not exist"" ) ; require ( _index < collectionTokens [ _collectionIndex ] . length , ""Index is out of bounds"" ) ; PixelCon storage pixelcon = pixelcons [ collectionTokens [ _collectionIndex ] [ _index ] ] ; return pixelcon . tokenId ; }
","Enumerate PixelCon in collection # ` ( _collectionIndex ) `
"
"function updatePrice ( uint newPrice , uint timeSent ) external onlyOracle { require ( lastPriceUpdateTime < timeSent && timeSent < now + ORACLE_FUTURE_LIMIT ) ; price = newPrice ; lastPriceUpdateTime = timeSent ; emitPriceUpdated ( newPrice , timeSent ) ; rolloverFeePeriodIfElapsed ( ) ; }
","Access point for the oracle to update the price of havvens .
"
"function isBalanceSufficientForContractCreation ( address userAddress ) external view returns ( bool ) { return balances [ userAddress ] >= minBalanceToAllowContractCreation ; }
","checks if a user address has enough token balance to be eligible to create a contract
"
"function hasIssued ( address account ) external view returns ( bool ) { return issuanceData [ account ] . initialDebtOwnership > 0 ; }
","Query whether an account has issued and has an outstanding debt balance
"
"function freezeAccount ( address _target , bool _freeze ) onlyOwner public { frozenAccount [ _target ] = _freeze ; emit FrozenFunds ( _target , _freeze ) ; }
","` freeze ?
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
","Transfer `` _value '' tokens from `` _from '' to `` _to '' if `` msg.sender '' is allowed .
"
"function pack ( uint8 _major , uint8 _minor , uint8 _patch ) internal pure returns ( uint24 ) { return ( uint24 ( _major ) << 16 ) | ( uint24 ( _minor ) << 8 ) | uint24 ( _patch ) ; }
","Used to pack the uint8 [ ] array data into uint24 value
"
"function registerModule ( address _moduleFactory ) external whenNotPaused returns ( bool ) { require ( registry [ _moduleFactory ] == 0 , ""Module factory should not be pre-registered"" ) ; IModuleFactory moduleFactory = IModuleFactory ( _moduleFactory ) ; require ( moduleFactory . getType ( ) != 0 , ""Factory type should not equal to 0"" ) ; registry [ _moduleFactory ] = moduleFactory . getType ( ) ; moduleList [ moduleFactory . getType ( ) ] . push ( _moduleFactory ) ; reputation [ _moduleFactory ] = new address [ ] ( 0 ) ; emit LogModuleRegistered ( _moduleFactory , moduleFactory . owner ( ) ) ; return true ; }
","Called by moduleFactory owner to register new modules for SecurityToken to use
"
"function synthsReceivedForEther ( uint amount ) public view returns ( uint ) { uint synthsTransferred = amount . multiplyDecimal ( usdToEthPrice ) ; return feePool . amountReceivedFromTransfer ( synthsTransferred ) ; }
","Calculate how many synths you will receive if you transfer an amount of ether .
"
"function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balanceOf [ _owner ] ; }
","function balanceOf will display balance of given address
"
"function mint ( address _recipient , uint256 _amount ) public onlyMinters returns ( bool ) { balances [ _recipient ] = balances [ _recipient ] . add ( _amount ) ; totalSupply = totalSupply . add ( _amount ) ; emit Transfer ( address ( 0 ) , _recipient , _amount ) ; emit CoinsMinted ( msg . sender , _recipient , _amount ) ; return true ; }
","This is used to mint new tokens
"
"function setUsername ( string name ) external gameIsNotOver { require ( bytes ( name ) . length > 2 , ""Provide a name longer than 2 chars"" ) ; require ( bytes ( name ) . length <= 32 , ""Provide a name shorter than 33 chars"" ) ; require ( users [ msg . sender ] . addr == address ( 0x0 ) , ""You already have a name"" ) ; require ( usernameToAddress [ name ] == address ( 0x0 ) , ""Name already taken"" ) ; users [ msg . sender ] = User ( msg . sender , name ) ; usernameToAddress [ name ] = msg . sender ; allUsers . push ( msg . sender ) ; emit NewUsername ( msg . sender , name ) ; }
","Set Username
"
"function countOfDeedsByOwner ( address _owner ) public view returns ( uint256 ) { return ownershipDeedCount [ _owner ] ; }
","Returns the number of deeds owned by a specific address .
"
"function updateDescription ( string _projectDescription , bytes32 _hashOfTheDocument ) onlyProjectManager { description = _projectDescription ; hashOfTheDocument = _hashOfTheDocument ; ProjectDescriptionUpdated ( msg . sender , _projectDescription , _hashOfTheDocument ) ; }
","Function to allow the project manager updating the description of the project
"
"function setAddressAliasUnsafe ( address oldAddr , address newAddr ) public onlyRole ( roleAddressAliaser ( ) ) { addressAlias [ newAddr ] = oldAddr ; emit UserAddressAliased ( oldAddr , newAddr ) ; }
","Alias a new address to an old address , bypassing all safety checks .
"
"function postIcoHold ( address who , uint256 quantity , uint256 addedTime ) public onlyTransferAgent { require ( who != 0x0 , ""The null address cannot own tokens."" ) ; require ( quantity != 0 , ""Quantity must be greater than zero."" ) ; require ( ! isExistingHolding ( who ) , ""Cannot overwrite an existing holding, use a new wallet."" ) ; Holding memory holding = Holding ( quantity , block . timestamp + addedTime , false ) ; heldTokens [ who ] = holding ; emit TokensHeld ( who , holding . quantity , holding . releaseDate ) ; }
","Hold tokens post-ICO with a variable release date on those tokens .
"
"function getSuppliers ( ) public view returns ( SupplierInterface [ ] ) { return suppliers ; }
","should be called off chain with as much gas as needed
"
"function addCommissionToPendingWithdrawals ( uint32 _canvasId ) external onlyOwner stateOwned ( _canvasId ) forceOwned ( _canvasId ) { Canvas storage canvas = _getCanvas ( _canvasId ) ; uint commission ; bool isPaid ; ( commission , isPaid ) = calculateCommission ( _canvasId ) ; require ( commission > 0 ) ; require ( ! isPaid ) ; canvas . isCommissionPaid = true ; addPendingWithdrawal ( owner , commission ) ; emit CommissionAddedToWithdrawals ( _canvasId , commission , ACTION_INITIAL_BIDDING ) ; }
","Only for the owner of the contract .
"
"function addPermission ( bytes4 _methodsignature , string _permissionName , string _permissionDescription , string _contractName ) public onlyValidator { Permission memory p = Permission ( _permissionName , _permissionDescription , _contractName , true ) ; permissions [ _methodsignature ] = p ; emit PermissionAdded ( _methodsignature ) ; }
","Sets a permission within the list of permissions .
"
"function addValidator ( address validator , string description ) external onlyOwner whenNotPaused { require ( validator != address ( 0 ) , ""must supply a valid address"" ) ; require ( isValidator ( validator ) == false , ""a validator with the provided address already exists"" ) ; _validators [ validator ] = Validator ( { exists : true , index : _validatorAccounts . length , description : description } ) ; _validatorAccounts . push ( validator ) ; emit ValidatorAdded ( validator , description ) ; }
","Add account ` validator ` as a validator with a description ` description ` who can be approved to set attributes of specific types .
"
"function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) , ""No address provided"" ) ; require ( signatures [ _signature ] == false , ""No signature"" ) ; bytes32 hashedTx = transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) , ""From address is not provided"" ) ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned transfer
"
"function finishAirdrop ( ) external returns ( bool ) { require ( undropped == 0 ) ; multiplierPercent = 0 ; AirdropComplete ( currentAirdrop ) ; unpause ( ) ; }
","Finish airdrop , unpause token transfers
"
"function ( ) public payable { require ( msg . value >= MIN_INVESTMENT ) ; require ( now >= preIcoStart && now <= preIcoEnd ) ; require ( isContract ( msg . sender ) == false ) ; if ( invested [ msg . sender ] == false ) { invested [ msg . sender ] = true ; } preIcoAddr . buyTokens . value ( msg . value ) ( msg . sender ) ; }
","This function will record your investment in this reservation contract and forward eths to the pre-ico , please note , you need to invest at least MIN_INVESTMENT and you must invest directly from your address , contracts are not allowed
"
"function isLegalCoordinates ( uint8 _fromX , uint8 _fromY , uint8 _toX , uint8 _toY ) private pure returns ( bool ) { return ( ( _fromX >= 1 ) && ( _fromY >= 1 ) && ( _toX <= 100 ) && ( _toY <= 100 ) && ( _fromX <= _toX ) && ( _fromY <= _toY ) ) ; }
","insures that area coordinates are within 100x100 field and from-coordinates > = to-coordinates
"
"function balanceOf ( address _owner ) external view returns ( uint ) { return addressToCount [ _owner ] ; }
","Returns number of canvases owned by the given address .
"
"function setWinnerPrizes ( uint32 amount ) external onlyAdmin checkState ( pointsValidationState . TopWinnersAssigned ) { require ( lastPrizeGiven + amount <= winnerCounter ) ; uint16 inRangeCounter = payDistributionAmount [ payoutRange ] ; for ( uint256 i = 0 ; i < amount ; i ++ ) { if ( inRangeCounter == 0 ) { payoutRange ++ ; inRangeCounter = payDistributionAmount [ payoutRange ] ; } uint256 tokenId = sortedWinners [ i + lastPrizeGiven ] ; tokenToPayoutMap [ tokenId ] = payoutDistribution [ payoutRange ] ; inRangeCounter -- ; } lastPrizeGiven += amount ; payDistributionAmount [ payoutRange ] = inRangeCounter ; if ( lastPrizeGiven == winnerCounter ) { pValidationState = pointsValidationState . WinnersAssigned ; return ; } }
","Sets prize percentage to every address that wins from the position 30th onwards
"
"function _removeSale ( uint256 _tokenId ) internal { delete tokenIdToSale [ _tokenId ] ; }
","Internal Function to remove sales
"
"function setSanityBounds ( uint256 _sanityBounds ) onlyOwner public { sanityBounds = _sanityBounds ; }
","Allows owner to set new sanity bounds for price updates
"
"function hasRecentPrice ( address ofAsset ) view pre_cond ( information [ ofAsset ] . exists ) returns ( bool isRecent ) { return sub ( now , information [ ofAsset ] . timestamp ) <= VALIDITY ; }
","Whether price of asset has been updated less than VALIDITY seconds ago
"
"function registerAndActivateDevice ( bytes32 _deviceId , bytes32 _deviceType , bytes32 _devicePublicKey ) public onlyManufacturer whenNotPaused returns ( bool ) { uint256 registrationFee = settings . registrationFee ( ) ; uint256 activationFee = settings . activationFee ( ) ; bytes32 deviceIdHash = keccak256 ( _deviceId ) ; Device memory d = _registerDevice ( msg . sender , deviceIdHash , _deviceType , _devicePublicKey ) ; bytes32 manufacturerId = d . manufacturerId ; emit DeviceRegistered ( msg . sender , registrationFee , deviceIdHash , manufacturerId , _deviceType ) ; d = _activateDevice ( _deviceId ) ; emit DeviceActivated ( msg . sender , activationFee , _deviceId , manufacturerId , _deviceType ) ; uint256 fee = registrationFee . add ( activationFee ) ; _depositTokens ( msg . sender , fee ) ; require ( token . transferFrom ( msg . sender , address ( this ) , fee ) , ""transferFrom failed"" ) ; return true ; }
","Registers and immediately activates device , used by manufacturers to prepay activation
"
"function allocate ( address _receiver , bytes16 _customerUuid , uint256 _weiAmount ) onlyAllowedAddresses whenNotPaused external { crowdsale . allocateTokens ( _receiver , _customerUuid , _weiAmount ) ; }
","Add tokens to specified address , tokens amount depends of wei amount .
"
"function finishHardcap ( ) public onlyContractOwner onlySale notHardcapReached returns ( uint ) { finishedHardcap = true ; _emitHardcapFinishedManually ( ) ; return OK ; }
","Performs finish hardcap manually Only by contract owner and in sale period
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalProperties = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 tokenId ; for ( tokenId = 1 ; tokenId <= totalProperties ; tokenId ++ ) { if ( propertyIndexToOwner [ tokenId ] == _owner ) { result [ resultIndex ] = tokenId ; resultIndex ++ ; } } return result ; } }
","Returns a list of all Property IDs assigned to an address .
"
"function bulkClaimReward ( uint256 [ ] _blockNumbers ) external canMint returns ( bool ) { require ( _blockNumbers . length <= 20 , ""can only claim up to 20 rewards at once"" ) ; uint256 totalMint ; for ( uint256 i = 0 ; i < _blockNumbers . length ; i ++ ) { totalMint = totalMint . add ( claimReward ( _blockNumbers [ i ] ) ) ; } emit MergedMinedRewardClaimed ( msg . sender , _blockNumbers , totalMint ) ; require ( totalMint > 0 , ""total coins to mint must be greater than 0"" ) ; require ( RTI . mint ( msg . sender , totalMint ) , ""unable to mint tokens"" ) ; return true ; }
","Used by a miner to bulk claim their merged mined RTC
"
"function getColor ( uint256 _tokenId ) public view returns ( string colorName , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Color storage color = colors [ _tokenId ] ; colorName = color . name ; sellingPrice = colorIndexToPrice [ _tokenId ] ; owner = colorIndexToOwner [ _tokenId ] ; previousPrice = colorIndexToPreviousPrice [ _tokenId ] ; previousOwners = colorIndexToPreviousOwners [ _tokenId ] ; }
","Returns all the relevant information about a specific color .
"
"function internalUpdateRates ( bytes4 [ ] currencyKeys , uint [ ] newRates , uint timeSent ) internal returns ( bool ) { require ( currencyKeys . length == newRates . length , ""Currency key array length must match rates array length."" ) ; require ( timeSent < ( now + ORACLE_FUTURE_LIMIT ) , ""Time is too far into the future"" ) ; for ( uint i = 0 ; i < currencyKeys . length ; i ++ ) { require ( newRates [ i ] != 0 , ""Zero is not a valid rate, please call deleteRate instead."" ) ; require ( currencyKeys [ i ] != ""sUSD"" , ""Rate of sUSD cannot be updated, it's always UNIT."" ) ; if ( timeSent >= lastRateUpdateTimes [ currencyKeys [ i ] ] ) { rates [ currencyKeys [ i ] ] = newRates [ i ] ; lastRateUpdateTimes [ currencyKeys [ i ] ] = timeSent ; } } emit RatesUpdated ( currencyKeys , newRates ) ; updateXDRRate ( timeSent ) ; return true ; }
","Internal function which sets the rates stored in this contract
"
"function transferOwnership ( address newOwner ) onlyOwner { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; }
","Allows the current owner to transfer control of the contract to a newOwner .
"
"function changeController ( address _newController ) auth { controller = _newController ; }
","Changes the controller of the contract
"
"function creationQuantity ( ) external view returns ( uint256 ) { return creationQuantity_ ; }
","Returns the creationQuantity
"
"function buyTokens ( ) payable returns ( bool ) { if ( ! transferable || msg . value < 100 finney ) throw ; addOrder ( msg . sender , msg . value ) ; return true ; }
","Function to create orders to buy tokens
"
"function getExpiryLimit ( ) external view returns ( uint256 ) ;
","Gets the expiry limit
"
"function _forwardPoly ( address _beneficiary , address _to , uint256 _fundsAmount ) internal { polyToken . transferFrom ( _beneficiary , _to , _fundsAmount ) ; }
","Internal function used to forward the POLY raised to beneficiary address
"
"function setManualPrice ( uint256 _price ) public onlyOwner { emit LogSetManualPrice ( manualPrice , _price , now ) ; manualPrice = _price ; }
","Set a manual price .
"
"function mintToken ( uint256 mintedAmount ) onlyOwner public { require ( mintedAmount >= 0 ) ; _balanceOf [ _owner ] += mintedAmount ; _totalSupply += mintedAmount ; Transfer ( 0 , _owner , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` owner ` , can be run only by owner
"
"function transferFromWithData ( address _from , address _to , uint256 _value , bytes _data ) external returns ( bool ) ;
","Overloaded version of the transferFrom function
"
"function withdrawEther ( ) payable onlyOwner returns ( bool ) { return owner . send ( this . balance ) ; }
","Withdraw all Ether in this contract
"
"function mintTokens ( uint256 _tokens ) external { require ( ! locked ) ; require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _tokens != 0 ) ; totalSupply_ = totalSupply_ . add ( _tokens ) ; balances [ depositAddress ] = balances [ depositAddress ] . add ( _tokens ) ; emit TokensMinted ( msg . sender , depositAddress , _tokens ) ; }
","Called when new tokens are needed in circulation
"
"function claimTokens ( token _address , address _to ) onlyAdmin ( 2 ) public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }
","Function to claim ANY token stuck on contract accidentally In case of claim of stuck tokens please contact contract owners
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }
","Transfer ` _value ` tokens from ` _from ` to ` _to ` if ` msg.sender ` is allowed .
"
"function changeAddress ( string _nameKey , address _newAddress ) public onlyOwner { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; emit LogChangeAddress ( _nameKey , storedAddresses [ key ] , _newAddress ) ; storedAddresses [ key ] = _newAddress ; }
","change the contract address
"
"function takeOwnership ( uint256 _deedId ) external ;
","Become owner of a deed for which you are currently approved
"
"function settle ( Data storage self ) notSettledButClosed ( self ) timeoutOver ( self ) { uint8 closing_index ; uint8 counter_index ; uint256 total_deposit ; uint256 counter_net ; uint256 closer_amount ; uint256 counter_amount ; self . settled = block . number ; closing_index = index_or_throw ( self , self . closing_address ) ; counter_index = 1 - closing_index ; Participant storage closing_party = self . participants [ closing_index ] ; Participant storage counter_party = self . participants [ counter_index ] ; counter_net = ( counter_party . balance + closing_party . transferred_amount - counter_party . transferred_amount ) ; total_deposit = closing_party . balance + counter_party . balance ; counter_amount = min ( counter_net , total_deposit ) ; counter_amount = max ( counter_amount , 0 ) ; closer_amount = total_deposit - counter_amount ; if ( counter_amount > 0 ) { require ( self . token . transfer ( counter_party . node_address , counter_amount ) ) ; } if ( closer_amount > 0 ) { require ( self . token . transfer ( closing_party . node_address , closer_amount ) ) ; } kill ( self ) ; }
","Settles the balance between the two parties
"
"function incrementInventory ( uint256 _productId , uint256 _inventoryAdjustment ) external onlyCLevel { _incrementInventory ( _productId , _inventoryAdjustment ) ; ProductInventoryAdjusted ( _productId , availableInventoryOf ( _productId ) ) ; }
","incrementInventory - increments the inventory of a product
"
"function approveWithSender ( address _sender , address _spender , uint256 _value ) public onlyProxy returns ( bool success ) { require ( _spender != address ( 0 ) ) ; erc20Store . setAllowance ( _sender , _spender , _value ) ; erc20Proxy . emitApproval ( _sender , _spender , _value ) ; return true ; }
","Core logic of the ERC20 ` approve ` function .
"
"function isPaused ( ) public view returns ( bool ) { return getBool ( Encoder . getKey ( ""paused"" ) ) ; }
","Checks whether the contract operations is paused or not
"
"function addPolicyRule ( bytes4 _sig , address _contract , bytes32 _groupName , uint _acceptLimit , uint _declineLimit ) onlyContractOwner external returns ( uint ) { require ( _sig != 0x0 ) ; require ( _contract != 0x0 ) ; require ( GroupsAccessManager ( accessManager ) . isGroupExists ( _groupName ) ) ; require ( _acceptLimit != 0 ) ; require ( _declineLimit != 0 ) ; bytes32 _policyHash = keccak256 ( _sig , _contract ) ; if ( policyId2Index [ _policyHash ] == 0 ) { uint _policiesCount = policiesCount . add ( 1 ) ; index2PolicyId [ _policiesCount ] = _policyHash ; policyId2Index [ _policyHash ] = _policiesCount ; policiesCount = _policiesCount ; } Policy storage _policy = policyId2policy [ _policyHash ] ; uint _policyGroupsCount = _policy . groupsCount ; if ( _policy . groupName2index [ _groupName ] == 0 ) { _policyGroupsCount += 1 ; _policy . groupName2index [ _groupName ] = _policyGroupsCount ; _policy . participatedGroups [ _policyGroupsCount ] . groupName = _groupName ; _policy . groupsCount = _policyGroupsCount ; _policy . sig = _sig ; _policy . contractAddress = _contract ; } uint _previousAcceptLimit = _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit ; uint _previousDeclineLimit = _policy . participatedGroups [ _policyGroupsCount ] . declineLimit ; _policy . participatedGroups [ _policyGroupsCount ] . acceptLimit = _acceptLimit ; _policy . participatedGroups [ _policyGroupsCount ] . declineLimit = _declineLimit ; _policy . totalAcceptedLimit = _policy . totalAcceptedLimit . sub ( _previousAcceptLimit ) . add ( _acceptLimit ) ; _policy . totalDeclinedLimit = _policy . totalDeclinedLimit . sub ( _previousDeclineLimit ) . add ( _declineLimit ) ; PolicyRuleAdded ( _sig , _contract , _policyHash , _groupName , _acceptLimit , _declineLimit ) ; return OK ; }
","Register new policy rule Can be called only by contract owner
"
"function replaceWizard ( address _replacement ) { externalEnter ( ) ; replaceWizardRP ( _replacement ) ; externalLeave ( ) ; }
","Used by either the topWizard or subWizard to transfer all rights to future commissions to the ` _replacement ` wizard .
"
"function onTokenReceived ( address _from , uint256 _value , uint256 _action , bytes _data ) public /* onlyTokenContract */ returns ( bytes4 ) ;
","Handle the receipt of Menlo Tokens
"
"function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }
","Get balance of account
"
"function ownerPowerUpContract ( ) external onlyOwner { require ( ! contractPoweredUp ) ; require ( parsecToken . balanceOf ( this ) >= PARSECS_TOTAL_AMOUNT ) ; contractPoweredUp = true ; }
","Check if contract has enough Parsecs to cover hard cap
"
"function setRBInformationStoreAddress ( address _address ) onlyMultiSig { rbInformationStore = RBInformationStore ( _address ) ; LogSetRBInformationStoreAddress ( _address ) ; }
","Change rbInformationStoreAddress .
"
"function checkCompletedCrowdsale ( ) public whenNotPaused { if ( ! isEnded ) { if ( hasEnded ( ) && ! goalReached ( ) ) { vault . enableRefunds ( ) ; isRefunding = true ; isEnded = true ; Finalized ( ) ; } else if ( goalReached ( ) ) { vault . close ( ) ; isEnded = true ; Finalized ( ) ; } } }
","Check if the crowdsale has ended and enables refunds only in case the goal has n't been reached
"
"function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < _allTokens . length , ""Index out of bounds"" ) ; return _allTokens [ _index ] ; }
","Enumerate valid NFTs
"
"function getBonusPercentage ( uint _cents ) view public returns ( uint256 ) { for ( uint8 i = 0 ; i < bonusLimits . length ; i ++ ) { if ( _cents >= bonusLimits [ i ] ) { return bonusPercentages [ i ] ; } } }
","Gets the bonus applicable for the supplied dollar cent value .
"
"function removeAdmin ( address _address ) external onlyAdmin { require ( _address != address ( 0 ) ) ; require ( admins [ _address ] ) ; require ( _address != owner ) ; admins [ _address ] = false ; emit AdminRemoved ( _address ) ; }
","Removes the specified address from the list of administrators .
"
"function createGroup ( bytes32 _groupName , uint _priority ) external onlyContractOwner returns ( uint ) { require ( _groupName != bytes32 ( 0 ) ) ; if ( isGroupExists ( _groupName ) ) { return USER_MANAGER_GROUP_ALREADY_EXIST ; } uint _groupsCount = groupsCount . add ( 1 ) ; groupName2index [ _groupName ] = _groupsCount ; index2groupName [ _groupsCount ] = _groupName ; groupName2group [ _groupName ] = Group ( _groupName , _priority , 0 ) ; groupsCount = _groupsCount ; GroupCreated ( _groupName ) ; return OK ; }
","Create group Can be called only by contract owner
"
"function getDeedTimestampByAddress ( string propertyAddress , uint256 i ) public constant returns ( uint256 ) { string memory deed = getDeedByAddress ( propertyAddress , i ) ; return getDeedTimestamp ( deed ) ; }
","Gets the deed registration timestamp by property address and chronological index
"
"function getCity ( uint256 _tokenId ) public view returns ( string cityName , string country , uint256 sellingPrice , address owner ) { City storage city = cities [ _tokenId ] ; cityName = city . name ; country = city . country ; sellingPrice = cityIndexToPrice [ _tokenId ] ; owner = cityIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific city .
"
"function burn ( uint256 _value ) public returns ( bool success ) { require ( balanceOf [ msg . sender ] > _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function claimPlotMultipleWithData ( uint256 [ ] _deedIds , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { uint256 buyAmount = _deedIds . length ; uint256 etherRequired ; if ( freeClaimAllowance [ msg . sender ] > 0 ) { if ( freeClaimAllowance [ msg . sender ] > buyAmount ) { freeClaimAllowance [ msg . sender ] -= buyAmount ; etherRequired = 0 ; } else { uint256 freeAmount = freeClaimAllowance [ msg . sender ] ; delete freeClaimAllowance [ msg . sender ] ; etherRequired = unclaimedPlotPrice . mul ( buyAmount - freeAmount ) ; } } else { etherRequired = unclaimedPlotPrice . mul ( buyAmount ) ; } require ( msg . value >= etherRequired ) ; uint256 offset = plots . length ; plots . length = plots . length . add ( _deedIds . length ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( validIdentifier ( _deedId ) ) ; require ( identifierToOwner [ _deedId ] == address ( 0 ) ) ; plots [ offset + i ] = uint32 ( _deedId ) ; _transfer ( address ( 0 ) , msg . sender , _deedId ) ; _setPlotData ( _deedId , name , description , imageUrl , infoUrl ) ; } uint256 excess = msg . value - etherRequired ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Buy unclaimed plots .
"
"function crowdsaleRunning ( ) constant public returns ( bool ) { return ! finalized && ( tokensMinted < hardCap ) && ( currentRoundNum ( ) > 0 ) ; }
","Shows if crowdsale is running
"
"function freezeAccount ( address target , bool freeze ) onlyOwner public { token . freezeAccount ( target , freeze ) ; }
","` freeze ?
"
"function setTokenState ( TokenState _tokenState ) external optionalProxy_onlyOwner { tokenState = _tokenState ; emitTokenStateUpdated ( _tokenState ) ; }
","Set the address of the TokenState contract .
"
"function invokeFor ( address _invoker ) public returns ( uint ) ;
","Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .
"
"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( DOTSToken ) { DOTSToken newToken = new DOTSToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function adminClose ( address _to ) public onlyAdmin validAddress ( _to ) { require ( forSalePixelconIndexes . length == uint256 ( 0 ) , ""Cannot close with active listings"" ) ; selfdestruct ( _to ) ; }
","Close and destroy the market
"
"function getIndexName ( bytes32 indexId ) constant returns ( bytes32 ) { return index_lookup [ indexId ] . name ; }
","Retrieves the name of an index .
"
"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; CountTransferManager countTransferManager = new CountTransferManager ( msg . sender , address ( polyToken ) ) ; require ( getSig ( _data ) == countTransferManager . getInitFunction ( ) , ""Provided data is not valid"" ) ; require ( address ( countTransferManager ) . call ( _data ) , ""Un-successfull call"" ) ; emit LogGenerateModuleFromFactory ( address ( countTransferManager ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( countTransferManager ) ; }
","used to launch the Module with the help of factory
"
"function havvensReceivedForNomins ( uint amount ) public view returns ( uint ) { uint nominsReceived = nomin . amountReceived ( amount ) ; return safeDiv_dec ( nominsReceived , usdToHavPrice ) ; }
","Calculate how many havvens you will receive if you transfer an amount of nomins .
"
"function finalizeSale ( ) public onlyOwner { doFinalizeSale ( ) ; }
","finalize the sale
"
"function getPrice ( Campaign storage _campaign ) internal view returns ( uint _price ) { return _campaign . price ; }
","Get campaign price per proof of attention
"
"function removeMember ( address targetMember ) onlyOwner public { require ( memberId [ targetMember ] != 0 ) ; for ( uint i = memberId [ targetMember ] ; i < members . length - 1 ; i ++ ) { members [ i ] = members [ i + 1 ] ; } delete members [ members . length - 1 ] ; members . length -- ; }
","Remove membership from ` targetMember `
"
"function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { return assetIndexToOwner [ _tokenId ] ; }
","Returns owner of a given Asset ( Token ) .
"
"function resolveAddress ( address addr ) public view returns ( address ) { address parentAddr = addressAlias [ addr ] ; if ( parentAddr == address ( 0 ) ) { return addr ; } else { return parentAddr ; } }
","Resolve an address to its canonical address .
"
"function transferPlusFee ( uint value ) external view returns ( uint ) { return safeAdd ( value , transferFeeIncurred ( value ) ) ; }
","The value that you would need to send so that the recipient receives a specified value .
"
"function pay ( uint index , uint256 _amount , address _from , bytes oracleData ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent ) ; addInterest ( index ) ; uint256 toPay = min ( getPendingAmount ( index ) , _amount ) ; PartialPayment ( index , msg . sender , _from , toPay ) ; loan . paid = safeAdd ( loan . paid , toPay ) ; if ( getRawPendingAmount ( index ) == 0 ) { TotalPayment ( index ) ; loan . status = Status . paid ; lendersBalance [ loan . lender ] -= 1 ; activeLoans -= 1 ; Transfer ( loan . lender , 0x0 , index ) ; } uint256 transferValue = convertRate ( loan . oracle , loan . currency , oracleData , toPay ) ; require ( transferValue > 0 || toPay < _amount ) ; lockTokens ( rcn , transferValue ) ; require ( rcn . transferFrom ( msg . sender , this , transferValue ) ) ; loan . lenderBalance = safeAdd ( transferValue , loan . lenderBalance ) ; return true ; }
","Pay loan Does a payment of a given Loan , before performing the payment the accumulated interest is computed and added to the total pending amount .
"
"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . onApprove ( msg . sender , _spender , _amount ) ) throw ; } return super . approve ( _spender , _amount ) ; }
","` msg.sender ` approves ` _spender ` to spend ` _amount ` tokens on its behalf .
"
"function _adjustBalanceCheckpoints ( address _investor ) internal { TokenLib . adjustCheckpoints ( checkpointBalances [ _investor ] , balanceOf ( _investor ) , currentCheckpointId ) ; }
","Internal - adjusts token holder balance at checkpoint after a token transfer
"
"function checkMonthlyLimit ( ) external constant returns ( uint256 remaining ) { return monthlyLimit [ msg . sender ] ; }
","Check how much Casino withdrawal balance remains for address
"
"function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = WHITELIST ; return allPermissions ; }
","Return the permissions flag that are associated with Percentage transfer Manager
"
"function checkPermission ( address _delegate , address _module , bytes32 _perm ) public view returns ( bool ) { if ( modules [ PERMISSIONMANAGER_KEY ] . length == 0 ) { return false ; } for ( uint8 i = 0 ; i < modules [ PERMISSIONMANAGER_KEY ] . length ; i ++ ) { if ( IPermissionManager ( modules [ PERMISSIONMANAGER_KEY ] [ i ] . moduleAddress ) . checkPermission ( _delegate , _module , _perm ) ) { return true ; } } }
","Validate permissions with PermissionManager if it exists , If no Permission return false
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _tokenExists ( _tokenId ) ) ; require ( _approvedFor ( _to , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; require ( _owns ( msg . sender , _tokenId ) || ( msg . sender == playerTokenToApproved [ _tokenId ] ) || operators [ _from ] [ msg . sender ] ) ; _transfer ( _from , _to , _tokenId ) ; }
","Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
"
"function ensureInAccountList ( address addr ) internal { require ( ! readOnly , ""Read only mode engaged"" ) ; bool found = false ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { if ( current == addr ) { found = true ; break ; } current = addressLinkedList [ current ] ; } if ( ! found ) { addToAccountList ( addr ) ; } }
","Make sure that this address exists in our linked list
"
"function claimTokens ( address _token ) public onlyOwner { NEC token = NEC ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) ;
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function getValueAt ( Checkpoint [ ] storage _checkpoints , uint256 _checkpointId , uint256 _currentValue ) public view returns ( uint256 ) { if ( _checkpointId == 0 ) { return 0 ; } if ( _checkpoints . length == 0 ) { return _currentValue ; } if ( _checkpoints [ 0 ] . checkpointId >= _checkpointId ) { return _checkpoints [ 0 ] . value ; } if ( _checkpoints [ _checkpoints . length - 1 ] . checkpointId < _checkpointId ) { return _currentValue ; } if ( _checkpoints [ _checkpoints . length - 1 ] . checkpointId == _checkpointId ) { return _checkpoints [ _checkpoints . length - 1 ] . value ; } uint256 min = 0 ; uint256 max = _checkpoints . length - 1 ; while ( max > min ) { uint256 mid = ( max + min ) / 2 ; if ( _checkpoints [ mid ] . checkpointId == _checkpointId ) { max = mid ; break ; } if ( _checkpoints [ mid ] . checkpointId < _checkpointId ) { min = mid + 1 ; } else { max = mid ; } } return _checkpoints [ max ] . value ; }
","Queries a value at a defined checkpoint
"
"function setPreDGZtoDgzRate ( uint rate ) public onlyOwner { preDGZtoDGZExchangeRate = rate ; tokensAvailableForSale = totalTokensAvailableForSale - preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 - privateSalesTokensSold ; }
","In case if prices are changed due to some great change in ETH price , this function can be used to change conversion rate for preDGZ owners .
"
"function withdraw ( uint256 _gameID ) external isHuman ( ) isActivated ( _gameID ) isEnded ( _gameID ) { require ( now < game_ [ _gameID ] . withdrawDeadline , ""withdraw deadline already passed"" ) ; require ( gameStatus_ [ _gameID ] . fundCleared == false , ""fund already cleared"" ) ; uint256 _pID = BMBook . pIDxAddr_ ( msg . sender ) ; require ( _pID != 0 , ""player has not played this game"" ) ; require ( players_ [ _pID ] [ _gameID ] . withdrawn == false , ""player already cashed out"" ) ; players_ [ _pID ] [ _gameID ] . withdrawn = true ; if ( game_ [ _gameID ] . canceled ) { uint256 _totalInvestment = players_ [ _pID ] [ _gameID ] . eth . mul ( 95 ) / 100 ; if ( _totalInvestment > 0 ) { BMBook . getPlayerAddr ( _pID ) . transfer ( _totalInvestment ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalInvestment . add ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; } emit BMEvents . onWithdraw ( _gameID , _pID , msg . sender , BMBook . getPlayerName ( _pID ) , _totalInvestment , now ) ; } else { uint256 _totalWinnings = getPlayerInstWinning ( _gameID , _pID , game_ [ _gameID ] . winnerTeam ) . add ( getPlayerPotWinning ( _gameID , _pID , game_ [ _gameID ] . winnerTeam ) ) ; if ( _totalWinnings > 0 ) { BMBook . getPlayerAddr ( _pID ) . transfer ( _totalWinnings ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalWinnings . add ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; } emit BMEvents . onWithdraw ( _gameID , _pID , msg . sender , BMBook . getPlayerName ( _pID ) , _totalWinnings , now ) ; } }
","Withdraw winnings .
"
"function updateFromRegistry ( ) external ;
","Use to get the latest contract address of the regstries
"
"function getPoll ( bytes32 _hash ) external constant returns ( bool , string , uint8 , uint256 , uint256 , bool , uint256 , uint256 , uint256 ) { Poll poll = polls [ _hash ] ; return ( poll . exists , poll . title , poll . percentage , poll . hashRate , totalHashRate , poll . approved , poll . approvalBlock , poll . approvalHashRate , poll . approvalTotalHashRate ) ; }
","Retreive the poll data
"
"function tokenBurner ( uint256 _amount ) public onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( totalSupply . sub ( _amount ) >= 0 ) ; require ( balances [ msg . sender ] >= _amount ) ; require ( balances [ msg . sender ] . sub ( _amount ) >= 0 ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; Transfer ( msg . sender , 0 , _amount ) ; return true ; }
","Used to burn tokens
"
"function contribute ( address _miner ) internal notBeforeGenesis nonZeroValued notPaused returns ( bool ) { uint256 block = currentBlock ( ) ; uint256 halving = currentHalving ( ) ; uint256 hashRate = HASH_RATE_MULTIPLIER . mul ( msg . value ) ; Miner miner = miners [ _miner ] ; if ( halving != 0 && halving < maxHalvings ) { uint256 I ; uint256 n = 0 ; for ( I = halving - 1 ; I > 0 ; I -- ) { if ( ! halvingsHashRate [ I ] . carried ) { n = n . add ( 1 ) ; } else { break ; } } for ( I = halving - n ; I < halving ; I ++ ) { if ( ! halvingsHashRate [ I ] . carried ) { halvingsHashRate [ I ] . carried = true ; halvingsHashRate [ I ] . rate = halvingsHashRate [ I ] . rate . add ( halvingsHashRate [ I - 1 ] . rate ) ; } } } if ( halving < maxHalvings ) { halvingsHashRate [ halving ] . rate = halvingsHashRate [ halving ] . rate . add ( hashRate ) ; } if ( miner . block == 0 ) { miner . block = block ; } miner . hashRate [ halving ] . rate = miner . hashRate [ halving ] . rate . add ( hashRate ) ; miner . totalHashRate = miner . totalHashRate . add ( hashRate ) ; totalHashRate = totalHashRate . add ( hashRate ) ; if ( ! bthFoundationWallet . send ( msg . value ) ) { throw ; } LogContribution ( _miner , msg . value , hashRate , block , halving ) ; return true ; }
","Contribute to the mining of BTH
"
"function emergencySplitToggle ( ) isAdmin external { splitInService = ! splitInService ; }
","Disable the splitting function
"
"function checkRelease ( ERC20 token ) public { uint _unRelease = 0 ; for ( uint i = 0 ; i < _amount . length ; i ++ ) { _unRelease = _unRelease . add ( _amount [ i ] ) ; } if ( _unRelease == 0 && block . timestamp >= _unlocktime ) { token . transfer ( owner , token . balanceOf ( this ) ) ; } }
","Release the unexpected token .
"
"function setMigrationAgent ( address _agent ) external isUpgrading onlyOwner { require ( _agent != 0x00 ) ; agent = MigrationAgent ( _agent ) ; if ( ! agent . isMigrationAgent ( ) ) { revert ( ) ; } if ( agent . originalSupply ( ) != supply ) { revert ( ) ; } }
","Set address of migration target contract and enable migration process .
"
"function ( ) external payable { require ( msg . sender == address ( saleAuction ) || msg . sender == address ( siringAuction ) || msg . sender == ceoAddress ) ; }
","No tipping !
"
"function changeController ( address _newController ) public auth { require ( _newController != 0x0 ) ; pls . changeController ( _newController ) ; ControllerChanged ( _newController ) ; }
","The owner of this contract can change the controller of the PLS token Please , be sure that the owner is a trusted agent or 0x0 address .
"
"function ( ) public payable { distribute ( ) ; }
","The Fallback Function that accepts payments .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( crowdsaleSuccessful ) ; require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; uint256 allowed = allowance [ _from ] [ msg . sender ] ; require ( _value <= allowed || _from == msg . sender ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; balanceOf [ _from ] = balanceOf [ _from ] . sub ( _value ) ; if ( allowed != MAX_UINT256 && _from != msg . sender ) { allowance [ _from ] [ msg . sender ] = allowed . sub ( _value ) ; } Transfer ( _from , _to , _value ) ; success = true ; }
","send ` _value ` tokens to ` _to ` address from ` _from ` address if allowance allows
"
"function addProductEndorsement ( string _mappingID , uint _operationIndex , int _productIndex , bool positive , string title , string description ) external returns ( bool success ) { require ( _productIndex > 0 ) ; productOperationEndorsements [ keccak256 ( _mappingID , _operationIndex , _productIndex ) ] . push ( Endorsement ( positive , title , description , msg . sender ) ) ; return true ; }
","Add new endorsement to product winery operation
"
"function collateralisationRatio ( address issuer ) public view returns ( uint ) { uint totalOwnedSynthetix = collateral ( issuer ) ; if ( totalOwnedSynthetix == 0 ) return 0 ; uint debtBalance = debtBalanceOf ( issuer , ""SNX"" ) ; return debtBalance . divideDecimalRound ( totalOwnedSynthetix ) ; }
","The current collateralisation ratio for a user .
"
"function batchTransfer ( address [ ] _tos , uint256 [ ] _values ) public returns ( bool success ) { require ( _tos . length == _values . length ) ; uint256 numTransfers = _tos . length ; uint256 senderBalance = erc20Store . balances ( msg . sender ) ; for ( uint256 i = 0 ; i < numTransfers ; i ++ ) { address to = _tos [ i ] ; require ( to != address ( 0 ) ) ; uint256 v = _values [ i ] ; require ( senderBalance >= v ) ; if ( msg . sender != to ) { senderBalance -= v ; erc20Store . addBalance ( to , v ) ; } erc20Proxy . emitTransfer ( msg . sender , to , v ) ; } erc20Store . setBalance ( msg . sender , senderBalance ) ; return true ; }
","A function for a sender to issue multiple transfers to multiple different addresses at once .
"
"function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) private whenNotPaused { address senderImplementation = interfaceAddr ( _from , ""ERC777TokensSender"" ) ; if ( senderImplementation != 0 ) { ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } }
","Helper function that checks for ERC777TokensSender on the sender and calls it .
"
"function sellMaximumPossibleAmountOfTokens ( ) { require ( ! frozenAccount [ msg . sender ] ) ; require ( tokenBalanceOf [ msg . sender ] > 0 ) ; require ( this . balance > sellPrice ) ; if ( tokenBalanceOf [ msg . sender ] * sellPrice <= this . balance ) { sell ( tokenBalanceOf [ msg . sender ] ) ; } else { sell ( this . balance / sellPrice ) ; } }
","Allow user to sell maximum possible amount of metadollars , depend on ether amount on contract
"
"function claim ( address engine , uint256 loanId , bytes ) external returns ( bool ) { uint256 mortgageId = loanToLiability [ engine ] [ loanId ] ; Mortgage storage mortgage = mortgages [ mortgageId ] ; require ( mortgage . status == Status . Ongoing , ""Mortgage not ongoing"" ) ; require ( mortgage . loanId == loanId , ""Mortgage don't match loan id"" ) ; if ( mortgage . engine . getStatus ( loanId ) == Engine . Status . paid || mortgage . engine . getStatus ( loanId ) == Engine . Status . destroyed ) { require ( _isAuthorized ( msg . sender , mortgageId ) , ""Sender not authorized"" ) ; mortgage . status = Status . Paid ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit PaidMortgage ( msg . sender , mortgageId ) ; } else if ( isDefaulted ( mortgage . engine , loanId ) ) { require ( msg . sender == mortgage . engine . ownerOf ( loanId ) , ""Sender not lender"" ) ; mortgage . status = Status . Defaulted ; land . safeTransferFrom ( this , msg . sender , mortgage . landId ) ; emit DefaultedMortgage ( mortgageId ) ; } else { revert ( ""Mortgage not defaulted/paid"" ) ; } _destroy ( mortgageId ) ; delete mortgageByLandId [ mortgage . landId ] ; return true ; }
","Claims the mortgage when the loan status is resolved and transfers the ownership of the parcel to which corresponds .
"
"function deedName ( uint256 _deedId ) external pure returns ( string _deedName ) ;
","A distinct name for a deed managed by this contract
"
"function blockTime ( ) constant returns ( uint32 ) { return uint32 ( block . timestamp ) ; }
","for test purpose
"
"function getBalance ( bytes32 _requestId ) public view returns ( int256 ) { int256 balance = requests [ _requestId ] . payee . balance ; for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { balance = balance . add ( subPayees [ _requestId ] [ i ] . balance ) ; } return balance ; }
","Gets balance total of a request .
"
"function paymentMixed ( uint256 _regularTokenAmount , uint256 _rewardTokenAmount , uint256 _rewardPercentageIndex ) public { paymentRewardTokens ( _rewardTokenAmount ) ; paymentRegularTokens ( _regularTokenAmount , _rewardPercentageIndex ) ; }
","Process a TRVL tokens payment with a combination of regular and rewards tokens .
"
"function freezeAccount ( address _target , bool _freeze ) public onlyOwner returns ( bool ) { _frozenAccount [ _target ] = _freeze ; AccountFrozen ( _target , _freeze ) ; return true ; }
","Freeze or unfreeze account , can be run only by owner
"
"function bulkTransfer ( address [ ] _destinations , uint256 [ ] _amounts ) public onlyAdmin returns ( bool ) { require ( _destinations . length == _amounts . length , ""Invalid operation."" ) ; uint256 requiredBalance = sumOf ( _amounts ) ; require ( balances [ msg . sender ] >= requiredBalance , ""You don't have sufficient funds to transfer amount that large."" ) ; for ( uint256 i = 0 ; i < _destinations . length ; i ++ ) { transfer ( _destinations [ i ] , _amounts [ i ] ) ; } emit BulkTransferPerformed ( _destinations , _amounts ) ; return true ; }
","Allows only the admins and/or whitelisted applications to perform bulk transfer operation .
"
"function applyDiscount ( uint256 _etherAmount , uint256 _contributorTokens ) internal constant returns ( uint256 ) { return _contributorTokens ; }
","Applies the discount based on the discount tiers
"
"function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes _data ) public returns ( bytes4 ) ;
","Handle the receipt of an NFT
"
"function STARTMETADOLLAR ( ) { sellPrice = 900000000000000 ; mtdAmount = 1000000000000000000 ; ethAmount = 1000000000000000 ; mtdPreAmount = 1 ; ethPreAmount = 1 ; preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = mtdAmount * ethAmount ; preICOprice = mtdPreAmount * ethPreAmount ; ICOprice = mtdAmount * ethAmount ; sellPrice = 0 ; updatePrices ( ) ; }
","Constructor of the contract
"
"function incremental ( uint256 totalEuroUlps , uint256 euroUlps ) public pure returns ( uint256 neumarkUlps ) { require ( totalEuroUlps + euroUlps >= totalEuroUlps ) ; uint256 from = cumulative ( totalEuroUlps ) ; uint256 to = cumulative ( totalEuroUlps + euroUlps ) ; assert ( to >= from ) ; return to - from ; }
","returns additional amount of neumarks issued for euroUlps at totalEuroUlps
"
"function setDirectPaymentThreshold ( uint256 threshold ) external onlyCFO { directPaymentThreshold = threshold ; }
","Set the threshold for a payment to be sent directly .
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < ownerToRareArray [ _owner ] . length ) ; if ( _owner != address ( 0 ) ) { uint256 tokenId = ownerToRareArray [ _owner ] [ _index ] ; return tokenId ; } }
","Enumerate rare items assigned to an owner
"
"function withdrawHavvens ( uint quantity ) external onlyOwner onlyDuringSetup { havven . transfer ( havven , quantity ) ; }
","Withdraws a quantity of havvens back to the havven contract .
"
"function getItem ( uint256 _tokenId ) public view returns ( string itemName , uint256 sellingPrice , address owner , bytes32 itemMessage , address creator ) { Item storage item = items [ _tokenId ] ; itemName = item . name ; itemMessage = item . message ; sellingPrice = itemIndexToPrice [ _tokenId ] ; owner = itemIndexToOwner [ _tokenId ] ; creator = item . creatoraddress ; }
","Returns all the relevant information about a specific item .
"
"function delegateVote ( address _to ) public { require ( ! gaveVote ( msg . sender ) ) ; require ( ! isDelegate [ msg . sender ] ) ; require ( isDelegate [ _to ] ) ; require ( myDelegate [ msg . sender ] == address ( 0 ) ) ; myDelegate [ msg . sender ] = _to ; myVotes [ _to ] . push ( msg . sender ) ; }
","Delegate vote to other address
"
"function approve ( address _spender , uint256 _amount ) returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] > 0 ) ; allowance [ msg . sender ] [ _spender ] = _amount ; Approve ( msg . sender , _spender , _amount ) ; return true ; }
","Used to approve a third-party to send funds on your behalf
"
"function transferFrom ( address from , address to , uint value ) public returns ( bool ) ;
","send ` value ` token to ` to ` from ` from ` on the condition it is approved by ` from `
"
"function depositERC20 ( address _user , address _token , uint256 _amount ) external onlyCoordinator onlyActiveState { require ( _amount > 0 , 'Invalid value' ) ; balances [ _user ] [ _token ] = balances [ _user ] [ _token ] . add ( _amount ) ; require ( ERC20 ( _token ) . transferFrom ( _user , address ( this ) , _amount ) , ""transferFrom failed."" ) ; emit BalanceIncrease ( _user , _token , _amount , ReasonDeposit ) ; }
","Deposits ERC20 tokens under the ` _user ` 's balance
"
"function price ( ) public constant returns ( uint ) { if ( stage == Stages . AuctionEnded || stage == Stages . AuctionCanceled || stage == Stages . TokensDistributed ) { return 0 ; } return calcTokenPrice ( ) ; }
","Get the XCH price in WEI during the auction , at the time of calling this function .
"
"function burnFrom ( address _from , uint256 _value ) public returns ( bool success ) { require ( balances [ _from ] >= _value ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; totalSupply -= _value ; Burn ( _from , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly on behalf of ` _from ` .
"
"function changeEscapeCaller ( address _newEscapeCaller ) onlyEscapeCallerOrOwner { escapeCaller = _newEscapeCaller ; }
","Changes the address assigned to call ` escapeHatch ( ) `
"
"function tokenFallback ( address _sender_address , uint256 _deposit , bytes _data ) external { require ( msg . sender == address ( token ) ) ; uint192 deposit = uint192 ( _deposit ) ; require ( deposit == _deposit ) ; uint length = _data . length ; require ( length == 40 || length == 44 ) ; address channel_sender_address = address ( addressFromBytes ( _data , 0x20 ) ) ; require ( _sender_address == channel_sender_address || trusted_contracts [ _sender_address ] ) ; address channel_receiver_address = address ( addressFromBytes ( _data , 0x34 ) ) ; if ( length == 40 ) { createChannelPrivate ( channel_sender_address , channel_receiver_address , deposit ) ; } else { uint32 open_block_number = uint32 ( blockNumberFromBytes ( _data , 0x48 ) ) ; updateInternalBalanceStructs ( channel_sender_address , channel_receiver_address , open_block_number , deposit ) ; } }
","Opens a new channel or tops up an existing one , compatibility with ERC 223 .
"
"function canClaim ( bytes32 channelId , uint256 payment , address origin , bytes signature ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isReceiver = origin == channel . receiver ; bytes32 hash = recoveryPaymentDigest ( channelId , payment ) ; bool isSigned = channel . sender == ECRecovery . recover ( hash , signature ) ; return isReceiver && isSigned ; }
","Ensure ` origin ` address can claim ` payment ` amount on channel identified by ` channelId ` .
"
"function transferFromPreSigned ( bytes _signature , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; bytes32 hashedTx = transferFromPreSignedHashing ( address ( this ) , _from , _to , _value , _fee , _nonce ) ; address spender = recover ( hashedTx , _signature ) ; require ( spender != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ spender ] = allowed [ _from ] [ spender ] . sub ( _value ) ; balances [ spender ] = balances [ spender ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Transfer ( _from , _to , _value ) ; emit Transfer ( spender , msg . sender , _fee ) ; return true ; }
","Transfer tokens from one address to another
"
"function transferFrom ( address from , address to , uint value ) public optionalProxy returns ( bool ) { address sender = messageSender ; require ( nominsIssued [ from ] == 0 || value <= transferableHavvens ( from ) , ""Value to transfer exceeds available havvens"" ) ; _transferFrom_byProxy ( sender , from , to , value ) ; return true ; }
","ERC20 transferFrom function .
"
"function setRoundRate ( uint32 roundNum , uint256 rate ) public onlyOwner { require ( roundNum < rounds . length ) ; rounds [ roundNum ] . rate = rate ; }
","Updates rate for the round
"
"function finalize ( ) external isNotFinalized onlyOwner { finalized = true ; Finalize ( msg . sender , totalSupply ) ; }
","This function completes BUY tokens .
"
"function removeAssetPartOwner ( bytes32 _symbol , address _partowner ) external onlyOneOfOwners ( _symbol ) returns ( uint ) { uint holderId = getHolderId ( _partowner ) ; delete assets [ _symbol ] . partowners [ holderId ] ; Emitter ( eventsHistory ) . emitOwnershipChange ( _partowner , 0x0 , _symbol ) ; return OK ; }
","Removes a co-owner for an asset with provided symbol .
"
"function payOut ( ) public { require ( msg . sender == creator ) ; require ( creator . send ( this . balance ) ) ; LogBeneficiaryPaid ( creator ) ; }
","function to withdraw eth to creator address
"
"function withdraw ( string currency , address account , uint amount , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . verifyAccount ( account ) , ""Error: Account is not verified!"" ) ; require ( lib . withdraw ( currency , account , amount , issuerFirm ) , ""Error: Unable to withdraw funds. Please check issuerFirm and firm authority are registered and have issued funds that can be withdrawn"" ) ; return true ; }
","Withdraws a specified amount of tokens of a given currency
"
"function transferFrom ( address from , address to , uint256 tokenAmount ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokenAmount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokenAmount ) ; balances [ to ] = balances [ to ] . add ( tokenAmount ) ; emit Transfer ( from , to , tokenAmount ) ; return true ; }
","Transfer tokens from an address to another one through an allowance made before
"
"function startBuyback ( uint256 _roundStartTime , uint256 _rate ) onlyOwner external payable { require ( _roundStartTime > now ) ; roundStartTime = _roundStartTime ; rate = _rate ; }
","Starts buyback at specified time , with specified rate
"
"function claimTokensByUser ( ) public { require ( KYCValid [ msg . sender ] == true ) ; uint256 tokens = balance [ msg . sender ] ; balance [ msg . sender ] = 0 ; require ( tokenReward . transfer ( msg . sender , tokens ) ) ; tokensSent [ msg . sender ] = tokensSent [ msg . sender ] . add ( tokens ) ; emit LogContributorsPayout ( msg . sender , tokens ) ; }
","function to let users claim their tokens
"
"function getAssetPackData ( uint _assetPackId ) public view returns ( bytes32 , address , uint , uint [ ] , uint [ ] , bytes32 [ ] , string , string , bytes32 ) { require ( _assetPackId < numberOfAssetPacks ) ; AssetPack memory assetPack = assetPacks [ _assetPackId ] ; bytes32 [ ] memory hashes = new bytes32 [ ] ( assetPack . assetIds . length ) ; for ( uint i = 0 ; i < assetPack . assetIds . length ; i ++ ) { hashes [ i ] = getAssetIpfs ( assetPack . assetIds [ i ] ) ; } uint [ ] memory attributes = getAttributesForAssets ( assetPack . assetIds ) ; return ( assetPack . packCover , assetPack . creator , assetPack . price , assetPack . assetIds , attributes , hashes , assetPack . ipfsHash , userManager . getUsername ( assetPack . creator ) , userManager . getProfilePicture ( assetPack . creator ) ) ; }
","Function to get ipfs hash and id for all assets in one asset pack
"
"function createNewTask ( uint uuid , uint amount ) public onlyCurator sufficientDevFundBalance ( amount ) { communityAccount . setEscrowedTaskBalances ( uuid , amount ) ; communityAccount . setTotalTaskEscrow ( SafeMath . add ( communityAccount . totalTaskEscrow ( ) , amount ) ) ; logger . emitTaskCreated ( uuid , amount ) ; logger . emitGenericLog ( ""createNewTask"" , """" ) ; }
","Updates the escrow values for a new task
"
"function addInvestorBonusInPercent ( address _to , uint8 p ) public onlyOwner { require ( p > 0 && p <= 5 ) ; uint bonus = balances [ _to ] . mul ( p ) . div ( 100 ) ; investorGiven = investorGiven . add ( bonus ) ; require ( investorGiven <= investorSupply ) ; _freezeTransfer ( _to , bonus ) ; }
","addInvestorBonusInPercent is used for sending bonuses for big investors in %
"
"function withdraw ( uint256 amount ) public { require ( _balances [ msg . sender ] >= amount ) ; _balances [ msg . sender ] = sub ( _balances [ msg . sender ] , amount ) ; _totalSupply = sub ( _totalSupply , amount ) ; LogWithdrawal ( msg . sender , amount ) ; Transfer ( msg . sender , address ( 0 ) , amount ) ; }
","withdraws 'amount ' of EUR-T by burning required amount and providing a proof of whithdrawal
"
"function ( ) payable { if ( controller == 0 ) throw ; if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) throw ; } else { if ( ! controller . send ( msg . value ) ) throw ; } }
","The fallback function : If the contract 's controller has not been set to 0 , the ether is sent to the controller ( normally the token creation contract ) using the ` proxyPayment ` method .
"
"function getCEOHashing ( address _newCEO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x486A0F3E ) , _newCEO , _nonce ) ; }
","Hash ( keccak256 ) of the payload used by setCEO
"
"function maxCommitTime ( Pledge p ) internal returns ( uint commitTime ) { PledgeAdmin storage m = findAdmin ( p . owner ) ; commitTime = m . commitTime ; for ( uint i = 0 ; i < p . delegationChain . length ; i ++ ) { m = findAdmin ( p . delegationChain [ i ] ) ; if ( m . commitTime > commitTime ) commitTime = m . commitTime ; } }
","A getter to find the longest commitTime out of the owner and all the delegates for a specified pledge
"
"function enableTransfers ( bool _transfersEnabled ) onlyController public { transfersEnabled = _transfersEnabled ; }
","Enables token holders to transfer their tokens freely if true
"
"function seal ( ) onlyController returns ( bool success ) { tokenController = 0 ; return true ; }
","` seal ( ) ` ends the Campaign by making it impossible to create more tokens .
"
"function setNextGameSettings ( uint256 rows , uint256 cols , uint256 activityTimer , uint256 unclaimedTilePrice , uint256 buyoutReferralBonusPercentage , uint256 buyoutPrizePoolPercentage , uint256 buyoutDividendPercentage , uint256 buyoutFeePercentage ) public onlyCFO { require ( 2000 <= buyoutDividendPercentage && buyoutDividendPercentage <= 12500 ) ; require ( buyoutFeePercentage <= 5000 ) ; nextGameSettings = GameSettings ( { rows : rows , cols : cols , activityTimer : activityTimer , unclaimedTilePrice : unclaimedTilePrice , buyoutReferralBonusPercentage : buyoutReferralBonusPercentage , buyoutPrizePoolPercentage : buyoutPrizePoolPercentage , buyoutDividendPercentage : buyoutDividendPercentage , buyoutFeePercentage : buyoutFeePercentage } ) ; NextGame ( rows , cols , activityTimer , unclaimedTilePrice , buyoutReferralBonusPercentage , buyoutPrizePoolPercentage , buyoutDividendPercentage , buyoutFeePercentage ) ; }
","Sets the settings for the next game .
"
"function canMateWith ( uint256 _matronId , uint256 _sireId ) external view returns ( bool ) { require ( _matronId > 0 ) ; require ( _sireId > 0 ) ; Pony storage matron = ponies [ _matronId ] ; Pony storage sire = ponies [ _sireId ] ; return _isValidMatingPair ( matron , _matronId , sire , _sireId ) && _isMatingPermitted ( _sireId , _matronId ) ; }
","Checks to see if two ponies can breed together , including checks for ownership and siring approvals .
"
"function changeDonor ( address _newDonor ) onlyDonor { donor = _newDonor ; }
","` onlyDonor ` Reassigns the ` donor ` to a new address
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) public validAddress ( _from ) validAddress ( _to ) validId ( _tokenId ) { require ( isApprovedOrOwner ( msg . sender , _tokenId ) , ""Sender does not have permission to transfer PixelCon"" ) ; clearApproval ( _from , _tokenId ) ; removeTokenFrom ( _from , _tokenId ) ; addTokenTo ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }
","Transfer the ownership of PixelCon ` ( _tokenId ) ` to ` ( _to ) ` ( try to use 'safeTransferFrom ' instead )
"
"function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; require ( creator . send ( this . balance ) ) ; tokenReward . transfer ( creator , remanent ) ; LogBeneficiaryPaid ( creator ) ; LogContributorsPayout ( creator , remanent ) ; }
","closure handler
"
"function replaySweep ( address [ ] _froms , address _to ) public onlySweeper { require ( _to != address ( 0 ) ) ; uint256 lenFroms = _froms . length ; uint256 sweptBalance = 0 ; for ( uint256 i = 0 ; i < lenFroms ; ++ i ) { address from = _froms [ i ] ; if ( sweptSet [ from ] ) { uint256 fromBalance = erc20Store . balances ( from ) ; if ( fromBalance > 0 ) { sweptBalance += fromBalance ; erc20Store . setBalance ( from , 0 ) ; erc20Proxy . emitTransfer ( from , _to , fromBalance ) ; } } } if ( sweptBalance > 0 ) { erc20Store . addBalance ( _to , sweptBalance ) ; } }
","For accounts that have delegated , transfer control to the sweeper , this function transfers their balances to the given destination .
"
"function calculateSeed ( uint [ ] _randomHashIds , uint _timestamp ) public view returns ( uint ) { require ( _timestamp != 0 ) ; require ( _randomHashIds . length == 10 ) ; bytes32 randomSeed = keccak256 ( abi . encodePacked ( randomHashes [ _randomHashIds [ 0 ] ] , randomHashes [ _randomHashIds [ 1 ] ] , randomHashes [ _randomHashIds [ 2 ] ] , randomHashes [ _randomHashIds [ 3 ] ] , randomHashes [ _randomHashIds [ 4 ] ] , randomHashes [ _randomHashIds [ 5 ] ] , randomHashes [ _randomHashIds [ 6 ] ] , randomHashes [ _randomHashIds [ 7 ] ] , randomHashes [ _randomHashIds [ 8 ] ] , randomHashes [ _randomHashIds [ 9 ] ] , _timestamp ) ) ; return uint ( randomSeed ) ; }
","Function to calculate initial random seed based on our hashes
"
"function isRegisteredInEpoch ( address _darknodeID , Epoch _epoch ) private view returns ( bool ) { uint256 registeredAt = store . darknodeRegisteredAt ( _darknodeID ) ; uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; bool registered = registeredAt != 0 && registeredAt <= _epoch . blocknumber ; bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch . blocknumber ; return registered && notDeregistered ; }
","Returns if a darknode was in the registered state for a given epoch .
"
"function transferToSelf ( uint256 _value ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ selfAddress ] = balances [ selfAddress ] + _value ; Transfer ( msg . sender , selfAddress , _value ) ; allowed [ selfAddress ] [ msg . sender ] = _value + allowed [ selfAddress ] [ msg . sender ] ; IOUSupply += _value ; Approval ( selfAddress , msg . sender , allowed [ selfAddress ] [ msg . sender ] ) ; return true ; }
","Handles Casino deposits ~ Custom ERC-223 Proposed Standard Addition
"
"function claimPlotMultiple ( uint256 [ ] _deedIds , uint256 _buyoutPrice ) external payable whenNotPaused { claimPlotMultipleWithData ( _deedIds , _buyoutPrice , """" , """" , """" , """" ) ; }
","Buy unclaimed plots .
"
"function getAssetInfo ( uint id ) public view returns ( uint , uint , uint , bytes32 ) { require ( id >= 0 ) ; require ( id < numberOfAssets ) ; Asset memory asset = assets [ id ] ; return ( asset . id , asset . packId , asset . attributes , asset . ipfsHash ) ; }
","Method to get all info for an asset
"
"function isInitialized ( ) public view returns ( bool ) { return _isInitialized ; }
","Check whether contract is initialised
"
"function finalizeSale ( ) onlyController { require ( now > endFundingTime || totalCollected >= maximumFunding ) ; require ( ! finalized ) ; uint256 reservedTokens = 225000000 * 0.35 * 10 ** 18 ; if ( ! tokenContract . generateTokens ( vaultAddress , reservedTokens ) ) { revert ( ) ; } finalized = true ; }
","` finalizeSale ( ) ` ends the EarlyTokenSale .
"
"function isOpen ( bytes32 channelId ) public view returns ( bool ) { return isPresent ( channelId ) && ! isSettling ( channelId ) ; }
","Check if the channel is open : present and not settling .
"
"function getAttributeTypeDescription ( uint256 attributeTypeID ) external view returns ( string description ) { return _attributeTypes [ attributeTypeID ] . description ; }
","Get a description of the attribute type with ID ` attributeTypeID ` .
"
"function release ( address token ) public onlyOwner { uint256 unreleased = _releasableAmount ( token ) ; require ( unreleased > 0 ) ; _released [ token ] = _released [ token ] . add ( unreleased ) ; tokenReward . transfer ( _beneficiary , unreleased ) ; }
","Mints and transfers tokens to beneficiary .
"
"function participantWithdrawIfMinimumFundingNotReached ( uint256 value ) external { if ( now <= PRESALE_END_DATE ) throw ; if ( totalFunding >= PRESALE_MINIMUM_FUNDING ) throw ; if ( balanceOf [ msg . sender ] < value ) throw ; balanceOf [ msg . sender ] = safeDecrement ( balanceOf [ msg . sender ] , value ) ; if ( ! msg . sender . send ( value ) ) throw ; }
","The participant will need to withdraw their funds from this contract if the presale has not achieved the minimum funding level
"
"function getSecurityTokenData ( address _securityToken ) public view returns ( string , address , string ) { return ( securityTokens [ _securityToken ] . symbol , ISecurityToken ( _securityToken ) . owner ( ) , securityTokens [ _securityToken ] . tokenDetails ) ; }
","Get security token data by its address
"
"function blockNumber ( bytes32 _symbol ) public view returns ( uint ) { return get ( store , assetBlockNumber , _symbol ) ; }
","Returns block number from which asset can be used .
"
"function approve ( address _spender , uint256 _value ) public onlyIfLockTimePassed returns ( bool ) { require ( _spender != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _spender ] == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to transfer ` _value ` tokens from ` msg.sender ` to any address .
"
"function procNormalSales ( ) payable public returns ( uint256 ) { uint256 amount = msg . value / buyPrice ; amount = amount * 10 ** uint256 ( decimals ) ; _transfer ( owner , msg . sender , amount ) ; owner . transfer ( msg . value ) ; return amount ; }
","Process normal sales transactions
"
"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner public { sellPrice = newSellPrice ; buyPrice = newBuyPrice ; tradeActive = true ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function extract ( address _to ) onlyController { require ( _to != 0x0 ) ; uint256 available = availableNow ( ) ; require ( available > 0 ) ; extracted = extracted . add ( available ) ; assert ( token . transfer ( _to , available ) ) ; Extract ( _to , available ) ; }
","Send all available tokens to a given address
"
"function addValidatorApproval ( address validator , uint256 attributeTypeID ) external onlyOwner whenNotPaused { require ( isValidator ( validator ) && isAttributeType ( attributeTypeID ) , ""must specify both a valid attribute and an available validator"" ) ; require ( _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] == false , ""validator is already approved on the provided attribute"" ) ; _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] = true ; uint256 index = _validatorApprovals [ validator ] . length ; _validatorApprovalsIndex [ validator ] [ attributeTypeID ] = index ; _validatorApprovals [ validator ] . push ( attributeTypeID ) ; emit ValidatorApprovalAdded ( validator , attributeTypeID ) ; }
","Approve the validator at address ` validator ` to issue attributes of the type with ID ` attributeTypeID ` .
"
"function lockedBbkOf ( address _address ) external view returns ( uint256 ) { return lockedBbkPerUser [ _address ] ; }
","Check an address for amount of currently locked BBK works similar to basic ERC20 balanceOf
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address _owner ) { _owner = tokenIdToOwner [ _tokenId ] ; require ( _owner != address ( 0 ) ) ; }
","Find the owner of an NFT
"
"function unfreezeAdministrationContract ( ) public onlyAdmin isFrozen returns ( bool unfrozen ) { administrationContractFrozen = false ; return true ; }
","used to unfreeze the administration contract
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public erc20 returns ( bool success ) { require ( _amount <= mAllowed [ _from ] [ msg . sender ] , ""Not enough funds allowed"" ) ; mAllowed [ _from ] [ msg . sender ] = mAllowed [ _from ] [ msg . sender ] . sub ( _amount ) ; doSend ( msg . sender , _from , _to , _amount , """" , """" , false ) ; return true ; }
","ERC20 backwards compatible transferFrom .
"
"function setTokenConverter ( TokenConverter _tokenConverter ) external onlyOwner returns ( bool ) { emit SetTokenConverter ( tokenConverter , _tokenConverter ) ; tokenConverter = _tokenConverter ; return true ; }
","Sets the token converter used to convert the MANA into RCN when performing the payment
"
"function setMigrationAgent ( address _agent ) external onlyOwner { require ( migrationAgent == 0x0 && totalMigrated == 0 ) ; migrationAgent = _agent ; }
","Set address of migration target contract and enable migration process
"
"function vote ( uint _proposalId , bool _yes ) public { require ( _proposalId < proposals . length ) ; require ( checkIfCurrentlyActive ( _proposalId ) ) ; Proposal memory p = proposals [ _proposalId ] ; uint amount = MiniMeToken ( p . token ) . balanceOf ( msg . sender ) ; require ( amount > 0 ) ; require ( MiniMeToken ( p . token ) . transferFrom ( msg . sender , address ( this ) , amount ) ) ; if ( _yes ) { proposals [ _proposalId ] . yesVotes += amount ; } else { proposals [ _proposalId ] . noVotes += amount ; } emit Vote ( _proposalId , msg . sender , _yes , amount ) ; }
","Vote for specific proposal with yes or no
"
"function recoverUnawardedMILs ( ) public { uint256 MILs = militaryToken . balanceOf ( address ( this ) ) ; if ( totalAwards < MILs ) { militaryToken . transfer ( owner , MILs - totalAwards ) ; } }
","Transfers any un-awarded MILs to the contract owner .
"
"function setApprove ( address _sender , address _spender , uint256 _value ) external onlyModule returns ( bool ) { allowed [ _sender ] [ _spender ] = _value ; return true ; }
","Set allowance of ` _spender ` in behalf of ` _sender ` at ` _value `
"
"function transfer ( address to , uint256 tokens ) public returns ( bool success ) { requireTrade ( msg . sender ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; ensureInAccountList ( to ) ; return true ; }
","Transfer the balance from token owner 's account to ` to ` account - Owner 's account must have sufficient balance to transfer - 0 value transfers are allowed
"
"function unvote ( uint _idPoll ) public { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll storage p = _polls [ _idPoll ] ; require ( block . number >= p . startBlock && block . number < p . endBlock && ! p . canceled , ""Poll is inactive"" ) ; if ( p . voters == 0 ) return ; p . voters -- ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { uint ballotAmount = p . ballots [ i ] [ msg . sender ] ; p . ballots [ i ] [ msg . sender ] = 0 ; if ( ballotAmount != 0 ) { p . qvResults [ i ] -= sqrt ( ballotAmount / 1 ether ) ; p . results [ i ] -= ballotAmount ; } } emit Unvote ( _idPoll , msg . sender ) ; }
","Cancel or reset a vote
"
"function setSlippage ( uint slip ) public auth { require ( slip < WAD ) ; slippage = slip ; }
","set the acceptable price slippage for trades .
"
"function proxy_contribution ( address _toAddr ) public payable { require ( _toAddr != 0x0 ) ; process_contribution ( _toAddr ) ; }
","This function handles receiving Ether in favor of a third party address we can use this function for buying tokens on behalf
"
"function createERC20TokenNetwork ( address _token_address ) canCreateTokenNetwork external returns ( address token_network_address ) { require ( token_to_token_networks [ _token_address ] == address ( 0x0 ) ) ; token_network_created = true ; TokenNetwork token_network ; token_network = new TokenNetwork ( _token_address , secret_registry_address , chain_id , settlement_timeout_min , settlement_timeout_max , deprecation_executor ) ; token_network_address = address ( token_network ) ; token_to_token_networks [ _token_address ] = token_network_address ; emit TokenNetworkCreated ( _token_address , token_network_address ) ; return token_network_address ; }
","Deploy a new TokenNetwork contract for the Token deployed at ` _token_address ` .
"
"function setWallet ( address _wallet ) external validAddress ( _wallet ) onlyOwner { wallet = _wallet ; }
","To set the wallet address by the owner only
"
"function _burn ( address _owner , uint256 _tokenId ) internal { super . _burn ( _owner , _tokenId ) ; assert ( tokens . length > 0 ) ; uint256 tokenIndex = idToIndex [ _tokenId ] ; assert ( tokens [ tokenIndex ] == _tokenId ) ; uint256 lastTokenIndex = tokens . length . sub ( 1 ) ; uint256 lastToken = tokens [ lastTokenIndex ] ; tokens [ tokenIndex ] = lastToken ; tokens . length -- ; idToIndex [ lastToken ] = tokenIndex ; idToIndex [ _tokenId ] = 0 ; }
","This is a private function which should be called from user-implemented external burn function .
"
"function getAllModulesAndPermsFromTypes ( address _delegate , uint8 [ ] _types ) external view returns ( address [ ] , bytes32 [ ] ) ;
","Used to return all permission of a single or multiple module
"
"function payToEvaluator ( uint _JobID , uint _payment ) public { require ( _JobID >= 0 ) ; require ( _payment > 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender == job . manager ) ; address evaluator = job . evaluator ; require ( DAI . allowance ( job . manager , address ( this ) ) >= _payment ) ; emit EvaluatorPaid ( msg . sender , evaluator , _JobID , _payment ) ; DAI . transferFrom ( job . manager , evaluator , _payment ) ; }
","this function lets the manager pay DAI to arbitrator
"
"function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 2 ) ; allPermissions [ 0 ] = WHITELIST ; allPermissions [ 1 ] = ADMIN ; return allPermissions ; }
","Return the permissions flag that are associated with Percentage transfer Manager
"
"function removeModule ( address _moduleFactory ) external whenNotPausedOrOwner { uint256 moduleType = getUint ( Encoder . getKey ( ""registry"" , _moduleFactory ) ) ; require ( moduleType != 0 , ""Module factory should be registered"" ) ; require ( msg . sender == IOwnable ( _moduleFactory ) . owner ( ) || msg . sender == owner ( ) , ""msg.sender must be the Module Factory owner or registry curator"" ) ; uint256 index = getUint ( Encoder . getKey ( ""moduleListIndex"" , _moduleFactory ) ) ; uint256 last = getArrayAddress ( Encoder . getKey ( ""moduleList"" , moduleType ) ) . length - 1 ; address temp = getArrayAddress ( Encoder . getKey ( ""moduleList"" , moduleType ) ) [ last ] ; if ( index != last ) { setArrayIndexValue ( Encoder . getKey ( ""moduleList"" , moduleType ) , index , temp ) ; set ( Encoder . getKey ( ""moduleListIndex"" , temp ) , index ) ; } deleteArrayAddress ( Encoder . getKey ( ""moduleList"" , moduleType ) , last ) ; set ( Encoder . getKey ( ""registry"" , _moduleFactory ) , uint256 ( 0 ) ) ; setArray ( Encoder . getKey ( ""reputation"" , _moduleFactory ) , new address [ ] ( 0 ) ) ; set ( Encoder . getKey ( ""verified"" , _moduleFactory ) , false ) ; set ( Encoder . getKey ( ""moduleListIndex"" , _moduleFactory ) , uint256 ( 0 ) ) ; emit ModuleRemoved ( _moduleFactory , msg . sender ) ; }
","Called by the ModuleFactory owner or registry curator to delete a ModuleFactory from the registry
"
"function addPlotAndData ( uint24 [ ] purchase , string ipfsHash , string url , uint256 initialBuyoutPriceInWeiPerPixel ) private returns ( uint256 ) { uint256 newPlotIndex = ownership . length ; ownership . push ( PlotOwnership ( purchase [ 0 ] , purchase [ 1 ] , purchase [ 2 ] , purchase [ 3 ] , msg . sender ) ) ; data [ newPlotIndex ] = PlotData ( ipfsHash , url ) ; if ( initialBuyoutPriceInWeiPerPixel > 0 ) { plotIdToPrice [ newPlotIndex ] = initialBuyoutPriceInWeiPerPixel ; } return newPlotIndex ; }
","Stores the plot information and data for a newly purchased plot .
"
"function addDistributionPeriod ( ) public onlyProfiterole returns ( uint ) { uint _periodsCount = periodsCount ; uint _nextPeriod = _periodsCount . add ( 1 ) ; periodDate2periodIdx [ now ] = _periodsCount ; Period storage _previousPeriod = periods [ _periodsCount ] ; uint _totalBmcDeposit = _getTotalBmcDaysAmount ( now , _periodsCount ) ; periods [ _nextPeriod ] . startDate = now ; periods [ _nextPeriod ] . bmcDaysPerDay = _previousPeriod . bmcDaysPerDay ; periods [ _nextPeriod ] . totalBmcDays = _totalBmcDeposit ; periodsCount = _nextPeriod ; return OK ; }
","Makes a checkpoint to start counting a new period
"
"function stage ( ) public constant returns ( Stage ) { if ( finalized ) { return Stage . Finalized ; } if ( ! initialized ) { return Stage . Created ; } if ( block . timestamp < startTime ) { return Stage . Initialized ; } if ( uint256 ( soldOut . cornerstoneValue ) . add ( soldOut . vcValue ) >= publicSupply ) { return Stage . Closed ; } if ( block . timestamp < endTime ) { if ( block . timestamp < startTime . add ( earlyStageLasts ) ) { return Stage . Early ; } return Stage . Normal ; } return Stage . Closed ; }
","estimate stage
"
"function breedWith ( uint40 _momId , uint40 _dadId ) public whenNotPaused returns ( uint40 ) { require ( _isOwner ( msg . sender , _momId ) ) ; require ( _isBreedingPermitted ( _dadId , _momId ) ) ; Cutie storage mom = cuties [ _momId ] ; require ( _canBreed ( mom ) ) ; Cutie storage dad = cuties [ _dadId ] ; require ( _canBreed ( dad ) ) ; require ( _canPairMate ( mom , _momId , dad , _dadId ) ) ; return _breedWith ( _momId , _dadId ) ; }
","Breed cuties that you own , or for which you have previously been given Breeding approval .
"
"function addNFToken ( address _to , uint256 _tokenId ) internal { super . addNFToken ( _to , _tokenId ) ; uint256 length = ownerToIds [ _to ] . push ( _tokenId ) ; idToOwnerIndex [ _tokenId ] = length - 1 ; }
","Use and override this function with caution .
"
"function convert_valuation_to_art ( uint _valuation , uint _art_price ) view public returns ( uint amount ) { amount = ( ( _valuation . mul ( oracle_price_decimals_factor ) ) . div ( _art_price ) ) . mul ( decimal_precission_difference_factor ) ; }
","Helper function that calculates the valuation of the asset in terms of an ART token quantity .
"
"function addHandlerToWhitelist ( address handler ) public onlyOwner handlerNotWhitelisted ( handler ) { handlerWhitelistMap [ handler ] = true ; handlerWhitelistArray . push ( handler ) ; emit GenericEvent ( 1 ) ; }
","Add an exchangeHandler address to the whitelist
"
"function clearApproval ( address _owner , uint256 _tokenId ) public { require ( msg . sender == _ownerOf ( _tokenId ) ) ; _clearApproval ( msg . sender , _tokenId ) ; }
","Clear current approval of ` _tokenId ` owned by ` _owner ` ,
"
"function changeRegistrationStatus ( address target , bool isRegistered ) public onlyBy ( owner ) { registered [ target ] = isRegistered ; }
","Updates registration status of an address for sale participation
"
"function withdrawFees ( address _to , uint256 _amount ) onlyOwner external { require ( _amount <= feesAvailableForWithdraw , ""Amount is higher than amount available"" ) ; feesAvailableForWithdraw -= _amount ; _to . transfer ( _amount ) ; }
","Withdraw fees collected by the contract .
"
"function upgrade ( uint256 value ) external { if ( nextUpgradeAgent . owner ( ) == 0x0 ) revert ( ) ; if ( finalizedNextUpgrade ) revert ( ) ; if ( value == 0 ) revert ( ) ; if ( value > balances [ msg . sender ] ) revert ( ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; nextUpgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , nextUpgradeAgent , value ) ; }
","Upgrade tokens to the new token contract .
"
"function requestImplChange ( address _proposedImpl ) public returns ( bytes32 lockId ) { require ( _proposedImpl != address ( 0 ) ) ; lockId = generateLockId ( ) ; implChangeReqs [ lockId ] = ImplChangeRequest ( { proposedNew : _proposedImpl } ) ; emit ImplChangeRequested ( lockId , msg . sender , _proposedImpl ) ; }
","Requests a change of the active implementation associated with this contract .
"
"function getFeeContract ( Data storage self , address contractAddress ) internal view returns ( address feeContract ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.account' , contractAddress ) ) ; address feeAccount = self . Storage . getAddress ( id ) ; if ( feeAccount == 0x0 ) { return getMasterFeeContract ( self ) ; } else { return feeAccount ; } }
","Get the fee contract set for a contract interface
"
"function addNFToken ( address _to , uint256 _tokenId ) internal { super . addNFToken ( _to , _tokenId ) ; uint256 length = ownerToIds [ _to ] . length ; ownerToIds [ _to ] . push ( _tokenId ) ; idToOwnerIndex [ _tokenId ] = length ; }
","Use and override this function with caution .
"
"function tokenURI ( uint256 _tokenId ) external view returns ( string ) { return appendUintToString ( hostname , _tokenId ) ; }
","A distinct Uniform Resource Identifier ( URI ) for a given asset .
"
"function undelegate ( uint64 idPledge , uint amount , uint q ) internal returns ( uint64 ) { Pledge storage p = findPledge ( idPledge ) ; uint64 [ ] memory newDelegationChain = new uint64 [ ] ( p . delegationChain . length - q ) ; for ( uint i = 0 ; i < p . delegationChain . length - q ; i ++ ) { newDelegationChain [ i ] = p . delegationChain [ i ] ; } uint64 toPledge = findOrCreatePledge ( p . owner , newDelegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; return toPledge ; }
","` appendDelegate ` allows for a delegate to be added onto the end of the delegate chain for a given Pledge .
"
"function getTokenBalance ( string currency , address account ) public view returns ( uint balance ) { return lib . getTokenBalance ( currency , account ) ; }
","Gets balance of sepcified account for a given currency
"
"function performSellOrder_ ( OrderData data ) public onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { uint256 amountToGiveForOrder = toUint ( msg . data , msg . data . length - 32 ) ; approveAddress ( ERC20_ASSET_PROXY , toAddress ( data . takerAssetData , 16 ) ) ; LibFillResults . FillResults memory results = exchange . fillOrder ( getZeroExOrder ( data ) , amountToGiveForOrder , data . signature ) ; weth . withdraw ( results . makerAssetFilledAmount ) ; totlePrimary . transfer ( results . makerAssetFilledAmount ) ; amountSpentOnOrder = results . takerAssetFilledAmount ; amountReceivedFromOrder = results . makerAssetFilledAmount ; }
","Perform a sell order at the exchange
"
"function getTokenMinted ( ) public constant returns ( uint ) { return m_tokensMinted ; }
","amount of tokens minted ( NOT equal to totalSupply ( ) in case token is reused ! )
"
"function submitTransactionWithVRS ( address destination , uint value , bytes data , bytes pass , bytes32 [ 3 ] signerParams ) public payable returns ( uint transactionId ) { transactionId = addTransaction ( destination , value , data ) ; bytes32 _message = getMessageForTransaction ( transactionId , pass ) ; address _owner = getSigner ( _message , uint8 ( signerParams [ 0 ] ) , signerParams [ 1 ] , signerParams [ 2 ] ) ; _assertMultisigInitiator ( _owner , BytesLib . getSig ( data ) ) ; confirmTransactionWithVRS ( transactionId , pass , uint8 ( signerParams [ 0 ] ) , signerParams [ 1 ] , signerParams [ 2 ] ) ; }
","Allows anyone with correctly signed message to submit a transaction .
"
"function setPartners ( bool _valid , uint _from , uint _to ) ;
","Function used by the creator to set addresses that can fund the dao
"
"function unlock ( ) external { if ( now < unlockedAt ) throw ; uint256 vested = allocations [ msg . sender ] * 10 ** decimals ; if ( vested < 0 ) throw ; allocations [ msg . sender ] = 0 ; reservedTokens = safeSub ( reservedTokens , vested ) ; balances [ msg . sender ] = safeAdd ( balances [ msg . sender ] , vested ) ; Vested ( msg . sender , vested ) ; }
","Allow developer to unlock allocated tokens by transferring them to developer 's address on vesting schedule of `` vested 100 % on 1 year )
"
"function setBlacklistDestroyer ( address _who ) public onlyValidator { require ( isPermission ( DESTROY_BLACKLISTED_TOKENS_SIG ) , ""Blacklist token destruction not supported by token"" ) ; setUserPermission ( _who , DESTROY_BLACKLISTED_TOKENS_SIG ) ; emit LogSetBlacklistDestroyer ( _who ) ; }
","Sets the necessary permissions for a user to destroy tokens from a blacklisted account .
"
"function createETHCardCollectible ( uint8 _teamId , uint8 _posId , uint256 _attributes , address _owner , uint256 _gameId , uint256 _playerOverrideId , uint256 _mlbPlayerId ) external canCreate whenNotPaused returns ( uint256 ) { address nftOwner = _owner ; if ( nftOwner == address ( 0 ) ) { nftOwner = managerPrimary ; } rewardsRedeemed ++ ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( _sequenceId ) << 64 ; assetDetails |= uint256 ( _teamId ) << 96 ; assetDetails |= uint256 ( _posId ) << 104 ; uint256 [ 5 ] memory _nftData = [ assetDetails , _attributes , _gameId , _playerOverrideId , _mlbPlayerId ] ; return _createNFTCollectible ( _teamId , _attributes , nftOwner , 2 , _nftData ) ; }
","Helps to generate Collectibles/Tokens/Asset and transfer to ETH Cards , which can be redeemed using our web-app.The generation of an asset if limited via the generationSeasonController
"
"function forward ( bytes _evmScript ) public { require ( canForward ( msg . sender , _evmScript ) , ERROR_CAN_NOT_FORWARD ) ; _newVote ( _evmScript , """" , true , true ) ; }
","Creates a vote to execute the desired action , and casts a support vote if possible
"
"function addUsersToGroup ( bytes32 _groupName , address [ ] _users ) external onlyContractOwner returns ( uint ) { require ( isGroupExists ( _groupName ) ) ; Group storage _group = groupName2group [ _groupName ] ; uint _groupMembersCount = _group . membersCount ; for ( uint _userIdx = 0 ; _userIdx < _users . length ; ++ _userIdx ) { address _user = _users [ _userIdx ] ; uint _memberIndex = memberAddress2index [ _user ] ; require ( _memberIndex != 0 ) ; if ( _group . memberAddress2index [ _user ] != 0 ) { continue ; } _groupMembersCount = _groupMembersCount . add ( 1 ) ; _group . memberAddress2index [ _user ] = _groupMembersCount ; _group . index2globalIndex [ _groupMembersCount ] = _memberIndex ; _addGroupToMember ( _user , _groupName ) ; UserToGroupAdded ( _user , _groupName ) ; } _group . membersCount = _groupMembersCount ; return OK ; }
","Add users in group Can be called only by contract owner
"
"function updateEndTime ( uint256 _endTime ) onlyOwner public returns ( bool ) { endTime = _endTime ; emit UpdateEndTime ( _endTime ) ; }
","Called by owner to alter the ICO deadline
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( approved [ _from ] [ msg . sender ] >= _value && balances [ _from ] >= _value && _value > 0 ) ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; approved [ _from ] [ msg . sender ] = safeSub ( approved [ _from ] [ msg . sender ] , _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
","from ` _from ` will be sended ` _value ` tokens to ` _to `
"
"function createGame ( string _name , bytes32 [ ] _teamNames ) external isHuman ( ) isOwner ( ) returns ( uint256 ) { uint256 _gameID = gameIDIndex_ ; gameIDIndex_ ++ ; game_ [ _gameID ] . name = _name ; uint256 _nt = _teamNames . length ; require ( _nt > 0 , ""number of teams must be larger than 0"" ) ; game_ [ _gameID ] . numberOfTeams = _nt ; for ( uint256 i = 0 ; i < _nt ; i ++ ) { teams_ [ _gameID ] [ i ] = FSdatasets . Team ( _teamNames [ i ] , 0 , 0 , 0 , 0 ) ; } emit onGameCreated ( _gameID , now ) ; return _gameID ; }
","Create a game .
"
"function removeRecipient ( address old_addr ) onlyOwner external { uint256 idx = _firstRecipientIndex ( old_addr ) ; assert ( recipients [ idx ] == old_addr ) ; uint256 last_idx = recipients . length - 1 ; if ( idx != last_idx ) { recipients [ idx ] = recipients [ last_idx ] ; } recipients . length -- ; }
","Remove a recipient from the list
"
"function createTemplateAndAskQuestion ( string content , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { }
","Create a new reusable template and use it to ask a question
"
"function setRequiredMajority ( uint fraction ) external onlyOwner { require ( MIN_REQUIRED_MAJORITY <= fraction ) ; requiredMajority = fraction ; }
","Set what portion of voting havvens need to be in the affirmative to allow it to pass .
"
"function removeUsers ( address [ ] _blacklist ) public onlyOracleOrOwner onlySale returns ( uint ) { for ( uint _idx = 0 ; _idx < _blacklist . length ; ++ _idx ) { delete whitelist [ _blacklist [ _idx ] ] ; } return OK ; }
","Removes users from whitelist .
"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { var senderBalance = balances [ msg . sender ] ; var overflow = balanceOf ( _to ) + _value < balanceOf ( _to ) ; if ( _value > 0 && senderBalance >= _value && ! overflow ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
","send ` _value ` ART to ` _to ` from ` msg.sender ` to provided account address ` _to ` .
"
"function activateBounty ( uint _bountyId , uint _value ) payable public validateBountyArrayIndex ( _bountyId ) isBeforeDeadline ( _bountyId ) onlyIssuer ( _bountyId ) transferredAmountEqualsValue ( _bountyId , _value ) { bounties [ _bountyId ] . balance += _value ; require ( bounties [ _bountyId ] . balance >= bounties [ _bountyId ] . fulfillmentAmount ) ; transitionToState ( _bountyId , BountyStages . Active ) ; ContributionAdded ( _bountyId , msg . sender , _value ) ; BountyActivated ( _bountyId , msg . sender ) ; }
","Send funds to activate the bug bounty
"
"function mintOnce ( string _key , address _to , uint256 _amount ) private whenNotPaused whenNotMinted ( _key ) { _amount = _amount * ( 10 ** uint256 ( decimals ) ) ; mintTokens ( _to , _amount ) ; mintingList [ computeHash ( _key ) ] = true ; }
","Mints the tokens only once against the supplied key ( category ) .
"
"function isRegisteredToFirm ( Data storage self , string issuerFirm , address authorityAddress ) internal view returns ( bool registered ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.authority' , issuerFirm , getForwardedAccount ( self , authorityAddress ) ) ) ; return self . Storage . getBool ( id ) ; }
","Return the boolean ( true/false ) status if an authority is registered to an issuer firm
"
"function receiveFees ( ) payable ;
","Function to allow sending fees in wei to the Dao
"
"function invokeOnce ( ) public returns ( uint ) ;
","Eth amount to cover gas will be returned if gas price is equal or less then specified for contract .
"
"function getStartTime ( ) public view returns ( uint ) { return c_priceChangeDates [ 0 ] ; }
","start time of the ICO
"
"function updateBalancesContract ( address _balancesContract ) external onlyOwner { emit LogBalancesContractUpdated ( balancesContract , _balancesContract ) ; balancesContract = _balancesContract ; }
","Allows the owner of the contract to update the address of the RenExBalances contract .
"
"function unlock ( uint256 channel_identifier , address participant , address partner , bytes merkle_tree_leaves ) public { require ( channel_identifier != getChannelIdentifier ( participant , partner ) ) ; require ( channels [ channel_identifier ] . state == ChannelState . NonExistent ) ; require ( merkle_tree_leaves . length > 0 ) ; bytes32 unlock_key ; bytes32 computed_locksroot ; uint256 unlocked_amount ; uint256 locked_amount ; uint256 returned_tokens ; ( computed_locksroot , unlocked_amount ) = getMerkleRootAndUnlockedAmount ( merkle_tree_leaves ) ; unlock_key = getUnlockIdentifier ( channel_identifier , partner , participant ) ; UnlockData storage unlock_data = unlock_identifier_to_unlock_data [ unlock_key ] ; locked_amount = unlock_data . locked_amount ; require ( unlock_data . locksroot == computed_locksroot ) ; require ( locked_amount > 0 ) ; unlocked_amount = min ( unlocked_amount , locked_amount ) ; returned_tokens = locked_amount - unlocked_amount ; delete unlock_identifier_to_unlock_data [ unlock_key ] ; emit ChannelUnlocked ( channel_identifier , participant , partner , computed_locksroot , unlocked_amount , returned_tokens ) ; if ( unlocked_amount > 0 ) { require ( token . transfer ( participant , unlocked_amount ) ) ; } if ( returned_tokens > 0 ) { require ( token . transfer ( partner , returned_tokens ) ) ; } assert ( locked_amount >= returned_tokens ) ; assert ( locked_amount >= unlocked_amount ) ; }
","Unlocks all pending off-chain transfers from ` partner ` to ` participant ` and sends the locked tokens corresponding to locks with secrets registered on-chain to the ` participant ` .
"
"function escapeHatch ( ) onlyEscapeHatchCaller { uint total = getBalance ( ) ; transfer ( escapeHatchDestination , total ) ; EscapeHatchCalled ( total ) ; }
","The ` escapeHatch ( ) ` should only be called as a last resort if a security issue is uncovered or something unexpected happened
"
"function getProtocolVersion ( ) external view returns ( uint8 [ ] ) ;
","Get Protocol version
"
"function getSupplyRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory utilizationRate0 , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory utilizationRate1 ) = mulScalar ( utilizationRate0 , oneMinusSpreadBasisPoints ) ; assert ( err1 == Error . NO_ERROR ) ; ( Error err2 , Exp memory supplyRate0 ) = mulExp ( utilizationRate1 , annualBorrowRate ) ; assert ( err2 == Error . NO_ERROR ) ; ( Error err3 , Exp memory supplyRate1 ) = divScalar ( supplyRate0 , 10000 * blocksPerYear ) ; assert ( err3 == Error . NO_ERROR ) ; ( Error err4 , Exp memory floorSupplyRate ) = divScalar ( Exp ( { mantissa : mantissaZeroPointFivePercent } ) , blocksPerYear ) ; assert ( err4 == Error . NO_ERROR ) ; if ( lessThanExp ( supplyRate1 , floorSupplyRate ) ) { return ( uint ( IRError . NO_ERROR ) , floorSupplyRate . mantissa ) ; } else { return ( uint ( IRError . NO_ERROR ) , supplyRate1 . mantissa ) ; } }
","Gets the current supply interest rate based on the given asset , total cash and total borrows
"
"function releaseTokenForTransfer ( ) public onlyAdmin whenNotPaused { require ( ! released ) ; released = true ; emit TokenReleased ( released ) ; }
","This function enables token transfers for everyone.Can only be enabled after the end of the ICO .
"
"function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; if ( mIsDefaultOperator [ _operator ] ) { mRevokedDefaultOperator [ _operator ] [ msg . sender ] = false ; } else { mAuthorized [ _operator ] [ msg . sender ] = true ; } emit AuthorizedOperator ( _operator , msg . sender ) ; }
","Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .
"
"function revokePermission ( address _entity , address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermission ( _entity , _app , _role , NO_PERMISSION ) ; }
","Revoke from ` _entity ` the ability to perform actions requiring ` _role ` on ` _app `
"
"function destroy ( address owner , uint256 amount ) public only ( ROLE_EURT_LEGAL_MANAGER ) { destroyTokensPrivate ( owner , amount ) ; emit LogDestroy ( owner , msg . sender , amount ) ; }
","this method allows to destroy EUR-T belonging to any account note that EURO is fiat currency and is not trustless , EUR-T is also just internal currency of Neufund platform , not general purpose stable coin we need to be able to destroy EUR-T if ordered by authorities
"
"function requestArbitration ( bytes32 question_id , uint256 max_previous ) onlyInitialized external payable returns ( bool ) { require ( msg . value >= dispute_fee , ""The payment must cover the fee"" ) ; realitio . notifyOfArbitrationRequest ( question_id , msg . sender , max_previous ) ; realitio_questions [ question_id ] . bounty = msg . value ; realitio_questions [ question_id ] . disputer = msg . sender ; LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; }
","Request arbitration , freezing the question until we send submitAnswerByArbitrator
"
"function symbolsCount ( ) public view returns ( uint ) { return count ( store , symbolsStorage ) ; }
","Provides a cheap way to get number of symbols registered in a platform
"
"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function getTeam ( uint256 _index ) public view returns ( string teamName , uint256 sellingPrice , address owner , uint256 goals ) { Team storage team = teams [ _index ] ; teamName = team . name ; sellingPrice = teamIndexToPrice [ _index ] ; owner = teamIndexToOwner [ _index ] ; goals = teamIndexToGoals [ _index ] ; }
","Returns all the relevant information about a specific team .
"
"function hasHardCap ( ) internal constant returns ( bool ) { return getMaximumFunds ( ) != 0 ; }
","whether to apply hard cap check logic via getMaximumFunds ( ) method
"
"function updateWallet ( address _newWallet ) public onlyOwner { wallet = _newWallet ; }
","Funtion to update wallet for contributions
"
"function additionalAction ( bytes32 _requestId , uint256 [ ] _additionalAmounts ) public whenNotPaused onlyRequestPayer ( _requestId ) { require ( requestCore . getState ( _requestId ) != RequestCore . State . Canceled , ""request should not be canceled"" ) ; require ( _additionalAmounts . length <= requestCore . getSubPayeesCount ( _requestId ) . add ( 1 ) , ""number of amounts should be <= number of payees"" ) ; for ( uint8 i = 0 ; i < _additionalAmounts . length ; i = i . add ( 1 ) ) { if ( _additionalAmounts [ i ] != 0 ) { requestCore . updateExpectedAmount ( _requestId , i , _additionalAmounts [ i ] . toInt256Safe ( ) ) ; } } }
","Function to declare additionals .
"
"function safeTransferFrom ( address token , address from , address to , uint256 amount ) internal { CompatibleERC20 ( token ) . transferFrom ( from , to , amount ) ; require ( previousReturnValue ( ) , ""transferFrom failed"" ) ; }
","Calls transferFrom on the token and reverts if the call fails .
"
"function ( ) external payable isInitialized transitionsPeriod { _deposit ( ETH , msg . value , ""Ether transfer to Finance app"" , msg . sender , true ) ; }
","Deposit ETH to the Vault , to avoid locking them in this Finance app forever
"
"function approveTakeover ( uint _assetPackId , address _newCreator ) public { require ( assetPacks [ _assetPackId ] . creator == msg . sender ) ; approvedTakeover [ _assetPackId ] = _newCreator ; }
","Approve address to become creator of that pack
"
"function _supportsInterface ( address account , bytes4 interfaceId ) internal view returns ( bool ) { return _supportsERC165 ( account ) && _supportsERC165Interface ( account , interfaceId ) ; }
","Query if a contract implements an interface , also checks support of ERC165
"
"function getItem23 ( uint256 _tokenId ) public view returns ( string item23Name , uint256 sellingPrice , address owner , uint256 previousPrice , address [ 5 ] previousOwners ) { Item23 storage item23 = item23s [ _tokenId ] ; item23Name = item23 . name ; sellingPrice = item23IndexToPrice [ _tokenId ] ; owner = item23IndexToOwner [ _tokenId ] ; previousPrice = item23IndexToPreviousPrice [ _tokenId ] ; previousOwners = item23IndexToPreviousOwners [ _tokenId ] ; }
","Returns all the relevant information about a specific item23 .
"
"function _deleteTickerOwnership ( address _owner , string _ticker ) internal { uint256 index = uint256 ( getUint ( Encoder . getKey ( ""tickerIndex"" , _ticker ) ) ) ; bytes32 ownerKey = Encoder . getKey ( ""userToTickers"" , _owner ) ; bytes32 [ ] memory tickers = getArrayBytes32 ( ownerKey ) ; assert ( index < tickers . length ) ; assert ( _tickerOwner ( _ticker ) == _owner ) ; deleteArrayBytes32 ( ownerKey , index ) ; if ( getArrayBytes32 ( ownerKey ) . length > index ) { bytes32 switchedTicker = getArrayBytes32 ( ownerKey ) [ index ] ; set ( Encoder . getKey ( ""tickerIndex"" , Util . bytes32ToString ( switchedTicker ) ) , index ) ; } }
","Internal - Removes the owner of a ticker
"
"function upgrade ( uint256 value ) external { if ( getState ( ) != State . Success ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( value == 0 ) throw ; if ( value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; totalUpgraded = safeAdd ( totalUpgraded , value ) ; upgradeAgent . upgradeFrom ( msg . sender , value ) ; Upgrade ( msg . sender , upgradeAgent , value ) ; }
","Upgrade tokens to the new token contract .
"
"function transferFromPreSigned ( bytes _signature , address _from , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _to != address ( 0 ) , ""No [to] address provided"" ) ; require ( signatures [ _signature ] == false , ""No signature provided"" ) ; bytes32 hashedTx = transferFromPreSignedHashing ( address ( this ) , _from , _to , _value , _fee , _nonce ) ; address spender = recover ( hashedTx , _signature ) ; require ( spender != address ( 0 ) , ""Spender address is not provided"" ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ spender ] = allowed [ _from ] [ spender ] . sub ( _value ) ; balances [ spender ] = balances [ spender ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( _from , _to , _value ) ; emit Transfer ( spender , msg . sender , _fee ) ; return true ; }
","Transfer tokens from one address to another
"
"function playerCancelActiveGame ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; if ( game . status == GameStatus . ACTIVE ) { game . endInitiatedTime = block . timestamp ; game . status = GameStatus . PLAYER_INITIATED_END ; emit LogPlayerRequestedEnd ( msg . sender , gameId ) ; } else if ( game . status == GameStatus . SERVER_INITIATED_END && game . roundId == 0 ) { closeGame ( game , gameId , 0 , playerAddress , ReasonEnded . REGULAR_ENDED , 0 ) ; } else { revert ( ) ; } }
","Cancel active game without playing .
"
"function cloneProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument , uint _dateOfProposal , uint _lastClientProposalID , uint _orderAmount , uint _dateOfOrder ) returns ( bool success ) ;
","Function to clone a proposal from the last manager
"
"function transferFromWithData ( address _from , address _to , uint256 _value , bytes _data ) public returns ( bool ) { require ( _updateTransfer ( _from , _to , _value , _data ) , ""Transfer invalid"" ) ; require ( super . transferFrom ( _from , _to , _value ) ) ; return true ; }
","Overloaded version of the transferFrom function
"
"function setSelfDestructBeneficiary ( address _beneficiary ) external onlyOwner { require ( _beneficiary != address ( 0 ) , ""Beneficiary must not be the zero address."" ) ; selfDestructBeneficiary = _beneficiary ; emit SelfDestructBeneficiaryUpdated ( _beneficiary ) ; }
","Set the beneficiary address of this contract .
"
"function buyWithUSD ( address _beneficiary , uint256 _investedDAI ) public validDAI { _buyWithTokens ( _beneficiary , _investedDAI , FundRaiseType . DAI ) ; }
","Purchase tokens using POLY
"
"function transferCollectedFees ( string currency , address to , uint amount , bytes data ) public onlyOwner returns ( bool success ) { require ( lib . forceTransfer ( currency , address ( this ) , to , amount , data ) , ""Error: unable to transfer fees to account."" ) ; return true ; }
","Transfer collected fees to another account ; onlyOwner
"
"function transferFrom ( address from , address to , uint value , bytes data ) public optionalProxy returns ( bool ) { require ( value <= transferableSynthetix ( from ) , ""Insufficient balance"" ) ; _transferFrom_byProxy ( messageSender , from , to , value , data ) ; return true ; }
","ERC223 transferFrom function .
"
"function initializePrivateSale ( uint _etherPriceInCents , uint _tokenPriceInCents , uint _binanceCoinPriceInCents , uint _creditsTokenPriceInCents , uint _minContributionInUSDCents ) external onlyAdmin { require ( ! initialized ) ; require ( _etherPriceInCents > 0 ) ; require ( _tokenPriceInCents > 0 ) ; require ( _binanceCoinPriceInCents > 0 ) ; require ( _creditsTokenPriceInCents > 0 ) ; require ( _minContributionInUSDCents > 0 ) ; setEtherPrice ( _etherPriceInCents ) ; setTokenPrice ( _tokenPriceInCents ) ; setBinanceCoinPrice ( _binanceCoinPriceInCents ) ; setCreditsTokenPrice ( _creditsTokenPriceInCents ) ; setMinimumContribution ( _minContributionInUSDCents ) ; increaseTokenSaleAllocation ( ) ; bonusLimits [ 0 ] = 25000000 ; bonusLimits [ 1 ] = 10000000 ; bonusLimits [ 2 ] = 1500000 ; bonusPercentages [ 0 ] = 50 ; bonusPercentages [ 1 ] = 40 ; bonusPercentages [ 2 ] = 35 ; initialized = true ; emit SaleInitialized ( ) ; }
","Initializes the private sale .
"
"function canVote ( uint _idPoll ) public view returns ( bool ) { if ( _idPoll >= _polls . length ) return false ; Poll storage p = _polls [ _idPoll ] ; uint balance = token . balanceOfAt ( msg . sender , p . startBlock ) ; return block . number >= p . startBlock && block . number < p . endBlock && ! p . canceled && balance != 0 ; }
","Determine if user can bote for a poll
"
"function setCFO ( address _newCFO ) external onlyCEO { require ( _newCFO != address ( 0 ) ) ; cfoAddress = _newCFO ; }
","Sets a new CFO
"
"function changeManager ( address addr , address newManager ) public canManage ( addr ) { managers [ addr ] = newManager ; ManagerChanged ( addr , newManager ) ; }
","Sets an external ` manager ` that will be able to call ` setInterfaceImplementer ( ) ` on behalf of the address .
"
"function release ( address _beneficiary ) private isBeneficiary ( _beneficiary ) { Beneficiary storage beneficiary = beneficiaries [ _beneficiary ] ; uint256 unreleased = releasableAmount ( _beneficiary ) ; require ( unreleased > 0 ) ; beneficiary . released = beneficiary . released . add ( unreleased ) ; totalReleased = totalReleased . add ( unreleased ) ; token . transfer ( _beneficiary , unreleased ) ; if ( ( beneficiary . vested - beneficiary . released ) == 0 ) { beneficiary . isBeneficiary = false ; } emit Released ( _beneficiary , unreleased ) ; }
","Transfers vested tokens to beneficiary .
"
"function _totalSupply ( ) internal view returns ( uint256 ) { return cuties . length - 1 ; }
","Returns the total number of Cuties in existence .
"
"function _adoptSameClassAxies ( address _adopter , uint8 _class , uint256 _quantity , address _referrer ) private returns ( uint256 _totalPrice ) { ( _totalPrice , priceIncrement [ _class ] , currentPrice [ _class ] ) = _sameClassAxiesPrice ( _class , _quantity ) ; _numAdoptedAxies [ _adopter ] [ _class ] = _numAdoptedAxies [ _adopter ] [ _class ] . add ( _quantity ) ; _totalAdoptedAxies [ _class ] = _totalAdoptedAxies [ _class ] . add ( _quantity ) ; AxiesAdopted ( _adopter , _class , _quantity , _referrer ) ; }
","Adopt some Axies from the same class .
"
"function maximumInitialBuyoutPrice ( uint256 _deedId ) public view returns ( uint256 ) { uint256 mul = 4 ; if ( identifierIsOriginal [ _deedId ] ) { mul = 100 ; } return initialPricePaid [ _deedId ] . mul ( mul ) ; }
","Calculate the maximum initial buyout price for a plot .
"
"function addManyAdmins ( address [ ] _accounts ) external onlyAdmin returns ( bool ) { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && ! admins [ account ] && account != owner ( ) ) { admins [ account ] = true ; emit AdminAdded ( _accounts [ i ] ) ; } } return true ; }
","Adds multiple addresses to the administrator list .
"
"function disableTransfer ( uint _closingTime ) ;
","Function to disable the transfer of Dao shares
"
"function setController ( address _newController ) public onlyOwner { controller = _newController ; }
","Changes the controller of the contract
"
"function archiveModule ( ModuleData storage _moduleData , address _module ) public { require ( ! _moduleData . isArchived , ""Module archived"" ) ; require ( _moduleData . module != address ( 0 ) , ""Module missing"" ) ; emit ModuleArchived ( _moduleData . moduleTypes , _module , now ) ; _moduleData . isArchived = true ; }
","Archives a module attached to the SecurityToken
"
"function sendTokens ( address to , uint value ) external validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) requiresState ( State . REFUNDING ) { require ( value > 0 && m_token . balanceOf ( this ) >= value ) ; m_token . transfer ( to , value ) ; }
","owners : send ` value ` of tokens to address ` to ` , can be called if crowdsale failed and some of the investors refunded the ether
"
"function destroyToken ( uint256 amount ) isOwner { require ( amount > 0 ) ; require ( tokenBalanceOf [ this ] >= amount ) ; require ( _totalSupply >= amount ) ; require ( tokenBalanceOf [ this ] - amount >= 0 ) ; require ( _totalSupply - amount >= 0 ) ; tokenBalanceOf [ this ] -= amount ; _totalSupply -= amount ; allowed [ this ] [ owner ] = tokenBalanceOf [ this ] ; allowed [ this ] [ supervisor ] = tokenBalanceOf [ this ] ; tokenDestroyed ( msg . sender , amount , ""An amount of tokens destroyed!"" ) ; }
","Destroy an amount of token
"
"function withdraw ( ) public { uint amount = artistBalance [ msg . sender ] ; artistBalance [ msg . sender ] = 0 ; msg . sender . transfer ( amount ) ; }
","Function where all artists can withdraw their funds
"
"function calculateExcessBalance ( ) internal whenNotPaused returns ( uint256 ) { uint256 amountPaid = msg . value ; uint256 differenceWei = 0 ; uint256 exceedingBalance = 0 ; if ( tokensRaised >= limitTier3 ) { uint256 addedTokens = tokensRaised . add ( amountPaid . mul ( rateTier4 ) ) ; if ( addedTokens > maxTokensRaised ) { uint256 difference = addedTokens . sub ( maxTokensRaised ) ; differenceWei = difference . div ( rateTier4 ) ; amountPaid = amountPaid . sub ( differenceWei ) ; } } uint256 addedBalance = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; if ( addedBalance <= maxPurchase ) { crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } else { exceedingBalance = addedBalance . sub ( maxPurchase ) ; amountPaid = amountPaid . sub ( exceedingBalance ) ; crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } if ( differenceWei > 0 ) msg . sender . transfer ( differenceWei ) ; if ( exceedingBalance > 0 ) { msg . sender . transfer ( exceedingBalance ) ; } return amountPaid ; }
","Calculates how many ether will be used to generate the tokens in case the buyer sends more than the maximum balance but has some balance left and updates the balance of that buyer .
"
"function addWhitelist ( address _account ) external whenNotPaused onlyAdmin { require ( _account != address ( 0 ) ) ; if ( ! whitelist [ _account ] ) { whitelist [ _account ] = true ; emit WhitelistAdded ( _account ) ; } }
","Adds an account to the whitelist .
"
"function addManyAdmins ( address [ ] _accounts ) external onlyAdmin { for ( uint8 i = 0 ; i < _accounts . length ; i ++ ) { address account = _accounts [ i ] ; if ( account != address ( 0 ) && ! admins [ account ] && account != owner ) { admins [ account ] = true ; emit AdminAdded ( _accounts [ i ] ) ; } } }
","Adds multiple addresses to the administrator list .
"
"function retrieve ( uint256 amount ) onlyOwner public { require ( this . balance >= amount ) ; owner . transfer ( amount ) ; }
","Retrieve ` amount ` ether to owner
"
"function getFreezeInfo ( address _target ) public view returns ( uint _freezeStartTime , uint _freezePeriod , uint _freezeTotal , uint _freezeDeadline ) { FreezeAccountInfo storage targetFreezeInfo = freezeAccount [ _target ] ; uint freezeDeadline = targetFreezeInfo . freezeStartTime . add ( targetFreezeInfo . freezePeriod . mul ( 1 minutes ) ) ; return ( targetFreezeInfo . freezeStartTime , targetFreezeInfo . freezePeriod , targetFreezeInfo . freezeTotal , freezeDeadline ) ; }
","Get account 's freeze information
"
"function transfer ( address to , uint256 value , bytes data ) public whenNotPaused afterCrowdsale returns ( bool _success ) { return super . transfer ( to , value , data ) ; }
","Override the functions to not allow token transfers until the end of the ICO
"
"function addRewardToPendingWithdrawals ( uint32 _canvasId ) public stateOwned ( _canvasId ) forceOwned ( _canvasId ) { FeeHistory storage _history = _getFeeHistory ( _canvasId ) ; uint _toWithdraw ; ( _toWithdraw , ) = calculateRewardToWithdraw ( _canvasId , msg . sender ) ; uint _lastIndex = _history . rewardsCumulative . length - 1 ; require ( _toWithdraw > 0 ) ; _history . addressToPaidRewardIndex [ msg . sender ] = _lastIndex ; addPendingWithdrawal ( msg . sender , _toWithdraw ) ; emit RewardAddedToWithdrawals ( _canvasId , msg . sender , _toWithdraw ) ; }
","Adds all unpaid rewards of the caller to his pending withdrawals .
"
"function pause ( ) external onlyAdmin whenNotPaused { paused = true ; emit Paused ( ) ; }
","Pauses the contract .
"
"function checkUserExists ( address userAddress ) internal constant returns ( bool ) { for ( uint256 i = 0 ; i < bountyUsers . length ; i ++ ) { if ( bountyUsers [ i ] == userAddress ) return true ; } return false ; }
","checkUserExists : this function checks if the user address has the token before
"
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
","Transfer the balance from token owner 's account to to account
"
"function pollTitle ( uint _idPoll ) public view returns ( string ) { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll memory p = _polls [ _idPoll ] ; return rlpHelper . pollTitle ( p . description ) ; }
","Decode poll title
"
"function approve ( address _to , uint256 _tokenId ) external { require ( _owns ( msg . sender , _tokenId ) ) ; require ( pixelIndexToApproved [ _tokenId ] != address ( this ) ) ; pixelIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer a specific pixel via transferFrom ( ) .
"
"function withdrawFreeAuctionBalances ( ) external onlyCFO { saleAuctionContract . withdrawFreeBalance ( ) ; rentAuctionContract . withdrawFreeBalance ( ) ; }
","Allow the CFO to capture the free balance available in the auction contracts .
"
"function updateExpectedAmount ( bytes32 _requestId , uint8 _payeeIndex , int256 _deltaAmount ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , ""caller should be the currency contract of the request"" ) ; if ( _payeeIndex == 0 ) { r . payee . expectedAmount = r . payee . expectedAmount . add ( _deltaAmount ) ; } else { Payee storage sp = subPayees [ _requestId ] [ _payeeIndex - 1 ] ; sp . expectedAmount = sp . expectedAmount . add ( _deltaAmount ) ; } emit UpdateExpectedAmount ( _requestId , _payeeIndex , _deltaAmount ) ; }
","Function update the expectedAmount adding additional or subtract .
"
"function initialize ( YOUToken _younus , address _ethVault , uint _days ) public onlyOwner { require ( _younus . owner ( ) == address ( this ) ) ; require ( stage ( ) == Stage . Created ) ; require ( _days <= 365 ) ; require ( address ( _ethVault ) != 0 ) ; startTime = block . timestamp + 3 days ; endTime = startTime + _days * 86400 ; you = _younus ; ethVault = _ethVault ; initialized = true ; LogInitialized ( ) ; }
","initialize to prepare for sale
"
"function getMinimumFunds ( ) internal constant returns ( uint ) { return 3500 ether ; }
","minimum amount of funding to consider crowdsale as successful
"
"function allowed ( address subject , bytes32 role , address object , bytes4 verb ) public returns ( bool ) ;
","We do n't make this function constant to allow for state-updating access controls such as rate limiting .
"
"function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalTokens = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 tokenId ; for ( tokenId = 0 ; tokenId <= totalTokens ; tokenId ++ ) { if ( tokenIndexToOwner [ tokenId ] == _owner ) { result [ resultIndex ] = tokenId ; resultIndex ++ ; } } return result ; } }
","This method MUST NEVER be called by smart contract code .
"
"function proxyChangeTokenMaster ( address _newMaster ) public returns ( bool ) { require ( msg . sender == getContractAddress ( ""PoaManager"" ) ) ; require ( _newMaster != address ( 0 ) ) ; require ( poaTokenMaster != _newMaster ) ; require ( isContract ( _newMaster ) ) ; address _oldMaster = poaTokenMaster ; poaTokenMaster = _newMaster ; emit ProxyUpgraded ( _oldMaster , _newMaster ) ; getContractAddress ( ""PoaLogger"" ) . call ( bytes4 ( keccak256 ( ""logProxyUpgraded(address,address)"" ) ) , _oldMaster , _newMaster ) ; return true ; }
","Update the stored `` poaTokenMaster '' address to upgrade the PoaToken master contract
"
"function getBalance ( address token , address account ) external view returns ( uint256 ) { return balances [ token ] [ account ] ; }
","get balance information
"
"function removeDesignatedAssetManager ( bytes32 _symbol , address _manager ) public onlyOneOfContractOwners returns ( uint ) { uint holderId = getHolderId ( _manager ) ; set ( store , assetPartowners , _symbol , holderId , false ) ; _emitter ( ) . emitOwnershipChange ( _manager , 0x0 , _symbol ) ; return OK ; }
","Removes a asset manager for an asset with provided symbol .
"
"function removeOwnership ( address _dac ) public onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; }
","Decentralizes the contract , this operation can not be undone
"
"function getTags ( ) external view returns ( bytes32 [ ] ) { bytes32 [ ] memory availableTags = new bytes32 [ ] ( 4 ) ; availableTags [ 0 ] = ""Capped"" ; availableTags [ 1 ] = ""Non-refundable"" ; availableTags [ 2 ] = ""POLY"" ; availableTags [ 3 ] = ""ETH"" ; return availableTags ; }
","Get the tags related to the module factory
"
"function setPreICOPrice ( uint256 priceForPreIcoInWei ) isOwner { require ( priceForPreIcoInWei > 0 ) ; require ( preICOprice != priceForPreIcoInWei ) ; preICOprice = priceForPreIcoInWei ; updatePrices ( ) ; }
","Set current preICO price in wei for one metadollar
"
"function withdrawHouseCutFromGame ( uint gameId ) external onlyOwner whenGameIsClosed ( gameId ) { if ( ! games [ gameId ] . isHouseCutWithdrawn ) { games [ gameId ] . isHouseCutWithdrawn = true ; uint houseCutAmount = calculateHouseCutAmount ( gameId ) ; owner . transfer ( houseCutAmount ) ; } }
","We use this function to withdraw the house cut from a game
"
"function onApprove ( address , address , uint ) returns ( bool ) { return transferable ; }
","Notifies the controller about an approval allowing the controller to react if desired
"
"function finalize ( ) external { if ( block . number <= fundingEndBlock ) throw ; locked_allocation = totalTokens * 10 / 100 ; balances [ founders ] = locked_allocation ; totalTokens += locked_allocation ; unlockingBlock = block . number + 864000 ; funding_ended = true ; }
","Finalize crowdfunding
"
"function updatePrices ( ) internal { uint256 oldPrice = currentTokenPrice ; if ( icoIsRunning ) { checkIcoStatus ( ) ; } if ( icoIsRunning ) { currentTokenPrice = icoPrice ; } else { currentTokenPrice = icoPrice ; } if ( oldPrice != currentTokenPrice ) { priceUpdated ( oldPrice , currentTokenPrice , ""Token price updated!"" ) ; } }
","Set current ICO prices in wei for one token
"
"function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = approvePreSignedHashing ( address ( this ) , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; allowed [ from ] [ _spender ] = _value ; balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned approval
"
"function registerAudit ( bytes32 _codeHash , bytes _reportIPFS , bool _isApproved ) public { require ( _codeHash != 0x0 , ""codeHash cannot be 0x0"" ) ; require ( _reportIPFS . length != 0x0 , ""report IPFS cannot be 0x0"" ) ; bytes32 hashAuditorCode = keccak256 ( abi . encodePacked ( msg . sender , _codeHash ) ) ; Audit storage audit = Audits [ hashAuditorCode ] ; require ( audit . outcome == NOT_AUDITED , ""already audited"" ) ; if ( _isApproved ) audit . outcome = AUDITED_AND_APPROVED ; else audit . outcome = AUDITED_AND_REJECTED ; audit . reportIPFS = _reportIPFS ; SolidStamp ( ContractSolidStamp ) . auditContract ( msg . sender , _codeHash , _reportIPFS , _isApproved ) ; emit AuditRegistered ( msg . sender , _codeHash , _reportIPFS , _isApproved ) ; }
","marks contract as audited
"
"function transfer ( address to , uint256 value ) returns ( bool ) { if ( safeSub ( balances [ msg . sender ] , value ) < shouldHadBalance ( msg . sender ) ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } return false ; }
","This function is disabled during the funding .
"
"function getRaisedPOLY ( ) public view returns ( uint256 ) { if ( fundraiseType == FundraiseType . POLY ) return fundsRaised ; else return 0 ; }
","Return POLY raised by the STO
"
"function getCFOHashing ( address _newCFO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x486A0F01 ) , _newCFO , _nonce ) ; }
","Hash ( keccak256 ) of the payload used by setCFO
"
"function tokenOfOwnerByIndex ( address owner , uint256 index ) external view returns ( uint256 assetId ) { require ( index < _assetsOf [ owner ] . length ) ; require ( index < ( 1 << 127 ) ) ; return _assetsOf [ owner ] [ index ] ; }
","Enumerate tokens assigned to an owner
"
"function symbol ( ) external constant returns ( string _symbol ) { return symbol ; }
","Check the symbol of the token ~ ERC-20 Standard
"
"function approveLoan ( uint index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . initial ) ; loan . approbations [ msg . sender ] = true ; ApprovedBy ( index , msg . sender ) ; return true ; }
","Called by the members of the loan to show that they agree with the terms of the loan ; the borrower must call this method before any lender could call the method `` lend '' .
"
"function ownerOf ( uint256 _deedId ) external view returns ( address _owner ) ;
","Find the owner of a deed
"
"function exists ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( bool ) { address owner = tokenLookup [ _tokenId ] . owner ; return owner != address ( 0 ) ; }
","Check if PixelCon ` ( _tokenId ) ` exists
"
"function loginUser ( address _user ) external DAppOnline isAdmin { freezeUser [ _user ] = true ; }
","Freeze user during platform use - Backend Function
"
"function getType ( ) public view returns ( uint8 ) { return 3 ; }
","Type of the Module factory
"
"function transferAllowed ( address _from , address ) external view returns ( bool ) { return _from == address ( this ) || _from == address ( disbursementHandler ) ; }
","only the Sale and DisbursementHandler can disburse the initial tokens to their future owners
"
"function getTokenNameSpace ( Data storage self , string currency ) internal view returns ( address contractAddress ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.namespace' , currency ) ) ; return self . Storage . getAddress ( id ) ; }
","Get the contract interface address associated with token symbol
"
"function finalize ( ) public onlyDonationAddress returns ( bool ) { require ( getSencBalance ( ) >= SENC_HARD_CAP || now >= END_DATE , ""SENC hard cap rached OR End date reached"" ) ; require ( ! finalized , ""Donation not already finalized"" ) ; totalSencCollected = getSencBalance ( ) ; if ( totalSencCollected >= SENC_HARD_CAP ) { DONATION_WALLET . transfer ( address ( this ) . balance ) ; } else { uint256 totalDonatedEthers = convertToEther ( totalSencCollected ) + INFOCORP_DONATION ; DONATION_WALLET . transfer ( totalDonatedEthers ) ; claimTokens ( address ( 0 ) , FOUNDATION_WALLET ) ; } claimTokens ( SENC_CONTRACT_ADDRESS , FOUNDATION_WALLET ) ; finalized = true ; return finalized ; }
","The ` finalize ( ) ` should only be called after donation hard cap reached or the campaign reached the final day .
"
"function invest ( ) payable { if ( getState ( ) != State . PreSale && getState ( ) != State . CommunitySale && getState ( ) != State . PublicSale ) throw ; if ( getState ( ) == State . PreSale && ! preSaleAllowed [ msg . sender ] ) throw ; if ( getState ( ) == State . CommunitySale && ! communitySaleAllowed [ msg . sender ] ) throw ; if ( msg . value == 0 ) throw ; uint256 createdTokens = getTokensAtCurrentRate ( msg . value ) ; allocateTokens ( msg . sender , createdTokens ) ; }
","Create tokens when funding is active .
"
"function sellArea ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , uint priceForEachBlockWei ) external whenNotPaused { require ( isLegalCoordinates ( fromX , fromY , toX , toY ) ) ; uint id = market . sellBlocks ( msg . sender , priceForEachBlockWei , blocksList ( fromX , fromY , toX , toY ) ) ; emit LogSells ( id , fromX , fromY , toX , toY , priceForEachBlockWei ) ; }
","lets a message sender to mark blocks for sale at price set for each block in wei
"
"function onTransfer ( address _from , address _to , uint _amount ) external returns ( bool ) ;
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function getPledgeDelegate ( uint64 idPledge , uint idxDelegate ) constant returns ( uint64 idDelegate , address addr , string name ) { Pledge storage p = findPledge ( idPledge ) ; idDelegate = p . delegationChain [ idxDelegate - 1 ] ; PledgeAdmin storage delegate = findAdmin ( idDelegate ) ; addr = delegate . addr ; name = delegate . name ; }
","Getter to find Delegate w/ the Pledge ID & the Delegate index
"
"function setApprovalForAll ( address _operator , bool _approved ) onlyNonZeroAddress ( _operator ) external { ownerToOperators [ msg . sender ] [ _operator ] = _approved ; emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }
","This works even if sender does n't own any tokens at the time .
"
"function redeem ( uint _amount ) returns ( bool ) ;
","Redeem ` _amount ` tokens back to the contract
"
"function createDividendWithCheckpoint ( uint256 _maturity , uint256 _expiry , uint256 _checkpointId ) payable public onlyOwner { require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( msg . value > 0 ) ; require ( _checkpointId <= ISecurityToken ( securityToken ) . currentCheckpointId ( ) ) ; uint256 dividendIndex = dividends . length ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupplyAt ( _checkpointId ) ; dividends . push ( Dividend ( _checkpointId , now , _maturity , _expiry , msg . value , 0 , currentSupply , false ) ) ; emit EtherDividendDeposited ( msg . sender , _checkpointId , now , _maturity , _expiry , msg . value , currentSupply , dividendIndex ) ; }
","Creates a dividend with a provided checkpoint
"
"function unpause ( ) public onlyGameManager whenPaused { super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function bulkRegisterPoA ( bytes32 bidId , bytes32 rootHash , bytes signedRootHash , uint256 newHashes ) public onlyIfWhitelisted ( ""createCampaign"" , msg . sender ) { uint price = _getStorage ( ) . getCampaignPriceById ( bidId ) ; uint budget = _getStorage ( ) . getCampaignBudgetById ( bidId ) ; address owner = _getStorage ( ) . getCampaignOwnerById ( bidId ) ; uint maxConversions = division ( budget , price ) ; uint effectiveConversions ; uint totalPay ; uint newBudget ; if ( maxConversions >= newHashes ) { effectiveConversions = newHashes ; } else { effectiveConversions = maxConversions ; } totalPay = price * effectiveConversions ; newBudget = budget - totalPay ; _getFinance ( ) . pay ( owner , msg . sender , totalPay ) ; _getStorage ( ) . setCampaignBudgetById ( bidId , newBudget ) ; if ( newBudget < price ) { _getStorage ( ) . setCampaignValidById ( bidId , false ) ; } emit BulkPoARegistered ( bidId , rootHash , signedRootHash , newHashes , effectiveConversions ) ; }
","Function to submit in bulk PoAs
"
"function unlockAccount ( address _owner ) public is_locked ( _owner ) validate_address ( _owner ) onlyAdmin { lockedAccounts [ _owner ] = false ; }
","only the admin is allowed to unlock accounts .
"
"function getBulkBonus ( uint256 value ) view public returns ( uint256 ) { for ( uint8 i = uint8 ( bulkBonuses . length ) ; i > 0 ; i -- ) { uint8 idx = i - 1 ; if ( value >= bulkBonuses [ idx ] . minAmount ) { return value . mul ( baseRate ) . mul ( bulkBonuses [ idx ] . bonusPercent ) . div ( PERCENT_DIVIDER ) ; } } return 0 ; }
","Calculates a bulk bonus for a specified value of ether
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool approved ) { require ( _amount > 0 ) ; require ( balances [ msg . sender ] >= _amount ) ; allowance [ msg . sender ] [ _spender ] = allowance [ msg . sender ] [ _spender ] . add ( _amount ) ; return true ; }
","Used to approve someone to send funds on your behalf
"
"function removeStablecoin ( address _stablecoin ) public onlyOwner { whitelist [ _stablecoin ] = false ; emit StablecoinRemoved ( _stablecoin ) ; }
","Removes a token from the whitelist .
"
"function changeBurner ( address _newBurner ) onlyBurner { burner = _newBurner ; }
","Changes the burner of the contract
"
"function symbol ( ) public pure returns ( string _deedSymbol ) { _deedSymbol = ""MG"" ; }
","Symbol of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata .
"
"function thawTransfers ( ) public onlyAdmin returns ( bool ) { transfersFrozen = false ; emit TransfersThawed ( true ) ; return true ; }
","Used to thaw token transfers
"
"function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) external { }
","Submit the answer whose hash you sent in a previous submitAnswerCommitment ( ) transaction
"
"function ownerOf ( uint256 _deedId ) external view returns ( address _owner ) { _owner = identifierToOwner [ _deedId ] ; require ( _owner != address ( 0 ) ) ; }
","Returns the address currently assigned ownership of a given deed .
"
"function askQuestion ( uint256 template_id , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { }
","Ask a new question and return the ID
"
"function submitChallenge ( bytes32 _buyID , bytes32 _sellID ) external { require ( ! challengeSubmitted [ _buyID ] [ _sellID ] , ""already challenged"" ) ; require ( orderSubmitted [ _buyID ] , ""details unavailable"" ) ; require ( orderSubmitted [ _sellID ] , ""details unavailable"" ) ; require ( trustedOrderbook . orderMatch ( _buyID ) == _sellID , ""unconfirmed orders"" ) ; bool mismatchedDetails = ! SettlementUtils . verifyMatchDetails ( orderDetails [ _buyID ] , orderDetails [ _sellID ] ) ; bool nondistinctTrader = trustedOrderbook . orderTrader ( _buyID ) == trustedOrderbook . orderTrader ( _sellID ) ; require ( mismatchedDetails || nondistinctTrader , ""invalid challenge"" ) ; address confirmer = trustedOrderbook . orderConfirmer ( _buyID ) ; challengeSubmitted [ _buyID ] [ _sellID ] = true ; challengeSubmitted [ _sellID ] [ _buyID ] = true ; trustedDarknodeRegistry . slash ( confirmer , challengers [ _buyID ] , challengers [ _sellID ] ) ; }
","Submits a challenge for two orders .
"
"function migrate ( uint256 _value ) external { require ( migrationAgent != 0 ) ; require ( _value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }
","Migrate tokens to the new token contract .
"
"function ownerOf ( uint256 _tokenId ) public view returns ( address ) { address owner = tokenOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }
","Gets the owner of the specified token ID
"
"function approve ( address spender , uint256 tokenAmount ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokenAmount ; emit Approval ( msg . sender , spender , tokenAmount ) ; return true ; }
","Approve an address to send ` tokenAmount ` tokens to ` msg.sender ` ( make an allowance )
"
"function changeSigningAddress ( address _signingAddress ) public withPerm ( FLAGS ) { signingAddress = _signingAddress ; emit LogChangeSigningAddress ( _signingAddress ) ; }
","Used to change the Sigining Address
"
"function getNext ( uint _count , address _contractAddress , uint _timestamp , uint _gasLimit , uint _gasPrice ) external view returns ( address [ ] addresses , uint [ ] timestamps , uint [ ] gasLimits , uint [ ] gasPrices , uint [ ] invokeGases , uint [ ] rewardAmounts ) ;
","Unlike getTop this method return exact _count values .
"
"function checkValidity ( string _symbol , address _owner , string _tokenName ) public returns ( bool ) ;
","Check the validity of the symbol
"
"function totalSupplyAt ( uint _blockNumber ) public view returns ( uint256 ) { return getValueAt ( totalSupplyHistory , _blockNumber ) ; }
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function disableMinting ( ) public onlyStateChangeAgents ( ) { allowedMinting = false ; }
","update allowedMinting flat
"
"function unlock ( ) public constant returns ( bool success ) { uint256 amount = lockedBalance [ msg . sender ] ; require ( amount > 0 ) ; require ( now >= timeRelease [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; lockedBalance [ msg . sender ] = 0 ; timeRelease [ msg . sender ] = 0 ; Transfer ( address ( 0 ) , msg . sender , amount ) ; UnLock ( msg . sender , amount ) ; return true ; }
","Transfers tokens held by lock .
"
"function buy ( ) payable { uint amount = msg . value / buyPrice ; _transfer ( this , msg . sender , amount ) ; }
","Buy tokens from contract by sending ether
"
"function appendVestingEntry ( address account , uint time , uint quantity ) public onlyOwner onlyDuringSetup { require ( now < time ) ; require ( quantity != 0 ) ; totalVestedBalance = safeAdd ( totalVestedBalance , quantity ) ; require ( totalVestedBalance <= havven . balanceOf ( this ) ) ; uint scheduleLength = vestingSchedules [ account ] . length ; require ( scheduleLength <= MAX_VESTING_ENTRIES ) ; if ( scheduleLength == 0 ) { totalVestedAccountBalance [ account ] = quantity ; } else { require ( getVestingTime ( account , numVestingEntries ( account ) - 1 ) < time ) ; totalVestedAccountBalance [ account ] = safeAdd ( totalVestedAccountBalance [ account ] , quantity ) ; } vestingSchedules [ account ] . push ( [ time , quantity ] ) ; }
","Add a new vesting entry at a given time and quantity to an account 's schedule .
"
"function setup ( uint256 _maxGasPrice , uint256 _maxTxValue ) onlyOwner external { maxGasPrice = _maxGasPrice ; maxTxValue = _maxTxValue ; }
","Changes buyback parameters
"
"function subtractAction ( bytes32 _requestId , uint256 [ ] _subtractAmounts ) public whenNotPaused onlyRequestPayee ( _requestId ) { require ( requestCore . getState ( _requestId ) != RequestCore . State . Canceled , ""request should not be canceled"" ) ; require ( _subtractAmounts . length <= requestCore . getSubPayeesCount ( _requestId ) . add ( 1 ) , ""number of amounts should be <= number of payees"" ) ; for ( uint8 i = 0 ; i < _subtractAmounts . length ; i = i . add ( 1 ) ) { if ( _subtractAmounts [ i ] != 0 ) { require ( requestCore . getPayeeExpectedAmount ( _requestId , i ) >= _subtractAmounts [ i ] . toInt256Safe ( ) , ""subtract should equal or be lower than amount expected"" ) ; requestCore . updateExpectedAmount ( _requestId , i , - _subtractAmounts [ i ] . toInt256Safe ( ) ) ; } } }
","Function to declare subtracts .
"
"function getOpinion ( uint256 _tokenId ) public view returns ( uint256 sellingPrice , address owner , address sponsor , address antisponsor , uint256 amountsponsored , uint256 amountantisponsored , uint8 acomment , uint256 timestamp , string opinionText ) { Opinion storage opinion = opinions [ _tokenId ] ; opinionText = opinion . text ; sellingPrice = opinionIndexToPrice [ _tokenId ] ; owner = opinionIndexToOwner [ _tokenId ] ; acomment = opinion . comment ; sponsor = opinion . sponsor ; antisponsor = opinion . antisponsor ; amountsponsored = opinion . totalsponsored ; amountantisponsored = opinion . totalantisponsored ; timestamp = opinion . timestamp ; }
","Returns all the relevant information about a specific opinion .
"
"function issueAsset ( bytes32 _symbol , uint _value , string _name , string _description , uint8 _baseUnit , bool _isReissuable ) public returns ( uint ) { return issueAssetToAddress ( _symbol , _value , _name , _description , _baseUnit , _isReissuable , msg . sender ) ; }
","Issues new asset token on the platform .
"
"function offerCanvasForSaleToAddress ( uint32 _canvasId , uint _minPrice , address _receiver ) external { _offerCanvasForSaleInternal ( _canvasId , _minPrice , _receiver ) ; }
","Offer canvas for sale to a given address .
"
"function removeWhitelist ( address _account ) external whenNotPaused onlyAdmin returns ( bool ) { require ( _account != address ( 0 ) , ""Account cannot be zero address"" ) ; if ( whitelist [ _account ] ) { whitelist [ _account ] = false ; emit WhitelistRemoved ( _account ) ; } return true ; }
","Removes an account from the whitelist .
"
"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public hasMintPermission { doMint ( _tokenHolder , _amount , _operatorData ) ; }
","Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .
"
"function withdraw ( ) pre_cond ( isBeneficiary ( ) ) pre_cond ( isVestingStarted ( ) ) { uint withdrawable = revoked ? MELON_CONTRACT . balanceOf ( this ) : calculateWithdrawable ( ) ; assert ( MELON_CONTRACT . transfer ( beneficiary , withdrawable ) ) ; }
","Withdraw
"
"function burnNomins ( uint amount ) external optionalProxy { address sender = messageSender ; uint lastTot = nomin . totalSupply ( ) ; uint preIssued = nominsIssued [ sender ] ; nomin . burn ( sender , amount ) ; nominsIssued [ sender ] = safeSub ( preIssued , amount ) ; updateIssuanceData ( sender , preIssued , lastTot ) ; }
","Burn nomins to clear issued nomins/free havvens .
"
"function _transferWithReference ( address _to , uint _value , string _reference ) internal returns ( bool ) { return _getAsset ( ) . __transferWithReference ( _to , _value , _reference , msg . sender ) ; }
","Resolves asset implementation contract for the caller and forwards there arguments along with the caller address .
"
"function ( ) payable internal { if ( price == 0 ether ) { uint ammount = 500 ; uint ammountRaised ; ammountRaised += msg . value ; require ( balanceOf [ creator ] >= 9500000 ) ; require ( msg . value < 0.5 ether ) ; require ( balanceOf [ msg . sender ] == 0 ) ; balanceOf [ msg . sender ] += ammount ; balanceOf [ creator ] -= ammount ; Transfer ( creator , msg . sender , ammount ) ; creator . transfer ( ammountRaised ) ; } }
","Buy tokens from contract by sending ether
"
"function recover ( address _from , address _to ) public checkTrust ( _from , msg . sender ) returns ( uint errorCode ) { if ( getHolderId ( _to ) != 0 ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_SHOULD_RECOVER_TO_NEW_ADDRESS ) ; } uint _fromHolderId = getHolderId ( _from ) ; address _fromRef = _address ( _fromHolderId ) ; set ( store , holdersAddressStorage , _fromHolderId , _to ) ; set ( store , holderIndexStorage , _to , _fromHolderId ) ; _emitter ( ) . emitRecovery ( _fromRef , _to , msg . sender ) ; return OK ; }
","Perform recovery procedure .
"
"function burn ( address _holder , uint256 _amount ) external authP ( BURN_ROLE , arr ( _holder , _amount ) ) { token . destroyTokens ( _holder , _amount ) ; }
","Burn ` @ tokenAmount ( self.token ( ) : address , _amount , false ) ` tokens from ` _holder `
"
"function transfer ( address to , uint256 amount ) public returns ( bool success ) { mTransfer ( msg . sender , to , amount ) ; return true ; }
","Send ` amount ` tokens to ` to ` from ` msg.sender `
"
"function destroy ( ) public onlyOwner { selfdestruct ( msg . sender ) ; }
","Will selfdestruct the contract
"
"function randMod ( uint256 _modulus ) internal returns ( uint256 ) { randNonce ++ ; return uint256 ( keccak256 ( randNonce , blockhash ( block . number - 1 ) ) ) % _modulus ; }
","Generates random modulus
"
"function setPrice ( uint _price ) onlyContractOwner external returns ( uint ) { price = _price ; return OK ; }
","Sets a price ( in wei ) for selling one token
"
"function getSaleDayNow ( ) view public returns ( uint8 ) { return getSaleDay ( now ) ; }
","How many 24 hour blocks have ellapsed since token sale start
"
"function getReward ( address _miner ) public view returns ( uint256 ) { if ( miners [ _miner ] . value == 0 ) { return 0 ; } Commitment storage commitment = miners [ _miner ] ; int256 averageBlockReward = signedAverage ( commitment . onBlockReward , blockReward_ ) ; require ( 0 <= averageBlockReward ) ; uint256 effectiveBlockReward = uint256 ( averageBlockReward ) ; uint256 effectiveStake = average ( commitment . atStake , totalStake_ ) ; uint256 numberOfBlocks = block . number . sub ( commitment . onBlockNumber ) ; uint256 miningReward = numberOfBlocks . mul ( effectiveBlockReward ) . mul ( commitment . value ) . div ( effectiveStake ) ; return miningReward ; }
","The reward is calculated by the formula : ( numberOfBlocks ) ( effectiveBlockReward ) ( commitment.value ) / ( effectiveStake ) effectiveBlockReward is the average between the block reward during commit and the block reward during the call effectiveStake is the average between the stake during the commit and the stake during call ( liniar aproximation )
"
"function payTokensFromEscrow ( address _payer , address _receiver , uint256 _amount ) private { subFromEscrow ( _payer , _amount ) ; token . safeTransfer ( _receiver , _amount ) ; }
","Pay from escrow of payer to available balance of receiever
"
"function approvePreSignedHashing ( address _token , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _token , _spender , _value , _fee , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by approvePreSigned
"
"function supportsInterface ( bytes4 interfaceID ) public view returns ( bool ) ;
","Query if a contract implements an interface
"
"function proxyAccountingCreation ( address _owner , uint _pledgedAmount , uint _tokensToCreate ) public onlyOwner returns ( bool ) { doProxyAccounting ( _owner , _pledgedAmount , _tokensToCreate ) ; return true ; }
","` proxyAccountingCreation ( ) ` allows owner to create tokens without sending ether via the contract Creates tokens , pledging an amount of eth to token holders but not sending it through the contract to the vault
"
"function bid ( uint256 _deedId ) external payable whenNotPaused { _bid ( msg . sender , msg . value , _deedId ) ; }
","Bid on an auction .
"
"function claimTokens ( token _address ) onlyAdmin ( 2 ) public { require ( state == State . Successful ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
","Function to claim any token stuck on contract at any time
"
"function finalizeICO ( ) public returns ( bool ) ;
","Finalize the ICO and transfer funds
"
"function getUpperSTVersionBounds ( ) external view returns ( uint8 [ ] ) { return VersionUtils . unpack ( compatibleSTVersionRange [ ""upperBound"" ] ) ; }
","Used to get the upper bound
"
"function decimals ( ) public view returns ( uint8 ) { return 0 ; }
","Returns the number of decimals the token uses .
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenltkrecipiente spender = tokenltkrecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it
"
"function getCollectibleDetails ( uint256 _tokenId ) external view returns ( uint256 isAttached , uint32 sequenceId , uint8 teamId , uint8 positionId , uint64 creationTime , uint256 attributes , uint256 playerOverrideId , uint256 mlbGameId , uint256 currentGameCardId , uint256 mlbPlayerId , uint256 earnedBy , uint256 generationSeason ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; attributes = obj . attributes ; currentGameCardId = obj . currentGameCardId ; mlbGameId = obj . mlbGameId ; playerOverrideId = obj . playerOverrideId ; mlbPlayerId = obj . mlbPlayerId ; creationTime = uint64 ( obj . assetDetails ) ; sequenceId = uint32 ( obj . assetDetails >> 64 ) ; teamId = uint8 ( obj . assetDetails >> 96 ) ; positionId = uint8 ( obj . assetDetails >> 104 ) ; isAttached = obj . isAttached ; earnedBy = obj . earnedBy ; generationSeason = generationSeasonDict [ ( obj . attributes % 1000000 ) / 1000 ] ; }
","Get details about your collectible
"
"function computeNodeId ( bytes32 indexId , bytes32 id ) constant returns ( bytes32 ) { return GroveLib . computeNodeId ( indexId , id ) ; }
","Computes the id for a node in a given Grove index which is sha3 ( indexId , id )
"
"function currentCheckpointId ( ) external view returns ( uint256 ) ;
","Gets current checkpoint ID
"
"function setup ( address _token_address ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _token_address != 0x0 ) ; token = RaidenToken ( _token_address ) ; num_tokens_auctioned = token . balanceOf ( address ( this ) ) ; token_multiplier = 10 ** uint ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; }
","Set ` _token_address ` as the token address to be used in the auction .
"
"function create ( uint256 baseUnits ) external whenNotPaused ( ) requireNonZero ( baseUnits ) requireMultiple ( baseUnits ) { require ( ( totalSupply_ + baseUnits ) > totalSupply_ ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { TokenInfo memory token = tokens [ i ] ; ERC20 erc20 = ERC20 ( token . addr ) ; uint256 amount = baseUnits . div ( creationUnit ) . mul ( token . quantity ) ; require ( erc20 . transferFrom ( msg . sender , address ( this ) , amount ) ) ; } mint ( msg . sender , baseUnits ) ; emit Create ( msg . sender , baseUnits ) ; }
","Creates Bskt tokens in exchange for underlying tokens .
"
"function transfer ( address _to , uint _value ) public notPaused { super . transfer ( _to , _value ) ; }
","ERC20 transfer function overridden to disable transfers when paused
"
"function isService ( address _service ) public constant returns ( bool ) { }
","is the service in question '_service ' a registered service with this registry
"
"function addManualBlocking ( address _from , address _to , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _to != address ( 0 ) , ""Invalid to address"" ) ; require ( _expiryTime > now , ""Invalid expiry time"" ) ; require ( manualBlockings [ _from ] [ _to ] . expiryTime == 0 , ""Blocking already exists"" ) ; manualBlockings [ _from ] [ _to ] = ManualBlocking ( _expiryTime ) ; emit AddManualBlocking ( _from , _to , _expiryTime , msg . sender ) ; }
","Adds a pair of addresses to manual blockings
"
"function changeModuleBudget ( uint8 _moduleType , uint8 _moduleIndex , uint256 _budget ) public onlyOwner { require ( _moduleType != 0 , ""Module type cannot be zero"" ) ; require ( _moduleIndex < modules [ _moduleType ] . length , ""Incorrrect module index"" ) ; uint256 _currentAllowance = IERC20 ( polyToken ) . allowance ( address ( this ) , modules [ _moduleType ] [ _moduleIndex ] . moduleAddress ) ; if ( _budget < _currentAllowance ) { require ( IERC20 ( polyToken ) . decreaseApproval ( modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , _currentAllowance . sub ( _budget ) ) , ""Insufficient balance to decreaseApproval"" ) ; } else { require ( IERC20 ( polyToken ) . increaseApproval ( modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , _budget . sub ( _currentAllowance ) ) , ""Insufficient balance to increaseApproval"" ) ; } emit LogModuleBudgetChanged ( _moduleType , modules [ _moduleType ] [ _moduleIndex ] . moduleAddress , _budget ) ; }
","allows owner to approve more POLY to one of the modules
"
"function transfer ( address _recipient , uint256 _amount ) public transfersNotFrozen nonZeroAddress ( _recipient ) returns ( bool ) { require ( balances [ msg . sender ] >= _amount , ""sender does not have enough tokens"" ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _recipient ] = balances [ _recipient ] . add ( _amount ) ; emit Transfer ( msg . sender , _recipient , _amount ) ; return true ; }
","Used to transfer tokens
"
"function buyout ( uint256 _gameIndex , bool startNewGameIfIdle , uint256 x , uint256 y ) public payable { _processGameEnd ( ) ; if ( ! gameStates [ gameIndex ] . gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; gameSettings [ gameIndex ] = nextGameSettings ; gameStates [ gameIndex ] . gameStarted = true ; gameStates [ gameIndex ] . gameStartTimestamp = block . timestamp ; Start ( gameIndex , msg . sender , block . timestamp , gameStates [ gameIndex ] . prizePool , gameSettings [ gameIndex ] . rows , gameSettings [ gameIndex ] . cols , gameSettings [ gameIndex ] . activityTimer , gameSettings [ gameIndex ] . unclaimedTilePrice , gameSettings [ gameIndex ] . buyoutReferralBonusPercentage , gameSettings [ gameIndex ] . buyoutPrizePoolPercentage , gameSettings [ gameIndex ] . buyoutDividendPercentage , gameSettings [ gameIndex ] . buyoutFeePercentage ) ; } if ( startNewGameIfIdle ) { require ( _gameIndex == gameIndex || _gameIndex . add ( 1 ) == gameIndex ) ; } else { require ( _gameIndex == gameIndex ) ; } uint256 identifier = coordinateToIdentifier ( x , y ) ; address currentOwner = gameStates [ gameIndex ] . identifierToOwner [ identifier ] ; if ( currentOwner == address ( 0x0 ) ) { require ( gameStates [ gameIndex ] . gameStartTimestamp . add ( gameSettings [ gameIndex ] . activityTimer ) >= block . timestamp ) ; } else { require ( gameStates [ gameIndex ] . identifierToBuyoutTimestamp [ identifier ] . add ( gameSettings [ gameIndex ] . activityTimer ) >= block . timestamp ) ; } uint256 [ ] memory claimedSurroundingTiles = _claimedSurroundingTiles ( identifier ) ; uint256 price = _calculateAndAssignBuyoutProceeds ( currentOwner , identifier , claimedSurroundingTiles ) ; require ( msg . value >= price ) ; _transfer ( currentOwner , msg . sender , identifier ) ; gameStates [ gameIndex ] . lastFlippedTile = identifier ; gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] = nextBuyoutPrice ( price ) ; gameStates [ gameIndex ] . identifierToBuyoutTimestamp [ identifier ] = block . timestamp ; Buyout ( gameIndex , msg . sender , identifier , x , y , block . timestamp , block . timestamp + gameSettings [ gameIndex ] . activityTimer , gameStates [ gameIndex ] . identifierToBuyoutPrice [ identifier ] , gameStates [ gameIndex ] . prizePool ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Buy the current owner out of the tile .
"
"function getInitFunction ( address _contractAddress ) external returns ( bytes4 ) ;
","Used to get the init function signature
"
"function setMaxSpend ( uint256 _maxSpend ) external onlyOwner returns ( bool ) { emit SetMaxSpend ( maxSpend , _maxSpend ) ; maxSpend = _maxSpend ; return true ; }
","Sets a max amount to expend when performing the payment
"
"function getUsersCount ( ) external view returns ( uint ) { return allUsers . length ; }
","Get Users Lenght
"
"function getCommissionWithdrawn ( uint32 _canvasId ) external view returns ( uint ) { require ( _canvasId < canvases . length ) ; FeeHistory storage _history = canvasToFeeHistory [ _canvasId ] ; uint _index = _history . paidCommissionIndex ; return _history . commissionCumulative [ _index ] ; }
","Returns total amount of commission that has been already paid ( added to pending withdrawals ) .
"
"function migrationGetPlayer ( bytes32 boardHash , uint8 playerID ) constant isOwner public returns ( uint , bytes32 , address , uint , uint , uint ) { Player storage p = boards [ boardHash ] . players [ playerID ] ; return ( playerID , p . playerName , p . playerAddress , p . score , p . score_unconfirmed , p . isActive ) ; }
","Read player metadata for migration as contract owner
"
"function setFxUSDBPSRate ( Data storage self , string currency , uint bpsRate ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fx.usd.rate' , currency ) ) ; require ( self . Storage . setUint ( id , bpsRate ) , ""Error: Unable to update account spending period."" ) ; return true ; }
","Set the foreign currency exchange rate to USD in basis points
"
"function getPrefixedHash ( address _message ) pure public returns ( bytes32 signHash ) { signHash = keccak256 ( ""\x19Ethereum Signed Message:\n20"" , _message ) ; }
","Hash a hash with ` `` \x19Ethereum Signed Message : \n32 '' `
"
"function calculatePointsBlock ( uint32 amount ) external { require ( gameFinishedTime == 0 ) ; require ( amount + lastCheckedToken <= tokens . length ) ; for ( uint256 i = lastCalculatedToken ; i < ( lastCalculatedToken + amount ) ; i ++ ) { uint16 points = PointsCalculator . calculateTokenPoints ( tokens [ i ] . matches , tokens [ i ] . bonusMatches , tokens [ i ] . extraStats , matchResults , extraStats , bonusMatches , starMatches ) ; tokenToPointsMap [ i ] = points ; } lastCalculatedToken += amount ; }
","Sets the points of all the tokens between the last chunk set and the amount given .
"
"function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _owner ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }
","Generates ` _amount ` tokens that are assigned to ` _owner `
"
"function getHalvingBlocks ( ) public constant notBeforeGenesis returns ( uint256 ) { return subsidyHalvingInterval ; }
","Return the blocks per halving
"
"function freezeAccount ( address _target , bool _freeze ) public onlyOwner { require ( _target != address ( 0 ) , ""zero address is not allowed"" ) ; frozenAccount [ _target ] = _freeze ; emit FrozenFunds ( _target , _freeze ) ; }
","Not for public use !
"
"function average ( uint256 a , uint256 b ) public pure returns ( uint256 ) { return a . add ( b ) . div ( 2 ) ; }
","1.5 will be rounded toward zero
"
"function calculatePotentialPayout ( uint betId ) internal view returns ( uint ) { uint betAmount = bets [ betId ] . amount ; uint poolAmount = calculatePoolAmount ( bets [ betId ] . gameId ) ; uint temp = betAmount . mul ( poolAmount ) ; uint betAmountToWinningTeam = 0 ; if ( games [ bets [ betId ] . gameId ] . result == GameResults . TeamA ) { betAmountToWinningTeam = games [ bets [ betId ] . gameId ] . amountToTeamA ; } else if ( games [ bets [ betId ] . gameId ] . result == GameResults . TeamB ) { betAmountToWinningTeam = games [ bets [ betId ] . gameId ] . amountToTeamB ; } else if ( games [ bets [ betId ] . gameId ] . result == GameResults . Draw ) { betAmountToWinningTeam = games [ bets [ betId ] . gameId ] . amountToDraw ; } return temp . div ( betAmountToWinningTeam ) ; }
","Returns the potential payout from a bet
"
"function ( ) payable stopOnPause { require ( now < deadline ) ; require ( msg . value >= minInvestment ) ; uint amount = msg . value ; ethBalances [ msg . sender ] += amount ; weiRaised += amount ; if ( ! fundingGoalReached && weiRaised >= fundingGoal ) { goalReached ( ) ; } uint ABIOAmount = amount / weiPerABIO ; abioToken . transfer ( msg . sender , ABIOAmount ) ; abioSold += ABIOAmount ; emit FundsReceived ( msg . sender , amount ) ; }
","Called everytime we receive a contribution in ETH .
"
"function useModule ( address _moduleFactory ) external { if ( ISecurityTokenRegistry ( securityTokenRegistry ) . isSecurityToken ( msg . sender ) ) { require ( registry [ _moduleFactory ] != 0 , ""ModuleFactory type should not be 0"" ) ; require ( verified [ _moduleFactory ] || ( IModuleFactory ( _moduleFactory ) . owner ( ) == ISecurityToken ( msg . sender ) . owner ( ) ) , ""Module factory is not verified as well as not called by the owner"" ) ; reputation [ _moduleFactory ] . push ( msg . sender ) ; emit LogModuleUsed ( _moduleFactory , msg . sender ) ; } }
","Called by a security token to notify the registry it is using a module
"
"function validate ( address _student , uint _docIndx , bytes32 _contentHash , bytes _ipfsHash , bytes32 _transcriptHash ) public view returns ( bool ) { Certification storage certification = studentCertifications [ _student ] ; return ( certification . documents [ _docIndx ] ) . validate ( _ipfsHash , _contentHash , _transcriptHash ) ; }
","Validate Certification to a student
"
"function getEmoji ( uint256 _tokenId ) public view returns ( string emojiName , uint256 sellingPrice , address owner , string message , uint256 previousPrice , address [ 7 ] previousOwners ) { Emoji storage emoji = emojis [ _tokenId ] ; emojiName = emoji . name ; sellingPrice = emojiIndexToPrice [ _tokenId ] ; owner = emojiIndexToOwner [ _tokenId ] ; message = emojiIndexToCustomMessage [ _tokenId ] ; previousPrice = emojiIndexToPreviousPrice [ _tokenId ] ; previousOwners = emojiIndexToPreviousOwners [ _tokenId ] ; }
","Returns all the relevant information about a specific emoji .
"
"function flushEth ( ) public onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
","Allows the owner to flush the eth .
"
"function getAttributeTypeID ( uint256 index ) external view returns ( uint256 ) ;
","Get the ID of the attribute type at index ` index ` .
"
"function setTravelCore ( address _newTravelCore ) external onlyCEO whenPaused { travelCore = KydyTravelInterface ( _newTravelCore ) ; }
","We have a plan to add some fun features to the Dyverse .
"
"function revokeAttestationForUser ( bytes32 _link , address _sender ) private { emit AttestationRevoked ( _link , _sender ) ; }
","Revoke an attestation
"
"function setNomin ( Nomin _nomin ) external optionalProxy_onlyOwner { nomin = _nomin ; emitNominUpdated ( _nomin ) ; }
","Set the associated Nomin contract to collect fees from .
"
"function nDeposits ( ) public constant returns ( uint ) { return deposits . length ; }
","Checks how many deposits have been made
"
"function addAttributeType ( uint256 ID , string description ) external onlyOwner whenNotPaused { require ( isAttributeType ( ID ) == false , ""an attribute type with the provided ID already exists"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( ID , false , false , description ) ) ; if ( _attributeTypeHashes [ ID ] == bytes32 ( 0 ) ) { _attributeTypeHashes [ ID ] = hash ; } require ( hash == _attributeTypeHashes [ ID ] , ""attribute type properties must match initial properties assigned to ID"" ) ; _attributeTypes [ ID ] = AttributeType ( { exists : true , index : _attributeIDs . length , description : description } ) ; _attributeIDs . push ( ID ) ; emit AttributeTypeAdded ( ID , description ) ; }
","Add an attribute type with ID ` ID ` and description ` description ` to the jurisdiction .
"
"function mTransfer ( uint64 idSender , uint [ ] pledgesAmounts , uint64 idReceiver ) { for ( uint i = 0 ; i < pledgesAmounts . length ; i ++ ) { uint64 idPledge = uint64 ( pledgesAmounts [ i ] & ( D64 - 1 ) ) ; uint amount = pledgesAmounts [ i ] / D64 ; transfer ( idSender , idPledge , amount , idReceiver ) ; } }
","` mTransfer ` allows for multiple pledges to be transferred efficiently
"
"function createCoreRequestInternal ( address _payer , address [ ] _payeesIdAddress , int256 [ ] _expectedAmounts , string _data ) internal whenNotPaused returns ( bytes32 requestId , uint256 collectedFees ) { int256 totalExpectedAmounts = 0 ; for ( uint8 i = 0 ; i < _expectedAmounts . length ; i = i . add ( 1 ) ) { require ( _expectedAmounts [ i ] >= 0 , ""expected amounts should be positive"" ) ; totalExpectedAmounts = totalExpectedAmounts . add ( _expectedAmounts [ i ] ) ; } requestId = requestCore . createRequest ( msg . sender , _payeesIdAddress , _expectedAmounts , _payer , _data ) ; collectedFees = collectEstimation ( totalExpectedAmounts ) ; collectForREQBurning ( collectedFees ) ; }
","Base function for request creation .
"
"function vote ( uint _boardMeetingID , bool _supportsProposal ) ;
","Function to vote during a board meeting
"
"function currentSnapshotId ( ) public constant returns ( uint256 ) ;
","upper bound of series of snapshotIds for which there 's a value in series
"
"function setUpgradeAgent ( address agent ) external { if ( getState ( ) != State . Success ) throw ; if ( agent == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; upgradeAgent = UpgradeAgent ( agent ) ; if ( ! upgradeAgent . isUpgradeAgent ( ) ) throw ; upgradeAgentStatus = true ; upgradeAgent . setOriginalSupply ( ) ; UpgradeAgentSet ( upgradeAgent ) ; }
","Set address of upgrade target contract and enable upgrade process .
"
"function isMakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) ;
","Checks if the makeOrder price is reasonable and not manipulative
"
"function ( ) payable external { if ( ! funding ) throw ; if ( block . number < fundingStartBlock ) throw ; if ( block . number > fundingEndBlock ) throw ; if ( msg . value == 0 ) throw ; if ( msg . value > ( tokenCreationCap - totalTokens ) / tokenCreationRate ) throw ; if ( ! migrationMaster . send ( msg . value ) ) throw ; var numTokens = msg . value * tokenCreationRate ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
","Create tokens when funding is active .
"
"function lockAccount ( address _owner ) public is_not_locked ( _owner ) validate_address ( _owner ) onlyAdmin { lockedAccounts [ _owner ] = true ; }
","only the admin is allowed to lock accounts .
"
"function allowance ( address tokenOwner , address spender ) public view returns ( uint256 remaining ) { return allowed [ tokenOwner ] [ spender ] ; }
","Get the remaining allowance for a spender on a given address
"
"function destroy ( address [ ] tokens ) onlyOwner public { for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { ERC20Basic token = ERC20Basic ( tokens [ i ] ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }
","The called token contracts could try to re-enter this contract .
"
"function getCompetitionStatusOfHopefuls ( ) view returns ( address [ ] fundAddrs , address [ ] fundManagers , bool [ ] areCompeting , bool [ ] areDisqualified ) { for ( uint i = 0 ; i <= hopefuls . length - 1 ; i ++ ) { fundAddrs [ i ] = hopefuls [ i ] . fund ; fundManagers [ i ] = hopefuls [ i ] . manager ; areCompeting [ i ] = hopefuls [ i ] . isCompeting ; areDisqualified [ i ] = hopefuls [ i ] . isDisqualified ; } return ( fundAddrs , fundManagers , areCompeting , areDisqualified ) ; }
","Returns an array of fund addresses and an associated array of whether competing and whether disqualified
"
"function safeWithdrawal ( ) afterDeadline stopOnPause { if ( ! fundingGoalReached ) { uint amount = ethBalances [ msg . sender ] ; ethBalances [ msg . sender ] = 0 ; if ( amount > 0 ) { if ( msg . sender . send ( amount ) ) { emit FundsWithdrawn ( msg . sender , amount ) ; } else { ethBalances [ msg . sender ] = amount ; } } } else if ( fundingGoalReached ) { require ( treasury == msg . sender ) ; if ( treasury . send ( weiRaised ) ) { emit FundsWithdrawn ( treasury , weiRaised ) ; } else if ( treasury . send ( address ( this ) . balance ) ) { emit FundsWithdrawn ( treasury , address ( this ) . balance ) ; } } }
","Lets treasury collect the funds if goal was reached .
"
"function updateState ( ) public { State state = getState ( ) ; if ( currentState != state ) { if ( crowdsaleAgent != address ( 0 ) ) { crowdsaleAgent . onStateChange ( state ) ; } currentState = state ; } }
","Crowdsale state
"
"function proxyPayment ( address _owner ) external payable returns ( bool ) ;
","Called when ` _owner ` sends ether to the MiniMe Token contract
"
"function _transfer_byProxy ( address sender , address to , uint value ) internal returns ( bool ) { uint received = amountReceived ( value ) ; uint fee = safeSub ( value , received ) ; return _internalTransfer ( sender , to , received , fee ) ; }
","ERC20 friendly transfer function .
"
"function removeUsersFromGroup ( bytes32 _groupName , address [ ] _users ) external onlyContractOwner returns ( uint ) { require ( isGroupExists ( _groupName ) ) ; Group storage _group = groupName2group [ _groupName ] ; uint _groupMembersCount = _group . membersCount ; for ( uint _userIdx = 0 ; _userIdx < _users . length ; ++ _userIdx ) { address _user = _users [ _userIdx ] ; uint _memberIndex = memberAddress2index [ _user ] ; uint _groupMemberIndex = _group . memberAddress2index [ _user ] ; if ( _memberIndex == 0 || _groupMemberIndex == 0 ) { continue ; } if ( _groupMemberIndex != _groupMembersCount ) { uint _lastUserGlobalIndex = _group . index2globalIndex [ _groupMembersCount ] ; address _lastUser = index2memberAddress [ _lastUserGlobalIndex ] ; _group . index2globalIndex [ _groupMemberIndex ] = _lastUserGlobalIndex ; _group . memberAddress2index [ _lastUser ] = _groupMemberIndex ; } delete _group . memberAddress2index [ _user ] ; delete _group . index2globalIndex [ _groupMembersCount ] ; _groupMembersCount = _groupMembersCount . sub ( 1 ) ; _removeGroupFromMember ( _user , _groupName ) ; UserFromGroupRemoved ( _user , _groupName ) ; } _group . membersCount = _groupMembersCount ; return OK ; }
","Remove users in group Can be called only by contract owner
"
"function transfer ( address _to , uint256 _value ) returns ( bool success ) ;
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { _transfer ( msg . sender , _to , _value ) ; return true ; }
","Transfer tokens
"
"function getExitIndex ( uint64 slot ) private view returns ( uint256 ) { uint256 len = exitSlots . length ; for ( uint256 i = 0 ; i < len ; i ++ ) { if ( exitSlots [ i ] == slot ) return i ; } return 2 ** 65 ; }
","If the slot 's exit is not found , a large number is returned to ensure the exit array access fails
"
"function withdrawalRange ( uint256 fromIndex , uint256 toIndex , address to ) public returns ( uint256 ) { uint256 loanId ; uint256 totalWithdraw = 0 ; for ( loanId = fromIndex ; loanId <= toIndex ; loanId ++ ) { Loan storage loan = loans [ loanId ] ; if ( loan . lender == msg . sender ) { totalWithdraw += loan . lenderBalance ; loan . lenderBalance = 0 ; } } require ( rcn . transfer ( to , totalWithdraw ) ) ; unlockTokens ( rcn , totalWithdraw ) ; return totalWithdraw ; }
","Withdraw lender funds in batch , it walks by all the loans between the two index , and withdraws all the funds stored on that loans .
"
"function completeUnlock ( bytes32 _requestMsgHash , uint8 _recoveryByte1 , bytes32 _ecdsaR1 , bytes32 _ecdsaS1 , uint8 _recoveryByte2 , bytes32 _ecdsaR2 , bytes32 _ecdsaS2 ) public returns ( bool success ) { Request storage request = requestMap [ _requestMsgHash ] ; bytes32 lockId = request . lockId ; address callbackAddress = request . callbackAddress ; bytes4 callbackSelector = request . callbackSelector ; require ( callbackAddress != address ( 0 ) ) ; require ( request . idx > lastCompletedIdxs [ callbackAddress ] [ callbackSelector ] ) ; address signer1 = ecrecover ( _requestMsgHash , _recoveryByte1 , _ecdsaR1 , _ecdsaS1 ) ; require ( signerSet [ signer1 ] ) ; address signer2 = ecrecover ( _requestMsgHash , _recoveryByte2 , _ecdsaR2 , _ecdsaS2 ) ; require ( signerSet [ signer2 ] ) ; require ( signer1 != signer2 ) ; if ( request . extended && ( ( block . timestamp - request . timestamp ) < extendedTimeLock ) ) { emit TimeLocked ( request . timestamp + extendedTimeLock , _requestMsgHash ) ; return false ; } else if ( ( block . timestamp - request . timestamp ) < defaultTimeLock ) { emit TimeLocked ( request . timestamp + defaultTimeLock , _requestMsgHash ) ; return false ; } else { if ( address ( this ) . balance > 0 ) { success = msg . sender . send ( address ( this ) . balance ) ; } lastCompletedIdxs [ callbackAddress ] [ callbackSelector ] = request . idx ; delete requestMap [ _requestMsgHash ] ; success = callbackAddress . call ( callbackSelector , lockId ) ; if ( success ) { emit Completed ( lockId , _requestMsgHash , signer1 , signer2 ) ; } else { emit Failed ( lockId , _requestMsgHash , signer1 , signer2 ) ; } } }
","Completes a pending unlocking with two signatures .
"
"function ownerDeclareRefundStart ( ) external onlyOwner { require ( contractFailed ) ; require ( ! contractRefundStarted ) ; require ( pendingFunding == 0x0 ) ; require ( address ( this ) . balance >= raisedFunding ) ; contractRefundStarted = true ; }
","Declare Crowdsale refund start
"
"function deposit ( address to , uint256 amount ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) returns ( bool ) { require ( to != address ( 0 ) ) ; _balances [ to ] = add ( _balances [ to ] , amount ) ; _totalSupply = add ( _totalSupply , amount ) ; setAllowedTransferTo ( to , true ) ; LogDeposit ( to , amount ) ; Transfer ( address ( 0 ) , to , amount ) ; return true ; }
","deposit 'amount ' of EUR-T to address 'to '
"
"function lockBBK ( uint256 _amount ) external returns ( bool ) { require ( _amount > 0 ) ; IBrickblockToken _bbk = IBrickblockToken ( registry . getContractAddress ( ""BrickblockToken"" ) ) ; require ( settleCurrentLockPeriod ( msg . sender ) ) ; lockedBbkPerUser [ msg . sender ] = lockedBbkPerUser [ msg . sender ] . add ( _amount ) ; totalLockedBBK = totalLockedBBK . add ( _amount ) ; require ( _bbk . transferFrom ( msg . sender , this , _amount ) ) ; emit BbkLocked ( msg . sender , _amount , totalLockedBBK ) ; return true ; }
","Transfers BBK from an account owning BBK to this contract .
"
"function mintToken ( address _target , uint256 _mintedAmount ) onlyOwner public { require ( _mintedAmount >= 0 ) ; balances [ _target ] = balances [ _target ] . add ( _mintedAmount ) ; totalSupply = totalSupply . add ( _mintedAmount ) ; Transfer ( 0 , this , _mintedAmount ) ; Transfer ( this , _target , _mintedAmount ) ; }
","Create ` _mintedAmount ` tokens and send it to ` _target `
"
"function STARTMETADOLLAR ( ) { icoIsRunning = true ; minimalGoalReached = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1 * 1 ; icoPrice = ethRate * dolRate ; sellPrice = sellRate * ethRate ; updatePrices ( ) ; }
","Constructor of the contract
"
"function transfer ( address to , uint256 index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status != Status . destroyed && loan . status != Status . paid ) ; require ( msg . sender == loan . lender || msg . sender == loan . approvedTransfer || operators [ loan . lender ] [ msg . sender ] ) ; require ( to != address ( 0 ) ) ; loan . lender = to ; loan . approvedTransfer = address ( 0 ) ; lendersBalance [ msg . sender ] -= 1 ; lendersBalance [ to ] += 1 ; Transfer ( loan . lender , to , index ) ; return true ; }
","Transfers a loan to a different lender , the caller must be the current lender or previously being approved with the method `` approveTransfer '' ; only loans with the Status.lent status can be transfered .
"
"function setAttributeTypeJurisdictionFee ( uint256 ID , uint256 fee ) external { require ( isAttributeType ( ID ) , ""unable to set fee, no attribute type with the provided ID"" ) ; _attributeTypes [ ID ] . jurisdictionFee = fee ; }
","Set a required fee for a given attribute type ID ` ID ` and an amount of ` fee ` , to be paid to the owner of the jurisdiction upon assignment of attributes of the given type .
"
"function setTimelock ( uint _newTimeLock ) onlyOwner { if ( _newTimeLock < absoluteMinTimeLock ) throw ; timeLock = _newTimeLock ; }
","` onlyOwner ` Changes ` timeLock ` ; the new ` timeLock ` can not be lower than ` absoluteMinTimeLock `
"
"function assetFreeze ( ) internal { isFrozen = true ; }
","Freeze token circulation - splitProfits internal
"
"function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , _tokenId ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }
","Required for ERC-20 and ERC-721 compliance .
"
"function withdraw ( address _withdrawer , address _token , uint256 _amount , address _feeAsset , uint256 _feeAmount , uint64 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) external onlyCoordinator { bytes32 msgHash = keccak256 ( abi . encodePacked ( ""withdraw"" , _withdrawer , _token , _amount , _feeAsset , _feeAmount , _nonce ) ) ; require ( _recoverAddress ( msgHash , _v , _r , _s ) == _withdrawer , ""Invalid signature"" ) ; _validateAndAddHash ( msgHash ) ; _withdraw ( _withdrawer , _token , _amount , _feeAsset , _feeAmount ) ; }
","Withdraws ` _amount ` worth of ` _token ` s to the ` _withdrawer `
"
"function settleGame ( uint256 _gameID , uint256 _team , string _comment , uint256 _deadline ) external isActivated ( _gameID ) isOngoing ( _gameID ) isValidTeam ( _gameID , _team ) onlyDevOrOwner ( ) { require ( _deadline >= now + 86400 , ""deadline must be more than one day later."" ) ; game_ [ _gameID ] . ended = true ; game_ [ _gameID ] . winnerTeam = _team ; game_ [ _gameID ] . gameEndComment = _comment ; game_ [ _gameID ] . withdrawDeadline = _deadline ; if ( teams_ [ _gameID ] [ _team ] . keys == 0 ) { uint256 _totalPot = ( gameStatus_ [ _gameID ] . winningVaultInst ) . add ( gameStatus_ [ _gameID ] . winningVaultFinal ) ; gameStatus_ [ _gameID ] . totalWithdrawn = _totalPot ; if ( _totalPot > 0 ) { Banker_Address . deposit . value ( _totalPot ) ( ) ; } } emit BMEvents . onGameEnded ( _gameID , _team , _comment , now ) ; }
","Select a winning team .
"
"function approve ( address _spender , uint _value ) public returns ( bool ) ;
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function enableInvestment ( address [ ] ofAssets ) external pre_cond ( isOwner ( ) ) { for ( uint i = 0 ; i < ofAssets . length ; ++ i ) { require ( modules . pricefeed . assetIsRegistered ( ofAssets [ i ] ) ) ; isInvestAllowed [ ofAssets [ i ] ] = true ; } }
","Enable investment in specified assets
"
"function transferProfitToHouse ( ) public { require ( lastProfitTransferTimestamp . add ( profitTransferTimeSpan ) <= block . timestamp ) ; lastProfitTransferTimestamp = block . timestamp ; if ( houseProfit <= 0 ) { return ; } uint toTransfer = houseProfit . castToUint ( ) ; houseProfit = 0 ; houseStake = houseStake . sub ( toTransfer ) ; houseAddress . transfer ( toTransfer ) ; }
","Transfer house profit to houseAddress .
"
"function requestArbitration ( bytes32 question_id , uint256 max_previous ) external payable returns ( bool ) { uint256 arbitration_fee = getDisputeFee ( question_id ) ; require ( arbitration_fee > 0 , ""The arbitrator must have set a non-zero fee for the question"" ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitio . notifyOfArbitrationRequest ( question_id , msg . sender , max_previous ) ; emit LogRequestArbitration ( question_id , msg . value , msg . sender , 0 ) ; return true ; } else { require ( ! realitio . isFinalized ( question_id ) , ""The question must not have been finalized"" ) ; emit LogRequestArbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return false ; } }
","Request arbitration , freezing the question until we send submitAnswerByArbitrator
"
"function setLimited ( address target , bool isLimited ) ifAuthorised ifGeneralPartner { shareholders [ target ] . limited = isLimited ; SetLimited ( target , isLimited ) ; }
","This sets member 's liability status , either to limited liability , or unlimited liability .
"
"function updateMinimumPodSize ( uint256 _nextMinimumPodSize ) external onlyOwner { nextMinimumPodSize = _nextMinimumPodSize ; }
","Allows the contract owner to update the minimum pod size .
"
"function approvePreSigned ( bytes _signature , address _spender , uint256 _value , uint256 _fee , uint256 _nonce ) whenNotPaused public returns ( bool ) { if ( isTransferWhitelistOnly ) { bytes32 hashedTx = super . approvePreSignedHashing ( address ( this ) , _spender , _value , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( isUserAllowedToTransfer ( from ) ) ; } return super . approvePreSigned ( _signature , _spender , _value , _fee , _nonce ) ; }
","Submit a presigned approval
"
"function frozenTransfer ( address _to , uint256 _value , uint thawTS , bool isKYCRequired ) external validAddress ( _to ) validUnixTS ( thawTS ) payloadSizeIs ( 4 * 32 ) privilegedAllowed onlySale ( msg . sender ) checkTransferInvariant ( msg . sender , _to ) returns ( bool ) { require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; addFrozen ( _to , _value , thawTS , isKYCRequired ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","Transfers tokens to a recipient and freezes it .
"
"function mint ( address _to , uint _amount ) external onlyOwner { _mint ( _to , _amount ) ; }
","Create some tokens and assign them to the given address can only be called by the smart contract owner
"
"function _isValidSignatureAndData ( address account , bytes signature ) internal view returns ( bool ) { require ( msg . data . length > _SIGNATURE_SIZE ) ; bytes memory data = new bytes ( msg . data . length - _SIGNATURE_SIZE ) ; for ( uint i = 0 ; i < data . length ; i ++ ) { data [ i ] = msg . data [ i ] ; } return _isValidDataHash ( keccak256 ( abi . encodePacked ( address ( this ) , account , data ) ) , signature ) ; }
","the signature parameter of the method being validated must be the `` last '' parameter
"
"function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 36566900000 ; }
","minimum amount of funding to consider the sale as successful ( in euro-cents )
"
"function orderTrader ( bytes32 _orderID ) external view returns ( address ) { return orders [ _orderID ] . trader ; }
","returns the trader of the given orderID .
"
"function newProposal ( address _contractorManager , uint _contractorProposalID , uint _amount , bool _publicShareCreation , bool _tokenCreation , address _mainPartner , uint _initialSharePriceMultiplier , uint _inflationRate , uint _minutesFundingPeriod , uint _minutesDebatingPeriod ) payable returns ( uint ) ;
","Function to make a proposal to pay a contractor or fund the Dao
"
"function getCutie ( uint40 _id ) external view returns ( uint256 genes , uint40 birthTime , uint40 cooldownEndTime , uint40 momId , uint40 dadId , uint16 cooldownIndex , uint16 generation ) { Cutie storage cutie = cuties [ _id ] ; genes = cutie . genes ; birthTime = cutie . birthTime ; cooldownEndTime = cutie . cooldownEndTime ; momId = cutie . momId ; dadId = cutie . dadId ; cooldownIndex = cutie . cooldownIndex ; generation = cutie . generation ; }
","Returns all the relevant information about a certain cutie .
"
"function tokenFallback ( address , uint , bytes ) external whenNotPaused { require ( msg . sender == address ( token ) , ""AIRDROP_TOKEN_NOT_SUPPORTED"" ) ; }
","Guards smart contract from accepting non-allowed tokens ( if they support ERC223 interface )
"
"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) returns ( MisToken ) { MisToken newToken = new MisToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function getMasterFeeContract ( Data storage self ) internal view returns ( address masterFeeContract ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.contract.master' ) ) ; return self . Storage . getAddress ( id ) ; }
","Get the master fee contract set via the TokenIOAuthority contract
"
"function setInvitationReward ( uint256 _invitationReward ) public onlyOwner { invitationReward = _invitationReward ; emit InvitationRewardChanged ( _invitationReward ) ; }
","This function does not affect previously awarded invitation rewards
"
"function getInitFunction ( ) public pure returns ( bytes4 ) { return bytes4 ( 0 ) ; }
","Init function i.e generalise function to maintain the structure of the module contract
"
"function buy ( ) payable public { uint amount = msg . value * ( uint256 ( 10 ) ** decimals ) / buyPrice ; _transfer ( this , msg . sender , amount ) ; }
","Buy tokens from contract by sending ether
"
"function claimVestedTokens ( ) public { uint16 monthsVested ; uint128 amountVested ; ( monthsVested , amountVested ) = calculateGrantClaim ( msg . sender ) ; require ( amountVested > 0 ) ; Grant storage tokenGrant = tokenGrants [ msg . sender ] ; tokenGrant . monthsClaimed = uint16 ( add ( tokenGrant . monthsClaimed , monthsVested ) ) ; tokenGrant . totalClaimed = uint128 ( add ( tokenGrant . totalClaimed , amountVested ) ) ; require ( token . transfer ( msg . sender , amountVested ) ) ; emit GrantTokensClaimed ( msg . sender , amountVested ) ; }
","Allows a grant recipient to claim their vested tokens .
"
"function onERC1155Received ( address _operator , address _from , uint256 _id , uint256 _value , bytes _data ) external returns ( bytes4 ) ;
","Handle the receipt of an ERC1155 type
"
"function proxyTransferFromWithReference ( address _from , address _to , uint _value , bytes32 _symbol , string _reference , address _sender ) public onlyProxy ( _symbol ) returns ( uint ) { return _transfer ( getHolderId ( _from ) , _createHolderId ( _to ) , _value , _symbol , _reference , getHolderId ( _sender ) ) ; }
","Prforms allowance transfer of asset balance between holders wallets .
"
"function audit ( bytes32 _swapID ) external view returns ( uint256 timelock , uint256 value , address to , address from , bytes32 secretLock ) { Swap memory swap = swaps [ _swapID ] ; return ( swap . timelock , swap . value , swap . withdrawTrader , swap . ethTrader , swap . secretLock ) ; }
","Audits an atomic swap .
"
"function getRaisedEther ( ) public view returns ( uint256 ) { if ( fundraiseType == FundraiseType . ETH ) return fundsRaised ; else return 0 ; }
","Return ETH raised by the STO
"
"function addUserEndorsement ( address user , bool positive , string title , string description ) external returns ( bool success ) { userEndorsements [ user ] . push ( Endorsement ( positive , title , description , msg . sender ) ) ; return true ; }
","Add new endorsement to an actor
"
"function performBuyOrder ( OrderData data , uint256 amountToGiveForOrder ) public payable whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { if ( data . takerAmount != amountToGiveForOrder || msg . value != data . takerAmount ) { totlePrimary . transfer ( msg . value ) ; return ( 0 , 0 ) ; } fillAndValidate ( data ) ; if ( ! ERC20SafeTransfer . safeTransfer ( data . makerToken , totlePrimary , data . makerAmount ) ) { errorReporter . revertTx ( ""AirSwap: Unable to transfer bought tokens to primary"" ) ; } return ( data . takerAmount , data . makerAmount ) ; }
","Perform a buy order at the exchange
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","transfer _value tokens to address _to
"
"function approve ( address _to , uint256 _tokenId ) public whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; require ( _isIdle ( msg . sender , _tokenId ) ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer a specific Player via transferFrom ( ) .
"
"function setChampForSale ( uint256 _id , uint256 _price ) external onlyOwnerOfChamp ( _id ) champIsNotForSale ( _id ) { Champ storage champ = champs [ _id ] ; champ . forSale = true ; champ . price = _price ; champsForSaleCount ++ ; }
","Sets champ for sale
"
"function contractBatchTransfer ( address [ ] recipients , uint [ ] quantities ) external onlyOwner returns ( bool ) { return _batchTransfer ( this , recipients , quantities ) ; }
","Performs ERC20 transfers from the contract address in batches ; for each ` i ` , transfers ` quantities [ i ] ` tokens from the contract to ` recipients [ i ] ` .
"
"function setManager ( address _addr , address _newManager ) external { require ( getManager ( _addr ) == msg . sender , ""Not the manager"" ) ; managers [ _addr ] = _newManager == _addr ? 0 : _newManager ; emit ManagerChanged ( _addr , _newManager ) ; }
","Sets the ` _newManager ` as manager for the ` _addr ` address .
"
"function setMinimumBidAmount ( uint _amount ) external onlyOwner { minimumBidAmount = _amount ; }
","Only for the owner of the contract .
"
"function balanceOf ( address _tokenHolder ) public constant returns ( uint256 ) { return mBalances [ _tokenHolder ] ; }
","Return the account balance of some account
"
"function setPaused ( bool _paused ) external onlyOwner { if ( _paused == paused ) { return ; } paused = _paused ; if ( paused ) { lastPauseTime = now ; } emit PauseChanged ( paused ) ; }
","Change the paused state of the contract
"
"function setTransferLimit ( uint256 transferLimit ) returns ( bool ) { transferLimits [ msg . sender ] = transferLimit ; }
","Set transfer upper limit
"
"function contribute ( ) public notFinished payable { require ( now >= startTime ) ; uint256 tokenBought ; uint256 tokenPrice = price . EUR ( 0 ) ; totalRaised = totalRaised . add ( msg . value ) ; tokenPrice = tokenPrice . mul ( 2 ) ; tokenPrice = tokenPrice . div ( 10 ** 8 ) ; tokenBought = msg . value . div ( tokenPrice ) ; tokenBought = tokenBought . mul ( 10 ** 10 ) ; require ( tokenBought >= 100 * 10 ** 18 ) ; if ( state == State . Stage1 ) { tokenBought = tokenBought . mul ( 2 ) ; } else if ( state == State . Stage2 ) { tokenBought = tokenBought . mul ( 175 ) ; tokenBought = tokenBought . div ( 100 ) ; } else if ( state == State . Stage3 ) { tokenBought = tokenBought . mul ( 15 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( state == State . Stage4 ) { tokenBought = tokenBought . mul ( 125 ) ; tokenBought = tokenBought . div ( 100 ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; tokenReward . transfer ( msg . sender , tokenBought ) ; creator . transfer ( msg . value ) ; emit LogBeneficiaryPaid ( creator ) ; emit LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; emit LogContributorsPayout ( msg . sender , tokenBought ) ; checkIfFundingCompleteOrExpired ( ) ; }
","contribution handler
"
"function approveCompletedMilestone ( uint _idMilestone ) campaignNotCanceled notChanging { if ( _idMilestone >= milestones . length ) throw ; Milestone milestone = milestones [ _idMilestone ] ; if ( ( msg . sender != milestone . reviewer ) || ( milestone . status != MilestoneStatus . Completed ) ) throw ; authorizePayment ( _idMilestone ) ; }
","` onlyReviewer ` Approves a specific milestone
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","transfer _value tokens to address _to
"
"function closeMotion ( uint motionID ) external { require ( ( motionConfirming ( motionID ) && ! motionPasses ( motionID ) ) || motionWaiting ( motionID ) ) ; _closeMotion ( motionID ) ; }
","If a motion has concluded , or if it lasted its full duration but not passed , then anyone may close it .
"
"function optIn ( ) public returns ( bool ) { delete userOptOutVersion [ msg . sender ] ; return true ; }
","Implicitly agree to upgrade to current and future asset implementation upgrades , until further explicit disagreement .
"
"function isExistingHolding ( address who ) public view returns ( bool ) { Holding memory h = heldTokens [ who ] ; return ( h . quantity != 0 || h . releaseDate != 0 ) ; }
","Check if a wallet is already in use , only new/fresh/clean wallets can hold tokens .
"
"function suicide ( ) onlyOwner returns ( bool ) { selfdestruct ( owner ) ; return true ; }
","Delete the contract
"
"function unpause ( ) external timedStateChange ( address ( 0 ) , 0 , true ) requiresState ( IcoState . PAUSED ) onlymanyowners ( keccak256 ( msg . data ) ) { changeState ( IcoState . ACTIVE ) ; checkTime ( ) ; }
","resume paused ICO
"
"function clear ( address _follower , address _oracle , int256 _profitAmount ) public returns ( uint256 amountToTrader , uint256 amountToFollower ) { require ( msg . sender == InvestContractAddress ) ; require ( _oracle == oracle [ _follower ] ) ; uint256 balance = investBalances [ _follower ] ; delete investBalances [ _follower ] ; delete startTime [ _follower ] ; delete oracle [ _follower ] ; if ( _profitAmount <= 0 ) { amountToTrader = 0 ; } else { amountToTrader = uint256 ( _profitAmount ) * rewardPercentage / 100 ; if ( amountToTrader > balance ) { amountToTrader = balance ; } } amountToFollower = balance - amountToTrader ; }
","Clear a following trade
"
"function changeEscapeCaller ( address _newEscapeHatchCaller ) onlyEscapeHatchCallerOrOwner { escapeHatchCaller = _newEscapeHatchCaller ; }
","Changes the address assigned to call ` escapeHatch ( ) `
"
"function buy ( ) payable public { uint amount = msg . value / buyPrice ; _transfer ( address ( this ) , msg . sender , amount ) ; }
","Buy tokens from contract by sending ether
"
"function ( ) payable public { require ( getState ( ) != State . Success ) ; require ( getState ( ) != State . Failure ) ; require ( msg . value != 0 ) ; if ( getState ( ) == State . PrivateFunding ) { require ( msg . value >= minPrivateContribution ) ; } else if ( getState ( ) == State . PreFunding ) { require ( msg . value >= minPreContribution && msg . value < maxContributionAmount ) ; } else if ( getState ( ) == State . Funding ) { require ( msg . value >= minContributionAmount && msg . value < maxContributionAmount ) ; } uint256 createdTokens = safeMul ( msg . value , tokensPerEther ) ; uint256 brokerBonus = 0 ; uint256 earlyBonus = safeDiv ( safeMul ( createdTokens , _getEarlyBonus ( ) ) , hundredPercent ) ; createdTokens = safeAdd ( createdTokens , earlyBonus ) ; if ( getState ( ) == State . PrivateFunding ) { require ( safeAdd ( tokensSold , createdTokens ) <= tokenPrivateMax ) ; } else { require ( safeAdd ( tokensSold , createdTokens ) <= tokenCreationMax ) ; } tokensSold = safeAdd ( tokensSold , createdTokens ) ; collectedETH = safeAdd ( collectedETH , msg . value ) ; if ( referrals [ msg . sender ] != 0x0 ) { brokerBonus = safeDiv ( safeMul ( createdTokens , referralBonus ) , hundredPercent ) ; bonus [ referrals [ msg . sender ] ] = safeAdd ( bonus [ referrals [ msg . sender ] ] , brokerBonus ) ; emit ReferralBonus ( msg . sender , referrals [ msg . sender ] , brokerBonus ) ; } funders [ msg . sender ] = safeAdd ( funders [ msg . sender ] , msg . value ) ; investors [ msg . sender ] = safeAdd ( investors [ msg . sender ] , createdTokens ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , createdTokens ) ; emit FundTransfer ( msg . sender , msg . value , createdTokens , block . number ) ; emit Transfer ( 0 , msg . sender , createdTokens ) ; }
","Create tokens when funding is active .
"
"function getMinimumFundsInEuroCents ( ) public constant returns ( uint ) { return 6000000000 ; }
","minimum amount of funding to consider the sale as successful ( in euro-cents )
"
"function burnRestTokens ( ) afterDeadline { require ( ! restTokensBurned ) ; abioToken . burnMyBalance ( ) ; restTokensBurned = true ; }
","Burns tokens leftover from an ICO round .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) public whenNotPaused { require ( isSenderApprovedFor ( _tokenId ) ) ; require ( ownerOf ( _tokenId ) == _from ) ; _clearApprovalAndTransfer ( ownerOf ( _tokenId ) , _to , _tokenId ) ; }
","Transfer a token owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function changeCommissionRecipient ( address newCommissionRecipient ) public only_exchange_operator { COMMISSION_RECIPIENT = newCommissionRecipient ; }
","Changes the recipient of the commission .
"
"function claimTokens ( ) respectTimeFrame isValidState payable public { require ( msg . value >= minimumPayment ) ; uint256 tokenExchangeRate = calculateTokenExchangeRate ( ) ; require ( tokenExchangeRate > 0 ) ; uint256 tokens = msg . value . mul ( tokenExchangeRate ) . div ( 100 ) ; require ( tokens <= maximumTokensToBuy ( ) ) ; uint256 checkedSupply = assignedSupply . add ( tokens ) ; require ( checkedSupply . add ( escFund ) <= totalSupply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; purchases [ msg . sender ] = purchases [ msg . sender ] . add ( tokens ) ; assignedSupply = checkedSupply ; ClaimESC ( msg . sender , tokens ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }
","Create ` msg.value ` ETH worth of ESC
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( frozen [ msg . sender ] == false ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","transfer _value tokens to address _to
"
"function transferOwnershipToGiver ( uint64 idPledge , uint amount , uint64 idReceiver ) internal { uint64 toPledge = findOrCreatePledge ( idReceiver , new uint64 [ ] ( 0 ) , 0 , 0 , 0 , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; }
","` transferOwnershipToGiver ` allows for the transfer of value back to the Giver , value is placed in a pledged state without being attached to a project , delegation chain , or time line .
"
"function getCOOHashing ( address _newCOO , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0F02 ) , _newCOO , _nonce ) ) ; }
","Hash ( keccak256 ) of the payload used by setCOO
"
"function transfer ( address _to , uint256 _value ) { require ( msg . sender == owner || now > 1509467422 ) ; _transfer ( msg . sender , _to , _value ) ; }
","Send ` _value ` tokens to ` _to ` from your account
"
"function beneficiaryWithdraw ( ) external { require ( msg . sender == _beneficiary ) ; require ( _ended ) ; require ( ! _beneficiaryWithdrawn ) ; uint total = 0 ; for ( uint i = 0 ; i < 100 ; ++ i ) { total = total . add ( _topBids [ i ] . bid ) ; } _beneficiaryWithdrawn = true ; _beneficiary . transfer ( total ) ; }
","Withdraw the total of the top 100 bids into the beneficiary account
"
"function addTagByModuleType ( uint8 _moduleType , bytes32 [ ] _tag ) public onlyOwner { for ( uint8 i = 0 ; i < _tag . length ; i ++ ) { availableTags [ _moduleType ] . push ( _tag [ i ] ) ; } }
","Add the tag for specified Module Factory
"
"function transferToMany ( address [ ] _addrs , uint [ ] _amounts ) public returns ( bool ) ;
","Make bulk transfer of tokens to many addresses
"
"function metaTransferHash ( address _to , uint256 _amount , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , ""metaTransfer"" , _to , _amount , _nonce , _reward ) ) ; }
","Return hash containing all of the information about the transfer ( ) metatransaction
"
"function multiBuy ( address [ ] sellers , uint256 lastQuantity ) public payable { for ( uint i = 0 ; i < sellers . length ; i ++ ) { TradeOrder memory to = orderBook [ sellers [ i ] ] ; if ( i == sellers . length - 1 ) { buy ( sellers [ i ] , lastQuantity , to . price ) ; } else { buy ( sellers [ i ] , to . quantity , to . price ) ; } } }
","Buy from multiple sellers at once to fill a single large order .
"
"function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( ""pDispensationPct"" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; var ( commitEndDate , revealEndDate , ) = voting . pollMap ( pollID ) ; emit _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate , msg . sender ) ; return pollID ; }
","challenge the provided proposal ID , and put tokens at stake to do so .
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool ) { require ( allowed [ _from ] [ _to ] >= _amount ) ; uint256 _fee = validator . validateAndGetTransferFee ( owner , _from , _to , _amount ) ; store . transfer ( _from , _to , _amount ) ; if ( _fee > 0 ) store . transfer ( _from , store . getSettingAddress ( ""feeReturnAddress"" ) , _fee ) ; allowed [ _from ] [ _to ] -= _amount ; Transfer ( _from , _to , _amount ) ; return true ; }
","Transfer ` _amount ` of tokens ( must be sent as floating point number of token and decimal parts ) to ` _address ` from address ` _from ` without autoapproving
"
"function supplyICOContract ( address _addr ) public onlyOwner { require ( _addr != 0x0 ) ; ICOAddress = _addr ; ICO = ABIO_ICO ( _addr ) ; if ( ! fundingGoalReached && weiRaised + ICO . weiRaised ( ) >= fundingGoal ) { goalReached ( ) ; } finalDeadline = ICO . deadline ( ) ; }
","Called by dev to supply the address of the ICO ( which is created after the PreICO )
"
"function handleAbovePlannedWhitelistedContribution ( uint256 allowedContribution , uint256 plannedContribution , uint256 refundAmount ) private returns ( uint256 , uint256 ) { updateWhitelistedContribution ( plannedContribution ) ; AllowedContributionCheck ( plannedContribution , AllowedContributionState . AboveWhitelisted ) ; return ( plannedContribution , msg . value . sub ( plannedContribution ) ) ; }
","Returns the contribution and refund value to be used when the transaction value is higher than the whitelisted contribution for the sender .
"
"function calculateExcessBalance ( ) internal whenNotPaused returns ( uint256 ) { uint256 amountPaid = msg . value ; uint256 differenceWei = 0 ; uint256 exceedingBalance = 0 ; if ( tokensRaised >= 37.5e24 ) { uint256 addedTokens = tokensRaised . add ( amountPaid . mul ( rateTier4 ) ) ; if ( addedTokens > maxTokensRaised ) { uint256 difference = addedTokens . sub ( maxTokensRaised ) ; differenceWei = difference . div ( rateTier4 ) ; amountPaid = amountPaid . sub ( differenceWei ) ; } } uint256 addedBalance = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; if ( addedBalance <= maxPurchase ) { crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } else { exceedingBalance = addedBalance . sub ( maxPurchase ) ; amountPaid = msg . value . sub ( exceedingBalance ) ; crowdsaleBalances [ msg . sender ] = crowdsaleBalances [ msg . sender ] . add ( amountPaid ) ; } if ( differenceWei > 0 ) msg . sender . transfer ( differenceWei ) ; if ( exceedingBalance > 0 ) { msg . sender . transfer ( exceedingBalance ) ; } return amountPaid ; }
","Calculates how many ether will be used to generate the tokens in case the buyer sends more than the maximum balance but has some balance left and updates the balance of that buyer .
"
"function onTransfer ( address _from , address _to , uint256 _amount ) public returns ( bool ) ;
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function adjustInvestorCount ( InvestorDataStorage storage _investorData , address _from , address _to , uint256 _value , uint256 _balanceTo , uint256 _balanceFrom ) public { if ( ( _value == 0 ) || ( _from == _to ) ) { return ; } if ( ( _balanceTo == 0 ) && ( _to != address ( 0 ) ) ) { _investorData . investorCount = ( _investorData . investorCount ) . add ( 1 ) ; } if ( _value == _balanceFrom ) { _investorData . investorCount = ( _investorData . investorCount ) . sub ( 1 ) ; } if ( ! _investorData . investorListed [ _to ] && ( _to != address ( 0 ) ) ) { _investorData . investors . push ( _to ) ; _investorData . investorListed [ _to ] = true ; } }
","Keeps track of the number of non-zero token holders
"
"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . transferOwnership ( msg . sender ) ; emit CreatedToken ( _tokenSymbol , address ( newToken ) ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the owner of this clone token
"
"function approveProposal ( uint _proposalId ) public onlyAdmins { require ( proposals . length > _proposalId ) ; require ( ! proposals [ _proposalId ] . denied ) ; Proposal storage p = proposals [ _proposalId ] ; require ( ! p . approved ) ; p . token = tokenFactory . createCloneToken ( nectarToken , getBlockNumber ( ) , appendUintToString ( ""NectarProposal-"" , _proposalId ) , MiniMeToken ( nectarToken ) . decimals ( ) , appendUintToString ( ""NP-"" , _proposalId ) , true ) ; p . approved = true ; p . startTime = now ; p . startBlock = getBlockNumber ( ) ; emit Approved ( _proposalId ) ; }
","Admins are able to approve proposal that someone submitted
"
"function _addToken ( address _to , uint256 _tokenId ) private { uint256 newTokenIndex = ownedTokens [ _to ] . length ; ownedTokens [ _to ] . push ( _tokenId ) ; require ( newTokenIndex == uint256 ( uint32 ( newTokenIndex ) ) , ""overflow"" ) ; tokenOwnerAndTokensIndex [ _tokenId ] = AddressAndTokenIndex ( { owner : _to , tokenIndex : uint32 ( newTokenIndex ) } ) ; }
","Internal function to add a token ID to the list of a given address
"
"function changeAllowAllTransfers ( bool _allowAllTransfers ) public withPerm ( FLAGS ) { allowAllTransfers = _allowAllTransfers ; emit LogAllowAllTransfers ( _allowAllTransfers ) ; }
","Used to change the flag true - It refers there are no transfer restrictions , for any addresses false - It refers transfers are restricted for all addresses .
"
"function getNumberOfAssets ( ) public view returns ( uint ) { return numberOfAssets ; }
","Function to fetch total number of assets
"
"function transferPreSigned ( bytes _signature , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( signatures [ _signature ] == false ) ; require ( block . number <= _validUntil ) ; bytes32 hashedTx = transferPreSignedHashing ( address ( this ) , _to , _value , _fee , _nonce , _validUntil ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; balances [ from ] = balances [ from ] . sub ( _value ) . sub ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Transfer ( from , _to , _value ) ; emit Transfer ( from , msg . sender , _fee ) ; emit TransferPreSigned ( from , _to , msg . sender , _value , _fee ) ; return true ; }
","Submit a presigned transfer
"
"function isNotaryAdditionValid ( address order , address notary , uint256 responsesPercentage , uint256 notarizationFee , string notarizationTermsOfService , bytes notarySignature ) public pure returns ( bool ) { require ( order != address ( 0 ) ) ; require ( notary != address ( 0 ) ) ; bytes32 hash = keccak256 ( abi . encodePacked ( order , responsesPercentage , notarizationFee , notarizationTermsOfService ) ) ; return isSignedBy ( hash , notary , notarySignature ) ; }
","Checks if the notary 's signature to be added to the DataOrder is valid .
"
"function withdraw ( address _recipient ) public returns ( bool ) { require ( shares [ _recipient ] > 0 ) ; require ( totalAtWithdrawal [ _recipient ] < totalReceived ) ; uint left = totalReceived . sub ( totalAtWithdrawal [ _recipient ] ) ; uint share = left . mul ( shares [ _recipient ] ) . div ( 10000 ) ; totalAtWithdrawal [ _recipient ] = totalReceived ; ERC20 ( holdingToken ) . transfer ( _recipient , share ) ; return true ; }
","Method to withdraw shared part of received tokens for providen address
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","Send `` _value '' tokens to `` _to '' from `` msg.sender '' .
"
"function approve ( address _to , uint256 _deedId ) external payable ;
","Set the `` approved taker '' for your deed , or revoke approval by setting the zero address .
"
"function transferFrom ( address from , address to , uint tokens ) public tokenTradingMustBeLive ( from ) returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; Transfer ( from , to , tokens ) ; return true ; }
","Transfer tokens from an address to another through an allowance made beforehand
"
"function freezeAmount ( address target , uint256 _value ) onlyOwner public { require ( _value > 0 ) ; frozenAmount [ target ] = _value ; emit FrozenAmt ( target , _value ) ; }
","Freeze ` _value ` of ` target ` balance
"
"function destroy ( ) public onlyOwner { selfdestruct ( owners [ 0 ] ) ; }
","Allows to destroy the contract and return the tokens to the owner .
"
"function link ( address _newAddress ) internal returns ( bool ) { currentApplicationEntityAddress = _newAddress ; currentApp = ApplicationEntityABI ( currentApplicationEntityAddress ) ; if ( ! currentApp . initialize ( ) ) { revert ( ) ; } EventGatewayNewAddress ( currentApplicationEntityAddress ) ; return true ; }
","Link to new Application Entity
"
"function createSingleSeedAuction ( uint8 _teamId , uint8 _posId , uint256 _attributes , uint256 _playerOverrideId , uint256 _mlbPlayerId , uint256 _startPrice , uint256 _endPrice , uint256 _saleDuration ) public onlyGameManager whenNotPaused { require ( nonFungibleContract != address ( 0 ) ) ; require ( _teamId != 0 ) ; uint256 nftId = nonFungibleContract . createSeedCollectible ( _teamId , _posId , _attributes , address ( this ) , 0 , _playerOverrideId , _mlbPlayerId ) ; uint256 startPrice = 0 ; uint256 endPrice = 0 ; uint256 duration = 0 ; if ( _startPrice == 0 ) { startPrice = _computeNextSeedPrice ( 0 , _teamId ) ; } else { startPrice = _startPrice ; } if ( _endPrice != 0 ) { endPrice = _endPrice ; } else { endPrice = 0 ; } if ( _saleDuration == 0 ) { duration = SALES_DURATION ; } else { duration = _saleDuration ; } _createSale ( nftId , startPrice , endPrice , duration , address ( this ) ) ; }
","Creates a new Collectible and creates an auction for it .
"
"function addChunk5ToWhiteList ( ) external onlyOwner { require ( ! chunk5IsAdded ) ; addToWhitelist ( 0x439f5420d4eD1DE8c982100Fcf808C5FcEeC1bFa , 1.25 ether ) ; addToWhitelist ( 0xfd5D41Dad5218C312d693a8b6b1128889cFFec43 , 1.25 ether ) ; addToWhitelist ( 0x1FBB99bf7E6e8920Fac8Ab371cEB5A90e0801656 , 1.5 ether ) ; addToWhitelist ( 0x6d767fE3e87b6Ffb762cd46138aaaB48a6788d06 , 1.5 ether ) ; addToWhitelist ( 0x9C299486fc9b5B1bA1dbE2d6D93E3580f9A64995 , 1.5 ether ) ; addToWhitelist ( 0x009e511c89e033142bdd1f34f7cad0f3e188696d , 2 ether ) ; addToWhitelist ( 0x25929fF98a1e8D7d1c14674bD883A24C26FB1df4 , 2 ether ) ; addToWhitelist ( 0x2a54850a5166d2fCC805B78A1D436b96e4477e09 , 2 ether ) ; addToWhitelist ( 0x3D212E369e08fB9D5585a35449595df044cdD7a4 , 2 ether ) ; addToWhitelist ( 0x417EcaE932D3bAE2d93a2af6dA91441d46532A7C , 2 ether ) ; addToWhitelist ( 0x53070A3A5faF50280563ea4fB4b5e6AcA53B7221 , 2 ether ) ; addToWhitelist ( 0x67314b5CdFD52A1D5c4794C02C5b3b2cc4bdc21B , 2 ether ) ; addToWhitelist ( 0x67fb2006dd8990de950d1eb41f07ff7f929c3bca , 2 ether ) ; addToWhitelist ( 0x76b3a5aad6aD161680F9e7C9dd09bA9626135765 , 2 ether ) ; addToWhitelist ( 0x77446d3Df1216B1e8Ea1913203B05F5cb182B112 , 2 ether ) ; addToWhitelist ( 0x788b7433ddf168544b2adae3c6aa416d3f6fa112 , 2 ether ) ; addToWhitelist ( 0x790310b3f668019056a8b811ced6e2a0af533660 , 2 ether ) ; addToWhitelist ( 0x7dD1b95E76F7893002E4FB9a533628994b703479 , 2 ether ) ; addToWhitelist ( 0x821578e6212651CAa996184404787ccC09C71014 , 2 ether ) ; addToWhitelist ( 0x8b91B39Ef4ae08bEacC128d3C2e19140AbD0245F , 2 ether ) ; addToWhitelist ( 0x8f566cdE6724DEA78756B8C252055e6eA7D3d7a4 , 2 ether ) ; addToWhitelist ( 0x90f7f982c2Ab40534e5E3bE449967B716ef04BB1 , 2 ether ) ; addToWhitelist ( 0x91FDae97a5a3Ba806fA3Eb8B3cd3F0bEE6431b77 , 2 ether ) ; addToWhitelist ( 0x99cf8060BaFca88C04Aa2Eace46CA880bE75F166 , 2 ether ) ; addToWhitelist ( 0xa099638b5CFE746C0B3DD1a3998051c2Ac1F3dC8 , 2 ether ) ; addToWhitelist ( 0xb9a2ACF30FB774881371F249928Cb48Ccc184bAC , 2 ether ) ; addToWhitelist ( 0xC301Fc1acCF9ab89Fa68Fd240dCDaa0Bd9a3658F , 2 ether ) ; addToWhitelist ( 0xc4f5bFad8Ec83Bcd4AB3b3a27266f08b4517f59B , 2 ether ) ; addToWhitelist ( 0xd1EA23d6713ca22cc1f2e10dc6FD8B1DfB65b563 , 2 ether ) ; addToWhitelist ( 0xd4F2ad288874653F09e3Cc522C1106692E30394C , 2 ether ) ; addToWhitelist ( 0xddF81dabe498118df262b1b907492b391211321e , 2 ether ) ; addToWhitelist ( 0xE4fBc54c0a08a5d0CD1EEBC8bf0Ea48fdBFd7E0c , 2 ether ) ; addToWhitelist ( 0xf42F3c005B1723782FC25E5771748a6A1fff5e03 , 2 ether ) ; addToWhitelist ( 0xff7ef21aC94961a3C9F71a3deFFfe2f58e102E1f , 2 ether ) ; addToWhitelist ( 0xa27A60769B426b1eEA3be951DF29D352B48ec5Da , 2.5 ether ) ; addToWhitelist ( 0xba334469f45f8e0ca1d61fa036fece3b4d5ec0f7 , 2.5 ether ) ; addToWhitelist ( 0xdE47f3C16cDb757027F61D07a44c881d2D32B161 , 2.5 ether ) ; addToWhitelist ( 0xfCD47A33207eD5a03390330Fd6EcFF2DFf8F5a2b , 2.5 ether ) ; addToWhitelist ( 0x27fcA80168B7eDC487B22F0F334BA922d1e26E2D , 3 ether ) ; addToWhitelist ( 0x36bd14eaf211d65164e1e0a2eab5c98b4b734875 , 3 ether ) ; addToWhitelist ( 0x3D1a96c1fE8D1281537c5A8C93A89215DF254d3f , 3 ether ) ; addToWhitelist ( 0x40ED9F03BFfFA1cB30E36910907cd55ac27Be05d , 3 ether ) ; addToWhitelist ( 0x5Da227c19913F4deEB64A6E7fE41B30B230161D2 , 3 ether ) ; addToWhitelist ( 0x7e443aA16aC53419CFd8056Bcc30b674864Ac55F , 3 ether ) ; addToWhitelist ( 0x80F30bAc95966922f1E8c66c0fD088959a00f15f , 3 ether ) ; addToWhitelist ( 0x8862004b5a7C21B8F771AF3213b79bD9b81f9DA0 , 3 ether ) ; addToWhitelist ( 0x904063eF93eEEd9584f6B0131F9FD047d7c3C28d , 3 ether ) ; addToWhitelist ( 0xa14aC1A9B3D52aBD0652C5Aca346099A6eb16b54 , 3 ether ) ; addToWhitelist ( 0xA2Ef14F0d1ae84609Cd104feB91EAeD4B39C4852 , 3 ether ) ; addToWhitelist ( 0xA4D1905ceF480Fb9089578F88D3C128cf386ebd5 , 3 ether ) ; addToWhitelist ( 0xa5D5404864E9eA3104ec6721CA08E563964Ae536 , 3 ether ) ; addToWhitelist ( 0xB3ADF1FB9c488DBB42378876ff4Fc2be4c1B4365 , 3 ether ) ; chunk5IsAdded = true ; }
","Add chunk 5 / 7 to the whitelist
"
"function computeIssuanceData ( uint preBalance , IssuanceData preIssuance ) internal view returns ( IssuanceData ) { uint currentBalanceSum = preIssuance . currentBalanceSum ; uint lastAverageBalance = preIssuance . lastAverageBalance ; uint lastModified = preIssuance . lastModified ; if ( lastModified < feePeriodStartTime ) { if ( lastModified < lastFeePeriodStartTime ) { lastAverageBalance = preBalance ; } else { uint timeUpToRollover = feePeriodStartTime - lastModified ; uint lastFeePeriodDuration = feePeriodStartTime - lastFeePeriodStartTime ; uint lastBalanceSum = safeAdd ( currentBalanceSum , safeMul ( preBalance , timeUpToRollover ) ) ; lastAverageBalance = lastBalanceSum / lastFeePeriodDuration ; } currentBalanceSum = safeMul ( preBalance , now - feePeriodStartTime ) ; } else { currentBalanceSum = safeAdd ( currentBalanceSum , safeMul ( preBalance , now - lastModified ) ) ; } return IssuanceData ( currentBalanceSum , lastAverageBalance , now ) ; }
","Compute the new IssuanceData on the old balance
"
"function setRate ( uint256 _rate ) public onlyOwner { require ( _rate > 0 ) ; rate = _rate ; emit NewRate ( rate ) ; }
","Update the ETH-to-LPC exchange rate
"
"function isPolicyExist ( bytes32 _policyHash ) public view returns ( bool ) { return policyId2Index [ _policyHash ] != 0 ; }
","Check is policy exist
"
"function darknodeOwner ( address darknodeID ) external view onlyOwner returns ( address ) { return darknodeRegistry [ darknodeID ] . owner ; }
","Returns the owner of a given darknode .
"
"function offer_energy ( uint32 aday , uint32 aprice , uint64 aenergy , uint64 atimestamp ) onlyRegisteredProducers external { require ( aenergy >= kWh ) ; uint idx = bidsIndex [ msg . sender ] [ aday ] ; if ( ( bids . length > idx ) && ( bids [ idx ] . producer == msg . sender ) && ( bids [ idx ] . day == aday ) ) { require ( atimestamp > bids [ idx ] . timestamp ) ; emit BidRevoked ( bids [ idx ] . producer , bids [ idx ] . day , bids [ idx ] . price , bids [ idx ] . energy ) ; } idx = bids . length ; bidsIndex [ msg . sender ] [ aday ] = idx ; bids . push ( Bid ( { producer : msg . sender , day : aday , price : aprice , energy : aenergy , timestamp : atimestamp } ) ) ; emit BidMade ( bids [ idx ] . producer , bids [ idx ] . day , bids [ idx ] . price , bids [ idx ] . energy ) ; }
","Offer ` ( aenergy / 1.0e6 ) .toFixed ( 6 ) ` kWh of energy for day ` aday ` at a price ` ( aprice / 1.0e3 ) .toFixed ( 3 ) + ' ct/kWh ' ` above market price for a date given as day ` aday ` whilst asserting that the current date and time in nanoseconds since 1970 is ` atimestamp ` .
"
"function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) { return 30636000000 ; }
","maximum investments to be accepted during the sale ( in euro-cents )
"
"function register ( string _nameString ) external payable isHuman ( ) { bytes32 _name = _nameString . nameFilter ( ) ; address _agent = msg . sender ; require ( msg . value >= 10000000000000000 ) ; require ( agentxName_ [ _name ] == address ( 0 ) ) ; if ( ! player [ _agent ] . isAgent ) { agents += 1 ; player [ _agent ] . isAgent = true ; player [ _agent ] . id = agents ; player [ _agent ] . level = 1 ; agentxID_ [ agents ] = _agent ; } player [ _agent ] . name = _name ; agentxName_ [ _name ] = _agent ; if ( ! community . send ( msg . value ) ) { pot = pot . add ( msg . value ) ; } }
","Register a name by a human player
"
"function _setPaused ( bool requestedState ) public returns ( uint ) { if ( msg . sender != anchorAdmin ) { return failOracle ( 0 , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PAUSED_OWNER_CHECK ) ; } paused = requestedState ; emit SetPaused ( requestedState ) ; return uint ( Error . NO_ERROR ) ; }
","set ` paused ` to the specified state
"
"function transferFrom ( address from , address to , uint256 amount ) public returns ( bool success ) ;
","Send ` amount ` tokens to ` to ` from ` from ` on the condition it is approved by ` from `
"
"function retire ( address _to ) onlyOwner whenPaused public { require ( now > lastDepositTime . add ( commissionExpiryTime ) ) ; _to . transfer ( this . balance ) ; retired = true ; }
","retire the contract ( dangerous )
"
"function halvingStartBlock ( uint256 _halving ) public constant notBeforeGenesis returns ( uint256 ) { return _halving . mul ( subsidyHalvingInterval ) ; }
","Compute the starting block of a halving
"
"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) { return false ; } allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function getNumberOfAssetPacks ( ) public view returns ( uint ) { return numberOfAssetPacks ; }
","Function to fetch total number of assetpacks
"
"function withdrawMarginPreSignedHashing ( address _investContract , address _from , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x7701c52d ) , _investContract , _from , _value , _fee , _nonce , _validUntil ) ) ; }
","Hash ( keccak256 ) of the payload used by withdrawMarginPreSigned
"
"function transferOwnership ( address _newOwner ) public onlyOwner { require ( _newOwner != address ( 0 ) , ""newOwner cannot be zero address"" ) ; owner = _newOwner ; }
","Transfers ownership to new owner address
"
"function getTimeBonus ( uint256 value ) view public returns ( uint256 ) { uint256 maxBonus = value . mul ( baseRate ) . mul ( maxTimeBonusPercent ) . div ( PERCENT_DIVIDER ) ; return maxBonus . mul ( endTimestamp - now ) . div ( endTimestamp - startTimestamp ) ; }
","Calculates current time bonus
"
"function whitelistedSenderAddresses ( ) external view returns ( address [ NUMBER_OF_CHOICES ] ) { return whitelistedSenderAdresses ; }
","Return array of allowed voter addresses .
"
"function changePermission ( address _delegate , address _module , bytes32 _perm , bool _valid ) public withPerm ( CHANGE_PERMISSION ) returns ( bool ) { require ( delegateDetails [ _delegate ] != bytes32 ( 0 ) , ""Delegate details not set"" ) ; perms [ _module ] [ _delegate ] [ _perm ] = _valid ; emit LogChangePermission ( _delegate , _module , _perm , _valid , now ) ; return true ; }
","Use to provide/change the permission to the delegate corresponds to the module contract
"
"function addTokens ( bytes16 _uuid , uint256 _tokensCount ) onlyAllowedAddresses whenNotPaused external { rntTokenVault . addTokensToAccount ( _uuid , _tokensCount ) ; rntToken . transferFrom ( owner , address ( rntTokenVault ) , _tokensCount ) ; }
","Function for adding tokens to account .
"
"function buyOilFactory ( ) public payable returns ( uint256 ) { return buyFactory ( FactoryType . Oil ) ; }
","buy wood factory
"
"function purgeUpgrade ( ) public onlyAssetOwner returns ( bool ) { if ( pendingVersion == 0x0 ) { return false ; } delete pendingVersion ; delete pendingVersionTimestamp ; return true ; }
","Cancel the pending upgrade process .
"
"function getPermissionParam ( address _entity , address _app , bytes32 _role , uint _index ) external view returns ( uint8 , uint8 , uint240 ) { Param storage param = permissionParams [ permissions [ permissionHash ( _entity , _app , _role ) ] ] [ _index ] ; return ( param . id , param . op , param . value ) ; }
","Get parameter for permission
"
"function getAddress ( string _nameKey ) view public returns ( address ) { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; require ( storedAddresses [ key ] != address ( 0 ) , ""Invalid address key"" ) ; return storedAddresses [ key ] ; }
","Get the contract address
"
"function airdropMinting ( address [ ] _to_list , uint [ ] _values ) public { require ( msg . sender == owner ) ; require ( _to_list . length == _values . length ) ; for ( uint i = 0 ; i < _to_list . length ; i ++ ) { mintToken ( _to_list [ i ] , _values [ i ] ) ; } }
","Will allow multiple minting within a single call to save gas .
"
"function newRepo ( string _name , address _dev ) public auth ( CREATE_REPO_ROLE ) returns ( Repo ) { return _newRepo ( _name , _dev ) ; }
","Create new repo in registry with ` _name `
"
"function balanceOf ( address account ) public view returns ( uint balance ) { return lib . getTokenBalance ( lib . getTokenSymbol ( address ( this ) ) , account ) ; }
","Gets balance of account
"
"function ( ) external payable { assembly { let _poaTokenMaster := sload ( poaTokenMaster_slot ) calldatacopy ( 0x0 , 0x0 , calldatasize ) let result := delegatecall ( gas , _poaTokenMaster , 0x0 , calldatasize , 0x0 , 0 ) if iszero ( result ) { revert ( 0 , 0 ) } returndatacopy ( 0x0 , 0x0 , returndatasize ) return ( 0x0 , returndatasize ) } }
","Fallback function for all proxied functions using `` delegatecall ( ) '' .
"
"function transferMultiple ( address _to , uint256 [ ] _deedIds ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( _owns ( msg . sender , _deedId ) ) ; _transfer ( msg . sender , _to , _deedId ) ; } }
","Transfers multiple deeds to another address .
"
"function frozenTransferFrom ( address _from , address _to , uint256 _value , uint thawTS , bool isKYCRequired ) external validAddress ( _to ) validUnixTS ( thawTS ) payloadSizeIs ( 5 * 32 ) privilegedAllowed checkTransferInvariant ( _from , _to ) returns ( bool ) { require ( isSale ( msg . sender ) && isSale ( _to ) ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; subFrozen ( _from , _value , thawTS , isKYCRequired ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }
","Transfers frozen tokens back .
"
"function burnFrom ( address _from , uint256 _value ) public onlyOwner returns ( bool success ) { bool bAccountFrozen = frozenAccount ( _from ) ; if ( bAccountFrozen ) { freezeAccount ( _from , false ) ; } _transfer ( _from , _owner , _value ) ; if ( bAccountFrozen ) { freezeAccount ( _from , bAccountFrozen ) ; } burn ( _value ) ; return true ; }
","Destroy tokens from other account , can be run only by owner Remove ` _value ` tokens from the system irreversibly on behalf of ` _from ` .
"
"function getValidity ( Campaign storage _campaign ) internal view returns ( bool _valid ) { return _campaign . valid ; }
","Get campaign validity
"
"function deleteDelegate ( address _delegate ) external ;
","Used to delete a delegate
"
"function forceTransfer ( Data storage self , string currency , address from , address to , uint amount , bytes data ) internal returns ( bool success ) { require ( address ( to ) != 0x0 , ""Error: `to` address must not be null."" ) ; bytes32 id_a = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , from ) ) ) ; bytes32 id_b = keccak256 ( abi . encodePacked ( 'token.balance' , currency , getForwardedAccount ( self , to ) ) ) ; require ( self . Storage . setUint ( id_a , self . Storage . getUint ( id_a ) . sub ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; require ( self . Storage . setUint ( id_b , self . Storage . getUint ( id_b ) . add ( amount ) ) , ""Error: Unable to set storage value. Please ensure contract has allowed permissions with storage contract."" ) ; emit Transfer ( currency , from , to , amount , data ) ; return true ; }
","Low-level transfer method
"
"function claimTokens ( address _token ) public onlyController { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } MiniMeToken token = MiniMeToken ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function renounceOwnership ( ) public onlyAdmin { burnAdmin = address ( 0 ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function getAllDelegatesWithPerm ( address _module , bytes32 _perm ) external view returns ( address [ ] ) ;
","Used to return all delegates with a given permission and module
"
"function lockCurrentApp ( ) internal { if ( ! currentApp . lock ( ) ) { revert ( ) ; } }
","Locks current application entity
"
"function withdrawOperationFees ( uint32 [ ] _dates ) external { require ( msg . sender == owner ) ; uint256 withdrawAmount = 0 ; uint256 datesLength = _dates . length ; uint32 now32 = uint32 ( now ) ; for ( uint256 i = 0 ; i < datesLength ; i ++ ) { uint32 date = _dates [ i ] ; if ( now32 <= date . add ( WITHDRAW_BUFFER ) ) { continue ; } if ( dateToContestStatus [ date ] . operationFeeWithdrawn ) { continue ; } dateToContestStatus [ date ] . operationFeeWithdrawn = true ; withdrawAmount = withdrawAmount . add ( calculateOperationFee ( date ) ) ; } if ( withdrawAmount > 0 ) { msg . sender . transfer ( withdrawAmount ) ; } LogOperationFeeWithdraw ( msg . sender , withdrawAmount ) ; }
","Changes state , owner only
"
"function proxyPayment ( address ) public payable returns ( bool ) { require ( msg . sender == address ( token ) , ERROR_PROXY_PAYMENT_WRONG_SENDER ) ; return false ; }
","Called when ether is sent to the MiniMe Token contract
"
"function buy ( address _to ) public validAddress ( _to ) isNotFinalized payable { uint256 _amount = msg . value ; assert ( _amount > 0 ) ; uint256 _tokens = _amount . mul ( rate ) ; assert ( totalSupply . add ( _tokens ) <= totalMaxBuy ) ; totalSupply = totalSupply . add ( _tokens ) ; totalETH = totalETH . add ( _amount ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _tokens ) ; wallet . transfer ( _amount ) ; Buy ( msg . sender , _to , rate , _tokens ) ; Transfer ( this , _to , _tokens ) ; FundTransfer ( msg . sender , _amount , true ) ; }
","This function sends B2BK tokens to the specified address when sending ETH
"
"function approve ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _owns ( msg . sender , _tokenId ) ) ; require ( warriors [ _tokenId ] . action == IDLE ) ; _approve ( _tokenId , _to ) ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer a specific Warrior via transferFrom ( ) .
"
"function updateContract ( string _contractName , address _newAddress ) external onlyContractOwner ( ""ContractManager"" , msg . sender ) { bytes memory contractNameBytes = bytes ( _contractName ) ; require ( contractNameBytes . length != 0 ) ; require ( contracts [ _contractName ] != address ( 0 ) ) ; require ( _newAddress != address ( 0 ) ) ; address oldAddress = contracts [ _contractName ] ; contracts [ _contractName ] = _newAddress ; emit ContractUpdated ( oldAddress , _newAddress , _contractName ) ; }
","Update an existing contract ( changing the address )
"
"function refund ( ) ;
","Function to refund after the closing time with 'msg.sender ' as 'beneficiary '
"
"function destroy ( ) public onlyOwner { selfdestruct ( owner ) ; }
","Allows to destroy the contract and return the tokens to the owner .
"
"function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { if ( ! oasis . isActive ( data . offerId ) ) { return false ; } address pay_gem ; address buy_gem ; ( , pay_gem , , buy_gem ) = oasis . getOffer ( data . offerId ) ; bool isBuyOrPayWeth = pay_gem == address ( weth ) || buy_gem == address ( weth ) ; if ( ! isBuyOrPayWeth ) { return false ; } return true ; }
","Perform exchange-specific checks on the given order
"
"function removeNFToken ( address _from , uint256 _tokenId ) internal { require ( nft [ _tokenId ] . owner == _from , ""from address must be owner of tokenId"" ) ; uint256 [ ] storage tokenList = ownerToTokenList [ _from ] ; assert ( tokenList . length > 0 ) ; for ( uint256 i = 0 ; i < tokenList . length ; i ++ ) { if ( tokenList [ i ] == _tokenId ) { tokenList [ i ] = tokenList [ tokenList . length - 1 ] ; delete tokenList [ tokenList . length - 1 ] ; tokenList . length -- ; break ; } } delete nft [ _tokenId ] . owner ; }
","Use and override this function with caution .
"
"function revealCeiling ( uint256 _limit , uint256 _slopeFactor , uint256 _collectMinimum , bool _last , bytes32 _salt ) public { require ( ! allRevealed ) ; require ( ceilings [ revealedCeilings ] . hash == calculateHash ( _limit , _slopeFactor , _collectMinimum , _last , _salt ) ) ; require ( _limit != 0 && _slopeFactor != 0 && _collectMinimum != 0 ) ; if ( revealedCeilings > 0 ) { require ( _limit >= ceilings [ revealedCeilings . sub ( 1 ) ] . limit ) ; } ceilings [ revealedCeilings ] . limit = _limit ; ceilings [ revealedCeilings ] . slopeFactor = _slopeFactor ; ceilings [ revealedCeilings ] . collectMinimum = _collectMinimum ; revealedCeilings = revealedCeilings . add ( 1 ) ; if ( _last ) { allRevealed = true ; } }
","Anybody can reveal the next ceiling if he knows it .
"
"function transferForeignToken ( address _tokenAddress , address _recipient , uint256 _amount ) public onlyAdmin nonZeroAddress ( _recipient ) returns ( bool ) { require ( _tokenAddress != address ( this ) , ""token address can't be this contract"" ) ; ERC20Interface eI = ERC20Interface ( _tokenAddress ) ; require ( eI . transfer ( _recipient , _amount ) , ""token transfer failed"" ) ; emit ForeignTokenTransfer ( msg . sender , _recipient , _amount ) ; return true ; }
","Allow us to transfer tokens that someone might 've accidentally sent to this contract
"
"function claim ( ) public notBeforeGenesis notPaused isMiner ( msg . sender ) returns ( uint256 ) { return claimHalvingsSubsidies ( claimableHalvings ( ) ) ; }
","Claim all the unclaimed halving subsidies of a miner
"
"function getMinInvestment ( ) public constant returns ( uint ) { return 10 finney ; }
","minimal amount of investment
"
"function updateWhitelistedContribution ( uint256 plannedContribution ) private { whitelistedPlannedContributions = whitelistedPlannedContributions . sub ( plannedContribution ) ; WhitelistedCounterUpdated ( whitelistedPlannedContributions , plannedContribution ) ; }
","Updates the whitelistedPlannedContributions counter , subtracting the contribution about to be applied .
"
"function sendEther ( address to , uint value ) external validAddress ( to ) onlymanyowners ( keccak256 ( msg . data ) ) requiresState ( State . SUCCEEDED ) { require ( value > 0 && this . balance >= value ) ; to . transfer ( value ) ; EtherSent ( to , value ) ; }
","owners : send ` value ` of ether to address ` to ` , can be called if crowdsale succeeded
"
"function initialize ( VEN _ven , address _ethVault , address _venVault , uint256 _channelsLimit , uint _startTime , uint _endTime , uint _earlyStageLasts ) onlyOwner { require ( stage ( ) == Stage . Created ) ; require ( _ven . owner ( ) == address ( this ) ) ; require ( address ( _ethVault ) != 0 ) ; require ( address ( _venVault ) != 0 ) ; require ( _startTime > blockTime ( ) ) ; require ( _startTime . add ( _earlyStageLasts ) < _endTime ) ; ven = _ven ; ethVault = _ethVault ; venVault = _venVault ; channelsLimit = _channelsLimit ; officialLimit = publicSupply . sub ( _channelsLimit ) ; startTime = _startTime ; endTime = _endTime ; earlyStageLasts = _earlyStageLasts ; ven . mint ( venVault , reservedForTeam . add ( reservedForOperations ) , false ) ; ven . mint ( venVault , privateSupply . add ( commercialPlan ) , true ) ; initialized = true ; onInitialized ( ) ; }
","initialize to prepare for sale
"
"function getPackage ( uint idPackage ) constant public returns ( string name , DAppNodePackageStatus status ) { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; name = c . name ; status = c . status ; }
","Returns the information of a DAppNode package
"
"function performSellOrder ( OrderData data , uint256 amountToSpend ) public whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { uint256 maxPayGem ; address payGem ; uint256 maxBuyGem ; address buyGem ; ( maxPayGem , payGem , maxBuyGem , buyGem ) = oasis . getOffer ( data . offerId ) ; if ( payGem != address ( weth ) ) { errorReporter . revertTx ( ""payGem != address(weth)"" ) ; } approveAddress ( address ( oasis ) , address ( buyGem ) ) ; uint256 amountToBuy = SafeMath . div ( SafeMath . mul ( amountToSpend , maxPayGem ) , maxBuyGem ) ; if ( amountToBuy == 0 ) { ERC20 ( buyGem ) . transfer ( totlePrimary , amountToSpend ) ; return ( 0 , 0 ) ; } if ( ! oasis . buy ( data . offerId , amountToBuy ) ) { errorReporter . revertTx ( ""Oasis buy failed"" ) ; } uint256 newMaxPayGem ; uint256 newMaxBuyGem ; ( newMaxPayGem , , newMaxBuyGem , ) = oasis . getOffer ( data . offerId ) ; amountReceivedFromOrder = maxPayGem - newMaxPayGem ; amountSpentOnOrder = maxBuyGem - newMaxBuyGem ; if ( amountSpentOnOrder < amountToSpend ) { ERC20 ( buyGem ) . transfer ( totlePrimary , amountToSpend - amountSpentOnOrder ) ; } weth . withdraw ( amountReceivedFromOrder ) ; totlePrimary . transfer ( amountReceivedFromOrder ) ; }
","Perform a sell order at the exchange
"
"function setFreezeOracle ( bool _frozen ) onlyOwner public { freezeOracle = _frozen ; }
","Allows owner to set oracle to ignore all Oraclize pricce updates
"
"function buy ( ) public payable nonReentrant returns ( uint ) { address investor = msg . sender ; uint256 payment = msg . value ; require ( payment >= c_MinInvestment ) ; require ( now < 1507766400 ) ; uint stq = payment . mul ( c_STQperETH ) ; m_token . mint ( investor , stq ) ; m_funds . transfer ( payment ) ; FundTransfer ( investor , payment , true ) ; return stq ; }
","ICO participation
"
"function addManualBlocking ( address _from , address _to , uint256 _expiryTime ) public withPerm ( TRANSFER_APPROVAL ) { require ( _from != address ( 0 ) , ""Invalid from address"" ) ; require ( _to != address ( 0 ) , ""Invalid to address"" ) ; require ( _expiryTime > now , ""Invalid expiry time"" ) ; require ( manualBlockings [ _from ] [ _to ] . expiryTime == 0 , ""Blocking already exists"" ) ; manualBlockings [ _from ] [ _to ] = ManualBlocking ( _expiryTime ) ; emit AddManualBlocking ( _from , _to , _expiryTime , msg . sender ) ; }
","Adds a pair of addresses to manual blockings
"
"function currentMigrationTarget ( ) public constant returns ( IMigrationTarget ) { return _migration ; }
","returns current migration target
"
"function transferWithSignature ( address _to , uint256 _amount , uint256 _fee , bytes _data , uint256 _nonce , bytes _sig ) public returns ( bool ) { doSendWithSignature ( _to , _amount , _fee , _data , _nonce , _sig , false ) ; return true ; }
","transfers tokens in ERC20 compatible way using signature to recover token sender
"
"function tokenURI ( uint256 _tokenId ) external view returns ( string ) ;
","A distinct Uniform Resource Identifier ( URI ) for a given asset .
"
"function forceTransfer ( address _from , address _to , uint256 _value , bytes _data , bytes _log ) public onlyController { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; bool verified = _updateTransfer ( _from , _to , _value , _data ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit ForceTransfer ( msg . sender , _from , _to , _value , verified , _log ) ; emit Transfer ( _from , _to , _value ) ; }
","Used by a controller to execute a forced transfer
"
"function setFeeReceiver ( address _feeReceiver ) public onlyOwner { require ( _feeReceiver != address ( 0 ) , ""zero address is not allowed"" ) ; feeReceiver = _feeReceiver ; }
","Not for public use !
"
"function isAllowedAsset ( address asset , string currency ) public view returns ( bool allowed ) { if ( isTokenXContract ( asset , currency ) ) { return true ; } else { bytes32 id = keccak256 ( abi . encodePacked ( 'allowed.stable.asset' , asset , currency ) ) ; return lib . Storage . getBool ( id ) ; } }
","Return boolean if the asset is an allowed stable asset for the corresponding currency
"
"function symbol ( ) external view returns ( string ) { return _symbol ; }
","An abbreviated name for NFTs in this contract
"
"function onTransfer ( address _from , address _to , uint _amount ) returns ( bool ) ;
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function hasError ( ) public onlyManager whenPaused { error = true ; }
","This is public rather than external so it can be called by derived contracts .
"
"function ( ) external payable { }
","Direct donations
"
"function distributeBonuses ( uint _amount ) public onlyDistributionSource returns ( uint ) { ERC20Interface _bonusToken = ERC20Interface ( bonusToken ) ; if ( _bonusToken . allowance ( msg . sender , address ( this ) ) < _amount ) { return _emitError ( PROFITEROLE_ERROR_INSUFFICIENT_DISTRIBUTION_BALANCE ) ; } if ( ! _bonusToken . transferFrom ( msg . sender , wallet , _amount ) ) { return _emitError ( PROFITEROLE_ERROR_TRANSFER_ERROR ) ; } if ( firstDepositDate == 0 ) { firstDepositDate = now ; } uint _lastDepositDate = lastDepositDate ; if ( _lastDepositDate != 0 ) { distributionDeposits [ _lastDepositDate ] . nextDepositDate = now ; } lastDepositDate = now ; distributionDeposits [ now ] = Deposit ( _amount , _amount , 0 ) ; Treasury ( treasury ) . addDistributionPeriod ( ) ; DepositPendingAdded ( _amount , msg . sender , now ) ; return OK ; }
","Makes checkmark and deposits tokens on profiterole account to pay them later as bonuses for Treasury shares holders .
"
"function ownerOf ( uint _tokenId ) external view returns ( address owner ) { owner = rabbitToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
","Returns the address currently assigned ownership of a given Rabbit .
"
"function collectionOf ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( uint256 ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return pixelcons [ tokenLookup [ _tokenId ] . tokenIndex ] . collectionIndex ; }
","Get the collection index of PixelCon ` ( _tokenId ) `
"
"function performRebalance ( Trade [ ] trades ) public payable whenNotPaused { TradeFlag [ ] memory tradeFlags = initialiseTradeFlags ( trades ) ; staticChecks ( trades , tradeFlags ) ; transferTokens ( trades , tradeFlags ) ; uint256 etherBalance = msg . value ; for ( uint256 i ; i < trades . length ; i ++ ) { Trade memory thisTrade = trades [ i ] ; TradeFlag memory thisTradeFlag = tradeFlags [ i ] ; CurrentAmounts memory amounts = CurrentAmounts ( { amountSpentOnTrade : 0 , amountReceivedFromTrade : 0 , amountLeftToSpendOnTrade : thisTrade . isSell ? thisTrade . tokenAmount : calculateMaxEtherSpend ( thisTrade , etherBalance ) } ) ; performTrade ( thisTrade , thisTradeFlag , amounts ) ; if ( amounts . amountReceivedFromTrade == 0 && thisTrade . optionalTrade ) { continue ; } if ( ! checkIfTradeAmountsAcceptable ( thisTrade , amounts . amountSpentOnTrade , amounts . amountReceivedFromTrade ) ) { errorReporter . revertTx ( ""Amounts spent/received in trade not acceptable"" ) ; } if ( thisTrade . isSell ) { etherBalance = SafeMath . add ( etherBalance , amounts . amountReceivedFromTrade ) ; } else { etherBalance = SafeMath . sub ( etherBalance , amounts . amountSpentOnTrade ) ; } transferTokensToUser ( thisTrade . tokenAddress , thisTrade . isSell ? amounts . amountLeftToSpendOnTrade : amounts . amountReceivedFromTrade ) ; } if ( etherBalance > 0 ) { msg . sender . transfer ( etherBalance ) ; } }
","Performs the requested portfolio rebalance
"
"function transferTickerOwnership ( address _newOwner , string _ticker ) external ;
","Transfers the ownership of the ticker
"
"function requestFreeDistribution ( ) external { require ( getState ( ) == State . Success ) ; assert ( investors [ msg . sender ] > 0 ) ; uint256 unSoldTokens = safeSub ( tokenCreationMax , tokensSold ) ; require ( unSoldTokens > 0 ) ; uint256 freeTokens = safeDiv ( safeMul ( unSoldTokens , investors [ msg . sender ] ) , tokensSold ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , freeTokens ) ; investors [ msg . sender ] = 0 ; emit FreeDistribution ( msg . sender , freeTokens , block . number ) ; emit Transfer ( 0 , msg . sender , freeTokens ) ; }
","send
"
"function setState ( State _state ) external onlyOwner { state = _state ; }
","Sets the Broker contract state
"
"function tokenURI ( uint256 _tokenId ) public view returns ( string ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , ""PixelCon does not exist"" ) ; PixelCon storage pixelcon = pixelcons [ lookupData . tokenIndex ] ; bytes8 pixelconName = pixelconNames [ lookupData . tokenIndex ] ; string memory finalTokenURI = tokenURITemplate ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<tokenId>"" , StringUtils . toHexString ( _tokenId , 32 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<tokenIndex>"" , StringUtils . toHexString ( uint256 ( lookupData . tokenIndex ) , 8 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<name>"" , StringUtils . toHexString ( uint256 ( pixelconName ) , 8 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<owner>"" , StringUtils . toHexString ( uint256 ( lookupData . owner ) , 20 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<creator>"" , StringUtils . toHexString ( uint256 ( pixelcon . creator ) , 20 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<dateCreated>"" , StringUtils . toHexString ( uint256 ( pixelcon . dateCreated ) , 8 ) ) ; finalTokenURI = StringUtils . replace ( finalTokenURI , ""<collectionIndex>"" , StringUtils . toHexString ( uint256 ( pixelcon . collectionIndex ) , 8 ) ) ; return finalTokenURI ; }
","Get a distinct Uniform Resource Identifier ( URI ) for PixelCon ` ( _tokenId ) `
"
"function unpause ( ) public onlyCOO whenPaused { paused = false ; }
","This is public rather than external so it can be called by derived contracts .
"
"function changeOwnership ( address _newOwner ) onlyOwner { require ( _newOwner != 0x0 ) ; address oldOwner = owner ; owner = _newOwner ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }
","` owner ` can step down and assign some other address to this role
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address ) { return _ownerOf ( _tokenId ) ; }
","Find the owner of an NFT
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( frozen [ _from ] == false ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }
","Transfer _value tokens from address _from to address _to using allowance msg.sender allowance on _from
"
"function pauseGame ( uint256 _gameID , bool _paused ) external isActivated ( _gameID ) isOngoing ( _gameID ) onlyDevOrOwner ( ) { game_ [ _gameID ] . paused = _paused ; emit onGamePaused ( _gameID , _paused , now ) ; }
","Pause a game .
"
"function transferToContract ( address to , uint256 value , bytes data ) public returns ( bool _success ) { require ( to != address ( 0 ) ) ; require ( value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; ContractReceiver ( to ) . tokenFallback ( msg . sender , value , data ) ; Transfer ( msg . sender , to , value , data ) ; return true ; }
","To transfer tokens to a contract address
"
"function acceptOwnership ( ) public { require ( msg . sender == newOwner , ""You have not been selected as the new owner."" ) ; emit OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; newOwner = address ( 0 ) ; }
","The new owner accepts responsibility of contract ownership by using this function .
"
"function createDividendWithExclusions ( uint256 _maturity , uint256 _expiry , address [ ] _excluded , bytes32 _name ) public payable withPerm ( MANAGE ) { uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; _createDividendWithCheckpointAndExclusions ( _maturity , _expiry , checkpointId , _excluded , _name ) ; }
","Creates a dividend and checkpoint for the dividend , specifying explicit excluded addresses
"
"function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }
","Returns the amount of tokens approved by the owner that can be transferred to the spender 's account
"
"function startWineryProductByRegulator ( string _harvestTrackID , string _producerOffChainIdentity , string _wineryOperationTrackIDs , string _wineryOffChainIdentity , int _productIndex ) external regulatorsOnly returns ( bool success ) { require ( _productIndex >= 0 ) ; address producer = getAddress ( _producerOffChainIdentity ) ; bytes32 harvestMappingID = keccak256 ( _harvestTrackID , producer ) ; address winery = getAddress ( _wineryOffChainIdentity ) ; bytes32 wineryOperationMappingID = keccak256 ( _wineryOperationTrackIDs , winery ) ; harvests [ harvestMappingID ] . child = IndexElem ( wineryOperationMappingID , _productIndex ) ; wineries [ wineryOperationMappingID ] [ uint ( _productIndex ) ] . parentList . push ( IndexElem ( harvestMappingID , - 1 ) ) ; return true ; }
","TODO Inserire commenti
"
"function createLoan ( Oracle _oracleContract , address _borrower , bytes32 _currency , uint256 _amount , uint256 _interestRate , uint256 _interestRatePunitory , uint256 _duesIn , uint256 _cancelableAt , uint256 _expirationRequest , string _metadata ) public returns ( uint256 ) { require ( ! deprecated ) ; require ( _cancelableAt <= _duesIn ) ; require ( _oracleContract != address ( 0 ) || _currency == 0x0 ) ; require ( _borrower != address ( 0 ) ) ; require ( _amount != 0 ) ; require ( _interestRatePunitory != 0 ) ; require ( _interestRate != 0 ) ; require ( _expirationRequest > block . timestamp ) ; var loan = Loan ( Status . initial , _oracleContract , _borrower , 0x0 , msg . sender , 0x0 , _amount , 0 , 0 , 0 , 0 , _interestRate , _interestRatePunitory , 0 , _duesIn , _currency , _cancelableAt , 0 , 0x0 , _expirationRequest , _metadata ) ; uint index = loans . push ( loan ) - 1 ; CreatedLoan ( index , _borrower , msg . sender ) ; bytes32 identifier = getIdentifier ( index ) ; require ( identifierToIndex [ identifier ] == 0 ) ; identifierToIndex [ identifier ] = index ; if ( msg . sender == _borrower ) { approveLoan ( index ) ; } return index ; }
","Creates a loan request , the loan can be generated with any borrower and conditions ; if the borrower agrees it must call the `` approve '' function .
"
"function isRefunded ( address _darknodeID ) public view returns ( bool ) { uint256 registeredAt = store . darknodeRegisteredAt ( _darknodeID ) ; uint256 deregisteredAt = store . darknodeDeregisteredAt ( _darknodeID ) ; return registeredAt == 0 && deregisteredAt == 0 ; }
","Returns if a darknode is in the refunded state .
"
"function cashBack ( address _to ) public { uint usd ; ( usd , , ) = ICOStatus ( ) ; require ( now > crowdsaleEndTime && usd < softcapUSD ) ; require ( ethSent [ _to ] > 0 ) ; delete ethSent [ _to ] ; _to . transfer ( ethSent [ _to ] ) ; }
","cashBack will be used in case of failed ICO All partitipants can receive their ETH back
"
"function unregisterUser ( address _user ) external onlyContractOwner returns ( uint ) { require ( _user != 0x0 ) ; uint _memberIndex = memberAddress2index [ _user ] ; if ( _memberIndex == 0 || address2member [ _user ] . groupsCount != 0 ) { return _emitError ( USER_MANAGER_INVALID_INVOCATION ) ; } uint _membersCount = membersCount ; delete memberAddress2index [ _user ] ; if ( _memberIndex != _membersCount ) { address _lastUser = index2memberAddress [ _membersCount ] ; index2memberAddress [ _memberIndex ] = _lastUser ; memberAddress2index [ _lastUser ] = _memberIndex ; } delete address2member [ _user ] ; delete index2memberAddress [ _membersCount ] ; delete memberAddress2index [ _user ] ; membersCount = _membersCount . sub ( 1 ) ; UserDeleted ( _user ) ; return OK ; }
","Discard user registration Can be called only by contract owner
"
"function claimWinnings ( bytes32 question_id , bytes32 [ ] history_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) stateFinalized ( question_id ) public { require ( history_hashes . length > 0 ) ; address payee = question_claims [ question_id ] . payee ; uint256 last_bond = question_claims [ question_id ] . last_bond ; uint256 queued_funds = question_claims [ question_id ] . queued_funds ; bytes32 last_history_hash = questions [ question_id ] . history_hash ; bytes32 best_answer = questions [ question_id ] . best_answer ; uint256 i ; for ( i = 0 ; i < history_hashes . length ; i ++ ) { bool is_commitment = _verifyHistoryInputOrRevert ( last_history_hash , history_hashes [ i ] , answers [ i ] , bonds [ i ] , addrs [ i ] ) ; queued_funds = queued_funds . add ( last_bond ) ; ( queued_funds , payee ) = _processHistoryItem ( question_id , best_answer , queued_funds , payee , addrs [ i ] , bonds [ i ] , answers [ i ] , is_commitment ) ; last_bond = bonds [ i ] ; last_history_hash = history_hashes [ i ] ; } if ( last_history_hash != NULL_HASH ) { if ( payee != NULL_ADDRESS ) { _payPayee ( question_id , payee , queued_funds ) ; queued_funds = 0 ; } question_claims [ question_id ] . payee = payee ; question_claims [ question_id ] . last_bond = last_bond ; question_claims [ question_id ] . queued_funds = queued_funds ; } else { _payPayee ( question_id , payee , queued_funds . add ( last_bond ) ) ; delete question_claims [ question_id ] ; } questions [ question_id ] . history_hash = last_history_hash ; }
","Assigns the winnings ( bounty and bonds ) to everyone who gave the accepted answer Caller must provide the answer history , in reverse order
"
"function pay ( address who ) external payable { require ( who != 0x0 ) ; require ( msg . value == fee ) ; require ( s_paid [ who ] . length < 10 ) ; s_paid [ who ] . push ( msg . sender ) ; Paid ( who , msg . sender ) ; treasury . transfer ( msg . value ) ; }
","This method is used to pay for the fee .
"
"function incTotalSupply ( uint _val ) external onlyOwner returns ( bool ) { totalSupply = totalSupply . add ( _val ) ; return true ; }
","Increase total supply by ` _val `
"
"function batchEscrowToTeamContract ( address _owner , uint32 [ ] _tokenIds ) public whenNotPaused { require ( teamContract != address ( 0 ) ) ; require ( msg . sender == address ( teamContract ) ) ; for ( uint32 i = 0 ; i < _tokenIds . length ; i ++ ) { uint32 _tokenId = _tokenIds [ i ] ; require ( _owns ( _owner , _tokenId ) ) ; _transfer ( _owner , teamContract , _tokenId ) ; } }
","Escrows all of the tokensIds passed by transfering ownership to the teamContract .
"
"function setLocked ( address _target , uint _timeStamp ) public onlyAdmin returns ( bool ) { locked [ _target ] = _timeStamp ; emit LockStatus ( _target , _timeStamp ) ; return true ; }
","_target - address you want to lock until _timeStamp - unix time
"
"function getCurrencyAddress ( ) external view returns ( address ) { return address ( 0 ) ; }
","Returns address of oracle currency ( 0x0 for ETH )
"
"function remainingCap ( ) private returns ( uint256 ) { return preSaleCap ; }
","Returns the Ether amount remaining until the hard-cap
"
"function revoke ( address who , address origin ) payable external only_delegate { require ( msg . value == fee ) ; bool found ; for ( uint i = 0 ; i < s_paid [ who ] . length ; i ++ ) { if ( s_paid [ who ] [ i ] != origin ) { continue ; } found = true ; uint last = s_paid [ who ] . length - 1 ; s_paid [ who ] [ i ] = s_paid [ who ] [ last ] ; delete s_paid [ who ] [ last ] ; s_paid [ who ] . length -= 1 ; break ; } require ( found ) ; origin . transfer ( msg . value ) ; }
","This method can be called by authorized persons only , and can issue a refund of the fee to the ` origin ` address who paid the fee for ` who ` .
"
"function approve ( address _spender , uint _value ) public returns ( bool success ) ;
","` msg.sender ` approves ` _addr ` to spend ` _value ` tokens
"
"function cumulativeInverse ( uint256 neumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public pure returns ( uint256 euroUlps ) { require ( maxEurUlps >= minEurUlps ) ; require ( cumulative ( minEurUlps ) <= neumarkUlps ) ; require ( cumulative ( maxEurUlps ) >= neumarkUlps ) ; uint256 min = minEurUlps ; uint256 max = maxEurUlps ; while ( max > min ) { uint256 mid = ( max + min ) / 2 ; uint256 val = cumulative ( mid ) ; if ( val < neumarkUlps ) { min = mid + 1 ; } else { max = mid ; } } return max ; }
","find issuance curve inverse by binary search
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( isTransferWhitelistOnly ) { require ( isUserAllowedToTransfer ( msg . sender ) ) ; } return super . transfer ( _to , _value ) ; }
","transfer token for a specified address
"
"function getOwners ( ) public constant returns ( address [ ] ) { address [ ] memory result = new address [ ] ( m_numOwners ) ; for ( uint i = 0 ; i < m_numOwners ; i ++ ) result [ i ] = getOwner ( i ) ; return result ; }
","Gets owners
"
"function setPrivateSaleTokensSold ( uint tokens ) public onlyOwner { privateSalesTokensSold = tokens ; tokensAvailableForSale = totalTokensAvailableForSale - preDGZTokensSold * preDGZtoDGZExchangeRate / 100000000 - privateSalesTokensSold ; }
","Set number of tokens sold on private round .
"
"function killTo ( address _to , bytes32 _hash ) external nonZeroAddress ( _to ) pollApproved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) { selfdestruct ( _to ) ; }
","Contract desctruction function with ethers redirection
"
"function setFundingFueled ( ) external ;
","Function used by the main partner to set the funding fueled
"
"function getModulesByType ( uint8 _type ) external view returns ( address [ ] ) ;
","Returns module list for a module type
"
"function mint ( address _investor , uint256 _amount ) public onlyModule ( STO_KEY , true ) checkGranularity ( _amount ) isMintingAllowed ( ) returns ( bool success ) { require ( _investor != address ( 0 ) , ""Investor address should not be 0x"" ) ; adjustInvestorCount ( address ( 0 ) , _investor , _amount ) ; require ( verifyTransfer ( address ( 0 ) , _investor , _amount ) , ""Transfer is not valid"" ) ; adjustBalanceCheckpoints ( _investor ) ; adjustTotalSupplyCheckpoints ( ) ; totalSupply_ = totalSupply_ . add ( _amount ) ; balances [ _investor ] = balances [ _investor ] . add ( _amount ) ; emit Minted ( _investor , _amount ) ; emit Transfer ( address ( 0 ) , _investor , _amount ) ; return true ; }
","mints new tokens and assigns them to the target _investor .
"
"function moveToNextCeiling ( ) public onlyOwner { currentIndex = currentIndex . add ( 1 ) ; }
","Move to ceiling , used as a failsafe
"
"function totalSupplyAt ( uint256 _checkpointId ) public view returns ( uint256 ) { return getValueAt ( checkpointTotalSupply , _checkpointId , totalSupply ( ) ) ; }
","Queries totalSupply as of a defined checkpoint
"
"function collectForREQBurning ( uint256 _amount ) internal { requestBurnerContract . transfer ( _amount ) ; }
","Sends fees to the request burning address .
"
"function fillAndValidate ( OrderData data ) internal { exchange . fill . value ( msg . value ) ( data . makerAddress , data . makerAmount , data . makerToken , data . takerAddress , data . takerAmount , data . takerToken , data . expiration , data . nonce , data . v , data . r , data . s ) ; bytes32 orderHash ; ( orderHash , ) = getOrderHash ( data ) ; if ( ! exchange . fills ( orderHash ) ) { errorReporter . revertTx ( ""AirSwap: Order failed validation after execution"" ) ; } }
","Calls the fill function at airSwap , then validates the order was filled
"
"function newChannel ( address client , address receiver , uint close_timeout , uint settle_timeout , uint audit_timeout , address auditor ) returns ( address ) { address new_channel_address = new ChannelContract ( this , msg . sender , client , receiver , close_timeout , settle_timeout , audit_timeout , auditor ) ; ChannelNew ( new_channel_address , msg . sender , client , receiver , close_timeout , settle_timeout , audit_timeout ) ; return new_channel_address ; }
","Create a new channel from msg.sender to receiver
"
"function calculateGrantClaim ( address _recipient ) public view returns ( uint16 , uint128 ) { Grant storage tokenGrant = tokenGrants [ _recipient ] ; uint elapsedTime = sub ( now , tokenGrant . startTime ) ; uint elapsedMonths = elapsedTime / SECONDS_PER_MONTH ; if ( elapsedMonths < tokenGrant . vestingCliff ) { return ( 0 , 0 ) ; } if ( elapsedMonths >= tokenGrant . vestingDuration ) { uint128 remainingGrant = tokenGrant . amount - tokenGrant . totalClaimed ; return ( tokenGrant . vestingDuration , remainingGrant ) ; } else { uint16 monthsVested = uint16 ( sub ( elapsedMonths , tokenGrant . monthsClaimed ) ) ; uint amountVestedPerMonth = tokenGrant . amount / tokenGrant . vestingDuration ; uint128 amountVested = uint128 ( mul ( monthsVested , amountVestedPerMonth ) ) ; return ( monthsVested , amountVested ) ; } }
","Calculate the vested and unclaimed months and tokens available for ` _recepient ` to claim Due to rounding errors once grant duration is reached , returns the entire left grant amount Returns ( 0 , 0 ) if cliff has not been reached
"
"function setMetaData ( string _metadata ) onlyOwner public { metadata = _metadata ; }
","Set a metadata string , expected to be JSON , containing things like arbitrator TOS address
"
"function getInstructions ( ) public view returns ( string ) { return ""Create a dividend which will be paid out to token holders proportional to their balances at the point the dividend is created"" ; }
","Get the Instructions that helped to used the module
"
"function proxyClaimTokens ( address receiverAddress ) public atStage ( Stages . AuctionEnded ) returns ( bool ) { require ( now > endTime + tokenClaimWaitingPeriod ) ; require ( receiverAddress != 0x0 ) ; if ( bids [ receiverAddress ] == 0 ) { return false ; } uint num = ( tokenMultiplier * bids [ receiverAddress ] ) / finalPrice ; uint auctionTokensBalance = token . balanceOf ( address ( this ) ) ; if ( num > auctionTokensBalance ) { num = auctionTokensBalance ; } fundsClaimed += bids [ receiverAddress ] ; bids [ receiverAddress ] = 0 ; require ( token . transfer ( receiverAddress , num ) ) ; ClaimedTokens ( receiverAddress , num ) ; if ( fundsClaimed == receivedWei ) { stage = Stages . TokensDistributed ; TokensDistributed ( ) ; } assert ( token . balanceOf ( receiverAddress ) >= num ) ; assert ( bids [ receiverAddress ] == 0 ) ; return true ; }
","Claim auction tokens for ` receiverAddress ` after the auction has ended .
"
"function destroyTokens ( uint256 _tokens , address _destination ) onlyOwner { shp . destroyTokens ( _destination , _tokens ) ; }
","Allows the owner to manually destroy some SHP to an address if something goes wrong
"
"function cancelSellOffer ( uint32 _canvasId ) external { cancelSellOfferInternal ( _canvasId , true ) ; }
","Cancels previously made sell offer .
"
"function orderTrader ( bytes32 _orderID ) external view returns ( address ) ;
","returns the trader of the given orderID .
"
"function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) ) ; require ( ! nonces [ _signature ] ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) ) ; nonces [ _signature ] = true ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
","Decrease the amount of tokens that an owner allowed to a spender .
"
"function cancelPayment ( uint _idPayment ) onlyOwner external { require ( _idPayment < authorizedPayments . length ) ; Payment storage p = authorizedPayments [ _idPayment ] ; require ( ! p . canceled ) ; require ( ! p . paid ) ; p . canceled = true ; emit PaymentCanceled ( _idPayment ) ; }
","` onlyOwner ` Cancel a payment all together
"
"function balanceOf ( address _owner ) public view validAddress ( _owner ) returns ( uint256 ) { return ownedTokens [ _owner ] . length ; }
","Get the balance of ` ( _owner ) `
"
"function initialize ( ) public onlyOwner { require ( initialized == false ) ; require ( tokensAvailable ( ) == CAP ) ; initialized = true ; }
","Initializes the Sale Required as we need to Ensure the pre-requirements are met .
"
"function transferOwnership ( address _newOwner ) public onlyOwner { balances [ _newOwner ] = safeAdd ( balances [ owner ] , balances [ _newOwner ] ) ; balances [ owner ] = 0 ; Ownable . transferOwnership ( _newOwner ) ; }
","To transfer token contract ownership
"
"function finalizeCrowdsale ( ) onlyOwner public { finalized = true ; assert ( token . finishMinting ( ) ) ; token . setTransferEnabled ( true ) ; token . transferOwnership ( owner ) ; claimEther ( ) ; }
","Finalizes ICO : changes token ownership to founder , allows token transfers
"
"function transfer ( address _to , uint256 _amount ) onlyPayloadSize ( 2 * 32 ) public returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender `
"
"function changeFactorySubscriptionFee ( uint256 _newSubscriptionCost ) public onlyOwner { emit ChangeFactorySubscriptionFee ( monthlySubscriptionCost , _newSubscriptionCost , address ( this ) ) ; monthlySubscriptionCost = _newSubscriptionCost ; }
","Used to change the fee of the subscription cost
"
"function approveToken ( Token _tokenContract , address _spender , uint256 _value ) onlyOwner external { _tokenContract . approve ( _spender , _value ) ; }
","Send ERC20 tokens away .
"
"function updateTransfer ( uint64 nonce , uint256 transferred_amount , bytes32 locksroot , bytes32 extra_hash , bytes signature ) { data . updateTransfer ( nonce , transferred_amount , locksroot , extra_hash , signature ) ; TransferUpdated ( msg . sender , block . number ) ; }
","Dispute the state after closing , called by the counterparty ( the participant who did not close the channel ) .
"
"function getPledgeLevel ( Pledge p ) internal returns ( uint ) { if ( p . oldPledge == 0 ) return 0 ; Pledge storage oldN = findPledge ( p . oldPledge ) ; return getPledgeLevel ( oldN ) + 1 ; }
","A getter to find how many old `` parent '' pledges a specific Pledge had using a self-referential loop
"
"function ids ( address _service ) public constant returns ( uint256 serviceId ) { }
","returns the id of a service address , if any
"
"function transfer ( address _to , uint _value ) returns ( bool success ) { }
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function acceptOwnership ( ) { require ( msg . sender == newOwnerCandidate ) ; address oldOwner = owner ; owner = newOwnerCandidate ; newOwnerCandidate = 0x0 ; OwnershipTransferred ( oldOwner , owner ) ; }
","Can only be called by the ` newOwnerCandidate ` , accepts the transfer of ownership
"
"function checkMerkleProof ( bytes32 _merkleRoot , bytes32 [ ] _proof , uint _position , bytes32 _leaf ) public pure returns ( bool ) { bytes32 _computedHash = _leaf ; uint _checkedPosition = _position ; for ( uint i = 0 ; i < _proof . length ; i += 1 ) { bytes32 _proofElement = _proof [ i ] ; if ( _checkedPosition % 2 == 0 ) { _computedHash = keccak256 ( abi . encodePacked ( _computedHash , _proofElement ) ) ; } else { _computedHash = keccak256 ( abi . encodePacked ( _proofElement , _computedHash ) ) ; } _checkedPosition /= 2 ; } return _computedHash == _merkleRoot ; }
","Checks merkle proof based on the latest merkle root set up .
"
"function extractTokens ( address _token , address _claimer ) onlyOwner public { if ( _token == 0x0 ) { _claimer . transfer ( this . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( _claimer , balance ) ; ExtractedTokens ( _token , _claimer , balance ) ; }
","This method can be used to extract mistakenly sent tokens to this contract .
"
"function giveChamp ( address _to , uint256 _champId ) external onlyOwnerOfChamp ( _champId ) { transferChamp ( msg . sender , _to , _champId ) ; }
","Gift champ
"
"function getCollection ( uint256 _collectionId ) public view returns ( uint256 id , string collectionName , uint256 [ ] editionIds ) { Collection storage collection = allCollections [ _collectionId - 1 ] ; id = collection . id ; collectionName = collection . name ; editionIds = collection . editionIds ; }
","Returns all the relevant information about a specific collection .
"
"function distribute ( ) internal { if ( operatingAddress . balance < opThreshold ) { if ( address ( this ) . balance < ( opThreshold - operatingAddress . balance ) ) { operatingAddress . transfer ( address ( this ) . balance ) ; } else { operatingAddress . transfer ( opThreshold - operatingAddress . balance ) ; coldStorage . transfer ( address ( this ) . balance ) ; } } else { coldStorage . transfer ( address ( this ) . balance ) ; } }
","Function that sends funds to either Cold Storage , Operating Address , or both based on the Operating Threshold .
"
"function checkCompletedCrowdsale ( ) public whenNotPaused { if ( ! isEnded ) { if ( hasEnded ( ) && ! goalReached ( ) ) { vault . enableRefunds ( ) ; isRefunding = true ; isEnded = true ; Finalized ( ) ; } else if ( hasEnded ( ) && goalReached ( ) ) { isEnded = true ; if ( tokensRaised < maxTokensRaised ) { token . burnTokens ( ) ; } Finalized ( ) ; } } }
","Check if the crowdsale has ended and enables refunds only in case the goal has n't been reached
"
"function launchContract ( ) public onlyOwner { require ( ! contractLaunched ) ; tokenIsFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; emit LaunchContract ( msg . sender , true ) ; }
","Used to launch the contract , and enabled token minting
"
"function addInvestor ( address _wallet ) external isManager returns ( bool ) { if ( walletsICO [ _wallet ] ) { error ( 'addInvestor: this wallet has been previously granted as ICO investor' ) ; return false ; } walletsICO [ _wallet ] = true ; emit AddInvestor ( _wallet , timestamp ( ) ) ; return true ; }
","Registers an investor
"
"function setPrices ( uint256 newBuyPrice , uint256 newSellPrice ) onlyOwner public { buyPrice = newBuyPrice ; sellPrice = newSellPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external canTransfer ( _tokenId ) validNFToken ( _tokenId ) { address tokenOwner = idToOwner [ _tokenId ] ; require ( tokenOwner == _from ) ; require ( _to != address ( 0 ) ) ; _transfer ( _to , _tokenId ) ; }
","The caller is responsible to confirm that ` _to ` is capable of receiving NFTs or else they maybe be permanently lost .
"
"function mDestroyTokens ( address owner , uint256 amount ) internal { require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= amount ) ; uint256 previousBalanceFrom = balanceOf ( owner ) ; require ( previousBalanceFrom >= amount ) ; uint256 newTotalSupply = curTotalSupply - amount ; uint256 newBalanceFrom = previousBalanceFrom - amount ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceFrom ) ; Transfer ( owner , 0 , amount ) ; }
","Burns ` amount ` tokens from ` owner `
"
"function accept ( bytes32 _requestId ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , ""caller should be the currency contract of the request"" ) ; r . state = State . Accepted ; emit Accepted ( _requestId ) ; }
","Function used by currency contracts to accept a request in the Core .
"
"function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
","Function to claim any token stuck on contract
"
"function contributeToTokenGroup ( uint256 _tokenId ) external payable whenNotForking whenNotPaused { address userAdd = msg . sender ; require ( _addressNotNull ( userAdd ) ) ; var group = tokenIndexToGroup [ _tokenId ] ; var contributor = userAddressToContributor [ userAdd ] ; if ( ! group . exists ) { group . exists = true ; activeGroups += 1 ; } else { require ( group . addressToContributorArrIndex [ userAdd ] == 0 ) ; } if ( ! contributor . exists ) { userAddressToContributor [ userAdd ] . exists = true ; } else { require ( contributor . tokenIdToGroupArrIndex [ _tokenId ] == 0 ) ; } require ( group . purchasePrice == 0 ) ; uint256 tokenPrice = linkedContract . priceOf ( _tokenId ) ; require ( msg . value >= uint256 ( SafeMath . div ( tokenPrice , MAX_CONTRIBUTION_SLOTS ) ) ) ; uint256 cIndex = tokenIndexToGroup [ _tokenId ] . contributorArr . push ( userAdd ) ; tokenIndexToGroup [ _tokenId ] . addressToContributorArrIndex [ userAdd ] = cIndex ; uint256 amountNeeded = SafeMath . sub ( tokenPrice , group . contributedBalance ) ; if ( msg . value > amountNeeded ) { tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] = amountNeeded ; tokenIndexToGroup [ _tokenId ] . contributedBalance += amountNeeded ; userAddressToContributor [ userAdd ] . withdrawableBalance += SafeMath . sub ( msg . value , amountNeeded ) ; FundsDeposited ( userAdd , SafeMath . sub ( msg . value , amountNeeded ) ) ; } else { tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] = msg . value ; tokenIndexToGroup [ _tokenId ] . contributedBalance += msg . value ; } uint256 gIndex = userAddressToContributor [ userAdd ] . groupArr . push ( _tokenId ) ; userAddressToContributor [ userAdd ] . tokenIdToGroupArrIndex [ _tokenId ] = gIndex ; JoinGroup ( _tokenId , userAdd , tokenIndexToGroup [ _tokenId ] . contributedBalance , tokenIndexToGroup [ _tokenId ] . addressToContribution [ userAdd ] ) ; if ( tokenIndexToGroup [ _tokenId ] . contributedBalance >= tokenPrice ) { _purchase ( _tokenId , tokenPrice ) ; } }
","Allow user to contribute to _tokenId token group
"
"function releaseEQUITokens ( bytes32 hash , uint8 v , bytes32 r , bytes32 s ) public whenNotPaused { require ( balances [ msg . sender ] > 0 ) ; uint256 amount = 0 ; for ( uint8 i = 0 ; i < ledger [ msg . sender ] . releaseTime . length ; i ++ ) { uint256 time = ledger [ msg . sender ] . releaseTime [ i ] ; if ( now >= time && ledger [ msg . sender ] . balance [ time ] > 0 ) { amount = ledger [ msg . sender ] . balance [ time ] ; ledger [ msg . sender ] . balance [ time ] = 0 ; continue ; } } if ( amount <= 0 || balances [ msg . sender ] < amount ) { revert ( ) ; } if ( isKYCRequired ) { require ( isWhitelistedAddress ( hash , v , r , s ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; if ( ! token . transferFrom ( tokenWallet , msg . sender , amount ) ) { revert ( ) ; } emit TokenReleased ( msg . sender , amount ) ; } else { balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; if ( ! token . transferFrom ( tokenWallet , msg . sender , amount ) ) { revert ( ) ; } emit TokenReleased ( msg . sender , amount ) ; } }
","Transfers tokens held by timelock to beneficiary .
"
"function withdraw ( uint256 _value ) private pure { _value = _value ; }
","Withdraws '_value ' in wei from the reserve address
"
"function updateFromRegistry ( ) external onlyOwner { address _polymathRegistry = getAddress ( Encoder . getKey ( ""polymathRegistry"" ) ) ; set ( Encoder . getKey ( ""securityTokenRegistry"" ) , IPolymathRegistry ( _polymathRegistry ) . getAddress ( ""SecurityTokenRegistry"" ) ) ; set ( Encoder . getKey ( ""featureRegistry"" ) , IPolymathRegistry ( _polymathRegistry ) . getAddress ( ""FeatureRegistry"" ) ) ; set ( Encoder . getKey ( ""polyToken"" ) , IPolymathRegistry ( _polymathRegistry ) . getAddress ( ""PolyToken"" ) ) ; }
","Stores the contract addresses of other key contracts from the PolymathRegistry
"
"function setConfirmationPeriod ( uint duration ) external onlyOwner { require ( MIN_CONFIRMATION_PERIOD <= duration && duration <= MAX_CONFIRMATION_PERIOD ) ; confirmationPeriod = duration ; }
","Set the confirmation period after a vote has concluded .
"
"function getTitle ( ) public view returns ( string ) { return ""Count Transfer Manager"" ; }
","Get the title of the Module
"
"function destroyTokens ( address _user , uint _amount ) onlyOwner public returns ( bool ) { require ( balanceOf [ _user ] >= _amount ) ; balanceOf [ owner ] += _amount ; balanceOf [ _user ] -= _amount ; Transfer ( _user , 0 , _amount ) ; Burn ( _user , _amount ) ; return true ; }
","Burns ` _amount ` tokens from ` _owner `
"
"function setPercentages ( uint8 _Fee1 , uint8 _Fee2 , uint8 _Fees , uint8 _1Step , uint8 _2Step , uint8 _Steps ) public onlyCLevel { percentageFee1Step = _Fee1 ; percentageFee2Step = _Fee2 ; percentageFeeSteps = _Fees ; percentage1Step = _1Step ; percentage2Step = _2Step ; percentageSteps = _Steps ; }
","Any C-level can change percentage values
"
"function collectResources ( ) public onlyExistingUser { uint256 index = addressToUser [ msg . sender ] ; User storage user = users [ index ] ; uint256 [ ] storage factoriesIds = userToFactories [ addressToUser [ msg . sender ] ] ; for ( uint256 i = 0 ; i < factoriesIds . length ; i ++ ) { _collectResource ( factories [ factoriesIds [ i ] ] , user ) ; } }
","function for collect all resources from all factories
"
"function moveAllTokensToAddress ( bytes16 _uuid , address _address ) onlyAllowedAddresses onlyRegisteredAccount ( _uuid ) whenNotPaused public returns ( bool ) { uint256 accountBalance = balances [ _uuid ] ; removeTokensFromAccount ( _uuid , accountBalance ) ; rntToken . transfer ( _address , accountBalance ) ; tokens = tokens . sub ( accountBalance ) ; tokenTransfers [ _address ] = _uuid ; return true ; }
","Function for withdrawal all tokens from Vault account to address .
"
"function getCertificationDocument ( address _student , uint _docIndx ) public view onlyOwner returns ( bytes , bytes32 , bytes32 ) { return ( ( studentCertifications [ _student ] . documents [ _docIndx ] ) . ipfsHash , ( studentCertifications [ _student ] . documents [ _docIndx ] ) . contentHash , ( studentCertifications [ _student ] . documents [ _docIndx ] ) . transcriptHash ) ; }
","Get Certification Document from DocType
"
"function cancelVote ( uint motionID ) external { require ( ! motionConfirming ( motionID ) ) ; Vote senderVote = vote [ msg . sender ] [ motionID ] ; require ( senderVote != Vote . Abstention ) ; if ( motionVoting ( motionID ) ) { if ( senderVote == Vote . Yea ) { votesFor [ motionID ] = safeSub ( votesFor [ motionID ] , voteWeight [ msg . sender ] [ motionID ] ) ; } else { votesAgainst [ motionID ] = safeSub ( votesAgainst [ motionID ] , voteWeight [ msg . sender ] [ motionID ] ) ; } emit VoteCancelled ( msg . sender , motionID ) ; } delete voteWeight [ msg . sender ] [ motionID ] ; delete vote [ msg . sender ] [ motionID ] ; }
","Cancel an existing vote by the sender on a motion to confiscate the target balance .
"
"function claimPresaleTokens ( ) whenNotPaused external { require ( isPresaleFinalized == true ) ; uint256 senderEther = deposit . receivedEtherFrom ( msg . sender ) ; uint256 multiplier = 10 ** 18 ; senderEther = senderEther . mul ( multiplier ) ; uint256 tokenWei = pricingStrategy . oneTokenInWei ( ) ; uint256 tokensAmount = senderEther . div ( tokenWei ) ; require ( tokensAmount > 0 ) ; token . transferFrom ( owner , msg . sender , tokensAmount ) ; PresaleTokensClaimed ( tokensAmount ) ; }
","Function for claiming tokens for presale investors .
"
"function closed ( ) constant returns ( uint ) { return data . closed ; }
","Returns the block number for when the channel was closed .
"
"function unlock ( ) external { if ( getTime ( ) < unlockedAtTime ) revert ( ) ; if ( ! decentBetToken . transfer ( decentBetMultisig , decentBetToken . balanceOf ( this ) ) ) revert ( ) ; }
","Transfer locked tokens to Decent.bet 's multisig wallet
"
"function registerToken ( address tokenAddress , uint256 index ) external onlyAdmin { require ( index > 1 ) ; require ( tokenAddress2Id [ tokenAddress ] == 0 ) ; require ( tokenId2Address [ index ] == 0 ) ; tokenAddress2Id [ tokenAddress ] = index ; tokenId2Address [ index ] = tokenAddress ; }
","add a new token into the token list , only admins
"
"function nominateNewOwner ( address _owner ) public onlyOwner { nominatedOwner = _owner ; emit OwnerNominated ( _owner ) ; }
","Nominate a new owner of this contract .
"
"function isBuyOrder ( bytes32 _orderID ) private view returns ( bool ) { uint64 tokens = orderDetails [ _orderID ] . tokens ; uint32 firstToken = uint32 ( tokens >> 32 ) ; uint32 secondaryToken = uint32 ( tokens ) ; return ( firstToken < secondaryToken ) ; }
","Order parity is set by the order tokens are listed .
"
"function distributeCustomSaleProceeds ( uint256 _tokenId , uint256 _amount ) external onlyCOO { var group = tokenIndexToGroup [ _tokenId ] ; require ( group . exists ) ; require ( group . purchasePrice > 0 ) ; require ( _amount > 0 ) ; _distributeProceeds ( _tokenId , _amount ) ; }
","Group is dissolved after fn call
"
"function ( ) public payable notPaused { proxyPayment ( msg . sender ) ; }
","If anybody sends Ether directly to this contract , consider he is getting ATTs .
"
"function checkIn ( ) external { uint32 nowDate = getDate ( uint32 ( now ) ) ; require ( userDateToStatus [ msg . sender ] [ nowDate ] == UserEntryStatus . REGISTERED ) ; userDateToStatus [ msg . sender ] [ nowDate ] = UserEntryStatus . COMPLETED ; dateToContestStatus [ nowDate ] . numCompleted += 1 ; }
","Changes state
"
"function convertIntoHtlc ( bytes32 msigId , address beneficiary , uint amount , uint fee , uint expirationTime , bytes32 hashedSecret ) public returns ( bytes32 swapId ) { require ( multisigs [ msigId ] . owner == msg . sender ) ; require ( multisigs [ msigId ] . deposit >= amount + fee ) ; require ( now <= expirationTime && expirationTime <= min ( now + 1 days , multisigs [ msigId ] . unlockTime ) ) ; require ( amount > 0 ) ; require ( ! isAntecedentHashedSecret [ hashedSecret ] ) ; isAntecedentHashedSecret [ hashedSecret ] = true ; multisigs [ msigId ] . deposit = sub ( multisigs [ msigId ] . deposit , add ( amount , fee ) ) ; swapId = keccak256 ( msigId , msg . sender , beneficiary , amount , fee , expirationTime , hashedSecret ) ; emit AtomicSwapInitialised ( swapId ) ; AtomicSwap storage swap = atomicswaps [ swapId ] ; swap . msigId = msigId ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expirationTime = expirationTime ; swap . hashedSecret = hashedSecret ; FEE_RECIPIENT . transfer ( fee ) ; }
","First or second stage of atomic swap .
"
"function claimHodlReward ( ) public { claimHodlRewardFor ( msg . sender ) ; }
","Claiming HODL reward for msg.sender
"
"function withdraw ( ) isOwner public returns ( bool ) { uint _amount = address ( this ) . balance ; emit Withdrawal ( owner , _amount ) ; owner . transfer ( _amount ) ; balance -= _amount ; return true ; }
","withdraw all funds to contract owner
"
"function proxyPayment ( address _owner ) payable { doPayment ( _owner ) ; }
","` proxyPayment ( ) ` allows the caller to send ether to the Campaign and have the CampaignTokens created in an address of their choosing
"
"function burn ( uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . subtract ( _value ) ; totalSupply_ = totalSupply_ . subtract ( _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function claimableHalvingsOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { Miner miner = miners [ _miner ] ; uint256 halving = currentHalving ( ) ; uint256 minerHalving = blockHalving ( miner . block ) ; if ( minerHalving == halving ) { return 0 ; } else { if ( currentBlock ( ) % subsidyHalvingInterval < miner . block % subsidyHalvingInterval ) { return halving . sub ( minerHalving ) . sub ( 1 ) ; } else { return halving . sub ( minerHalving ) ; } } }
","Computes the number of halvings claimable by the miner
"
"function addScriptExecutor ( IEVMScriptExecutor _executor ) external auth ( REGISTRY_ADD_EXECUTOR_ROLE ) returns ( uint256 id ) { uint256 executorId = executorsNextIndex ++ ; executors [ executorId ] = ExecutorEntry ( _executor , true ) ; emit EnableExecutor ( executorId , _executor ) ; return executorId ; }
","Add a new script executor with address ` _executor ` to the registry
"
"function addPlayerToBoard ( bytes32 boardHash , bytes32 playerName ) public payable returns ( bool ) { require ( msg . value >= playerCost ) ; Board storage g = boards [ boardHash ] ; split ( g . boardOwner , msg . value ) ; uint newPlayerID = g . numPlayers ++ ; g . players [ newPlayerID ] = Player ( playerName , msg . sender , 0 , 0 , 1 ) ; return true ; }
","Add a new player to an existing leaderboard
"
"function disableTransfers ( ) external onlyOwner { require ( transfersEnabled ) ; transfersEnabled = false ; DisableTransfers ( msg . sender ) ; }
","Disable all transfers in case of a vulnerability found in the contract or other systems .
"
"function ( ) external payable { require ( isContract ( controller ) ) ; require ( ITokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) == true ) ; }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function getPrices ( ) public view returns ( uint256 , uint256 ) { return ( sellPrice_ , buyPrice_ ) ; }
","Get the current buy and sell prices
"
"function STARTMETADOLLAR ( ) { preIcoIsRunning = true ; minimalGoalReached = false ; icoExitIsPossible = false ; icoIsClosed = false ; tokenBalanceOf [ this ] += _totalSupply ; allowed [ this ] [ owner ] = _totalSupply ; allowed [ this ] [ supervisor ] = _totalSupply ; currentTokenPrice = 1000 * 1 ; preICOprice = 1000 * 1 ; ICOprice = 1000 * 1 ; sellPrice = 1000 ; commission1 = 1000 ; commission2 = 950 ; updatePrices ( ) ; }
","Constructor of the contract
"
"function assignToEarlyBirds ( address [ ] earlyBirds , uint256 amount ) onlyOwner public { require ( amount > 0 ) ; for ( uint i = 0 ; i < earlyBirds . length ; i ++ ) _transfer ( msg . sender , earlyBirds [ i ] , amount * 10 ** 18 ) ; }
","batch assign tokens to users registered in airdrops
"
"function name ( ) external view returns ( string _name ) ;
","A descriptive name for a collection of NFTs in this contract
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( approved [ _from ] [ msg . sender ] >= _value && balances [ _from ] >= _value && _value > 0 ) ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; approved [ _from ] [ msg . sender ] = safeSub ( approved [ _from ] [ msg . sender ] , _value ) ; Transfer ( _from , _to , _value ) ; return true ; }
","from ` _from ` will be sended ` _value ` tokens to ` _to `
"
"function getAmountFida ( uint256 _weiAmount ) public view returns ( uint256 _fidaAmount ) { require ( _weiAmount != 0 ) ; _fidaAmount = _weiAmount . mul ( fidaPerEther ) . div ( 100000 ) ; return _fidaAmount ; }
","Amount of fida you would get for any amount in wei
"
"function distributeFixed ( uint index , address [ ] _addrs , uint _amoutToEach ) public onlyOwner { if ( timeGone ( index ) == true ) { Airdrop memory airdrop = airdrops [ index ] ; for ( uint i = 0 ; i < _addrs . length ; ++ i ) { airdrop . tokenSC . transfer ( _addrs [ i ] , _amoutToEach ) ; } } else revert ( ""Distribution Failed: Countdown not finished yet"" ) ; }
","Distirbutes a constant quantity of tokens to all the specified addresses
"
"function approveAndCall ( address spender , uint256 amount , uint256 nonce , bytes extraData ) external returns ( bool success ) { address _trg = libAddress ; assembly { let m := mload ( 0x20 ) calldatacopy ( m , 0 , calldatasize ) let success := delegatecall ( gas , _trg , m , calldatasize , m , 0x20 ) switch success case 0 { invalid } default { return ( m , 0x20 ) } } }
","` msg.sender ` approves ` spender ` to spend ` amount ` tokens on its behalf and notify the spender from your approve with your ` extraData ` data .
"
"function hasClosed ( ) public view returns ( bool ) { return ( totalTokensSold >= totalSaleAllocation ) || super . hasClosed ( ) ; }
","Signifies whether or not the private sale has ended .
"
"function _freezeTransfer ( address _to , uint cst ) private { _transfer ( owner , _to , cst ) ; freezed [ _to ] = freezed [ _to ] . add ( cst ) ; }
","_freezeTranfer perform actual tokens transfer which will be freezed ( see also checkTransfer ( ) )
"
"function getChannelWith ( address partner ) constant returns ( address ) { return data . getChannelWith ( partner ) ; }
","Get the address of channel with a partner
"
"function decision ( ) external returns ( bool ) ;
","Transaction will fail when have no decision
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) public ;
","Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
"
"function checkCooldown ( address _allower , address _allowee ) external constant returns ( uint256 remaining ) { if ( cooldown [ _allower ] [ _allowee ] > now ) { return ( cooldown [ _allower ] [ _allowee ] - now ) ; } else { return 0 ; } }
","Check the cooldown remaining until the allowee can withdraw the balance
"
"function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ;
","send ` tokens ` token to ` to ` from ` from ` on the condition it is approved by ` from `
"
"function missingTokensFallback ( ) public { uint256 missingTokens = token . balanceOf ( this ) . sub ( totalFrozen ) ; require ( missingTokens > 0 ) ; TokenWithOwner tokenWithOwner = TokenWithOwner ( token ) ; token . safeTransfer ( tokenWithOwner . owner ( ) , missingTokens ) ; }
","Transfers tokens of unknown holders to token contract owner .
"
"function sell ( uint256 amount ) public { amount = amount * 10 ** uint256 ( decimals ) ; require ( this . balance >= amount / sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount / sellPrice ) ; }
","Sell ` amount ` tokens to contract 10 ( decimals ) )
"
"function pauseContribution ( ) public onlyOwner { paused = true ; }
","Pauses the contribution if there is any issue
"
"function mintCUSD ( address _to , uint256 _amount ) public requiresPermission whenNotPaused userNotBlacklisted ( _to ) { return _mintCUSD ( _to , _amount ) ; }
","Mints CarbonUSD for the user .
"
"function allowFreezeBypass ( address sender ) public onlyOwner returns ( bool success ) { freezeBypassing [ sender ] = true ; return true ; }
","Allowing a spender to bypass global frezze
"
"function removeOwnership ( uint _dac ) onlyOwner { require ( _dac == 0xdac ) ; owner = 0x0 ; newOwnerCandidate = 0x0 ; OwnershipRemoved ( ) ; }
","Decentralizes the contract , this operation can not be undone
"
"function buyPreciousMetal ( ) public payable returns ( uint256 ) { return buyFactory ( FactoryType . PreciousMetal ) ; }
","buy wood factory
"
"function changeCertifier ( address newCertifier ) pre_cond ( isOracle ( ) ) { CERTIFIER = Certifier ( newCertifier ) ; }
","Changes certifier contract address
"
"function transferCheck ( address _sender , address _receiver , uint256 _amount ) private constant returns ( bool success ) { require ( ! tokenIsFrozen ) ; require ( _amount > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] . sub ( _amount ) >= 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > 0 ) ; require ( balances [ _receiver ] . add ( _amount ) > balances [ _receiver ] ) ; return true ; }
","Reusable code to do sanity check of transfer variables
"
"function setNextGame ( uint256 _price , uint256 _timeout , uint256 _minimumTimeout , uint256 _numberOfWagersToMinimumTimeout ) external onlyCFO { require ( _timeout >= _minimumTimeout ) ; nextPrice = _price ; nextTimeout = _timeout ; nextMinimumTimeout = _minimumTimeout ; nextNumberOfWagersToMinimumTimeout = _numberOfWagersToMinimumTimeout ; NextGame ( nextPrice , nextTimeout , nextMinimumTimeout , nextNumberOfWagersToMinimumTimeout ) ; }
","Set the parameters for the next game .
"
"function changeForeignBridge ( address _newForeignBridge ) public onlyController { foreignBridge = _newForeignBridge ; }
","Changes the foreignBridge
"
"function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) internal { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != address ( 0 ) ) ; require ( mBalances [ _from ] >= _amount ) ; mBalances [ _from ] = mBalances [ _from ] . sub ( _amount ) ; mBalances [ _to ] = mBalances [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; if ( mErc20compatible ) { emit Transfer ( _from , _to , _amount ) ; } }
","Helper function actually performing the sending of tokens .
"
"function isAirDropUnique ( uint index , address receiver , address sc ) private view returns ( bool ) { Airdrop storage airdrop = airdrops [ index ] ; if ( airdrop . uniqueAirdrop [ receiver ] == sc ) { return true ; } else return false ; }
","Determines whether an aidrop unique
"
"function sell ( uint256 amount ) { require ( this . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
","Sell ` amount ` tokens to contract
"
"function calculateFees ( Data storage self , address contractAddress , uint amount ) internal view returns ( uint calculatedFees ) { uint maxFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.max' , contractAddress ) ) ) ; uint minFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.min' , contractAddress ) ) ) ; uint bpsFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.bps' , contractAddress ) ) ) ; uint flatFee = self . Storage . getUint ( keccak256 ( abi . encodePacked ( 'fee.flat' , contractAddress ) ) ) ; uint fees = ( ( amount . mul ( bpsFee ) ) . div ( 10000 ) ) . add ( flatFee ) ; if ( fees > maxFee ) { return maxFee ; } else if ( fees < minFee ) { return minFee ; } else { return fees ; } }
","Set the frozen token balance for a given account
"
"function convertToEther ( uint256 _value ) private pure returns ( uint256 ) { return _value * FIXED_RATE / 10 ** 18 ; }
","The ` convertToEther ( ) ` converts value of SENC Tokens to Ether based on pegged rate .
"
"function upgrade ( uint256 _value ) public { UpgradeState _state = getUpgradeState ( ) ; require ( _state == UpgradeState . ReadyToUpgrade || _state == UpgradeState . Upgrading , ""State must be correct for upgrade"" ) ; require ( _value > 0 , ""Upgrade value must be greater than zero"" ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; totalUpgraded = totalUpgraded . add ( _value ) ; upgradeAgent . upgradeFrom ( msg . sender , _value ) ; emit Upgrade ( msg . sender , upgradeAgent , _value ) ; }
","Allow the token holder to upgrade some of their tokens to the new contract .
"
"function onApprove ( address _owner , address _spender , uint _amount ) returns ( bool ) { return true ; }
","Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) external returns ( bool success ) ;
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function removeNFToken ( address _from , uint256 _tokenId ) internal { require ( idToOwner [ _tokenId ] == _from ) ; assert ( ownerToNFTokenCount [ _from ] > 0 ) ; ownerToNFTokenCount [ _from ] = ownerToNFTokenCount [ _from ] . sub ( 1 ) ; delete idToOwner [ _tokenId ] ; }
","Use and override this function with caution .
"
"function updateDates ( uint8 _tierId , uint256 _start , uint256 _end ) public onlyOwner ( ) { if ( _start != 0 && _start < _end && _tierId < tiers . length ) { Tier storage tier = tiers [ _tierId ] ; tier . startDate = _start ; tier . endDate = _end ; } }
","updates tier start/end dates by id
"
"function isProviderFor ( uint ein , address provider ) public view returns ( bool ) { return identityDirectory [ ein ] . providers . contains ( provider ) ; }
","Checks whether the passed provider is set for the passed EIN .
"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( 0 , this , mintedAmount ) ; Transfer ( this , target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function disableInterface ( string _interface ) public onlyOwner { setInterfaceImplementation ( _interface , 0x0 ) ; }
","Disables an interface .
"
"function buyItem ( uint256 _classId ) public { require ( now > presaleStart , ""The presale is not started yet"" ) ; ItemClass storage class = classIdToClass [ _classId ] ; require ( class . active == true , ""This item is not for sale"" ) ; require ( class . amount > 0 ) ; require ( class . total < class . amount , ""Sold out"" ) ; require ( class . statsMin . length == class . statsMax . length ) ; if ( class . price > 0 ) { require ( MANAContract != address ( 0 ) , ""Invalid contract address for MANA. Please use the setDatabase() function first."" ) ; require ( MANAContract . transferFrom ( msg . sender , address ( this ) , class . price ) == true , ""Failed transfering MANA"" ) ; } _mintItem ( _classId , msg . sender ) ; }
","The price of the items increases after each bought item by a given amount
"
"function projectReimbursement ( ) public payable isAdmin isAwaitingOrCompleted { reimbursementTotal = reimbursementTotal . add ( msg . value ) ; emit ProjectReimbursed ( msg . value ) ; }
","Provides a refund for the entire list of swimmers to distribute at a pro-rata rate via the reimbursement functions .
"
"function setInfo ( string _zitetag , string _info ) onlyAuthBy0Admin external returns ( bool success ) { bytes32 hash = keccak256 ( abi . encodePacked ( 'zitetag.' , _zitetag ) ) ; zer0netDb . setString ( hash , _info ) ; emit ZitetagUpdate ( hash , _zitetag , _info ) ; return true ; }
","Set the zitetag 's registration info .
"
"function approveAll ( address _to ) public whenNotPaused { require ( _to != msg . sender ) ; require ( _to != address ( 0 ) ) ; operatorApprovals [ msg . sender ] [ _to ] = true ; ApprovalForAll ( msg . sender , _to , true ) ; }
","Approves another address to claim for the ownership of any tokens owned by this account
"
"function notate ( address _sender , uint256 _value , uint256 _blockNumber , uint256 [ ] _amounts ) public returns ( bool earlySuccess ) { }
","notate contribution
"
"function burnFromWithData ( address _from , uint256 _value , bytes _data ) public onlyModule ( BURN_KEY ) { require ( _value <= allowed [ _from ] [ msg . sender ] , ""Value too high"" ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; require ( _burn ( _from , _value , _data ) , ""Burn invalid"" ) ; }
","Burn function used to burn the securityToken on behalf of someone else
"
"function addPayerRefundAddressAction ( bytes32 _requestId , bytes _payerRefundAddress ) external whenNotPaused onlyRequestPayer ( _requestId ) { uint8 payeesCount = requestCore . getSubPayeesCount ( _requestId ) . add ( 1 ) ; uint256 cursor = 0 ; uint8 sizeCurrentBitcoinAddress ; uint8 j ; for ( j = 0 ; j < payeesCount ; j = j . add ( 1 ) ) { require ( bytes ( payerRefundAddress [ _requestId ] [ cursor ] ) . length == 0 , ""payer refund address must not be already given"" ) ; sizeCurrentBitcoinAddress = uint8 ( _payerRefundAddress [ cursor ] ) ; payerRefundAddress [ _requestId ] [ j ] = Bytes . extractString ( _payerRefundAddress , sizeCurrentBitcoinAddress , ++ cursor ) ; cursor += sizeCurrentBitcoinAddress ; } emit RefundAddressAdded ( _requestId ) ; }
","the refund addresses must not have been already provided
"
"function setUnclaimedPlotPrice ( uint256 _unclaimedPlotPrice ) external onlyCFO { unclaimedPlotPrice = _unclaimedPlotPrice ; }
","Sets the new price for unclaimed plots .
"
"function getSharesPercentForPeriod ( bytes32 _userKey , uint _date ) public view returns ( uint ) { uint _periodIdx = periodDate2periodIdx [ _date ] ; if ( _date != 0 && _periodIdx == 0 ) { return 0 ; } if ( _date == 0 ) { _date = now ; _periodIdx = periodsCount ; } uint _bmcDays = _getBmcDaysAmountForUser ( _userKey , _date , _periodIdx ) ; uint _totalBmcDeposit = _getTotalBmcDaysAmount ( _date , _periodIdx ) ; return _totalBmcDeposit != 0 ? _bmcDays * PERCENT_PRECISION / _totalBmcDeposit : 0 ; }
","Gets shares ( in percents ) the user has on provided date
"
"function cancel ( ) public { orderBook [ msg . sender ] = TradeOrder ( 0 , 0 , 0 ) ; TradeOrder memory order = orderBook [ msg . sender ] ; emit TokenOfferChanged ( msg . sender , order . quantity , order . price , order . expiry ) ; }
","Cancel an outstanding order .
"
"function buyoutCost ( uint256 _deedId ) external view returns ( uint256 ) { uint256 price = identifierToBuyoutPrice [ _deedId ] ; uint256 [ ] memory claimedSurroundingPlots = _claimedSurroundingPlots ( _deedId ) ; uint256 flatDividends = claimDividend ( ) . mul ( claimedSurroundingPlots . length ) ; return price . add ( flatDividends ) ; }
","Get the buyout cost for a given plot .
"
"function refundChannel ( bytes32 channelId ) public { require ( now >= channels [ channelId ] . expiresAt , ""TOO_EARLY"" ) ; require ( channels [ channelId ] . state == State . Created , ""WRONG_STATE"" ) ; uint amount = channels [ channelId ] . amount ; address initiator = channels [ channelId ] . initiator ; channels [ channelId ] . state = State . Refunded ; initiator . transfer ( amount ) ; emit ChannelRefunded ( channelId ) ; }
","Refund ETH to the channel initiator and set channel state as refuned .
"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( _spender != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _spender ] == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to transfer ` _value ` tokens from ` msg.sender ` to any address .
"
"function claim ( address _claimer ) onlyToken returns ( bool success ) { return false ; }
","Only one of claimByProof ( ) or claim ( ) will potentially be activated in the future .
"
"function ( ) payable { if ( isContract ( controller ) ) { if ( ! TokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) throw ; } else { throw ; } }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function disableSelling ( ) onlyOwner public { require ( msg . sender == owner ) ; sellingAllowed = false ; }
","does n't allow to sell to the contract
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) transable public returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallReceiver ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function setToken ( address _token ) external onlyOwner { token = ERC20 ( _token ) ; }
","sets the token that is to be used for this Lottery
"
"function isSecurityToken ( address _securityToken ) public view returns ( bool ) { return ( keccak256 ( bytes ( securityTokens [ _securityToken ] . symbol ) ) != keccak256 ( """" ) ) ; }
","Check that Security Token is registered
"
"function tokenFallback ( address _sender , uint _value , bytes ) external { if ( ! active ) { revert ( ) ; } ATxAssetProxy _token = token ; if ( msg . sender != _token . getLatestVersion ( ) ) { revert ( ) ; } uint _etherToExchange = _value . mul ( price ) / ( 10 ** uint ( _token . decimals ( ) ) ) ; if ( this . balance < _etherToExchange ) { revert ( ) ; } ATxPlatformInterface _platform = ATxPlatformInterface ( address ( _token . platform ( ) ) ) ; require ( OK == _platform . revokeAsset ( _token . smbl ( ) , _value ) ) ; uint _restEther = _takeRdFee ( _etherToExchange ) ; _sender . transfer ( _restEther ) ; TokenExchanged ( _sender , _token , _value , _restEther , _etherToExchange . sub ( _restEther ) , rdCollectorAddress , price ) ; }
","Fallback function for ERC223 standard .
"
"function buyTokensWithPoly ( uint256 _investedPOLY ) public nonReentrant { require ( ! paused ) ; require ( fundraiseType == FundraiseType . POLY , ""POLY should be the mode of investment"" ) ; require ( verifyInvestment ( msg . sender , _investedPOLY ) , ""Not valid Investment"" ) ; _processTx ( msg . sender , _investedPOLY ) ; _forwardPoly ( msg . sender , wallet , _investedPOLY ) ; _postValidatePurchase ( msg . sender , _investedPOLY ) ; }
","low level token purchase
"
"function claimMultipleAndWithdrawBalance ( bytes32 [ ] question_ids , uint256 [ ] lengths , bytes32 [ ] hist_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) public { }
","Convenience function to assign bounties/bonds for multiple questions in one go , then withdraw all your funds .
"
"function newProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument ) returns ( uint ) ;
","Function to make a proposal to work for the client
"
"function setPrice ( uint256 _productId , uint256 _price ) external onlyCLevel { _setPrice ( _productId , _price ) ; ProductPriceChanged ( _productId , _price ) ; }
","setPrice - sets the price of a product
"
"function enablePurchasing ( ) onlyOwner public { require ( msg . sender == owner ) ; purchasingAllowed = true ; }
","allows to purchase from the contract
"
"function processRequest ( bytes32 [ ] _proof , bytes5 _code , address _dest ) public onlyController { require ( ! sentToAddress [ _dest ] && ! codeUsed [ _code ] , ""Funds already sent / Code already used"" ) ; require ( MerkleProof . verifyProof ( _proof , root , keccak256 ( abi . encodePacked ( _code ) ) ) , ""Invalid code"" ) ; sentToAddress [ _dest ] = true ; codeUsed [ _code ] = true ; require ( SNT . transfer ( _dest , sntAmount ) , ""Transfer did not work"" ) ; _dest . transfer ( ethAmount ) ; emit AddressFunded ( _dest , _code , ethAmount , sntAmount ) ; }
","Process request for SNT/ETH and send it to destination address
"
"function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; require ( finalizedTime == 0 ) ; require ( getBlockTimestamp ( ) >= startTime ) ; require ( msg . sender == controller || getBlockTimestamp ( ) > endTime || weiToCollect ( ) == 0 ) ; uint256 tokenCap = aix . totalSupply ( ) . mul ( 100 ) . div ( 51 ) ; aix . generateTokens ( devHolder , tokenCap . mul ( 20 ) . div ( 100 ) ) ; aix . generateTokens ( communityHolder , tokenCap . mul ( 29 ) . div ( 100 ) ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = getBlockTimestamp ( ) ; Finalized ( finalizedBlock ) ; }
","This method will can be called by the controller before the contribution period end or by anybody after the ` endTime ` .
"
"function verifyTransfer ( address _from , address _to , uint256 _value , bytes _data ) public returns ( bool ) { return _verifyTransfer ( _from , _to , _value , _data , false ) ; }
","Validates a transfer with a TransferManager module if it exists
"
"function regularTransfer ( bytes32 swapId , bytes32 secret ) public { require ( sha256 ( secret ) == atomicswaps [ swapId ] . hashedSecret ) ; uint amount = atomicswaps [ swapId ] . amount ; address beneficiary = atomicswaps [ swapId ] . beneficiary ; delete atomicswaps [ swapId ] ; beneficiary . transfer ( amount ) ; }
","Withdraw ether and delete the htlc swap .
"
"function approve ( address spender , uint256 amount , uint256 nonce ) external returns ( bool success ) { address _trg = libAddress ; assembly { let m := mload ( 0x20 ) calldatacopy ( m , 0 , calldatasize ) let success := delegatecall ( gas , _trg , m , calldatasize , m , 0x20 ) switch success case 0 { invalid } default { return ( m , 0x20 ) } } }
","` msg.sender ` approves ` spender ` to spend ` amount ` tokens on its behalf .
"
"function withdraw ( ) external whenWithdrawalEnabled { uint256 ethBalance = ethBalances [ msg . sender ] ; require ( ethBalance > 0 ) ; uint256 elpBalance = elpBalances [ msg . sender ] ; elpBalances [ msg . sender ] = 0 ; ethBalances [ msg . sender ] = 0 ; if ( isWhitelisted ( msg . sender ) ) { token . transfer ( msg . sender , elpBalance ) ; } else { token . transfer ( msg . sender , elpBalance . mul ( threshold ) . div ( ethBalance ) ) ; if ( ethBalance > threshold ) { msg . sender . transfer ( ethBalance - threshold ) ; } } emit Withdrawal ( msg . sender , ethBalance , elpBalance ) ; }
","Withdraws the tokens .
"
"function finishMintingSTO ( ) public onlyOwner { finishedSTOMinting = true ; emit LogFinishMintingSTO ( now ) ; }
","End token minting period permanently for STOs
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { success = TokenTransferController ( get_contract ( CONTRACT_CONTROLLER_TOKEN_TRANSFER ) ) . put_transfer ( _from , _to , msg . sender , _value , true ) ; }
","transfer amount to account from account deducting from spender allowance
"
"function euroCentsInOneEther ( ) public constant returns ( uint ) { return 58000 ; }
","euro-cents per 1 ether
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) returns ( bool success ) { if ( ! approve ( _spender , _amount ) ) revert ( ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function purchaseAreaWithData ( uint24 [ ] purchase , uint24 [ ] purchasedAreas , uint256 [ ] areaIndices , string ipfsHash , string url , uint256 initialBuyoutPriceInWeiPerPixel ) external payable { uint256 initialPurchasePrice = validatePurchaseAndDistributeFunds ( purchase , purchasedAreas , areaIndices ) ; uint256 newPlotIndex = addPlotAndData ( purchase , ipfsHash , url , initialBuyoutPriceInWeiPerPixel ) ; for ( uint256 i = 0 ; i < areaIndices . length ; i ++ ) { holes [ areaIndices [ i ] ] . push ( newPlotIndex ) ; } emit PlotPurchased ( newPlotIndex , initialPurchasePrice , msg . sender ) ; }
","Purchases a new plot with at the location ( ` purchase [ 0 ] ` , ` purchase [ 1 ] ` ) and dimensions ` purchase [ 2 ] ` x ` purchase [ 2 ] ` .
"
"function withdrawExcessToken ( address token ) external onlyOwner { ERC20 erc20 = ERC20 ( token ) ; uint256 withdrawAmount ; uint256 amountOwned = erc20 . balanceOf ( address ( this ) ) ; uint256 tokenUnits ; bool ok ; ( tokenUnits , ok ) = getTokenUnits ( token ) ; if ( ok ) { withdrawAmount = amountOwned . sub ( totalSupply_ . div ( creationQuantity_ ) . mul ( tokenUnits ) ) ; } else { withdrawAmount = amountOwned ; } require ( erc20 . transfer ( owner , withdrawAmount ) ) ; }
","Owner : Withdraw excess funds which do n't belong to Basket Token holders
"
"function renounceOwnership ( ) public onlyOwner { OwnershipRenounced ( owner ) ; owner = address ( 0 ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes _data ) public onlyRegistry returns ( bytes4 ) { uint256 estateId = _bytesToUint ( _data ) ; _pushLandId ( estateId , _tokenId ) ; return ERC721_RECEIVED ; }
","Handle the receipt of an NFT
"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( _spender != 0x0 ) ; require ( _value == 0 || allowed [ msg . sender ] [ _spender ] == 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to transfer ` _value ` tokens from ` msg.sender ` to any address .
"
"function buyTokens ( address beneficiary ) public onlyFromRc validPurchase mustBeAtStage ( Stage . Running ) payable { require ( beneficiary != address ( 0 ) ) ; require ( beneficiary != address ( this ) ) ; require ( msg . value >= 1 ether ) ; uint256 weiAmount = msg . value ; uint256 tokens = getTokenAmount ( weiAmount ) ; require ( tokens > 0 ) ; require ( tokensSold . add ( tokens ) <= MAX_TOKENS ) ; tokensSold = tokensSold . add ( tokens ) ; weiRaised = weiRaised . add ( weiAmount ) ; balancesToken [ beneficiary ] = balancesToken [ beneficiary ] . add ( tokens ) ; balancesWei [ beneficiary ] = balancesWei [ beneficiary ] . add ( weiAmount ) ; TokenPurchase ( msg . sender , beneficiary , weiAmount , tokens ) ; forwardFunds ( ) ; }
","If you call directly this function your are buying for someone else
"
"function ( ) public payable { require ( isContract ( owner ) ) ; require ( TokenController ( owner ) . proxyPayment . value ( msg . value ) ( msg . sender ) ) ; }
","The fallback function : If the contract 's owner has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token owner contract
"
"function name ( ) public view returns ( string _name ) ;
","Returns the name of the token .
"
"function calculateMaxEtherSpend ( Trade trade , uint256 etherBalance ) internal view returns ( uint256 ) { assert ( ! trade . isSell ) ; uint256 tokenDecimals = Utils . getDecimals ( ERC20 ( trade . tokenAddress ) ) ; uint256 srcDecimals = trade . isSell ? tokenDecimals : Utils . eth_decimals ( ) ; uint256 destDecimals = trade . isSell ? Utils . eth_decimals ( ) : tokenDecimals ; uint256 maxSpendAtMinRate = Utils . calcSrcQty ( trade . tokenAmount , srcDecimals , destDecimals , trade . minimumExchangeRate ) ; return Utils . min ( etherBalance , maxSpendAtMinRate ) ; }
","Calculates the maximum amount that should be spent on a given buy trade
"
"function setInt ( bytes32 _key , int _value ) public onlyOwner returns ( bool success ) { intStorage [ _key ] = _value ; return true ; }
","Set value for Int associated with bytes32 id key
"
"function release ( ERC20Basic token ) public { uint256 unreleased = releasableAmount ( token ) ; require ( unreleased > 0 ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . safeTransfer ( beneficiary , unreleased ) ; Released ( unreleased ) ; }
","Transfers vested tokens to beneficiary .
"
"function getDeed ( uint256 identifier ) external view returns ( uint256 deedId , address owner , uint256 buyPrice , uint256 nextBuyPrice ) { deedId = identifier ; owner = identifierToOwner [ identifier ] ; buyPrice = identifierToPrice [ identifier ] ; nextBuyPrice = nextPrice ( buyPrice ) ; }
","Return a collectible 's details .
"
"function getCollectionNamesInRange ( uint64 _startIndex , uint64 _endIndex ) public view returns ( bytes8 [ ] ) { require ( _startIndex <= totalCollections ( ) , ""Start index is out of bounds"" ) ; require ( _endIndex <= totalCollections ( ) , ""End index is out of bounds"" ) ; require ( _startIndex <= _endIndex , ""End index is less than the start index"" ) ; uint64 length = _endIndex - _startIndex ; bytes8 [ ] memory names = new bytes8 [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { names [ i ] = collectionNames [ _startIndex + i ] ; } return names ; }
","Get the names of all collections from index ` ( _startIndex ) ` to ` ( _endIndex ) `
"
"function ( ) payable { }
","Function to receive payments
"
"function withdrawalToken ( uint256 amount ) onlyOwner public { require ( balanceOf [ this ] >= amount ) ; _transfer ( this , msg . sender , amount ) ; }
","withdrawal ` amount ` tokens from contract
"
"function getCurrencySymbol ( ) external view returns ( bytes32 ) { return bytes32 ( ""POLY"" ) ; }
","Returns symbol of oracle currency ( 0x0 for ETH )
"
"function removeValidator ( address validator ) external onlyOwner whenNotPaused { require ( isValidator ( validator ) , ""unable to remove, no validator located at the provided address"" ) ; while ( _validatorApprovals [ validator ] . length > 0 && gasleft ( ) > 25000 ) { uint256 lastIndex = _validatorApprovals [ validator ] . length . sub ( 1 ) ; uint256 targetApproval = _validatorApprovals [ validator ] [ lastIndex ] ; delete _attributeTypes [ targetApproval ] . approvedValidators [ validator ] ; delete _validatorApprovalsIndex [ validator ] [ targetApproval ] ; _validatorApprovals [ validator ] . length -- ; } require ( _validatorApprovals [ validator ] . length == 0 , ""Cannot remove validator - first remove any existing validator approvals"" ) ; address lastAccount = _validatorAccounts [ _validatorAccounts . length . sub ( 1 ) ] ; _validatorAccounts [ _validators [ validator ] . index ] = lastAccount ; _validators [ lastAccount ] . index = _validators [ validator ] . index ; _validatorAccounts . length -- ; delete _signingKeys [ _validators [ validator ] . signingKey ] ; delete _validators [ validator ] ; emit ValidatorRemoved ( validator ) ; }
","Remove the validator at address ` validator ` from the jurisdiction .
"
"function play ( bool startNewGameIfIdle ) external payable { _processGameEnd ( ) ; require ( msg . value >= price ) ; if ( ! gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; gameStarted = true ; gameStarter = msg . sender ; Start ( msg . sender , block . timestamp ) ; } uint256 fee = price . mul ( feePercentage ) . div ( 100000 ) ; uint256 dividend = price . mul ( gameStarterDividendPercentage ) . div ( 100000 ) ; uint256 wagerPoolPart = price . mul ( 2 ) . div ( 7 ) ; lastPlayer = msg . sender ; lastPlayTimestamp = block . timestamp ; prizePool = prizePool . add ( price . sub ( fee ) . sub ( dividend ) . sub ( wagerPoolPart ) ) ; Play ( msg . sender , block . timestamp , block . timestamp + timeout , wagerIndex , prizePool ) ; _sendFunds ( gameStarter , dividend ) ; if ( wagerIndex > 0 && ( wagerIndex % 7 ) == 0 ) { msg . sender . transfer ( wagerPool ) ; wagerPool = 0 ; } wagerPool = wagerPool . add ( wagerPoolPart ) ; wagerIndex = wagerIndex . add ( 1 ) ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Participate in the game .
"
"function setFeatureStatus ( string _nameKey , bool _newStatus ) public onlyOwner { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; require ( featureStatus [ key ] != _newStatus , ""Status unchanged"" ) ; emit ChangeFeatureStatus ( _nameKey , _newStatus ) ; featureStatus [ key ] = _newStatus ; }
","change a feature status
"
"function mintToken ( address target , uint256 mintedAmount ) onlyAuthorized public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function cancelBuyOffer ( uint32 _canvasId ) external stateOwned ( _canvasId ) forceOwned ( _canvasId ) { BuyOffer memory offer = buyOffers [ _canvasId ] ; require ( offer . buyer == msg . sender ) ; buyOffers [ _canvasId ] = BuyOffer ( false , 0x0 , 0 ) ; if ( offer . amount > 0 ) { addPendingWithdrawal ( offer . buyer , offer . amount ) ; } emit BuyOfferCancelled ( _canvasId , offer . buyer , offer . amount ) ; }
","Cancels previously made buy offer .
"
"function finalize ( ) minCapReached salePeriodCompleted isValidState onlyBy ( owner ) external { balances [ shitFundAddress ] = balances [ shitFundAddress ] . add ( shitFund ) ; assignedSupply = assignedSupply . add ( shitFund ) ; ClaimSHIT ( shitFundAddress , shitFund ) ; Transfer ( 0x0 , shitFundAddress , shitFund ) ; if ( assignedSupply < totalSupply ) { uint256 unassignedSupply = totalSupply . sub ( assignedSupply ) ; balances [ shitFundAddress ] = balances [ shitFundAddress ] . add ( unassignedSupply ) ; assignedSupply = assignedSupply . add ( unassignedSupply ) ; ClaimSHIT ( shitFundAddress , unassignedSupply ) ; Transfer ( 0x0 , shitFundAddress , unassignedSupply ) ; } ethFundAddress . transfer ( this . balance ) ; isFinalized = true ; }
","Sends the ETH to ETH fund wallet and finalizes the token sale
"
"function setExpirationTime ( uint256 time ) public onlyOwner returns ( bool ) { expiration = time ; return true ; }
","Sets the time window of the validity of the signed rates .
"
"function setPOLYUSD ( uint256 _price ) onlyOwner public { emit LogPriceUpdated ( _price , POLYUSD , 0 , now ) ; POLYUSD = _price ; latestUpdate = now ; }
","Allows owner to manually set POLYUSD price
"
"function isCertified ( address student ) payable requestFeePaid returns ( bool isIndeed ) { isIndeed = studentCertifications [ student ] . certified ; }
","Requesting a certification confirmation is a paying feature .
"
"function revoke ( ) onlyOwner public { require ( revocable ) ; require ( ! revoked ) ; _releaseTo ( beneficiary ) ; token . safeTransfer ( owner , token . balanceOf ( this ) ) ; revoked = true ; Revoked ( ) ; }
","Allows the owner to revoke the vesting .
"
"function transferPreSigned ( address _to , address _delegate , uint256 _value , uint256 _fee , uint256 _nonce , bytes _userData , bytes32 _sig_r , bytes32 _sig_s , uint8 _sig_v ) external { require ( _delegate == address ( 0 ) || _delegate == msg . sender , ""_delegate should be address(0) or msg.sender"" ) ; address _signer = ( _sig_v != 27 && _sig_v != 28 ) ? address ( 0 ) : ecrecover ( keccak256 ( abi . encodePacked ( address ( this ) , _to , _delegate , _value , _fee , _nonce , _userData ) ) , _sig_v , _sig_r , _sig_s ) ; require ( _signer != address ( 0 ) , ""_signature is invalid."" ) ; require ( _nonce > usedNonce [ _signer ] , ""_nonce must be greater than the last used nonce of the token holder."" ) ; usedNonce [ _signer ] = _nonce ; tokenContract . operatorSend ( _signer , _to , _value , _userData , """" ) ; if ( _fee > 0 ) { tokenContract . operatorSend ( _signer , msg . sender , _fee , _userData , """" ) ; } }
","some rules : 1 .
"
"function isCreated ( bytes32 _symbol ) public view returns ( bool ) { return assets [ _symbol ] . owner != 0 ; }
","Check asset existance .
"
"function channelManagerByToken ( address token_address ) addressExists ( token_address ) constant returns ( address ) { return registry [ token_address ] ; }
","Get the ChannelManager address for a specific token
"
"function ( ) payable { acceptPayment ( ) ; }
","Default function used for any payments made .
"
"function playerForceGameEnd ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; require ( game . status == GameStatus . PLAYER_INITIATED_END ) ; int newBalance = conflictRes . playerForceGameEnd ( game . gameType , game . betNum , game . betValue , game . balance , game . stake , game . endInitiatedTime ) ; closeGame ( game , gameId , playerAddress , ReasonEnded . END_FORCED_BY_PLAYER , newBalance ) ; payOut ( game , playerAddress ) ; }
","Force end of game if server does not respond .
"
"function buy ( ) payable public { require ( ! frozenAccount [ msg . sender ] ) ; require ( msg . value > 0 ) ; buyToken ( ) ; }
","Buy DOL from VAULT by sending ETH
"
"function transferToSelf ( uint256 _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ selfAddress ] = balances [ selfAddress ] + _value ; Transfer ( msg . sender , selfAddress , _value , _data ) ; allowed [ selfAddress ] [ msg . sender ] = _value + allowed [ selfAddress ] [ msg . sender ] ; Approval ( selfAddress , msg . sender , allowed [ selfAddress ] [ msg . sender ] ) ; return true ; }
","Handles Casino deposits ~ Custom ERC-223 Proposed Standard Addition
"
"function setDeprecatedContract ( Data storage self , address contractAddress ) internal returns ( bool success ) { require ( contractAddress != 0x0 , ""Error: cannot deprecate a null address."" ) ; bytes32 id = keccak256 ( abi . encodePacked ( 'depcrecated' , contractAddress ) ) ; require ( self . Storage . setBool ( id , true ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Deprecate a contract interface
"
"function sponsorDAI ( uint _JobID , uint _amount ) public { require ( _JobID >= 0 ) ; require ( _amount > 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( job . status == JobStatus . inProgress ) ; if ( job . sponsors [ msg . sender ] == 0 ) { job . sponsorList . push ( msg . sender ) ; } job . sponsors [ msg . sender ] = job . sponsors [ msg . sender ] + _amount ; job . sponsoredTokens = job . sponsoredTokens + _amount ; job . paymentAvailableForWorker = job . paymentAvailableForWorker + _amount ; job . sponsorsCount = job . sponsorsCount + 1 ; emit DAISponsored ( _JobID , _amount , msg . sender ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _amount ) ; DAI . transferFrom ( msg . sender , address ( this ) , _amount ) ; }
","this function lets any registered address send DAI tokens to any Job as sponsored tokens
"
"function removePermissionManager ( address _app , bytes32 _role ) external onlyPermissionManager ( _app , _role ) { _setPermissionManager ( address ( 0 ) , _app , _role ) ; }
","Remove the manager of ` _role ` in ` _app `
"
"function refund ( address _darknodeID ) external onlyRefundable ( _darknodeID ) { address darknodeOwner = store . darknodeOwner ( _darknodeID ) ; uint256 amount = store . darknodeBond ( _darknodeID ) ; store . removeDarknode ( _darknodeID ) ; ren . transfer ( darknodeOwner , amount ) ; emit LogDarknodeOwnerRefunded ( darknodeOwner , amount ) ; }
","Refund the bond of a deregistered darknode .
"
"function unlock ( ) public returns ( bool success ) { uint256 amount = lockedBalance [ msg . sender ] ; require ( amount > 0 ) ; require ( now >= timeRelease [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; lockedBalance [ msg . sender ] = 0 ; timeRelease [ msg . sender ] = 0 ; Transfer ( 0x0 , msg . sender , amount ) ; UnLock ( msg . sender , amount ) ; return true ; }
","Transfers tokens held by lock .
"
"function getWithdrawableDates ( ) external view returns ( uint32 [ ] ) { uint32 [ ] memory dates = userToDates [ msg . sender ] ; uint256 datesLength = dates . length ; uint32 [ ] memory withdrawableDates = new uint32 [ ] ( datesLength ) ; uint256 index = 0 ; uint32 now32 = uint32 ( now ) ; for ( uint256 i = 0 ; i < datesLength ; i ++ ) { uint32 date = dates [ i ] ; if ( now32 <= date . add ( WITHDRAW_BUFFER ) ) { continue ; } if ( userDateToStatus [ msg . sender ] [ date ] != UserEntryStatus . COMPLETED ) { continue ; } withdrawableDates [ index ] = date ; index += 1 ; } return withdrawableDates ; }
","Does n't change state
"
"function addToken ( address _tokenAddress ) public isAdmin isAwaitingOrCompleted { if ( state != PoolState . COMPLETED ) { setPoolToCompleted ( ) ; } for ( uint256 i = 0 ; i < tokenAddress . length ; ++ i ) { require ( tokenAddress [ i ] != _tokenAddress ) ; } ERC20Basic token = ERC20Basic ( _tokenAddress ) ; require ( token . balanceOf ( this ) >= 0 ) ; tokenAddress . push ( _tokenAddress ) ; emit TokenAdded ( _tokenAddress ) ; }
","Set a new token address where users can redeem ERC20 tokens .
"
"function cancelByAdmin ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 1 ] ; uint256 nonce = data >> 224 ; address user = userId2Address [ data & USER_MASK ] ; require ( nonce > userNonce [ user ] ) ; uint256 gasFee = inputs [ 0 ] ; require ( verify ( keccak256 ( this , gasFee , data & SIGN_MASK ) , user , uint8 ( retrieveV ( data ) ) , bytes32 ( inputs [ 2 ] ) , bytes32 ( inputs [ 3 ] ) ) ) ; address gasToken = 0 ; if ( data & PAYMENT_METHOD_MASK == PAY_BY_JOY ) { gasToken = joyToken ; } require ( balances [ gasToken ] [ user ] >= gasFee ) ; balances [ gasToken ] [ user ] = balances [ gasToken ] [ user ] . sub ( gasFee ) ; balances [ gasToken ] [ joysoWallet ] = balances [ gasToken ] [ joysoWallet ] . add ( gasFee ) ; userNonce [ user ] = nonce ; }
","update user on-chain nonce with admins involved , only admin
"
"function getRdFee ( ) public view returns ( uint _value , uint _decimals ) { FeeData memory _fee = rdFee ; return ( _fee . feeValue , _fee . feeDecimals ) ; }
","Gets redemption fee value
"
"function doReserveTrade ( ERC20 src , uint amount , ERC20 dest , address destAddress , uint expectedDestAmount , KyberReserveInterface reserve , uint conversionRate , bool validate ) internal returns ( bool ) { uint callValue = 0 ; if ( src == ETH_TOKEN_ADDRESS ) { callValue = amount ; } else { src . transferFrom ( msg . sender , this , amount ) ; } require ( reserve . trade . value ( callValue ) ( src , amount , dest , this , conversionRate , validate ) ) ; if ( dest == ETH_TOKEN_ADDRESS ) { destAddress . transfer ( expectedDestAmount ) ; } else { require ( dest . transfer ( destAddress , expectedDestAmount ) ) ; } return true ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function approve ( address _to , uint256 _cutieId ) external whenNotPaused canBeStoredIn40Bits ( _cutieId ) { require ( _isOwner ( msg . sender , uint40 ( _cutieId ) ) ) ; _approve ( uint40 ( _cutieId ) , _to ) ; emit Approval ( msg . sender , _to , _cutieId ) ; }
","Grant another address the right to transfer a perticular Cutie via transferFrom ( ) .
"
"function updateShares ( uint newWinnerShare , uint newHostShare , uint newBonusShare ) public onlyOwner { require ( newWinnerShare + newHostShare == 1000 ) ; WINNER_SHARE = newWinnerShare ; HOST_SHARE = newHostShare ; HONORABLE_LOSS_BONUS = newBonusShare ; }
","If we need to adjust the amounts players or EthernalGo gets for each game
"
"function isOwner ( address _addr ) public constant returns ( bool ) { return m_ownerIndex [ _addr ] > 0 ; }
","checks if provided address is an owner address
"
"function enableTokenMinting ( ) public onlyOwner returns ( bool enabled ) { tokenMintingEnabled = true ; TokenMintingEnabled ( msg . sender , true ) ; return true ; }
","Used to enable token minting
"
"function isValidIndex ( uint _index , uint _size ) public pure { require ( _index < _size , KEY_NOT_FOUND_ERR ) ; }
","index not out of bounds
"
"function withdrawal ( uint index , address to , uint256 amount ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( msg . sender == loan . lender ) ; loan . lenderBalance = safeSubtract ( loan . lenderBalance , amount ) ; require ( rcn . transfer ( to , amount ) ) ; unlockTokens ( rcn , amount ) ; return true ; }
","Withdraw lender funds When a loan is paid , the funds are not transferred automatically to the lender , the funds are stored on the engine contract , and the lender must call this function specifying the amount desired to transfer and the destination .
"
"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( WizzleGlobalToken ) { WizzleGlobalToken newToken = new WizzleGlobalToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { mimonedarecipiente spender = mimonedarecipiente ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf , and then ping the contract about it
"
"function getState ( ) public view returns ( State , State ) { if ( needInitialization ) { return ( State . Init , State . Init ) ; } if ( destructed ) { return ( State . Destructed , State . Destructed ) ; } if ( now < startDate ) { return ( State . Waiting , State . Waiting ) ; } State _hardcapState = ( finishedHardcap || ( tokenHardcapIssuedValue == tokenHardcapValue ) || ( now > endDate ) ) ? State . Reached : State . Sale ; State _softcapState = ( tokenSoftcapIssued == tokenSoftcap ) ? State . Reached : State . Sale ; return ( _hardcapState , _softcapState ) ; }
","Gets current state of Emission Provider .
"
"function removeWhitelist ( address _account ) external whenNotPaused onlyAdmin { require ( _account != address ( 0 ) ) ; if ( whitelist [ _account ] ) { whitelist [ _account ] = false ; emit WhitelistRemoved ( _account ) ; } }
","Removes an account from the whitelist .
"
"function effectiveValue ( bytes4 sourceCurrencyKey , uint sourceAmount , bytes4 destinationCurrencyKey ) public view rateNotStale ( sourceCurrencyKey ) rateNotStale ( destinationCurrencyKey ) returns ( uint ) { if ( sourceCurrencyKey == destinationCurrencyKey ) return sourceAmount ; return sourceAmount . multiplyDecimalRound ( exchangeRates . rateForCurrency ( sourceCurrencyKey ) ) . divideDecimalRound ( exchangeRates . rateForCurrency ( destinationCurrencyKey ) ) ; }
","A function that lets you easily convert an amount in a source currency to an amount in the destination currency
"
"function ICOSplit ( ) external isAdmin oneTime { bytes memory empty ; uint i ; if ( ! isFrozen ) { require ( ( relativeDateSave - now ) >= ( relativeDateSave - 150 days ) ) ; assetFreeze ( ) ; require ( balances [ selfAddress ] > 50000000000000 ) ; currentProfits = ( ( balances [ selfAddress ] - 50000000000000 ) / 10 ) * 7 ; amountInCirculation = safeSub ( 300000000000000 , balances [ selfAddress ] ) ; currentIteration = 0 ; actualProfitSplit = 0 ; } else { for ( i = currentIteration ; i < users . length ; i ++ ) { if ( msg . gas < 240000 ) { currentIteration = i ; break ; } balances [ users [ i ] ] += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; actualProfitSplit += ( balances [ users [ i ] ] * currentProfits ) / amountInCirculation ; if ( i == users . length - 1 ) { assetThaw ( ) ; balances [ selfAddress ] = balances [ selfAddress ] - actualProfitSplit ; hasICORun = true ; } Transfer ( selfAddress , users [ i ] , ( balances [ users [ i ] ] / amountInCirculation ) * currentProfits , empty ) ; } } }
","Split the unsold WBC of the ICO
"
"function transfer ( address from , address to , uint256 amount ) public onlyTransferAgent returns ( bool ) { require ( to != 0x0 , ""Cannot transfer tokens to the null address."" ) ; require ( amount > 0 , ""Cannot transfer zero tokens."" ) ; Holding memory fromHolding = heldTokens [ from ] ; require ( fromHolding . quantity >= amount , ""Not enough tokens to perform the transfer."" ) ; require ( ! isExistingHolding ( to ) , ""Cannot overwrite an existing holding, use a new wallet."" ) ; heldTokens [ from ] = Holding ( fromHolding . quantity . sub ( amount ) , fromHolding . releaseDate , fromHolding . isAffiliate ) ; heldTokens [ to ] = Holding ( amount , fromHolding . releaseDate , false ) ; emit TokensTransferred ( from , to , amount ) ; return true ; }
","Under special circumstances the Transfer Agent needs to move tokens around .
"
"function revokeAssetWithExternalReference ( bytes32 _symbol , uint _value , string _externalReference ) public returns ( uint _resultCode ) { TransactionContext memory txContext ; txContext . from = msg . sender ; txContext . fromHolderId = getHolderId ( txContext . from ) ; _resultCode = _revokeAsset ( _symbol , _value , txContext ) ; if ( _resultCode != OK ) { return _emitErrorCode ( _resultCode ) ; } _emitter ( ) . emitRevokeExternal ( _symbol , _value , txContext . from , _externalReference ) ; _proxyTransferEvent ( _value , _symbol , txContext ) ; return OK ; }
","Destroys specified amount of senders asset tokens .
"
"function mWithdraw ( uint [ ] pledgesAmounts ) { for ( uint i = 0 ; i < pledgesAmounts . length ; i ++ ) { uint64 idPledge = uint64 ( pledgesAmounts [ i ] & ( D64 - 1 ) ) ; uint amount = pledgesAmounts [ i ] / D64 ; withdraw ( idPledge , amount ) ; } }
","` mWithdraw ` allows for multiple pledges to be withdrawn efficiently
"
"function balanceOf ( address _owner ) public view returns ( uint ) { return ownershipTokenCount [ _owner ] ; }
","Returns the number of tokens owned by a specific address .
"
"function play ( uint256 _gameIndex , bool startNewGameIfIdle ) external payable { _processGameEnd ( ) ; if ( ! gameStarted ) { require ( ! paused ) ; require ( startNewGameIfIdle ) ; price = nextPrice ; timeout = nextTimeout ; finalTimeout = nextFinalTimeout ; numberOfWagersToFinalTimeout = nextNumberOfWagersToFinalTimeout ; gameStarted = true ; gameStarter = msg . sender ; Start ( gameIndex , msg . sender , block . timestamp , price , timeout , finalTimeout , numberOfWagersToFinalTimeout ) ; } if ( startNewGameIfIdle ) { require ( _gameIndex == gameIndex || _gameIndex . add ( 1 ) == gameIndex ) ; } else { require ( _gameIndex == gameIndex ) ; } require ( msg . value >= price ) ; uint256 fee = price . mul ( feePercentage ) . div ( 100000 ) ; uint256 dividend = price . mul ( gameStarterDividendPercentage ) . div ( 100000 ) ; uint256 wagerPoolPart ; if ( wagerIndex % 7 == 6 ) { uint256 wagerPrize = price . mul ( 2 ) ; wagerPoolPart = wagerPrize . sub ( wagerPool ) ; msg . sender . transfer ( wagerPrize ) ; wagerPool = 0 ; } else { wagerPoolPart = price . mul ( 2 ) . div ( 7 ) ; wagerPool = wagerPool . add ( wagerPoolPart ) ; } uint256 currentTimeout = calculateTimeout ( ) ; lastPlayer = msg . sender ; lastWagerTimeoutTimestamp = block . timestamp + currentTimeout ; prizePool = prizePool . add ( price . sub ( fee ) . sub ( dividend ) . sub ( wagerPoolPart ) ) ; Play ( gameIndex , wagerIndex , msg . sender , block . timestamp , lastWagerTimeoutTimestamp , prizePool ) ; _sendFunds ( gameStarter , dividend ) ; wagerIndex ++ ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Participate in the game .
"
"function addEmissionProvider ( address _provider , uint _block ) public returns ( uint _code ) { if ( emissionProviders [ _provider ] ) { return _emitError ( SERVICE_CONTROLLER_EMISSION_EXIST ) ; } _code = _multisig ( keccak256 ( _provider ) , _block ) ; if ( OK != _code ) { return _code ; } emissionProviders [ _provider ] = true ; uint _count = emissionProvidersCount + 1 ; index2emissionProvider [ _count ] = _provider ; emissionProvider2index [ _provider ] = _count ; emissionProvidersCount = _count ; return OK ; }
","Add emission provider
"
"function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }
","Get the token balance ` _owner `
"
"function contribute ( ) public notFinished payable { require ( msg . value <= 500 ether ) ; uint256 tokenBought = 0 ; totalRaised = totalRaised . add ( msg . value ) ; if ( state == State . PreSale ) { require ( now >= PreSaleStart ) ; tokenBought = msg . value . mul ( rates [ 0 ] ) ; if ( PreSaleDistributed <= 30000000 * ( 10 ** 18 ) ) { tokenBought = tokenBought . mul ( 12 ) ; tokenBought = tokenBought . div ( 10 ) ; } else if ( PreSaleDistributed <= 50000000 * ( 10 ** 18 ) ) { tokenBought = tokenBought . mul ( 11 ) ; tokenBought = tokenBought . div ( 10 ) ; } PreSaleDistributed = PreSaleDistributed . add ( tokenBought ) ; } else if ( state == State . MainSale ) { require ( now >= MainSaleStart ) ; if ( MainSaleDistributed < mainSale1Limit ) { tokenBought = msg . value . mul ( rates [ 1 ] ) ; if ( MainSaleDistributed <= 80000000 * ( 10 ** 18 ) ) { tokenBought = tokenBought . mul ( 12 ) ; tokenBought = tokenBought . div ( 10 ) ; } } else tokenBought = msg . value . mul ( rates [ 2 ] ) ; MainSaleDistributed = MainSaleDistributed . add ( tokenBought ) ; } totalDistributed = totalDistributed . add ( tokenBought ) ; require ( totalDistributed <= hardCap ) ; require ( tokenReward . transfer ( msg . sender , tokenBought ) ) ; emit LogContributorsPayout ( msg . sender , tokenBought ) ; emit LogFundingReceived ( msg . sender , msg . value , totalRaised ) ; checkIfFundingCompleteOrExpired ( ) ; }
","contribution handler
"
"function getBetInfo ( uint betId ) public view returns ( uint , GameResults , uint , bool ) { return ( bets [ betId ] . gameId , bets [ betId ] . result , bets [ betId ] . amount , bets [ betId ] . isPayoutWithdrawn ) ; }
","Returns the info of a specific bet
"
"function requireMultiple ( uint256 _amount ) internal pure { require ( _amount . div ( granularity ) . mul ( granularity ) == _amount ) ; }
","Internal function that ensures ` _amount ` is multiple of the granularity
"
"function startAirdrop ( uint256 _multiplierPercent ) onlyOwner external returns ( bool ) { pause ( ) ; require ( multiplierPercent == 0 ) ; require ( _multiplierPercent > PERCENT_DIVIDER ) ; currentAirdrop = currentAirdrop . add ( 1 ) ; multiplierPercent = _multiplierPercent ; undropped = totalSupply ( ) ; assert ( multiplierPercent . mul ( undropped ) > 0 ) ; AirdropStart ( multiplierPercent , currentAirdrop ) ; }
","Start airdrop
"
"function getDisputeFee ( bytes32 ) external view returns ( uint256 ) { return dispute_fee ; }
","Return the dispute fee for the specified question .
"
"function cost ( address , uint256 , bytes , bytes ) public view returns ( uint256 ) { return 0 ; }
","Returns the cost of the cosigner This cosigner does not have any risk or maintenance cost , so its free .
"
"function tokenOfOwnerByIndex ( address _owner , uint _index ) external view returns ( uint ) { require ( _index >= balanceOf ( _owner ) ) ; require ( _owner != address ( 0 ) ) ; uint [ ] memory tokens ; uint tokenId ; if ( tokenIsChamp ) { tokens = core . getChampsByOwner ( _owner ) ; } else { tokens = core . getItemsByOwner ( _owner ) ; } for ( uint i = 0 ; i < tokens . length ; i ++ ) { if ( i + 1 == _index ) { tokenId = tokens [ i ] ; break ; } } return tokenId ; }
","Enumerate NFTs assigned to an owner
"
"function transferFrom ( address from , address to , uint256 value ) public returns ( bool _success ) { require ( from != address ( 0 ) ) ; require ( to != address ( 0 ) ) ; require ( value != 0 ) ; uint256 allowance = allowed [ from ] [ msg . sender ] ; balances [ from ] = balances [ from ] . sub ( value ) ; allowed [ from ] [ msg . sender ] = allowance . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; Transfer ( from , to , value ) ; return true ; }
","To make token transfers from the allowance of another user
"
"function setFeeMax ( Data storage self , uint feeMax ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fee.max' , address ( this ) ) ) ; require ( self . Storage . setUint ( id , feeMax ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set maximum fee for contract interface
"
"function mintARC ( address target , uint256 mintAmount ) onlyPayloadSize ( 2 * 32 ) onlyOwner whenNotPaused public { require ( ! deprecated ) ; require ( ARCCheck . maximumCirculation ( ) >= valueTotalSupply . add ( mintAmount ) ) ; balances [ target ] = balances [ target ] . add ( mintAmount ) ; valueTotalSupply = valueTotalSupply . add ( mintAmount ) ; Transfer ( 0 , this , mintAmount ) ; Transfer ( this , target , mintAmount ) ; }
","Create ` mintAmount ` tokens and send it to ` target `
"
"function approve ( address _spender , uint256 _value ) returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","` msg.sender ` approves ` _spender ` to spend ` _value ` tokens
"
"function transfer ( address commitment , uint256 amount , bytes ) public onlyIfCommitment ( commitment ) { require ( amount > 0 , ""NF_LOCKED_NO_ZERO"" ) ; Account storage account = _accounts [ msg . sender ] ; require ( account . balance >= amount , ""NF_LOCKED_NO_FUNDS"" ) ; uint112 unlockedNmkUlps = uint112 ( proportion ( account . neumarksDue , amount , account . balance ) ) ; account . balance = subBalance ( account . balance , uint112 ( amount ) ) ; account . neumarksDue -= unlockedNmkUlps ; Account storage investment = _commitments [ address ( commitment ) ] [ msg . sender ] ; investment . balance += uint112 ( amount ) ; investment . neumarksDue += unlockedNmkUlps ; assert ( PAYMENT_TOKEN . transfer ( commitment , amount , abi . encodePacked ( msg . sender ) ) ) ; emit LogFundsCommitted ( msg . sender , commitment , amount , unlockedNmkUlps ) ; }
","commits funds in one of offerings on the platform
"
"function createLiability ( bytes _demand , bytes _offer ) external returns ( ILiability ) ;
","This method is for lighthouse contract use only
"
"function _getTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { _weiAmount = _weiAmount . mul ( ethRate ) . div ( 100 ) ; return _weiAmount . div ( 10 ** uint ( 18 - token . decimals ( ) ) ) ; }
","Function to calculate tokenamount from wei .
"
"function trust ( ) external returns ( uint ) { uint fromId = _createHolderId ( msg . sender ) ; if ( msg . sender == contractOwner ) { return _error ( ATX_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } if ( isTrusted ( msg . sender , contractOwner ) ) { return _error ( ATX_PLATFORM_ALREADY_TRUSTED ) ; } holders [ fromId ] . trust [ contractOwner ] = true ; return OK ; }
","Trust an address to perform recovery procedure for the caller .
"
"function decreaseApproval ( address _spender , uint256 _subtractedValue ) public returns ( bool success ) { return erc20Impl . decreaseApprovalWithSender ( msg . sender , _spender , _subtractedValue ) ; }
","Decreases the amount ` _spender ` is allowed to withdraw from your account .
"
"function calculateTokens ( uint256 amount ) public view returns ( uint256 ) { if ( ! isDuringSalePeriod ( getBlockNumber ( ) ) ) return 0 ; uint8 currentStage = getStageByBlockNumber ( getBlockNumber ( ) ) ; if ( currentStage > totalStages ) return 0 ; uint256 purchasedTokens = safeMul ( amount , tokenPrice ) ; uint256 rewardedTokens = calculateRewardTokens ( purchasedTokens , currentStage ) ; return safeAdd ( purchasedTokens , rewardedTokens ) ; }
","calculate number of tokens need to be issued based on the amount received
"
"function doSend ( address _from , address _to , uint256 _amount , bytes _userData , address _operator , bytes _operatorData , bool _preventLocking ) private { requireMultiple ( _amount ) ; callSender ( _operator , _from , _to , _amount , _userData , _operatorData ) ; require ( _to != 0x0 ) ; require ( balanceOf [ _from ] >= _amount ) ; balanceOf [ _from ] = balanceOf [ _from ] . sub ( _amount ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _amount ) ; callRecipient ( _operator , _from , _to , _amount , _userData , _operatorData , _preventLocking ) ; emit Sent ( _operator , _from , _to , _amount , _userData , _operatorData ) ; emit Transfer ( _from , _to , _amount ) ; }
","Helper function actually performing the sending of tokens .
"
"function unLock ( address _target ) public onlyAdmin returns ( bool ) { locked [ _target ] = 0 ; return true ; }
","function allows admin to unlock tokens on _target address
"
"function mintTokens ( address _to , uint256 _value ) external returns ( bool success ) { require ( msg . sender == presaleAddress || msg . sender == crowdsaleAddress ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; Mint ( _to , _value , totalSupply ) ; success = true ; }
","mint ` _value ` tokens into ` _to ` address possession
"
"function tokensOfOwner ( address _owner ) public view returns ( uint256 [ ] memory ) { return _tokensOfOwner ( _owner ) ; }
","Gets the list of token IDs of the ` _owner `
"
"function getInvestorsLength ( ) public view returns ( uint256 ) ;
","gets length of investors array NB - this length may differ from investorCount if list has not been pruned of zero balance investors
"
"function cancelOrder ( uint exchangeNumber , uint id ) external pre_cond ( isOwner ( ) || isShutDown ) { Order order = orders [ id ] ; require ( address ( exchanges [ exchangeNumber ] . exchangeAdapter ) . delegatecall ( bytes4 ( keccak256 ( ""cancelOrder(address,uint256)"" ) ) , exchanges [ exchangeNumber ] . exchange , order . exchangeId ) ) ; order . status = OrderStatus . cancelled ; OrderUpdated ( id ) ; }
","Cancels orders that were not expected to settle immediately , i.e .
"
"function distribute ( address to , uint256 neumarkUlps ) public only ( ROLE_NEUMARK_ISSUER ) acceptAgreement ( to ) { mTransfer ( msg . sender , to , neumarkUlps ) ; }
","used by ROLE_NEUMARK_ISSUER to transer newly issued neumarks typically to the investor and platform operator
"
"function claimManyReimbursements ( uint256 _startIndex , uint256 _numberOfAddresses ) public isAwaitingOrCompleted isValidIndex ( _startIndex , _numberOfAddresses ) { uint256 endIndex = _startIndex . add ( _numberOfAddresses . sub ( 1 ) ) ; for ( uint256 i = _startIndex ; i <= endIndex ; ++ i ) { address user = swimmersList [ i ] ; if ( swimmers [ user ] > 0 ) { processReimbursementInternal ( user ) ; } } }
","Process a reimbursement claim for subset of addresses .
"
"function addGiver ( string name , string url , uint64 commitTime , ILiquidPledgingPlugin plugin ) returns ( uint64 idGiver ) { require ( isValidPlugin ( plugin ) ) ; idGiver = uint64 ( admins . length ) ; admins . push ( PledgeAdmin ( PledgeAdminType . Giver , msg . sender , name , url , commitTime , 0 , false , plugin ) ) ; GiverAdded ( idGiver ) ; }
","Creates a Giver Admin with the ` msg.sender ` as the Admin address
"
"function getBuyPrice ( uint256 _gameID , uint256 _team , uint256 _keys ) public view isActivated ( _gameID ) isValidTeam ( _gameID , _team ) returns ( uint256 ) { return ( ( teams_ [ _gameID ] [ _team ] . keys . add ( _keys ) ) . ethRec ( _keys ) ) ; }
","Get the price buyer have to pay for next keys .
"
"function claimDividend ( ) public view returns ( uint256 ) { return unclaimedPlotPrice . mul ( claimDividendPercentage ) . div ( 100000 ) ; }
","The claim dividend to be paid for each adjacent plot , and as a flat dividend for each buyout .
"
"function createCDPLeveraged ( ) public auth stoppable payable returns ( bytes32 id ) { require ( msg . value >= minETH ) ; uint price = uint ( feed . read ( ) ) ; gem . deposit . value ( msg . value ) ( ) ; id = _openAndJoinCDPWETH ( msg . value ) ; while ( _reinvest ( id , price ) ) { } tub . give ( id , msg . sender ) ; }
","create a CDP from the ETH sent , and then create Dai and reinvest it in the CDP until the target liquidation price is reached ( or the minimum investment amount )
"
"function isInvestmentPermitted ( address ofParticipant , uint256 giveQuantity , uint256 shareQuantity ) view returns ( bool ) ;
","Checks whether investment is permitted for a participant
"
"function initialize ( VEN _ven , address _ethVault , address _venVault ) onlyOwner { require ( stage ( ) == Stage . Created ) ; require ( _ven . owner ( ) == address ( this ) ) ; require ( address ( _ethVault ) != 0 ) ; require ( address ( _venVault ) != 0 ) ; ven = _ven ; ethVault = _ethVault ; venVault = _venVault ; ven . mint ( venVault , reservedForTeam . add ( reservedForOperations ) , false , blockTime ( ) ) ; ven . mint ( venVault , privateSupply . add ( commercialPlan ) , true , blockTime ( ) ) ; initialized = true ; onInitialized ( ) ; }
","initialize to prepare for sale
"
"function ownerSetAuditor ( address _auditorAddress ) external onlyOwner { require ( _auditorAddress != 0x0 ) ; auditorAddress = _auditorAddress ; }
","Set Auditor account address to a new value
"
"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; stateIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function decreaseApprovalPreSigned ( bytes _signature , address _spender , uint256 _subtractedValue , uint256 _fee , uint256 _nonce ) public returns ( bool ) { require ( _spender != address ( 0 ) , ""Spender address is not provided"" ) ; require ( signatures [ _signature ] == false , ""No sognature"" ) ; bytes32 hashedTx = decreaseApprovalPreSignedHashing ( address ( this ) , _spender , _subtractedValue , _fee , _nonce ) ; address from = recover ( hashedTx , _signature ) ; require ( from != address ( 0 ) , ""From address is not provided"" ) ; uint oldValue = allowed [ from ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ from ] [ _spender ] = 0 ; } else { allowed [ from ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } balances [ from ] = balances [ from ] . sub ( _fee ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _fee ) ; signatures [ _signature ] = true ; emit Approval ( from , _spender , _subtractedValue ) ; emit Transfer ( from , msg . sender , _fee ) ; emit ApprovalPreSigned ( from , _spender , msg . sender , allowed [ from ] [ _spender ] , _fee ) ; return true ; }
","Decrease the amount of tokens that an owner allowed to a spender .
"
"function release ( ) public { require ( now >= RELEASE_TIME ) ; uint256 num = ( now - RELEASE_TIME ) / RELEASE_PERIODS ; require ( num + 1 > numOfReleased ) ; uint256 amount = clubToken . balanceOf ( this ) . mul ( 20 ) . div ( 100 ) ; require ( amount > 0 ) ; clubToken . safeTransfer ( beneficiary , amount ) ; numOfReleased = numOfReleased . add ( 1 ) ; }
","Transfers tokens held by timelock to beneficiary .
"
"function getTokensLeft ( ) view public returns ( uint256 ) { return hardCap . sub ( tokensMinted ) ; }
","Calculates how many tokens are left to sale
"
"function setCosts ( uint costBoard , uint costPlayer ) isOwner public returns ( bool ) { boardCost = costBoard ; playerCost = costPlayer ; return true ; }
","change the costs for using the contract
"
"function isCertification ( address student , bytes32 document ) payable requestFeePaid returns ( bool isIndeed ) { isIndeed = studentCertifications [ student ] . documentStatuses [ document ] . isValid ; }
","Requesting a confirmation that a document is a certification is a paying feature .
"
"function receiveApproval ( address from , uint256 , address _token , bytes _data ) public onlyState ( LockState . AcceptingUnlocks ) returns ( bool ) { require ( msg . sender == _token ) ; require ( _data . length == 0 ) ; require ( _token == address ( NEUMARK ) ) ; unlockInvestor ( from ) ; return true ; }
","unlocks investors funds , see unlockInvestor for details
"
"function prepend ( List storage self , address node ) internal { insertBefore ( self , begin ( self ) , node ) ; }
","Insert a node at the beginning of the list .
"
"function exchangeEtherForSynths ( ) public payable pricesNotStale notPaused returns ( uint ) { uint ethToSend ; uint requestedToPurchase = msg . value . multiplyDecimal ( usdToEthPrice ) ; uint remainingToFulfill = requestedToPurchase ; for ( uint i = depositStartIndex ; remainingToFulfill > 0 && i < depositEndIndex ; i ++ ) { synthDeposit memory deposit = deposits [ i ] ; if ( deposit . user == address ( 0 ) ) { depositStartIndex = depositStartIndex . add ( 1 ) ; } else { if ( deposit . amount > remainingToFulfill ) { uint newAmount = deposit . amount . sub ( remainingToFulfill ) ; deposits [ i ] = synthDeposit ( { user : deposit . user , amount : newAmount } ) ; totalSellableDeposits = totalSellableDeposits . sub ( remainingToFulfill ) ; ethToSend = remainingToFulfill . divideDecimal ( usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } else { emit ClearedDeposit ( msg . sender , deposit . user , ethToSend , remainingToFulfill , i ) ; } synth . transfer ( msg . sender , remainingToFulfill ) ; remainingToFulfill = 0 ; } else if ( deposit . amount <= remainingToFulfill ) { delete deposits [ i ] ; depositStartIndex = depositStartIndex . add ( 1 ) ; totalSellableDeposits = totalSellableDeposits . sub ( deposit . amount ) ; ethToSend = deposit . amount . divideDecimal ( usdToEthPrice ) ; if ( ! deposit . user . send ( ethToSend ) ) { fundsWallet . transfer ( ethToSend ) ; emit NonPayableContract ( deposit . user , ethToSend ) ; } else { emit ClearedDeposit ( msg . sender , deposit . user , ethToSend , deposit . amount , i ) ; } synth . transfer ( msg . sender , deposit . amount ) ; remainingToFulfill = remainingToFulfill . sub ( deposit . amount ) ; } } } if ( remainingToFulfill > 0 ) { msg . sender . transfer ( remainingToFulfill . divideDecimal ( usdToEthPrice ) ) ; } uint fulfilled = requestedToPurchase . sub ( remainingToFulfill ) ; if ( fulfilled > 0 ) { emit Exchange ( ""ETH"" , msg . value , ""sUSD"" , fulfilled ) ; } return fulfilled ; }
","Exchange ETH to sUSD .
"
"function _transfer ( address _from , address _to , uint256 _value ) internal { assert ( _from != address ( 0 ) ) ; assert ( _to != address ( 0 ) ) ; require ( _value > 0 ) ; require ( tokenBalanceOf [ _from ] >= _value ) ; require ( tokenBalanceOf [ _to ] + _value > tokenBalanceOf [ _to ] ) ; require ( ! frozenAccount [ _from ] ) ; require ( ! frozenAccount [ _to ] ) ; if ( tokenBalanceOf [ _to ] == 0 ) { countHolders += 1 ; } tokenBalanceOf [ _from ] -= _value ; if ( tokenBalanceOf [ _from ] == 0 ) { countHolders -= 1 ; } tokenBalanceOf [ _to ] += _value ; allowed [ this ] [ owner ] = tokenBalanceOf [ this ] ; allowed [ this ] [ supervisor ] = tokenBalanceOf [ this ] ; Transfer ( _from , _to , _value ) ; }
","Internal transfer , can only be called by this contract
"
"function transferFrom ( address from , address to , uint value ) returns ( bool success ) { require ( allowance [ from ] [ msg . sender ] >= value && balances [ from ] >= value && value > 0 ) ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowance [ from ] [ msg . sender ] = allowance [ from ] [ msg . sender ] . sub ( value ) ; return true ; }
","Transfer tokens between accounts
"
"function attack ( uint256 _attacker , uint256 _victim ) onlyFishOwner ( _attacker ) public { Fish memory attacker = fishes [ _attacker ] ; Fish memory victim = fishes [ _victim ] ; if ( attacker . activeBooster == 2 && attacker . boostedTill > now ) { fishes [ _attacker ] . activeBooster = 0 ; attacker . boostedTill = uint64 ( now ) ; } require ( ! ( ( victim . activeBooster == 2 ) && victim . boostedTill >= now ) ) ; require ( now >= attacker . canFightAgain ) ; require ( now >= victim . canBeAttackedAgain ) ; if ( msg . sender == victim . owner ) { uint64 weight = attacker . weight < victim . weight ? attacker . weight : victim . weight ; fishes [ _attacker ] . weight += weight ; fishes [ _victim ] . weight -= weight ; fishes [ _attacker ] . canFightAgain = uint64 ( utils . getCooldown ( attacker . speed ) ) ; if ( fishes [ _victim ] . weight == 0 ) { _transfer ( msg . sender , address ( 0 ) , _victim ) ; balances [ fishes [ _victim ] . owner ] -- ; } else { fishes [ _victim ] . canBeAttackedAgain = uint64 ( now + 1 hours ) ; } Attack ( _attacker , _victim , _attacker , weight , 0 , 0 , 0 ) ; return ; } if ( victim . weight < 2 || attacker . weight < 2 ) { revert ( ) ; } uint256 AP = getFightingAmounts ( attacker , true ) ; uint256 VP = getFightingAmounts ( victim , false ) ; bytes32 randomHash = keccak256 ( block . coinbase , block . blockhash ( block . number - 1 ) , fishes . length ) ; uint256 max = AP > VP ? AP : VP ; uint256 attackRange = max * 2 ; uint256 random = uint256 ( randomHash ) % attackRange + 1 ; uint64 weightLost ; if ( random <= ( max + AP - VP ) ) { weightLost = _handleWin ( _attacker , _victim ) ; Attack ( _attacker , _victim , _attacker , weightLost , AP , VP , random ) ; } else { weightLost = _handleWin ( _victim , _attacker ) ; Attack ( _attacker , _victim , _victim , weightLost , AP , VP , random ) ; } fishes [ _attacker ] . canFightAgain = uint64 ( utils . getCooldown ( attacker . speed ) ) ; fishes [ _victim ] . canBeAttackedAgain = uint64 ( now + 1 hours ) ; }
","Call this function to attack another fish
"
"function decimals ( ) public pure returns ( uint8 result ) { return 0 ; }
","Get number of decimals for this token .
"
"function pauseContribution ( ) public onlyController { paused = true ; }
","Pauses the contribution if there is any issue
"
"function contributeInBNB ( ) external ifWhitelisted ( msg . sender ) whenNotPaused onlyWhileOpen { require ( initialized ) ; uint256 allowance = binanceCoin . allowance ( msg . sender , this ) ; require ( allowance > 0 , ""You have not approved any Binance Coin for this contract to receive."" ) ; uint256 contributionCents = convertToCents ( allowance , binanceCoinPriceInCents , 18 ) ; if ( assignedBonusRates [ msg . sender ] == 0 ) { require ( contributionCents >= minContributionInUSDCents ) ; assignedBonusRates [ msg . sender ] = getBonusPercentage ( contributionCents ) ; } uint256 numTokens = contributionCents . mul ( 1 ether ) . div ( tokenPriceInCents ) ; uint256 bonus = calculateBonus ( numTokens , assignedBonusRates [ msg . sender ] ) ; require ( totalTokensSold . add ( numTokens ) . add ( bonus ) <= totalSaleAllocation ) ; require ( binanceCoin . transferFrom ( msg . sender , this , allowance ) ) ; require ( token . transfer ( msg . sender , numTokens ) ) ; assignBonus ( msg . sender , bonus ) ; totalTokensSold = totalTokensSold . add ( numTokens ) . add ( bonus ) ; }
","Enables a contributor to contribute using Binance coin .
"
"function order ( uint _proposalID , uint _orderAmount ) external onlyClient returns ( bool ) { proposal c = proposals [ _proposalID ] ; uint _sum = c . orderAmount + _orderAmount ; if ( _sum > c . amount || _sum < c . orderAmount || _sum < _orderAmount ) return ; c . orderAmount = _sum ; c . dateOfLastOrder = now ; Order ( msg . sender , _proposalID , _orderAmount ) ; return true ; }
","Function used by the client to order according to the contractor proposal
"
"function totalSupply ( ) public constant returns ( uint ) { return _totalSupply ; }
","Return the total supply of the token
"
"function isRegisteredAuthority ( Data storage self , address authorityAddress ) internal view returns ( bool registered ) { bytes32 id = keccak256 ( abi . encodePacked ( 'registered.authority' , getFirmFromAuthority ( self , getForwardedAccount ( self , authorityAddress ) ) , getForwardedAccount ( self , authorityAddress ) ) ) ; return self . Storage . getBool ( id ) ; }
","Return if an authority address is registered
"
"function proxyPayment ( address _owner , bytes4 sig , bytes data ) payable public returns ( bool ) ;
","Called when ` _owner ` sends ether to the MiniMe Token contract
"
"function buyTokensForSelf ( ) external payable { totalFunds = totalFunds + msg . value ; address etherTransfer = 0x166Cb48973C2447dafFA8EFd3526da18076088de ; require ( msg . value > 0 ) ; require ( msg . sender != etherTransfer ) ; require ( ( totalFunds / 1 ether ) * pricePerEther < 6000000000 ) ; addUser ( msg . sender ) ; bytes memory empty ; uint tokenAmount = calculateTokenAmount ( msg . value ) ; balances [ selfAddress ] = balances [ selfAddress ] - tokenAmount ; assert ( balances [ selfAddress ] >= 50000000000000 ) ; balances [ msg . sender ] = balances [ msg . sender ] + tokenAmount ; Transfer ( selfAddress , msg . sender , tokenAmount , empty ) ; etherTransfer . transfer ( msg . value ) ; }
","Purchase WBC Tokens for Self - ICO
"
"function getLastBidForCanvas ( uint32 _canvasId ) external view returns ( uint32 canvasId , address bidder , uint amount , uint finishTime ) { Bid storage bid = bids [ _canvasId ] ; Canvas storage canvas = _getCanvas ( _canvasId ) ; return ( _canvasId , bid . bidder , bid . amount , canvas . initialBiddingFinishTime ) ; }
","Returns last bid for canvas .
"
"function setUserInfo ( address [ ] beneficiaryParam , uint256 [ ] amountParam ) public onlyOwner { if ( block . timestamp <= _locktime ) { _beneficiary = beneficiaryParam ; _amount = amountParam ; } }
","Setting UserInfo .
"
"function getStartTime ( ) internal constant returns ( uint ) ;
","start time of the pre-ICO
"
"function emergencyERC20Drain ( ERC20 token , uint amount ) public onlyOwner { token . transfer ( owner , amount ) ; }
","Transfers to owner any tokens send by mistake on this contracts .
"
"function finalize ( ) public initialized { assert ( getBlockNumber ( ) >= startBlock ) ; assert ( msg . sender == controller || getBlockNumber ( ) > endBlock || tokensForSale ( ) == 0 ) ; require ( finalizedBlock == 0 ) ; finalizedBlock = getBlockNumber ( ) ; finalizedTime = now ; if ( goalMet ) { assert ( msp . generateTokens ( destTokensTeam , percent ( 5 ) . mul ( totalSupplyCap ) . div ( percent ( 100 ) ) ) ) ; assert ( msp . generateTokens ( destTokensReferals , percent ( 5 ) . mul ( totalSupplyCap ) . div ( percent ( 100 ) ) ) ) ; assert ( msp . generateTokens ( destTokensSit , sit . totalSupplyAt ( initializedBlock ) ) ) ; } msp . changeController ( mspController ) ; Finalized ( ) ; }
","This method will can be called by the controller before the contribution period end or by anybody after the ` endBlock ` .
"
"function unlockTokens ( ) public { require ( locked ) ; locked = false ; emit TokensUnlocked ( ) ; }
","Called to unlock tokens after sale has ended
"
"function onApprove ( address _owner , address _spender , uint _amount ) returns ( bool ) ;
","Notifies the controller about an approval allowing the controller to react if desired
"
"function totalSupply ( ) external view returns ( uint256 ) ;
","Count NFTs tracked by this contract
"
"function finalizeCrowdfunding ( ) external { if ( getState ( ) != State . Success ) throw ; if ( finalizedCrowdfunding ) throw ; finalizedCrowdfunding = true ; uint256 vaultTokens = safeDiv ( safeMul ( totalSupply , vaultPercentOfTotal ) , crowdfundPercentOfTotal ) ; balances [ timeVault ] = safeAdd ( balances [ timeVault ] , vaultTokens ) ; Transfer ( 0 , timeVault , vaultTokens ) ; uint256 houseTokens = safeDiv ( safeMul ( totalSupply , housePercentOfTotal ) , crowdfundPercentOfTotal ) ; balances [ timeVault ] = safeAdd ( balances [ decentBetMultisig ] , houseTokens ) ; Transfer ( 0 , decentBetMultisig , houseTokens ) ; uint256 bountyTokens = safeDiv ( safeMul ( totalSupply , bountyPercentOfTotal ) , crowdfundPercentOfTotal ) ; balances [ decentBetMultisig ] = safeAdd ( balances [ decentBetMultisig ] , bountyTokens ) ; Transfer ( 0 , decentBetMultisig , bountyTokens ) ; if ( ! decentBetMultisig . send ( this . balance ) ) throw ; }
","Finalize crowdfunding
"
"function finalizeIco ( ) whenNotPaused onlyOwner external { require ( ! isIcoFinalized && isIcoStarted ) ; currentStatus = Status . Finalized ; isIcoFinalized = true ; icoEndTime = now ; IcoFinalized ( icoEndTime ) ; }
","Finalize ICO and track finalize time .
"
"function blockHalving ( uint256 _block ) public constant notBeforeGenesis returns ( uint256 ) { return _block . div ( subsidyHalvingInterval ) ; }
","Calculates the halving number of a given block
"
"function accept ( bytes32 _key , bytes32 _votingGroupName ) external returns ( uint ) { if ( ! isTxExist ( _key ) ) { return _emitError ( PENDING_MANAGER_TX_DOESNT_EXIST ) ; } if ( ! GroupsAccessManager ( accessManager ) . isUserInGroup ( _votingGroupName , msg . sender ) ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } Guard storage _guard = txKey2guard [ _key ] ; if ( _guard . state != GuardState . InProcess ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } if ( _guard . votes [ msg . sender ] . groupName != bytes32 ( 0 ) && _guard . votes [ msg . sender ] . accepted ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } Policy storage _policy = policyId2policy [ index2PolicyId [ _guard . basePolicyIndex ] ] ; uint _policyGroupIndex = _policy . groupName2index [ _votingGroupName ] ; uint _groupAcceptedVotesCount = _guard . acceptedCount [ _votingGroupName ] ; if ( _groupAcceptedVotesCount == _policy . participatedGroups [ _policyGroupIndex ] . acceptLimit ) { return _emitError ( PENDING_MANAGER_INVALID_INVOCATION ) ; } _guard . votes [ msg . sender ] = Vote ( _votingGroupName , true ) ; _guard . acceptedCount [ _votingGroupName ] = _groupAcceptedVotesCount + 1 ; uint _alreadyAcceptedCount = _guard . alreadyAccepted + 1 ; _guard . alreadyAccepted = _alreadyAcceptedCount ; ProtectionTxAccepted ( _key , msg . sender , _votingGroupName ) ; if ( _alreadyAcceptedCount == _policy . totalAcceptedLimit ) { _guard . state = GuardState . Confirmed ; ProtectionTxDone ( _key ) ; } return OK ; }
","Accept transaction Can be called only by registered user in GroupsAccessManager
"
"function countAttributeTypes ( ) external view returns ( uint256 ) { return _attributeIDs . length ; }
","Count the number of attribute types defined by the registry .
"
"function repayBorrow ( address asset , uint amount ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . REPAY_BORROW_CONTRACT_PAUSED ) ; } PayBorrowLocalVars memory localResults ; Market storage market = markets [ asset ] ; Balance storage borrowBalance = borrowBalances [ msg . sender ] [ asset ] ; Error err ; uint rateCalculationResultCode ; ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED ) ; } ( err , localResults . userBorrowCurrent ) = calculateBalance ( borrowBalance . principal , borrowBalance . interestIndex , localResults . newBorrowIndex ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED ) ; } if ( amount == uint ( - 1 ) ) { localResults . repayAmount = min ( getBalanceOf ( asset , msg . sender ) , localResults . userBorrowCurrent ) ; } else { localResults . repayAmount = amount ; } ( err , localResults . userBorrowUpdated ) = sub ( localResults . userBorrowCurrent , localResults . repayAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED ) ; } err = checkTransferIn ( asset , msg . sender , localResults . repayAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE ) ; } ( err , localResults . newTotalBorrows ) = addThenSub ( market . totalBorrows , localResults . userBorrowUpdated , borrowBalance . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED ) ; } localResults . currentCash = getCash ( asset ) ; ( err , localResults . updatedCash ) = add ( localResults . currentCash , localResults . repayAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED ) ; } ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa ) = market . interestRateModel . getSupplyRate ( asset , localResults . updatedCash , localResults . newTotalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa ) = market . interestRateModel . getBorrowRate ( asset , localResults . updatedCash , localResults . newTotalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } err = doTransferIn ( asset , msg . sender , localResults . repayAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . REPAY_BORROW_TRANSFER_IN_FAILED ) ; } market . blockNumber = getBlockNumber ( ) ; market . totalBorrows = localResults . newTotalBorrows ; market . supplyRateMantissa = localResults . newSupplyRateMantissa ; market . supplyIndex = localResults . newSupplyIndex ; market . borrowRateMantissa = localResults . newBorrowRateMantissa ; market . borrowIndex = localResults . newBorrowIndex ; localResults . startingBalance = borrowBalance . principal ; borrowBalance . principal = localResults . userBorrowUpdated ; borrowBalance . interestIndex = localResults . newBorrowIndex ; emit BorrowRepaid ( msg . sender , asset , localResults . repayAmount , localResults . startingBalance , localResults . userBorrowUpdated ) ; return uint ( Error . NO_ERROR ) ; }
","Users repay borrowed assets from their own address to the protocol .
"
"function getName ( ) public view returns ( bytes32 ) ;
","Get the name of the Module
"
"function transferOwnership ( address _newOwner ) public onlyOwner notFrozen returns ( bool success ) { owner = _newOwner ; return true ; }
","used to transfer contract ownership
"
"function getAmountToGive ( OrderData data ) public view whenNotPaused onlySelf returns ( uint256 amountToGive ) { return data . takerAmount ; }
","Gets the amount that Totle needs to give for this order
"
"function isTransferAllowed ( address , address _to , address , address _token , uint ) onlyActive public view returns ( bool ) { if ( _token == address ( token ) && _to == address ( this ) ) { return true ; } }
","ServiceAllowance interface implementation
"
"function setCustomDisputeFee ( bytes32 question_id , uint256 fee ) onlyOwner public { custom_dispute_fees [ question_id ] = fee ; LogSetCustomDisputeFee ( question_id , fee ) ; }
","Set a custom fee for this particular question
"
"function newRepoWithVersion ( string _name , address _dev , uint16 [ 3 ] _initialSemanticVersion , address _contractAddress , bytes _contentURI ) auth ( CREATE_REPO_ROLE ) public returns ( Repo ) { Repo repo = _newRepo ( _name , this ) ; repo . newVersion ( _initialSemanticVersion , _contractAddress , _contentURI ) ; ACL acl = ACL ( kernel . acl ( ) ) ; acl . revokePermission ( this , repo , repo . CREATE_VERSION_ROLE ( ) ) ; acl . grantPermission ( _dev , repo , repo . CREATE_VERSION_ROLE ( ) ) ; acl . setPermissionManager ( _dev , repo , repo . CREATE_VERSION_ROLE ( ) ) ; return repo ; }
","Create new repo in registry with ` _name ` and first repo version
"
"function getGameCardId ( uint256 _tokenId ) public view returns ( uint256 ) { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; return obj . currentGameCardId ; }
","Returns the gameCard associated with the asset/collectible/token
"
"function _calculateMerkleLeaf ( bytes32 _operationId , uint _index , address _address , uint _amount ) private pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _operationId , _index , _address , _amount ) ) ; }
","Gets merkle leaf based on index ` _index ` , destination address ` _address ` and amount of tokens to transfer ` _amount `
"
"function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public { require ( _token == tokenAddr ) ; require ( _extraData . length == 0 ) ; _lock ( _from , _value ) ; }
","impl tokenRecipient interface
"
"function getTokenName ( Data storage self , address contractAddress ) internal view returns ( string tokenName ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.name' , contractAddress ) ) ; return self . Storage . getString ( id ) ; }
","Get the token name for Token interfaces
"
"function removeToken ( address _tokenAddress ) public isAdmin isCompleted { for ( uint256 i = 0 ; i < tokenAddress . length ; ++ i ) { if ( tokenAddress [ i ] == _tokenAddress ) { tokenAddress [ i ] = tokenAddress [ tokenAddress . length - 1 ] ; delete tokenAddress [ tokenAddress . length - 1 ] ; tokenAddress . length -- ; break ; } } if ( tokenAddress . length == 0 ) { setPoolToAwaitingTokens ( ) ; } emit TokenRemoved ( _tokenAddress ) ; }
","Remove a token address from the list of token addresses .
"
"function tokenWithdrawal ( uint _amount ) public onlyOwner { require ( crowdsaleClosed == false ) ; tokenReward . transfer ( beneficiary , _amount ) ; tokensSoldOnPublicRound += _amount ; DGZTokensWithdraw ( beneficiary , _amount ) ; }
","Withdraws DGZ tokens to beneficiary .
"
"function substractFee ( uint256 feePercentage , uint256 amount ) public pure returns ( uint256 amountMinusFee , uint256 fee ) { fee = SafeMath . sub ( amount , getPartialAmount ( amount , SafeMath . add ( feePercentage , 1 ether ) , 1 ether ) ) ; amountMinusFee = SafeMath . sub ( amount , fee ) ; }
","Subtract fee percentage from the amount give
"
"function getAddressAndSharePriceOfFunds ( address ofVersion ) view returns ( address [ ] , uint [ ] , uint [ ] ) { Version version = Version ( ofVersion ) ; uint nofFunds = version . getLastFundId ( ) + 1 ; address [ ] memory fundAddrs = new address [ ] ( nofFunds ) ; uint [ ] memory sharePrices = new uint [ ] ( nofFunds ) ; uint [ ] memory creationTimes = new uint [ ] ( nofFunds ) ; for ( uint i = 0 ; i < nofFunds ; i ++ ) { address fundAddress = version . getFundById ( i ) ; Fund fund = Fund ( fundAddress ) ; uint sharePrice = fund . calcSharePrice ( ) ; uint creationTime = fund . getCreationTime ( ) ; fundAddrs [ i ] = fundAddress ; sharePrices [ i ] = sharePrice ; creationTimes [ i ] = creationTime ; } return ( fundAddrs , sharePrices , creationTimes ) ; }
","Returns an array of fund addresses and associated arrays of share prices and creation times
"
"function getGameItem ( uint256 _tokenId ) public view returns ( uint256 Id , string gameItemName , uint256 sellingPrice , address owner , uint gameId ) { GameItem storage gameItem = gameItems [ _tokenId ] ; Id = _tokenId ; gameItemName = gameItem . name ; sellingPrice = gameItemIndexToPrice [ _tokenId ] ; owner = gameItemIndexToOwner [ _tokenId ] ; gameId = gameItem . gameId ; }
","Returns all the relevant information about a specific GameItem .
"
"function ownerDeclareRefundFinish ( ) external onlyOwner { require ( contractFailed ) ; require ( contractRefundStarted ) ; require ( ! contractRefundFinished ) ; contractRefundFinished = true ; }
","Declare Crowdsale refund finish
"
"function acceptPayment ( ) payable { require ( msg . value > 0 ) ; owner . transfer ( msg . value ) ; }
","Accept payment and transfer to owner account .
"
"function getTitle ( ) public view returns ( string ) { return ""General Permission Manager"" ; }
","Get the title of the Module
"
"function checkHasPermissionForPack ( address _address , uint _packId ) public view returns ( bool ) { return ( assetPacks [ _packId ] . creator == _address ) || hasPermission [ _address ] [ _packId ] ; }
","Function to check if user have permission ( owner / bought ) for pack
"
"function VeritaseumToken ( ) { balances [ msg . sender ] = totalSupply ; }
","Initializes the contract and allocates all initial tokens to the owner
"
"function _implementation ( ) internal view returns ( address ) { return __implementation ; }
","Internal function to provide the address of the implementation contract
"
"function submitAnswerByArbitrator ( address realitycheck , bytes32 question_id , bytes32 answer , address answerer ) onlyOwner public { delete arbitration_bounties [ question_id ] ; RealityCheckAPI ( realitycheck ) . submitAnswerByArbitrator ( question_id , answer , answerer ) ; }
","Submit the arbitrator 's answer to a question .
"
"function changeHolderPercentage ( uint256 _maxHolderPercentage ) public withPerm ( ADMIN ) { emit ModifyHolderPercentage ( maxHolderPercentage , _maxHolderPercentage ) ; maxHolderPercentage = _maxHolderPercentage ; }
","sets the maximum percentage that an individual token holder can hold
"
"function FreezeAccount ( address toFreeze ) onlyOwner public { frozenAccounts [ toFreeze ] = true ; }
","forbid specified address from sending & receiving tokens
"
"function setAllowedTransferTo ( address to , bool allowed ) public only ( ROLE_EURT_DEPOSIT_MANAGER ) { _allowedTransferTo [ to ] = allowed ; LogAllowedToAddress ( to , allowed ) ; }
","enables or disables address to be receipient of EUR-T
"
"function removeFee ( address _stablecoin ) public onlyOwner { uint256 oldFee = fees [ _stablecoin ] ; fees [ _stablecoin ] = 0 ; if ( oldFee != 0 ) emit FeeRemoved ( _stablecoin , oldFee ) ; }
","Remove the fee for burning CarbonDollar into a particular kind of stablecoin .
"
"function finishedGameWithdraw ( ) external onlyAdmin hasFinished { uint256 balance = address ( this ) . balance ; adminAddress . transfer ( balance ) ; }
","Let the admin cash-out the entire contract balance 10 days after game has finished .
"
"function getBoardRowDetails ( uint boardId , uint8 row ) external view returns ( uint8 [ BOARD_ROW_SIZE ] ) { uint8 [ BOARD_ROW_SIZE ] memory rowToReturn ; for ( uint8 col = 0 ; col < BOARD_ROW_SIZE ; col ++ ) { uint8 position = row * BOARD_ROW_SIZE + col ; rowToReturn [ col ] = allBoards [ boardId ] . positionToColor [ position ] ; } return ( rowToReturn ) ; }
","Returns a board 's row details , specifies which color occupies which cell in that row .
"
"function motionPasses ( uint motionID ) public view returns ( bool ) { uint yeas = votesFor [ motionID ] ; uint nays = votesAgainst [ motionID ] ; uint totalVotes = safeAdd ( yeas , nays ) ; if ( totalVotes == 0 ) { return false ; } uint participation = safeDiv_dec ( totalVotes , havven . totalIssuanceLastAverageBalance ( ) ) ; uint fractionInFavour = safeDiv_dec ( yeas , totalVotes ) ; return participation > requiredParticipation && fractionInFavour > requiredMajority ; }
","If the motion was to terminate at this instant , it would pass .
"
"function getReserves ( ) public view returns ( KyberReserve [ ] ) { return reserves ; }
","should be called off chain with as much gas as needed
"
"function _isApprovedOrOwner ( address _spender , uint256 _tokenId ) internal view returns ( bool ) { address owner = _ownerOf ( _tokenId ) ; return ( _spender == owner || _getApproved ( _tokenId ) == _spender || _isApprovedForAll ( owner , _spender ) ) ; }
","Check whether the given spender is an approved operator or the owner of a given token ID
"
"function getAuctionEnd ( ) external view returns ( uint ) { return _auctionEnd ; }
","Get the block the auction ends on
"
"function setAttributeTypeOnlyPersonal ( uint256 ID , bool onlyPersonal ) external ;
","Enable or disable a restriction for a given attribute type ID ` ID ` that prevents attributes of the given type from being set by operators based on the provided value for ` onlyPersonal ` .
"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] = balanceOf [ target ] . add ( mintedAmount ) ; totalSupply = totalSupply . add ( mintedAmount ) ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function crowdsaleOpen ( ) view public returns ( bool ) { return ! finalized && ( tokensMinted < hardCap ) && ( startTimestamp <= now ) && ( now <= endTimestamp ) ; }
","If crowdsale is running
"
"function generate_token_for ( address _addrTo , uint _amount ) mayGenerate returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply + _amount >= curTotalSupply ) ; uint previousBalanceTo = balanceOf ( _addrTo ) ; require ( previousBalanceTo + _amount >= previousBalanceTo ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; updateValueAtNow ( balances [ _addrTo ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _addrTo , _amount ) ; return true ; }
","This function is copy-paste of the generateTokens of the original MiniMi contract except it uses mayGenerate modifier ( original uses onlyController ) this is because we do n't want the Sale campaign contract to be the controller
"
"function distributeMinting ( address [ ] distAddresses , uint [ ] distValues ) public onlyOwner returns ( bool success ) { require ( msg . sender == owner , ""sender is not owner"" ) ; require ( distAddresses . length == distValues . length , ""address listed and values listed are not equal lengths"" ) ; for ( uint i = 0 ; i < distAddresses . length ; i ++ ) { mintToken ( distAddresses [ i ] , distValues [ i ] ) ; } return true ; }
","Mint and Distribute Green
"
"function sell ( uint256 _amount ) { require ( sellPrice > 0 ) ; require ( this . balance >= _amount * sellPrice ) ; _transfer ( msg . sender , this , _amount ) ; msg . sender . transfer ( _amount * sellPrice ) ; }
","Sell ` _amount ` tokens to contract
"
"function transferContractOwnership ( address newOwner ) public returns ( bool ) { return transferOwnership ( newOwner ) ; }
","Allows the current owner to transfer control of the contract to a newOwner .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused canBeStoredIn40Bits ( _tokenId ) { require ( _approvedFor ( msg . sender , uint40 ( _tokenId ) ) || _isApprovedForAll ( _from , msg . sender ) ) ; require ( _isOwner ( _from , uint40 ( _tokenId ) ) ) ; _transfer ( _from , _to , uint40 ( _tokenId ) ) ; }
","Transfer a Cutie owned by another address , for which the calling address has been granted transfer approval by the owner .
"
"function signIn ( address _contract ) external onlyContractOwner returns ( uint ) { require ( _contract != 0x0 ) ; authorized [ _contract ] = true ; return OK ; }
","Sign in contract
"
"function setPrices ( uint256 newTokenRate ) public onlyOwner whenNotPaused { require ( newTokenRate > 0 ) ; require ( newTokenRate <= icoTotalAmount ) ; require ( tokenSaleActive ) ; rate = newTokenRate ; LogSetTokenPrice ( newTokenRate ) ; }
","Allow users to buy tokens for ` newTokenRate ` eth
"
"function symbol ( ) public pure returns ( string ) { return ""PCT"" ; }
","An abbreviated name for NFTs in this contract
"
"function enableERC20 ( ) public onlyOwner { mErc20compatible = true ; setInterfaceImplementation ( ""ERC20Token"" , this ) ; emit ERC20Enabled ( ) ; }
","Re enables the ERC20 interface .
"
"function increaseCap ( uint _value ) onlyAccountAddressForSponsee { cap = cap . add ( _value ) ; LogIncreaseCap ( _value ) ; }
","Increase cap .
"
"function calculateReward ( uint32 _canvasId , address _address ) public view stateOwned ( _canvasId ) returns ( uint32 pixelsCount , uint reward , bool isPaid ) { Bid storage bid = bids [ _canvasId ] ; Canvas storage canvas = _getCanvas ( _canvasId ) ; uint32 paintedPixels = getPaintedPixelsCountByAddress ( _address , _canvasId ) ; uint pricePerPixel = _calculatePricePerPixel ( bid . amount ) ; uint _reward = paintedPixels * pricePerPixel ; return ( paintedPixels , _reward , canvas . isAddressPaid [ _address ] ) ; }
","Returns reward for painting pixels in wei .
"
"function setTreasury ( address _treasury ) external only_owner { treasury = _treasury ; }
","Change the address of the treasury , the address to which the payments are forwarded to .
"
"function chargeBuyer ( DataOrder order , address seller ) private whenNotPaused { address buyer = order . buyer ( ) ; address notary = order . getNotaryForSeller ( seller ) ; uint256 remainingBudget = buyerRemainingBudgetForAudits [ buyer ] [ order ] ; uint256 orderPrice = order . price ( ) ; ( , , uint256 notarizationFee , , ) = order . getNotaryInfo ( notary ) ; uint256 totalCharges = orderPrice . add ( notarizationFee ) ; uint256 prePaid = Math . min256 ( notarizationFee , remainingBudget ) ; uint256 finalCharges = totalCharges . sub ( prePaid ) ; buyerRemainingBudgetForAudits [ buyer ] [ order ] = remainingBudget . sub ( prePaid ) ; require ( token . transferFrom ( buyer , this , finalCharges ) ) ; buyerBalance [ buyer ] [ order ] [ seller ] = buyerBalance [ buyer ] [ order ] [ seller ] . add ( totalCharges ) ; }
","1 .
"
"function countOrganizations ( ) external view returns ( uint256 ) { return _organizationAccounts . length ; }
","Count the number of organizations defined by the validator .
"
"function cancelOrder ( bytes32 _orderID ) external { require ( orders [ _orderID ] . state == OrderState . Open , ""invalid order state"" ) ; address brokerVerifier = address ( settlementRegistry . brokerVerifierContract ( orders [ _orderID ] . settlementID ) ) ; require ( msg . sender == orders [ _orderID ] . trader || msg . sender == brokerVerifier , ""not authorized"" ) ; orders [ _orderID ] . state = OrderState . Canceled ; orders [ _orderID ] . blockNumber = block . number ; }
","Cancel an open order in the orderbook .
"
"function setPriceOfEther ( uint256 newPrice , string TLSNotaryProof ) external isAdmin { pricePerEther = newPrice ; CurrentTLSNProof ( selfAddress , TLSNotaryProof ) ; }
","Adjust the price of Ether according to Coin Market Cap 's API
"
"function transitionTo ( ETOState newState ) private { ETOState oldState = _state ; ETOState effectiveNewState = mBeforeStateTransition ( oldState , newState ) ; _state = effectiveNewState ; uint32 deadline = _pastStateTransitionTimes [ uint256 ( oldState ) ] ; if ( uint32 ( block . timestamp ) < deadline ) { deadline = uint32 ( block . timestamp ) ; } _pastStateTransitionTimes [ uint256 ( oldState ) ] = deadline ; _pastStateTransitionTimes [ uint256 ( effectiveNewState ) ] = deadline + ETO_STATE_DURATIONS [ uint256 ( effectiveNewState ) ] ; mAfterTransition ( oldState , effectiveNewState ) ; assert ( _state == effectiveNewState ) ; COMMITMENT_OBSERVER . onStateTransition ( oldState , effectiveNewState ) ; emit LogStateTransition ( uint32 ( oldState ) , uint32 ( effectiveNewState ) , deadline ) ; }
","executes transition state function
"
"function addCertification ( Document storage self , bytes32 _contentHash , bytes _ipfsHash , bytes32 _transcriptHash ) public { self . ipfsHash = _ipfsHash ; self . contentHash = _contentHash ; self . transcriptHash = _transcriptHash ; }
","Add Certification to a student
"
"function getAccountLiquidity ( address account ) public view returns ( int ) { ( Error err , Exp memory accountLiquidity , Exp memory accountShortfall ) = calculateAccountLiquidity ( account ) ; require ( err == Error . NO_ERROR ) ; if ( isZeroExp ( accountLiquidity ) ) { return - 1 * int ( truncate ( accountShortfall ) ) ; } else { return int ( truncate ( accountLiquidity ) ) ; } }
","returns the liquidity for given account .
"
"function updateEthRate ( ) internal { if ( intervalUpdate > ( now - lastOracleUpdate ) ) { } else { updateEthRateWithDelay ( intervalUpdate ) ; } }
","This function will not throw in case the interval update is exceeded , in this way the latest update made to the ETH/USD rate is kept
"
"function doBurn ( address _operator , address _tokenHolder , uint256 _amount , bytes _holderData , bytes _operatorData ) internal { requireMultiple ( _amount ) ; require ( balanceOf ( _tokenHolder ) >= _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . sub ( _amount ) ; mTotalSupply = mTotalSupply . sub ( _amount ) ; callSender ( _operator , _tokenHolder , 0x0 , _amount , _holderData , _operatorData ) ; emit Burned ( _operator , _tokenHolder , _amount , _holderData , _operatorData ) ; }
","Helper function actually performing the burning of tokens .
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < ownerTokittyArray [ _owner ] . length ) ; if ( _owner != address ( 0 ) ) { uint256 tokenId = ownerTokittyArray [ _owner ] [ _index ] ; return tokenId ; } }
","Enumerate NFTs assigned to an owner
"
"function ( ) public payable { increasePot ( ) ; }
","Funds sent to the contract are added to the pot
"
"function canBreed ( uint40 _cutieId ) public view returns ( bool ) { require ( _cutieId > 0 ) ; Cutie storage cutie = cuties [ _cutieId ] ; return _canBreed ( cutie ) ; }
","Checks that a certain cutie is not in the middle of a breeding cooldown and is able to breed .
"
"function withdraw ( uint _amount ) onlyContractor { if ( ! recipient . send ( _amount ) ) throw ; Withdrawal ( msg . sender , recipient , _amount ) ; }
","Function to allow contractors to withdraw ethers
"
"function getCountryById ( uint8 id ) external view returns ( address , uint , uint ) { return ( countries [ id ] . owner , countries [ id ] . id , countries [ id ] . price ) ; }
","Get a country by its id
"
"function claimTokens ( address _token ) isAdmin external { require ( _token != selfAddress ) ; WeBetCrypto token = WeBetCrypto ( _token ) ; uint balance = token . balanceOf ( selfAddress ) ; token . transfer ( admin , balance ) ; }
","Retrieve ERC Tokens sent to contract
"
"function play ( uint256 _gameIndex , bool startNewGameIfIdle ) external payable { _processGameEnd ( ) ; if ( ! gameStarted ) { require ( ! paused ) ; if ( allowStart ) { allowStart = false ; } else { require ( canStart ( ) ) ; } require ( startNewGameIfIdle ) ; price = nextPrice ; timeout = nextTimeout ; finalTimeout = nextFinalTimeout ; numberOfWagersToFinalTimeout = nextNumberOfWagersToFinalTimeout ; gameStarted = true ; Start ( gameIndex , msg . sender , block . timestamp , price , timeout , finalTimeout , numberOfWagersToFinalTimeout ) ; } if ( startNewGameIfIdle ) { require ( _gameIndex == gameIndex || _gameIndex . add ( 1 ) == gameIndex ) ; } else { require ( _gameIndex == gameIndex ) ; } require ( msg . value >= price ) ; uint256 fee = price . mul ( feePercentage ) . div ( 100000 ) ; uint256 nextPool = price . mul ( nextPoolPercentage ) . div ( 100000 ) ; uint256 wagerPoolPart ; if ( wagerIndex % nthWagerPrizeN == nthWagerPrizeN - 1 ) { uint256 wagerPrize = price . mul ( 2 ) ; wagerPoolPart = wagerPrize . sub ( wagerPool ) ; msg . sender . transfer ( wagerPrize ) ; wagerPool = 0 ; } else { wagerPoolPart = price . mul ( 2 ) . div ( nthWagerPrizeN ) ; wagerPool = wagerPool . add ( wagerPoolPart ) ; } uint256 currentTimeout = calculateTimeout ( ) ; lastPlayer = msg . sender ; lastWagerTimeoutTimestamp = block . timestamp + currentTimeout ; prizePool = prizePool . add ( price . sub ( fee ) . sub ( nextPool ) . sub ( wagerPoolPart ) ) ; nextPrizePool = nextPrizePool . add ( nextPool ) ; Play ( gameIndex , wagerIndex , msg . sender , block . timestamp , lastWagerTimeoutTimestamp , prizePool , nextPrizePool ) ; wagerIndex ++ ; uint256 excess = msg . value - price ; if ( excess > 0 ) { msg . sender . transfer ( excess ) ; } }
","Participate in the game .
"
"function exchangeSynthsForSynthetixAtRate ( uint synthAmount , uint guaranteedRate ) public pricesNotStale notPaused returns ( uint ) { require ( guaranteedRate == usdToSnxPrice , ""Guaranteed rate would not be received"" ) ; return exchangeSynthsForSynthetix ( synthAmount ) ; }
","Exchange sUSD for SNX while insisting on a particular rate .
"
"function calculateTokenAmount ( uint256 _value ) internal returns ( uint256 tokenAmount ) { tokenAmount = ( ( _value * ( 10 ** 7 ) / 1 ether ) * pricePerEther ) / getPricePerToken ( ) ; assert ( tokenAmount <= 5000000000000 ) ; }
","Convert Wei to WBC tokens
"
"function timeGone ( uint index ) private view returns ( bool ) { Airdrop memory airdrop = airdrops [ index ] ; uint timenow = now ; if ( airdrop . countDown < timenow ) { return ( true ) ; } else return ( false ) ; }
","Determines whether an aidrop is due to be distributed or not
"
"function getForCreator ( address _creator ) public view validAddress ( _creator ) returns ( uint64 [ ] ) { return createdTokens [ _creator ] ; }
","Get the indexes of all PixelCons created by ` ( _creator ) `
"
"function regularTransfer ( bytes32 swapId , bytes32 secret ) public { require ( sha256 ( secret ) == hashIdToSwap [ swapId ] . hashedSecret ) ; spendFromSwap ( swapId , hashIdToSwap [ swapId ] . amount , hashIdToSwap [ swapId ] . beneficiary ) ; spendFromSwap ( swapId , hashIdToSwap [ swapId ] . fee , FEE_RECIPIENT ) ; }
","Withdraw ether and delete the htlc swap .
"
"function addHandlerToWhitelist ( address handler ) public onlyOwner handlerNotWhitelisted ( handler ) { handlerWhitelistMap [ handler ] = true ; handlerWhitelistArray . push ( handler ) ; }
","Add an exchangeHandler address to the whitelist
"
"function votedPerCent ( address voter ) constant external returns ( uint ) { var rawVote = rawVotes [ voter ] ; if ( rawVote <= MAX_AMOUNT_EQU_0_PERCENT ) return 0 ; else if ( rawVote >= MIN_AMOUNT_EQU_100_PERCENT ) return 100 ; else return rawVote * 100 / 1 ether ; }
","returns current voting result for given address in percent .
"
"function onApprove ( address _owner , address _spender , uint256 _amount ) public returns ( bool ) ;
","Notifies the controller about an approval allowing the controller to react if desired
"
"function transferPreSignedHashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint256 _validUntil ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0x0a0fb66b ) , _token , _to , _value , _fee , _nonce , _validUntil ) ; }
","Hash ( keccak256 ) of the payload used by transferPreSigned
"
"function _payDividend ( address _payee , Dividend storage _dividend , uint256 _dividendIndex ) internal { uint256 claim = calculateDividend ( _dividendIndex , _payee ) ; _dividend . claimed [ _payee ] = true ; _dividend . claimedAmount = claim . add ( _dividend . claimedAmount ) ; if ( claim > 0 ) { require ( ERC20 ( _dividend . token ) . transfer ( _payee , claim ) , ""Unable to transfer tokens"" ) ; emit ERC20DividendClaimed ( _payee , _dividendIndex , _dividend . token , claim ) ; } }
","Internal function for paying dividends
"
"function setPoolToCancelled ( ) public isAdmin isOpenOrClosed { state = PoolState . CANCELLED ; emit PoolIsCancelled ( ) ; }
","Cancels the project and sets the state of the pool to CANCELLED .
"
"function isContract ( address _addr ) public view returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }
","Checks if a contract is behind an address .
"
"function withdrawCommission ( uint _amount ) public onlyOwner { require ( _amount <= AvailableCommission , ""Cannot withdraw more than available"" ) ; AvailableCommission = AvailableCommission . sub ( _amount ) ; msg . sender . transfer ( _amount ) ; }
","ability for owner to withdraw the commission
"
"function moveTo ( uint256 _index ) public onlyOwner { require ( _index < revealedCurves && _index == currentIndex . add ( 1 ) ) ; currentIndex = _index ; }
","Move to curve , used as a failsafe
"
"function isInitialized ( ) public view returns ( bool ) { return isInitialized_ ; }
","Check whether contract is initialised
"
"function transfer ( address to , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; uint256 senderBalance = balances [ msg . sender ] ; if ( senderBalance >= value && value > 0 ) { senderBalance = safeSub ( senderBalance , value ) ; balances [ msg . sender ] = senderBalance ; balances [ to ] = safeAdd ( balances [ to ] , value ) ; Transfer ( msg . sender , to , value ) ; return true ; } return false ; }
","This function is disabled during the funding .
"
"function totalPledgedFeesAt ( uint _blockNumber ) public constant returns ( uint ) { if ( ( totalPledgedFeesHistory . length == 0 ) || ( totalPledgedFeesHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalPledgedFeesAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalPledgedFeesHistory , _blockNumber ) ; } }
","Total amount of fees at a specific ` _blockNumber ` .
"
"function clearApproval ( address _owner , uint256 _tokenId ) internal { require ( tokenLookup [ _tokenId ] . owner == _owner , ""Incorrect PixelCon owner"" ) ; if ( tokenApprovals [ _tokenId ] != address ( 0 ) ) { tokenApprovals [ _tokenId ] = address ( 0 ) ; } }
","Clear current approval of a given token ID
"
"function claimTokens ( token _address , address _to ) onlyAdmin public { require ( _to != address ( 0 ) ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( _to , remainder ) ; }
","Function to claim ANY token stuck on contract accidentally In case of claim of stuck tokens please contact contract owners
"
"function getApproved ( uint256 _tokenId ) ownerExists ( _tokenId ) public view returns ( address ) { return nft [ _tokenId ] . approval ; }
","Throws if ` _tokenId ` is not a valid NFT .
"
"function migrate ( uint256 _value ) external { if ( funding ) throw ; if ( migrationAgent == 0 ) throw ; if ( _value == 0 ) throw ; if ( _value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] -= _value ; totalTokens -= _value ; totalMigrated += _value ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; Migrate ( msg . sender , migrationAgent , _value ) ; }
","Migrate tokens to the new token contract .
"
"function isContract ( address _target ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( _target ) } return size > 0 ; }
","if it is a contract , we use this function to lookup for the owner
"
"function isContract ( address addr ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }
","Returns whether there is code in the target address
"
"function limitedPrint ( address _receiver , uint256 _value ) public onlyLimitedPrinter { uint256 totalSupply = erc20Impl . totalSupply ( ) ; uint256 newTotalSupply = totalSupply + _value ; require ( newTotalSupply >= totalSupply ) ; require ( newTotalSupply <= totalSupplyCeiling ) ; erc20Impl . confirmPrint ( erc20Impl . requestPrint ( _receiver , _value ) ) ; }
","Increases the token supply , with the newly created tokens being added to the balance of the specified account .
"
"function setRebuyThreshold ( uint256 _rebuyThreshold ) external onlyOwner returns ( bool ) { emit SetRebuyThreshold ( rebuyThreshold , _rebuyThreshold ) ; rebuyThreshold = _rebuyThreshold ; return true ; }
","Sets a new min of tokens to rebuy when paying a loan
"
"function deleteBytes ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete bytesStorage [ _key ] ; return true ; }
","Delete value for Bytes associated with bytes32 id key
"
"function getAllDelegates ( ) external view returns ( address [ ] ) ;
","Used to get all delegates
"
"function claimPlotMultiple ( uint256 [ ] _deedIds ) external payable whenNotPaused { claimPlotMultipleWithData ( _deedIds , """" , """" , """" , """" ) ; }
","Buy unclaimed plots .
"
"function _bid ( uint256 _tokenId , uint256 _bidAmount ) internal returns ( uint256 ) { Sale storage _sale = tokenIdToSale [ _tokenId ] ; uint256 [ 9 ] memory tokenIdsStore = tokenIdToSale [ _tokenId ] . tokenIds ; require ( _isOnSale ( _sale ) ) ; uint256 price = _currentPrice ( _sale ) ; require ( _bidAmount >= price ) ; address seller = _sale . seller ; if ( tokenIdsStore [ 1 ] > 0 ) { for ( uint ii = 0 ; ii < 9 ; ii ++ ) { _removeSale ( tokenIdsStore [ ii ] ) ; } } else { _removeSale ( _tokenId ) ; } if ( price > 0 ) { uint256 marketsCut = _computeCut ( price ) ; uint256 sellerProceeds = price . sub ( marketsCut ) ; seller . transfer ( sellerProceeds ) ; } uint256 bidExcess = _bidAmount . sub ( price ) ; msg . sender . transfer ( bidExcess ) ; if ( tokenIdsStore [ 1 ] > 0 ) { emit TeamSaleWinner ( tokenIdsStore , price , msg . sender ) ; } else { emit SaleWinner ( _tokenId , price , msg . sender ) ; } return price ; }
","Internal function , helps in making the bid and transferring asset if successful
"
"function convertToEur ( uint256 amount ) public constant returns ( uint256 ) { require ( amount < 2 ** 123 ) ; return decimalFraction ( amount , ETH_EUR_FRACTION ) ; }
","Considering the max possible ETH_EUR_FRACTION value ( 1018104 == ~273 ) , the max amount of ETH ( not wei ) that is safe to be passed as the argument is ~10 ( 54 - 18 ) ( ~2123 ) .
"
"function collect ( address caller ) public ;
","This method should be called by the WCT holders to collect their corresponding WPRs
"
"function allowance ( address _from , address _recipient ) public constant returns ( uint256 ) { return allowed [ _from ] [ _recipient ] ; }
","Return allowed transaction amount from ` _from ` to ` _recipient `
"
"function setPolls ( address _address ) public onlyOwner { polls = _address ; }
","Only contract owner
"
"function canIssueAttribute ( address account , uint256 attributeTypeID ) external view returns ( bool , bytes1 ) ;
","Check if the validator is approved to issue an attribute of the type with ID ` attributeTypeID ` to account ` account ` on the jurisdiction .
"
"function modifyWhitelistMulti ( address [ ] _investors , uint256 [ ] _fromTimes , uint256 [ ] _toTimes , uint256 [ ] _expiryTimes , bool [ ] _canBuyFromSTO ) public withPerm ( WHITELIST ) { require ( _investors . length == _fromTimes . length , ""Mismatched input lengths"" ) ; require ( _fromTimes . length == _toTimes . length , ""Mismatched input lengths"" ) ; require ( _toTimes . length == _expiryTimes . length , ""Mismatched input lengths"" ) ; require ( _canBuyFromSTO . length == _toTimes . length , ""Mismatched input length"" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { modifyWhitelist ( _investors [ i ] , _fromTimes [ i ] , _toTimes [ i ] , _expiryTimes [ i ] , _canBuyFromSTO [ i ] ) ; } }
","Adds or removes addresses from the whitelist .
"
"function vest ( ) external { uint numEntries = numVestingEntries ( msg . sender ) ; uint total ; for ( uint i = 0 ; i < numEntries ; i ++ ) { uint time = getVestingTime ( msg . sender , i ) ; if ( time > now ) { break ; } uint qty = getVestingQuantity ( msg . sender , i ) ; if ( qty == 0 ) { continue ; } vestingSchedules [ msg . sender ] [ i ] = [ 0 , 0 ] ; total = total . add ( qty ) ; } if ( total != 0 ) { totalVestedBalance = totalVestedBalance . sub ( total ) ; totalVestedAccountBalance [ msg . sender ] = totalVestedAccountBalance [ msg . sender ] . sub ( total ) ; synthetix . transfer ( msg . sender , total ) ; emit Vested ( msg . sender , now , total ) ; } }
","Allow a user to withdraw any SNX in their schedule that have vested .
"
"function confirmTransactionWithVRS ( uint transactionId , bytes pass , uint8 v , bytes32 r , bytes32 s ) public transactionExists ( transactionId ) { bytes32 _message = getMessageForTransaction ( transactionId , pass ) ; address _owner = getSigner ( _message , v , r , s ) ; _confirmTransaction ( transactionId , _owner ) ; }
","Confirms a transaction for any owner with signed message .
"
"function changeExpiryLimit ( uint256 _newExpiry ) external ;
","Changes the expiry time for the token ticker
"
"function setCrowdsaleAddress ( address _crowdsale ) public onlyOwner { require ( _crowdsale != address ( 0 ) ) ; crowdsale = _crowdsale ; }
","To set the address of the crowdsale in order to distribute the tokens
"
"function finalize ( ) external { if ( ! funding ) throw ; if ( ( block . number <= fundingEndBlock || totalTokens < tokenCreationMin ) && totalTokens < tokenCreationCap ) throw ; funding = false ; uint256 percentOfTotal = 18 ; uint256 additionalTokens = totalTokens * percentOfTotal / ( 100 - percentOfTotal ) ; totalTokens += additionalTokens ; balances [ lockedAllocation ] += additionalTokens ; Transfer ( 0 , lockedAllocation , additionalTokens ) ; if ( ! golemFactory . send ( this . balance ) ) throw ; }
","Finalize crowdfunding
"
"function freeze ( address _addr , uint256 _value ) public { require ( owner == msg . sender ) ; require ( balanceOf [ _addr ] >= _value ) ; require ( _value > 0 ) ; balanceOf [ _addr ] = SafeMath . sub ( balanceOf [ _addr ] , _value ) ; freezeOf [ _addr ] = SafeMath . add ( freezeOf [ _addr ] , _value ) ; emit Freeze ( _addr , _value ) ; }
","freeze ` _value ` token of '_addr ' address
"
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) public returns ( address ) { if ( _snapshotBlock == 0 ) _snapshotBlock = block . number ; DOTSToken cloneToken = tokenFactory . createCloneToken ( this , _snapshotBlock , _cloneTokenName , _cloneDecimalUnits , _cloneTokenSymbol , _transfersEnabled ) ; cloneToken . changeController ( msg . sender ) ; NewCloneToken ( address ( cloneToken ) , _snapshotBlock ) ; return address ( cloneToken ) ; }
","Creates a new clone token with the initial distribution being this token at ` _snapshotBlock `
"
"function reclaimDividend ( uint256 _dividendIndex ) public onlyOwner { require ( _dividendIndex < dividends . length , ""Incorrect dividend index"" ) ; require ( now >= dividends [ _dividendIndex ] . expiry , ""Dividend expiry is in the future"" ) ; require ( ! dividends [ _dividendIndex ] . reclaimed , ""Dividend already claimed"" ) ; Dividend storage dividend = dividends [ _dividendIndex ] ; dividend . reclaimed = true ; uint256 remainingAmount = dividend . amount . sub ( dividend . claimedAmount ) ; msg . sender . transfer ( remainingAmount ) ; emit EtherDividendReclaimed ( msg . sender , _dividendIndex , remainingAmount ) ; }
","Issuer can reclaim remaining unclaimed dividend amounts , for expired dividends
"
"function initialize ( IACL _baseAcl , address _permissionsCreator ) public onlyInit { initialized ( ) ; _setApp ( KERNEL_APP_BASES_NAMESPACE , KERNEL_DEFAULT_ACL_APP_ID , _baseAcl ) ; IACL acl = IACL ( newAppProxy ( this , KERNEL_DEFAULT_ACL_APP_ID ) ) ; acl . initialize ( _permissionsCreator ) ; _setApp ( KERNEL_APP_ADDR_NAMESPACE , KERNEL_DEFAULT_ACL_APP_ID , acl ) ; recoveryVaultAppId = KERNEL_DEFAULT_VAULT_APP_ID ; }
","Initializes a kernel instance along with its ACL and sets ` _permissionsCreator ` as the entity that can create other permissions
"
"function getForSeller ( address _seller ) public view validAddress ( _seller ) returns ( uint64 [ ] ) { return sellerPixelconIndexes [ _seller ] ; }
","Get all PixelCon indexes being sold by ` ( _seller ) `
"
"function finalize ( ) salePeriodCompleted isValidState onlyBy ( owner ) external { balances [ escFundAddress ] = balances [ escFundAddress ] . add ( escFund ) ; assignedSupply = assignedSupply . add ( escFund ) ; ClaimESC ( escFundAddress , escFund ) ; Transfer ( 0x0 , escFundAddress , escFund ) ; for ( uint i = 0 ; i < allocationsLength ; i ++ ) { balances [ allocationsIndex [ i ] ] = balances [ allocationsIndex [ i ] ] . add ( allocations [ allocationsIndex [ i ] ] ) ; ClaimESC ( allocationsIndex [ i ] , allocations [ allocationsIndex [ i ] ] ) ; Transfer ( 0x0 , allocationsIndex [ i ] , allocations [ allocationsIndex [ i ] ] ) ; } if ( assignedSupply < totalSupply ) { uint256 unassignedSupply = totalSupply . sub ( assignedSupply ) ; balances [ escFundAddress ] = balances [ escFundAddress ] . add ( unassignedSupply ) ; assignedSupply = assignedSupply . add ( unassignedSupply ) ; ClaimESC ( escFundAddress , unassignedSupply ) ; Transfer ( 0x0 , escFundAddress , unassignedSupply ) ; } ethFundAddress . transfer ( this . balance ) ; isFinalized = true ; }
","Sends the ETH to ETH fund wallet and finalizes the token sale
"
"function addToWhiteList ( address _address ) public onlyOwner { if ( nonWLBalanceOf [ _address ] > 0 ) { sendTokens ( _address , nonWLBalanceOf [ _address ] ) ; nonWLBalanceOf [ _address ] = 0 ; } whiteList [ _address ] = true ; }
","Add a single address to white list to allow purchase for more than 10 ETH .
"
"function withdraw ( uint _totalAmount , bytes _reason , address [ ] _destination ) external founderCall { if ( this . balance < _totalAmount ) throw ; uint withdrawalID = withdrawals . length ++ ; withdrawals [ withdrawalID ] . Amount = _totalAmount ; withdrawals [ withdrawalID ] . reason = _reason ; withdrawals [ withdrawalID ] . destination = _destination ; withdrawals [ withdrawalID ] . approved = false ; withdrawals [ withdrawalID ] . spent = false ; WithdrawalCreatedEvent ( withdrawalID , _totalAmount , _reason ) ; }
","Requestng withdrawal of ` _totalAmount ` to ` _destination.address ( ) `
"
"function tokenURI ( uint256 _tokenId ) public view returns ( string ) { require ( exists ( _tokenId ) ) ; string memory infoUrl ; infoUrl = strConcat ( 'https://cryptoflowers.io/v/' , uint2str ( _tokenId ) ) ; return infoUrl ; }
","The user/developper needs to add the tokenID , in the end of URL , to use the URI and get all details .
"
"function acceptProposedMilestones ( bytes32 _hashProposals ) onlyDonor campaignNotCanceled { uint i ; if ( ! changingMilestones ) throw ; if ( sha3 ( proposedMilestones ) != _hashProposals ) throw ; for ( i = 0 ; i < milestones . length ; i ++ ) { if ( milestones [ i ] . status != MilestoneStatus . AuthorizedForPayment ) { milestones [ i ] . status = MilestoneStatus . Canceled ; } } bytes memory mProposedMilestones = proposedMilestones ; var itmProposals = mProposedMilestones . toRLPItem ( true ) ; if ( ! itmProposals . isList ( ) ) throw ; var itrProposals = itmProposals . iterator ( ) ; while ( itrProposals . hasNext ( ) ) { var itmProposal = itrProposals . next ( ) ; Milestone milestone = milestones [ milestones . length ++ ] ; if ( ! itmProposal . isList ( ) ) throw ; var itrProposal = itmProposal . iterator ( ) ; milestone . description = itrProposal . next ( ) . toAscii ( ) ; milestone . url = itrProposal . next ( ) . toAscii ( ) ; milestone . minCompletionDate = itrProposal . next ( ) . toUint ( ) ; milestone . maxCompletionDate = itrProposal . next ( ) . toUint ( ) ; milestone . milestoneLeadLink = itrProposal . next ( ) . toAddress ( ) ; milestone . reviewer = itrProposal . next ( ) . toAddress ( ) ; milestone . reviewTime = itrProposal . next ( ) . toUint ( ) ; milestone . paymentSource = itrProposal . next ( ) . toAddress ( ) ; milestone . payData = itrProposal . next ( ) . toData ( ) ; milestone . status = MilestoneStatus . AcceptedAndInProgress ; } delete proposedMilestones ; changingMilestones = false ; NewMilestoneListAccepted ( ) ; }
","` onlyDonor ` Approves the proposed milestone list
"
"function lock ( address _to , uint256 _value , uint256 _end ) internal validAddress ( _to ) onlyOwner returns ( bool ) { require ( _value > 0 ) ; assert ( totalProjectToken > 0 ) ; totalLockToken = totalLockToken . add ( _value ) ; assert ( totalProjectToken >= totalLockToken ) ; require ( allocations [ _to ] . value == 0 ) ; allocations [ _to ] = allocationLock ( { value : _value , end : _end , locked : true } ) ; Lock ( this , _to , _value , _end ) ; return true ; }
","This function can accept for blocking no more than `` totalProjectToken '' .
"
"function takeOffItem ( uint _champId , uint8 _type ) public onlyOwnerOfChamp ( _champId ) { uint256 itemId ; Champ storage champ = champs [ _champId ] ; if ( _type == 1 ) { itemId = champ . eq_sword ; if ( itemId > 0 ) { champ . eq_sword = 0 ; } } if ( _type == 2 ) { itemId = champ . eq_shield ; if ( itemId > 0 ) { champ . eq_shield = 0 ; } } if ( _type == 3 ) { itemId = champ . eq_helmet ; if ( itemId > 0 ) { champ . eq_helmet = 0 ; } } if ( itemId > 0 ) { items [ itemId ] . onChamp = false ; } }
","Takes item off champ
"
"function balanceOf ( address _owner ) constant returns ( uint256 ) { return balances [ _owner ] ; }
","Return the address balance
"
"function getReputationByFactory ( address _factoryAddress ) external view returns ( address [ ] ) ;
","Used to get the reputation of a Module Factory
"
"function kill ( bytes32 _hash ) external pollApproved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) { selfdestruct ( bthFoundationWallet ) ; }
","Contract desctruction function
"
"function slowCancel ( bytes32 _offerHash ) external { require ( announcedCancellations [ _offerHash ] != 0 && announcedCancellations [ _offerHash ] <= now , ""Insufficient delay"" ) ; delete announcedCancellations [ _offerHash ] ; Offer memory offer = offers [ _offerHash ] ; _cancel ( _offerHash , offer . availableAmount , etherAddr , 0 ) ; }
","Cancel an offer without requiring the coordinator
"
"function batchCreateETHCardAsset ( uint8 [ ] _teamId , uint256 [ ] _attributes , uint256 [ ] _playerOverrideId , uint256 [ ] _mlbPlayerId , address [ ] _to ) external canCreate whenNotPaused { require ( isBatchSupported ) ; require ( _teamId . length > 0 && _attributes . length > 0 && _playerOverrideId . length > 0 && _mlbPlayerId . length > 0 && _to . length > 0 ) ; uint256 assetDetails ; uint256 [ 5 ] memory _nftData ; for ( uint ii = 0 ; ii < _attributes . length ; ii ++ ) { require ( _to [ ii ] != address ( 0 ) && _teamId [ ii ] != 0 && _attributes . length != 0 && _mlbPlayerId [ ii ] != 0 ) ; assetDetails = uint256 ( uint64 ( now ) ) ; assetDetails |= uint256 ( getSequenceId ( _teamId [ ii ] ) ) << 64 ; assetDetails |= uint256 ( _teamId [ ii ] ) << 96 ; assetDetails |= uint256 ( ( _attributes [ ii ] / 1000000000000000000000000000000000000000 ) - 800 ) << 104 ; _nftData = [ assetDetails , _attributes [ ii ] , 0 , _playerOverrideId [ ii ] , _mlbPlayerId [ ii ] ] ; _createNFTCollectible ( _teamId [ ii ] , _attributes [ ii ] , _to [ ii ] , 2 , _nftData ) ; } }
","Batch Function to Create Assets
"
"function finalize ( ) public initialized { require ( finalizedBlock == 0 ) ; assert ( getBlockNumber ( ) >= startBlock ) ; assert ( msg . sender == controller || getBlockNumber ( ) > endBlock || tokensForSale ( ) == 0 ) ; wct . changeController ( 0x0 ) ; finalizedBlock = getBlockNumber ( ) ; Finalized ( finalizedBlock ) ; }
","This method will can be called by the controller before the contribution period end or by anybody after the ` endBlock ` .
"
"function addSpender ( address _spender ) external onlyOwner { _validateAddress ( _spender ) ; whitelistedSpenders [ _spender ] = true ; }
","Adds an address to the set of allowed spenders .
"
"function open ( bytes32 channelId , address receiver , uint32 settlingPeriod ) public payable { require ( isAbsent ( channelId ) ) ; channels [ channelId ] = PaymentChannel ( { sender : msg . sender , receiver : receiver , value : msg . value , settlingPeriod : settlingPeriod , settlingUntil : 0 } ) ; DidOpen ( channelId , msg . sender , receiver , msg . value ) ; }
","Open a new channel between ` msg.sender ` and ` receiver ` , and do an initial deposit to the channel .
"
"function emergencyStopSale ( ) public only_sale_active onlyOwner { saleStopped = true ; }
","Function to stop sale for an emergency .
"
"function isTrusted ( address _from , address _to ) public view returns ( bool ) { return holders [ getHolderId ( _from ) ] . trust [ _to ] ; }
","Check if specified holder trusts an address with recovery procedure .
"
"function isSettling ( bytes32 channelId ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; return channel . settlingUntil != 0 ; }
","Check if the channel is in settling state : waits till the settling period is over .
"
"function kill ( ) public { if ( msg . sender == owner ) selfdestruct ( owner ) ; }
","allows the owner of this contract to destroy the contract
"
"function _getTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { uint256 tokenAmount = _weiAmount . mul ( rate ) ; uint256 bonusTokens = tokenAmount . mul ( bonus ) . div ( 100 ) ; return tokenAmount . add ( bonusTokens ) ; }
","Returns the number of tokens for ETH
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( crowdsaleSuccessful ) ; require ( _to != address ( 0 ) ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; success = true ; }
","send ` _value ` tokens to ` _to ` address from ` msg.sender `
"
"function convertCarbonDollar ( address stablecoin , uint256 _amount ) public userNotBlacklisted ( msg . sender ) whenNotPaused { require ( isWhitelisted ( stablecoin ) , ""Stablecoin must be whitelisted prior to setting conversion fee"" ) ; WhitelistedToken whitelisted = WhitelistedToken ( stablecoin ) ; require ( whitelisted . balanceOf ( address ( this ) ) >= _amount , ""Carbon escrow account in WT0 doesn't have enough tokens for burning"" ) ; uint256 chargedFee = tokenStorage_CD . computeFee ( _amount , computeFeeRate ( stablecoin ) ) ; uint256 feedAmount = _amount . sub ( chargedFee ) ; _burn ( msg . sender , _amount ) ; require ( whitelisted . transfer ( msg . sender , feedAmount ) ) ; whitelisted . burn ( chargedFee ) ; _mint ( address ( this ) , chargedFee ) ; emit ConvertedToWT ( msg . sender , _amount ) ; }
","user can convert CarbonUSD umbrella token into a whitelisted stablecoin .
"
"function onERC721Received ( address _from , uint256 _tokenId , bytes data ) external returns ( bytes4 ) ;
","Handle the receipt of an NFT
"
"function setBypassStatus ( address to , bool status ) public onlyOwner { freezeBypassing [ to ] = status ; }
","choose if an address is allowed to bypass the global freeze
"
"function challengeWinnerReward ( uint _challengeID ) public view returns ( uint ) { if ( voting . getTotalNumberOfTokensForWinningOption ( _challengeID ) == 0 ) { return challenges [ _challengeID ] . stake . mul ( 2 ) ; } return challenges [ _challengeID ] . stake . mul ( 2 ) . sub ( challenges [ _challengeID ] . rewardPool ) ; }
","Determines the number of tokens to awarded to the winning party in a challenge
"
"function poll ( uint _idPoll ) public view returns ( uint _startBlock , uint _endTime , bool _canVote , bool _canceled , bytes _description , uint8 _numBallots , bool _finalized , uint _voters , address _author , uint [ 100 ] _tokenTotal , uint [ 100 ] _quadraticVotes , uint [ 100 ] _votersByBallot ) { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll storage p = _polls [ _idPoll ] ; _startBlock = p . startBlock ; _endTime = p . endTime ; _canceled = p . canceled ; _canVote = canVote ( _idPoll ) ; _description = p . description ; _numBallots = p . numBallots ; _author = p . author ; _finalized = ( ! p . canceled ) && ( block . number >= _endTime ) ; _voters = p . voters ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { _tokenTotal [ i ] = p . results [ i ] ; _quadraticVotes [ i ] = p . qvResults [ i ] ; _votersByBallot [ i ] = p . votersByBallot [ i ] ; } }
","Get Poll info
"
"function isCampaignValid ( bytes32 bidId ) public view returns ( bool valid ) { uint startDate = advertisementStorage . getCampaignStartDateById ( bidId ) ; uint endDate = advertisementStorage . getCampaignEndDateById ( bidId ) ; bool validity = advertisementStorage . getCampaignValidById ( bidId ) ; uint nowInMilliseconds = now * 1000 ; return validity && startDate < nowInMilliseconds && endDate > nowInMilliseconds ; }
","Check if a certain campaign is still valid Returns a boolean representing the validity of the campaign Has value of True if the campaign is still valid else has value of False
"
"function mintWithData ( address _investor , uint256 _value , bytes _data ) external returns ( bool success ) ;
","Mints new tokens and assigns them to the target _investor .
"
"function destroy ( uint index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status != Status . destroyed ) ; require ( msg . sender == loan . lender || ( msg . sender == loan . borrower && loan . status == Status . initial ) ) ; DestroyedBy ( index , msg . sender ) ; if ( loan . status != Status . initial ) { lendersBalance [ loan . lender ] -= 1 ; activeLoans -= 1 ; Transfer ( loan . lender , 0x0 , index ) ; } loan . status = Status . destroyed ; return true ; }
","Destroys a loan , the borrower could call this method if they performed an accidental or regretted `` approve '' of the loan , this method only works for them if the loan is in `` pending '' status .
"
"function getPreICOBonus ( ) internal constant returns ( uint ) ;
","pre-ICO bonus
"
"function challengeReparameterization ( bytes32 _propID ) public returns ( uint challengeID ) { ParamProposal memory prop = proposals [ _propID ] ; uint deposit = prop . deposit ; require ( propExists ( _propID ) && prop . challengeID == 0 ) ; uint pollID = voting . startPoll ( get ( ""pVoteQuorum"" ) , get ( ""pCommitStageLen"" ) , get ( ""pRevealStageLen"" ) ) ; challenges [ pollID ] = Challenge ( { challenger : msg . sender , rewardPool : SafeMath . sub ( 100 , get ( ""pDispensationPct"" ) ) . mul ( deposit ) . div ( 100 ) , stake : deposit , resolved : false , winningTokens : 0 } ) ; proposals [ _propID ] . challengeID = pollID ; require ( token . transferFrom ( msg . sender , this , deposit ) ) ; var ( commitEndDate , revealEndDate , ) = voting . pollMap ( pollID ) ; _NewChallenge ( _propID , pollID , commitEndDate , revealEndDate , msg . sender ) ; return pollID ; }
","challenge the provided proposal ID , and put tokens at stake to do so .
"
"function signedAverage ( int256 a , int256 b ) public pure returns ( int256 ) { int256 ans = a + b ; if ( a > 0 && b > 0 && ans <= 0 ) { require ( false ) ; } if ( a < 0 && b < 0 && ans >= 0 ) { require ( false ) ; } return ans / 2 ; }
","1.5 will be toward zero
"
"function emergencyRedeem ( uint shareQuantity , address [ ] requestedAssets ) public pre_cond ( balances [ msg . sender ] >= shareQuantity ) returns ( bool ) { address ofAsset ; uint [ ] memory ownershipQuantities = new uint [ ] ( requestedAssets . length ) ; address [ ] memory redeemedAssets = new address [ ] ( requestedAssets . length ) ; for ( uint i = 0 ; i < requestedAssets . length ; ++ i ) { ofAsset = requestedAssets [ i ] ; require ( isInAssetList [ ofAsset ] ) ; for ( uint j = 0 ; j < redeemedAssets . length ; j ++ ) { if ( ofAsset == redeemedAssets [ j ] ) { revert ( ) ; } } redeemedAssets [ i ] = ofAsset ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( address ( this ) ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; if ( assetHoldings == 0 ) continue ; ownershipQuantities [ i ] = mul ( assetHoldings , shareQuantity ) / _totalSupply ; if ( uint ( AssetInterface ( ofAsset ) . balanceOf ( address ( this ) ) ) < ownershipQuantities [ i ] ) { isShutDown = true ; emit ErrorMessage ( ""CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy"" ) ; return false ; } } annihilateShares ( msg . sender , shareQuantity ) ; for ( uint k = 0 ; k < requestedAssets . length ; ++ k ) { ofAsset = requestedAssets [ k ] ; if ( ownershipQuantities [ k ] == 0 ) { continue ; } else if ( ! AssetInterface ( ofAsset ) . transfer ( msg . sender , ownershipQuantities [ k ] ) ) { revert ( ) ; } } emit Redeemed ( msg . sender , now , shareQuantity ) ; return true ; }
","Redeems by allocating an ownership percentage only of requestedAssets to the participant
"
"function reclaimERC20 ( address _token , uint _tokens ) external returns ( bool _success ) { require ( msg . sender == fundsWallet ) ; return Token ( _token ) . transfer ( msg . sender , _tokens ) ; }
","Safety function so any accidentally sent ERC20 compliant tokens can be recovered .
"
"function emergencyWithdrawAdmin ( ) external hasFinalized onlyAdmin { require ( finalizedTime != 0 && now >= finalizedTime + 10 days ) ; msg . sender . transfer ( address ( this ) . balance ) ; }
","Let the admin cash-out the entire contract balance 10 days after game has finished .
"
"function _verifyTransfer ( address _from , address _to , uint256 _value , bytes _data , bool _isTransfer ) internal checkGranularity ( _value ) returns ( bool ) { if ( ! transfersFrozen ) { bool isInvalid = false ; bool isValid = false ; bool isForceValid = false ; bool unarchived = false ; address module ; for ( uint256 i = 0 ; i < modules [ TRANSFER_KEY ] . length ; i ++ ) { module = modules [ TRANSFER_KEY ] [ i ] ; if ( ! modulesToData [ module ] . isArchived ) { unarchived = true ; ITransferManager . Result valid = ITransferManager ( module ) . verifyTransfer ( _from , _to , _value , _data , _isTransfer ) ; if ( valid == ITransferManager . Result . INVALID ) { isInvalid = true ; } else if ( valid == ITransferManager . Result . VALID ) { isValid = true ; } else if ( valid == ITransferManager . Result . FORCE_VALID ) { isForceValid = true ; } } } return unarchived ? ( isForceValid ? true : ( isInvalid ? false : isValid ) ) : true ; } return false ; }
","Validate transfer with TransferManager module if it exists
"
"function numberOfPossibleChoices ( ) public pure returns ( uint8 ) { return NUMBER_OF_CHOICES ; }
","Returns the number of possible choices , which can be voted for .
"
"function _getTokenAmount ( uint256 _investedAmount ) internal view returns ( uint256 ) { return _investedAmount . mul ( rate ) ; }
","Overrides to extend the way in which ether is converted to tokens .
"
"function finalizeUpgrade ( ) external { if ( getState ( ) != State . Success ) throw ; if ( upgradeAgent . owner ( ) == 0x0 ) throw ; if ( msg . sender != upgradeMaster ) throw ; if ( finalizedUpgrade ) throw ; finalizedUpgrade = true ; upgradeAgent . finalizeUpgrade ( ) ; UpgradeFinalized ( msg . sender , upgradeAgent ) ; }
","finalize the upgrade
"
"function tokensOfOwner ( address _owner ) public view returns ( uint256 [ ] ownerTokens ) { uint256 tokenCount = balanceOf ( _owner ) ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( tokenCount ) ; uint256 totalCountries = totalSupply ( ) ; uint256 resultIndex = 0 ; uint256 countryId ; for ( countryId = 0 ; countryId < totalCountries ; countryId ++ ) { if ( countryIndexToOwner [ countryId ] == _owner ) { result [ resultIndex ] = countryId ; resultIndex ++ ; } } return result ; } }
","Get all tokens of a particular address
"
"function getPayeeBalance ( bytes32 _requestId , uint8 _payeeIndex ) public view returns ( int256 ) { if ( _payeeIndex == 0 ) { return requests [ _requestId ] . payee . balance ; } else { return subPayees [ _requestId ] [ _payeeIndex - 1 ] . balance ; } }
","Gets balance of a payee .
"
"function getGameInfo ( uint gameId ) public view returns ( string , string , string ) { return ( games [ gameId ] . teamA , games [ gameId ] . teamB , games [ gameId ] . description ) ; }
","Returns some basic information about a specific game
"
"function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { return transfersAllowed ; }
","Notifies the controller about a transfer , for this TokenSale all transfers are allowed by default and no extra notifications are needed
"
"function transfer ( address _to , uint256 _value ) public { _transfer ( msg . sender , _to , _value ) ; }
","Send ` _value ` tokens to ` _to ` from your account
"
"function setTransferFeeRate ( uint _transferFeeRate ) external optionalProxy_onlyOwner { require ( _transferFeeRate <= MAX_TRANSFER_FEE_RATE , ""Transfer fee rate must be below MAX_TRANSFER_FEE_RATE"" ) ; transferFeeRate = _transferFeeRate ; emitTransferFeeUpdated ( _transferFeeRate ) ; }
","Set the transfer fee , anywhere within the range 0-10 % .
"
"function calcNav ( uint gav , uint unclaimedFees ) view returns ( uint nav ) { nav = sub ( gav , unclaimedFees ) ; }
","Calculates the Net asset value of this fund
"
"function registerTicker ( address _owner , string _ticker , string _tokenName ) external ;
","its ownership .
"
"function vote ( uint _idPoll , uint [ ] _ballots ) public { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll storage p = _polls [ _idPoll ] ; require ( block . number >= p . startBlock && block . number < p . endBlock && ! p . canceled , ""Poll is inactive"" ) ; require ( _ballots . length == p . numBallots , ""Number of ballots is incorrect"" ) ; unvote ( _idPoll ) ; uint amount = token . balanceOfAt ( msg . sender , p . startBlock ) ; require ( amount != 0 , ""No SNT balance available at start block of poll"" ) ; p . voters ++ ; uint totalBallots = 0 ; for ( uint8 i = 0 ; i < _ballots . length ; i ++ ) { totalBallots += _ballots [ i ] ; p . ballots [ i ] [ msg . sender ] = _ballots [ i ] ; if ( _ballots [ i ] != 0 ) { p . qvResults [ i ] += sqrt ( _ballots [ i ] / 1 ether ) ; p . results [ i ] += _ballots [ i ] ; } } require ( totalBallots <= amount , ""Total ballots must be less than the SNT balance at poll start block"" ) ; emit Vote ( _idPoll , msg . sender , _ballots ) ; }
","Vote for a poll
"
"function ownerWithdrawParsecs ( uint256 value ) external onlyOwner { require ( contractFinished ) ; uint256 parsecBalance = parsecToken . balanceOf ( this ) ; uint256 maxAmountToWithdraw = parsecBalance . sub ( pendingParsecs ) ; require ( maxAmountToWithdraw > 0 ) ; require ( maxAmountToWithdraw <= parsecBalance ) ; require ( value > 0 ) ; require ( value <= maxAmountToWithdraw ) ; parsecToken . transfer ( owner , value ) ; }
","Owner can withdraw Parsecs only after contract is finished
"
"function _payDividend ( address _payee , Dividend storage _dividend , uint256 _dividendIndex ) internal { uint256 claim = calculateDividend ( _dividendIndex , _payee ) ; _dividend . claimed [ _payee ] = true ; _dividend . claimedAmount = claim . add ( _dividend . claimedAmount ) ; if ( claim > 0 ) { if ( _payee . send ( claim ) ) { emit EtherDividendClaimed ( _payee , _dividendIndex , claim ) ; } else { _dividend . claimed [ _payee ] = false ; emit EtherDividendClaimFailed ( _payee , _dividendIndex , claim ) ; } } }
","Internal function for paying dividends
"
"function getOldestPledgeNotCanceled ( uint64 idPledge ) internal constant returns ( uint64 ) { if ( idPledge == 0 ) return 0 ; Pledge storage p = findPledge ( idPledge ) ; PledgeAdmin storage admin = findAdmin ( p . owner ) ; if ( admin . adminType == PledgeAdminType . Giver ) return idPledge ; assert ( admin . adminType == PledgeAdminType . Project ) ; if ( ! isProjectCanceled ( p . owner ) ) return idPledge ; return getOldestPledgeNotCanceled ( p . oldPledge ) ; }
","A getter to find the oldest pledge that has n't been canceled
"
"function setName ( string _name ) onlyOwner { name = _name ; LogSetName ( _name ) ; }
","Change name .
"
"function resultFor ( bytes32 question_id ) external view returns ( bytes32 ) { }
","Return the final answer to the specified question , or revert if there is n't one
"
"function setController ( address _controller ) external onlymanyowners ( sha3 ( msg . data ) ) { m_controller = _controller ; ControllerSet ( m_controller ) ; }
","sets the controller
"
"function __callback ( bytes32 myid , string result , bytes proof ) public { require ( msg . sender == oraclize_cbAddress ( ) ) ; uint newPrice = parseInt ( result ) . mul ( 100 ) ; if ( newPrice >= m_ETHPriceLowerBound && newPrice <= m_ETHPriceUpperBound ) { m_ETHPriceInCents = newPrice ; m_ETHPriceLastUpdate = getTime ( ) ; NewETHPrice ( m_ETHPriceInCents ) ; } else { ETHPriceOutOfBounds ( newPrice ) ; } updateETHPriceInCents ( ) ; }
","Called on ETH price update by Oraclize
"
"function adminshipLevel ( address _newAdmin , uint8 _level ) onlyAdmin ( 2 ) public { require ( _newAdmin != address ( 0 ) ) ; level [ _newAdmin ] = _level ; emit AdminshipUpdated ( _newAdmin , _level ) ; }
","This function set the adminship level on the contract to _newAdmin
"
"function addNewAirdrop ( string _name , uint _tokenAmount , uint _countDown , address _smartContract , uint _decimals ) public minEth payable { Token t = Token ( _smartContract ) ; if ( t . balanceOf ( this ) >= _tokenAmount ) { uint lastIndex = airdrops . length ++ ; Airdrop storage airdrop = airdrops [ lastIndex ] ; airdrop . name = _name ; airdrop . id = lastIndex ; airdrop . decimals = _decimals ; airdrop . tokenAmount = _tokenAmount ; airdrop . countDown = _countDown ; airdrop . gasFeePaid = msg . value ; airdrop . timeStamp = now ; airdrop . distributor = msg . sender ; airdrop . tokenSC = Token ( _smartContract ) ; } else revert ( 'Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop' ) ; }
","Adds a new airdrop to the smart contract and starts the count down until it is distributed
"
"function getApprovedProposals ( ) public view returns ( uint [ ] ) { uint count = 0 ; for ( uint i = 0 ; i < proposals . length ; i ++ ) { if ( proposals [ i ] . approved && ! proposals [ i ] . denied ) { count ++ ; } } uint [ ] memory approvedProposals = new uint [ ] ( count ) ; count = 0 ; for ( i = 0 ; i < proposals . length ; i ++ ) { if ( proposals [ i ] . approved && ! proposals [ i ] . denied ) { approvedProposals [ count ] = i ; count ++ ; } } return approvedProposals ; }
","Get all approved proposals
"
"function getMaximumFundsInEuroCents ( ) public constant returns ( uint ) ;
","maximum investments to be accepted during the sale ( in euro-cents )
"
"function claim ( ) public returns ( bool ) { return claimInternal ( msg . sender ) ; }
","Withdraw a bid that was overbid and platform owner share
"
"function authorizeOperator ( address _operator ) public whenNotPaused { require ( _operator != msg . sender , ""You cannot authorize yourself as an operator"" ) ; mAuthorized [ _operator ] [ msg . sender ] = true ; emit AuthorizedOperator ( _operator , msg . sender ) ; }
","Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .
"
"function authorizeSpender ( address _spender , bool _authorize ) onlyContractOwner { allowedSpenders [ _spender ] = _authorize ; SpenderAuthorization ( _spender , _authorize ) ; }
","` onlyOwner ` Adds a spender to the ` allowedSpenders [ ] ` white list
"
"function addChunk1ToWhiteList ( ) external onlyOwner { require ( ! chunk1IsAdded ) ; addToWhitelist ( 0x2C66aDd04950eE3235fd3EC6BcB2577c88d804E4 , 0.5 ether ) ; addToWhitelist ( 0x008e2E5FC70a2bccB5857AE8591119B3B63fdbc2 , 0.5 ether ) ; addToWhitelist ( 0x0330cc41bDd33f820d92C2df591CD2A5cB99f792 , 0.5 ether ) ; addToWhitelist ( 0x0756ea3a926399c3da2d5bfc520b711bdadfd0b9 , 0.5 ether ) ; addToWhitelist ( 0x08c93a267832a8997a46f13b12faa2821d16a472 , 0.5 ether ) ; addToWhitelist ( 0x0B58dAeAB6D292B5B8A836643023F43E4D0d9b78 , 0.5 ether ) ; addToWhitelist ( 0x0b73f53885581caf26141b4bb5f8c192af611921 , 0.5 ether ) ; addToWhitelist ( 0x0be30C8338C76Cc3EF92734863B0A898d8C8fef4 , 0.5 ether ) ; addToWhitelist ( 0x0fb6829D5543F173d6bba244c2E21CB60544B7fA , 0.5 ether ) ; addToWhitelist ( 0x0fccb03ceb56e683fbcf0229c950d666def66d1d , 0.5 ether ) ; addToWhitelist ( 0x1578416c880a0F282bAc17c692b2A80b4336D29B , 0.5 ether ) ; addToWhitelist ( 0x16fc89d92592b88bc459e19717eEDD51732CfCA1 , 0.5 ether ) ; addToWhitelist ( 0x183feBd8828a9ac6c70C0e27FbF441b93004fC05 , 0.5 ether ) ; addToWhitelist ( 0x1A9D4a4DBb3Fb0750107406f4A7c9379DB42f7B3 , 0.5 ether ) ; addToWhitelist ( 0x1bB95a9c7d50B9b270a604674f4Ed35265087c40 , 0.5 ether ) ; addToWhitelist ( 0x1bf032d01bab6cd4a2d67ec251f5c3f09728a7e3 , 0.5 ether ) ; addToWhitelist ( 0x1C1f687165F982Fcd4672B4319AB966256B57b2e , 0.5 ether ) ; addToWhitelist ( 0x1E2B069ca94e0232A04A4D1317e120f903D41c3A , 0.5 ether ) ; addToWhitelist ( 0x21F23Bb7299Caa26D854DDC38E134E49997471Dd , 0.5 ether ) ; addToWhitelist ( 0x23437833ebf735cdaf526c2a2c24f57ca4726358 , 0.5 ether ) ; addToWhitelist ( 0x2389Ce4eFB2805Fd047C59Fa8991EA9c8361A9a0 , 0.5 ether ) ; addToWhitelist ( 0x248dd8D2b7991d94860c44A5F99fc1483964FBBf , 0.5 ether ) ; addToWhitelist ( 0x257D66c42623c108060a66e4ddE5c3813691Ef38 , 0.5 ether ) ; addToWhitelist ( 0x26D6F116a16efD1f8361c5Da90AEA4B26b564004 , 0.5 ether ) ; addToWhitelist ( 0x272899d5b1451B09De35161B11722C95E34f06A9 , 0.5 ether ) ; addToWhitelist ( 0x29F436906826a7d7Ef0B35292b4f285050108082 , 0.5 ether ) ; addToWhitelist ( 0x2A8Be3303C83e5E9699a8b4B70976577BFedeC71 , 0.5 ether ) ; addToWhitelist ( 0x2C351d47CE2737982D1E25FB6dfa30265913aEAa , 0.5 ether ) ; addToWhitelist ( 0x3cf2fC2cc45EACf1B6495Bf2AA69fbFC0d4b4a30 , 0.5 ether ) ; addToWhitelist ( 0x3Cf5f48Dd9bec4Eff46Ee1E2B9e64b2892B5E64F , 0.5 ether ) ; addToWhitelist ( 0x3D86C8A928E9595114e01bb0539bdD69e9EfDF3B , 0.5 ether ) ; addToWhitelist ( 0x3e825763457fd92a6cb46f5ee0b4969089997da8 , 0.5 ether ) ; addToWhitelist ( 0x3F4351eb6b1dd9a84890C1C89F4D4419Eb88f1Af , 0.5 ether ) ; addToWhitelist ( 0x459cc576ac8332f52ee93cb88228416a872bebd6 , 0.5 ether ) ; addToWhitelist ( 0x45c556aff90d5fe6e91d24874a8036693cec18d0 , 0.5 ether ) ; addToWhitelist ( 0x47449fa838794e665A648FA3e47208a7cd105c9D , 0.5 ether ) ; addToWhitelist ( 0x50405fB11735160056DBc40b92a09B4215501481 , 0.5 ether ) ; addToWhitelist ( 0x51DD5Ef09cF73312BADe4C6BA8e03d647730Ecc3 , 0.5 ether ) ; addToWhitelist ( 0x546A4F1eD47e853Ba119f55A20CbFeaa40ab70E6 , 0.5 ether ) ; addToWhitelist ( 0x549022ad5cd11816eb7ce6ea15ae61c1fb4edb8a , 0.5 ether ) ; addToWhitelist ( 0x5abDC3cB826fC0277D642c9FB52FA76FE3ABb4E7 , 0.5 ether ) ; addToWhitelist ( 0x5b65dfa08283e024c4ad09b5ea7212c539cb9dbf , 0.5 ether ) ; addToWhitelist ( 0x5cC69E09cA05004e5aDCdbE8C8Aac4D16A4651ed , 0.5 ether ) ; addToWhitelist ( 0x60a5550D1e43b63b3164F78F2D186bDb7D393C90 , 0.5 ether ) ; addToWhitelist ( 0x6111d340C833661840ec4c11e84a79a67bE8acCD , 0.5 ether ) ; addToWhitelist ( 0x61E140a78Ec39d373C182bf3eD23cBc1AC86023b , 0.5 ether ) ; addToWhitelist ( 0x62f12F6C3AD04DFACB10ae05fB54f1E997b0133e , 0.5 ether ) ; addToWhitelist ( 0x65276d60Ab36879a6BD88F040D350cd60630FD03 , 0.5 ether ) ; addToWhitelist ( 0x66B993F856d6175D11B98Be2cBc79EB1888B72f7 , 0.5 ether ) ; addToWhitelist ( 0x6806408fd066ccddceaecc0a6c6fbbdb2ae8259c , 0.5 ether ) ; addToWhitelist ( 0x6918a5b07c2f79a4b272bb7653a43438ca96cd3f , 0.5 ether ) ; addToWhitelist ( 0x697DE67DB7d462480418814831d52DA25917A12E , 0.5 ether ) ; chunk1IsAdded = true ; }
","Add chunk 1 / 7 to the whitelist
"
"function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }
","Tells whether an operator is approved by a given owner
"
"function withdrawTokens ( uint _value ) external ;
","owner : send ` _value ` of tokens to his address , can be called if crowdsale failed and some of the investors refunded the ether
"
"function setRegistrationFee ( uint256 _registrationFee ) public onlyOwner returns ( bool ) { require ( _registrationFee > 0 , ""new registration fee must be greater than zero"" ) ; require ( _registrationFee != registrationFee , ""new registration fee must be different"" ) ; registrationFee = _registrationFee ; emit RegistrationFeeUpdated ( msg . sender , _registrationFee ) ; return true ; }
","sets the global registration fee
"
"function onBurn ( address _owner , uint _tokensToBurn ) public returns ( bool ) { require ( msg . sender == address ( tokenContract ) ) ; uint256 feeTotal = tokenContract . totalPledgedFees ( ) ; uint256 totalTokens = tokenContract . totalSupply ( ) ; uint256 feeValueOfTokens = ( feeTotal . mul ( _tokensToBurn ) ) . div ( totalTokens ) ; require ( tokenContract . destroyTokens ( _owner , _tokensToBurn ) ) ; require ( address ( this ) . balance >= feeValueOfTokens ) ; require ( _owner . send ( feeValueOfTokens ) ) ; emit LogClaim ( _owner , feeValueOfTokens ) ; return true ; }
","Notifies the controller about a burn attempt .
"
"function upgradeFinance ( address addrAdverFinance ) public onlyOwner ( ""upgradeFinance"" ) { BaseFinance newAdvFinance = BaseFinance ( addrAdverFinance ) ; address [ ] memory devList = advertisementFinance . getUserList ( ) ; for ( uint i = 0 ; i < devList . length ; i ++ ) { uint balance = advertisementFinance . getUserBalance ( devList [ i ] ) ; newAdvFinance . increaseBalance ( devList [ i ] , balance ) ; } uint256 initBalance = appc . balanceOf ( address ( advertisementFinance ) ) ; advertisementFinance . transferAllFunds ( address ( newAdvFinance ) ) ; uint256 oldBalance = appc . balanceOf ( address ( advertisementFinance ) ) ; uint256 newBalance = appc . balanceOf ( address ( newAdvFinance ) ) ; require ( initBalance == newBalance ) ; require ( oldBalance == 0 ) ; advertisementFinance = newAdvFinance ; }
","Upgrade finance contract used by this contract This function is part of the upgrade mechanism avaliable to the advertisement contracts .
"
"function migrateCraftTokenMaster ( uint tokenId , address newMasterContract ) public onlyCLevel { CraftToken ( emojiCraftTokenAddress [ tokenId ] ) . setContractMaster ( newMasterContract ) ; }
","Here for bug related migration
"
"function getRanking ( ) external view returns ( address [ ] , uint256 [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint256 [ ] memory arr_def = new uint256 [ ] ( len ) ; uint counter = 0 ; for ( uint k = 0 ; k < len ; k ++ ) { arr [ counter ] = getJadeProduction ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; ( , arr_def [ counter ] , , ) = getPlayersBattleStats ( players [ k ] . owneraddress ) ; counter ++ ; } for ( uint i = 0 ; i < len - 1 ; i ++ ) { for ( uint j = 0 ; j < len - i - 1 ; j ++ ) { if ( arr [ j ] < arr [ j + 1 ] ) { uint256 temp = arr [ j ] ; address temp_addr = arr_addr [ j ] ; uint256 temp_def = arr_def [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; arr_addr [ j ] = arr_addr [ j + 1 ] ; arr_addr [ j + 1 ] = temp_addr ; arr_def [ j ] = arr_def [ j + 1 ] ; arr_def [ j + 1 ] = temp_def ; } } } return ( arr_addr , arr , arr_def ) ; }
","rainysiu
"
"function proposalChecked ( address _sender , uint _proposalID , uint _amount ) constant external onlyClient returns ( bool ) { if ( _sender != recipient && _sender != creator ) return ; if ( _amount <= proposals [ _proposalID ] . amount - proposals [ _proposalID ] . submittedAmount ) return true ; }
","Function used by the client to check the proposal before submitting
"
"function updateBytes20inBytes ( bytes data , uint offset , bytes20 b ) internal pure { require ( offset >= 0 && offset + 20 <= data . length , ""offset value should be in the correct range"" ) ; assembly { let m := mload ( add ( data , add ( 20 , offset ) ) ) m := and ( m , 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 ) m := or ( m , div ( b , 0x1000000000000000000000000 ) ) mstore ( add ( data , add ( 20 , offset ) ) , m ) } }
","Modifies 20 bytes in a bytes .
"
"function refund ( ) external { if ( getState ( ) != State . Failure ) throw ; uint256 lunValue = balances [ msg . sender ] ; if ( lunValue == 0 ) throw ; balances [ msg . sender ] = 0 ; totalSupply = safeSub ( totalSupply , lunValue ) ; uint256 ethValue = safeDiv ( lunValue , tokensPerEther ) ; Refund ( msg . sender , ethValue ) ; if ( ! msg . sender . send ( ethValue ) ) throw ; }
","Get back the ether sent during the funding in case the funding has not reached the minimum level .
"
"function userInfo ( uint256 _userId ) public view returns ( address , uint256 , uint256 , uint256 , uint256 [ ] , uint256 [ ] ) { User memory user = users [ _userId ] ; return ( user . addr , user . balance , user . totalPay , user . referrersReceived , user . resources , user . referrersByLevel ) ; }
","getter for extended information of user
"
"function order ( uint _proposalID , uint _amount ) external returns ( bool ) ;
","Function used by the client to order according to the contractor proposal
"
"function reclaim ( IBasicToken token ) public { require ( token != PAYMENT_TOKEN , ""NO_PAYMENT_TOKEN_RECLAIM"" ) ; Reclaimable . reclaim ( token ) ; }
","allows LockedAccount to reclaim tokens wrongly sent to its address
"
"function registerApprove ( bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) public returns ( bool ) { uint256 index = identifierToIndex [ identifier ] ; require ( index != 0 ) ; Loan storage loan = loans [ index ] ; require ( loan . borrower == ecrecover ( keccak256 ( ""\x19Ethereum Signed Message:\n32"" , identifier ) , v , r , s ) ) ; loan . approbations [ loan . borrower ] = true ; ApprovedBy ( index , loan . borrower ) ; return true ; }
","Register an approvation made by a borrower in the past
"
"function withdrawTokens ( address _to , uint _amount ) external validAddress ( _to ) requiresState ( IcoState . FAILED ) onlymanyowners ( keccak256 ( msg . data ) ) { require ( ( _amount > 0 ) && ( m_token . balanceOf ( this ) >= _amount ) ) ; m_token . transfer ( _to , _amount ) ; }
","withdraw tokens if ico failed
"
"function freezeAccount ( address account , bool isAllowed , string issuerFirm ) public onlyAuthority ( issuerFirm , msg . sender ) returns ( bool success ) { require ( lib . setAccountStatus ( account , isAllowed , issuerFirm ) , ""Error: Unable to freeze account. Please check issuerFirm and firm authority are registered"" ) ; return true ; }
","Updates account status .
"
"function onICO ( address buyer , uint256 tokens ) public onlyOwner returns ( bool success ) { require ( isICORunning ) ; require ( isWhitelisted ( buyer ) , ""Buyer is not whitelisted"" ) ; require ( icoContract != address ( 0 ) ) ; require ( msg . sender == icoContract ) ; require ( tokens > 0 ) ; require ( buyer != address ( 0 ) ) ; require ( totalSupply_ . add ( tokens ) <= TOTAL_SUPPLY_LIMIT ) ; super . mint ( buyer , tokens ) ; emit Transfer ( address ( ICO_EVENT ) , buyer , tokens ) ; return true ; }
","ICO handler
"
"function transfer ( address _to , uint256 _value , bytes _data ) external isRunning requireThaw returns ( bool success ) { if ( _to == selfAddress ) { return transferToSelf ( _value , _data ) ; } else if ( isContract ( _to ) ) { return transferToContract ( _to , _value , _data ) ; } else { return transferToAddress ( _to , _value , _data ) ; } }
","Transfer the specified amount to the target address with embedded bytes data ~ ERC-223 Proposed Standard
"
"function sell ( uint256 amount ) public { require ( tradeActive == true ) ; require ( this . balance >= amount * sellPrice ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sellPrice ) ; }
","Sell ` amount ` tokens to contract
"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner { balances [ target ] = balances [ target ] . add ( mintedAmount ) ; currentSupply = currentSupply . add ( mintedAmount ) ; Transfer ( 0 , this , mintedAmount ) ; Transfer ( this , target , mintedAmount ) ; }
","Increase the number of coins
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( now >= Stage3Deadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; successful ( ) ; } else if ( state == State . Stage1 && now >= Stage1Deadline ) { state = State . Stage2 ; } else if ( state == State . Stage2 && now >= Stage2Deadline ) { state = State . Stage3 ; } }
","function to check status
"
"function approve ( address _spender , uint256 _amount ) public whenNotPaused erc20 returns ( bool success ) { uint balanceAvailable = getAmountOfUnlockedTokens ( msg . sender ) ; require ( balanceAvailable >= _amount , ""You can only approve an amount >= the amount of tokens currently unlocked for this account"" ) ; mAllowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
","ERC20 backwards compatible approve .
"
"function drainContract ( ) external onlyOwner { msg . sender . transfer ( address ( this ) . balance ) ; }
","Returns balance to owner
"
"function cancelChampSale ( uint256 _id ) public champIsForSale ( _id ) onlyOwnerOfChamp ( _id ) { Champ storage champ = champs [ _id ] ; _cancelChampSale ( champ ) ; }
","Champ is no more for sale
"
"function transfer ( address _to , uint _value ) public returns ( bool ) { require ( balances [ msg . sender ] >= _value && balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","Send ` _value ` from ` msg.sender ` to ` _to `
"
"function tick ( ) internal returns ( bool ) { if ( _now != now ) { _now = now ; uint256 _today ; ( , , end , ended , , , , , , , , ) = FoMoLong . round_ ( thisRoundIndex ) ; if ( ! ended ) { _today = _now / 1 days ; } else { _today = end / 1 days ; } while ( today < _today ) { issuedInsurance = issuedInsurance . sub ( unitToExpire [ today ] ) ; today += 1 ; } } return ended ; }
","It is called everytime when a player interacts with this contract
"
"function updateStateChangeAgent ( address _agent , bool _status ) public onlyOwner { stateChangeAgents [ _agent ] = _status ; }
","update state change agent
"
"function _setProtocolVersion ( address _STFactoryAddress , uint8 _major , uint8 _minor , uint8 _patch ) internal { uint8 [ ] memory _version = new uint8 [ ] ( 3 ) ; _version [ 0 ] = _major ; _version [ 1 ] = _minor ; _version [ 2 ] = _patch ; uint24 _packedVersion = VersionUtils . pack ( _major , _minor , _patch ) ; require ( VersionUtils . isValidVersion ( getProtocolVersion ( ) , _version ) , ""In-valid version"" ) ; set ( Encoder . getKey ( ""latestVersion"" ) , uint256 ( _packedVersion ) ) ; set ( Encoder . getKey ( ""protocolVersionST"" , getUint ( Encoder . getKey ( ""latestVersion"" ) ) ) , _STFactoryAddress ) ; }
","Internal - Changes the protocol version and the SecurityToken contract
"
"function withdraw ( uint256 summeInWei ) isOwner { uint256 contractbalance = this . balance ; address sender = msg . sender ; require ( contractbalance >= summeInWei ) ; withdrawed ( sender , summeInWei , ""wei withdrawed"" ) ; sender . transfer ( summeInWei ) ; }
","Withdraw an amount of ether
"
"function claimPayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( job . worker == msg . sender ) ; uint payment = job . paymentAvailableForWorker ; require ( payment > 0 ) ; job . paymentAvailableForWorker = 0 ; emit PaymentClaimed ( msg . sender , payment , _JobID ) ; DAI . transfer ( msg . sender , payment ) ; }
","this function lets the worker claim the approved payment
"
"function _balanceOf ( address _owner ) internal view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return _ownedTokens [ _owner ] . length ; }
","Count all NFTs assigned to an owner
"
"function updateRenExBalances ( RenExBalances _newRenExBalancesContract ) external onlyOwner { emit LogRenExBalancesUpdated ( renExBalancesContract , _newRenExBalancesContract ) ; renExBalancesContract = _newRenExBalancesContract ; }
","The owner of the contract can update the RenExBalances address .
"
"function updateGenerationStopTime ( uint256 _season , uint8 _value ) public onlyManager whenNotPaused { require ( generationSeasonController [ _season ] == 1 && _value != 0 ) ; _updateGenerationSeasonFlag ( _season , _value ) ; }
","Updates the Generation Season Controller .
"
"function getTime ( ) internal returns ( uint256 ) { return now ; }
","This function is overrided by the test Mocks .
"
"function cloneTokens ( uint _from , uint _to ) returns ( bool success ) ;
","Function to clone tokens from a manager
"
"function isContract ( address _caller ) internal constant returns ( bool ) { uint size ; assembly { size := extcodesize ( _caller ) } return size > 0 ; }
","Internal function to determine if an address is a contract
"
"function takeOwnership ( uint _divCardId ) public isNotContract { address newOwner = msg . sender ; address oldOwner = divCardIndexToOwner [ _divCardId ] ; require ( _addressNotNull ( newOwner ) ) ; require ( _approved ( newOwner , _divCardId ) ) ; _transfer ( oldOwner , newOwner , _divCardId ) ; }
","Allow pre-approved user to take ownership of a dividend card .
"
"function _removeFromDebtRegister ( bytes4 currencyKey , uint amount ) internal { uint debtToRemove = effectiveValue ( currencyKey , amount , ""XDR"" ) ; uint existingDebt = debtBalanceOf ( messageSender , ""XDR"" ) ; uint totalDebtIssued = totalIssuedSynths ( ""XDR"" ) ; uint debtPercentage = debtToRemove . divideDecimalRoundPrecise ( totalDebtIssued ) ; uint delta = SafeDecimalMath . preciseUnit ( ) . add ( debtPercentage ) ; if ( debtToRemove == existingDebt ) { synthetixState . clearIssuanceData ( messageSender ) ; synthetixState . decrementTotalIssuerCount ( ) ; } else { uint newDebt = existingDebt . sub ( debtToRemove ) ; uint newTotalDebtIssued = totalDebtIssued . sub ( debtToRemove ) ; uint newDebtPercentage = newDebt . divideDecimalRoundPrecise ( newTotalDebtIssued ) ; synthetixState . setCurrentIssuanceData ( messageSender , newDebtPercentage ) ; } synthetixState . appendDebtLedgerValue ( synthetixState . lastDebtLedgerEntry ( ) . multiplyDecimalRoundPrecise ( delta ) ) ; }
","Remove a debt position from the register
"
"function getInitFunction ( ) external pure returns ( bytes4 ) ;
","This function returns the signature of configure function
"
"function removeMember ( address _member ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( members [ _member ] == true ) ; delete members [ _member ] ; for ( uint256 i = 0 ; i < memberKeys . length ; i ++ ) { if ( memberKeys [ i ] == _member ) { delete memberKeys [ i ] ; break ; } } emit MemberRemoved ( _member ) ; }
","Remove a member from this contract
"
"function _resourcesAtTime ( FactoryType _type , uint8 _level , uint256 _collected_at ) public view returns ( uint256 ) { return worktimeAtDate ( _collected_at ) * ( getProductsPerMinute ( _type , _level ) + getBonusPerMinute ( _type , _level ) ) / 100 ; }
","function for compute resource factory at time
"
"function addAttributeFor ( address account , uint256 attributeTypeID , uint256 value , uint256 validatorFee , bytes signature ) external payable ;
","Add an attribute of the type with ID ` attributeTypeID ` , an attribute value of ` value ` , and an associated validator fee of ` validatorFee ` to account ` account ` by passing in a signed attribute approval with signature ` signature ` .
"
"function giveMeCDP ( uint id ) public auth { tub . give ( bytes32 ( id ) , msg . sender ) ; }
","give ownership of a CDP back to the sender
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { bool sucsSlrLmt = _chkSellerLmts ( msg . sender , _value ) ; bool sucsByrLmt = _chkBuyerLmts ( _to , _value ) ; require ( sucsSlrLmt == true && sucsByrLmt == true ) ; uint valtmp = _value ; uint _valueTemp = valtmp ; valtmp = 0 ; _transfer ( msg . sender , _to , _valueTemp ) ; _valueTemp = 0 ; return true ; }
","Allows to Send Coins to other accounts
"
"function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; require ( beneficiary . send ( address ( this ) . balance ) ) ; tokenReward . transfer ( beneficiary , remanent ) ; emit LogBeneficiaryPaid ( beneficiary ) ; emit LogContributorsPayout ( beneficiary , remanent ) ; }
","closure handler
"
"function getCertificationDocumentAtIndex ( address student , uint256 index ) payable requestFeePaid returns ( bytes32 document ) { document = studentCertifications [ student ] . documents [ index ] ; }
","Requesting a certification document by index is a paying feature .
"
"function auditSecret ( bytes32 _swapID ) external view onlyClosedSwaps ( _swapID ) returns ( bytes32 secretKey ) { Swap memory swap = swaps [ _swapID ] ; return swap . secretKey ; }
","Audits the secret of an atomic swap .
"
"function finalizeApprovedContracts ( ) public onlyOwner { approvedContractsFinalized = true ; }
","Finalize the contract so it will be forever impossible to change the approved contracts list
"
"function proxyPayment ( address _th ) public payable notPaused initialized contributionOpen returns ( bool ) { require ( _th != 0x0 ) ; doBuy ( _th ) ; return true ; }
","This method will generally be called by the AIX token contract to acquire AIXs .
"
"function ( ) payable external { if ( ! funding ) revert ( ) ; if ( msg . value == 0 ) revert ( ) ; var numTokens = msg . value * ( 1000.0 / totalTokens ) ; totalTokens += numTokens ; balances [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; }
","Create tokens when funding is active .
"
"function issue ( uint256 _amount ) external authP ( ISSUE_ROLE , arr ( _amount ) ) { _mint ( address ( this ) , _amount ) ; }
","Mint ` @ tokenAmount ( self.token ( ) : address , _amount , false ) ` tokens for the Token Manager
"
"function getNotaryForSeller ( address seller ) public view validAddress ( seller ) returns ( address ) { require ( hasSellerBeenAccepted ( seller ) ) ; SellerInfo memory info = sellerInfo [ seller ] ; return info . notary ; }
","Gets the selected notary for the given seller .
"
"function description ( ) external view returns ( string ) ;
","A description of what this DAR is used for
"
"function transferOwnership ( address newOwner ) isOwner { assert ( newOwner != address ( 0 ) ) ; address oldOwner = owner ; owner = newOwner ; ownerChanged ( msg . sender , oldOwner , newOwner ) ; allowed [ this ] [ oldOwner ] = 0 ; allowed [ this ] [ newOwner ] = tokenBalanceOf [ this ] ; }
","Transfer the ownership to another account
"
"function getTokensSold ( ) public view returns ( uint256 ) { return totalTokensSold ; }
","Return the total no .
"
"function transferFrom ( address from , address to , uint256 value ) returns ( bool ok ) { if ( getState ( ) != State . Success ) throw ; if ( balances [ from ] >= value && allowed [ from ] [ msg . sender ] >= value && safeAdd ( balances [ to ] , value ) > balances [ to ] ) { balances [ to ] = safeAdd ( balances [ to ] , value ) ; balances [ from ] = safeSub ( balances [ from ] , value ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , value ) ; Transfer ( from , to , value ) ; return true ; } else { return false ; } }
","This function is disabled during the funding .
"
"function _transfer ( address _from , address _to , uint256 _amount , bytes _data ) internal returns ( bool success ) { require ( _to != 0x0 ) ; require ( _amount <= balanceOf ( _from ) ) ; uint256 initialBalances = balanceOf ( _from ) . add ( balanceOf ( _to ) ) ; balances [ _from ] = balanceOf ( _from ) . sub ( _amount ) ; balances [ _to ] = balanceOf ( _to ) . add ( _amount ) ; if ( isContract ( _to ) ) { ReceiverContract receiver = ReceiverContract ( _to ) ; receiver . tokenFallback ( _from , _amount , _data ) ; } assert ( initialBalances == balanceOf ( _from ) . add ( balanceOf ( _to ) ) ) ; return true ; }
","Underlying transfer function ; it is called by public functions later .
"
"function release ( ) public onlyOwnerOrCoOwner { _release ( ) ; }
","Owner must release all sale smart contracts
"
"function setLockQtyToAllowTrading ( uint qtyToLock ) external onlyOwner { lockQtyToAllowTrading = qtyToLock ; }
","allows the creator to set the qty each user address needs to lock in order to trade a given MarketContract
"
"function getRegion ( uint256 _tokenId ) public view returns ( string regionName , uint256 sellingPrice , address owner ) { Region storage region = regions [ _tokenId ] ; regionName = region . name ; sellingPrice = regionIndexToPrice [ _tokenId ] ; owner = regionIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific region .
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) public returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallReceiver ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function distributeBonuses ( ) public onlyOracleOrOwner onlySaleFinished notDestructed returns ( uint ) { ERC20Interface _token = ERC20Interface ( bonusToken ) ; uint _balance = _token . balanceOf ( address ( this ) ) ; if ( _balance == 0 ) { return _emitError ( EMISSION_PROVIDER_ERROR_INSUFFICIENT_BMC ) ; } Profiterole _profiterole = Profiterole ( profiterole ) ; if ( ! _token . approve ( address ( _profiterole ) , _balance ) ) { return _emitError ( EMISSION_PROVIDER_ERROR_INTERNAL ) ; } if ( OK != _profiterole . distributeBonuses ( _balance ) ) { revert ( ) ; } return OK ; }
","Performs distribution of sent BMC tokens and send them to Profiterole address Only by oracle address and after reaching hardcap conditions
"
"function finalizeTS ( ) public returns ( bool ) ;
","Finalize the TS and transfer funds
"
"function getAmountToGive ( OrderData order ) public view onlySelf returns ( uint256 amountToGive ) { bytes32 orderHash = hashOrder ( order ) ; uint256 makeFee = exchange . makeFee ( ) ; uint256 takeFee = exchange . takeFee ( ) ; uint256 ethVolumeAvailable ; if ( order . isSell ) { uint256 tokenVolumeAvailable = Math . min ( exchange . sellOrderBalances ( orderHash ) , order . tokenAmount ) ; ethVolumeAvailable = SafeMath . div ( SafeMath . mul ( tokenVolumeAvailable , order . weiAmount ) , order . tokenAmount ) ; amountToGive = SafeMath . add ( ethVolumeAvailable , feeFromTotalCost ( ethVolumeAvailable , takeFee ) ) ; } else { ethVolumeAvailable = Math . min ( removeFee ( exchange . buyOrderBalances ( orderHash ) , makeFee ) , order . weiAmount ) ; amountToGive = SafeMath . div ( SafeMath . mul ( ethVolumeAvailable , order . tokenAmount ) , order . weiAmount ) ; } }
","Gets the amount that Totle needs to give for this order
"
"function revoke ( ERC20 token ) public onlyOwner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance = token . balanceOf ( this ) ; uint256 unreleased = releasableAmount ( token ) ; uint256 refund = balance . sub ( unreleased ) ; revoked [ token ] = true ; token . transfer ( owner , refund ) ; emit Revoked ( ) ; }
","Allows the owner to revoke the vesting .
"
"function ( ) public payable { buyTokens ( msg . sender ) ; }
","Anonymous payable function , this makes it easier for people to buy their tokens
"
"function _setOracle ( address newOracle ) public returns ( uint ) { if ( msg . sender != admin ) { return fail ( Error . UNAUTHORIZED , FailureInfo . SET_ORACLE_OWNER_CHECK ) ; } PriceOracleInterface oracleInterface = PriceOracleInterface ( newOracle ) ; oracleInterface . assetPrices ( address ( 0 ) ) ; address oldOracle = oracle ; oracle = newOracle ; emit NewOracle ( oldOracle , newOracle ) ; return uint ( Error . NO_ERROR ) ; }
","Set new oracle , who can set asset prices
"
"function deletePoll ( bytes32 _hash ) external onlymanyowners ( sha3 ( msg . data ) ) { Poll poll = polls [ _hash ] ; if ( poll . exists ) { delete polls [ _hash ] ; LogPollDeleted ( _hash ) ; } }
","Delete a poll
"
"function getEstateSize ( uint256 estateId ) external view returns ( uint256 ) { return estateLandIds [ estateId ] . length ; }
","Return the amount of tokens for a given Estate
"
"function mintToken ( uint256 mintedAmount ) onlyOwner public { require ( _balanceOf [ _owner ] + mintedAmount >= _balanceOf [ _owner ] ) ; require ( _totalSupply + mintedAmount >= _totalSupply ) ; _balanceOf [ _owner ] += mintedAmount ; _totalSupply += mintedAmount ; Transfer ( 0 , _owner , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` owner ` , can be run only by owner
"
"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( DASToken ) { DASToken newToken = new DASToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }
","Update the DApp by creating a new token with new functionalities the msg.sender becomes the controller of this clone token
"
"function collectTokens ( ) public onlyOwner { uint256 balance = miniMeToken . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finalizedTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( months ( 18 ) ) ) ; uint256 canExtract = 0 ; if ( getTime ( ) <= finalizedTime . add ( months ( 36 ) ) ) { require ( collectedTokens < total . percent ( 50 ) ) ; canExtract = total . percent ( 50 ) ; } else { require ( collectedTokens < total ) ; canExtract = total ; } canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; miniMeToken . transfer ( owner , canExtract ) ; TokensWithdrawn ( owner , canExtract ) ; }
","The owner will call this method to extract the tokens
"
"function setAuthorizedContract ( string _contractName , address _authorizedAddress , bool _authorized ) external onlyContractOwner ( ""ContractManager"" , msg . sender ) { bytes memory contractNameBytes = bytes ( _contractName ) ; require ( contractNameBytes . length != 0 ) ; require ( _authorizedAddress != address ( 0 ) ) ; require ( authorization [ _contractName ] [ _authorizedAddress ] != _authorized ) ; authorization [ _contractName ] [ _authorizedAddress ] = _authorized ; emit AuthorizationChanged ( _authorizedAddress , _authorized , _contractName ) ; }
","Change whether an address is authorized to use a specific contract or not
"
"function renounceOwnership ( ) public onlyOwner { emit OwnershipTransferred ( owner , address ( 0 ) ) ; owner = address ( 0 ) ; }
","Renouncing to ownership will leave the contract without an owner .
"
"function getSwimmersListArray ( ) public view returns ( address [ ] _arrayToReturn ) { _arrayToReturn = swimmersList ; }
","Returns the array of swimmers addresses .
"
"function migrate ( ) onlyMigrationEnabled ( ) public ;
","should migrate state that belongs to msg.sender
"
"function setPrices ( uint256 newSellPrice , uint256 newBuyPrice ) onlyOwner public { sellTokenPerEther = newSellPrice ; buyTokenPerEther = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth and sell tokens for ` newSellPrice ` eth
"
"function orderConfirmer ( bytes32 _orderID ) external view returns ( address ) ;
","returns the darknode address which confirms the given orderID .
"
"function setMigrationAgent ( address _agent ) external { require ( migrationAgent == 0 ) ; require ( msg . sender == migrationMaster ) ; migrationAgent = _agent ; }
","Set address of migration target contract and enable migration process .
"
"function spiceUp ( uint256 _gameIndex , string message ) external payable { _processGameEnd ( ) ; require ( _gameIndex == gameIndex ) ; require ( gameStates [ gameIndex ] . gameStarted || ! paused ) ; require ( msg . value > 0 ) ; gameStates [ gameIndex ] . prizePool = gameStates [ gameIndex ] . prizePool . add ( msg . value ) ; SpiceUpPrizePool ( gameIndex , msg . sender , msg . value , message , gameStates [ gameIndex ] . prizePool ) ; }
","Spice up the prize pool .
"
"function getRaisedPOLY ( ) public view returns ( uint256 ) ;
","Return POLY raised by the STO
"
"function requestMortgageId ( Engine engine , uint256 loanId , uint256 deposit , uint256 landId , TokenConverter tokenConverter ) public returns ( uint256 id ) { require ( engine . getCurrency ( loanId ) == MANA_CURRENCY , ""Loan currency is not MANA"" ) ; address borrower = engine . getBorrower ( loanId ) ; require ( engine . getStatus ( loanId ) == Engine . Status . initial , ""Loan status is not inital"" ) ; require ( msg . sender == engine . getBorrower ( loanId ) || ( msg . sender == engine . getCreator ( loanId ) && creators [ msg . sender ] ) , ""Creator should be borrower or authorized"" ) ; require ( engine . isApproved ( loanId ) , ""Loan is not approved"" ) ; require ( rcn . allowance ( borrower , this ) >= REQUIRED_ALLOWANCE , ""Manager cannot handle borrower's funds"" ) ; require ( tokenConverter != address ( 0 ) , ""Token converter not defined"" ) ; require ( loanToLiability [ engine ] [ loanId ] == 0 , ""Liability for loan already exists"" ) ; uint256 landCost ; ( , , landCost , ) = landMarket . auctionByAssetId ( landId ) ; uint256 loanAmount = engine . getAmount ( loanId ) ; require ( ( loanAmount + deposit ) >= ( ( landCost / 10 ) * 11 ) , ""Not enought total amount"" ) ; _tokenTransferFrom ( mana , msg . sender , this , deposit ) ; id = mortgages . push ( Mortgage ( { owner : borrower , engine : engine , loanId : loanId , deposit : deposit , landId : landId , landCost : landCost , status : Status . Pending , tokenConverter : tokenConverter } ) ) - 1 ; loanToLiability [ engine ] [ loanId ] = id ; emit RequestedMortgage ( { _id : id , _borrower : borrower , _engine : engine , _loanId : loanId , _landId : landId , _deposit : deposit , _tokenConverter : tokenConverter } ) ; }
","Request a mortgage with a loan id
"
"function setAccountStatus ( Data storage self , address account , bool isAllowed , string issuerFirm ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'account.allowed' , getForwardedAccount ( self , account ) ) ) ; require ( self . Storage . setBool ( id , isAllowed ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; emit AccountStatus ( account , isAllowed , issuerFirm ) ; return true ; }
","Set the global approval status ( true/false ) for a given account
"
"function calculateCommission ( uint32 _canvasId ) public view stateOwned ( _canvasId ) returns ( uint commission , bool isPaid ) { Bid storage bid = bids [ _canvasId ] ; Canvas storage canvas = _getCanvas ( _canvasId ) ; return ( _calculateCommission ( bid . amount ) , canvas . isCommissionPaid ) ; }
","Calculates commission that has been charged for selling the canvas .
"
"function removeRole ( address addr , string role ) public onlyOwnerOrAdmin { roles [ addr ] [ role ] = false ; emit RoleRemoved ( addr , role ) ; }
","Remove a role from an address .
"
"function addOfficialOperator ( address _operator ) external onlyOwner { require ( _operator . isContract ( ) , ""An official operator must be a contract."" ) ; require ( ! mIsOfficialOperator [ _operator ] , ""_operator is already an official operator."" ) ; mIsOfficialOperator [ _operator ] = true ; emit OfficialOperatorAdded ( _operator ) ; }
","Add an address into the list of official operators .
"
"function transferTokensToUser ( address tokenAddress , uint256 tokenAmount ) internal { if ( tokenAmount > 0 ) { if ( ! ERC20SafeTransfer . safeTransfer ( tokenAddress , msg . sender , tokenAmount ) ) { errorReporter . revertTx ( ""Unable to transfer tokens to user"" ) ; } } }
","Transfers the given amount of tokens back to the msg.sender
"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function totalSupply ( ) public view returns ( uint ) { return players . length ; }
","Returns the total number of Players currently in existence .
"
"function updateMinimumEpochInterval ( uint256 _nextMinimumEpochInterval ) external onlyOwner { nextMinimumEpochInterval = _nextMinimumEpochInterval ; }
","Allows the contract owner to update the minimum epoch interval .
"
"function reparametrizeMultisig ( bytes32 msigId , uint unlockTime ) public payable { require ( multisigs [ msigId ] . owner == msg . sender ) ; Multisig storage multisig = multisigs [ msigId ] ; multisig . deposit = add ( multisig . deposit , msg . value ) ; assert ( multisig . unlockTime <= unlockTime ) ; multisig . unlockTime = unlockTime ; emit MultisigReparametrized ( msigId ) ; }
","Inititate/extend multisig unlockTime and/or initiate/refund multisig deposit
"
"function sendTransaction ( address to , uint256 value , bytes data ) public onlyOwner returns ( bool ) { return to . call . value ( value ) ( data ) ; }
","Executes a transaction from this contract
"
"function forward ( bytes _evmScript ) public { require ( canForward ( msg . sender , _evmScript ) , ERROR_CAN_NOT_FORWARD ) ; bytes memory input = new bytes ( 0 ) ; address [ ] memory blacklist = new address [ ] ( 1 ) ; blacklist [ 0 ] = address ( token ) ; runScript ( _evmScript , input , blacklist ) ; }
","Execute desired action as a token holder
"
"function ( ) payable public { require ( isContract ( controller ) ) ; require ( ITokenController ( controller ) . proxyPayment . value ( msg . value ) ( msg . sender ) == true ) ; }
","The fallback function : If the contract 's controller has not been set to 0 , then the ` proxyPayment ` method is called which relays the ether and creates tokens as described in the token controller contract
"
"function ( ) payable { IncomingTx ( block . number , msg . sender , msg . value , now ) ; }
","Triggered by invalid function calls and incoming transactions
"
"function transferMinusFees ( address _to , uint256 _value , uint128 _totalGasFeesSpentByRelayer , uint16 _fee ) private { uint256 _totalFees = ( _value * _fee / 10000 ) + _totalGasFeesSpentByRelayer ; if ( _value - _totalFees > _value ) { return ; } feesAvailableForWithdraw += _totalFees ; _to . transfer ( _value - _totalFees ) ; }
","Transfer the value of an escrow , minus the fees , minus the gas costs incurred by relay
"
"function claimAssetPack ( uint _assetPackId ) public { require ( approvedTakeover [ _assetPackId ] == msg . sender ) ; approvedTakeover [ _assetPackId ] = address ( 0 ) ; assetPacks [ _assetPackId ] . creator = msg . sender ; }
","claim asset pack that is previously approved by creator
"
"function createDividend ( uint256 _maturity , uint256 _expiry ) payable public onlyOwner { require ( _expiry > _maturity ) ; require ( _expiry > now ) ; require ( msg . value > 0 ) ; uint256 dividendIndex = dividends . length ; uint256 checkpointId = ISecurityToken ( securityToken ) . createCheckpoint ( ) ; uint256 currentSupply = ISecurityToken ( securityToken ) . totalSupply ( ) ; dividends . push ( Dividend ( checkpointId , now , _maturity , _expiry , msg . value , 0 , currentSupply , false ) ) ; emit EtherDividendDeposited ( msg . sender , checkpointId , now , _maturity , _expiry , msg . value , currentSupply , dividendIndex ) ; }
","Creates a dividend and checkpoint for the dividend
"
"function list_indexed_bytesarray ( bytes32 _collection_index , uint256 _count , function ( bytes32 ) external constant returns ( bytes32 ) _function_first , function ( bytes32 ) external constant returns ( bytes32 ) _function_last , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _indexed_bytes_items ) { if ( _from_start ) { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _function_first ( _collection_index ) , _count , true , _function_last , _function_next ) ; } else { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _function_last ( _collection_index ) , _count , true , _function_first , _function_previous ) ; } }
","Lists an indexed Bytes collection from start or end
"
"function mint ( uint256 _stakeNumber ) public validMint ( _stakeNumber ) returns ( bool ) { uint256 mintAmount = calculateMint ( _stakeNumber ) ; stakes [ msg . sender ] [ _stakeNumber ] . coinsMinted = stakes [ msg . sender ] [ _stakeNumber ] . coinsMinted . add ( mintAmount ) ; stakes [ msg . sender ] [ _stakeNumber ] . lastBlockWithdrawn = block . number ; emit StakeRewardWithdrawn ( msg . sender , _stakeNumber , mintAmount ) ; require ( RTI . mint ( msg . sender , mintAmount ) , ""token minting failed"" ) ; return true ; }
","Used by a staker to claim currently staked coins
"
"function doSellerRequestCancel ( bytes16 _tradeID , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additionalGas ) private returns ( bool ) { Escrow memory _escrow ; bytes32 _tradeHash ; ( _escrow , _tradeHash ) = getEscrowAndHash ( _tradeID , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return false ; } if ( _escrow . sellerCanCancelAfter != 1 ) { return false ; } escrows [ _tradeHash ] . sellerCanCancelAfter = uint32 ( block . timestamp ) + requestCancellationMinimumTime ; emit SellerRequestedCancel ( _tradeHash ) ; if ( msg . sender == relayer ) { increaseGasSpent ( _tradeHash , GAS_doSellerRequestCancel + _additionalGas ) ; } return true ; }
","Request to cancel .
"
"function detachController ( ) external onlyController { address was = m_controller ; m_controller = address ( 0 ) ; ControllerRetired ( was ) ; }
","ability for controller to step down
"
"function retrieveFunds ( ) public onlyController { uint sntBalance = SNT . balanceOf ( address ( this ) ) ; require ( SNT . transfer ( msg . sender , sntBalance ) , ""Transfer did not work"" ) ; }
","Extract balance in ETH + SNT from the contract
"
"function setPrice ( address asset , uint requestedPriceMantissa ) public returns ( uint ) { if ( msg . sender != poster ) { return failOracle ( asset , OracleError . UNAUTHORIZED , OracleFailureInfo . SET_PRICE_PERMISSION_CHECK ) ; } return setPriceInternal ( asset , requestedPriceMantissa ) ; }
","entry point for updating prices
"
"function ( ) public payable { uint256 size ; address sender = msg . sender ; assembly { size := extcodesize ( sender ) } require ( size > 0 ) ; }
","payable fallback to block EOA sending eth
"
"function setStop ( ) onlyOwnerOrCoOwner { isStopped = true ; }
","Owner should release InvestmentDiscount smart contract before call this
"
"function checkGoalReached ( ) public afterDeadline { if ( ! goalChecked ) { if ( _checkFundingGoalReached ( ) ) { emit GoalReached ( beneficiary , tokenSold , amountRaisedETH ) ; } if ( ! crowdsaleClosed ) { crowdsaleClosed = true ; emit SaleClosed ( ) ; } goalChecked = true ; } }
","Check if the funding goal was reached .
"
"function setAddressAlias ( address oldAddr , address newAddr ) public onlyRole ( roleAddressAliaser ( ) ) { require ( addressAlias [ oldAddr ] == address ( 0 ) , ""oldAddr is already aliased to another address"" ) ; require ( addressAlias [ newAddr ] == address ( 0 ) , ""newAddr is already aliased to another address"" ) ; require ( oldAddr != newAddr , ""oldAddr and newAddr must be different"" ) ; setAddressAliasUnsafe ( oldAddr , newAddr ) ; }
","Alias a new address to an old address .
"
"function transfer ( address to , uint tokens ) public tokenTradingMustBeLive ( msg . sender ) returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ; }
","Transfers ` tokens ` from msg.sender to ` to `
"
"function init ( ) public onlyContractOwner onlyInit returns ( uint ) { needInitialization = false ; bytes32 _symbol = Token ( token ) . smbl ( ) ; if ( OK != Platform ( Token ( token ) . platform ( ) ) . reissueAsset ( _symbol , tokenSoftcap ) ) { revert ( ) ; } return OK ; }
","Initialization Issue new ATx tokens for Softcap .
"
"function getInvestorsAt ( uint256 _checkpointId ) external view returns ( address [ ] ) { uint256 count = 0 ; uint256 i ; for ( i = 0 ; i < investorData . investors . length ; i ++ ) { if ( balanceOfAt ( investorData . investors [ i ] , _checkpointId ) > 0 ) { count ++ ; } } address [ ] memory investors = new address [ ] ( count ) ; count = 0 ; for ( i = 0 ; i < investorData . investors . length ; i ++ ) { if ( balanceOfAt ( investorData . investors [ i ] , _checkpointId ) > 0 ) { investors [ count ] = investorData . investors [ i ] ; count ++ ; } } return investors ; }
","returns an array of investors at a given checkpoint NB - this length may differ from investorCount as it contains all investors that ever held tokens
"
"function initAtx ( address _proxy , address _serviceController , address _dataController , uint _lockupDate ) onlyContractOwner public returns ( bool ) { require ( _serviceController != 0x0 ) ; require ( _dataController != 0x0 ) ; require ( _proxy != 0x0 ) ; require ( _lockupDate > now || _lockupDate == 0 ) ; if ( ! super . init ( ATxProxy ( _proxy ) ) ) { return false ; } serviceController = ServiceController ( _serviceController ) ; dataController = DataController ( _dataController ) ; lockupDate = _lockupDate ; return true ; }
","Init function for ATxAsset .
"
"function registerNotary ( address notary , string name , string notaryUrl , string publicKey ) public onlyOwner whenNotPaused validAddress ( notary ) returns ( bool ) { bool isNew = notaryInfo [ notary ] . addr == address ( 0 ) ; require ( allowedNotaries . insert ( notary ) ) ; notaryInfo [ notary ] = NotaryInfo ( notary , name , notaryUrl , publicKey ) ; if ( isNew ) { emit NotaryRegistered ( notary ) ; } else { emit NotaryUpdated ( notary ) ; } return true ; }
","Registers a new notary or replaces an already existing one .
"
"function takeOwnership ( uint256 _deedId ) external whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; takeOwnershipMultiple ( _deedIds ) ; }
","Transfer a deed owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function totalSupply ( ) public view returns ( uint supply ) { return lib . getTokenSupply ( lib . getTokenSymbol ( address ( this ) ) ) ; }
","Gets total supply of token
"
"function getInstructions ( ) external view returns ( string ) { return ""Initialises a USD tiered STO."" ; }
","Returns the instructions associated with the module
"
"function withdrawFunds ( uint256 _amount ) external whenNotPaused onlyAdmin { require ( _amount <= address ( this ) . balance ) ; msg . sender . transfer ( _amount ) ; emit FundsWithdrawn ( msg . sender , _amount ) ; }
","Enables the admins to withdraw Ethers present in this contract .
"
"function getAttributeTypeID ( uint256 index ) external view returns ( uint256 ) { require ( index < _attributeIDs . length , ""provided index is outside of the range of defined attribute type IDs"" ) ; return _attributeIDs [ index ] ; }
","Get the ID of the attribute type at index ` index ` .
"
"function removeTokenFrom ( address _from , uint256 _tokenId ) internal { uint64 [ ] storage ownedList = ownedTokens [ _from ] ; TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner == _from , ""From address is incorrect"" ) ; lookupData . owner = address ( 0 ) ; uint64 replacementTokenIndex = ownedList [ ownedList . length - 1 ] ; delete ownedList [ ownedList . length - 1 ] ; ownedList . length -- ; if ( lookupData . ownedIndex < ownedList . length ) { ownedList [ lookupData . ownedIndex ] = replacementTokenIndex ; tokenLookup [ pixelcons [ replacementTokenIndex ] . tokenId ] . ownedIndex = lookupData . ownedIndex ; } lookupData . ownedIndex = 0 ; }
","Remove a token ID from the list of a given address
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value && balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value > 0 ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }
","Transfers '_value ' in wei to the '_to ' address
"
"function linkAddresses ( address _currentAddress , bytes _currentAddressSig , address _newAddress , bytes _newAddressSig , bytes32 _nonce ) external { require ( linkIds [ _newAddress ] == 0 ) ; validateLinkSignature ( _currentAddress , _newAddress , _nonce , _currentAddressSig ) ; validateLinkSignature ( _newAddress , _currentAddress , _nonce , _newAddressSig ) ; if ( linkIds [ _currentAddress ] == 0 ) { linkIds [ _currentAddress ] = ++ linkCounter ; } linkIds [ _newAddress ] = linkIds [ _currentAddress ] ; emit AddressLinked ( _currentAddress , _newAddress , linkIds [ _currentAddress ] ) ; }
","Add an address to an existing id on behalf of a user to pay the gas costs
"
"function setAllocation ( address _beneficiary , uint256 _amount ) external onlyOwner vaultLoading returns ( bool ) { require ( _beneficiary != address ( 0 ) , ""Beneficiary of allocation must not be blank"" ) ; require ( _amount != 0 , ""Amount of allocation must not be zero"" ) ; require ( allocations [ _beneficiary ] == 0 , ""Allocation amount for this beneficiary is not already set"" ) ; allocations [ _beneficiary ] = allocations [ _beneficiary ] . add ( _amount ) ; tokensAllocated = tokensAllocated . add ( _amount ) ; emit Allocated ( _beneficiary , _amount ) ; return true ; }
","Function to set allocations for accounts .
"
"function availableBalanceOf ( address _owner ) public view returns ( uint256 ) { uint256 balance = balances [ _owner ] ; for ( uint cellIndex = 0 ; cellIndex < frozenBalances [ _owner ] . length ; ++ cellIndex ) { if ( isSpendableFrozenCell ( _owner , cellIndex ) ) balance = balance . add ( frozenBalances [ _owner ] [ cellIndex ] . amount ) ; } return balance ; }
","Version of balanceOf ( ) which includes only currently spendable tokens .
"
"function claimTokens ( address _token ) onlyController public { if ( _token == 0x0 ) { controller . transfer ( this . balance ) ; return ; } Token token = Token ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( controller , balance ) ; ClaimedTokens ( _token , controller , balance ) ; }
","This method can be used by the controller to extract mistakenly sent tokens to this contract .
"
"function setTransferLockFree ( ) onlyAdmin public { require ( lockTransfer == true ) ; lockTransfer = false ; SetTransferLock ( lockTransfer ) ; }
","It 's only possible to unlock the transfers
"
"function viewTokenMeta ( uint256 _tokenId ) external view returns ( uint256 tokenType_ , string specialQuality_ , string tokenTitle_ , string tokenDescription_ , string iptcKeyword_ , string imageDescription_ , string tokenClass_ , string originalImageUrl_ ) { tokenType_ = tokenTypes [ _tokenId ] ; tokenTitle_ = tokenTitles [ _tokenId ] ; tokenDescription_ = tokenDescriptions [ _tokenId ] ; specialQuality_ = specialQualities [ _tokenId ] ; iptcKeyword_ = iptcKeywords [ _tokenId ] ; imageDescription_ = imageDescriptions [ _tokenId ] ; tokenClass_ = tokenClasses [ _tokenId ] ; originalImageUrl_ = originalImageUrls [ _tokenId ] ; }
","Returns all the relevant information about a specific token
"
"function whitelistAddress ( address _user , bool _flag ) public onlyAdmin ( 1 ) { whiteList [ _user ] = _flag ; }
","Whitelist function
"
"function setShp ( address _shp ) public onlyOwner { shp = SHP ( _shp ) ; }
","Sets the SHP token smart contract
"
"function purchase ( uint256 _productId , uint256 _numCycles , address _assignee , address _affiliate ) external payable whenNotPaused returns ( uint256 ) { require ( _productId != 0 ) ; require ( _numCycles != 0 ) ; require ( _assignee != address ( 0 ) ) ; require ( msg . value == costForProductCycles ( _productId , _numCycles ) ) ; if ( ! isSubscriptionProduct ( _productId ) ) { require ( _numCycles == 1 ) ; } uint256 attributes = uint256 ( keccak256 ( block . blockhash ( block . number - 1 ) ) ) ^ _productId ^ ( uint256 ( _assignee ) ) ; uint256 licenseId = _performPurchase ( _productId , _numCycles , _assignee , attributes , _affiliate ) ; if ( priceOf ( _productId ) > 0 && _affiliate != address ( 0 ) && _affiliateProgramIsActive ( ) ) { _handleAffiliate ( _affiliate , _productId , licenseId , msg . value ) ; } return licenseId ; }
","Makes a purchase of a product .
"
"function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { return transfersAllowed ; }
","Notifies the controller about an approval , for this TokenSale all approvals are allowed by default and no extra notifications are needed
"
"function buyTokensPostHook ( address _beneficiary , uint256 _tokens , uint256 _toFund ) internal { }
","post hook for buyTokens function
"
"function burnFrom ( address _from , uint _value ) public onlyOwner returns ( bool success ) { require ( balanceOf [ _from ] >= _value ) ; balanceOf [ _from ] -= _value ; totalSupply -= _value ; emit Burn ( _from , _value ) ; return true ; }
","Destroy tokens from other account
"
"function unlockedCollateral ( address account ) public view returns ( uint ) { uint locked = lockedCollateral ( account ) ; uint collat = collateral ( account ) ; return safeSub ( collat , locked ) ; }
","Collateral that is not locked and available for issuance .
"
"function getRarePLATInfo ( uint256 _tokenId ) external view returns ( uint256 sellingPrice , address owner , uint256 nextPrice , uint256 rareClass , uint256 cardId , uint256 rareValue ) { RareCard storage rarecard = rareArray [ _tokenId ] ; sellingPrice = SafeMath . mul ( IndexToPrice [ _tokenId ] , PLATPrice ) ; owner = IndexToOwner [ _tokenId ] ; nextPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 125 ) , 100 ) ; rareClass = rarecard . rareClass ; cardId = rarecard . cardId ; rareValue = rarecard . rareValue ; }
","Returns all the relevant information about a specific tokenId .
"
"function recoverToVault ( address _token ) public isInitialized transitionsPeriod { uint256 amount = _token == ETH ? address ( this ) . balance : ERC20 ( _token ) . balanceOf ( this ) ; require ( amount > 0 , ERROR_RECOVER_AMOUNT_ZERO ) ; _deposit ( _token , amount , ""Recover to Vault"" , this , false ) ; }
","Send tokens held in this contract to the Vault
"
"function transferTickerOwnership ( address _newOwner , string _ticker ) external whenNotPausedOrOwner { string memory ticker = Util . upper ( _ticker ) ; require ( _newOwner != address ( 0 ) , ""Invalid address"" ) ; bytes32 ownerKey = Encoder . getKey ( ""registeredTickers_owner"" , ticker ) ; require ( getAddress ( ownerKey ) == msg . sender , ""Not authorised"" ) ; if ( _tickerStatus ( ticker ) ) require ( IOwnable ( getAddress ( Encoder . getKey ( ""tickerToSecurityToken"" , ticker ) ) ) . owner ( ) == _newOwner , ""New owner does not match token owner"" ) ; _deleteTickerOwnership ( msg . sender , ticker ) ; _setTickerOwnership ( _newOwner , ticker ) ; set ( ownerKey , _newOwner ) ; emit ChangeTickerOwnership ( ticker , msg . sender , _newOwner ) ; }
","Transfers the ownership of the ticker
"
"function blacklisted ( ) public view requiresPermission returns ( bool ) { return true ; }
","If a user is blacklisted , they will have the permission to execute this dummy function .
"
"function remainingIssuableNomins ( address issuer ) view public returns ( uint ) { uint issued = nominsIssued [ issuer ] ; uint max = maxIssuableNomins ( issuer ) ; if ( issued > max ) { return 0 ; } else { return safeSub ( max , issued ) ; } }
","The remaining nomins an issuer can issue against their total havven quantity .
"
"function totalSupply ( ) public constant returns ( uint256 _totalSupply ) ;
","Get the total amount of token supply
"
"function setBurnAddress ( address _address ) onlyOwner { burnAddress = _address ; ledger . setBurnAddress ( _address ) ; token . setBurnAddress ( _address ) ; }
","New Functionality
"
"function removeModerator ( address _removeMod ) public onlyAdmin notFrozen returns ( bool success ) { moderators [ _removeMod ] = false ; ModeratorRemoved ( msg . sender , _removeMod , true ) ; return true ; }
","used to remove a moderator
"
"function registerDevices ( bytes32 [ ] _deviceIdHashes , bytes32 [ ] _deviceTypes , bytes32 [ ] _devicePublicKeys ) public onlyManufacturer whenNotPaused returns ( bool ) { require ( _deviceIdHashes . length > 0 , ""at least one device is required"" ) ; require ( _deviceIdHashes . length == _deviceTypes . length , ""device type array needs to be same size as devices"" ) ; require ( _deviceIdHashes . length == _devicePublicKeys . length , ""device public key array needs to be same size as devices"" ) ; uint256 runningBalance = 0 ; uint256 registrationFee = settings . registrationFee ( ) ; for ( uint256 i = 0 ; i < _deviceIdHashes . length ; i ++ ) { bytes32 deviceIdHash = _deviceIdHashes [ i ] ; bytes32 deviceType = _deviceTypes [ i ] ; bytes32 devicePublicKey = _devicePublicKeys [ i ] ; Device memory d = _registerDevice ( msg . sender , deviceIdHash , deviceType , devicePublicKey ) ; emit DeviceRegistered ( msg . sender , registrationFee , deviceIdHash , d . manufacturerId , deviceType ) ; runningBalance = runningBalance . add ( registrationFee ) ; } _depositTokens ( msg . sender , runningBalance ) ; require ( token . transferFrom ( msg . sender , address ( this ) , runningBalance ) , ""transferFrom failed"" ) ; return true ; }
","registers multiple devices on the Atonomi network
"
"function _updatePurchasingState ( address _beneficiary , uint256 _weiAmount ) internal { super . _updatePurchasingState ( _beneficiary , _weiAmount ) ; uint256 purchasedTokens = _getTokenAmount ( _weiAmount ) ; tokensRaised = tokensRaised . add ( purchasedTokens ) ; if ( capReached ( ) ) { emit CapOverflow ( _beneficiary , _weiAmount , purchasedTokens ) ; } }
","Update the amount of tokens raised & emit cap overflow events .
"
"function addAddressesToWhitelist ( address [ ] _addresses ) public onlyWhitelister { for ( uint i = 0 ; i < _addresses . length ; ++ i ) addToWhitelist ( _addresses [ i ] ) ; }
","Only callable by the whitelister .
"
"function purgeAccount ( address account ) external onlyOwner onlyDuringSetup { delete vestingSchedules [ account ] ; totalVestedBalance = totalVestedBalance . sub ( totalVestedAccountBalance [ account ] ) ; delete totalVestedAccountBalance [ account ] ; }
","Destroy the vesting information associated with an account .
"
"function withdraw ( uint256 amount ) external onlyOwner { _token . safeTransfer ( owner ( ) , amount ) ; }
","Withdraw tokens from the contract .
"
"function changeController ( address _newController ) onlyController public { controller = _newController ; }
","Changes the controller of the contract
"
"function calculateToFund ( address _beneficiary , uint256 _weiAmount ) internal view returns ( uint256 ) { uint256 weiAmount = _weiAmount ; uint8 currentStage ; bool onSale ; ( currentStage , onSale ) = getStageIndex ( ) ; require ( onSale ) ; Stage memory p = stages [ currentStage ] ; if ( p . kyc ) { require ( super . registered ( _beneficiary ) ) ; } require ( weiAmount >= uint ( p . minPurchaseLimit ) ) ; if ( p . maxPurchaseLimit != 0 && weiAmount > uint ( p . maxPurchaseLimit ) ) { weiAmount = uint ( p . maxPurchaseLimit ) ; } if ( p . cap > 0 ) { uint256 postWeiRaised = uint256 ( p . weiRaised ) . add ( weiAmount ) ; if ( postWeiRaised > p . cap ) { weiAmount = uint256 ( p . cap ) . sub ( p . weiRaised ) ; } } return super . calculateToFund ( _beneficiary , weiAmount ) ; }
","Override BaseCrowdsale.calculateToFund function .
"
"function isInitialized ( ) public view returns ( bool ) { return true ; }
","Check whether contract is initialised
"
"function getCurrencyAddress ( ) external view returns ( address ) { return currencyAddress ; }
","Returns address of oracle currency ( 0x0 for ETH )
"
"function setEtherFeeMin ( uint256 min ) public onlyOwner { etherFeeMin = min ; }
","Set the minimum amount of Ether to be deducted during a buy .
"
"function mConfirmPayment ( uint [ ] pledgesAmounts ) { for ( uint i = 0 ; i < pledgesAmounts . length ; i ++ ) { uint64 idPledge = uint64 ( pledgesAmounts [ i ] & ( D64 - 1 ) ) ; uint amount = pledgesAmounts [ i ] / D64 ; confirmPayment ( idPledge , amount ) ; } }
","` mConfirmPayment ` allows for multiple pledges to be confirmed efficiently
"
"function mintOnce ( string _key , address _to , uint256 _amount ) private whenNotPaused whenNotMinted ( _key ) returns ( bool ) { mintingList [ computeHash ( _key ) ] = true ; return mintTokens ( _to , _amount ) ; }
","Mints the tokens only once against the supplied key ( category ) .
"
"function updatePollDescription ( uint _idPoll , bytes _description , uint8 _numBallots ) public { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; require ( _numBallots <= 100 , ""Only a max of 100 ballots are allowed"" ) ; Poll storage p = _polls [ _idPoll ] ; require ( p . startBlock > block . number , ""You cannot modify an active poll"" ) ; require ( p . author == msg . sender || msg . sender == controller , ""Only the owner/controller can modify the poll"" ) ; p . numBallots = _numBallots ; p . description = _description ; p . author = msg . sender ; }
","Update poll description ( title or ballots ) as long as it has n't started
"
"function contains ( string source , string query ) internal pure returns ( bool ) { return indexOf ( source , query ) != - 1 ; }
","Returns true if and only if source string contains the specified query substring .
"
"function balanceOf ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return ownerToRareArray [ _owner ] . length ; }
","Count all the rare items assigned to an owner
"
"function removeValidatorApproval ( address validator , uint256 attributeTypeID ) external ;
","Deny the validator at address ` validator ` the ability to continue to issue attributes of the type with ID ` attributeTypeID ` .
"
"function destroy ( ) public auth { require ( stopped ) ; selfdestruct ( msg . sender ) ; }
","transfer all ETH balance from this contract to the sender and destroy the contract .
"
"function optOut ( ) public returns ( bool ) { if ( userOptOutVersion [ msg . sender ] != 0x0 ) { return false ; } userOptOutVersion [ msg . sender ] = latestVersion ; return true ; }
","Disagree with proposed upgrade , and stick with current asset implementation until further explicit agreement to upgrade .
"
"function changeHolderCount ( uint256 _maxHolderCount ) public withPerm ( ADMIN ) { emit ModifyHolderCount ( maxHolderCount , _maxHolderCount ) ; maxHolderCount = _maxHolderCount ; }
","Sets the cap for the amount of token holders there can be
"
"function transfer ( address _to , uint256 _value ) { _transfer ( msg . sender , _to , _value ) ; }
","Send ` _value ` tokens to ` _to ` from your account
"
"function sendWithSignature ( address _to , uint256 _amount , uint256 _fee , bytes _data , uint256 _nonce , bytes _sig ) public returns ( bool ) { doSendWithSignature ( _to , _amount , _fee , _data , _nonce , _sig , true ) ; return true ; }
","sends tokens using signature to recover token sender
"
"function getUserList ( ) public view onlyAllowed returns ( address [ ] _userList ) { return users ; }
","Get list of users with coins stored in the contract This function can only be called by the Advertisement contract
"
"function setTradingLive ( ) public onlyOwner { tradingLive = true ; }
","One-way toggle to allow trading ( remove global freeze )
"
"function staticExchangeChecks ( OrderData data ) public view whenNotPaused onlySelf returns ( bool checksPassed ) { bytes32 orderHash ; bytes32 prefixedHash ; ( orderHash , prefixedHash ) = getOrderHash ( data ) ; return ( data . takerAddress != data . makerAddress && data . expiration >= block . timestamp && ecrecover ( prefixedHash , data . v , data . r , data . s ) == data . makerAddress && ! exchange . fills ( orderHash ) && data . takerAddress == address ( this ) && Utils . tokenAllowanceAndBalanceSet ( data . makerAddress , data . makerToken , data . makerAmount , address ( exchange ) ) ) ; }
","Perform exchange-specific checks on the given order
"
"function modifyWhitelist ( address _investor , uint256 _fromTime , uint256 _toTime , uint256 _expiryTime , bool _canBuyFromSTO ) public withPerm ( WHITELIST ) { whitelist [ _investor ] = TimeRestriction ( _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; emit ModifyWhitelist ( _investor , now , msg . sender , _fromTime , _toTime , _expiryTime , _canBuyFromSTO ) ; }
","Adds or removes addresses from the whitelist .
"
"function rentOutMultiple ( address _to , uint256 _rentPeriod , uint256 [ ] _deedIds ) public whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; for ( uint256 i = 0 ; i < _deedIds . length ; i ++ ) { uint256 _deedId = _deedIds [ i ] ; require ( validIdentifier ( _deedId ) ) ; require ( identifierToRentPeriodEndTimestamp [ _deedId ] < now ) ; require ( _owns ( msg . sender , _deedId ) ) ; _rentOut ( _to , _rentPeriod , _deedId ) ; } }
","Rents multiple plots out to another address .
"
"function thaw ( ) external privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { m_frozen = false ; }
","Make transfer of tokens available to everyone
"
"function getEndTime ( ) internal constant returns ( uint ) { return getStartTime ( ) + ( 5 days ) ; }
","end time of the pre-ICO
"
"function isReserved ( string _symbol , address _owner , string _tokenName , bytes32 _swarmHash ) public returns ( bool ) ;
","Check the symbol is reserved or not
"
"function setVault ( address _newVaultAddress ) onlyOwner public { vaultAddress = _newVaultAddress ; }
","` onlyOwner ` changes the location that ether is sent
"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return approved [ _owner ] [ _spender ] ; }
","Check ` _value ` tokens allowed to ` _spender ` by ` _owner `
"
"function unpause ( ) public onlyCOO { require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function collect ( ) external onlyAuthorized { owner . transfer ( address ( this ) . balance ) ; }
","collect ether to owner account
"
"function _getCampaign ( bytes32 campaignId ) internal returns ( CampaignLibrary . Campaign storage _campaign ) { return campaigns [ campaignId ] ; }
","Get a Campaign information Based on a camapaign Id ( bidId ) , returns all stored information for that campaign .
"
"function setQuestionFee ( address realitycheck , uint256 fee ) onlyOwner public { RealityCheckAPI ( realitycheck ) . setQuestionFee ( fee ) ; LogSetQuestionFee ( fee ) ; }
","Set a fee for asking a question with us as the arbitrator
"
"function cancelSaleWhenPaused ( uint256 _tokenId ) external whenPaused onlyGameManager { Sale memory sale = tokenIdToSale [ _tokenId ] ; require ( _isOnSale ( sale ) ) ; address seller = sale . seller ; _cancelSale ( _tokenId , seller ) ; }
","This is a state-modifying function that can be called while the contract is paused .
"
"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( msg . sender != controller ) { require ( transfersEnabled ) ; if ( allowed [ _from ] [ msg . sender ] < _amount ) return false ; allowed [ _from ] [ msg . sender ] -= _amount ; } return doTransfer ( _from , _to , _amount ) ; }
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function withdrawPayments ( address payee ) external nonReentrant onlyOwner requiresState ( State . REFUNDING ) { uint256 payment = m_weiBalances [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; totalInvested = totalInvested . sub ( payment ) ; m_weiBalances [ payee ] = 0 ; payee . transfer ( payment ) ; RefundSent ( payee , payment ) ; }
","withdraw accumulated balance , called by payee in case crowdsale has failed
"
"function disableTokenTransfers ( ) public onlyAdmin whenNotPaused { require ( released ) ; released = false ; emit TokenReleased ( released ) ; }
","This function disables token transfers for everyone .
"
"function buyTokensLowLevel ( address _beneficiary , uint256 _weisAmount ) private stopInEmergency returns ( uint256 tokenAmount ) { if ( _beneficiary == 0x0 ) { revert ( 'buyTokensLowLevel: _beneficiary == 0x0' ) ; } if ( timestamp ( ) < startTime || timestamp ( ) > endTime ) { revert ( 'buyTokensLowLevel: Not withinPeriod' ) ; } if ( ! SCWhitelist . isInvestor ( _beneficiary ) ) { revert ( 'buyTokensLowLevel: Investor is not registered on the whitelist' ) ; } if ( isFinalized ) { revert ( 'buyTokensLowLevel: ICO is already finalized' ) ; } if ( _weisAmount < weisMinInvestment ) { revert ( 'buyTokensLowLevel: Minimal investment not reached. Not enough ethers to perform the minimal purchase' ) ; } if ( weisRaised . add ( _weisAmount ) > weisHardCap ) { revert ( 'buyTokensLowLevel: HardCap reached. Not enough tokens on ICO contract to perform this purchase' ) ; } tokenAmount = _weisAmount . mul ( weisPerEther ) . div ( weisPerBigToken ) ; tokenAmount = tokenAmount . mul ( 100 ) . div ( discountedPricePercentage ) ; weisRaised = weisRaised . add ( _weisAmount ) ; if ( ! SCTokens . transfer ( _beneficiary , tokenAmount ) ) { revert ( 'buyTokensLowLevel: unable to transfer tokens from ICO contract to beneficiary' ) ; } emit BuyTokensLowLevel ( msg . sender , _beneficiary , _weisAmount , tokenAmount ) ; return tokenAmount ; }
","Low level token purchase function , w/o ether transfer from investor
"
"function stopPreSales ( ) onlyOwner public { isPreSales = false ; }
","Stop presales with setting state variable
"
"function resumeContribution ( ) onlyOwner { paused = false ; }
","Resumes the contribution
"
"function tokensup ( uint256 _value ) onlyowner public { totalBhinneka = safeAdd ( totalBhinneka , _value * ( 10 ** decimals ) ) ; balances [ owner ] = safeAdd ( balances [ owner ] , _value * ( 10 ** decimals ) ) ; }
","Alter the Total Supply .
"
"function adminWithdraw ( address _to ) public onlyAdmin validAddress ( _to ) { _to . transfer ( address ( this ) . balance ) ; }
","Withdraw all contract funds to ` ( _to ) `
"
"function transfer ( address _to , uint256 _value ) public notContractAddress ( _to ) returns ( bool success ) { require ( ! tokenFrozen ) ; require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` from ` msg.sender `
"
"function decreaseApproval ( address _spender , uint256 _subtractedValue ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) ) ; return super . decreaseApproval ( _spender , _subtractedValue ) ; }
","Decreases the approval of the spender .
"
"function validateNameInternal ( string _name ) constant internal returns ( bool allowed ) { bytes memory nameBytes = bytes ( _name ) ; uint lengthBytes = nameBytes . length ; if ( lengthBytes < minimumNameLength || lengthBytes > maximumNameLength ) { return false ; } bool foundNonPunctuation = false ; for ( uint i = 0 ; i < lengthBytes ; i ++ ) { byte b = nameBytes [ i ] ; if ( ( b >= 48 && b <= 57 ) || ( b >= 65 && b <= 90 ) || ( b >= 97 && b <= 122 ) ) { foundNonPunctuation = true ; continue ; } if ( b == 32 || b == 33 || b == 40 || b == 41 || b == 45 || b == 46 || b == 95 ) { continue ; } return false ; } return foundNonPunctuation ; }
","Check if ` _name ` is a reasonable choice of name .
"
"function unlock ( ) public { if ( now < unlockedAt ) throw ; if ( ! teamMultisig . send ( address ( this ) . balance ) ) throw ; Unlocked ( ) ; }
","Transfer locked tokens to Lunyr 's multisig wallet
"
"function verifyModule ( address _moduleFactory , bool _verified ) external ;
","( The only exception to this is that the author of the module is the owner of the ST - Only if enabled by the FeatureRegistry )
"
"function forward ( ) public payable { require ( msg . value > 0 ) ; weiCollected += msg . value ; internalForward ( ) ; }
","transfer wei to receiver
"
"function sendPending ( ) returns ( bool ) ;
","Execute the first TX in the pendingTxs queue .
"
"function getInstructions ( ) public view returns ( string ) { return ""Create a ERC20 dividend which will be paid out to token holders proportional to their balances at the point the dividend is created"" ; }
","Get the Instructions that helped to used the module
"
"function rollbackTransfer ( address _from , address _to , uint _value ) onlyPayloadSize ( 3 * 32 ) { require ( multiSigAddress == msg . sender ) ; balances [ _to ] = balances [ _to ] . sub ( _value ) ; balances [ _from ] = balances [ _from ] . add ( _value ) ; LogRollbackTransfer ( _from , _to , _value ) ; Transfer ( _from , _to , _value ) ; }
","Rollback transfer .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ;
","send ` _value ` token to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function setup ( address _tokenAddress ) public isOwner atStage ( Stages . AuctionDeployed ) { require ( _tokenAddress != 0x0 ) ; token = LetsbetToken ( _tokenAddress ) ; tokensAuctioned = token . balanceOf ( address ( this ) ) ; tokenMultiplier = 10 ** uint ( token . decimals ( ) ) ; stage = Stages . AuctionSetUp ; Setup ( ) ; }
","Set ` _tokenAddress ` as the token address to be used in the auction .
"
"function resetWinner ( ) public { require ( grace ) ; require ( now > timeOfWin + 30 days ) ; grace = false ; winner = 0 ; ownersBalance = 0 ; pot = address ( this ) . balance ; }
","Reset the hunt if the grace period is over
"
"function enableTransfers ( bool _isTransferEnabled ) public onlyAdmin { isTransferEnabled = _isTransferEnabled ; TransferStatus ( msg . sender , isTransferEnabled ) ; }
","Enables token holders to transfer their tokens freely if true after the crowdsale is finished it will be true for security reasons can be switched to false
"
"function unlock ( ) public onlyOwner { unlocked = true ; }
","Unlocks the token .
"
"function donate ( uint64 idGiver , uint64 idReceiver ) payable { if ( idGiver == 0 ) { idGiver = addGiver ( """" , """" , 259200 , ILiquidPledgingPlugin ( 0x0 ) ) ; } PledgeAdmin storage sender = findAdmin ( idGiver ) ; checkAdminOwner ( sender ) ; require ( sender . adminType == PledgeAdminType . Giver ) ; uint amount = msg . value ; require ( amount > 0 ) ; vault . transfer ( amount ) ; uint64 idPledge = findOrCreatePledge ( idGiver , new uint64 [ ] ( 0 ) , 0 , 0 , 0 , PledgeState . Pledged ) ; Pledge storage nTo = findPledge ( idPledge ) ; nTo . amount += amount ; Transfer ( 0 , idPledge , amount ) ; transfer ( idGiver , idPledge , amount , idReceiver ) ; }
","This is how value enters into the system which creates pledges ; the token of value goes into the vault and the amount in the pledge relevant to this Giver without delegates is increased , and a normal transfer is done to the idReceiver
"
"function _mint ( address _to , uint256 _tokenId ) internal { require ( _to != address ( 0 ) ) ; _addTokenTo ( _to , _tokenId ) ; emit Transfer ( address ( 0 ) , _to , _tokenId ) ; }
","Mint a new NFT token
"
"function getContentByID ( ContentMapping storage self , bytes32 _id ) public view returns ( Content storage _content , bool exists ) { return ( self . data [ _id ] , self . data [ _id ] . id == bytes32 ( 0 ) ) ; }
","get content by sha3 ID hash
"
"function getTokenAmount ( uint256 weiAmount ) internal view returns ( uint256 ) { uint256 bonus = computeBonus ( weiAmount ) ; uint256 rateWithBonus = rate . mul ( coeff . add ( bonus ) ) . div ( coeff ) ; return weiAmount . mul ( rateWithBonus ) ; }
","Overrided getTokenAmount function of parent Crowdsale contract to calculate the token with time and amount bonus .
"
"function setToken ( MintableToken _token ) public onlyOwner { token = _token ; }
","update instance of MintableToken
"
"function decimals ( ) public view returns ( uint _decimals ) { return lib . getTokenDecimals ( lib . getTokenSymbol ( address ( this ) ) ) ; }
","Gets decimals of token
"
"function removeApprovedContractAddress ( address contractAddress ) public onlyOwner { require ( ! approvedContractsFinalized ) ; approvedContractAddresses [ contractAddress ] = false ; }
","Unapprove a contract address for minting tokens and transferring tokens
"
"function reissueAsset ( bytes32 _symbol , uint _value ) public onlyOneOfOwners ( _symbol ) returns ( uint ) { if ( _value == 0 ) { return _error ( ATX_PLATFORM_INVALID_VALUE ) ; } Asset storage asset = assets [ _symbol ] ; if ( ! asset . isReissuable ) { return _error ( ATX_PLATFORM_CANNOT_REISSUE_FIXED_ASSET ) ; } if ( asset . totalSupply + _value < asset . totalSupply ) { return _error ( ATX_PLATFORM_SUPPLY_OVERFLOW ) ; } uint holderId = getHolderId ( msg . sender ) ; asset . wallets [ holderId ] . balance = asset . wallets [ holderId ] . balance . add ( _value ) ; asset . totalSupply = asset . totalSupply . add ( _value ) ; Emitter ( eventsHistory ) . emitIssue ( _symbol , _value , _address ( holderId ) ) ; _proxyTransferEvent ( 0 , holderId , _value , _symbol ) ; return OK ; }
","Issues additional asset tokens if the asset have dynamic supply .
"
"function getValidatorSigningKey ( address validator ) external view returns ( address signingKey ) ;
","Get a validator 's signing key .
"
"function deposit ( Data storage self , uint256 amount ) returns ( bool success , uint256 balance ) { uint8 index ; require ( self . opened > 0 ) ; require ( self . closed == 0 ) ; require ( self . token . balanceOf ( msg . sender ) >= amount ) ; index = index_or_throw ( self , msg . sender ) ; Participant storage participant = self . participants [ index ] ; success = self . token . transferFrom ( msg . sender , this , amount ) ; if ( success == true ) { balance = participant . balance ; balance += amount ; participant . balance = balance ; return ( true , balance ) ; } return ( false , 0 ) ; }
","Deposit amount to channel .
"
"function deleteDelegate ( address _delegate ) external withPerm ( CHANGE_PERMISSION ) { require ( delegateDetails [ _delegate ] != bytes32 ( 0 ) , ""delegate does not exist"" ) ; for ( uint256 i = 0 ; i < allDelegates . length ; i ++ ) { if ( allDelegates [ i ] == _delegate ) { allDelegates [ i ] = allDelegates [ allDelegates . length - 1 ] ; allDelegates . length = allDelegates . length - 1 ; } } delete delegateDetails [ _delegate ] ; }
","Used to delete a delegate
"
"function orderStatus ( bytes32 _orderID ) external view returns ( uint8 ) ;
","orderStatus should return the status of the order , which should be : 0 - Order not seen before 1 - Order details submitted > 1 - Order settled , or settlement no longer possible
"
"function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
","Determine the Spork token balance for an account
"
"function unarchiveModule ( address _module ) external onlyOwner { TokenLib . unarchiveModule ( modulesToData [ _module ] , _module ) ; }
","Unarchives a module attached to the SecurityToken
"
"function getPermissions ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory allPermissions = new bytes32 [ ] ( 1 ) ; allPermissions [ 0 ] = ADMIN ; return allPermissions ; }
","Return the permissions flag that are associated with CountTransferManager
"
"function releaseToEarlyInvestors ( address _beneficiary , uint256 _releaseAmount ) public onlyOwner { require ( isWhitelisted ( _beneficiary ) , ""Beneficiary is not whitelisted"" ) ; require ( now >= releaseTimeToUnlockEarlyInvestorTokens , ""Release Early Investors tokens on or after GMT: Wednesday, 21 August 2019 00:00:00"" ) ; uint256 releaseAmount = _releaseAmount . mul ( E18 ) ; require ( totalTokensIssuedToEarlyInvestors . add ( releaseAmount ) <= EARLY_INVESTORS_SUPPLY_LIMIT ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( releaseAmount ) ; totalTokensIssuedToEarlyInvestors = totalTokensIssuedToEarlyInvestors . add ( releaseAmount ) ; emit Released ( _releaseAmount ) ; }
","Transfers vested tokens to Early Investors .
"
"function claimManyAddresses ( uint256 _startIndex , uint256 _numberOfAddresses ) public isValidIndex ( _startIndex , _numberOfAddresses ) { uint256 endIndex = _startIndex . add ( _numberOfAddresses . sub ( 1 ) ) ; claimAddressesInternal ( _startIndex , endIndex ) ; }
","Distribute available tokens to a subset of users .
"
"function finalizeNextUpgrade ( ) external { if ( nextUpgradeAgent . owner ( ) == 0x0 ) revert ( ) ; if ( msg . sender != nextUpgradeMaster ) revert ( ) ; if ( finalizedNextUpgrade ) revert ( ) ; finalizedNextUpgrade = true ; nextUpgradeAgent . finalizeUpgrade ( ) ; UpgradeFinalized ( msg . sender , nextUpgradeAgent ) ; }
","finalize the upgrade
"
"function getSetupCost ( ) external view returns ( uint256 ) ;
","Get the setup cost of the module
"
"function getCampaignEndPointById ( bytes32 _bidId ) public returns ( string _endPoint ) { return campaignEndPoints [ _bidId ] ; }
","Get campaign signing web service endpoint Get the end point to which the user should submit the proof of attention to be signed
"
"function tokenBurner ( uint256 _amount ) public onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( totalSupply . sub ( _amount ) > 0 ) ; require ( balances [ msg . sender ] > _amount ) ; require ( balances [ msg . sender ] . sub ( _amount ) > 0 ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; emit Transfer ( msg . sender , 0 , _amount ) ; return true ; }
","Used to burn tokens and decrease total supply
"
"function initialize ( string _name , string _symbol ) public onlyInit { require ( bytes ( _name ) . length != 0 ) ; require ( bytes ( _symbol ) . length != 0 ) ; configureToken ( _name , _symbol ) ; initialized ( ) ; }
","Function to initialize the AragonApp
"
"function set ( uint _fee ) onlyOwner returns ( bool ) { value = _fee ; return true ; }
","Set the product creation fee
"
"function _transfer ( address _to , uint256 _tokenId ) private { address from = nft [ _tokenId ] . owner ; clearApproval ( _tokenId ) ; removeNFToken ( from , _tokenId ) ; addNFToken ( _to , _tokenId ) ; emit Transfer ( from , _to , _tokenId ) ; }
","Does NO checks .
"
"function changeOwnership ( address _newOwner ) external onlyOwner { require ( _newOwner != 0x0 ) ; address oldOwner = owner ; owner = _newOwner ; newOwnerCandidate = 0x0 ; emit OwnershipTransferred ( oldOwner , owner ) ; }
","` owner ` can step down and assign some other address to this role
"
"function updateGameTimes ( uint secondsPerPeriod , uint8 numberOfPeriods ) public onlyOwner { PLAYER_TURN_SINGLE_PERIOD = secondsPerPeriod ; PLAYER_START_PERIODS = numberOfPeriods ; }
","Separating the CFO and the CEO responsibilities requires the ability to set the CFO account
"
"function tokenMinter ( uint256 _amount ) internal view returns ( bool valid ) { require ( tokenMintingEnabled ) ; require ( _amount > 0 ) ; require ( totalSupply . add ( _amount ) > 0 ) ; require ( totalSupply . add ( _amount ) > totalSupply ) ; return true ; }
","Low level function Used to create new tokens and increase total supply
"
"function changeHatchEscapeCaller ( address _newEscapeHatchCaller ) onlyEscapeHatchCallerOrOwner { escapeHatchCaller = _newEscapeHatchCaller ; }
","Changes the address assigned to call ` escapeHatch ( ) `
"
"function setAccessManager ( address _accessManager ) external onlyContractOwner returns ( uint ) { require ( _accessManager != 0x0 ) ; accessManager = _accessManager ; return OK ; }
","Update access manager address
"
"function multiMint ( uint nonce , uint256 [ ] bits ) onlyOwner { require ( ! mintingStopped ) ; if ( nonce != mintingNonce ) return ; mintingNonce += 1 ; uint256 lomask = ( 1 << 96 ) - 1 ; uint created = 0 ; for ( uint i = 0 ; i < bits . length ; i ++ ) { address a = address ( bits [ i ] >> 96 ) ; uint value = bits [ i ] & lomask ; balanceOf [ a ] = balanceOf [ a ] + value ; controller . ledgerTransfer ( 0 , a , value ) ; created += value ; } totalSupply += created ; }
","Expected packed structure is [ ADDR ( 20 ) | VALUE ( 12 ) ] .
"
"function collectTokens ( ) public onlyOwner { uint256 balance = token . balanceOf ( address ( this ) ) ; uint256 total = collectedTokens . add ( balance ) ; uint256 finalizedTime = crowdsale . finishTime ( ) ; require ( finalizedTime > 0 && getTime ( ) > finalizedTime . add ( 14 days ) ) ; uint256 canExtract = total . mul ( getTime ( ) . sub ( finalizedTime ) ) . div ( months ( 12 ) ) ; canExtract = canExtract . sub ( collectedTokens ) ; if ( canExtract > balance ) { canExtract = balance ; } collectedTokens = collectedTokens . add ( canExtract ) ; require ( token . transfer ( owner , canExtract ) ) ; TokensWithdrawn ( owner , canExtract ) ; }
","The Dev ( Owner ) will call this method to extract the tokens
"
"function burn ( uint256 _value ) public returns ( bool success ) { require ( balanceOf [ msg . sender ] > _value ) ; balanceOf [ msg . sender ] -= _value ; totalSupply -= _value ; emit Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function clearIssuanceData ( address account ) external onlyAssociatedContract { delete issuanceData [ account ] ; }
","Clear issuance data for an address
"
"function transferOwnership ( address _newOwner ) public onlyOwner ( ) { require ( _newOwner != address ( 0 ) ) ; owner = _newOwner ; }
","Transfer smartContract ownership
"
"function proxyClaimTokens ( address receiverAddress ) public atStage ( Stages . AuctionEnded ) returns ( bool ) { require ( now > finalizedTime + TOKEN_CLAIM_WAITING_PERIOD ) ; require ( receiverAddress != 0x0 ) ; if ( bids [ receiverAddress ] == 0 ) { return false ; } uint num = ( tokenMultiplier * bids [ receiverAddress ] ) / finalPrice ; uint auctionTokensBalance = token . balanceOf ( address ( this ) ) ; if ( num > auctionTokensBalance ) { num = auctionTokensBalance ; } fundsClaimed += bids [ receiverAddress ] ; bids [ receiverAddress ] = 0 ; require ( token . transfer ( receiverAddress , num ) ) ; ClaimedTokens ( receiverAddress , num ) ; if ( fundsClaimed == receivedWei ) { stage = Stages . TokensDistributed ; TokensDistributed ( ) ; } assert ( token . balanceOf ( receiverAddress ) >= num ) ; assert ( bids [ receiverAddress ] == 0 ) ; return true ; }
","Claim auction tokens for ` receiverAddress ` after the auction has ended .
"
"function transferOwnership ( address _newOwner ) public onlyOwner { newOwner = _newOwner ; }
","Give the ownership to the address _newOwner .
"
"function issueAttribute ( address account , uint256 attributeTypeID , uint256 value ) external payable ;
","Issue an attribute of the type with ID ` attributeTypeID ` and a value of ` value ` to ` account ` if ` message.caller.address ( ) ` is approved validator .
"
"function claimTokens ( address _token ) auth { if ( _token == 0x0 ) { address ( msg . sender ) . transfer ( address ( this ) . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( address ( msg . sender ) , balance ) ; emit ClaimedTokens ( _token , address ( msg . sender ) , balance ) ; }
","This method can be used by the owner to extract mistakenly sent tokens to this contract .
"
"function claimFees ( bytes4 currencyKey ) external optionalProxy returns ( bool ) { uint availableFees = feesAvailable ( messageSender , ""XDR"" ) ; require ( availableFees > 0 , ""No fees available for period, or fees already claimed"" ) ; lastFeeWithdrawal [ messageSender ] = recentFeePeriods [ 1 ] . feePeriodId ; _recordFeePayment ( availableFees ) ; _payFees ( messageSender , availableFees , currencyKey ) ; emitFeesClaimed ( messageSender , availableFees ) ; return true ; }
","Claim fees for last period when available or not already withdrawn .
"
"function cancelPayment ( uint64 idPledge , uint amount ) onlyVault { Pledge storage p = findPledge ( idPledge ) ; require ( p . pledgeState == PledgeState . Paying ) ; uint64 oldPledge = findOrCreatePledge ( p . owner , p . delegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; oldPledge = normalizePledge ( oldPledge ) ; doTransfer ( idPledge , oldPledge , amount ) ; }
","Method called by the vault to cancel a payment .
"
"function creatorOf ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( address ) { TokenLookup storage lookupData = tokenLookup [ _tokenId ] ; require ( lookupData . owner != address ( 0 ) , ""PixelCon does not exist"" ) ; return pixelcons [ lookupData . tokenIndex ] . creator ; }
","Get the creator of PixelCon ` ( _tokenId ) `
"
"function requestCosign ( Engine engine , uint256 index , bytes data , bytes oracleData ) public returns ( bool ) { Mortgage storage mortgage = mortgages [ uint256 ( readBytes32 ( data , 0 ) ) ] ; require ( mortgage . engine == engine , ""Engine does not match"" ) ; require ( mortgage . loanId == index , ""Loan id does not match"" ) ; require ( mortgage . status == Status . Pending , ""Mortgage is not pending"" ) ; require ( engines [ engine ] , ""Engine not authorized"" ) ; mortgage . status = Status . Ongoing ; _generate ( uint256 ( readBytes32 ( data , 0 ) ) , mortgage . owner ) ; uint256 loanAmount = convertRate ( engine . getOracle ( index ) , engine . getCurrency ( index ) , oracleData , engine . getAmount ( index ) ) ; require ( rcn . transferFrom ( mortgage . owner , this , loanAmount ) , ""Error pulling RCN from borrower"" ) ; uint256 boughtMana = convertSafe ( mortgage . tokenConverter , rcn , mana , loanAmount ) ; delete mortgage . tokenConverter ; uint256 currentLandCost ; ( , , currentLandCost , ) = mortgage . landMarket . auctionByAssetId ( mortgage . landId ) ; require ( currentLandCost <= mortgage . landCost , ""Parcel is more expensive than expected"" ) ; require ( mana . approve ( mortgage . landMarket , currentLandCost ) , ""Error approving mana transfer"" ) ; flagReceiveLand = mortgage . landId ; mortgage . landMarket . executeOrder ( mortgage . landId , currentLandCost ) ; require ( mana . approve ( mortgage . landMarket , 0 ) , ""Error removing approve mana transfer"" ) ; require ( flagReceiveLand == 0 , ""ERC721 callback not called"" ) ; require ( land . ownerOf ( mortgage . landId ) == address ( this ) , ""Error buying parcel"" ) ; land . setUpdateOperator ( mortgage . landId , mortgage . owner ) ; uint256 totalMana = boughtMana . add ( mortgage . deposit ) ; uint256 rest = totalMana . sub ( currentLandCost ) ; require ( mana . transfer ( mortgage . owner , rest ) , ""Error returning MANA"" ) ; require ( mortgage . engine . cosign ( index , 0 ) , ""Error performing cosign"" ) ; mortgageByLandId [ mortgage . landId ] = uint256 ( readBytes32 ( data , 0 ) ) ; emit StartedMortgage ( uint256 ( readBytes32 ( data , 0 ) ) ) ; return true ; }
","Request the cosign of a loan Buys the parcel and locks its ownership until the loan status is resolved .
"
"function unpause ( ) public onlyOwner { super . _unpause ( ) ; }
","Unpause ( overridden function )
"
"function mintToken ( address _target , uint256 _mintedAmount ) onlyOwner { require ( _target != 0x0 ) ; balanceOf [ _target ] += _mintedAmount ; _totalSupply += _mintedAmount ; Transfer ( 0 , this , _mintedAmount ) ; Transfer ( this , _target , _mintedAmount ) ; }
","Create ` _mintedAmount ` tokens and send it to ` _target `
"
"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; personIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function safeWithdrawal ( ) public afterDeadline { require ( crowdsaleClosed , ""crowdsale must be closed"" ) ; if ( ! fundingGoalReached ) { require ( customer [ msg . sender ] . amountRaisedEther > 0 , ""message sender has not raised any ether to this contract"" ) ; uint256 amount = customer [ msg . sender ] . amountRaisedEther ; customer [ msg . sender ] . amountRaisedEther = 0 ; msg . sender . transfer ( amount ) ; emit FundsWithdrawal ( msg . sender , amount ) ; } else { require ( beneficiary == msg . sender , ""message sender is not the beneficiary"" ) ; uint256 ethAmount = address ( this ) . balance ; beneficiary . transfer ( ethAmount ) ; emit FundsWithdrawal ( beneficiary , ethAmount ) ; uint256 founderToken = ( tokenSold - minTokenSell ) * ( maxFounderToken - minFounderToken ) / ( maxTokenSell - minTokenSell ) + minFounderToken - ( maxBountyToken - tokenLeftForBounty ) ; require ( tokenReward . transfer ( beneficiary , founderToken ) , ""founder token transfer failed"" ) ; emit FounderTokenTransfer ( beneficiary , founderToken ) ; uint256 rdaToken = ( tokenSold - minTokenSell ) * ( maxRDAToken - minRDAToken ) / ( maxTokenSell - minTokenSell ) + minRDAToken ; require ( tokenReward . transfer ( beneficiary , rdaToken ) , ""RDA token transfer failed"" ) ; emit RDATokenTransfer ( beneficiary , rdaToken ) ; tokenReward . burn ( tokenReward . balanceOf ( this ) ) ; } }
","Withdraw your funds if the ICO softcap has not been reached .
"
"function withdraw ( ) public { uint toTransfer = pendingReturns [ msg . sender ] ; require ( toTransfer > 0 ) ; pendingReturns [ msg . sender ] = 0 ; msg . sender . transfer ( toTransfer ) ; }
","Withdraw pending returns .
"
"function onApprove ( address _owner , address _spender , uint256 _amount ) returns ( bool ) { return true ; }
","Notifies the controller about an approval , for this Campaign all approvals are allowed by default and no extra notifications are needed
"
"function totalSupply ( ) public view returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }
","Get the total supply of Green
"
"function addAddressToAccountForUser ( address _newAddress , bytes _newAddressSig , bytes _senderSig , address _sender , bytes32 _nonce ) private nonZero ( _newAddress ) { require ( ! usedSignatures [ keccak256 ( abi . encodePacked ( _newAddressSig ) ) ] , ""Signature not unique"" ) ; require ( ! usedSignatures [ keccak256 ( abi . encodePacked ( _senderSig ) ) ] , ""Signature not unique"" ) ; usedSignatures [ keccak256 ( abi . encodePacked ( _newAddressSig ) ) ] = true ; usedSignatures [ keccak256 ( abi . encodePacked ( _senderSig ) ) ] = true ; bytes32 _currentAddressDigest = signingLogic . generateAddAddressSchemaHash ( _newAddress , _nonce ) ; require ( _sender == signingLogic . recoverSigner ( _currentAddressDigest , _senderSig ) ) ; bytes32 _newAddressDigest = signingLogic . generateAddAddressSchemaHash ( _sender , _nonce ) ; require ( _newAddress == signingLogic . recoverSigner ( _newAddressDigest , _newAddressSig ) ) ; registry . addAddressToAccount ( _newAddress , _sender ) ; uint256 _accountId = registry . accountIdForAddress ( _newAddress ) ; emit AddressAdded ( _accountId , _newAddress ) ; }
","Add an address to an existing id
"
"function disablePrivileged ( ) external privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { m_allowPrivileged = false ; }
","Disables further use of any privileged functions like freezing tokens .
"
"function finalize ( ) public returns ( bool ) { require ( super . finalize ( ) ) ; require ( finishMinting ( ) ) ; return true ; }
","Overrides finalize function from RBACERC223TokenFinalization to prevent future minting after finalization
"
"function externalContribution ( address _contributor , uint256 _wei ) public payable { require ( externalContributionAgents [ msg . sender ] ) ; internalContribution ( _contributor , _wei ) ; }
","allows external user to do contribution
"
"function removeMember ( address userAddress ) public isMember ( userAddress ) onlyOwner { uint256 refund = cancelMembershipInternal ( userAddress ) ; emit AdminRemovedMember ( msg . sender , userAddress , refund ) ; }
","Can be called if user is authorised or joined
"
"function burn ( uint256 value ) returns ( bool success ) { require ( balances [ msg . sender ] > value && value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; currentSupply = currentSupply . sub ( value ) ; Burn ( msg . sender , value ) ; return true ; }
","Remove tokens from the system irreversibly
"
"function ( ) public payable { require ( ( msg . value >= 100000000000000000 ) && ( rateMe != 0 ) ) ; uint value = msg . value * rateMe ; require ( value / msg . value == rateMe ) ; token . transfer ( msg . sender , value ) ; }
","Any funds sent to this contract will be converted to the linked contract 's tokens
"
"function depositEther ( ) payable returns ( bool ) { ErrorReport ( tx . origin , 0 , 0 ) ; DepositToken ( ETH_TOKEN_ADDRESS , msg . value ) ; return true ; }
","ether could also be deposited without calling this function
"
"function burnBid ( uint _index ) public onlyOwner { require ( status == state . ended ) ; require ( bids_sorted_count == 0 ) ; require ( bids [ _index ] . exist == true ) ; require ( bids [ _index ] . is_decrypted == false ) ; require ( bids [ _index ] . is_burned == false ) ; bids_burned [ bids_burned_count ] = _index ; bids_burned_count ++ ; bids_decrypted [ bids_decrypted_count ] = _index ; bids_decrypted_count ++ ; bids [ _index ] . is_burned = true ; emit BidBurned ( _index ) ; }
","Allows the `` burning '' of a bid , for cases in which a bid was corrupted and ca n't be decrypted .
"
"function getAttributeValue ( address account , uint256 attributeTypeID ) external view returns ( uint256 value ) { address validator = _issuedAttributes [ account ] [ attributeTypeID ] . validator ; require ( ( _validators [ validator ] . exists && _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] && _attributeTypes [ attributeTypeID ] . exists ) , ""could not find an attribute value at the provided address and ID"" ) ; return _issuedAttributes [ account ] [ attributeTypeID ] . value ; }
","Retrieve the value of the attribute of the type with ID ` attributeTypeID ` on the account at ` account ` , assuming it is valid .
"
"function totalSupply ( ) public view returns ( uint ) { return dogs . length - 1 ; }
","Returns the total number of dogs currently in existence .
"
"function setMaxSecurityGuardDelay ( uint _maxSecurityGuardDelay ) onlyOwner { maxSecurityGuardDelay = _maxSecurityGuardDelay ; }
","` onlyOwner ` Changes the maximum number of seconds ` securityGuard ` can delay a payment
"
"function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; tokenReward . transfer ( creator , remanent ) ; LogContributorsPayout ( creator , remanent ) ; }
","closure handler
"
"function transferFrom ( address _from , address _to , uint256 _value ) public notContractAddress ( _to ) returns ( bool success ) { require ( ! tokenFrozen ) ; require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value <= allowances [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; balances [ _to ] += _value ; allowances [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }
","Send ` _value ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function reclaimERC20 ( address _tokenContract ) external onlyOwner { require ( _tokenContract != address ( 0 ) , ""Invalid address"" ) ; IERC20 token = IERC20 ( _tokenContract ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; require ( token . transfer ( msg . sender , balance ) , ""Transfer failed"" ) ; }
","Reclaims ERC20Basic compatible tokens
"
"function claimPlotWithData ( uint256 _deedId , string name , string description , string imageUrl , string infoUrl ) public payable whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; claimPlotMultipleWithData ( _deedIds , name , description , imageUrl , infoUrl ) ; }
","Buy an unclaimed plot .
"
"function ( ) external payable { require ( msg . value > 0 ) ; }
","The fallback function payable
"
"function refundTokens ( address _buyer , uint256 tokens ) external onlyCrowdsale whenNotPaused { require ( _buyer != address ( 0 ) ) ; require ( tokens > 0 ) ; require ( balances [ _buyer ] >= tokens ) ; balances [ _buyer ] = balances [ _buyer ] . sub ( tokens ) ; RefundedTokens ( _buyer , tokens ) ; }
","Deletes the amount of tokens refunded from that buyer balance
"
"function release ( ) public { require ( block . timestamp >= releaseTime ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; require ( amount > 0 ) ; token . transfer ( beneficiary , amount ) ; }
","Transfers tokens held by timelock to beneficiary .
"
"function askQuestion ( uint256 template_id , string question , address arbitrator , uint32 timeout , uint32 opening_ts , uint256 nonce ) public payable returns ( bytes32 ) { require ( templates [ template_id ] > 0 ) ; bytes32 content_hash = keccak256 ( template_id , opening_ts , question ) ; bytes32 question_id = keccak256 ( content_hash , arbitrator , timeout , msg . sender , nonce ) ; _askQuestion ( question_id , content_hash , arbitrator , timeout , opening_ts ) ; LogNewQuestion ( question_id , msg . sender , template_id , question , content_hash , arbitrator , timeout , opening_ts , nonce , now ) ; return question_id ; }
","Ask a new question and return the ID
"
"function newDaoRulesProposal ( uint _minQuorumDivisor , uint _minBoardMeetingFees , uint _minutesSetProposalPeriod , uint _minMinutesDebatePeriod , uint _feesRewardInflationRate , bool _transferable , uint _minutesDebatingPeriod ) payable returns ( uint ) ;
","Function to make a proposal to change the Dao rules
"
"function initialize ( address jurisdiction , uint256 validAttributeTypeID , address sender ) public initializer { Ownable . initialize ( sender ) ; Pausable . initialize ( sender ) ; _issuancePaused = false ; _registry = AttributeRegistryInterface ( jurisdiction ) ; _jurisdiction = BasicJurisdictionInterface ( jurisdiction ) ; _validAttributeTypeID = validAttributeTypeID ; }
","The initializer function for the OrganizationsValidator , with owner and pauser roles initially assigned to contract creator , and with an associated jurisdiction at ` jurisdiction ` and an assignable attribute type with ID ` validAttributeTypeID ` .
"
"function sellCoinsToICO ( uint256 amountOfCoinsToSell ) public returns ( bool success ) { uint amount = amountOfCoinsToSell ; msgSndr [ msg . sender ] = amount ; bool isPreview = false ; ICO ico = ICO ( _getIcoAddr ( ) ) ; bool icosuccess ; uint sellPaymentValue ; ( icosuccess , sellPaymentValue ) = ico . sell ( amount , msg . sender , isPreview ) ; require ( icosuccess == true ) ; require ( _getIcoAddr ( ) . balance >= safeAdd ( ico . getMinBal ( ) , sellPaymentValue ) ) ; bool sucsTrTk = false ; bool pymActSucs = false ; if ( isPreview == false ) { sucsTrTk = _safeTransferTkn ( msg . sender , owner , amount ) ; require ( sucsTrTk == true ) ; msgSndr [ msg . sender ] = sellPaymentValue ; pymActSucs = _safePaymentActionAtIco ( sellPaymentValue , msg . sender , 2 ) ; require ( pymActSucs == true ) ; } msgSndr [ msg . sender ] = 0 ; return ( true ) ; }
","Allows Token owners to Sell Tokens directly to this Contract
"
"function destroy ( ) onlyOwner public { uint256 balance = token . balanceOf ( this ) ; assert ( balance > 0 ) ; token . transfer ( owner , balance ) ; selfdestruct ( owner ) ; }
","Terminate contract and refund to owner
"
"function approve ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; powIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function getRareInfo ( uint256 _tokenId ) external view returns ( uint256 sellingPrice , address owner , uint256 nextPrice , uint256 rareClass , uint256 cardId , uint256 rareValue ) { RareCard storage rarecard = rareArray [ _tokenId ] ; sellingPrice = IndexToPrice [ _tokenId ] ; owner = IndexToOwner [ _tokenId ] ; nextPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , 125 ) , 100 ) ; rareClass = rarecard . rareClass ; cardId = rarecard . cardId ; rareValue = rarecard . rareValue ; }
","Returns all the relevant information about a specific tokenId .
"
"function transfer ( address to , uint256 value ) public returns ( bool ) { require ( _registry . hasAttribute ( to , _validAttributeTypeID ) , ""Transfer failed - receiver is not approved."" ) ; return super . transfer ( to , value ) ; }
","Transfer an amount of ` value ` to a receiver at account ` to ` .
"
"function rewardTokensForClient ( address _recipient , uint _amount ) external returns ( uint ) ;
","Function used by the client to pay with shares or tokens
"
"function getState ( ) public constant returns ( State ) { if ( finalizedCrowdfunding ) return State . Success ; else if ( getTime ( ) < preSaleStartTime ) return State . Waiting ; else if ( getTime ( ) >= preSaleStartTime && getTime ( ) < fundingStartTime && totalSupply < tokenCreationMax ) return State . PreSale ; else if ( getTime ( ) >= fundingStartTime && getTime ( ) < fundingStartTime + 2 days && totalSupply < tokenCreationMax ) return State . CommunitySale ; else if ( getTime ( ) >= ( fundingStartTime + 2 days ) && getTime ( ) < fundingEndTime && totalSupply < tokenCreationMax ) return State . PublicSale ; else if ( getTime ( ) >= fundingEndTime || totalSupply == tokenCreationMax ) return State . Success ; }
","This manages the crowdfunding state machine We make it a function and do not assign the result to a variable So there is no chance of the variable being stale
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool _success ) ;
","Transfers ` _value ` amount of tokens from address ` _from ` to address ` _to ` .
"
"function mOnApprove ( address owner , address spender , uint256 amount ) internal returns ( bool allow ) ;
","Notifies the controller about an approval allowing the controller to react if desired
"
"function proxyClaimTokens ( address receiver_address ) public atStage ( Stages . AuctionEnded ) returns ( bool ) { require ( now > end_time + token_claim_waiting_period ) ; require ( receiver_address != 0x0 ) ; if ( bids [ receiver_address ] == 0 ) { return false ; } uint num = ( token_multiplier * bids [ receiver_address ] ) / final_price ; uint auction_tokens_balance = token . balanceOf ( address ( this ) ) ; if ( num > auction_tokens_balance ) { num = auction_tokens_balance ; } funds_claimed += bids [ receiver_address ] ; bids [ receiver_address ] = 0 ; require ( token . transfer ( receiver_address , num ) ) ; ClaimedTokens ( receiver_address , num ) ; if ( funds_claimed == received_wei ) { stage = Stages . TokensDistributed ; TokensDistributed ( ) ; } assert ( token . balanceOf ( receiver_address ) >= num ) ; assert ( bids [ receiver_address ] == 0 ) ; return true ; }
","Claim auction tokens for ` receiver_address ` after the auction has ended .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { uint valtmp = _value ; uint _valueA = valtmp ; valtmp = 0 ; require ( _valueA <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] = safeSub ( allowance [ _from ] [ msg . sender ] , _valueA ) ; _transfer ( _from , _to , _valueA ) ; _valueA = 0 ; return true ; }
","Send ` _value ` tokens to ` _to ` on behalf of ` _from `
"
"function ( ) public payable { contribute ( ) ; }
","Function to handle eth transfers
"
"function balanceOf ( address _owner ) public view returns ( uint256 ) ;
","Count all NFTs assigned to an owner
"
"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; address generalTransferManager = new GeneralTransferManager ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( address ( generalTransferManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( generalTransferManager ) ; }
","Used to launch the Module with the help of factory
"
"function destroy ( ) onlyHammer { suicide ( msg . sender ) ; }
","Only hammer can call it
"
"function initialize ( address sender ) public initializer { Ownable . initialize ( sender ) ; Pausable . initialize ( sender ) ; }
","The initializer function for the jurisdiction , with owner and pauser roles initially assigned to contract creator ( ` message.caller.address ( ) ` ) .
"
"function useModule ( address _moduleFactory ) external ;
","Called by a security token to notify the registry it is using a module
"
"function getFinalizeTS ( bytes32 question_id ) public view returns ( uint32 ) { }
","Returns the timestamp at which the question will be/was finalized
"
"function transfer ( address _to , uint256 _deedId ) external whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; transferMultiple ( _to , _deedIds ) ; }
","Transfer a deed to another address .
"
"function getType ( ) public view returns ( uint8 ) { return 1 ; }
","Type of the Module factory
"
"function setUpgradeMaster ( address master ) external { require ( master != 0x0 && msg . sender == upgradeMaster ) ; upgradeMaster = master ; }
","Set address of upgrade target contract and enable upgrade process .
"
"function unlock ( address addr , uint index ) public { require ( addr == msg . sender ) ; var lock = lockRecordMap [ addr ] [ index ] ; require ( lock . amount > 0 && ! lock . completed ) ; var during = now - lock . time ; var reward = _calcReward ( during , lock . amount ) ; token t = token ( tokenAddr ) ; t . transferFrom ( owner , addr , lock . amount + reward ) ; lock . completed = true ; Unlock ( addr , index , lock . amount , reward ) ; }
","withdraw CZR
"
"function setWhitelistingAddress ( address _address ) external { require ( contractManager . authorize ( contractName , msg . sender ) ) ; require ( _address != address ( 0 ) ) ; require ( _address != whitelistingAddress ) ; address oldAddress = whitelistingAddress ; whitelistingAddress = _address ; emit WhitelistingAddressChanged ( oldAddress , _address ) ; }
","Change the address that is authorized to change whitelist
"
"function onChangeTokenController ( address sender , address newController ) public constant returns ( bool ) ;
","controls if sender can change controller to newController
"
"function addNewBoard ( bytes32 name , string boardDescription ) public payable returns ( bytes32 boardHash ) { require ( msg . value >= boardCost ) ; balance += msg . value ; boardHash = keccak256 ( abi . encodePacked ( name , msg . sender ) ) ; numBoards ++ ; boards [ boardHash ] = Board ( name , boardDescription , 0 , msg . sender ) ; emit newBoardCreated ( boardHash ) ; }
","a funding is required to create a new leaderboard
"
"function burn ( uint256 _amount ) public onlyOwner returns ( bool ) { require ( burnable != address ( 0x0 ) ) ; uint256 currTotalSupply = totalSupply ( ) ; uint256 previousBalance = balanceOf ( burnable ) ; require ( currTotalSupply >= _amount ) ; require ( previousBalance >= _amount ) ; updateValueAtNow ( totalSupplyHistory , currTotalSupply - _amount ) ; updateValueAtNow ( balances [ burnable ] , previousBalance - _amount ) ; emit Transfer ( burnable , 0 , _amount ) ; return true ; }
","Burns ` _amount ` tokens from pre-defined `` burnable '' address .
"
"function triggerDestruction ( uint ein , address [ ] memory firstChunk , address [ ] memory lastChunk , bool resetResolvers ) public _identityExists ( ein ) { require ( ! canRecover ( ein ) , ""Recovery has not recently been triggered."" ) ; Identity storage _identity = identityDirectory [ ein ] ; address payable [ 1 ] memory middleChunk = [ msg . sender ] ; require ( keccak256 ( abi . encodePacked ( firstChunk , middleChunk , lastChunk ) ) == recoveryLogs [ ein ] . hashedOldAssociatedAddresses , ""Cannot destroy an EIN from an address that was not recently removed from said EIN via recovery."" ) ; emit IdentityDestroyed ( msg . sender , ein , _identity . recoveryAddress , resetResolvers ) ; resetIdentityData ( _identity , address ( 0 ) , resetResolvers ) ; }
","Allows associated addresses recently removed via recovery to permanently disable their old Identity .
"
"function triggerVersion ( address ofVersion ) { trigger ( versionToProposalIds [ ofVersion ] ) ; addVersion ( ofVersion ) ; }
","Trigger new versions of Melon
"
"function tokenController ( ) public constant returns ( address currentController ) ;
","returns current controller
"
"function mintMulti ( address [ ] _investors , uint256 [ ] _values ) external returns ( bool success ) { require ( _investors . length == _values . length , ""Incorrect inputs"" ) ; for ( uint256 i = 0 ; i < _investors . length ; i ++ ) { mint ( _investors [ i ] , _values [ i ] ) ; } return true ; }
","Mints new tokens and assigns them to the target _investor .
"
"function getChampsCount ( ) external view returns ( uint256 ) { return champs . length ; }
","Gets total champs count
"
"function totalSupply ( ) external view returns ( uint256 ) { return _allTokens . length ; }
","Count NFTs tracked by this contract
"
"function validateTradeInput ( ERC20 src , uint srcAmount , ERC20 dest , address destAddress ) internal view returns ( bool ) { require ( srcAmount <= MAX_QTY ) ; require ( srcAmount != 0 ) ; require ( destAddress != address ( 0 ) ) ; require ( src != dest ) ; if ( src == ETH_TOKEN_ADDRESS ) { require ( msg . value == srcAmount ) ; } else { require ( msg . value == 0 ) ; require ( src . balanceOf ( this ) >= srcAmount ) ; } return true ; }
","use token address ETH_TOKEN_ADDRESS for ether
"
"function performSellOrder ( OrderData order , uint256 amountToGiveForOrder ) public onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { approveAddress ( address ( exchange ) , order . token ) ; uint256 takeFee = exchange . takeFee ( ) ; amountSpentOnOrder = amountToGiveForOrder ; uint256 ethAmount = SafeMath . div ( SafeMath . mul ( amountSpentOnOrder , order . weiAmount ) , order . tokenAmount ) ; amountReceivedFromOrder = SafeMath . sub ( ethAmount , exchange . calculateFeeForAccount ( ethAmount , takeFee , address ( this ) ) ) ; exchange . takeBuyOrder ( order . token , order . tokenAmount , order . weiAmount , amountSpentOnOrder , order . maker ) ; totlePrimary . transfer ( amountReceivedFromOrder ) ; }
","Perform a sell order at the exchange
"
"function setTokenConverter ( TokenConverter _tokenConverter ) external onlyOwner returns ( bool ) { require ( _isContract ( _tokenConverter ) , ""Should be a contract"" ) ; emit SetTokenConverter ( tokenConverter , _tokenConverter ) ; tokenConverter = _tokenConverter ; return true ; }
","Sets the token converter used to convert the MANA into RCN when performing the payment
"
"function supportsInterface ( bytes4 interfaceID ) external view returns ( bool ) { return ( interfaceID == this . supportsInterface . selector || interfaceID == ( this . hasAttribute . selector ^ this . getAttributeValue . selector ^ this . countAttributeTypes . selector ^ this . getAttributeTypeID . selector ) ) ; }
","Determine if the interface ID ` interfaceID ` is supported ( ERC-165 )
"
"function addNotary ( address notary , uint256 responsesPercentage , uint256 notarizationFee , string notarizationTermsOfService ) public onlyOwner validAddress ( notary ) returns ( bool ) { require ( transactionCompletedAt == 0 ) ; require ( responsesPercentage <= 100 ) ; require ( ! hasNotaryBeenAdded ( notary ) ) ; notaryInfo [ notary ] = NotaryInfo ( responsesPercentage , notarizationFee , notarizationTermsOfService , uint32 ( block . timestamp ) ) ; notaries . push ( notary ) ; orderStatus = OrderStatus . NotaryAdded ; return true ; }
","Adds a notary to the Data Order .
"
"function proposeMilestones ( bytes _newMilestones ) onlyRecipient campaignNotCanceled { proposedMilestones = _newMilestones ; changingMilestones = true ; NewMilestoneListProposed ( ) ; }
","` onlyRecipient ` Proposes new milestones or changes old milestones , this will require a user interface to be built up to support this functionality as asks for RLP encoded bytecode to be generated , until this interface is built you can use this script : https : //github.com/Giveth/milestonetracker/blob/master/js/milestonetracker_helper.js the functions milestones2bytes and bytes2milestones will enable the recipient to encode and decode a list of milestones , also see https : //github.com/Giveth/milestonetracker/blob/master/README.md
"
"function getPerson ( uint256 _tokenId ) public view returns ( string personName , uint256 sellingPrice , address owner ) ;
","Returns all the relevant information about a specific person .
"
"function liabilityCreated ( ILiability _liability , uint256 _start_gas ) external returns ( bool ) ;
","This method is for lighthouse contract use only
"
"function buy ( address _sender ) internal { if ( funding_ended ) throw ; if ( block . number < fundingStartBlock ) throw ; if ( block . number > fundingEndBlock ) throw ; if ( msg . value == 0 ) throw ; var numTokens = msg . value * tokenCreationRate ; totalTokens += numTokens ; balances [ _sender ] += numTokens ; founders . transfer ( msg . value ) ; Transfer ( 0 , _sender , numTokens ) ; }
","Create tokens when funding is active .
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( now > stage5Deadline && state != State . Successful ) { emit LogStageFinish ( state , stageDistributed ) ; state = State . Successful ; completedAt = now ; emit LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } else if ( state == State . stage1 && now > stage1Deadline ) { emit LogStageFinish ( state , stageDistributed ) ; state = State . stage2 ; stageDistributed = 0 ; } else if ( state == State . stage2 && now > stage2Deadline ) { emit LogStageFinish ( state , stageDistributed ) ; state = State . stage3 ; stageDistributed = 0 ; } else if ( state == State . stage3 && now > stage3Deadline ) { emit LogStageFinish ( state , stageDistributed ) ; state = State . stage4 ; stageDistributed = 0 ; } else if ( state == State . stage4 && now > stage4Deadline ) { emit LogStageFinish ( state , stageDistributed ) ; state = State . stage5 ; stageDistributed = 0 ; } }
","check status
"
"function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { return false ; }
","Notifies the controller about a token transfer allowing the controller to react if desired
"
"function startSettling ( bytes32 channelId ) public { require ( canStartSettling ( channelId , msg . sender ) ) ; PaymentChannel storage channel = channels [ channelId ] ; channel . settlingUntil = block . number + channel . settlingPeriod ; DidStartSettling ( channelId ) ; }
","Sender initiates settling of the contract .
"
"function leaveTokenGroupAndWithdrawBalance ( uint256 _tokenId ) external whenNotPaused { address userAdd = msg . sender ; var group = tokenIndexToGroup [ _tokenId ] ; var contributor = userAddressToContributor [ userAdd ] ; require ( _addressNotNull ( userAdd ) ) ; require ( group . exists ) ; require ( group . purchasePrice == 0 ) ; require ( group . addressToContributorArrIndex [ userAdd ] > 0 ) ; require ( contributor . tokenIdToGroupArrIndex [ _tokenId ] > 0 ) ; uint refundBalance = _clearContributorRecordInGroup ( _tokenId , userAdd ) ; _clearGroupRecordInContributor ( _tokenId , userAdd ) ; userAddressToContributor [ userAdd ] . withdrawableBalance += refundBalance ; FundsDeposited ( userAdd , refundBalance ) ; _withdrawUserFunds ( userAdd ) ; LeaveGroup ( _tokenId , userAdd , tokenIndexToGroup [ _tokenId ] . contributedBalance , refundBalance ) ; }
","Allow user to leave purchase group ; note that their contribution and any funds they have in their withdrawableBalance will transfered to them .
"
"function addAddressesToWhitelist ( address [ ] _users ) public isAdmin { addAddressesToWhitelistInternal ( _users ) ; }
","Adds a list of addresses to this pools whitelist .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( isNotContract ( _to ) ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }
","send ` _value ` token to ` _to ` from ` msg.sender `
"
"function _postValidatePurchase ( address , uint256 ) internal pure { }
","Validation of an executed purchase .
"
"function finalize ( ) external { if ( ! funding ) throw ; if ( ( block . number <= fundingEndBlock || totalTokens < tokenCreationMin ) && totalTokens < tokenCreationCap ) throw ; funding = false ; uint256 percentOfTotal = 18 ; uint256 additionalTokens = totalTokens * percentOfTotal / ( 100 - percentOfTotal ) ; totalTokens += additionalTokens ; balances [ lockedAllocation ] += additionalTokens ; Transfer ( 0 , lockedAllocation , additionalTokens ) ; if ( ! prospectors_team . send ( this . balance ) ) throw ; }
","Finalize crowdfunding
"
"function balanceOfAt ( address _investor , uint256 _checkpointId ) external view returns ( uint256 ) ;
","Queries balance at a specified checkpoint
"
"function incBalance ( address _acct , uint _val ) public onlyModule returns ( bool ) { balances [ _acct ] = balances [ _acct ] . add ( _val ) ; emit BalanceAdj ( msg . sender , _acct , _val , ""+"" ) ; return true ; }
","Increment ` _acct ` balance by ` _val `
"
"function GrantToken ( address _customer , uint256 _value , string note ) onlyOwner public { require ( balances [ msg . sender ] >= _value && balances [ _customer ] + _value > balances [ _customer ] ) ; BonusToken ( _customer , _value , note ) ; balances [ msg . sender ] -= _value ; balances [ _customer ] += _value ; Transfer ( msg . sender , _customer , _value ) ; }
","Grant tokens to customers
"
"function addAttribute ( uint256 attributeTypeID , uint256 value , uint256 validatorFee , bytes signature ) external payable { require ( ! _issuedAttributes [ msg . sender ] [ attributeTypeID ] . exists , ""duplicate attributes are not supported, remove existing attribute first"" ) ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; uint256 stake = msg . value . sub ( validatorFee ) . sub ( jurisdictionFee ) ; require ( stake >= minimumStake , ""attribute requires a greater value than is currently provided"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( address ( this ) , msg . sender , address ( 0 ) , msg . value , validatorFee , attributeTypeID , value ) ) ; require ( ! _invalidAttributeApprovalHashes [ hash ] , ""signed attribute approvals from validators may not be reused"" ) ; address signingKey = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; address validator = _signingKeys [ signingKey ] ; require ( canValidate ( validator , attributeTypeID ) , ""signature does not match an approved validator for given attribute type"" ) ; _issuedAttributes [ msg . sender ] [ attributeTypeID ] = IssuedAttribute ( { exists : true , setPersonally : true , operator : address ( 0 ) , validator : validator , value : value , stake : stake } ) ; _invalidAttributeApprovalHashes [ hash ] = true ; emit AttributeAdded ( validator , msg . sender , attributeTypeID , value ) ; if ( stake > 0 ) { emit StakeAllocated ( msg . sender , attributeTypeID , stake ) ; } if ( jurisdictionFee > 0 ) { if ( owner ( ) . send ( jurisdictionFee ) ) { emit FeePaid ( owner ( ) , msg . sender , attributeTypeID , jurisdictionFee ) ; } } if ( validatorFee > 0 ) { if ( validator . send ( validatorFee ) ) { emit FeePaid ( validator , msg . sender , attributeTypeID , validatorFee ) ; } } }
","Add an attribute of the type with ID ` attributeTypeID ` , an attribute value of ` value ` , and an associated validator fee of ` validatorFee ` to account of ` msg.sender ` by passing in a signed attribute approval with signature ` signature ` .
"
"function performRebalance ( Trade [ ] trades , bytes32 id ) public payable whenNotPaused { emit LogRebalance ( id ) ; TradeFlag [ ] memory tradeFlags = initialiseTradeFlags ( trades ) ; staticChecks ( trades , tradeFlags ) ; transferTokens ( trades , tradeFlags ) ; uint256 etherBalance = msg . value ; for ( uint256 i ; i < trades . length ; i ++ ) { Trade memory thisTrade = trades [ i ] ; TradeFlag memory thisTradeFlag = tradeFlags [ i ] ; CurrentAmounts memory amounts = CurrentAmounts ( { amountSpentOnTrade : 0 , amountReceivedFromTrade : 0 , amountLeftToSpendOnTrade : thisTrade . isSell ? thisTrade . tokenAmount : calculateMaxEtherSpend ( thisTrade , etherBalance ) } ) ; performTrade ( thisTrade , thisTradeFlag , amounts ) ; if ( amounts . amountReceivedFromTrade == 0 && thisTrade . optionalTrade ) { continue ; } if ( ! checkIfTradeAmountsAcceptable ( thisTrade , amounts . amountSpentOnTrade , amounts . amountReceivedFromTrade ) ) { errorReporter . revertTx ( ""Amounts spent/received in trade not acceptable"" ) ; } if ( thisTrade . isSell ) { etherBalance = SafeMath . add ( etherBalance , amounts . amountReceivedFromTrade ) ; } else { etherBalance = SafeMath . sub ( etherBalance , amounts . amountSpentOnTrade ) ; } transferTokensToUser ( thisTrade . tokenAddress , thisTrade . isSell ? amounts . amountLeftToSpendOnTrade : amounts . amountReceivedFromTrade ) ; } if ( etherBalance > 0 ) { msg . sender . transfer ( etherBalance ) ; } }
","Performs the requested portfolio rebalance
"
"function cancelGame ( uint _gameId ) public { address playerAddress = msg . sender ; uint gameId = playerGameId [ playerAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId ) ; require ( game . status == GameStatus . WAITING_FOR_SERVER ) ; closeGame ( game , gameId , playerAddress , ReasonEnded . CANCELLED_BY_PLAYER , 0 ) ; payOut ( game , playerAddress ) ; }
","Cancel game session waiting for server acceptance .
"
"function calcSharePriceAndAllocateFees ( ) public returns ( uint ) { var ( gav , managementFee , performanceFee , unclaimedFees , feesShareQuantity , nav , sharePrice ) = performCalculations ( ) ; createShares ( owner , feesShareQuantity ) ; uint highWaterMark = atLastUnclaimedFeeAllocation . highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation . highWaterMark : sharePrice ; atLastUnclaimedFeeAllocation = Calculations ( { gav : gav , managementFee : managementFee , performanceFee : performanceFee , unclaimedFees : unclaimedFees , nav : nav , highWaterMark : highWaterMark , totalSupply : _totalSupply , timestamp : now } ) ; emit FeesConverted ( now , feesShareQuantity , unclaimedFees ) ; emit CalculationUpdate ( now , managementFee , performanceFee , nav , sharePrice , _totalSupply ) ; return sharePrice ; }
","Converts unclaimed fees of the manager into fund shares
"
"function whitelistAddresses ( address [ ] _addresses , uint256 _tier , bool _status ) public onlyController { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { address investorAddress = _addresses [ i ] ; require ( investors [ investorAddress ] . contributedAmount == 0 ) ; investors [ investorAddress ] = WhitelistedInvestor ( _tier , _status , 0 ) ; } }
","interface for founders to whitelist investors
"
"function enableTransfers ( bool _transfersEnabled ) ;
","Enables token holders to transfer their tokens freely if true
"
"function getDisputeFee ( bytes32 question_id ) public view returns ( uint256 ) { return ( custom_dispute_fees [ question_id ] > 0 ) ? custom_dispute_fees [ question_id ] : dispute_fee ; }
","Return the dispute fee for the specified question .
"
"function mGenerateTokens ( address owner , uint256 amount ) internal { require ( owner != address ( 0 ) ) ; require ( parentToken ( ) == address ( 0 ) || parentSnapshotId ( ) < parentToken ( ) . currentSnapshotId ( ) ) ; uint256 curTotalSupply = totalSupply ( ) ; uint256 newTotalSupply = curTotalSupply + amount ; require ( newTotalSupply >= curTotalSupply ) ; uint256 previousBalanceTo = balanceOf ( owner ) ; uint256 newBalanceTo = previousBalanceTo + amount ; assert ( newBalanceTo >= previousBalanceTo ) ; setValue ( _totalSupplyValues , newTotalSupply ) ; setValue ( _balances [ owner ] , newBalanceTo ) ; emit Transfer ( 0 , owner , amount ) ; }
","Generates ` amount ` tokens that are assigned to ` owner `
"
"function processContribution ( ) private isValidContribution returns ( uint256 , uint256 ) { var ( allowedContribution , refundAmount ) = getAllowedContribution ( ) ; if ( ! honourWhitelist ( ) ) { AllowedContributionCheck ( allowedContribution , AllowedContributionState . WhitelistClosed ) ; return ( allowedContribution , refundAmount ) ; } if ( whitelist [ msg . sender ] > 0 ) { return processWhitelistedContribution ( allowedContribution , refundAmount ) ; } AllowedContributionCheck ( allowedContribution , AllowedContributionState . NotWhitelisted ) ; return ( allowedContribution , refundAmount ) ; }
","Returns the contribution to be used as part of the transaction , and any refund value if expected .
"
"function removePartOwner ( address _partowner ) external onlyContractOwner returns ( uint ) { delete partowners [ _partowner ] ; return OK ; }
","emoves a co-owner of a contract
"
"function unlockInvestor ( address investor ) private { Account memory accountInMem = _accounts [ investor ] ; if ( accountInMem . balance == 0 ) { return ; } removeInvestor ( investor , accountInMem . balance ) ; if ( _lockState == LockState . AcceptingUnlocks ) { require ( NEUMARK . transferFrom ( investor , address ( this ) , accountInMem . neumarksDue ) ) ; NEUMARK . burn ( accountInMem . neumarksDue ) ; if ( currentTime ( ) < accountInMem . unlockDate ) { require ( _penaltyDisbursalAddress != address ( 0 ) ) ; uint256 penalty = decimalFraction ( accountInMem . balance , PENALTY_FRACTION ) ; if ( isContract ( _penaltyDisbursalAddress ) ) { require ( ASSET_TOKEN . approveAndCall ( _penaltyDisbursalAddress , penalty , """" ) ) ; } else { assert ( ASSET_TOKEN . transfer ( _penaltyDisbursalAddress , penalty ) ) ; } LogPenaltyDisbursed ( _penaltyDisbursalAddress , penalty , ASSET_TOKEN , investor ) ; accountInMem . balance -= penalty ; } } if ( _lockState == LockState . ReleaseAll ) { accountInMem . neumarksDue = 0 ; } assert ( ASSET_TOKEN . transfer ( investor , accountInMem . balance ) ) ; LogFundsUnlocked ( investor , accountInMem . balance , accountInMem . neumarksDue ) ; }
","unlocks 'investor ' tokens by making them withdrawable from assetToken
"
"function getPayer ( bytes32 _requestId ) public view returns ( address ) { return requests [ _requestId ] . payer ; }
","Gets payer of a request .
"
"function unlock ( ) external { require ( block . timestamp >= unlockedAtTime ) ; require ( decentBetToken . transfer ( decentBetMultisig , decentBetToken . balanceOf ( address ( this ) ) ) ) ; }
","Transfer locked tokens to Decent.bet 's multisig wallet
"
"function canReceive ( address receiver ) external view returns ( bool ) ;
","Check if an account is approved to receive token transfers at account ` receiver ` .
"
"function private_list_indexed_bytes_from_bytes ( bytes32 _collection_index , bytes32 _current_item , uint256 _count , bool _including_current , function ( bytes32 ) external constant returns ( bytes32 ) _function_last , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_next ) private constant returns ( bytes32 [ ] _indexed_bytes_items ) { uint256 _i ; uint256 _real_count = 0 ; bytes32 _last_item ; _last_item = _function_last ( _collection_index ) ; if ( _count == 0 || _last_item == bytes32 ( 0x0 ) ) { _indexed_bytes_items = new bytes32 [ ] ( 0 ) ; } else { bytes32 [ ] memory _items_temp = new bytes32 [ ] ( _count ) ; bytes32 _this_item ; if ( _including_current ) { _items_temp [ 0 ] = _current_item ; _real_count = 1 ; } _this_item = _current_item ; for ( _i = _real_count ; ( _i < _count ) && ( _this_item != _last_item ) ; _i ++ ) { _this_item = _function_next ( _collection_index , _this_item ) ; if ( _this_item != bytes32 ( 0x0 ) ) { _real_count ++ ; _items_temp [ _i ] = _this_item ; } } _indexed_bytes_items = new bytes32 [ ] ( _real_count ) ; for ( _i = 0 ; _i < _real_count ; _i ++ ) { _indexed_bytes_items [ _i ] = _items_temp [ _i ] ; } } }
","a private function to lists an indexed Bytes collection starting from some ` _current_item ` ( which could be included or excluded ) , in the forwards or backwards direction
"
"function getVariableReleasableAmount ( address _beneficiary ) internal view returns ( uint releasableAmount ) { Beneficiary memory _b = beneficiaries [ _beneficiary ] ; Release memory _r = releases [ _beneficiary ] ; uint totalReleasableAmount = getTotalLockedAmounts ( _beneficiary ) ; uint releaseRatio ; for ( uint i = _r . releaseTimes . length - 1 ; i >= 0 ; i -- ) { if ( now >= _r . releaseTimes [ i ] ) { releaseRatio = _r . releaseRatios [ i ] ; break ; } } require ( releaseRatio > 0 ) ; releasableAmount = getPartialAmount ( releaseRatio , coeff , totalReleasableAmount ) ; releasableAmount = releasableAmount . sub ( _b . withdrawAmount ) ; }
","return releaseable amount for beneficiary in case of variable type of release
"
"function setCUSDAddress ( address _cusd ) public onlyOwner { require ( _cusd != address ( cusdAddress ) , ""Must be a new cusd address"" ) ; require ( AddressUtils . isContract ( _cusd ) , ""Must be an actual contract"" ) ; address oldCUSD = address ( cusdAddress ) ; cusdAddress = _cusd ; emit CUSDAddressChanged ( oldCUSD , _cusd ) ; }
","Change the cusd address .
"
"function howMuchCanIContributeNow ( ) view public returns ( uint256 ) { return howMuchCanXContributeNow ( msg . sender ) ; }
","How many wei can the msg.sender contribute now .
"
"function _payDividend ( address _payee , Dividend storage _dividend , uint256 _dividendIndex ) internal ;
","Internal function for paying dividends
"
"function insert ( MapStorage storage self , address _key ) public returns ( bool ) { require ( _key != address ( 0 ) ) ; if ( exist ( self , _key ) ) { return true ; } self . addressToIndex [ _key ] = self . addresses . length ; self . addresses . push ( _key ) ; return true ; }
","Inserts a new address within the given storage .
"
"function setEscrow ( HavvenEscrow _escrow ) external optionalProxy_onlyOwner { escrow = _escrow ; emitEscrowUpdated ( _escrow ) ; }
","Set the associated havven escrow contract .
"
"function getTokenSymbol ( Data storage self , address contractAddress ) internal view returns ( string tokenSymbol ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.symbol' , contractAddress ) ) ; return self . Storage . getString ( id ) ; }
","Get the token symbol for Token interfaces
"
"function transferFrom ( address _from , address _to , uint256 _value ) public saleOrUnfrozen ( msg . sender ) returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }
","Standard transferFrom but incorporating frozen tokens logic
"
"function fulfill ( ContentMapping storage self , bytes32 _id , address _creator , address _brand ) public returns ( bool ) { return self . data [ _id ] . deliverable . fulfill ( _creator , _brand ) ; }
","wrapper around internal deliverable method
"
"function mint ( address _tokenHolder , uint256 _amount , bytes _operatorData ) public onlyOwner { requireMultiple ( _amount ) ; mTotalSupply = mTotalSupply . add ( _amount ) ; mBalances [ _tokenHolder ] = mBalances [ _tokenHolder ] . add ( _amount ) ; callRecipient ( msg . sender , 0x0 , _tokenHolder , _amount , """" , _operatorData , true ) ; Minted ( msg . sender , _tokenHolder , _amount , _operatorData ) ; if ( mErc20compatible ) { Transfer ( 0x0 , _tokenHolder , _amount ) ; } }
","Generates ` _amount ` tokens to be assigned to ` _tokenHolder ` Sample mint function to showcase the use of the ` Minted ` event and the logic to notify the recipient .
"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { require ( _beneficiary != address ( 0 ) ) ; require ( _weiAmount != 0 ) ; increaseTime = token . pauseTime ( ) ; require ( ! crowdsaleClosed && block . timestamp >= start . add ( increaseTime ) && block . timestamp <= end . add ( increaseTime ) ) ; }
","Validation of an incoming purchase .
"
"function list_indexed_bytesarray_from ( bytes32 _collection_index , bytes32 _current_item , uint256 _count , function ( bytes32 ) external constant returns ( bytes32 ) _function_first , function ( bytes32 ) external constant returns ( bytes32 ) _function_last , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _indexed_bytes_items ) { if ( _from_start ) { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _current_item , _count , false , _function_last , _function_next ) ; } else { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _current_item , _count , false , _function_first , _function_previous ) ; } }
","Lists an indexed Bytes collection from some ` _current_item ` , going forwards or backwards depending on ` _from_start `
"
"function setPrice ( uint256 _newPrice ) onlyOwner public { require ( now > 1539561600 ) ; buyBackPrice = _newPrice ; }
","Allow owner to set tokens price for Buy-Back Campaign .
"
"function finished ( ) public { require ( state == State . Successful ) ; uint256 remanent = tokenReward . balanceOf ( this ) ; creator . transfer ( address ( this ) . balance ) ; tokenReward . transfer ( creator , remanent ) ; emit LogBeneficiaryPaid ( creator ) ; emit LogContributorsPayout ( creator , remanent ) ; }
","closure handler
"
"function removeFee ( address stablecoin ) public onlyOwner whenNotPaused { require ( isWhitelisted ( stablecoin ) , ""Stablecoin must be whitelisted prior to setting conversion fee"" ) ; tokenStorage_CD . removeFee ( stablecoin ) ; }
","Remove fees associated with going from CarbonUSD to a particular stablecoin .
"
"function freezeAccount ( address from , bool freeze ) onlyOwner public { frozenAccount [ from ] = freeze ; emit FrozenFunds ( from , freeze ) ; }
","` freeze ?
"
"function getDarknodes ( address _start , uint256 _count ) external view returns ( address [ ] ) { uint256 count = _count ; if ( count == 0 ) { count = numDarknodes ; } return getDarknodesFromEpochs ( _start , count , false ) ; }
","Retrieves a list of darknodes which are registered for the current epoch .
"
"function _cancelSale ( uint256 _tokenId , address _seller ) internal { Sale memory saleItem = tokenIdToSale [ _tokenId ] ; if ( saleItem . tokenIds [ 1 ] != 0 ) { for ( uint ii = 0 ; ii < 9 ; ii ++ ) { _removeSale ( saleItem . tokenIds [ ii ] ) ; _transfer ( address ( this ) , _seller , saleItem . tokenIds [ ii ] ) ; } emit SaleCancelled ( _tokenId , _seller ) ; } else { _removeSale ( _tokenId ) ; _transfer ( address ( this ) , _seller , _tokenId ) ; emit SaleCancelled ( _tokenId , _seller ) ; } }
","Cancels an sale ( given the collectibleID is not 0 ) .
"
"function lock ( address investor , uint256 amount , uint256 neumarks ) public onlyState ( LockState . AcceptingLocks ) onlyController ( ) { require ( amount > 0 ) ; assert ( ASSET_TOKEN . transferFrom ( msg . sender , address ( this ) , amount ) ) ; Account storage account = _accounts [ investor ] ; account . balance = addBalance ( account . balance , amount ) ; account . neumarksDue = add ( account . neumarksDue , neumarks ) ; if ( account . unlockDate == 0 ) { _totalInvestors += 1 ; account . unlockDate = currentTime ( ) + LOCK_PERIOD ; } emit LogFundsLocked ( investor , amount , neumarks ) ; }
","locks funds of investors for a period of time
"
"function setSaleAuctionContractAddress ( address _address ) external onlyOwner { SaleAuction _contract = SaleAuction ( _address ) ; require ( _contract . isSaleAuction ( ) ) ; saleAuctionContract = _contract ; }
","set the contract address of the sale auction .
"
"function restartSale ( ) onlyBy ( owner ) external { isStopped = false ; }
","Restart sale in case of an emergency stop
"
"function emergencyRedeem ( uint shareQuantity , address [ ] requestedAssets ) public pre_cond ( balances [ msg . sender ] >= shareQuantity ) returns ( bool ) { address ofAsset ; uint [ ] memory ownershipQuantities = new uint [ ] ( requestedAssets . length ) ; for ( uint i = 0 ; i < requestedAssets . length ; ++ i ) { ofAsset = requestedAssets [ i ] ; uint assetHoldings = add ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) , quantityHeldInCustodyOfExchange ( ofAsset ) ) ; if ( assetHoldings == 0 ) continue ; ownershipQuantities [ i ] = mul ( assetHoldings , shareQuantity ) / totalSupply ; if ( uint ( AssetInterface ( ofAsset ) . balanceOf ( this ) ) < ownershipQuantities [ i ] ) { isShutDown = true ; ErrorMessage ( ""CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy"" ) ; return false ; } } annihilateShares ( msg . sender , shareQuantity ) ; for ( uint j = 0 ; j < requestedAssets . length ; ++ j ) { ofAsset = requestedAssets [ j ] ; if ( ownershipQuantities [ j ] == 0 ) { continue ; } else if ( ! AssetInterface ( ofAsset ) . transfer ( msg . sender , ownershipQuantities [ j ] ) ) { revert ( ) ; } } Redeemed ( msg . sender , now , shareQuantity ) ; return true ; }
","Redeems by allocating an ownership percentage only of requestedAssets to the participant
"
"function granularity ( ) external view returns ( uint256 ) { return granularity_ ; }
","Returns the granularity
"
"function revealVote ( uint _pollID , uint _voteOption , uint _salt ) public { require ( revealPeriodActive ( _pollID ) ) ; require ( pollMap [ _pollID ] . didCommit [ msg . sender ] ) ; require ( ! pollMap [ _pollID ] . didReveal [ msg . sender ] ) ; require ( keccak256 ( abi . encodePacked ( _voteOption , _salt ) ) == getCommitHash ( msg . sender , _pollID ) ) ; uint numTokens = getNumTokens ( msg . sender , _pollID ) ; if ( _voteOption == 1 ) { pollMap [ _pollID ] . votesFor += numTokens ; } else { pollMap [ _pollID ] . votesAgainst += numTokens ; } dllMap [ msg . sender ] . remove ( _pollID ) ; pollMap [ _pollID ] . didReveal [ msg . sender ] = true ; emit _VoteRevealed ( _pollID , numTokens , pollMap [ _pollID ] . votesFor , pollMap [ _pollID ] . votesAgainst , _voteOption , msg . sender ) ; }
","Reveals vote with choice and secret salt used in generating commitHash to attribute committed tokens
"
"function _forwardFunds ( ) internal { wallet . transfer ( msg . value ) ; }
","Determines how ETH is stored/forwarded on purchases .
"
"function ( ) external payable { uint ethInWei = msg . value ; totalEthInWei = totalEthInWei + ethInWei ; uint perEth = unitsOneEthCanBuy ( ) ; uint256 amount = ethInWei . mul ( perEth ) . div ( 10 ** uint ( 18 - decimals ) ) ; require ( amount > 0 ) ; require ( balances [ fundsWallet ] >= amount ) ; fundsWallet . transfer ( msg . value ) ; bytes memory empty ; processTransfer ( fundsWallet , msg . sender , amount , empty ) ; }
","Accepts payment of eth in exchange for a variable amount of tokens , depending upon the conversion rate of the current sale round .
"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 allowed ) { return allowance [ _owner ] [ _spender ] ; }
","Used to look up allowance of a user
"
"function getExpectedAmount ( bytes32 _requestId ) public view returns ( int256 ) { int256 expectedAmount = requests [ _requestId ] . payee . expectedAmount ; for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { expectedAmount = expectedAmount . add ( subPayees [ _requestId ] [ i ] . expectedAmount ) ; } return expectedAmount ; }
","Gets total expectedAmount of a request .
"
"function setCreateChampFee ( uint256 _fee ) external onlyOwner { createChampFee = _fee ; }
","Change `` CreateChampFee '' .
"
"function cutFor ( address _affiliate , uint256 _productId , uint256 _purchaseId , uint256 _purchaseAmount ) public view returns ( uint256 ) { uint256 rate = rateFor ( _affiliate , _productId , _purchaseId , _purchaseAmount ) ; require ( rate <= hardCodedMaximumRate ) ; return ( _purchaseAmount . mul ( rate ) ) . div ( 10000 ) ; }
","cutFor returns the affiliate cut for a sale
"
"function addBurningMan ( address _burningMan , uint _block ) public returns ( uint _code ) { if ( burningMans [ _burningMan ] ) { return SERVICE_CONTROLLER_BURNING_MAN_EXIST ; } _code = _multisig ( keccak256 ( _burningMan ) , _block ) ; if ( OK != _code ) { return _code ; } burningMans [ _burningMan ] = true ; return OK ; }
","Add burning man
"
"function getBlockNumber ( ) internal constant returns ( uint256 ) { return block . number ; }
","This function is overridden by the test Mocks .
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( now > ICOdeadline && state != State . Successful ) { state = State . Successful ; closedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
","check status
"
"function checkIfFundingCompleteOrExpired ( ) public { if ( state == State . stage1 && now > dateTimeContract . toTimestamp ( 2018 , 5 , 31 , 23 , 59 ) ) { state = State . stage2 ; } else if ( state == State . stage2 && now > dateTimeContract . toTimestamp ( 2018 , 6 , 30 , 23 , 59 ) ) { state = State . stage3 ; } else if ( state == State . stage3 && now > ICOdeadline && state != State . Successful ) { state = State . Successful ; completedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
","check status
"
"function pause ( ) external timedStateChange ( address ( 0 ) , 0 , true ) requiresState ( IcoState . ACTIVE ) onlyowner { changeState ( IcoState . PAUSED ) ; }
","pauses ICO
"
"function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownersTokenCount [ _owner ] ; }
","Returns the number of Warriors ( tokens ) owned by a specific address .
"
"function processPreSale ( address _caller ) private { var ( allowedContribution , refundAmount ) = processContribution ( ) ; assert ( msg . value == allowedContribution . add ( refundAmount ) ) ; if ( allowedContribution > 0 ) { doBuy ( _caller , allowedContribution ) ; if ( refundAmount > 0 ) { msg . sender . transfer ( refundAmount ) ; closePreSale ( ) ; } uint256 tillCap = remainingCap ( ) ; if ( tillCap == 0 ) { closePreSale ( ) ; } } else { revert ( ) ; } }
","Processes the presale if the allowed contribution is more than zero
"
"function _isApprovedForAll ( address _owner , address _operator ) internal view returns ( bool ) { return _operatorApprovals [ _owner ] [ _operator ] ; }
","Query if an address is an authorized operator for another address
"
"function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) ;
","Send ` _amount ` tokens to ` _to ` from ` _from ` on the condition it is approved by ` _from `
"
"function assetPrices ( address asset ) public view returns ( uint ) { if ( paused ) { return 0 ; } else { return _assetPrices [ asset ] . mantissa ; } }
","retrieves price of an asset
"
"function withdrawSynthetix ( uint quantity ) external onlyOwner onlyDuringSetup { synthetix . transfer ( synthetix , quantity ) ; }
","Withdraws a quantity of SNX back to the synthetix contract .
"
"function isValidator ( ) external view returns ( bool ) ;
","Check if contract is assigned as a validator on the jurisdiction .
"
"function withdrawCommission ( uint _amount ) public onlyOwner { require ( _amount <= availableCommission ) ; availableCommission = availableCommission . sub ( _amount ) ; msg . sender . transfer ( _amount ) ; }
","ability for owner to withdraw the commission
"
"function getApproved ( uint256 _tokenId ) public view returns ( address ) ;
","Get the approved address for a single NFT
"
"function getModulesByName ( bytes32 _name ) external view returns ( address [ ] ) { return names [ _name ] ; }
","Returns a list of modules that match the provided name
"
"function setPreferredCurrency ( address account , bytes4 currencyKey ) external onlyAssociatedContract { preferredCurrency [ account ] = currencyKey ; }
","Set preferred currency for a user
"
"function getMinerHalving ( ) public constant returns ( uint256 ) { return getHalvingOf ( msg . sender ) ; }
","Return the miner halving ( starting halving or last claimed )
"
"function changeFactorySetupFee ( uint256 _newSetupCost ) external ;
","Used to change the setup fee
"
"function symbol ( ) external view returns ( string ) ;
","An abbreviated name for NFTs in this contract
"
"function setFunding ( uint _to ) returns ( bool _success ) ;
","Function used to set the funding limits for partners
"
"function setBuyPrices ( uint256 newBuyPrice ) onlyOwner public { buyPrice = newBuyPrice ; }
","Allow users to buy tokens for ` newBuyPrice ` eth
"
"function swap ( address requester , string symbolA , string symbolB , uint valueA , uint valueB , uint8 sigV , bytes32 sigR , bytes32 sigS , uint expiration ) public returns ( bool success ) { require ( lib . execSwap ( requester , symbolA , symbolB , valueA , valueB , sigV , sigR , sigS , expiration ) , ""Error: Unable to perform atomic currency swap. Please check parameters."" ) ; return true ; }
","Accepts a signed fx request to swap currency pairs at a given amount ;
"
"function cloneProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument , uint _dateOfProposal , uint _orderAmount , uint _dateOfOrder , bool _cloneOrder ) returns ( bool success ) { if ( smartContractStartDate != 0 || recipient == 0 || msg . sender != creator ) throw ; uint _proposalID = proposals . length ++ ; proposal c = proposals [ _proposalID ] ; c . amount = _amount ; c . description = _description ; c . hashOfTheDocument = _hashOfTheDocument ; c . dateOfProposal = _dateOfProposal ; c . orderAmount = _orderAmount ; c . dateOfLastOrder = _dateOfOrder ; ProposalAdded ( msg . sender , _proposalID , _amount , _description , _hashOfTheDocument ) ; if ( _cloneOrder ) passProject . cloneOrder ( address ( this ) , _proposalID , _orderAmount , _dateOfOrder ) ; return true ; }
","Function to clone a proposal from the last contractor
"
"function name ( ) public view returns ( string _name ) { return lib . getTokenName ( address ( this ) ) ; }
","Gets name of token
"
"function getTitle ( ) public view returns ( string ) { return ""ERC20 Dividend Checkpoint"" ; }
","Get the title of the Module
"
"function addRecipient ( address addr ) onlyOwner external { require ( recipients . length < MAX_RECIPIENTS , ""Too many recipients"" ) ; recipients . push ( addr ) ; }
","Add a recipient to the list
"
"function deedsOfOwner ( address _owner ) external view returns ( uint256 [ ] ) { uint256 deedCount = countOfDeedsByOwner ( _owner ) ; if ( deedCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( deedCount ) ; uint256 totalDeeds = countOfDeeds ( ) ; uint256 resultIndex = 0 ; for ( uint256 deedNumber = 0 ; deedNumber < totalDeeds ; deedNumber ++ ) { uint256 identifier = identifiers [ deedNumber ] ; if ( identifierToOwner [ identifier ] == _owner ) { result [ resultIndex ] = identifier ; resultIndex ++ ; } } return result ; } }
","Returns a list of all deed identifiers assigned to an address .
"
"function validInitialBuyoutPrice ( uint256 _deedId , uint256 price ) public view returns ( bool ) { return ( price >= unclaimedPlotPrice && price <= maximumInitialBuyoutPrice ( _deedId ) ) ; }
","Test whether a buyout price is valid .
"
"function approve ( address _spender , uint256 _value ) public canTransfer ( msg . sender ) returns ( bool ) { require ( _spender != address ( 0 ) , ""Invalid address."" ) ; return super . approve ( _spender , _value ) ; }
","Approves a wallet address to spend on behalf of the sender .
"
"function owner ( ) public view returns ( address ) { return getAddress ( Encoder . getKey ( ""owner"" ) ) ; }
","Gets the owner of the contract
"
"function userEndGame ( uint32 _roundId , int _balance , bytes32 _serverHash , bytes32 _userHash , uint _gameId , address _contractAddress , bytes _serverSig ) public { verifySig ( _roundId , 0 , 0 , 0 , _balance , _serverHash , _userHash , _gameId , _contractAddress , _serverSig , serverAddress ) ; regularEndGame ( msg . sender , _roundId , _balance , _gameId , _contractAddress ) ; }
","Regular end game session .
"
"function unlock ( ) external { if ( block . number < unlockedAtBlockNumber ) throw ; if ( ! lunyrToken . transfer ( lunyrMultisig , lunyrToken . balanceOf ( this ) ) ) throw ; }
","Transfer locked tokens to Lunyr 's multisig wallet
"
"function increaseApprovalPreSignedHashing ( address _token , address _spender , uint256 _addedValue , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( 0xa45f71ff ) , _token , _spender , _addedValue , _fee , _nonce ) ; }
","Hash ( keccak256 ) of the payload used by increaseApprovalPreSigned
"
"function totalSupply ( ) external view returns ( uint ) { return core . getTokenCount ( tokenIsChamp ) ; }
","Count NFTs tracked by this contract
"
"function clearFund ( uint256 _gameID ) external isHuman ( ) isEnded ( _gameID ) isOwner ( ) { require ( now >= game_ [ _gameID ] . withdrawDeadline , ""withdraw deadline not passed yet"" ) ; require ( gameStatus_ [ _gameID ] . fundCleared == false , ""fund already cleared"" ) ; gameStatus_ [ _gameID ] . fundCleared = true ; uint256 _totalPot = ( gameStatus_ [ _gameID ] . winningVaultInst ) . add ( gameStatus_ [ _gameID ] . winningVaultFinal ) ; uint256 _amount = _totalPot . sub ( gameStatus_ [ _gameID ] . totalWithdrawn ) ; if ( _amount > 0 ) { FSKingCorp . deposit . value ( _amount ) ( ) ; } emit onFundCleared ( _gameID , _amount , now ) ; }
","Clear funds of a game .
"
"function tokensOf ( address owner ) public view returns ( uint256 [ ] ) { return _assetsOf [ owner ] ; }
","Get all tokens of a given address
"
"function setMinBalanceForContractCreation ( uint minBalance ) external onlyOwner { minBalanceToAllowContractCreation = minBalance ; }
","allows the creator to set minimum balance a user must have in order to create MarketContracts
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }
","Allows ` _spender ` to spend no more than ` _value ` tokens in your behalf
"
"function transferForAdmin ( address token , address account , uint256 amount ) onlyAdmin external { require ( tokenAddress2Id [ token ] != 0 ) ; require ( userAddress2Id [ msg . sender ] != 0 ) ; addUser ( account ) ; balances [ token ] [ msg . sender ] = balances [ token ] [ msg . sender ] . sub ( amount ) ; balances [ token ] [ account ] = balances [ token ] [ account ] . add ( amount ) ; }
","transfer token from admin to users
"
"function expiry ( ) public constant returns ( uint256 blockNumber ) { }
","the block number at which the campaign fails or succeeds
"
"function unpause ( ) external whenPaused onlyOwner { set ( Encoder . getKey ( ""paused"" ) , false ) ; emit Unpause ( now ) ; }
","Called by the owner to unpause , returns to normal state
"
"function setFee ( address _stablecoin , uint256 _fee ) public onlyOwner { uint256 oldFee = fees [ _stablecoin ] ; fees [ _stablecoin ] = _fee ; if ( oldFee != _fee ) emit FeeChanged ( _stablecoin , oldFee , _fee ) ; }
","Set a fee for burning CarbonDollar into a stablecoin .
"
"function freezeAccount ( address _target , bool _freeze ) public onlyOwner { frozenAccount [ _target ] = _freeze ; emit FrozenFunds ( _target , _freeze ) ; }
","` freeze ?
"
"function getInstructions ( ) external view returns ( string ) { return ""Create a dividend which will be paid out to token holders proportionally according to their balances at the point the dividend is created"" ; }
","Returns the instructions associated with the module
"
"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }
","If this function is called again it overwrites the current allowance with _amount .
"
"function name ( ) public pure returns ( string _deedName ) { _deedName = ""MetaGame"" ; }
","Name of the collection of deeds ( non-fungible token ) , as defined in ERC721Metadata .
"
"function setTierRates ( uint256 tier1 , uint256 tier2 , uint256 tier3 , uint256 tier4 ) external onlyOwner whenNotPaused { require ( tier1 > 0 && tier2 > 0 && tier3 > 0 && tier4 > 0 ) ; require ( tier1 > tier2 && tier2 > tier3 && tier3 > tier4 ) ; rate = tier1 ; rateTier2 = tier2 ; rateTier3 = tier3 ; rateTier4 = tier4 ; }
","Set 's the rate of tokens per ether for each tier .
"
"function getTagsByType ( uint8 _moduleType ) external view returns ( bytes32 [ ] , address [ ] ) ;
","Returns all the tags related to the a module type which are valid for the given token
"
"function ownerWithdraw ( uint256 value ) external onlyOwner { if ( totalFunding >= PRESALE_MAXIMUM_FUNDING ) { owner . transfer ( value ) ; saleHasEnded = true ; } else { require ( now >= PRESALE_END_DATE ) ; require ( totalFunding >= PRESALE_MINIMUM_FUNDING ) ; owner . transfer ( value ) ; } }
","The owner can withdraw ethers after the presale has completed , only if the minimum funding level has been reached
"
"function changeOwner ( address _newOwner ) public onlyOwner { owner = _newOwner ; }
","` owner ` can step down and assign some other address to this role
"
"function deedUri ( uint256 _deedId ) external view returns ( string _deedUri ) ;
","A distinct URI ( RFC 3986 ) for a given token .
"
"function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { require ( state == State . Successful ) ; uint256 remainder = _address . balanceOf ( address ( this ) ) ; _address . transfer ( msg . sender , remainder ) ; }
","Function to claim any token stuck on contract
"
"function getVote ( uint _idPoll , address _voter ) public view returns ( uint [ 100 ] votes ) { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll storage p = _polls [ _idPoll ] ; for ( uint8 i = 0 ; i < p . numBallots ; i ++ ) { votes [ i ] = p . ballots [ i ] [ _voter ] ; } return votes ; }
","Get votes for poll/ballot
"
"function makeOffer ( uint256 _tokenId , uint8 _v , bytes32 _r , bytes32 _s ) public notHalted ( ) payable { address recoveredSigner = verify ( keccak256 ( msg . sender ) , _v , _r , _s ) ; require ( signers [ recoveredSigner ] == true ) ; require ( msg . sender != address ( 0 ) ) ; require ( msg . value > 0 ) ; uint256 currentPrice = getTokenPrice ( _tokenId ) ; require ( currentPrice > 0 ) ; if ( _tokenId == logoId && token . getCurrentPriceForToken ( _tokenId ) == 0 ) { require ( msg . value >= logoPrice ) ; token . updateTokensState ( logoId , msg . value ) ; erc20token . mint ( msg . sender , 100 ) ; transferEthers ( platformWallet , msg . value ) ; emit Purchased ( 0 , msg . sender , _tokenId , msg . value , 0 , 0 , msg . value , now ) ; return ; } uint256 minPrice = pricingStrategy . calculateMinPriceForNextRound ( currentPrice , minResalePercentage ) ; require ( msg . value >= minPrice ) ; uint256 offerCounter = offers . length ; offers . push ( Offer ( _tokenId , offerCounter , msg . sender , msg . value , currentPrice , false , now ) ) ; emit OfferMade ( msg . sender , _tokenId , offerCounter , msg . value , now ) ; approve ( offerCounter , _tokenId ) ; }
","allow user to make an offer after initial phase ( re-sale ) any offer minResalePercentage is accepted automatically
"
"function setMaxGas ( uint256 _maxGas , uint256 _penalty ) public onlyOwner beforeSale { maxGasPrice = _maxGas ; maxGasPricePenalty = _penalty ; }
","Sets max gas price and penalty before sale
"
"function performBuyOrder_ ( OrderData data ) public payable onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { uint256 amountToGiveForOrder = toUint ( msg . data , msg . data . length - 32 ) ; approveAddress ( ERC20_ASSET_PROXY , toAddress ( data . takerAssetData , 16 ) ) ; weth . deposit . value ( amountToGiveForOrder ) ( ) ; LibFillResults . FillResults memory results = exchange . fillOrder ( getZeroExOrder ( data ) , amountToGiveForOrder , data . signature ) ; require ( ERC20SafeTransfer . safeTransfer ( toAddress ( data . makerAssetData , 16 ) , totlePrimary , results . makerAssetFilledAmount ) ) ; amountSpentOnOrder = results . takerAssetFilledAmount ; amountReceivedFromOrder = results . makerAssetFilledAmount ; }
","Perform a buy order at the exchange
"
"function transferFrom ( address _from , address _to , uint256 _value ) public onlyIfLockTimePassed returns ( bool ) { require ( _from != 0x0 ) ; require ( _to != 0x0 ) ; require ( _to != address ( this ) ) ; require ( balances [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( balances [ _to ] . add ( _value ) >= balances [ _to ] ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }
","Transfer ` _value ` tokens from ` _from ` to ` _to ` if ` msg.sender ` is allowed .
"
"function changeOwnership ( bytes32 _symbol , address _newOwner ) public onlyOwner ( _symbol ) returns ( uint ) { if ( _newOwner == 0x0 ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_INVALID_NEW_OWNER ) ; } uint newOwnerId = _createHolderId ( _newOwner ) ; uint assetOwner = _assetOwner ( _symbol ) ; if ( assetOwner == newOwnerId ) { return _emitErrorCode ( CHRONOBANK_PLATFORM_CANNOT_APPLY_TO_ONESELF ) ; } address oldOwner = _address ( assetOwner ) ; set ( store , assetOwnerIdStorage , _symbol , newOwnerId ) ; _emitter ( ) . emitOwnershipChange ( oldOwner , _newOwner , _symbol ) ; return OK ; }
","Passes asset ownership to specified address .
"
"function getJurisdiction ( ) external view returns ( address ) ;
","Get account of utilized jurisdiction and associated attribute registry managed by the jurisdiction .
"
"function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) , ""0x0 Is not a valid owner"" ) ; require ( _index < _balanceOf ( _owner ) , ""Index out of bounds"" ) ; return _assetsOf [ _owner ] [ _index ] ; }
","Enumerate NFTs assigned to an owner
"
"function redeemChannel ( bytes32 channelId , bytes32 secret ) public { require ( sha256 ( abi . encodePacked ( secret ) ) == channels [ channelId ] . hashedSecret , ""WRONG_SECRET"" ) ; require ( channels [ channelId ] . state == State . Created , ""WRONG_STATE"" ) ; uint amount = channels [ channelId ] . amount ; address beneficiary = channels [ channelId ] . beneficiary ; channels [ channelId ] . state = State . Redeemed ; beneficiary . transfer ( amount ) ; emit ChannelRedeemed ( channelId ) ; }
","Redeem ETH to channel beneficiary and and set channel state as redeemed .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool _success ) ;
","Transfers ` _value ` amount of tokens to address ` _to ` .
"
"function safeTransfer ( address token , address to , uint256 amount ) internal { CompatibleERC20 ( token ) . transfer ( to , amount ) ; require ( previousReturnValue ( ) , ""transfer failed"" ) ; }
","Calls transfer on the token and reverts if the call fails .
"
"function allocateInvestors ( ) public onlyController { require ( ( campaignState == 1 ) || ( ( campaignState != 0 ) && ( now > tCampaignEnd + ( 2880 minutes ) ) ) ) ; uint256 nTokens = 0 ; uint256 rate = 0 ; uint256 contributedAmount = 0 ; uint256 investorsProcessedEnd = investorsProcessed + investorsBatchSize ; if ( investorsProcessedEnd > joinedCrowdsale . length ) { investorsProcessedEnd = joinedCrowdsale . length ; } for ( uint256 i = investorsProcessed ; i < investorsProcessedEnd ; i ++ ) { investorsProcessed ++ ; address investorAddress = joinedCrowdsale [ i ] ; contributedAmount = participantList [ investorAddress ] . contributedAmountPreCrowd ; if ( isWhiteListed ) { if ( contributedAmount > participantWhitelist [ investorAddress ] . maxCap ) { contributedAmount = participantWhitelist [ investorAddress ] . maxCap ; } if ( contributedAmount > 0 ) { participantWhitelist [ investorAddress ] . maxCap = participantWhitelist [ investorAddress ] . maxCap . sub ( contributedAmount ) ; } } if ( contributedAmount > 0 ) { rate = preCrowd_tokens_scaled ; nTokens = ( rate . mul ( contributedAmount ) ) . div ( 1 ether ) ; if ( nTokens > maxPreCrowdAllocationPerInvestor ) { nTokens = maxPreCrowdAllocationPerInvestor ; } if ( tokensRemainingPreCrowd . sub ( nTokens ) < 0 ) { nTokens = tokensRemainingPreCrowd ; } participantList [ joinedCrowdsale [ i ] ] . spentAmount = participantList [ joinedCrowdsale [ i ] ] . spentAmount . add ( nTokens . div ( rate ) . mul ( 1 ether ) ) ; tokensRemainingPreCrowd = tokensRemainingPreCrowd . sub ( nTokens ) ; participantList [ investorAddress ] . allocatedTokens = participantList [ investorAddress ] . allocatedTokens . add ( nTokens ) ; } contributedAmount = participantList [ investorAddress ] . contributedAmountStage1 ; if ( isWhiteListed ) { if ( contributedAmount > participantWhitelist [ investorAddress ] . maxCap ) { contributedAmount = participantWhitelist [ investorAddress ] . maxCap ; } if ( contributedAmount > 0 ) { participantWhitelist [ investorAddress ] . maxCap = participantWhitelist [ investorAddress ] . maxCap . sub ( contributedAmount ) ; } } if ( contributedAmount > 0 ) { rate = stage_1_tokens_scaled ; nTokens = ( rate . mul ( contributedAmount ) ) . div ( 1 ether ) ; if ( nTokens > maxStage1AllocationPerInvestor ) { nTokens = maxStage1AllocationPerInvestor ; } if ( tokensRemainingStage1 . sub ( nTokens ) < 0 ) { nTokens = tokensRemainingStage1 ; } participantList [ joinedCrowdsale [ i ] ] . spentAmount = participantList [ joinedCrowdsale [ i ] ] . spentAmount . add ( nTokens . div ( rate ) . mul ( 1 ether ) ) ; tokensRemainingStage1 = tokensRemainingStage1 . sub ( nTokens ) ; participantList [ investorAddress ] . allocatedTokens = participantList [ investorAddress ] . allocatedTokens . add ( nTokens ) ; } contributedAmount = participantList [ investorAddress ] . contributedAmountStage2 ; if ( isWhiteListed ) { if ( contributedAmount > participantWhitelist [ investorAddress ] . maxCap ) { contributedAmount = participantWhitelist [ investorAddress ] . maxCap ; } if ( contributedAmount > 0 ) { participantWhitelist [ investorAddress ] . maxCap = participantWhitelist [ investorAddress ] . maxCap . sub ( contributedAmount ) ; } } if ( contributedAmount > 0 ) { rate = stage_2_tokens_scaled ; nTokens = ( rate . mul ( contributedAmount ) ) . div ( 1 ether ) ; if ( nTokens > maxStage2AllocationPerInvestor ) { nTokens = maxStage2AllocationPerInvestor ; } if ( tokensRemainingStage2 . sub ( nTokens ) < 0 ) { nTokens = tokensRemainingStage2 ; } participantList [ joinedCrowdsale [ i ] ] . spentAmount = participantList [ joinedCrowdsale [ i ] ] . spentAmount . add ( nTokens . div ( rate ) . mul ( 1 ether ) ) ; tokensRemainingStage2 = tokensRemainingStage2 . sub ( nTokens ) ; participantList [ investorAddress ] . allocatedTokens = participantList [ investorAddress ] . allocatedTokens . add ( nTokens ) ; } contributedAmount = participantList [ investorAddress ] . contributedAmountStage3 ; if ( isWhiteListed ) { if ( contributedAmount > participantWhitelist [ investorAddress ] . maxCap ) { contributedAmount = participantWhitelist [ investorAddress ] . maxCap ; } if ( contributedAmount > 0 ) { participantWhitelist [ investorAddress ] . maxCap = participantWhitelist [ investorAddress ] . maxCap . sub ( contributedAmount ) ; } } if ( contributedAmount > 0 ) { rate = stage_3_tokens_scaled ; nTokens = ( rate . mul ( contributedAmount ) ) . div ( 1 ether ) ; if ( nTokens > maxStage3AllocationPerInvestor ) { nTokens = maxStage3AllocationPerInvestor ; } if ( tokensRemainingStage3 . sub ( nTokens ) < 0 ) { nTokens = tokensRemainingStage3 ; } participantList [ joinedCrowdsale [ i ] ] . spentAmount = participantList [ joinedCrowdsale [ i ] ] . spentAmount . add ( nTokens . div ( rate ) . mul ( 1 ether ) ) ; tokensRemainingStage3 = tokensRemainingStage3 . sub ( nTokens ) ; participantList [ investorAddress ] . allocatedTokens = participantList [ investorAddress ] . allocatedTokens . add ( nTokens ) ; } do_grant_tokens ( investorAddress , participantList [ investorAddress ] . allocatedTokens ) ; } }
","Finalizes the campaign Get funds out , generates team , reserve and reserve tokens
"
"function bringKydyHome ( uint256 _yinId ) external whenNotPaused returns ( uint256 ) { Kydy storage yin = kydys [ _yinId ] ; require ( yin . createdTime != 0 ) ; require ( _isReadyToBringKydyHome ( yin ) ) ; uint256 yangId = yin . synthesizingWithId ; Kydy storage yang = kydys [ yangId ] ; uint16 parentGen = yin . generation ; if ( yang . generation > yin . generation ) { parentGen = yang . generation ; } uint256 childGenes = geneSynthesis . synthGenes ( yin . genes , yang . genes ) ; address owner = kydyIndexToOwner [ _yinId ] ; uint256 kydyId = _createKydy ( _yinId , yin . synthesizingWithId , parentGen + 1 , childGenes , owner ) ; delete yin . synthesizingWithId ; creatingKydys -- ; msg . sender . transfer ( autoCreationFee ) ; return kydyId ; }
","Let 's bring the new Kydy to it 's home !
"
"function closePreSignedHashing ( address _investContract , bytes32 _strategyID ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0xc95bd3aa ) , _investContract , _strategyID ) ) ; }
","Hash ( keccak256 ) of the payload used by closeTradeProfile
"
"function updatePollDescription ( uint _idPoll , bytes _description , uint8 _numBallots ) public { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; require ( _numBallots <= 15 , ""Only a max of 15 ballots are allowed"" ) ; Poll storage p = _polls [ _idPoll ] ; require ( p . startBlock > block . number , ""You cannot modify an active poll"" ) ; require ( p . author == msg . sender || msg . sender == controller , ""Only the owner/controller can modify the poll"" ) ; p . numBallots = _numBallots ; p . description = _description ; p . author = msg . sender ; }
","Update poll description ( title or ballots ) as long as it has n't started
"
"function signOut ( address _contract ) external onlyContractOwner returns ( uint ) { require ( _contract != 0x0 ) ; delete authorized [ _contract ] ; return OK ; }
","Sign out contract
"
"function frozenCell ( address owner , uint index ) public view returns ( uint amount , uint thawTS , bool isKYCRequired ) { require ( index < frozenCellCount ( owner ) ) ; amount = frozenBalances [ owner ] [ index ] . amount ; thawTS = uint ( frozenBalances [ owner ] [ index ] . thawTS ) ; isKYCRequired = decodeKYCFlag ( frozenBalances [ owner ] [ index ] . isKYCRequired ) ; }
","Retrieves information about account frozen tokens .
"
"function addValidatorApproval ( address validator , uint256 attributeTypeID ) external onlyOwner whenNotPaused { require ( isValidator ( validator ) && isAttributeType ( attributeTypeID ) , ""must specify both a valid attribute and an available validator"" ) ; require ( ! _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] , ""validator is already approved on the provided attribute"" ) ; _attributeTypes [ attributeTypeID ] . approvedValidators [ validator ] = true ; uint256 index = _validatorApprovals [ validator ] . length ; _validatorApprovalsIndex [ validator ] [ attributeTypeID ] = index ; _validatorApprovals [ validator ] . push ( attributeTypeID ) ; emit ValidatorApprovalAdded ( validator , attributeTypeID ) ; }
","Approve the validator at address ` validator ` to issue attributes of the type with ID ` attributeTypeID ` .
"
"function approve ( address _to , uint256 _tokenId ) public onlyERC721 { require ( _owns ( msg . sender , _tokenId ) ) ; politicianIndexToApproved [ _tokenId ] = _to ; Approval ( msg . sender , _to , _tokenId ) ; }
","Grant another address the right to transfer token via takeOwnership ( ) and transferFrom ( ) .
"
"function unpause ( ) public onlyCEO whenPaused { require ( ethernautsStorage != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; require ( ethernautsStorage . contractsGrantedAccess ( address ( this ) ) == true ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function deleteAddress ( bytes32 _key ) public onlyOwner returns ( bool success ) { delete addressStorage [ _key ] ; return true ; }
","Delete value for Address associated with bytes32 id key
"
"function clearTrade ( bytes _signature , address _trader , bytes32 _strategyID , address _follower , uint256 _investedAmount , int256 _profitAmount , string _causeToClear ) public returns ( bool ) { require ( traderProfile [ _trader ] [ _strategyID ] != address ( 0 ) ) ; TradeProfile profile = TradeProfile ( traderProfile [ _trader ] [ _strategyID ] ) ; if ( msg . sender != bincentive ) { require ( profile . startTimeOf ( _follower ) + profile . periodLength ( ) <= now ) ; } bytes32 hashedTx = ECRecovery . toEthSignedMessageHash ( clearTradePreSignedHashing ( address ( this ) , _trader , _strategyID , _follower , _investedAmount , _profitAmount , _causeToClear ) ) ; address from = ECRecovery . recover ( hashedTx , _signature ) ; uint256 amountToTrader ; uint256 amountToFollower ; ( amountToTrader , amountToFollower ) = profile . clear ( _follower , from , _profitAmount ) ; marginBalances [ _trader ] = marginBalances [ _trader ] . add ( amountToTrader ) ; marginBalances [ _follower ] = marginBalances [ _follower ] . add ( amountToFollower ) ; emit ClearTrade ( _follower , _trader , _investedAmount , _profitAmount , _causeToClear ) ; return true ; }
","Clear a following trade
"
"function totalSupplyAt ( uint256 _checkpointId ) external view returns ( uint256 ) { require ( _checkpointId <= currentCheckpointId ) ; return TokenLib . getValueAt ( checkpointTotalSupply , _checkpointId , totalSupply ( ) ) ; }
","Queries totalSupply as of a defined checkpoint
"
"function platformLogin ( ) userNotBanned ( msg . sender ) external { cooldown [ msg . sender ] = 0 ; cooldown [ msg . sender ] -= 1 ; }
","Freeze user during platform use - Backend Function
"
"function withdrawalList ( uint256 [ ] memory loanIds , address to ) public returns ( uint256 ) { uint256 inputId ; uint256 totalWithdraw = 0 ; for ( inputId = 0 ; inputId < loanIds . length ; inputId ++ ) { Loan storage loan = loans [ loanIds [ inputId ] ] ; if ( loan . lender == msg . sender ) { totalWithdraw += loan . lenderBalance ; loan . lenderBalance = 0 ; } } require ( rcn . transfer ( to , totalWithdraw ) ) ; unlockTokens ( rcn , totalWithdraw ) ; return totalWithdraw ; }
","Withdraw lender funds in batch , it walks by all the loans passed to the function and withdraws all the funds stored on that loans .
"
"function transferFrom ( address _from , address _to , uint256 _amount ) stopOnPause public returns ( bool success ) { require ( _from != 0x0 ) ; require ( allowance ( _from , msg . sender ) >= _amount ) ; bytes memory empty ; allowed [ _from ] [ msg . sender ] = allowance ( _from , msg . sender ) . sub ( _amount ) ; assert ( _transfer ( _from , _to , _amount , empty ) ) ; emit Transfer ( _from , _to , _amount , empty ) ; return true ; }
","Transfers ` _amount ` from ` _from ` to ` _to ` with additional data .
"
"function addAdministrators ( address _adminAddress ) onlyOwner { administrators [ _adminAddress ] = true ; AdminstratorAdded ( _adminAddress ) ; }
","Add an administrator
"
"function approvePayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( msg . sender != arbitrator ) { require ( job . manager == msg . sender ) ; require ( job . proofOfLastWorkVerified == true ) ; } require ( job . noOfTotalPayments > job . noOfPaymentsMade ) ; uint currentPayment = job . salaryDeposited . div ( job . noOfTotalPayments ) ; job . paymentAvailableForWorker = job . paymentAvailableForWorker + currentPayment ; job . totalPaidToWorker = job . totalPaidToWorker + currentPayment ; job . noOfPaymentsMade ++ ; if ( job . noOfTotalPayments == job . noOfPaymentsMade ) { job . status = JobStatus . Completed ; } emit PaymentApproved ( msg . sender , _JobID , currentPayment ) ; }
","this function lets the manager to approve payment
"
"function totalSupply ( ) public constant returns ( uint256 ) { return totalSupply_ - balances [ address ( 0 ) ] ; }
","Total supply
"
"function refundTokens ( address _from , uint256 _amount ) public notTimeLocked stopInEmergency returns ( bool success ) { if ( tx . origin != _from ) { error ( 'refundTokens: tx.origin did not request the refund directly' ) ; return false ; } if ( addressSCICO != msg . sender ) { error ( 'refundTokens: caller is not the current ICO address' ) ; return false ; } if ( balances [ _from ] < _amount ) { error ( 'refundTokens: the amount to transfer is higher than your token balance' ) ; return false ; } if ( ! SCComplianceService . validate ( _from , addressSCICO , _amount ) ) { error ( 'transfer: not allowed by the compliance service' ) ; return false ; } balances [ _from ] = balances [ _from ] . sub ( _amount ) ; balances [ addressSCICO ] = balances [ addressSCICO ] . add ( _amount ) ; emit Transfer ( _from , addressSCICO , _amount ) ; return true ; }
","Send _amount amount of tokens to from tx.origin to address _to
"
"function batchApprove ( address [ ] spenders , uint [ ] quantities ) external pausableIfNotSelfDestructing requireSameLength ( spenders . length , quantities . length ) returns ( bool ) { uint length = spenders . length ; for ( uint i = 0 ; i < length ; i ++ ) { approve ( spenders [ i ] , quantities [ i ] ) ; } return true ; }
","Performs ERC20 approvals in batches ; for each ` i ` , approves ` quantities [ i ] ` tokens to be spent by ` spenders [ i ] ` on behalf of the message sender .
"
"function canAddAttribute ( uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee , bytes signature ) external view returns ( bool ) { bytes32 hash = calculateAttributeApprovalHash ( msg . sender , address ( 0 ) , attributeTypeID , value , fundsRequired , validatorFee ) ; address signingKey = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; address validator = _signingKeys [ signingKey ] ; uint256 minimumStake = _attributeTypes [ attributeTypeID ] . minimumStake ; uint256 jurisdictionFee = _attributeTypes [ attributeTypeID ] . jurisdictionFee ; return ( fundsRequired >= minimumStake . add ( jurisdictionFee ) . add ( validatorFee ) && ! _invalidAttributeApprovalHashes [ hash ] && canValidate ( validator , attributeTypeID ) && ! _issuedAttributes [ msg . sender ] [ attributeTypeID ] . exists ) ; }
","Check if a given signed attribute approval is currently valid when submitted directly by ` msg.sender ` .
"
"function sendTo ( address _recipient , uint _amount ) external onlyClient returns ( bool ) { if ( _recipient . send ( _amount ) ) return true ; else return false ; }
","Function used by the client to send ethers
"
"function changeCommission ( uint _newCommission ) public onlyOwner whenNotPaused { require ( _newCommission <= MAX_COMMISION ) ; require ( _newCommission != commission ) ; commission = _newCommission ; emit NewCommission ( commission ) ; }
","ability for owner to change the service commmission
"
"function deedOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _deedId ) ;
","Enumerate deeds assigned to an owner
"
"function setupVote ( uint motionID ) internal returns ( uint ) { require ( motionVoting ( motionID ) ) ; require ( ! hasVoted ( msg . sender , motionID ) ) ; require ( msg . sender != motionTarget [ motionID ] ) ; uint weight = havven . recomputeLastAverageBalance ( msg . sender ) ; require ( weight > 0 ) ; voteWeight [ msg . sender ] [ motionID ] = weight ; return weight ; }
","Shared vote setup function between voteFor and voteAgainst .
"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { var senderBalance = balances [ msg . sender ] ; if ( senderBalance >= _value && _value > 0 ) { senderBalance -= _value ; balances [ msg . sender ] = senderBalance ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }
","This function is disabled during the funding .
"
"function getTime ( ) internal returns ( uint ) { return now ; }
","Basic helper function to return the current time
"
"function initializeToken ( address _cnd ) public onlyController { assert ( CND ( _cnd ) . controller ( ) == address ( this ) ) ; assert ( CND ( _cnd ) . IS_CND_CONTRACT_MAGIC_NUMBER ( ) == 0x1338 ) ; require ( _cnd != 0x0 ) ; cnd = CND ( _cnd ) ; }
","Initializes CND token to contribution
"
"function transferFrom ( address _from , address _to , uint256 _value ) external noFreeze { var _allowance = allowed [ _from ] [ _to ] ; if ( _from == selfAddress ) { monthlyLimit [ _to ] = safeSub ( monthlyLimit [ _to ] , _value ) ; require ( cooldown [ _to ] < now ) ; IOUSupply -= _value ; } balances [ _to ] = balances [ _to ] + _value ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; allowed [ _from ] [ _to ] = safeSub ( _allowance , _value ) ; addUser ( _to ) ; Transfer ( _from , _to , _value ) ; }
","Transfer tokens from an address to another ~ ERC-20 Standard
"
"function release ( ) public { require ( now >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . safeTransfer ( beneficiary , amount ) ; }
","Transfers tokens held by timelock to beneficiary .
"
"function calculateInterest ( uint256 timeDelta , uint256 interestRate , uint256 amount ) internal pure returns ( uint256 realDelta , uint256 interest ) { if ( amount == 0 ) { interest = 0 ; realDelta = timeDelta ; } else { interest = safeMult ( safeMult ( 100000 , amount ) , timeDelta ) / interestRate ; realDelta = safeMult ( interest , interestRate ) / ( amount * 100000 ) ; } }
","Calculates the interest of a given amount , interest rate and delta time .
"
"function setOraclizeTimeTolerance ( uint256 _oraclizeTimeTolerance ) onlyOwner public { oraclizeTimeTolerance = _oraclizeTimeTolerance ; }
","Allows owner to set new time tolerance on Oraclize queries
"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( balances [ msg . sender ] >= _value ) { approved [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; } return false ; }
","Approve ` _value ` tokens for ` _spender `
"
"function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) ) ; }
","Introspection interface as per ERC-165 ( https : //github.com/ethereum/EIPs/issues/165 ) .
"
"function modifySecurityToken ( string _name , string _ticker , address _owner , address _securityToken , string _tokenDetails , uint256 _deployedAt ) external onlyOwner { require ( bytes ( _name ) . length > 0 && bytes ( _ticker ) . length > 0 , ""String length > 0"" ) ; require ( bytes ( _ticker ) . length <= 10 , ""Ticker length range (0,10]"" ) ; require ( _deployedAt != 0 && _owner != address ( 0 ) , ""0 value params not allowed"" ) ; string memory ticker = Util . upper ( _ticker ) ; require ( _securityToken != address ( 0 ) , ""ST address is 0x"" ) ; uint256 registrationTime = getUint ( Encoder . getKey ( ""registeredTickers_registrationDate"" , ticker ) ) ; uint256 expiryTime = getUint ( Encoder . getKey ( ""registeredTickers_expiryDate"" , ticker ) ) ; if ( registrationTime == 0 ) { registrationTime = now ; expiryTime = registrationTime . add ( getExpiryLimit ( ) ) ; } set ( Encoder . getKey ( ""tickerToSecurityToken"" , ticker ) , _securityToken ) ; _modifyTicker ( _owner , ticker , _name , registrationTime , expiryTime , true ) ; _storeSecurityTokenData ( _securityToken , ticker , _tokenDetails , _deployedAt ) ; emit NewSecurityToken ( ticker , _name , _securityToken , _owner , _deployedAt , msg . sender , true , getSecurityTokenLaunchFee ( ) ) ; }
","Adds a new custom Security Token and saves it to the registry .
"
"function totalSupply ( ) constant returns ( uint256 totalAmount ) ;
","Get the total metadollars supply
"
"function donateToFeePool ( uint n ) external optionalProxy returns ( bool ) { address sender = messageSender ; uint balance = tokenState . balanceOf ( sender ) ; require ( balance != 0 ) ; tokenState . setBalanceOf ( sender , safeSub ( balance , n ) ) ; tokenState . setBalanceOf ( FEE_ADDRESS , safeAdd ( tokenState . balanceOf ( FEE_ADDRESS ) , n ) ) ; emitFeesDonated ( sender , n ) ; emitTransfer ( sender , FEE_ADDRESS , n ) ; return true ; }
","Donate tokens from the sender 's balance into the fee pool .
"
"function setEthRate ( uint256 ethInWei ) isOwner { require ( ethInWei >= 0 ) ; ethRate = ethInWei ; }
","Set the current ETH rate in wei for one DOL
"
"function registerFor ( address _registrant , address _address , uint _timestamp , uint _gasLimit , uint _gasPrice ) public payable returns ( uint ) ;
","If value would be more then required ( see getPrice ) change will be returned to msg.sender ( not to _registrant !
"
"function donateToFeePool ( uint n ) external optionalProxy returns ( bool ) { address sender = messageSender ; uint balance = tokenState . balanceOf ( sender ) ; require ( balance != 0 , ""Must have a balance in order to donate to the fee pool"" ) ; tokenState . setBalanceOf ( sender , safeSub ( balance , n ) ) ; tokenState . setBalanceOf ( FEE_ADDRESS , safeAdd ( tokenState . balanceOf ( FEE_ADDRESS ) , n ) ) ; emitFeesDonated ( sender , n ) ; emitTransfer ( sender , FEE_ADDRESS , n ) ; return true ; }
","Donate tokens from the sender 's balance into the fee pool .
"
"function unpause ( ) public anyOperator whenPaused { super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function freezeTokens ( uint256 frozenAmount ) onlyOwner { require ( balanceOf [ address ( this ) ] >= frozenAmount ) ; frozenTokensSupply += frozenAmount ; balanceOf [ address ( this ) ] -= frozenAmount ; }
","Freeze ` frozenAmount ` tokens from being sold
"
"function onGenerateTokens ( address sender , address owner , uint256 amount ) public constant returns ( bool allow ) ;
","see MTokenMint
"
"function emergencyThaw ( ) isAdmin external { isFrozen = false ; }
","Re-enable token circulation
"
"function authorizeOperator ( address _operator ) public { require ( _operator != msg . sender ) ; isOperatorFor [ _operator ] [ msg . sender ] = true ; emit AuthorizedOperator ( _operator , msg . sender ) ; }
","Authorize a third party ` _operator ` to manage ( send ) ` msg.sender ` 's tokens .
"
"function transferBalanceWithFee ( address _traderFrom , address _traderTo , address _token , uint256 _value , uint256 _fee , address _feePayee ) external onlyRenExSettlementContract ;
","Transfer a token value from one trader to another , transferring a fee to the RewardVault .
"
"function getValidAttributeTypeID ( ) external view returns ( uint256 ) { return _validAttributeTypeID ; }
","Get the ID of the attribute type that the validator can issue .
"
"function deploy ( bytes _data ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; CappedSTO cappedSTO = new CappedSTO ( msg . sender , address ( polyToken ) ) ; require ( getSig ( _data ) == cappedSTO . getInitFunction ( ) , ""Provided data is not valid"" ) ; require ( address ( cappedSTO ) . call ( _data ) , ""Un-successfull call"" ) ; emit LogGenerateModuleFromFactory ( address ( cappedSTO ) , getName ( ) , address ( this ) , msg . sender , now ) ; return address ( cappedSTO ) ; }
","used to launch the Module with the help of factory
"
"function setWhiteList ( address [ NUMBER_OF_CHOICES ] whitelistedSenders ) external onlyOwner { whitelistedSenderAdresses = whitelistedSenders ; emit WhitelistUpdated ( whitelistedSenders ) ; }
","Only the owner can define which addresses are allowed to vote ( and also which address stands for which vote choice )
"
"function cancelJob ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( msg . sender != arbitrator ) { require ( job . manager == msg . sender ) ; require ( job . worker == 0x0 ) ; require ( job . status == JobStatus . Open ) ; } job . status = JobStatus . Cancelled ; uint returnAmount = job . salaryDeposited ; emit JobCancelled ( _JobID ) ; DAI . transfer ( job . manager , returnAmount ) ; }
","this function lets the manager or arbitrator cancel the job
"
"function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { owner = pixelIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
","Returns the address currently assigned ownership of a given Pixel .
"
"function symbol ( ) public view returns ( string ) ;
","An abbreviated name for NFTs in this contract
"
"function _transferFromSenderPaysFee_byProxy ( address sender , address from , address to , uint value , bytes data ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; uint total = safeAdd ( value , fee ) ; tokenState . setAllowance ( from , sender , safeSub ( tokenState . allowance ( from , sender ) , total ) ) ; return _internalTransfer ( from , to , value , fee , data ) ; }
","Ability to transferFrom where they sender pays the fees ( not ERC20 ) .
"
"function setOperator ( address _operator , address _tokenHolder , bool _status ) external onlyModule returns ( bool ) { mAuthorized [ _operator ] [ _tokenHolder ] = _status ; return true ; }
","Setting operator ` _operator ` for ` _tokenHolder `
"
"function setLockTime ( uint256 locktimeParam , uint256 unlocktimeParam ) public onlyOwner { _unlocktime = unlocktimeParam ; _locktime = locktimeParam ; }
","Setting lock time .
"
"function performSellOrder ( OrderData data , uint256 amountToGiveForOrder ) public onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { approveAddress ( address ( exchange ) , data . tokenGet ) ; exchange . depositToken ( data . tokenGet , amountToGiveForOrder ) ; uint256 amountToTrade ; uint256 fee ; ( amountToTrade , fee ) = substractFee ( data . exchangeFee , amountToGiveForOrder ) ; trade ( data , amountToTrade ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = getPartialAmount ( data . amountGive , data . amountGet , amountToTrade ) ; exchange . withdraw ( amountReceivedFromOrder ) ; address ( totlePrimary ) . transfer ( amountReceivedFromOrder ) ; }
","Perform a sell order at the exchange
"
"function _pause ( ) internal whenNotPaused { paused = true ; emit Pause ( now ) ; }
","Called by the owner to pause , triggers stopped state
"
"function put ( ContentMapping storage self , string _name , string _description , uint _reward ) public returns ( bool ) { require ( ! self . locked ) ; bytes32 _id = generateContentID ( _name ) ; require ( self . data [ _id ] . id == bytes32 ( 0 ) ) ; self . data [ _id ] = Content ( _id , _name , _description , block . timestamp , DeliverableUtils . newDeliverable ( _reward ) ) ; self . keys . push ( _id ) ; return true ; }
","put item into mapping
"
"function getSupplyRate ( address _asset , uint cash , uint borrows ) public view returns ( uint , uint ) { _asset ; ( IRError err0 , Exp memory utilizationRate0 , Exp memory annualBorrowRate ) = getUtilizationAndAnnualBorrowRate ( cash , borrows ) ; if ( err0 != IRError . NO_ERROR ) { return ( uint ( err0 ) , 0 ) ; } ( Error err1 , Exp memory utilizationRate1 ) = mulScalar ( utilizationRate0 , oneMinusSpreadBasisPoints ) ; assert ( err1 == Error . NO_ERROR ) ; ( Error err2 , Exp memory supplyRate0 ) = mulExp ( utilizationRate1 , annualBorrowRate ) ; assert ( err2 == Error . NO_ERROR ) ; ( Error err3 , Exp memory standardSupplyRate ) = divScalar ( supplyRate0 , 10000 * blocksPerYear ) ; assert ( err3 == Error . NO_ERROR ) ; ( Error err4 , uint finalSupplyRate ) = div ( standardSupplyRate . mantissa , 2 ) ; assert ( err4 == Error . NO_ERROR ) ; return ( uint ( IRError . NO_ERROR ) , finalSupplyRate ) ; }
","Gets the current supply interest rate based on the given asset , total cash and total borrows
"
"function userCancelActiveGame ( uint _gameId ) public { address userAddress = msg . sender ; uint gameId = userGameId [ userAddress ] ; Game storage game = gameIdGame [ gameId ] ; require ( gameId == _gameId , ""inv gameId"" ) ; if ( game . status == GameStatus . ACTIVE ) { game . endInitiatedTime = block . timestamp ; game . status = GameStatus . USER_INITIATED_END ; emit LogUserRequestedEnd ( msg . sender , gameId ) ; } else if ( game . status == GameStatus . SERVER_INITIATED_END && game . roundId == 0 ) { cancelActiveGame ( game , gameId , userAddress ) ; } else { revert ( ) ; } }
","Cancel active game without playing .
"
"function removeExchange ( address ofExchange , uint exchangeIndex ) auth pre_cond ( exchangeInformation [ ofExchange ] . exists ) { require ( registeredExchanges [ exchangeIndex ] == ofExchange ) ; delete exchangeInformation [ ofExchange ] ; delete registeredExchanges [ exchangeIndex ] ; for ( uint i = exchangeIndex ; i < registeredExchanges . length - 1 ; i ++ ) { registeredExchanges [ i ] = registeredExchanges [ i + 1 ] ; } registeredExchanges . length -- ; assert ( ! exchangeInformation [ ofExchange ] . exists ) ; }
","Deletes an existing entry
"
"function callSender ( address _operator , address _from , address _to , uint256 _amount , bytes _userData , bytes _operatorData ) internal { address senderImplementation = interfaceAddr ( _from , ""ERC777TokensSender"" ) ; if ( senderImplementation != 0 ) { ERC777TokensSender ( senderImplementation ) . tokensToSend ( _operator , _from , _to , _amount , _userData , _operatorData ) ; } }
","Helper function that checks for ERC777TokensSender on the sender and calls it .
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { _safeTransferFrom ( _from , _to , _tokenId , """" ) ; }
","Transfers the ownership of an NFT from one address to another address
"
"function updateEthRateWithDelay ( uint delay ) internal { require ( delay >= 5 ) ; if ( oraclize_getPrice ( ""URL"" , ORACLIZE_GAS_LIMIT ) > this . balance ) { LogBalanceRequired ( ) ; } else { oraclize_query ( delay , ""URL"" , ""json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0"" , ORACLIZE_GAS_LIMIT ) ; } }
","Call oraclize_query with a delay in seconds
"
"function getSecurityTokenData ( address _securityToken ) external view returns ( string , address , string , uint256 ) { return ( getString ( Encoder . getKey ( ""securityTokens_ticker"" , _securityToken ) ) , IOwnable ( _securityToken ) . owner ( ) , getString ( Encoder . getKey ( ""securityTokens_tokenDetails"" , _securityToken ) ) , getUint ( Encoder . getKey ( ""securityTokens_deployedAt"" , _securityToken ) ) ) ; }
","Returns the security token data by address
"
"function pay ( string currency , address merchant , uint amount , bool merchantPaysFees , bytes data ) public returns ( bool success ) { uint fees = calculateFees ( amount ) ; require ( lib . setAccountSpendingAmount ( msg . sender , lib . getFxUSDAmount ( currency , amount ) ) , ""Error: Unable to set account spending amount."" ) ; require ( lib . forceTransfer ( currency , msg . sender , merchant , amount , data ) , ""Error: Unable to transfer funds to account"" ) ; address feeContract = lib . getFeeContract ( address ( this ) ) ; if ( merchantPaysFees ) { require ( lib . forceTransfer ( currency , merchant , feeContract , fees , lib . getFeeMsg ( feeContract ) ) , ""Error: Unable to transfer fees to fee contract."" ) ; } else { require ( lib . forceTransfer ( currency , msg . sender , feeContract , fees , lib . getFeeMsg ( feeContract ) ) , ""Error: Unable to transfer fees to fee contract."" ) ; } return true ; }
","Pay method for merchant interface
"
"function appendVestingEntry ( address account , uint time , uint quantity ) public onlyOwner onlyDuringSetup { require ( now < time , ""Time must be in the future"" ) ; require ( quantity != 0 , ""Quantity cannot be zero"" ) ; totalVestedBalance = safeAdd ( totalVestedBalance , quantity ) ; require ( totalVestedBalance <= havven . balanceOf ( this ) , ""Must be enough balance in the contract to provide for the vesting entry"" ) ; uint scheduleLength = vestingSchedules [ account ] . length ; require ( scheduleLength <= MAX_VESTING_ENTRIES , ""Vesting schedule is too long"" ) ; if ( scheduleLength == 0 ) { totalVestedAccountBalance [ account ] = quantity ; } else { require ( getVestingTime ( account , numVestingEntries ( account ) - 1 ) < time , ""Cannot add new vested entries earlier than the last one"" ) ; totalVestedAccountBalance [ account ] = safeAdd ( totalVestedAccountBalance [ account ] , quantity ) ; } vestingSchedules [ account ] . push ( [ time , quantity ] ) ; }
","Add a new vesting entry at a given time and quantity to an account 's schedule .
"
"function tokenMetadata ( uint256 _tokenId ) external view returns ( string infoUrl ) { return appendUintToString ( metaBaseUrl , _tokenId ) ; }
","Returns a URI pointing to a metadata package for this token conforming to ERC-721 ( https : //github.com/ethereum/EIPs/issues/721 )
"
"function balanceOf ( address _owner ) public view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return ownedTokens [ _owner ] . length ; }
","Gets the balance of the specified address
"
"function buysXid ( uint256 _gameID , uint256 [ ] memory _teamEth ) public payable isActivated ( _gameID ) isOngoing ( _gameID ) isNotPaused ( _gameID ) isNotClosed ( _gameID ) isHuman ( ) isWithinLimits ( msg . value ) { uint256 _pID = BMBook . getPlayerID ( msg . sender ) ; buysCore ( _gameID , _pID , _teamEth ) ; }
","Buy keys for each team .
"
"function length ( MapStorage storage self ) public view returns ( uint ) { return self . addresses . length ; }
","Gets the current length of the Map .
"
"function setFundingStartTime ( uint _proposalID , uint _startTime ) external ;
","Function used by the main partner to set the start time of the funding
"
"function buyoutAndSetReferrer ( uint256 _gameIndex , bool startNewGameIfIdle , uint256 x , uint256 y , address referrerAddress ) external payable { burnupHolding . setReferrer ( msg . sender , referrerAddress ) ; buyout ( _gameIndex , startNewGameIfIdle , x , y ) ; }
","Buy the current owner out of the tile .
"
"function reclaimDividend ( uint256 _dividendIndex ) public onlyOwner { require ( _dividendIndex < dividends . length , ""Incorrect dividend index"" ) ; require ( now >= dividends [ _dividendIndex ] . expiry , ""Dividend expiry is in the future"" ) ; require ( ! dividends [ _dividendIndex ] . reclaimed , ""Dividend already claimed"" ) ; dividends [ _dividendIndex ] . reclaimed = true ; Dividend storage dividend = dividends [ _dividendIndex ] ; uint256 remainingAmount = dividend . amount . sub ( dividend . claimedAmount ) ; require ( ERC20 ( dividend . token ) . transfer ( msg . sender , remainingAmount ) , ""Unable to transfer tokens"" ) ; emit ERC20DividendReclaimed ( msg . sender , _dividendIndex , dividend . token , remainingAmount ) ; }
","Issuer can reclaim remaining unclaimed dividend amounts , for expired dividends
"
"function getWhitelistStatus ( address _address ) external view returns ( bool _whitelisted ) { require ( msg . sender == whitelistingAddress ) ; return whitelist [ _address ] ; }
","Get the whitelist status for an address
"
"function release ( address token ) public { require ( msg . sender == creator ) ; uint256 unreleased = _releasableAmount ( token ) ; require ( unreleased > 0 ) ; _released [ token ] = _released [ token ] . add ( unreleased ) ; tokenReward . transfer ( _beneficiary , unreleased ) ; }
","Mints and transfers tokens to beneficiary .
"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { assert ( msg . sender != address ( 0 ) ) ; assert ( _from != address ( 0 ) ) ; assert ( _to != address ( 0 ) ) ; require ( ! frozenAccount [ msg . sender ] ) ; require ( ! frozenAccount [ _from ] ) ; require ( ! frozenAccount [ _to ] ) ; require ( tokenBalanceOf [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( tokenBalanceOf [ _from ] - _value < tokenBalanceOf [ _from ] ) ; require ( tokenBalanceOf [ _to ] + _value > tokenBalanceOf [ _to ] ) ; require ( _value > 0 ) ; orderToTransfer ( msg . sender , _from , _to , _value , ""Order to transfer metadollars from allowed account"" ) ; _transfer ( _from , _to , _value ) ; allowed [ _from ] [ msg . sender ] -= _value ; return true ; }
","these standardized APIs for approval :
"
"function safeSub ( uint256 a , uint256 b ) internal constant returns ( uint256 z ) { assert ( ( z = a - b ) <= a ) ; }
","SafeMath Library safeSub Import
"
"function setVault ( address _newVaultAddress ) public onlyOwner { vaultAddress = _newVaultAddress ; }
","` onlyOwner ` changes the location that ether is sent
"
"function deploy ( bytes ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; address manualTransferManager = new ManualApprovalTransferManager ( msg . sender , address ( polyToken ) ) ; emit GenerateModuleFromFactory ( address ( manualTransferManager ) , getName ( ) , address ( this ) , msg . sender , setupCost , now ) ; return address ( manualTransferManager ) ; }
","used to launch the Module with the help of factory
"
"function sendTo ( address _recipient , uint _amount ) external returns ( bool ) ;
","Function used by the client to send ethers from the Dao manager
"
"function licenseIssuedTime ( uint256 _licenseId ) public view returns ( uint256 ) { return licenses [ _licenseId ] . issuedTime ; }
","Get a license 's issueTime
"
"function description ( bytes32 _symbol ) public view returns ( string ) { return get ( store , assetDescription , _symbol ) ; }
","Returns asset description .
"
"function changeEscapeHatchCaller ( address _newEscapeHatchCaller ) onlyEscapeHatchCaller { escapeHatchCaller = _newEscapeHatchCaller ; EscapeHatchCallerChanged ( escapeHatchCaller ) ; }
","Changes the address assigned to call ` escapeHatch ( ) `
"
"function bid ( uint256 _wave , uint256 _tokenId ) external payable whenNotPaused { require ( ethernautsStorage . ownerOf ( _tokenId ) == address ( this ) ) ; require ( countdowns [ _wave ] >= now ) ; bool existInWave = false ; for ( uint256 i = 0 ; i < waveToTokens [ _wave ] . length ; i ++ ) { if ( waveToTokens [ _wave ] [ i ] == _tokenId ) { existInWave = true ; break ; } } require ( existInWave ) ; address oldBuyer = tokenToBuyer [ _tokenId ] ; uint256 sellingPrice = ethernautsStorage . priceOf ( _tokenId ) ; require ( msg . sender != address ( 0 ) ) ; require ( msg . value > sellingPrice ) ; sellingPrice = msg . value ; uint256 newPrice = SafeMath . div ( SafeMath . mul ( sellingPrice , bonus [ _wave ] ) , percBase ) ; tokenToLastPrice [ _tokenId ] = sellingPrice ; ethernautsStorage . setPrice ( _tokenId , newPrice ) ; tokenToBuyer [ _tokenId ] = msg . sender ; if ( oldBuyer != address ( 0 ) ) { oldBuyer . transfer ( tokenToLastPrice [ _tokenId ] ) ; } Bid ( _tokenId , sellingPrice , newPrice , oldBuyer , msg . sender ) ; }
","Allows someone buy obtain an Pre sale token
"
"function changeHouseCutPercentage ( uint newHouseCutPercentage ) external onlyOwner { if ( newHouseCutPercentage >= 0 && newHouseCutPercentage < 20 ) { houseCutPercentage = newHouseCutPercentage ; emit HouseCutPercentageChanged ( newHouseCutPercentage ) ; } }
","Changes the house cut percentage
"
"function assetThaw ( ) internal { isFrozen = false ; }
","Re-enable token circulation - splitProfits internal
"
"function tokenBurner ( uint256 _amount ) public onlyOwner returns ( bool burned ) { require ( _amount > 0 ) ; require ( totalSupply . sub ( _amount ) > 0 ) ; require ( balances [ msg . sender ] > _amount ) ; require ( balances [ msg . sender ] . sub ( _amount ) > 0 ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; Transfer ( msg . sender , 0 , _amount ) ; return true ; }
","Used to burn tokens and decrease total supply
"
"function calcReward ( uint256 amount ) view public returns ( uint256 ) { if ( rate == 0 ) return 0 ; return amount . div ( rate ) ; }
","Calculates how much ETH somebody can receive for selling amount BOB
"
"function registerAsset ( address ofAsset , bytes32 inputName , bytes8 inputSymbol , uint inputDecimals , string inputUrl , string inputIpfsHash , address [ 2 ] breakInBreakOut , uint [ ] inputStandards , bytes4 [ ] inputFunctionSignatures ) auth pre_cond ( ! assetInformation [ ofAsset ] . exists ) { assetInformation [ ofAsset ] . exists = true ; registeredAssets . push ( ofAsset ) ; updateAsset ( ofAsset , inputName , inputSymbol , inputDecimals , inputUrl , inputIpfsHash , breakInBreakOut , inputStandards , inputFunctionSignatures ) ; assert ( assetInformation [ ofAsset ] . exists ) ; }
","Registers an Asset information entry
"
"function balanceOf ( address _owner ) public view returns ( uint256 ) { require ( _owner != address ( 0 ) , ""null owner"" ) ; return ownedTokens [ _owner ] . length ; }
","Gets the balance of the specified address
"
"function getAllIdentifiers ( ) external view returns ( uint256 [ ] ) { return identifiers ; }
","Get all minted identifiers ;
"
"function name ( ) public pure returns ( string result ) { return ""An Etheal Promo"" ; }
","Get name of this token .
"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external payable { require ( _getApproved ( _tokenId ) == msg . sender ) ; require ( _ownerOf ( _tokenId ) == _from ) ; require ( _to != address ( 0 ) ) ; _clearApprovalAndTransfer ( _from , _to , _tokenId ) ; Approval ( _from , 0 , _tokenId ) ; Transfer ( _from , _to , _tokenId ) ; if ( isContract ( _to ) ) { bytes4 value = ERC721TokenReceiver ( _to ) . onERC721Received ( _from , _tokenId , """" ) ; if ( value != bytes4 ( keccak256 ( ""onERC721Received(address,uint256,bytes)"" ) ) ) { revert ( ) ; } } }
","Transfers the ownership of an NFT from one address to another address
"
"function onContribution ( address _contributor , uint256 _weiAmount , uint256 _tokens , uint256 _bonus ) public onlyCrowdsale ;
","Takes actions on contribution
"
"function append ( List storage self , address node ) internal { insertAfter ( self , end ( self ) , node ) ; }
","Insert a node at the end of the list .
"
"function addBoardScore ( bytes32 boardHash , bytes32 playerName , uint score ) public returns ( bool ) { uint8 playerID = getPlayerId ( boardHash , playerName , 0 ) ; require ( playerID < 255 ) ; boards [ boardHash ] . players [ playerID ] . score_unconfirmed = score ; return true ; }
","Add a unconfirmed score to leaderboard/player .
"
"function resumePresale ( ) onlyOwner public returns ( bool ) { paused = false ; Resumed ( owner , now ) ; return true ; }
","Resumes the presale
"
"function getCampaignPriceById ( bytes32 bidId ) public view returns ( uint price ) { return campaigns [ bidId ] . getPrice ( ) ; }
","Get the price of a campaign Based on the Campaign id , return the value paid for each proof of attention registered .
"
"function createRequestAsPayeeAction ( address [ ] _payeesIdAddress , address [ ] _payeesPaymentAddress , int256 [ ] _expectedAmounts , address _payer , address _payerRefundAddress , string _data ) external payable whenNotPaused returns ( bytes32 requestId ) { require ( msg . sender == _payeesIdAddress [ 0 ] && msg . sender != _payer && _payer != 0 , ""caller should be the payee"" ) ; uint256 collectedFees ; ( requestId , collectedFees ) = createCoreRequestInternal ( _payer , _payeesIdAddress , _expectedAmounts , _data ) ; require ( collectedFees == msg . value , ""fees should be the correct amout"" ) ; for ( uint8 j = 0 ; j < _payeesPaymentAddress . length ; j = j . add ( 1 ) ) { payeesPaymentAddress [ requestId ] [ j ] = _payeesPaymentAddress [ j ] ; } if ( _payerRefundAddress != 0 ) { payerRefundAddress [ requestId ] = _payerRefundAddress ; } return requestId ; }
","Function to create a request as payee .
"
"function getOpeningTS ( bytes32 question_id ) public view returns ( uint32 ) { return questions [ question_id ] . opening_ts ; }
","Returns the timestamp when the question can first be answered
"
"function totalSupply ( ) public constant returns ( uint256 ) { return _totalSupply ; }
","Total supply , including in reserve
"
"function startDistribution ( uint256 _currentPeriodRate ) onlyOwner public { require ( currentState != State . Distribution ) ; require ( _currentPeriodRate != 0 ) ; currentState = State . Distribution ; currentPeriodRate = _currentPeriodRate ; }
","Start distribution phase
"
"function transferTokens ( address _to , uint256 _amount ) external { require ( _to != address ( 0x00 ) ) ; require ( _amount > 0 ) ; uint256 balance = token . balanceOf ( this ) ; require ( balance >= _amount ) ; token . safeTransfer ( _to , _amount ) ; }
","Owner can move tokens to any address
"
"function setAccountSpendingPeriod ( Data storage self , address account , uint period ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'limit.spending.period' , account ) ) ; require ( self . Storage . setUint ( id , period ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set the Account Spending Period Limit as UNIX timestamp
"
"function proposeOwnership ( address _newOwnerCandidate ) onlyOwner { newOwnerCandidate = _newOwnerCandidate ; OwnershipRequested ( msg . sender , newOwnerCandidate ) ; }
","` onlyOwner ` Proposes to transfer control of the contract to a new owner
"
"function clearKyc ( address [ ] _addrs ) public returns ( bool ) ;
","Clear the KYC flags for an array of addresses to allow tokens transfers
"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balances [ target ] = balances [ target ] . plus ( mintedAmount ) ; totalSupply_ = totalSupply_ . plus ( mintedAmount ) ; emit Transfer ( 0 , this , mintedAmount ) ; emit Transfer ( this , target , mintedAmount ) ; }
","Create ` mintedAmount ` tokens and send it to ` target `
"
"function unlock ( ) public returns ( bool success ) { uint256 amount = lockedBalance [ msg . sender ] ; require ( amount > 0 ) ; require ( now >= timeRelease [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; lockedBalance [ msg . sender ] = 0 ; timeRelease [ msg . sender ] = 0 ; emit Transfer ( 0x0 , msg . sender , amount ) ; emit UnLock ( msg . sender , amount ) ; return true ; }
","Transfers tokens held by lock .
"
"function getCurrencyAddress ( ) external view returns ( address ) { return 0x9992eC3cF6A55b00978cdDF2b27BC6882d88D1eC ; }
","Returns address of oracle currency ( 0x0 for ETH )
"
"function isDesignatedAssetManager ( address _manager , bytes32 _symbol ) public view returns ( bool ) { uint managerId = getHolderId ( _manager ) ; return isCreated ( _symbol ) && get ( store , assetPartowners , _symbol , managerId ) ; }
","Checks if a provided address ` _manager ` has designated access to asset ` _symbol ` .
"
"function addChunk3ToWhiteList ( ) external onlyOwner { require ( ! chunk3IsAdded ) ; addToWhitelist ( 0xd9b4cb7bf6a04f545c4c0e32d4570f16cbb3be56 , 0.5 ether ) ; addToWhitelist ( 0xDCfe2F26c4c47741851e0201a91FB3b8b6452C81 , 0.5 ether ) ; addToWhitelist ( 0xDf1734032A21Fc9F59E6aCE263b65E4c2bE29861 , 0.5 ether ) ; addToWhitelist ( 0xDFEa4bE32b1f777d82a6389a0d4F399569c46202 , 0.5 ether ) ; addToWhitelist ( 0xE18C42Ecb41d125FB21C61B9A18857A361aFC645 , 0.5 ether ) ; addToWhitelist ( 0xE3e29044291E4f2678c8C1859849a3126B95C2a4 , 0.5 ether ) ; addToWhitelist ( 0xE4B55adb4eCe93f4F53B3a18561BA876dbA3A2cb , 0.5 ether ) ; addToWhitelist ( 0xe96D559283cE2AFC3C79981dA4717bFfFAE69777 , 0.5 ether ) ; addToWhitelist ( 0xEA7F1b3e36eD60257D79a65d8BA2b305d31cEEE7 , 0.5 ether ) ; addToWhitelist ( 0xeaf61945762fa3408bfe286da7ea64bd212abfbf , 0.5 ether ) ; addToWhitelist ( 0xeC7715afA5Fd2833693Bfc3521EF5197716A65b0 , 0.5 ether ) ; addToWhitelist ( 0xee15AD84321176b2644d0894f28db22621c12b74 , 0.5 ether ) ; addToWhitelist ( 0xF05538779A8Ab41741e73a9650CE9B9FE1F3DEc7 , 0.5 ether ) ; addToWhitelist ( 0xF0c106d282648da9690Cd611F4654fF0e78DEf18 , 0.5 ether ) ; addToWhitelist ( 0xF132D556c8d065264A36d239b11Ad4Ad3d9f8f6e , 0.5 ether ) ; addToWhitelist ( 0xAac34A6B597240B1fAEBaEbeD762F0ecbe02fe18 , 0.5 ether ) ; addToWhitelist ( 0xaae16c984ca5245E6AC3c646c1Fb3A9695d2f412 , 0.5 ether ) ; addToWhitelist ( 0xfc575d7064ad46804b28ddc4fce90860addaa256 , 0.5 ether ) ; addToWhitelist ( 0x4df33f230b862941c92585078eb549a7747c47bd , 0.51 ether ) ; addToWhitelist ( 0xaaF1Df7c351c71aD1Df94DB11Ec87b65F5e72531 , 0.51 ether ) ; addToWhitelist ( 0x5C3E4c34f8a12AFBF1b9d85dfc83953c310e4645 , 0.6 ether ) ; addToWhitelist ( 0x6580B24104BCAf1ba4171d6bB3B2F1D31a96C549 , 0.6 ether ) ; addToWhitelist ( 0x0F3B2d5e7C51700aC0986fCe669aB3c69601499a , 0.7 ether ) ; addToWhitelist ( 0x0b74911659bfc903d978ea57a70ea00fab893aa2 , 0.75 ether ) ; addToWhitelist ( 0x45cAa6B0a1d9Db9227DC3D883e31132Ef08F1980 , 0.75 ether ) ; addToWhitelist ( 0xAcC0F848404e484D6fEB8Bef3bc53DF1a80CB94A , 0.75 ether ) ; addToWhitelist ( 0x32c299f7df2e46549fd2dd73f540bf5e8c867d8a , 0.9 ether ) ; addToWhitelist ( 0x00aEc73b737Bf387c60094f993B8010f70C06d4e , 1 ether ) ; addToWhitelist ( 0x014b65Cf880129A5aC836bcb1C35305De529b59c , 1 ether ) ; addToWhitelist ( 0x03D74A8b469dDB568072923323B370d64E795b03 , 1 ether ) ; addToWhitelist ( 0x04E436cC3fCF465e82932DBd1c7598808Ed07b79 , 1 ether ) ; addToWhitelist ( 0x0545Cb34B8e136768dF9f889072a87FD83605480 , 1 ether ) ; addToWhitelist ( 0x0d421e17ABF7509113f3EF03C357Bc2aeF575cb7 , 1 ether ) ; addToWhitelist ( 0x0faF819dE159B151Dd20E304134a6c167B55D9C1 , 1 ether ) ; addToWhitelist ( 0x123d31DA8fCbc11ab3B507c61086a7444305fd44 , 1 ether ) ; addToWhitelist ( 0x16C96155328d9F22973502c2aB2CbEa06Fb3D1A4 , 1 ether ) ; addToWhitelist ( 0x16D6ddeA3cb142773ca7aD4b12842e47B9835C69 , 1 ether ) ; addToWhitelist ( 0x1C3DF26aAC85dC9bebB1E8C0a771705b38abF673 , 1 ether ) ; addToWhitelist ( 0x1d664ddD7A985bED478c94b029444BB43A13ba07 , 1 ether ) ; addToWhitelist ( 0x218A7E78a960B437c409222ED6b48C088C429949 , 1 ether ) ; addToWhitelist ( 0x232f4ADd6ee2d479A9178ea184a83D43C1dca70f , 1 ether ) ; addToWhitelist ( 0x23D6Fa98877C713C00968D43d7E1fE2B14ce443F , 1 ether ) ; addToWhitelist ( 0x241A410828DA842CFB24512b91004ba6bF555D0a , 1 ether ) ; addToWhitelist ( 0x3472bdEca240fDFE3A701254bdD62a6c10B2f0e7 , 1 ether ) ; addToWhitelist ( 0x36889c0Bc35F585062613B6dfa30365AdE826804 , 1 ether ) ; addToWhitelist ( 0x3775eF0bB806098e4678D7758f6b16595c4D0618 , 1 ether ) ; addToWhitelist ( 0x37c9909DFb1f13281Cc0109f5C4F4775a337df7c , 1 ether ) ; addToWhitelist ( 0x3831ee9f3be7ac81d6653d312adefedbf8ede843 , 1 ether ) ; addToWhitelist ( 0x38c9606DAaD44fEB86144ab55107a3154DddCf5c , 1 ether ) ; addToWhitelist ( 0x400d654A92494958E630A928f9c2Cfc9a0A8e011 , 1 ether ) ; addToWhitelist ( 0x42593b745B20f03d36137B6E417C222c1b0FE1a8 , 1 ether ) ; addToWhitelist ( 0x435ca13E9814e0edd2d203E3e14AD9dbcBd19224 , 1 ether ) ; chunk3IsAdded = true ; }
","Add chunk 3 / 7 to the whitelist
"
"function approveAndCall ( address _operator , uint256 _amount , bytes _operatorData ) public whenNotPaused returns ( bool success ) { uint balanceAvailable = getAmountOfUnlockedTokens ( msg . sender ) ; require ( balanceAvailable >= _amount , ""The amount of unlocked tokens must be >= the amount sent"" ) ; mAllowed [ msg . sender ] [ _operator ] = _amount ; callOperator ( _operator , msg . sender , _operator , _amount , ""0x0"" , _operatorData , true ) ; emit Approval ( msg . sender , _operator , _amount ) ; return true ; }
","extended 777 approveAndCall and erc20 approve functionality that gives an allowance and calls the new operator .
"
"function auditContract ( bytes32 _codeHash , bool _isApproved ) public whenNotPaused { bytes32 hashAuditorCode = keccak256 ( msg . sender , _codeHash ) ; uint8 outcome = auditOutcomes [ hashAuditorCode ] ; require ( outcome == NOT_AUDITED ) ; if ( _isApproved ) auditOutcomes [ hashAuditorCode ] = AUDITED_AND_APPROVED ; else auditOutcomes [ hashAuditorCode ] = AUDITED_AND_REJECTED ; uint reward = rewards [ hashAuditorCode ] ; totalRequestsAmount = totalRequestsAmount . sub ( reward ) ; commission = calcCommission ( reward ) ; availableCommission = availableCommission . add ( commission ) ; emit ContractAudited ( msg . sender , _codeHash , reward , _isApproved ) ; msg . sender . transfer ( reward . sub ( commission ) ) ; }
","marks contract as audited
"
"function transferAndCall ( address _to , uint256 _amount , bytes _data ) external returns ( bool ) { require ( transfer ( _to , _amount ) ) ; emit Transfer ( msg . sender , _to , _amount , _data ) ; if ( isContract ( _to ) ) { require ( contractFallback ( _to , _amount , _data ) ) ; } return true ; }
","Send ` _amount ` tokens to ` _to ` from ` msg.sender ` and call ` contractFallback ` on the recipient if it is a Contract .
"
"function canDeposit ( bytes32 channelId , address origin ) public view returns ( bool ) { PaymentChannel memory channel = channels [ channelId ] ; bool isSender = channel . sender == origin ; return isOpen ( channelId ) && isSender ; }
","Ensure ` origin ` address can deposit money into the channel identified by ` channelId ` .
"
"function closeCrowdsale ( ) onlyOwner { require ( block . timestamp > END_DATE || crowdsaleCanceled || balances [ this ] == 0 ) ; transferable = true ; if ( balances [ this ] > 0 ) { uint256 amount = balances [ this ] ; balances [ MULTISIG_WALLET_ADDRESS ] = safeAdd ( balances [ MULTISIG_WALLET_ADDRESS ] , amount ) ; balances [ this ] = 0 ; Transfer ( this , MULTISIG_WALLET_ADDRESS , amount ) ; } }
","returns non-sold tokens to owner
"
"function acceptAction ( bytes32 _requestId ) public whenNotPaused onlyRequestPayer ( _requestId ) { require ( requestCore . getState ( _requestId ) == RequestCore . State . Created , ""request should be created"" ) ; requestCore . accept ( _requestId ) ; }
","msg.sender must be _payer , The request must be in the state CREATED ( not CANCELED , not ACCEPTED ) .
"
"function isCanvasFinished ( uint32 _canvasId ) public view returns ( bool ) { return _isCanvasFinished ( _getCanvas ( _canvasId ) ) ; }
","Returns true if the canvas has been already finished .
"
"function getPermission ( bytes4 _methodsignature ) public view returns ( string name , string description , string contract_name , bool active ) { return ( permissions [ _methodsignature ] . name , permissions [ _methodsignature ] . description , permissions [ _methodsignature ] . contract_name , permissions [ _methodsignature ] . active ) ; }
","get Permission structure
"
"function addValidator ( address validator , string description ) external onlyOwner whenNotPaused { require ( validator != address ( 0 ) , ""must supply a valid address"" ) ; require ( ! isValidator ( validator ) , ""a validator with the provided address already exists"" ) ; require ( _signingKeys [ validator ] == address ( 0 ) , ""a signing key matching the provided address already exists"" ) ; _validators [ validator ] = Validator ( { exists : true , index : _validatorAccounts . length , signingKey : validator , description : description } ) ; _signingKeys [ validator ] = validator ; _validatorAccounts . push ( validator ) ; emit ValidatorAdded ( validator , description ) ; }
","Add account ` validator ` as a validator with a description ` description ` who can be approved to set attributes of specific types .
"
"function totalSupplyAt ( uint _blockNumber ) constant returns ( uint ) { if ( _blockNumber < creationBlock ) { return 0 ; } else if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( parentSnapShotBlock ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }
","Total amount of tokens at a specific ` _blockNumber ` .
"
"function getPerson ( uint256 _tokenId ) public view returns ( string personName , uint64 satisfaction , uint64 cooldownTime , string slogan , uint256 basePrice , uint256 sellingPrice , address owner ) { Person storage person = persons [ _tokenId ] ; personName = person . name ; satisfaction = uint64 ( person . satisfaction ) ; cooldownTime = uint64 ( person . cooldownTime ) ; slogan = person . slogan ; basePrice = person . basePrice ; sellingPrice = personIndexToPrice [ _tokenId ] ; owner = personIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific person .
"
"function finishICO ( ) public timedStateChange ( address ( 0 ) , 0 , true ) requiresState ( IcoState . ACTIVE ) onlymanyowners ( keccak256 ( msg . data ) ) { finishICOInternal ( ) ; }
","finishes ICO
"
"function submitAnswerReveal ( bytes32 question_id , bytes32 answer , uint256 nonce , uint256 bond ) stateOpen ( question_id ) external { bytes32 answer_hash = keccak256 ( answer , nonce ) ; bytes32 commitment_id = keccak256 ( question_id , answer_hash , bond ) ; require ( ! commitments [ commitment_id ] . is_revealed ) ; require ( commitments [ commitment_id ] . reveal_ts > uint32 ( now ) ) ; commitments [ commitment_id ] . revealed_answer = answer ; commitments [ commitment_id ] . is_revealed = true ; if ( bond == questions [ question_id ] . bond ) { _updateCurrentAnswer ( question_id , answer , questions [ question_id ] . timeout ) ; } LogAnswerReveal ( question_id , msg . sender , answer_hash , answer , nonce , bond ) ; }
","Submit the answer whose hash you sent in a previous submitAnswerCommitment ( ) transaction
"
"function blacklistParty ( address _address , bool _motion ) public onlyOwner ( ) { blacklist [ _address ] = _motion ; }
","This allows the owner to stop a malicious party from spamming the orderbook
"
"function transfer ( address _to , uint256 _amount , bytes _data ) public returns ( bool success ) { return transferFrom ( msg . sender , _to , _amount , _data ) ; }
","Send ` _value ` tokens to ` _to ` from ` msg.sender ` and trigger tokenFallback if sender is a contract .
"
"function removeAddressesFromAdmins ( address [ ] _admins ) external onlyOwner { require ( _admins . length > 0 , ""Cannot remove an empty list to admins!"" ) ; for ( uint256 i = 0 ; i < _admins . length ; ++ i ) { address user = _admins [ i ] ; if ( admins [ user ] ) { admins [ user ] = false ; emit AdminRemoved ( user ) ; } } }
","Removes a list of addresses from the admins list .
"
"function hashOrder ( bytes details , OrderDetails memory order ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( details , order . settlementID , order . tokens , order . price , order . volume , order . minimumVolume ) ) ; }
","Calculates the ID of the order .
"
"function getTagByModuleType ( uint8 _moduleType ) public view returns ( bytes32 [ ] ) ;
","Use to get all the tags releated to the functionality of the Module Factory .
"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) public returns ( bool success ) ;
","` msg.sender ` approves ` _spender ` to send ` _amount ` tokens on its behalf , and then a function is triggered in the contract that is being approved , ` _spender ` .
"
"function airdrop ( address _token , uint256 _amount , address [ ] memory _targets ) public onlyOwner { require ( _targets . length > 0 , 'Target addresses must not be 0' ) ; require ( _targets . length <= 64 , 'Target array length is too big' ) ; require ( _amount * _targets . length <= ERC20 ( _token ) . balanceOf ( address ( this ) ) , 'Airdrop contract does not have enough tokens to execute the airdrop' ) ; for ( uint8 target = 0 ; target < _targets . length ; target ++ ) { ERC20 ( _token ) . transfer ( _targets [ target ] , _amount ) ; } }
","MultiTransfer function for airdrop
"
"function freeClaimAllowanceOf ( address addr ) external view returns ( uint256 ) { return freeClaimAllowance [ addr ] ; }
","Get the free claim allowance of an address .
"
"function balanceOf ( address tokenOwner ) constant public returns ( uint coinBalance ) { return balanceOf [ tokenOwner ] ; }
","Show the ` tokenOwner ` balances for this contract
"
"function updateTreasury ( address _treasury , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _treasury ) , _block ) ; if ( OK != _code ) { return _code ; } treasury = _treasury ; return OK ; }
","Update a treasury address
"
"function allowPublicTransfer ( ) onlyOwner { isPublicTransferAllowed = true ; }
","Function to allow the Token users to transfer among themselves .
"
"function unlock ( ) external { require ( now >= unlockDate ) ; uint256 entitled = allocations [ msg . sender ] ; require ( entitled > 0 ) ; allocations [ msg . sender ] = 0 ; if ( ! StandardToken ( gmtAddress ) . transfer ( msg . sender , entitled ) ) { revert ( ) ; } }
","transfer ` allocations [ msg.sender ] ` tokens to ` msg.sender ` from this contract
"
"function destroy ( ) onlyOwner { uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; selfdestruct ( owner ) ; }
","Terminate contract and refund to owner
"
"function setActiveTimes ( uint256 [ ] _from , uint256 [ ] _to ) external onlyCFO { require ( _from . length == _to . length ) ; activeTimesFrom = _from ; activeTimesTo = _to ; ActiveTimes ( _from , _to ) ; }
","Set the active times .
"
"function isRegisteredAuthority ( address authority ) public view returns ( bool registered ) { return lib . isRegisteredAuthority ( authority ) ; }
","Gets status of authority registration
"
"function upgradeFrom ( address _from , uint256 _value ) public { if ( finalizedUpgrade ) revert ( ) ; if ( msg . sender != address ( oldToken ) ) revert ( ) ; if ( _from == decentBetMultisig ) revert ( ) ; if ( ! newToken . isNewToken ( ) ) revert ( ) ; setUpgradeHasBegun ( ) ; safetyInvariantCheck ( _value ) ; newToken . createToken ( _from , _value ) ; safetyInvariantCheck ( 0 ) ; }
","Creates new version tokens from the new token contract
"
"function authorizePayment ( string _name , bytes32 _reference , address _recipient , uint _amount , uint _paymentDelay ) returns ( uint ) { if ( ! allowedSpenders [ msg . sender ] ) throw ; uint idPayment = authorizedPayments . length ; authorizedPayments . length ++ ; Payment p = authorizedPayments [ idPayment ] ; p . spender = msg . sender ; if ( _paymentDelay > 10 ** 18 ) throw ; p . earliestPayTime = _paymentDelay >= timeLock ? now + _paymentDelay : now + timeLock ; p . recipient = _recipient ; p . amount = _amount ; p . name = _name ; p . reference = _reference ; PaymentAuthorized ( idPayment , p . recipient , p . amount ) ; return idPayment ; }
","only ` allowedSpenders [ ] ` Creates a new ` Payment `
"
"function isSecurityToken ( address _securityToken ) public view returns ( bool ) ;
","Check that Security Token is registered
"
"function depositToken ( ERC20 token , uint amount ) returns ( bool ) { if ( token . allowance ( msg . sender , this ) < amount ) { ErrorReport ( tx . origin , 0x850000001 , token . allowance ( msg . sender , this ) ) ; return false ; } if ( ! token . transferFrom ( msg . sender , this , amount ) ) { ErrorReport ( tx . origin , 0x850000002 , uint ( token ) ) ; return false ; } DepositToken ( token , amount ) ; return true ; }
","tokens could also be deposited without calling this function
"
"function updatePolyTokenAddress ( address _newAddress ) external onlyOwner { require ( _newAddress != address ( 0 ) , ""Invalid address"" ) ; set ( POLYTOKEN , _newAddress ) ; }
","Changes the PolyToken address .
"
"function burnToken ( address _target , uint256 _burnedAmount ) onlyAdmin public { balances [ _target ] = SafeMath . sub ( balances [ _target ] , _burnedAmount ) ; totalSupply = SafeMath . sub ( totalSupply , _burnedAmount ) ; Burned ( _target , _burnedAmount ) ; }
","Burn _burnedAmount tokens form _target address .
"
"function getPlace ( uint256 _tokenId ) public view returns ( string placeName , string placeCountry , string placeOwnerName , uint256 sellingPrice , address owner ) { Place storage place = places [ _tokenId ] ; placeName = place . name ; placeCountry = place . country ; placeOwnerName = place . owner_name ; sellingPrice = placeIndexToPrice [ _tokenId ] ; owner = placeIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific place .
"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( isTransferWhitelistOnly ) { require ( isUserAllowedToTransfer ( _from ) ) ; } return super . transferFrom ( _from , _to , _value ) ; }
","Transfer tokens from one address to another
"
"function getDisputeFee ( bytes32 question_id ) public constant returns ( uint256 ) { return ( custom_dispute_fees [ question_id ] > 0 ) ? custom_dispute_fees [ question_id ] : dispute_fee ; }
","Return the dispute fee for the specified question .
"
"function adminRemoveTrustedCurrencyContract ( address _oldTrustedContractAddress ) external onlyOwner { require ( trustedCurrencyContracts [ _oldTrustedContractAddress ] != 0 , ""_oldTrustedContractAddress should not be 0"" ) ; trustedCurrencyContracts [ _oldTrustedContractAddress ] = 0 ; emit RemoveTrustedContract ( _oldTrustedContractAddress ) ; }
","Removes a trusted currencyContract .
"
"function metaIncreaseApproval ( address _spender , uint256 _addedValue , bytes _signature , uint256 _nonce , uint256 _reward ) public userNotBlacklisted ( _spender ) whenNotPaused returns ( bool ) { bytes32 metaHash = metaApproveHash ( _spender , _addedValue , _nonce , _reward ) ; address signer = _getSigner ( metaHash , _signature ) ; require ( ! regulator . isBlacklistedUser ( signer ) , ""signer is blacklisted"" ) ; require ( _nonce == replayNonce [ signer ] , ""this transaction has already been broadcast"" ) ; replayNonce [ signer ] ++ ; require ( _reward > 0 , ""reward to incentivize relayer must be positive"" ) ; require ( _reward <= balanceOf ( signer ) , ""not enough balance to reward relayer"" ) ; _increaseApproval ( _spender , _addedValue , signer ) ; _transfer ( msg . sender , signer , _reward ) ; return true ; }
","increaseApproval should be used instead of approve when the user 's allowance is greater than 0 .
"
"function canTransferFrom ( address from , address to , uint256 tokenId , uint256 value ) external view returns ( bool , bytes1 ) { from ; if ( value > 0 ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( ! _isApprovedOrOwner ( msg . sender , tokenId ) ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( to == address ( 0 ) ) { return ( false , bytes1 ( hex""A0"" ) ) ; } if ( ! _registry . hasAttribute ( to , _validAttributeTypeID ) ) { return ( false , bytes1 ( hex""10"" ) ) ; } return ( true , bytes1 ( hex""01"" ) ) ; }
","Check if a transfer of the NFT with ID ` tokenId ` on behalf of account ` from ` to a recipient at account ` to ` with ` msg.value ` of ` value ` is approved .
"
"function getTokenAddressArray ( ) public view returns ( address [ ] _arrayToReturn ) { _arrayToReturn = tokenAddress ; }
","Returns the array of token addresses .
"
"function claimTokens ( uint256 amount , address beneficiary ) onlyOwner external { require ( token . transfer ( beneficiary , amount ) ) ; }
","Claim some of tokens stored on the contract
"
"function finalize ( ) external { if ( ! funding ) throw ; if ( ( block . number <= fundingEndBlock || totalTokens < tokenCreationMin ) && totalTokens < tokenCreationCap ) throw ; funding = false ; if ( ! bitplusAddress . send ( this . balance ) ) throw ; for ( uint i = 0 ; i < earlyBackers . length ; i ++ ) { if ( earlyBackers [ i ] . deposited != uint256 ( 0 ) ) { uint256 percentage = ( earlyBackers [ i ] . deposited * earlyBackers [ i ] . agreedPercentage / earlyBackers [ i ] . agreedEthPrice ) ; uint256 additionalTokens = totalTokens * percentage / ( 10000 - percentage ) ; address backerAddr = earlyBackers [ i ] . backerAddress ; balances [ backerAddr ] = additionalTokens ; totalTokens += additionalTokens ; Transfer ( 0 , backerAddr , additionalTokens ) ; } } }
","Finalize crowdfunding
"
"function opened ( ) constant returns ( uint ) { return data . opened ; }
","Returns the block number for when the channel was opened .
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _approvedFor ( msg . sender , _tokenId ) ) ; require ( _owns ( _from , _tokenId ) ) ; _transfer ( _from , _to , _tokenId ) ; }
","Transfer a element owned by another address , for which the calling address has previously been granted transfer approval by the owner .
"
"function onApprove ( address _owner , address _spender , uint _amount ) public initialized returns ( bool ) { return false ; }
","Notifies the controller about an approval allowing the controller to react if desired
"
"function setDefaultReputationForManufacturer ( bytes32 _manufacturerId , bytes32 _newDefaultScore ) public onlyOwner returns ( bool ) { require ( _manufacturerId != 0 , ""_manufacturerId is required"" ) ; require ( _newDefaultScore != defaultManufacturerReputations [ _manufacturerId ] , ""_newDefaultScore should be different"" ) ; defaultManufacturerReputations [ _manufacturerId ] = _newDefaultScore ; emit DefaultReputationScoreChanged ( msg . sender , _manufacturerId , _newDefaultScore ) ; return true ; }
","allows the owner to change the default reputation for manufacturers
"
"function transferAnyERC20Token ( address addr , uint256 tokens ) public onlyOwner returns ( bool success ) { requireTrade ( addr ) ; return ERC20Interface ( addr ) . transfer ( owner , tokens ) ; }
","In the event of errors , allow the owner to move tokens from an account
"
"function unpause ( ) public onlyCEO whenPaused { require ( geneScience != address ( 0 ) ) ; require ( newContractAddress == address ( 0 ) ) ; super . unpause ( ) ; }
","This is public rather than external so we can call super.unpause without using an expensive CALL .
"
"function proxyPayment ( address _owner ) public payable returns ( bool ) { return false ; }
","Called when ` _owner ` sends ether to the MiniMe Token contract
"
"function transferFrom ( address _from , address _to , uint256 _tokenId ) external payable ;
","Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT ` _to ` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST
"
"function authorizeSpender ( address _spender , bool _authorize ) onlyOwner { allowedSpenders [ _spender ] = _authorize ; SpenderAuthorization ( _spender , _authorize ) ; }
","` onlyOwner ` Adds a spender to the ` allowedSpenders [ ] ` white list
"
"function approve ( address _to , uint256 _deedId ) external whenNotPaused { uint256 [ ] memory _deedIds = new uint256 [ ] ( 1 ) ; _deedIds [ 0 ] = _deedId ; approveMultiple ( _to , _deedIds ) ; }
","Approve a given address to take ownership of a deed .
"
"function claimReimbursement ( address _user ) public isAwaitingOrCompleted userHasFundedPool ( _user ) { processReimbursementInternal ( _user ) ; }
","Process a reimbursement claim for a specified address .
"
"function performSellOrder ( OrderData order , uint256 amountToGiveForOrder ) public onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { approveAddress ( address ( exchange ) , order . addresses [ 2 ] ) ; exchange . depositTokens ( order . addresses [ 2 ] , amountToGiveForOrder ) ; uint256 feeRate = exchange . feeRate ( ) ; uint256 amountToGive = SafeMath . div ( SafeMath . mul ( amountToGiveForOrder , feeRate ) , SafeMath . add ( feeRate , 1 ) ) ; exchange . takeBuyOrder ( order . addresses , order . values , amountToGive , order . v , order . r , order . s ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = SafeMath . div ( SafeMath . mul ( amountToGive , order . values [ 0 ] ) , order . values [ 1 ] ) ; exchange . withdrawEthers ( amountReceivedFromOrder ) ; address ( totlePrimary ) . transfer ( amountReceivedFromOrder ) ; }
","Perform a sell order at the exchange
"
"function process_contribution ( address _toAddr ) internal { require ( ( campaignState == 2 ) && ( now <= tCampaignEnd ) && ( paused == false ) ) ; if ( ( now > tBonusStageEnd ) && ( now < tRegSaleStart ) ) { revert ( ) ; } if ( ( now <= tBonusStageEnd ) && ( ( msg . value < bonusMinContribution ) || ( tokensGenerated >= bonusTokenThreshold ) ) ) { revert ( ) ; } require ( msg . value >= minContribution ) ; uint256 rate = get_rate ( ) ; uint256 nTokens = ( rate . mul ( msg . value ) ) . div ( 1 ether ) ; uint256 opEth = ( PRCT_ETH_OP . mul ( msg . value ) ) . div ( 100 ) ; opVaultAddr . transfer ( opEth ) ; require ( do_grant_tokens ( _toAddr , nTokens ) ) ; amountRaised = amountRaised . add ( msg . value ) ; TokenGranted ( _toAddr , nTokens ) ; TotalRaised ( amountRaised ) ; }
","processes the contribution checks campaign state , time window and minimal contribution throws if one of the conditions fails
"
"function receiveApproval ( address _sender , uint256 _value , bytes _extraData ) public ;
","Signals that token holder approved spending of tokens and some action should be taken .
"
"function adminWithdrawBalance ( ) external onlyAdmin { uint256 adminPrize = adminPool ; adminPool = 0 ; adminAddress . transfer ( adminPrize ) ; }
","Called by the development team once the World Cup has ended ( adminPool is set )
"
"function unpause ( ) public onlyGameManager whenPaused { paused = false ; }
","This is public rather than external so it can be called by derived contracts .
"
"function _burn ( address _owner , uint256 _tokenId ) internal { super . _burn ( _owner , _tokenId ) ; assert ( tokens . length > 0 ) ; uint256 tokenIndex = idToIndex [ _tokenId ] ; assert ( tokens [ tokenIndex ] == _tokenId ) ; uint256 lastTokenIndex = tokens . length - 1 ; uint256 lastToken = tokens [ lastTokenIndex ] ; tokens [ tokenIndex ] = lastToken ; tokens . length -- ; idToIndex [ lastToken ] = tokenIndex ; idToIndex [ _tokenId ] = 0 ; }
","This is a private function which should be called from user-implemented external burn function .
"
"function _payDividend ( address _payee , Dividend storage _dividend , uint256 _dividendIndex ) internal { ( uint256 claim , uint256 withheld ) = calculateDividend ( _dividendIndex , _payee ) ; _dividend . claimed [ _payee ] = true ; uint256 claimAfterWithheld = claim . sub ( withheld ) ; if ( claimAfterWithheld > 0 ) { if ( _payee . send ( claimAfterWithheld ) ) { _dividend . claimedAmount = _dividend . claimedAmount . add ( claim ) ; _dividend . dividendWithheld = _dividend . dividendWithheld . add ( withheld ) ; investorWithheld [ _payee ] = investorWithheld [ _payee ] . add ( withheld ) ; emit EtherDividendClaimed ( _payee , _dividendIndex , claim , withheld ) ; } else { _dividend . claimed [ _payee ] = false ; emit EtherDividendClaimFailed ( _payee , _dividendIndex , claim , withheld ) ; } } }
","Internal function for paying dividends
"
"function mintToken ( address target , uint256 mintedOshiAmount ) onlyOwner public returns ( bool ) { balanceOf [ target ] = balanceOf [ target ] . add ( mintedOshiAmount ) ; totalSupply = totalSupply . add ( mintedOshiAmount ) ; emit Transfer ( 0 , address ( this ) , mintedOshiAmount ) ; emit Transfer ( address ( this ) , target , mintedOshiAmount ) ; return true ; }
","Create ` mintedOshiAmount ` and send it to ` target `
"
"function trade ( OrderData data , uint256 amountToTrade ) internal { exchange . trade ( data . tokenGet , data . amountGet , data . tokenGive , data . amountGive , data . expires , data . nonce , data . user , data . v , data . r , data . s , amountToTrade ) ; }
","Performs the trade at the exchange
"
"function getGirl ( uint256 _tokenId ) public view returns ( string girlName , uint256 sellingPrice , address owner ) { Girl storage girl = girls [ _tokenId ] ; girlName = girl . name ; sellingPrice = girlIndexToPrice [ _tokenId ] ; owner = girlIndexToOwner [ _tokenId ] ; }
","Returns all the relevant information about a specific girl .
"
"function transfer ( address from , address to , uint amount ) public onlyTransferAgent returns ( bool ) { require ( to != 0x0 , ""Cannot transfer tokens to the null address."" ) ; require ( amount > 0 , ""Cannot transfer zero tokens."" ) ; Holding memory fromHolding = heldTokens [ from ] ; require ( fromHolding . quantity >= amount , ""Not enough tokens to perform the transfer."" ) ; require ( ! isExistingHolding ( to ) , ""Cannot overwrite an existing holding, use a new wallet."" ) ; heldTokens [ from ] = Holding ( fromHolding . quantity . sub ( amount ) , fromHolding . releaseDate , fromHolding . isAffiliate ) ; heldTokens [ to ] = Holding ( amount , fromHolding . releaseDate , false ) ; emit TokensTransferred ( from , to , amount ) ; return true ; }
","Under special circumstances the Transfer Agent needs to move tokens around .
"
"function getSecurityTokenAddress ( string _ticker ) external view returns ( address ) ;
","Get security token address by ticker name
"
"function getStraightReleasableAmount ( address _beneficiary ) internal view returns ( uint releasableAmount ) { Beneficiary memory _b = beneficiaries [ _beneficiary ] ; Release memory _r = releases [ _beneficiary ] ; uint totalReleasableAmount = getTotalLockedAmounts ( _beneficiary ) ; uint firstTime = _r . releaseTimes [ 0 ] ; uint lastTime = _r . releaseTimes [ 1 ] ; require ( now >= firstTime ) ; if ( now >= lastTime ) { releasableAmount = totalReleasableAmount ; } else { uint firstAmount = getPartialAmount ( _r . releaseRatios [ 0 ] , coeff , totalReleasableAmount ) ; releasableAmount = getPartialAmount ( now . sub ( firstTime ) , lastTime . sub ( firstTime ) , totalReleasableAmount . sub ( firstAmount ) ) ; releasableAmount = releasableAmount . add ( firstAmount ) ; } releasableAmount = releasableAmount . sub ( _b . withdrawAmount ) ; }
","return releaseable amount for beneficiary in case of straight type of release
"
"function incrementalInverse ( uint256 totalEuroUlps , uint256 burnNeumarkUlps , uint256 minEurUlps , uint256 maxEurUlps ) public pure returns ( uint256 euroUlps ) { uint256 totalNeumarkUlps = cumulative ( totalEuroUlps ) ; require ( totalNeumarkUlps >= burnNeumarkUlps ) ; uint256 fromNmk = totalNeumarkUlps - burnNeumarkUlps ; uint newTotalEuroUlps = cumulativeInverse ( fromNmk , minEurUlps , maxEurUlps ) ; assert ( totalEuroUlps >= newTotalEuroUlps ) ; return totalEuroUlps - newTotalEuroUlps ; }
","returns amount of euro corresponding to burned neumarks
"
"function setPlayerOverrideId ( uint256 _tokenId , uint256 _newOverrideId ) public onlyManager whenNotPaused { require ( exists ( _tokenId ) ) ; _updatePlayerOverrideId ( _tokenId , _newOverrideId ) ; }
","Sets the player override identifier .
"
"function claim ( ) public { claimAddress ( msg . sender ) ; }
","claims available tokens .
"
"function approveAndCall ( address spender , uint256 tokenAmount , bytes data ) public tradable ( spender ) returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokenAmount ; emit Approval ( msg . sender , spender , tokenAmount ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokenAmount , this , data ) ; return true ; }
","Permits to create an approval on a contract and then call a method on the approved contract right away .
"
"function ownerWithdrawUnspentCredits ( ) external onlyOwner { require ( now >= PRESALE_END_DATE ) ; require ( now < TOKEN_WITHDRAWAL_START_DATE ) ; require ( totalFunding >= PRESALE_MINIMUM_FUNDING ) ; require ( ! unspentCreditsWithdrawn ) ; uint256 currentCredits = parsecToken . balanceOf ( this ) ; uint256 unspentAmount = currentCredits . sub ( grantedParsecCredits ) ; unspentCreditsWithdrawn = true ; parsecToken . transfer ( owner , unspentAmount ) ; }
","The owner can withdraw unspent Parsec credits if the minimum funding level has been reached and pre-sale is over
"
"function sendGiftCard ( address _address ) external onlyAuto { uint256 existing = cards . getOwnedCount ( _address , 1 ) ; require ( existing < schema . getMaxCAP ( ) ) ; require ( SafeMath . add ( existing , 1 ) <= schema . getMaxCAP ( ) ) ; cards . updatePlayersCoinByPurchase ( _address , 0 ) ; if ( schema . unitCoinProduction ( 1 ) > 0 ) { cards . increasePlayersJadeProduction ( _address , cards . getUnitsProduction ( _address , 1 , 1 ) ) ; cards . setUintCoinProduction ( _address , 1 , cards . getUnitsProduction ( _address , 1 , 1 ) , true ) ; } if ( cards . getUintsOwnerCount ( _address ) <= 0 ) { cards . AddPlayers ( _address ) ; } cards . setUintsOwnerCount ( _address , 1 , true ) ; cards . setOwnedCount ( _address , 1 , 1 , true ) ; UnitBought ( _address , 1 , 1 ) ; }
","invite
"
"function getName ( ) public view returns ( bytes32 ) { return ""GeneralPermissionManager"" ; }
","Get the name of the Module
"
"function setProxy ( address _proxyAddress , bytes32 _symbol ) public onlyOneOfContractOwners returns ( uint ) { if ( proxies [ _symbol ] != 0x0 ) { return ATX_PLATFORM_PROXY_ALREADY_EXISTS ; } proxies [ _symbol ] = _proxyAddress ; return OK ; }
","Sets Proxy contract address for a particular asset .
"
"function acceptOwnership ( ) external onlyNominatedOwner { owner = nominatedOwner ; nominatedOwner = address ( 0 ) ; emit OwnerChanged ( owner , nominatedOwner ) ; }
","Accept the nomination to be owner .
"
"function exchangeEtherForHavvensAtRate ( uint guaranteedEtherRate , uint guaranteedHavvenRate ) public payable pricesNotStale notPaused returns ( uint ) { require ( guaranteedEtherRate == usdToEthPrice ) ; require ( guaranteedHavvenRate == usdToHavPrice ) ; return exchangeEtherForHavvens ( ) ; }
","Exchange ETH to HAV while insisting on a particular set of rates .
"
"function extGoalReached ( ) afterDeadline external { require ( ICOAddress != 0x0 ) ; require ( msg . sender == ICOAddress ) ; goalReached ( ) ; }
","supposed to be called by ICO Contract IF ` fundingGoal ` was n't reached during PreICO to notify it
"
"function addInvestorBonusInTokens ( address _to , uint tokens ) public onlyOwner { _freezeTransfer ( _to , tokens ) ; investorGiven = investorGiven . add ( tokens ) ; require ( investorGiven <= investorSupply ) ; }
","addInvestorBonusInTokens is used for sending bonuses for big investors in tokens
"
"function freezeTransfers ( ) external onlyOwner { require ( ! transfersFrozen , ""Already frozen"" ) ; transfersFrozen = true ; emit FreezeTransfers ( true , now ) ; }
","freezes transfers
"
"function setTokenSymbol ( Data storage self , string tokenSymbol ) internal returns ( bool success ) { bytes32 id = keccak256 ( abi . encodePacked ( 'token.symbol' , address ( this ) ) ) ; require ( self . Storage . setString ( id , tokenSymbol ) , ""Error: Unable to set storage value. Please ensure contract interface is allowed by the storage contract."" ) ; return true ; }
","Set the token symbol for Token interfaces
"
"function generateContentID ( string _name ) public pure returns ( bytes32 ) { return keccak256 ( _name ) ; }
","get sha256 hash of name for content ID
"
"function onApprove ( address _owner , address _spender , uint _amount ) returns ( bool ) { return false ; }
","Notifies the controller about an approval allowing the controller to react if desired
"
"function getCampaignStartDateById ( bytes32 bidId ) public view returns ( uint startDate ) { return campaigns [ bidId ] . getStartDate ( ) ; }
","Get the start date of a campaign Based on the Campaign id , return the value ( in miliseconds ) corresponding to the start Date of the campaign .
"
"function setWhitelistStatus ( address _address , bool _whitelisted ) external { require ( msg . sender == whitelistingAddress ) ; require ( whitelist [ _address ] != _whitelisted ) ; whitelist [ _address ] = _whitelisted ; emit WhitelistChanged ( _address , _whitelisted ) ; }
","Set the whitelist status for an address
"
"function registerEndpoint ( string endpoint ) public noEmptyString ( endpoint ) { string storage old_endpoint = address_to_endpoint [ msg . sender ] ; if ( equals ( old_endpoint , endpoint ) ) { return ; } address_to_endpoint [ msg . sender ] = endpoint ; emit AddressRegistered ( msg . sender , endpoint ) ; }
","Registers the Ethereum address to the given endpoint .
"
"function transfer ( address _to , uint256 _value ) onlyPayloadSize ( 2 * 32 ) returns ( bool success ) { if ( _to != 0x0 && _value > 0 && balances [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; if ( msg . sender == owner && _to != owner ) { shareholdersBalance += _value ; } if ( msg . sender != owner && _to == owner ) { shareholdersBalance -= _value ; } if ( owner != _to ) { insertShareholder ( _to ) ; } Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }
","Send ` _value ` tokens to ` _to ` from your account
"
"function setSelfDestructBeneficiary ( address _beneficiary ) external onlyOwner { require ( _beneficiary != address ( 0 ) ) ; selfDestructBeneficiary = _beneficiary ; emit SelfDestructBeneficiaryUpdated ( _beneficiary ) ; }
","Set the beneficiary address of this contract .
"
"function transferFeeIncurred ( uint value ) public view returns ( uint ) { return value . multiplyDecimal ( transferFeeRate ) ; }
","Calculate the Fee charged on top of a value being sent
"
"function getChannelIdentifier ( address participant , address partner ) view public returns ( uint256 ) { require ( participant != address ( 0x0 ) ) ; require ( partner != address ( 0x0 ) ) ; require ( participant != partner ) ; bytes32 pair_hash = getParticipantsHash ( participant , partner ) ; return participants_hash_to_channel_identifier [ pair_hash ] ; }
","Returns the unique identifier for the channel given by the contract .
"
"function getOrderPrice ( address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( uint orderPrice ) { return mul ( buyQuantity , 10 ** uint ( getDecimals ( sellAsset ) ) ) / sellQuantity ; }
","Gets price of Order
"
"function initialize ( address _permissionsCreator ) onlyInit public { initialized ( ) ; require ( msg . sender == address ( kernel ) ) ; _createPermission ( _permissionsCreator , this , CREATE_PERMISSIONS_ROLE , _permissionsCreator ) ; }
","Initializes an ACL instance and sets ` _permissionsCreator ` as the entity that can create other permissions
"
"function commitVote ( uint _pollID , bytes32 _secretHash , uint _numTokens , uint _prevPollID ) public { require ( commitPeriodActive ( _pollID ) ) ; if ( voteTokenBalance [ msg . sender ] < _numTokens ) { uint remainder = _numTokens . sub ( voteTokenBalance [ msg . sender ] ) ; requestVotingRights ( remainder ) ; } require ( voteTokenBalance [ msg . sender ] >= _numTokens ) ; require ( _pollID != 0 ) ; require ( _secretHash != 0 ) ; require ( _prevPollID == 0 || dllMap [ msg . sender ] . contains ( _prevPollID ) ) ; uint nextPollID = dllMap [ msg . sender ] . getNext ( _prevPollID ) ; if ( nextPollID == _pollID ) { nextPollID = dllMap [ msg . sender ] . getNext ( _pollID ) ; } require ( validPosition ( _prevPollID , nextPollID , msg . sender , _numTokens ) ) ; dllMap [ msg . sender ] . insert ( _prevPollID , _pollID , nextPollID ) ; bytes32 UUID = attrUUID ( msg . sender , _pollID ) ; store . setAttribute ( UUID , ""numTokens"" , _numTokens ) ; store . setAttribute ( UUID , ""commitHash"" , uint ( _secretHash ) ) ; pollMap [ _pollID ] . didCommit [ msg . sender ] = true ; emit _VoteCommitted ( _pollID , _numTokens , msg . sender ) ; }
","Commits vote using hash of choice and secret salt to conceal vote until reveal
"
"function fulfilled ( bytes32 _missionId , address _buyerId ) public { require ( identity . verifyOwnership ( _buyerId , msg . sender ) ) ; require ( missions [ _missionId ] . isSigned == false ) ; require ( missions [ _missionId ] . balance == missions [ _missionId ] . cost ) ; missions [ _missionId ] . isSigned = true ; missions [ _missionId ] . balance = 0 ; token . approve ( this , missions [ _missionId ] . cost ) ; token . transferFrom ( this , identity . getIdentityWallet ( missions [ _missionId ] . seller ) , missions [ _missionId ] . cost ) ; emit Signed ( _missionId ) ; }
","Fund a mission
"
"function launchContract ( ) onlyOwner returns ( bool launched ) { require ( ! contractLaunched ) ; tokenTransfersFrozen = false ; tokenMintingEnabled = true ; contractLaunched = true ; EnableTokenMinting ( true ) ; return true ; }
","Used to launch start the contract
"
"function _sellCrowd ( uint cst , address _to ) private { require ( cst >= crowdsaleMinUSD ) ; if ( crowdsaleSold . add ( cst ) <= crowdsaleSupply ) { crowdsaleSold = crowdsaleSold . add ( cst ) ; } else { presaleSold = presaleSold . add ( crowdsaleSold ) . add ( cst ) . sub ( crowdsaleSupply ) ; require ( presaleSold <= presaleSupply ) ; crowdsaleSold = crowdsaleSupply ; } if ( now < crowdsaleStartTime + 3 days ) { if ( whitemap [ _to ] >= cst ) { whitemap [ _to ] -= cst ; whitelistTokens -= cst ; } else { require ( crowdsaleSupply . add ( presaleSupply ) . sub ( presaleSold ) >= crowdsaleSold . add ( whitelistTokens ) ) ; } } }
","_sellCrowd checks CST purchases during crowdsale
"
"function withdraw ( uint256 amount ) public ;
","withdraws from a token holding assets
"
"function checkTransfer ( address from , uint tokens ) public view { uint newBalance = balances [ from ] . sub ( tokens ) ; uint total = 0 ; if ( now < unlockDate5 ) { require ( now >= unlockDate1 ) ; uint frzdPercent = 0 ; if ( now < unlockDate2 ) { frzdPercent = 80 ; } else if ( now < unlockDate3 ) { frzdPercent = 60 ; } else if ( now < unlockDate4 ) { frzdPercent = 40 ; } else { frzdPercent = 20 ; } total = freezed [ from ] . mul ( frzdPercent ) . div ( 100 ) ; require ( newBalance >= total ) ; } if ( now < teamUnlock4 && teamFreezed [ from ] > 0 ) { uint p = 0 ; if ( now < teamUnlock1 ) { p = 100 ; } else if ( now < teamUnlock2 ) { p = 75 ; } else if ( now < teamUnlock3 ) { p = 50 ; } else if ( now < teamUnlock4 ) { p = 25 ; } total = total . add ( teamFreezed [ from ] . mul ( p ) . div ( 100 ) ) ; require ( newBalance >= total ) ; } }
","this function is called for every transfer We unlock PURCHASED and BONUS tokens in 5 stages : after 28.09.2018 20 % are unlocked after 30.11.2018 40 % are unlocked after 31.01.2019 60 % are unlocked after 29.03.2019 80 % are unlocked after 31.05.2019 100 % are unlocked
"
"function shutDownVersion ( uint id ) pre_cond ( isActive ( id ) ) internal { VersionInterface Version = VersionInterface ( versions [ id ] . version ) ; Version . shutDown ( ) ; delete versions [ id ] ; VersionUpdated ( id ) ; }
","Remove and shut down version of Melon
"
"function withdraw ( address _darknode , ERC20 _token ) public { address darknodeOwner = darknodeRegistry . getDarknodeOwner ( address ( _darknode ) ) ; require ( darknodeOwner != 0x0 , ""invalid darknode owner"" ) ; uint256 value = darknodeBalances [ _darknode ] [ _token ] ; darknodeBalances [ _darknode ] [ _token ] = 0 ; if ( address ( _token ) == ETHEREUM ) { darknodeOwner . transfer ( value ) ; } else { CompatibleERC20 ( _token ) . safeTransfer ( darknodeOwner , value ) ; } }
","Withdraw fees earned by a Darknode .
"
"function updateSettings ( uint _ethAmount , uint _sntAmount , bytes32 _root ) public onlyController { ethAmount = _ethAmount ; sntAmount = _sntAmount ; root = _root ; }
","Update configuration settings
"
"function addAssetManager ( address _assetManager ) public onlyOwner { require ( address ( assetManager ) == 0x0 ) ; assetManager = IAssetManager ( _assetManager ) ; }
","Function to add assetManager
"
"function transferFrom ( address from , address to , uint256 tokens ) public returns ( bool success ) { requireTrade ( from ) ; balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; ensureInAccountList ( from ) ; ensureInAccountList ( to ) ; return true ; }
","Transfer ` tokens ` from the ` from ` account to the ` to ` account
"
"function _transferFromSenderPaysFee_byProxy ( address sender , address from , address to , uint value ) internal returns ( bool ) { uint fee = transferFeeIncurred ( value ) ; uint total = safeAdd ( value , fee ) ; tokenState . setAllowance ( from , sender , safeSub ( tokenState . allowance ( from , sender ) , total ) ) ; return _internalTransfer ( from , to , value , fee ) ; }
","Ability to transferFrom where they sender pays the fees ( not ERC20 ) .
"
"function getQueryPrice ( uint EthInCents , uint gasPriceInWei ) public view returns ( uint ) { uint256 oneEth = 1 ether ; uint256 oracalizeFee = oneEth . div ( EthInCents ) . div ( 98 ) ; uint256 gasCost = callbackGasLimit . mul ( gasPriceInWei ) ; return oracalizeFee + gasCost ; }
","calculates the ammount of ether to send with updatePrice
"
"function disablePrivileged ( ) external privilegedAllowed onlymanyowners ( keccak256 ( msg . data ) ) { require ( false == m_frozen ) ; m_allowPrivileged = false ; }
","Disables further use of privileged functions : setSale , thaw
"
"function highestBid ( ) public view returns ( uint ) { return ( bids [ highestBidder ] ) ; }
","Getter function for highestBid ` bids [ highestBidder ] `
"
"function sellTokens ( uint _tokenAmount , uint _from , uint _to ) returns ( uint ) { if ( ! transferable || uint ( balances [ msg . sender ] ) < _amount || numberOfOrders == 0 ) throw ; if ( _to == 0 || _to > numberOfOrders - 1 ) _to = numberOfOrders - 1 ; uint _tokenAmounto ; uint _amount ; uint _totalAmount ; uint o = _from ; for ( uint i = _from ; i <= _to ; i ++ ) { if ( _tokenAmount > 0 && orders [ o ] . buyer != msg . sender ) { _tokenAmounto = TokenAmount ( orders [ o ] . weiGiven , priceMultiplier ( 0 ) , actualPriceDivisor ( 0 ) ) ; if ( _tokenAmount >= _tokenAmounto && transferFromTo ( msg . sender , orders [ o ] . buyer , _tokenAmounto ) ) { _tokenAmount -= _tokenAmounto ; _totalAmount += orders [ o ] . weiGiven ; removeOrder ( o ) ; } else if ( _tokenAmount < _tokenAmounto && transferFromTo ( msg . sender , orders [ o ] . buyer , _tokenAmount ) ) { _amount = weiAmount ( _tokenAmount , priceMultiplier ( 0 ) , actualPriceDivisor ( 0 ) ) ; orders [ o ] . weiGiven -= _amount ; _totalAmount += _amount ; i = _to + 1 ; } else o += 1 ; } else o += 1 ; } if ( ! msg . sender . send ( _totalAmount ) ) throw ; else return _totalAmount ; }
","Function to sell tokens
"
"function burn ( uint256 _value ) public returns ( bool success ) { require ( _value > 0 ) ; require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; totalSupply = safeSub ( totalSupply , _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }
","Remove ` _value ` tokens from the system irreversibly
"
"function getFxUSDBPSRate ( Data storage self , string currency ) internal view returns ( uint bpsRate ) { bytes32 id = keccak256 ( abi . encodePacked ( 'fx.usd.rate' , currency ) ) ; return self . Storage . getUint ( id ) ; }
","Return the foreign currency USD exchanged amount in basis points
"
"function transferAdminship ( address _newAdmin ) onlyAdmin public { admin = _newAdmin ; emit TransferAdminship ( admin ) ; }
","This function transfer the adminship of the contract to _newAdmin
"
"function getPendingManager ( ) public view returns ( address ) ;
","Get pending address
"
"function addWhitelistAddress ( address investor ) public onlyOwner mustBeAtStage ( Stage . Finished ) { require ( investor != address ( 0 ) && investor != address ( this ) ) ; require ( isWhitelisted [ investor ] == false ) ; require ( balancesToken [ investor ] > 0 ) ; isWhitelisted [ investor ] = true ; }
","This is mainly an helper function but can be useful in case the ` addWhitelistAddrs ` loop has issues
"
"function changeAllowAllTransfers ( bool _allowAllTransfers ) public withPerm ( FLAGS ) { allowAllTransfers = _allowAllTransfers ; emit AllowAllTransfers ( _allowAllTransfers ) ; }
","Used to change the flag true - It refers there are no transfer restrictions , for any addresses false - It refers transfers are restricted for all addresses .
"
"function setEthealToken ( address _token , address _hodler ) public onlyOwner whenPaused { require ( _token != address ( 0 ) ) ; ethealToken = ERC20MiniMe ( _token ) ; if ( _hodler != address ( 0 ) ) { hodlerReward = Hodler ( _hodler ) ; } else if ( hodlerReward == address ( 0 ) ) { hodlerReward = new Hodler ( TOKEN_HODL_3M , TOKEN_HODL_6M , TOKEN_HODL_9M ) ; } if ( ethealToken . totalSupply ( ) == 0 ) { ethealToken . generateTokens ( SALE , TOKEN_SALE1_PRE . add ( TOKEN_SALE1_NORMAL ) . add ( TOKEN_SALE2 ) . add ( TOKEN_SALE3 ) ) ; ethealToken . generateTokens ( address ( hodlerReward ) , TOKEN_HODL_3M . add ( TOKEN_HODL_6M ) . add ( TOKEN_HODL_9M ) ) ; ethealToken . generateTokens ( owner , TOKEN_BOUNTY . add ( TOKEN_REFERRAL ) ) ; ethealToken . generateTokens ( address ( ethealMultisigWallet ) , TOKEN_COMMUNITY ) ; ethealToken . generateTokens ( address ( this ) , TOKEN_FOUNDERS . add ( TOKEN_TEAM ) ) ; ethealToken . generateTokens ( INVESTOR1 , TOKEN_INVESTORS . div ( 3 ) . mul ( 2 ) ) ; ethealToken . generateTokens ( INVESTOR2 , TOKEN_INVESTORS . div ( 3 ) ) ; } }
","set the token , if no hodler provided then creates a hodler reward contract
"
"function withdrawPoly ( uint256 _amount ) public onlyOwner { require ( ERC20 ( polyToken ) . transfer ( owner , _amount ) , ""In-sufficient balance"" ) ; }
","allows the owner to withdraw unspent POLY stored by them on the ST .
"
"function externalTokensRecovery ( ERC20Basic _address ) onlyAdmin ( 2 ) public { require ( state == State . Successful ) ; uint256 remainder = _address . balanceOf ( this ) ; _address . transfer ( msg . sender , remainder ) ; }
","Function to claim any token stuck on contract
"
"function isRegisteredInPreviousEpoch ( address _darknodeID ) public view returns ( bool ) { return isRegisteredInEpoch ( _darknodeID , previousEpoch ) ; }
","Returns if a darknode was in the registered state last epoch .
"
"function changeRecipient ( address _newRecipient ) onlyRecipient { recipient = _newRecipient ; }
","` onlyRecipient ` Reassigns the ` recipient ` to a new address
"
"function withdraw ( address asset , uint requestedAmount ) public returns ( uint ) { if ( paused ) { return fail ( Error . CONTRACT_PAUSED , FailureInfo . WITHDRAW_CONTRACT_PAUSED ) ; } Market storage market = markets [ asset ] ; Balance storage supplyBalance = supplyBalances [ msg . sender ] [ asset ] ; WithdrawLocalVars memory localResults ; Error err ; uint rateCalculationResultCode ; ( err , localResults . accountLiquidity , localResults . accountShortfall ) = calculateAccountLiquidity ( msg . sender ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED ) ; } ( err , localResults . newSupplyIndex ) = calculateInterestIndex ( market . supplyIndex , market . supplyRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED ) ; } ( err , localResults . userSupplyCurrent ) = calculateBalance ( supplyBalance . principal , supplyBalance . interestIndex , localResults . newSupplyIndex ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED ) ; } if ( requestedAmount == uint ( - 1 ) ) { ( err , localResults . withdrawCapacity ) = getAssetAmountForValue ( asset , localResults . accountLiquidity ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_CAPACITY_CALCULATION_FAILED ) ; } localResults . withdrawAmount = min ( localResults . withdrawCapacity , localResults . userSupplyCurrent ) ; } else { localResults . withdrawAmount = requestedAmount ; } localResults . currentCash = getCash ( asset ) ; ( err , localResults . updatedCash ) = sub ( localResults . currentCash , localResults . withdrawAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( Error . TOKEN_INSUFFICIENT_CASH , FailureInfo . WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE ) ; } ( err , localResults . userSupplyUpdated ) = sub ( localResults . userSupplyCurrent , localResults . withdrawAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( Error . INSUFFICIENT_BALANCE , FailureInfo . WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED ) ; } if ( ! isZeroExp ( localResults . accountShortfall ) ) { return fail ( Error . INSUFFICIENT_LIQUIDITY , FailureInfo . WITHDRAW_ACCOUNT_SHORTFALL_PRESENT ) ; } ( err , localResults . ethValueOfWithdrawal ) = getPriceForAssetAmount ( asset , localResults . withdrawAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED ) ; } if ( lessThanExp ( localResults . accountLiquidity , localResults . ethValueOfWithdrawal ) ) { return fail ( Error . INSUFFICIENT_LIQUIDITY , FailureInfo . WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL ) ; } ( err , localResults . newTotalSupply ) = addThenSub ( market . totalSupply , localResults . userSupplyUpdated , supplyBalance . principal ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newSupplyRateMantissa ) = market . interestRateModel . getSupplyRate ( asset , localResults . updatedCash , market . totalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } ( err , localResults . newBorrowIndex ) = calculateInterestIndex ( market . borrowIndex , market . borrowRateMantissa , market . blockNumber , getBlockNumber ( ) ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED ) ; } ( rateCalculationResultCode , localResults . newBorrowRateMantissa ) = market . interestRateModel . getBorrowRate ( asset , localResults . updatedCash , market . totalBorrows ) ; if ( rateCalculationResultCode != 0 ) { return failOpaque ( FailureInfo . WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED , rateCalculationResultCode ) ; } err = doTransferOut ( asset , msg . sender , localResults . withdrawAmount ) ; if ( err != Error . NO_ERROR ) { return fail ( err , FailureInfo . WITHDRAW_TRANSFER_OUT_FAILED ) ; } market . blockNumber = getBlockNumber ( ) ; market . totalSupply = localResults . newTotalSupply ; market . supplyRateMantissa = localResults . newSupplyRateMantissa ; market . supplyIndex = localResults . newSupplyIndex ; market . borrowRateMantissa = localResults . newBorrowRateMantissa ; market . borrowIndex = localResults . newBorrowIndex ; localResults . startingBalance = supplyBalance . principal ; supplyBalance . principal = localResults . userSupplyUpdated ; supplyBalance . interestIndex = localResults . newSupplyIndex ; emit SupplyWithdrawn ( msg . sender , asset , localResults . withdrawAmount , localResults . startingBalance , localResults . userSupplyUpdated ) ; return uint ( Error . NO_ERROR ) ; }
","withdraw ` amount ` of ` asset ` from sender 's account to sender 's address
"
